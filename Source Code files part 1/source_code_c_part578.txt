DeviceAddresses )
	{
		pdplConnectionSettings->ppdp8DeviceAddresses = new PDIRECTPLAY8ADDRESS[pdplSettings->cNumDeviceAddresses];

		if( !pdplConnectionSettings->ppdp8DeviceAddresses )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed allocating memory" );			
			goto INITIALIZE_FAILED;
		}

		for( DWORD dwIndex = 0; dwIndex < pdplSettings->cNumDeviceAddresses; dwIndex++ )
		{
			hr = IDirectPlay8Address_Duplicate( pdplSettings->ppdp8DeviceAddresses[dwIndex], &pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex] );

			if( FAILED( hr ) )
			{
	            DPFX(DPFPREP,  0, "Error duplicating host address hr [0x%x]", hr );
	            goto INITIALIZE_FAILED;
			}			
		}
	}
	
	if( pdplSettings->pwszPlayerName )
	{
		pdplConnectionSettings->pwszPlayerName = new WCHAR[wcslen(pdplSettings->pwszPlayerName)+1];

		if( !pdplConnectionSettings->pwszPlayerName )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );						
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		wcscpy( pdplConnectionSettings->pwszPlayerName, pdplSettings->pwszPlayerName  );
	}

	if( pdplSettings->dpnAppDesc.pwszSessionName )
	{
		pdplConnectionSettings->dpnAppDesc.pwszSessionName = new WCHAR[wcslen(pdplSettings->dpnAppDesc.pwszSessionName)+1];

		if( !pdplConnectionSettings->dpnAppDesc.pwszSessionName )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );						
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		wcscpy( pdplConnectionSettings->dpnAppDesc.pwszSessionName, pdplSettings->dpnAppDesc.pwszSessionName  );
	}

	if( pdplSettings->dpnAppDesc.pwszPassword )
	{
		pdplConnectionSettings->dpnAppDesc.pwszPassword = new WCHAR[wcslen(pdplSettings->dpnAppDesc.pwszPassword)+1];

		if( !pdplConnectionSettings->dpnAppDesc.pwszPassword )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );						
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		wcscpy( pdplConnectionSettings->dpnAppDesc.pwszPassword, pdplSettings->dpnAppDesc.pwszPassword  );
	}	

	if( pdplSettings->dpnAppDesc.pvReservedData )
	{
		pdplConnectionSettings->dpnAppDesc.pvReservedData = new BYTE[pdplSettings->dpnAppDesc.dwReservedDataSize];

		if( !pdplConnectionSettings->dpnAppDesc.pvReservedData )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );			
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		memcpy( pdplConnectionSettings->dpnAppDesc.pvReservedData, 
			    pdplSettings->dpnAppDesc.pvReservedData,
			    pdplSettings->dpnAppDesc.dwReservedDataSize );
	}		

	if( pdplSettings->dpnAppDesc.pvApplicationReservedData )
	{
		pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData = new BYTE[pdplSettings->dpnAppDesc.dwApplicationReservedDataSize];

		if( !pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );			
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		memcpy( pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, 
			    pdplSettings->dpnAppDesc.pvApplicationReservedData,
			    pdplSettings->dpnAppDesc.dwApplicationReservedDataSize );
	}			

	// Free the old structure if one exists.  
	if( m_fManaged )
	{
		m_fManaged = FALSE;		
	} 
	else if( m_pdplConnectionSettings )
	{
		FreeConnectionSettings( m_pdplConnectionSettings );		
	}

    m_pdplConnectionSettings = pdplConnectionSettings;

    return DPN_OK;	
	
INITIALIZE_FAILED:

	FreeConnectionSettings( pdplConnectionSettings );

	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::BuildWireStruct"
// BuildWireStruct
//
// This function fills the packed buffer with the wire representation of the
// connection settings structure.  
HRESULT CConnectionSettings::BuildWireStruct( CPackedBuffer *const pPackedBuffer )
{
	HRESULT hr = DPN_OK;
	DPL_INTERNAL_CONNECTION_SETTINGS *pdplConnectSettings = NULL;  
	WCHAR *wszTmpAddress = NULL;
	DWORD dwTmpStringSize = 0;
	UNALIGNED DWORD *pdwTmpOffsets = NULL;
	UNALIGNED DWORD *pdwTmpLengths = NULL;
 
	pdplConnectSettings = (DPL_INTERNAL_CONNECTION_SETTINGS *) pPackedBuffer->GetHeadAddress();	

	hr = pPackedBuffer->AddToFront( NULL, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS ) );

	if( hr == DPN_OK )
	{
	    ZeroMemory( pdplConnectSettings, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS ) );
	        
		//
		// COPY CORE FIXED VALUES
		//
		pdplConnectSettings->dwFlags = m_pdplConnectionSettings->dwFlags;
		pdplConnectSettings->dwNumDeviceAddresses = m_pdplConnectionSettings->cNumDeviceAddresses;

		//
		// COPY APPDESC FIXED VALUES
		//
		pdplConnectSettings->dpnApplicationDesc.dwSize = sizeof( DPN_APPLICATION_DESC_INFO );
		pdplConnectSettings->dpnApplicationDesc.dwFlags = m_pdplConnectionSettings->dpnAppDesc.dwFlags;
		pdplConnectSettings->dpnApplicationDesc.dwMaxPlayers = m_pdplConnectionSettings->dpnAppDesc.dwMaxPlayers;
		pdplConnectSettings->dpnApplicationDesc.dwCurrentPlayers = m_pdplConnectionSettings->dpnAppDesc.dwCurrentPlayers;
		pdplConnectSettings->dpnApplicationDesc.guidInstance = m_pdplConnectionSettings->dpnAppDesc.guidInstance;
		pdplConnectSettings->dpnApplicationDesc.guidApplication = m_pdplConnectionSettings->dpnAppDesc.guidApplication;		
	}

	// 
	// COPY VARIABLE CORE VALUES
	// 

	if( m_pdplConnectionSettings->pwszPlayerName )
	{
		hr = pPackedBuffer->AddWCHARStringToBack( m_pdplConnectionSettings->pwszPlayerName );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dwPlayerNameOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dwPlayerNameLength = 
				(wcslen( m_pdplConnectionSettings->pwszPlayerName )+1) * sizeof( WCHAR );
		}		
	}

	if( m_pdplConnectionSettings->pdp8HostAddress )
	{
		hr = IDirectPlay8Address_GetURLW( m_pdplConnectionSettings->pdp8HostAddress, NULL, &dwTmpStringSize );

		if( hr != DPNERR_BUFFERTOOSMALL )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}

		wszTmpAddress = new WCHAR[dwTmpStringSize];

		if( !wszTmpAddress )
		{
			hr = DPNERR_OUTOFMEMORY;
            DPFX(DPFPREP,  0, "Failed allocating memory" );				
            goto BUILDWIRESTRUCT_FAILURE;			
		}

		hr = IDirectPlay8Address_GetURLW( m_pdplConnectionSettings->pdp8HostAddress, wszTmpAddress, &dwTmpStringSize );

		if( FAILED( hr ) )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}
		
		hr = pPackedBuffer->AddWCHARStringToBack( wszTmpAddress );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dwHostAddressOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dwHostAddressLength = 
				(wcslen( wszTmpAddress )+1) * sizeof( WCHAR );
		}	

		delete [] wszTmpAddress;
		wszTmpAddress = NULL;		
			
	}

	hr = pPackedBuffer->AddToBack( NULL, sizeof( DWORD ) * m_pdplConnectionSettings->cNumDeviceAddresses );

	if( hr == DPN_OK && pdplConnectSettings )
	{
		pdwTmpOffsets = (DWORD *) pPackedBuffer->GetTailAddress();
		pdplConnectSettings->dwDeviceAddressOffset = pPackedBuffer->GetTailOffset();
	}

	hr = pPackedBuffer->AddToBack( NULL, sizeof( DWORD ) * m_pdplConnectionSettings->cNumDeviceAddresses );

	if( hr == DPN_OK && pdplConnectSettings )
	{
		pdwTmpLengths = (DWORD *) pPackedBuffer->GetTailAddress();
		pdplConnectSettings->dwDeviceAddressLengthOffset = pPackedBuffer->GetTailOffset();		
	}	

	DWORD dwIndex;
	for( dwIndex = 0; dwIndex < m_pdplConnectionSettings->cNumDeviceAddresses; dwIndex++ )
	{
		dwTmpStringSize = 0;
		
		hr = IDirectPlay8Address_GetURLW( 
				m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex], 
				NULL, &dwTmpStringSize );

		if( hr != DPNERR_BUFFERTOOSMALL )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}

		wszTmpAddress = new WCHAR[dwTmpStringSize];

		if( !wszTmpAddress )
		{
			hr = DPNERR_OUTOFMEMORY;
            DPFX(DPFPREP,  0, "Failed allocating memory" );				
            goto BUILDWIRESTRUCT_FAILURE;			
		}

		hr = IDirectPlay8Address_GetURLW( 
				m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex], 
				wszTmpAddress, &dwTmpStringSize );

		if( FAILED( hr ) )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}
		
		hr = pPackedBuffer->AddWCHARStringToBack( wszTmpAddress );

		if( hr == DPN_OK && pdplConnectSettings && pdwTmpLengths )
		{
			pdwTmpOffsets[dwIndex] = pPackedBuffer->GetTailOffset();
			pdwTmpLengths[dwIndex] = (wcslen( wszTmpAddress )+1) * sizeof( WCHAR );
		}	

		delete [] wszTmpAddress;
		wszTmpAddress = NULL;		
	}

	//
	// COPY APP DESC VARIABLE MEMBERS
	//
	
	if( m_pdplConnectionSettings->dpnAppDesc.pwszPassword )
	{
		hr = pPackedBuffer->AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszPassword );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwPasswordOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwPasswordSize = 
				(wcslen( m_pdplConnectionSettings->dpnAppDesc.pwszPassword )+1) * sizeof( WCHAR );
		}
	}

	if( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName)
	{
		hr = pPackedBuffer->AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwSessionNameOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwSessionNameSize = 
				(wcslen( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName )+1) * sizeof( WCHAR );
		}
	}	

	if( m_pdplConnectionSettings->dpnAppDesc.pvReservedData )
	{
		hr = pPackedBuffer->AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvReservedData, 
									   m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwReservedDataOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwReservedDataSize = m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize;
		}
	}		

	if( m_pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData)
	{
		hr = pPackedBuffer->AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, 
									   m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize);

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwApplicationReservedDataOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwApplicationReservedDataSize = m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize;
		}
	}			

BUILDWIRESTRUCT_FAILURE:

	if( wszTmpAddress )
		delete [] wszTmpAddress;

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::SetEqual"
// SetEqual 
//
// This function provides a deep copy of the specified class into this object
HRESULT CConnectionSettings::SetEqual( CConnectionSettings * pdplSettings )
{
	PDPL_CONNECTION_SETTINGS pConnectSettings = pdplSettings->GetConnectionSettings();

	if( pConnectSettings == NULL )
	{
	    DPFX(DPFPREP,  0, "Error getting settings -- no settings available!" );
	    return DPNERR_DOESNOTEXIST;
	}

	return Initialize( pConnectSettings );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::CopyToBuffer( BYTE *pbBuffer, DWORD *pdwBufferSize )"
HRESULT CConnectionSettings::CopyToBuffer( BYTE *pbBuffer, DWORD *pdwBufferSize )
{
    if( m_pdplConnectionSettings == NULL )
    {
        *pdwBufferSize = 0;
        return DPNERR_DOESNOTEXIST;
    }

    CPackedBuffer packBuff;
    HRESULT hr = DPN_OK;
    DPL_CONNECTION_SETTINGS *pConnectionSettings = NULL;

    packBuff.Initialize( pbBuffer, *pdwBufferSize, TRUE );

   	pConnectionSettings = (DPL_CONNECTION_SETTINGS *) packBuff.GetHeadAddress();

    hr = packBuff.AddToFront( m_pdplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ), TRUE );

    if( FAILED( hr ) )
    {
    	pConnectionSettings = NULL;	
    }

    // Add app desc's session name if there is one
    if( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName != NULL )
    {
        hr = packBuff.AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName, TRUE );
        
        if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pwszSessionName = (WCHAR *) packBuff.GetTailAddress();
    }

    // Copy player name
    if( m_pdplConnectionSettings->pwszPlayerName != NULL )
    {
        hr = packBuff.AddWCHARStringToBack( m_pdplConnectionSettings->pwszPlayerName, TRUE );
        
        if( pConnectionSettings )
			pConnectionSettings->pwszPlayerName = (WCHAR *) packBuff.GetTailAddress();
    }

    // Copy password
    if( m_pdplConnectionSettings->dpnAppDesc.pwszPassword )
    {
        hr = packBuff.AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszPassword, TRUE );

        if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pwszPassword = (WCHAR *) packBuff.GetTailAddress();
    }

    if( m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize )
    {
        hr = packBuff.AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvReservedData, m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize, TRUE );
		if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pvReservedData = (WCHAR *)  packBuff.GetTailAddress();
    }

    if( m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize )
    {
        hr = packBuff.AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize, TRUE );

        if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pvApplicationReservedData = (WCHAR *)  packBuff.GetTailAddress();
    }

    hr = packBuff.AddToBack( m_pdplConnectionSettings->ppdp8DeviceAddresses, sizeof( IDirectPlay8Address * )*m_pdplConnectionSettings->cNumDeviceAddresses, TRUE );
    
    if( pConnectionSettings )
	    pConnectionSettings->ppdp8DeviceAddresses = (IDirectPlay8Address **) packBuff.GetTailAddress();

	if( pConnectionSettings )
	{
	    if( m_pdplConnectionSettings->pdp8HostAddress != NULL )
		{
			hr = IDirectPlay8Address_Duplicate( m_pdplConnectionSettings->pdp8HostAddress, &pConnectionSettings->pdp8HostAddress );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error duplicating host address hr [0x%x]", hr );
				goto INITIALIZE_COMPLETE;
			}			
		}

	    for( DWORD dwIndex = 0; dwIndex < m_pdplConnectionSettings->cNumDeviceAddresses; dwIndex++ )
	    {
			hr = IDirectPlay8Address_Duplicate( m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex], &pConnectionSettings->ppdp8DeviceAddresses[dwIndex] );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error duplicating device address hr [0x%x]", hr );
				goto INITIALIZE_COMPLETE;
			}						
	    }
	}

INITIALIZE_COMPLETE:

	*pdwBufferSize = packBuff.GetSizeRequired();
	
    return hr;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplconset.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConset.h
 *  Content:    DirectPlay Lobby Connection Settings Utility Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/13/00   rmt		Created
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPLCONSET_H__
#define	__DPLCONSET_H__

typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS DPL_INTERNAL_CONNECTION_SETTINGS;


#define DPLSIGNATURE_LOBBYCONSET			'BSCL'
#define DPLSIGNATURE_LOBBYCONSET_FREE		'BSC_'

// CConnectionSettings
//
// This class is responsible for managing connection settings data.  
//
class CConnectionSettings
{
public:
	CConnectionSettings( );
	~CConnectionSettings();

	// Initialize (DPL_CONNECTION_SETTINGS version)
	//
	// This function tells this class to take the specified connection settings and 
	// work with it.  
	//
	HRESULT Initialize( DPL_CONNECTION_SETTINGS * pdplSettings );

	// Initialize (Wire Version)
	//
	// THis function initializes this object to contain a connection settings structure
	// that mirrors the values of the wire message.  
	HRESULT Initialize( UNALIGNED DPL_INTERNAL_CONNECTION_SETTINGS *pdplSettingsMsg, UNALIGNED BYTE * pbBufferStart );

	// InitializeAndCopy
	//
	// This function initializes this class to contain a copy of the specified 
	// connection settings structure.
	HRESULT InitializeAndCopy( const DPL_CONNECTION_SETTINGS * const pdplSettings );

	// SetEqual 
	//
	// This function provides a deep copy of the specified class into this object
	HRESULT SetEqual( CConnectionSettings * pdplSettings );	

	// CopyToBuffer
	//
	// This function copies the contents of the connection settings to the specified
	// buffer (if it fits).
	// 
	HRESULT CopyToBuffer( BYTE *pbBuffer, DWORD *pdwBufferSize ); 
	
	// BuildWireStruct
	//
	// This function fills the packed buffer with the wire representation of the
	// connection settings structure.  
	HRESULT BuildWireStruct( CPackedBuffer * pPackedBuffer );

	PDPL_CONNECTION_SETTINGS GetConnectionSettings() { return m_pdplConnectionSettings; };

protected:

	void Lock() { DNEnterCriticalSection( &m_csLock ); };
	void UnLock() { DNLeaveCriticalSection( &m_csLock ); };

	static void FreeConnectionSettings( DPL_CONNECTION_SETTINGS *pConnectionSettings );

	DWORD m_dwSignature;
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION m_csLock;
#endif // !DPNBUILD_ONLYONETHREAD
	BOOL m_fManaged;  
	DPL_CONNECTION_SETTINGS *m_pdplConnectionSettings;
	BOOL m_fCritSecInited;
};

#endif // __DPLCONSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplglobals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 20000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    DirectNet Lobby Global Variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"

//
//	Global Variables
//

#ifndef DPNBUILD_LIBINTERFACE
LONG	g_lLobbyObjectCount = 0;
#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dpldllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DllMain.cpp
 *  Content:    Defines the entry point for the DLL application.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/2000	mjn		Created
 *   06/07/2000	rmt		Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *   06/15/2000	rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances 
 *   07/21/2000	RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *   08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process 
 *   08/30/2000	rmt		Whistler Bug #171824 - PREFIX Bug
 *   04/12/2001	VanceO	Moved granting registry permissions into common.
 *   06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored).
 *						- Removed permission modifications from lobby self-registration -- no longer needed.  
 *   06/19/2001 RichGr  DX8.0 added special security rights for "everyone" - remove them if they exist.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"

#ifndef DPNBUILD_LIBINTERFACE
// Globals
extern	LONG	g_lLobbyObjectCount;
#endif // ! DPNBUILD_LIBINTERFACE

DEBUG_ONLY(BOOL g_fLobbyObjectInited = FALSE);

#define DNOSINDIR_INITED	0x00000001
#define DNCOM_INITED		0x00000002

#undef DPF_MODNAME
#define DPF_MODNAME "DNLobbyInit"
BOOL DNLobbyInit(HANDLE hModule)
{
	DWORD dwInitFlags = 0;

#ifdef DBG
	DNASSERT(!g_fLobbyObjectInited);
#endif // DBG

	DEBUG_ONLY(g_fLobbyObjectInited = TRUE);

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNLobbyDeInit"
void DNLobbyDeInit()
{
#ifdef DBG
	DNASSERT(g_fLobbyObjectInited);
#endif // DBG

	DPFX(DPFPREP, 5, "Deinitializing Lobby");

	DEBUG_ONLY(g_fLobbyObjectInited = FALSE);
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DNLobbyRegister"
BOOL DNLobbyRegister(LPCWSTR wszDLLName)
{
	if( !CRegistry::Register( L"DirectPlay8Lobby.LobbyClient.1", L"DirectPlay8LobbyClient Object", 
							  wszDLLName, &CLSID_DirectPlay8LobbyClient, L"DirectPlay8Lobby.LobbyClient") )
	{
		DPFERR( "Could not register lobby client object" );
		return FALSE;
	}

	if( !CRegistry::Register( L"DirectPlay8Lobby.LobbiedApplication.1", L"DirectPlay8LobbiedApplication Object", 
							  wszDLLName, &CLSID_DirectPlay8LobbiedApplication, L"DirectPlay8Lobby.LobbiedApplication") )
	{
		DPFERR( "Could not register lobby client object" );
		return FALSE;
	}

	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPL_REG_LOCAL_APPL_ROOT DPL_REG_LOCAL_APPL_SUB, FALSE, TRUE ) )
	{
		DPFERR( "Could not create app subkey" );
		return FALSE;
	}
	// Adjust security permissions of the given key
	else
	{
#ifdef WINNT
		// 6/19/01: DX8.0 added special security rights for "everyone" - remove them.
		if( !creg.RemoveAllAccessSecurityPermissions() )
		{
			DPFX(DPFPREP,  0, "Error removing security permissions for app key" );
		}
#endif // WINNT
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNLobbyUnRegister"
BOOL DNLobbyUnRegister()
{
	BOOL fReturn = TRUE;

	if( !CRegistry::UnRegister(&CLSID_DirectPlay8LobbyClient) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister client object" );
		fReturn = FALSE;
	}

	if( !CRegistry::UnRegister(&CLSID_DirectPlay8LobbiedApplication) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister app object" );
		fReturn = FALSE;
	}

	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPL_REG_LOCAL_APPL_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove app, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPL_REG_LOCAL_APPL_SUB)[1] ) )
		{
			DPFERR( "Cannot remove cp sub-key, could have elements" );
		}
	}

	return fReturn;
}

#endif // !DPNBUILD_NOCOMREGISTER


#ifndef DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "DNLobbyGetRemainingObjectCount"
DWORD DNLobbyGetRemainingObjectCount()
{
	return g_lLobbyObjectCount;
}

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplconnect.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConnect.h
 *  Content:    DirectPlay Lobby Connections Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLCONNECT_H__
#define	__DPLCONNECT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CMessageQueue;
class CConnectionSettings;

typedef struct _DPL_CONNECTION 
{
	CBilink			m_blLobbyObjectLinkage;

	DPNHANDLE		hConnect;
	DWORD			dwTargetProcessIdentity;
	DNHANDLE		hTargetProcess;
	DNHANDLE		hConnectEvent;
	LONG			lRefCount;
	CMessageQueue	*pSendQueue;
	CConnectionSettings *pConnectionSettings;
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION csLock;
#endif // !DPNBUILD_ONLYONETHREAD
	PVOID			pvConnectContext;
} DPL_CONNECTION,  *PDPL_CONNECTION;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DPLConnectionNew(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE *const phConnect,
						 DPL_CONNECTION **const ppdnConnection);

HRESULT DPLConnectionSetConnectSettings( DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE const phConnect, 
						 CConnectionSettings * pdplConnectSettings );

HRESULT DPLConnectionGetConnectSettings( DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE const phConnect, 
						 DPL_CONNECTION_SETTINGS * const pdplConnectSettings,
						 DWORD * const pdwDataSize );						 

HRESULT DPLConnectionRelease(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect);

HRESULT DPLConnectionFind(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  const DPNHANDLE hConnect,
						  DPL_CONNECTION **const ppdnConnection,
						  const BOOL bAddRef);

HRESULT DPLConnectionConnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwProcessId,
							 const BOOL fApplication );

HRESULT DPLConnectionDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnect );

HRESULT DPLConnectionEnum(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  DPNHANDLE *const prghConnect,
						  DWORD *const pdwNum);

HRESULT DPLConnectionSendREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwPID,
							 DPL_CONNECT_INFO *const pInfo);

HRESULT DPLConnectionReceiveREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								BYTE *const pBuffer);

HRESULT DPLConnectionSendACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect);

HRESULT DPLConnectionReceiveACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hSender,
								BYTE *const pBuffer);

HRESULT DPLConnectionReceiveDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
									   const DPNHANDLE hSender,
									   BYTE *const pBuffer,
									   const HRESULT hrDisconnectReason );

HRESULT DPLConnectionSetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID pvConnectContext );

HRESULT DPLConnectionGetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID *ppvConnectContext );


#endif	// __DPLCONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplobby8int.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLobbyInt.h
 *  Content:    DirectPlay Lobby Internal Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   04/18/2000 rmt     Added object param validation flag
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *				rmt		Added signature bytes
 *   02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *   06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored). 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPLOBBYINT_H__
#define	__DPLOBBYINT_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

#ifndef DPNBUILD_NOPARAMVAL
#define TRY 			_try
#define EXCEPT(a)		_except( a )
#endif // !DPNBUILD_NOPARAMVAL

#define	BREAKPOINT		_asm	{ int 3 }

#define DPL_MSGQ_TIMEOUT_IDLE                   1000

#define	DPL_OBJECT_FLAG_LOBBIEDAPPLICATION		0x0001
#define	DPL_OBJECT_FLAG_LOBBYCLIENT				0x0002
#define DPL_OBJECT_FLAG_PARAMVALIDATION         0x0004
#define DPL_OBJECT_FLAG_MULTICONNECT            0x0008
#define DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH	0x0010

#define DPL_OBJECT_FLAG_HANDLETABLE_INITED		0x0020
#define DPL_OBJECT_FLAG_CRITSEC_INITED			0x0040


#define DPL_ID_STR								_T("DPLID=")
#define DPL_ID_STR_W							L"DPLID="

#define DPL_NUM_APP_HANDLES						16

#define DPL_REGISTRY_READ_ACCESS 				(READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS)

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// Forward declarations

class CMessageQueue;

#define DPLSIGNATURE_LOBBYOBJECT			'BOLL'
#define DPLSIGNATURE_LOBBYOBJECT_FREE		'BOL_'

typedef struct _DIRECTPLAYLOBBYOBJECT
{
	DWORD					dwSignature;			// Signature
	PVOID					pvUserContext;
	DWORD					dwFlags;
	DWORD					dwPID;					// PID of this process
	CMessageQueue			*pReceiveQueue;
	PFNDPNMESSAGEHANDLER	pfnMessageHandler;
	DNHANDLE				hReceiveThread;			// Handle to receive Msg Handler thread
	DNHANDLE				hConnectEvent;			// Connection Event
	DNHANDLE				hLobbyLaunchConnectEvent; // Set if a lobby launch connection was succesful
	LONG					lLaunchCount;			// Number of application launches
	DPNHANDLE				dpnhLaunchedConnection;	// Launched connection

	CHandleTable			m_HandleTable;
	CBilink					m_blConnections;
	DWORD					m_dwConnectionCount;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION		m_cs;
#endif // !DPNBUILD_ONLYONETHREAD

} DIRECTPLAYLOBBYOBJECT, *PDIRECTPLAYLOBBYOBJECT;


typedef struct _DPL_SHARED_CONNECT_BLOCK
{
	DWORD	dwPID;
} DPL_SHARED_CONNECT_BLOCK, *PDPL_SHARED_CONNECT_BLOCK;


//**********************************************************************
// Variable definitions
//**********************************************************************


//extern DWORD	DnOsPlatformId;


//**********************************************************************
// Function prototypes
//**********************************************************************


#endif  // __DPLOBBYINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplmsgq.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLMsgQ.h
 *  Content:    DirectPlay Lobby Message Queues Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *	04/26/00	mjn		Fixed AddData() to return HRESULT
 *  07/07/2000	rmt		
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLMSGQ_H__
#define	__DPLMSGQ_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
//	Message Queue Object IDs
//
#define DPL_MSGQ_OBJECT_IDCHAR_FILEMAP		_T('F')
#define DPL_MSGQ_OBJECT_IDCHAR_MUTEX		_T('M')
#define DPL_MSGQ_OBJECT_IDCHAR_EVENT		_T('E')
#define DPL_MSGQ_OBJECT_IDCHAR_EVENT2		_T('V')
#define DPL_MSGQ_OBJECT_IDCHAR_SEMAPHORE	_T('S')

//
//	Message Queue Object Suffixes
//
#define	DPL_MSGQ_OBJECT_SUFFIX_CLIENT		_T('C')
#define	DPL_MSGQ_OBJECT_SUFFIX_APPLICATION	_T('A')

//
//	Message Queue Flags
//
#define	DPL_MSGQ_FLAG_AVAILABLE				0x00001
#define	DPL_MSGQ_FLAG_RECEIVING				0x00010

#define DPL_MSGQ_OPEN_FLAG_NO_CREATE		0x10000

//
//	Message Queue File Size
//
// Increased so user can send a 64K message
#define DPL_MSGQ_SIZE						0x010030

//
//	Internal Message IDs
//
#define	DPL_MSGQ_MSGID_SEND					0x0001
#define	DPL_MSGQ_MSGID_TERMINATE			0x0003
#define DPL_MSGQ_MSGID_IDLE                 0x0004

#define DPL_MSGQ_MSGFLAGS_QUEUESYSTEM		0x0001
#define DPL_MSGQ_MSGFLAGS_USER1				0x0002
#define DPL_MSGQ_MSGFLAGS_USER2				0x0004

#define	DPL_MSGQ_SIGNATURE					'QMLD'

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_LOBBY

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack(push,4)
//
//	Message Queue File Map Info
//
typedef struct _DPL_MSGQ_INFO
{
	DWORD	dwFlags;			// Queue usage flags
	DWORD	dwStartOffset;
	DWORD	dwEndOffset;
	DWORD	dwFreeBytes;
	DWORD	dwQueueSize;
	LONG	lRefCount;			// Number of connections
} DPL_MSGQ_INFO, *PDPL_MSGQ_INFO;


//
//	Message Queue Send Message
//
typedef	struct _DPL_MSGQ_SEND
{
	DWORD		dwCurrentSize;		// Size of this frame (in BYTES)
	DWORD		dwTotalSize;		// Total size of message
	DWORD		dwMsgId;			// Message ID
	DPNHANDLE	hSender;
	DWORD		dwFlags;
	DWORD		dwCurrentOffset;	// Offset of this frame in message
} DPL_MSGQ_HEADER, *PDPL_MSGQ_HEADER;

//
//	Message Queue Terminate Message
//
typedef struct _DPL_MSGQ_TERMINATE
{
	DWORD	dwMsgId;
} DPL_MSGQ_TERMINATE, *PDPL_MSGQ_TERMINATE;

#pragma pack(pop)

//
//	Message Handler Callback
//
typedef HRESULT (*PFNDPLMSGQMESSAGEHANDLER)(PVOID,const DPNHANDLE,DWORD, BYTE *const,const DWORD);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	DPLIsApplicationAvailable(const DWORD dwPid);
HRESULT	DPLMakeApplicationUnavailable(const DWORD dwPid);
DWORD WINAPI DPLProcessMessageQueue(PVOID pvReceiveQueue);

//**********************************************************************
// Class prototypes
//**********************************************************************

class CMessageQueue
{
public:
	CMessageQueue()
		{
			m_dwPID = 0;
			m_hFileMap = NULL;
			m_hEvent = NULL;
			m_hMutex = NULL;
			m_hSemaphore = NULL;
			m_pFileMapAddress = NULL;
			m_pInfo = NULL;
			m_pvContext = NULL;
			m_pfnMessageHandler = NULL;
			m_hSender = 0xFFFFFFFF;
			m_hReceiveThreadRunningEvent = NULL;
			m_dwIdleTimeout = INFINITE;
		};

//	~CMessageQueue() { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::SetMessageHandler"
	void CMessageQueue::SetMessageHandler(PVOID pvContext,PFNDPLMSGQMESSAGEHANDLER pfn )
		{
			DNASSERT(pfn != NULL);

			m_pvContext = pvContext;
			m_pfnMessageHandler = pfn;
		};

	void CMessageQueue::SetSenderHandle(DPNHANDLE hSender)
		{
			m_hSender = hSender;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::CallMessageHandler"
	HRESULT CMessageQueue::CallMessageHandler(const DPNHANDLE hSender,
											  DWORD dwMessageFlags, 
											  BYTE *const pBuffer,
											  const DWORD dwBufferSize)
		{
			DNASSERT(m_pfnMessageHandler != NULL);

			return((m_pfnMessageHandler)(m_pvContext,hSender,dwMessageFlags,pBuffer,dwBufferSize));
		};

	HRESULT CMessageQueue::Open(const DWORD dwPID,
								const TCHAR cSuffix,
								const DWORD dwQueueSize,
								const DWORD dwIdleTimeout,
								const DWORD dwFlags
                                 );

	void CMessageQueue::Close(void);

	LONG CMessageQueue::GetRefCount(void)
		{
			DWORD	lRefCount;

			if (m_pInfo == NULL)
				return(0);

			Lock();
			lRefCount = m_pInfo->lRefCount;
			Unlock();

			return(lRefCount);
		};

	HRESULT CMessageQueue::AddData(BYTE *const pBuffer,
								   const DWORD dwSize);


	HRESULT CMessageQueue::Send(BYTE *const pBuffer,
								const DWORD dwSize,
								const DWORD dwTimeOut,
								const DWORD dwMessageFlags,
								const DWORD dwFlags);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::Lock"
	void CMessageQueue::Lock(void)
		{
			DNASSERT(m_hMutex != NULL);
			DNWaitForSingleObject(m_hMutex,INFINITE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::Unlock"
	void CMessageQueue::Unlock(void)
		{
			DNASSERT(m_hMutex != NULL);
			DNReleaseMutex(m_hMutex);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::WaitForMessages"
	DWORD CMessageQueue::WaitForMessages(void)
		{
			DNASSERT(m_hSemaphore != NULL);
			return DNWaitForSingleObject(m_hSemaphore,m_dwIdleTimeout);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IndicateMessage"
	void CMessageQueue::IndicateMessage(void)
		{
			DNASSERT(m_hSemaphore != NULL);
			DNReleaseSemaphore(m_hSemaphore,1,NULL);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::WaitForConsumption"
	BOOL CMessageQueue::WaitForConsumption(const DWORD dwTimeOut)
		{
			DWORD	dwError;

			DNASSERT(m_hEvent != NULL);
			dwError = DNWaitForSingleObject(m_hEvent,dwTimeOut);
			if (dwError==WAIT_OBJECT_0)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IndicateConsumption"
	void CMessageQueue::IndicateConsumption(void)
		{
			DNASSERT(m_hEvent != NULL);
			//DNSetEvent(m_hEvent);		// Will auto-reset (i.e. pulse)

			DNReleaseSemaphore( m_hEvent, 1, NULL );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeAvailable"
	void CMessageQueue::MakeAvailable(void)
		{
			DNASSERT(m_pInfo != NULL);

			Lock();

			m_pInfo->dwFlags |= DPL_MSGQ_FLAG_AVAILABLE;

			Unlock();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeUnavailable"
	HRESULT CMessageQueue::MakeUnavailable(void)
		{

			HRESULT		hResultCode;

			DNASSERT(m_pInfo != NULL);

			Lock();

			if (m_pInfo->dwFlags & DPL_MSGQ_FLAG_AVAILABLE)
			{
				m_pInfo->dwFlags &= (~DPL_MSGQ_FLAG_AVAILABLE);
				hResultCode = DPN_OK;
			}
			else
			{
				hResultCode = DPNERR_ALREADYCONNECTED;
			}

			Unlock();

			return(hResultCode);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeReceiving"
	void CMessageQueue::MakeReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			Lock();
			m_pInfo->dwFlags |= DPL_MSGQ_FLAG_RECEIVING;
			Unlock();
			DNSetEvent(m_hReceiveThreadRunningEvent);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeNotReceiving"
	void CMessageQueue::MakeNotReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			DNResetEvent(m_hReceiveThreadRunningEvent);
			Lock();
			m_pInfo->dwFlags &= (~DPL_MSGQ_FLAG_RECEIVING);
			Unlock();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::WaitForReceiveThread"
	BOOL CMessageQueue::WaitForReceiveThread(const DWORD dwTimeOut)
		{
			DWORD	dwError;

			DNASSERT(m_hEvent != NULL);
			dwError = DNWaitForSingleObject(m_hReceiveThreadRunningEvent,dwTimeOut);
			if (dwError==WAIT_OBJECT_0)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IsOpen"
	BOOL CMessageQueue::IsOpen(void) const
		{
			if (m_hFileMap!= NULL)	return(TRUE);
			else					return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IsAvailable"
	BOOL CMessageQueue::IsAvailable(void) const
		{
			DNASSERT(m_pInfo != NULL);

			if (m_pInfo->dwFlags & DPL_MSGQ_FLAG_AVAILABLE)
				return(TRUE);
			else
				return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IsReceiving"
	BOOL CMessageQueue::IsReceiving(void) const
		{
			DNASSERT(m_pInfo != NULL);

			if (m_pInfo->dwFlags & DPL_MSGQ_FLAG_RECEIVING)
				return(TRUE);
			else
				return(FALSE);
		};

	HRESULT GetNextMessage( PDPL_MSGQ_HEADER pMsgHeader, PBYTE pbPayload, DWORD *pdwBufferSize );
	
/*
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::Realign"
	void CMessageQueue::Realign(void)
		{
			DNASSERT(m_pInfo != NULL);

			m_pInfo->dwFirstMsgOffset = 0;
			m_pInfo->dwFreeSpaceAtEnd = m_pInfo->dwTotalUsableSpace
					- (m_pInfo->dwNextFreeOffset - m_pInfo->dwFirstMsgOffset);
			m_pInfo->dwTotalFreeSpace = m_pInfo->dwFreeSpaceAtEnd;

		};*/

	void CMessageQueue::Terminate(void); 


private:

	// GetData
	//
	// Get dwSize bytes from the queue.  If the queue is empty this function will return
	// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
	//
	// Needs LOCK()
	//
	HRESULT GetData( BYTE *pbData, DWORD dwSize );

	// Consume
	//
	// Marks dwSize bytes as consumed
	//
	// Needs LOCK()
	void Consume( const DWORD dwSize );

	DWORD			m_dwSig;			// Signature (ensure initialized)
	DWORD			m_dwPID;			// Queue PID
	PBYTE			m_pFileMapAddress;	// File Mapping address
	DPL_MSGQ_INFO	*m_pInfo;			// Message queue file mapping info
	PBYTE			m_pData;			// Message data starts here 

	DNHANDLE	m_hReceiveThreadRunningEvent;

	//	Notes:
	//		Each message queue has four shared memory items: file map, mutex, event, semaphore.
	//		The file map is a circular queue of messages.
	//		The mutex controls access to the file map.
	//		The event signals when an item has been taken off the queue by the consumer.
	//		The semaphore indicates to the consumer that there are messages in the queue

	DNHANDLE	m_hFileMap;			// File Mapping handle
	DNHANDLE	m_hMutex;			// Mutex handle
	DNHANDLE	m_hEvent;			// Event handle
	DNHANDLE	m_hSemaphore;		// Semaphore handle

	PFNDPLMSGQMESSAGEHANDLER	m_pfnMessageHandler;
	PVOID						m_pvContext;

	DPNHANDLE	m_hSender;	// For all SEND messages

	DWORD   m_dwIdleTimeout;   // Amount of time between idle messages
};

#undef DPF_MODNAME

#endif	// __DPLMSGQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplmsgq.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLMsgQ.cpp
 *  Content:    DirectPlay Lobby Message Queues
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *	04/26/00	mjn		Fixed AddData() to return HRESULT
 *  07/06/00	rmt		Bug #38111 - Fixed prefix bug
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *	07/21/2000	rmt		Removed assert which wasn't needed
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/31/2000	rmt		Bug #171831, 131832 (Prefix Bugs)
 *  01/31/2001	rmt		WINBUG #295562 IDirectPlay8LobbyClient: SetConnectionSettings not sending DPL_CONNECTION_SETTINGS message to App
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//	DirectPlay Lobby Message Queues
//
//	We will use shared memory circular message buffers to implement this.
//	Each MsgQ has a set of synchronization objects to control access to the MsgQs.
//	The head of the shared memory file contains state information about the MsgQ:
//		pStartAddress
//		dwTotalUsableSpace
//		dwFirstMsgOffset
//		dwNextFreeOffset
//		dwFreeSpaceAtEnd
//		dwTotalFreeSpace
//	Messages are DWORD aligned in the MsgQ.
//	Each message in the MsgQ has a header:
//		dwMsgId
//		dwCurrentOffset
//		dwCurrentSize
//		dwTotalSize
//	Messages which fit in one frame have dwCurrentSize = dwTotalSize and dwCurrentOffset = 0.
//	Messages over multiple frames have dwCurrentSize < dwTotalSize.


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
//	CMessageQueue::Open
//
//	Entry:	const DWORD		dwPID			Id associated with this queue (user supplied)
//			const CHAR		cSuffix			Suffix character associated with this Q (user supp.)
//			const DWORD		dwQueueSize		Size of file map to use when implementing msg queue
//          const DWORD     dwIdleTimeout   Amount of time between idle messages == INFINITE to disable idle
//			const DWORD		dwFlags			TBA
//      
//
//	Exit:		HRESULT:	DPN_OK		If able to open an existing message queue,
//											or create a message queue if one didn't exist
//							DPNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Open"

HRESULT CMessageQueue::Open(const DWORD dwPID,
							const TCHAR cSuffix,
							const DWORD dwQueueSize,
							const DWORD dwIdleTimeout,
							const DWORD dwFlags)
{
	HRESULT		hResultCode;
	PTSTR		pszObjectName = NULL;
	BOOL		bQueueExists = FALSE;
	DWORD		dwFileMapSize;

#ifdef UNICODE
	DPFX(DPFPREP, 3,"Parameters: dwPID [0x%lx], cSuffix [%C], dwQueueSize [%ld], dwFlags [0x%lx]",
			dwPID,cSuffix,dwQueueSize,dwFlags);
#else
	DPFX(DPFPREP, 3,"Parameters: dwPID [0x%lx], cSuffix [%c], dwQueueSize [%ld], dwFlags [0x%lx]",
			dwPID,cSuffix,dwQueueSize,dwFlags);
#endif // UNICODE
	// Create Receive Thread Running Event
	//	This will be set by the receive thread once it has spun up.  We need it for synchronization
	m_hReceiveThreadRunningEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL);
	if (m_hReceiveThreadRunningEvent == NULL)
	{
		DPFERR("Could not create recevie thread");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create shared object name
	// pszObjectName : {SharedObjectChar}PID{cSuffix}{\0}
	if ((pszObjectName = (PTSTR)DNMalloc((1 + (sizeof(DWORD)*2) + 1 + 1) * sizeof (TCHAR))) == NULL)
	{
		DPFERR("Could not allocate space for lpszObjectName");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}
	wsprintf(pszObjectName,_T("-%08X%c"),dwPID,cSuffix);// save first char for object differentiation

	DPFX(DPFPREP, 5,"Shared object name [%s]",pszObjectName);

	// Set the filemap size big enough that the largest message (text) will be dwQueueSize
	// so we add on the MsgQ info structure at the front and 1 Msg header
	dwFileMapSize = dwQueueSize + sizeof(DPL_MSGQ_INFO) + sizeof(DPL_MSGQ_HEADER);
	dwFileMapSize = (dwFileMapSize + 3) & (~0x3);	// DWORD align

	m_dwIdleTimeout = dwIdleTimeout;

	// Create File Mapping Object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_FILEMAP;
	m_hFileMap = DNCreateFileMapping(INVALID_HANDLE_VALUE,DNGetNullDacl(),
		PAGE_READWRITE,(DWORD)0,dwQueueSize,pszObjectName);
	if (m_hFileMap == NULL)
	{
		DPFERR("CreateFileMapping() failed");
		hResultCode = DPNERR_GENERIC;
		goto EXIT_Initialize;
	}
	if (GetLastError() == ERROR_ALREADY_EXISTS)
	{
		bQueueExists = TRUE;
	}

	if ((dwFlags & DPL_MSGQ_OPEN_FLAG_NO_CREATE) && !bQueueExists)
	{
		DPFERR("Open existing queue failed - does not exist");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_Initialize;
	}

	// Map file
	m_pFileMapAddress = reinterpret_cast<BYTE*>(MapViewOfFile(HANDLE_FROM_DNHANDLE(m_hFileMap),FILE_MAP_ALL_ACCESS,0,0,0));
	if (m_pFileMapAddress == NULL)
	{
		DPFERR("MapViewOfFile() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create semaphore object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_SEMAPHORE;
	m_hSemaphore = DNCreateSemaphore(DNGetNullDacl(),0,
		(dwQueueSize/sizeof(DPL_MSGQ_HEADER))+1,pszObjectName);
	if (m_hSemaphore == NULL)
	{
		DPFERR("CreateSemaphore() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create event object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_EVENT;

	// Changed to a semaphore to ensure that we never miss an event signal
	m_hEvent = DNCreateSemaphore(DNGetNullDacl(), 0, (dwQueueSize/sizeof(DPL_MSGQ_HEADER))+1, pszObjectName );

	if( m_hEvent == NULL )
	{
		DPFERR( "CreateSemaphore() failed" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create mutex object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_MUTEX;
	m_hMutex = DNCreateMutex(DNGetNullDacl(),FALSE,pszObjectName);
	if (m_hMutex == NULL)
	{
		DPFERR("CreateMutex() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Update structure elements
	m_dwPID = dwPID;
	m_pInfo = reinterpret_cast<DPL_MSGQ_INFO*>(m_pFileMapAddress);

	// Initialize msg queue if it didn't exist
	if (!bQueueExists)
	{
		m_pInfo->dwFlags = dwFlags & 0x0000ffff;	// Just last two bytes
		m_pInfo->dwStartOffset = 0;
		m_pInfo->dwEndOffset = 0;
		m_pInfo->dwQueueSize = dwQueueSize - sizeof(DPL_MSGQ_INFO);
		m_pInfo->dwFreeBytes = m_pInfo->dwQueueSize;
		m_pInfo->lRefCount = 0;
	}

	m_pData = (BYTE *) &m_pInfo[1];
	m_dwSig = DPL_MSGQ_SIGNATURE;

	// Increment user count
	Lock();
	m_pInfo->lRefCount++;
	Unlock();

	// If we made it this far, everything was okay
	hResultCode = DPN_OK;

EXIT_Initialize:

	// Free object name string
	if (pszObjectName != NULL)
		DNFree(pszObjectName);

	// If there was a problem - close handles
	if (hResultCode != DPN_OK)
	{
		DPFERR("Errors encountered - closing");
		Close();
	}

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
//	CMessageQueue::Close
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Close"

void CMessageQueue::Close(void)
{
	DPFX(DPFPREP, 3,"Parameters: (none)");

	if (m_hMutex != NULL)
	{
		// Decrement user count
		Lock();
		if( m_pInfo != NULL )
		{
			m_pInfo->lRefCount--;
		}
		Unlock();

		DPFX(DPFPREP, 5,"Close Mutex [0x%p]",m_hMutex);
		DNCloseHandle(m_hMutex);
		m_hMutex = NULL;
	}
	if (m_hEvent != NULL)
	{
		DPFX(DPFPREP, 5,"Close Event [0x%p]",m_hEvent);
		DNCloseHandle(m_hEvent);
		m_hEvent = NULL;
	}
	if (m_hSemaphore != NULL)
	{
		DPFX(DPFPREP, 5,"Close Semaphore [0x%p]",m_hSemaphore);
		DNCloseHandle(m_hSemaphore);
		m_hSemaphore = NULL;
	}
	if (m_pFileMapAddress != NULL)
	{
		DPFX(DPFPREP, 5,"UnMap View of File [0x%p]",m_pFileMapAddress);
		UnmapViewOfFile(m_pFileMapAddress);
		m_pFileMapAddress = NULL;
	}
	if (m_hFileMap != NULL)
	{
		DPFX(DPFPREP, 5,"Close FileMap [0x%p]",m_hFileMap);
		DNCloseHandle(m_hFileMap);
		m_hFileMap = NULL;
	}
	if (m_hReceiveThreadRunningEvent != NULL)
	{
		DPFX(DPFPREP, 5,"Close Event [0x%p]",m_hReceiveThreadRunningEvent);
		DNCloseHandle(m_hReceiveThreadRunningEvent);
		m_hReceiveThreadRunningEvent = NULL;
	}

	m_pInfo = NULL;

	DPFX(DPFPREP, 3,"Returning");
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::Terminate
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Terminate"

void CMessageQueue::Terminate(void)
{

	BOOL	bDone = FALSE;

	DPL_MSGQ_HEADER	Header;

	Header.dwCurrentSize = 0;
	Header.dwTotalSize = 0;
	Header.dwMsgId = DPL_MSGQ_MSGID_TERMINATE;
	Header.hSender = 0xFFFFFFFF;
	Header.dwFlags = DPL_MSGQ_MSGFLAGS_QUEUESYSTEM;
	Header.dwCurrentOffset = 0;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	DNASSERT(m_pInfo != NULL);

	while (!bDone)
	{
		// Wait until there's enough space for the message
		while (sizeof(DWORD) > m_pInfo->dwFreeBytes)
			WaitForConsumption(INFINITE);

		Lock();

		// Ensure there is space once we get the lock
		// (someone else might have beaten us here)
		if (sizeof(DWORD) <= m_pInfo->dwFreeBytes)
		{
			AddData(reinterpret_cast<BYTE*>(&Header),sizeof(DPL_MSGQ_HEADER));
			bDone = TRUE;

			IndicateMessage();
		}

		Unlock();
	}

	DPFX(DPFPREP, 3,"Returning");
}

// GetNextMessage
//
// Attempts to retrieve the next message from the queue
//
// pMsgHeader must be large enough to hold a message header.
//
// If no message is present in the queue then this function fills pMsgHeader with an
// idle message header
//
HRESULT CMessageQueue::GetNextMessage( PDPL_MSGQ_HEADER pMsgHeader, BYTE *pbPayload, DWORD *pdwBufferSize )
{
	HRESULT hr;

	Lock();

	hr = GetData( (BYTE *) pMsgHeader, sizeof( DPL_MSGQ_HEADER ) );

	// If there is no header on the queue fill in the header with an 
	// idle message
	if( hr == DPNERR_DOESNOTEXIST )
	{
		pMsgHeader->dwCurrentSize = sizeof( DPL_MSGQ_HEADER );
		pMsgHeader->dwTotalSize = sizeof( DPL_MSGQ_HEADER );
		pMsgHeader->dwMsgId = DPL_MSGQ_MSGID_IDLE;
		pMsgHeader->hSender = 0;
		pMsgHeader->dwFlags = DPL_MSGQ_MSGFLAGS_QUEUESYSTEM;
		pMsgHeader->dwCurrentOffset = 0;
		Unlock();

		return DPN_OK;
	}
	//// DBG
	else if( FAILED( hr ) )
	{
		DNASSERT( FALSE );
	}
	else if( pMsgHeader->dwMsgId == 0xFFFFFFFF )
	{
		DNASSERT( FALSE );
	}

	DWORD dwPayloadSize = pMsgHeader->dwCurrentSize;

	// Otherwise it's a valid message of some kind
	if( *pdwBufferSize < dwPayloadSize || pbPayload == NULL )
	{
		*pdwBufferSize = dwPayloadSize;
		Unlock();
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwBufferSize = dwPayloadSize;

	Consume( sizeof(DPL_MSGQ_HEADER) );

	// There is no payload, only a header.  Return here.
	if( dwPayloadSize == 0 )
	{
		Unlock();
		return DPN_OK;
	}

	hr = GetData( pbPayload, dwPayloadSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting IPC queue message payload" );
		DNASSERT( FALSE );
		Unlock();
		return hr;
	}

	Consume( dwPayloadSize );
	
	Unlock();

	return DPN_OK;
}

// Consume
//
// Marks dwSize bytes as consumed
//
// Needs LOCK()
void CMessageQueue::Consume( const DWORD dwSize )
{
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	m_pInfo->dwStartOffset += dwAlignedSize;

	if( m_pInfo->dwStartOffset >= m_pInfo->dwQueueSize )
	{
		m_pInfo->dwStartOffset -= m_pInfo->dwQueueSize;
	}

	m_pInfo->dwFreeBytes += dwAlignedSize;

	DNASSERT( m_pInfo->dwFreeBytes <= m_pInfo->dwFreeBytes );

	IndicateConsumption();
}

// GetData
//
// Get dwSize bytes from the queue.  If the queue is empty this function will return
// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
//
// REQUIRES LOCK
//
HRESULT CMessageQueue::GetData( BYTE *pbData, DWORD dwSize )
{
	if( m_pInfo->dwQueueSize == m_pInfo->dwFreeBytes )
	{
		return DPNERR_DOESNOTEXIST;
	}

	if( pbData == NULL )
	{
		return DPNERR_BUFFERTOOSMALL;
	}	

	// Calculate aligned size 
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	// Data block we want is wrapped
	if( m_pInfo->dwStartOffset+dwAlignedSize > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwStartOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - (cbBytesLeft);
		DWORD cbSecondBlock = dwSize - (cbBytesLeft);

		DNASSERT( dwAlignedSize > cbBytesLeft);

		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, cbBytesLeft);
		memcpy( pbData + cbBytesLeft, m_pData , cbSecondBlock );
	}
	// Data block is contiguous
	else
	{
		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, dwSize );
	}		

	return DPN_OK;
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::AddData
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//
//	Exit:		HRESULT
// ------------------------------
//
// REQUIRES LOCK!!
//
#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::AddData"

HRESULT CMessageQueue::AddData(BYTE *const pBuffer,
							   const DWORD dwSize)
{
	HRESULT		hResultCode;
	DWORD		dwAlignedSize;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p], dwSize [%ld]",pBuffer,dwSize);

	dwAlignedSize = (dwSize + 3) & (~0x3);

	// Check to ensure there is space
	if( dwAlignedSize > m_pInfo->dwFreeBytes )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Exit;
	}

	// We have a wrapping condition
	if( (m_pInfo->dwEndOffset+dwAlignedSize) > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwEndOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - cbBytesLeft;
		DWORD cbSecondBlock = dwSize - cbBytesLeft;

		DNASSERT( dwAlignedSize > cbBytesLeft );

		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, cbBytesLeft );
		memcpy( m_pData, pBuffer + cbBytesLeft, cbSecondBlock );

		m_pInfo->dwEndOffset = cbSecondBlockAligned;
	}
	// Queue is in the middle
	else
	{
		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, dwSize );
		m_pInfo->dwEndOffset += dwAlignedSize;
	}

	m_pInfo->dwFreeBytes -= dwAlignedSize;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::Send
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//				const DWORD dwFlags
//
//	Exit:		HRESULT
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Send"

HRESULT CMessageQueue::Send(BYTE *const pBuffer,
							const DWORD dwSize,
							const DWORD dwTimeOut,
							const DWORD dwMsgFlags,
							const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DWORD			dwMsgSize;		// DWORD aligned
	DWORD			dwTotalMsgSize;	// Msg + Header - DWORD aligned
	DPL_MSGQ_HEADER	Header;
	BOOL			bDone;
	DWORD			dwTimeRemaining;
	DWORD			dwTimeStart;
	DWORD			dwTimeFinish;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p], dwSize [%ld], dwFlags [0x%lx]",pBuffer,dwSize,dwFlags);

	DNASSERT( pBuffer != NULL );
	DNASSERT( dwSize <= m_pInfo->dwQueueSize );

	dwTimeRemaining = dwTimeOut;

	// Need DWORD aligned size
	dwMsgSize = (dwSize + 3) & (~0x3);
	dwTotalMsgSize = dwMsgSize + sizeof(DPL_MSGQ_HEADER);

	// Place the message into the MsgQ
	// Check to see if fragmentation is required
	// If we're at the end of the MsgQ and there isn't enough space for a Msg Header, REALIGN
	if (dwTotalMsgSize <= m_pInfo->dwQueueSize)
	{
		DPFX(DPFPREP, 5,"Message does not need to be fragmented");

		Header.dwMsgId = DPL_MSGQ_MSGID_SEND;
		Header.dwCurrentOffset = 0;
		Header.dwCurrentSize = dwSize;
		Header.dwTotalSize = dwSize;
		Header.hSender = m_hSender;
		Header.dwFlags = dwMsgFlags; // Mark this as a user message

		//// DBG
		if( Header.dwMsgId == 0xFFFFFFFF )
		{
			DNASSERT( FALSE );
		}

		bDone = FALSE;
		while (!bDone)
		{
			// Wait until there's enough space for the message
			while (dwTotalMsgSize > m_pInfo->dwFreeBytes)
			{
				if (dwTimeOut != INFINITE)
				{
					dwTimeStart = GETTIMESTAMP();
				}

				if (!WaitForConsumption(dwTimeRemaining))
				{
					return(DPNERR_TIMEDOUT);
				}

				if (dwTimeOut != INFINITE)
				{
					dwTimeFinish = GETTIMESTAMP();
					if ((dwTimeFinish - dwTimeStart) > dwTimeRemaining)
					{
						return(DPNERR_TIMEDOUT);
					}
					dwTimeRemaining -= (dwTimeFinish - dwTimeStart);
				}
			}

			Lock();

			// Ensure there is space once we get the lock
			// (someone else might have beaten us here)
			if (dwTotalMsgSize <= m_pInfo->dwFreeBytes)
			{
				//// DBG
				if( Header.dwMsgId == 0xFFFFFFFF )
				{
					DNASSERT( FALSE );
				}

				hResultCode = AddData(reinterpret_cast<BYTE*>(&Header),sizeof(DPL_MSGQ_HEADER));
				DNASSERT(hResultCode == DPN_OK);
				hResultCode = AddData(pBuffer,dwSize);
				DNASSERT(hResultCode == DPN_OK);
				bDone = TRUE;

				IndicateMessage();
			}

			Unlock();
			hResultCode = DPN_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 5,"Message needs to be fragmented");
		DNASSERT(FALSE);
		hResultCode = DPNERR_GENERIC;
#pragma TODO(a-minara,"Implement this")
	}


	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
//	DPLIsApplicationAvailable
//
//	Entry:		const DWORD		dwPID		PID to check
//
//	Exit:		BOOL	TRUE	If the application's queue's flags were retrieved successfully
//									and the application is waiting for a connection
//						FALSE	Otherwise
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLIsApplicationAvailable"

BOOL DPLIsApplicationAvailable(const DWORD dwPID)
{
	BOOL			bReturnCode;
	CMessageQueue	MessageQueue;

	DPFX(DPFPREP, 3,"Parameters: dwPID [%lx]",dwPID);

	if (MessageQueue.Open(dwPID,DPL_MSGQ_OBJECT_SUFFIX_APPLICATION,DPL_MSGQ_SIZE,
			INFINITE, DPL_MSGQ_OPEN_FLAG_NO_CREATE) != DPN_OK)
	{
		DPFERR("Could not open Msg Queue");
		return(FALSE);
	}

	bReturnCode = MessageQueue.IsAvailable();

	MessageQueue.Close();

	DPFX(DPFPREP, 3,"Returning: [%ld]",bReturnCode);
	return(bReturnCode);
}


//**********************************************************************
// ------------------------------
//	DPLMakeApplicationUnavailable
//
//	Entry:		const DWORD		dwPID		PID to check
//
//	Exit:		HRESULT	DPN_OK	If the application was waiting for a connection
//									and made unavailable
//						DPNERR_INVALIDAPPLICATION
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLMakeApplicationUnavailable"

HRESULT DPLMakeApplicationUnavailable(const DWORD dwPID)
{
	HRESULT			hResultCode;
	CMessageQueue	MessageQueue;

	DPFX(DPFPREP, 3,"Parameters: dwPID [%lx]",dwPID);

	if (MessageQueue.Open(dwPID,DPL_MSGQ_OBJECT_SUFFIX_APPLICATION,DPL_MSGQ_SIZE,
			DPL_MSGQ_OPEN_FLAG_NO_CREATE,INFINITE) != DPN_OK)
	{
		DPFERR("Could not open Msg Queue");
		return(DPNERR_INVALIDAPPLICATION);
	}

	if ((hResultCode = MessageQueue.MakeUnavailable()) != DPN_OK)
	{
		DPFERR("Could not make application unavailable");
		hResultCode = DPNERR_INVALIDAPPLICATION;
	}

	MessageQueue.Close();

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	DPLProcessMessageQueue
//
//	Entry:
//
//	Exit:		HRESULT	DPN_OK	If the application was waiting for a connection
//									and made unavailable
//						DPNERR_INVALIDAPPLICATION
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLProcessMessageQueue"

DWORD WINAPI DPLProcessMessageQueue(PVOID pvReceiveQueue)
{
	HRESULT			hResultCode;
	DPL_MSGQ_HEADER	dplMsgHeader;
	BYTE			*pBuffer = NULL;
	DWORD			dwBufferSize = 0;
	DWORD			dwSize;
	CMessageQueue	*pReceiveQueue;
	DWORD           dwWaitResult;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	COM_CoInitialize(NULL);

	pReceiveQueue = static_cast<CMessageQueue*>(pvReceiveQueue);

	// Indicate we are running
	pReceiveQueue->MakeReceiving();

	while(1)
	{
		dwWaitResult = pReceiveQueue->WaitForMessages();

		while( 1 ) 
		{
			dwSize = dwBufferSize;
    		hResultCode = pReceiveQueue->GetNextMessage(&dplMsgHeader, pBuffer, &dwSize);

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( pBuffer )
					delete [] pBuffer;

				pBuffer = new BYTE[dwSize];
				
				if( pBuffer == NULL )
				{
					DPFX(DPFPREP,  0, "Error allocating memory" );
					DNASSERT( FALSE );
					goto EXIT_DPLProcessMessageQueue;
				}

				dwBufferSize = dwSize;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error while getting messages from the queue" );
				DNASSERT( FALSE );
				goto EXIT_DPLProcessMessageQueue;
			}
			else
			{
				break;
			}
		}

		DPFX(DPFPREP, 5,"dwMsgId [0x%lx] dwTotalSize [0x%lx] dwCurrentSize [0x%lx] dwCurrentOffset [0x%lx] ",
			dplMsgHeader.dwMsgId, dplMsgHeader.dwTotalSize, dplMsgHeader.dwCurrentSize, 
			dplMsgHeader.dwCurrentOffset );

		switch(dplMsgHeader.dwMsgId)
		{
		case DPL_MSGQ_MSGID_IDLE:
		    {
		        DPFX(DPFPREP, 6,"Idle message fired" );
		        DWORD dwMsgId = DPL_MSGID_INTERNAL_IDLE_TIMEOUT;
                //  7/17/2000(RichGr) - IA64: Change last parm from sizeof(DWORD) to sizeof(BYTE*).
				hResultCode = pReceiveQueue->CallMessageHandler(NULL,DPL_MSGQ_MSGFLAGS_USER1,(BYTE *) &dwMsgId,sizeof(BYTE*));
		    }
		    break;
		case DPL_MSGQ_MSGID_SEND:
			{
				DPFX(DPFPREP, 5,"DPL_MSGQ_MSGID_SEND");
				hResultCode = pReceiveQueue->CallMessageHandler(dplMsgHeader.hSender,dplMsgHeader.dwFlags,pBuffer,dwSize);
				break;
			}

		case DPL_MSGQ_MSGID_TERMINATE:
			{
				DPFX(DPFPREP, 5,"DPL_MSGQ_MSGID_TERMINATE");
				hResultCode = DPN_OK;
				goto EXIT_DPLProcessMessageQueue;
				break;
			}

		default:
			{
				DPFX(DPFPREP, 5,"UNKNOWN - should never get here");
				DNASSERT(FALSE);
				hResultCode = DPNERR_GENERIC;
				goto EXIT_DPLProcessMessageQueue;
				break;
			}
		}
	}

EXIT_DPLProcessMessageQueue:

	if( pBuffer )
		delete [] pBuffer;

	// Indicate we are no longer running
	pReceiveQueue->MakeNotReceiving();

	COM_CoUninitialize();

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplprot.h
 *  Content:    DirectPlay8 Inter-Memory Packet format
 *
 ***************************************************************************/
#ifndef __DPLPROT_H
#define __DPLPROT_H

#define	DPL_MSGID_INTERNAL_MASK					0xffff0000
#define	DPL_MSGID_INTERNAL						0xb00b0000
#define	DPL_MSGID_INTERNAL_DISCONNECT			(0x0001 | DPL_MSGID_INTERNAL)
#define	DPL_MSGID_INTERNAL_CONNECT_REQ			(0x0002 | DPL_MSGID_INTERNAL)
#define	DPL_MSGID_INTERNAL_CONNECT_ACK			(0x0003 | DPL_MSGID_INTERNAL)
#define	DPL_MSGID_INTERNAL_UPDATE_STATUS		(0x0004 | DPL_MSGID_INTERNAL)
#define DPL_MSGID_INTERNAL_IDLE_TIMEOUT         (0x0005 | DPL_MSGID_INTERNAL)
#define DPL_MSGID_INTERNAL_CONNECTION_SETTINGS  (0x0006 | DPL_MSGID_INTERNAL)

#pragma pack(push,1)

// DPL_INTERNAL_CONNECTION_SETTINGS
//
// This structure is used to pass connection settings on the IPC wire.  It is used
// be several message types.
// 
typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS 
{
	DWORD						dwFlags;
	DWORD						dwHostAddressOffset;
	DWORD						dwHostAddressLength;  
	DWORD						dwDeviceAddressOffset;
	DWORD						dwDeviceAddressLengthOffset;
	DWORD						dwNumDeviceAddresses;
	DWORD						dwPlayerNameOffset;
	DWORD						dwPlayerNameLength;
	DPN_APPLICATION_DESC_INFO	dpnApplicationDesc;
} DPL_INTERNAL_CONNECTION_SETTINGS, *PDPL_INTERNAL_CONNECTION_SETTINGS;

// DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER
//
// Lobby Client <--> Lobbied Application
//
// This structure is the header portion of the connection_settings_update message
typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER
{

	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_CONNECTION_SETTINGS
	DWORD						dwConnectionSettingsSize;   // 0 = no settings, 1 = settings
} DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER, *PDPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER;

// DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE
//
// Lobby Client <--> Lobbied Application
//
// This structure is sent to update the connection settings for a specified connection.
typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE : DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER
{
	DPL_INTERNAL_CONNECTION_SETTINGS dplConnectionSettings;
} DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE, *PDPL_INTERNAL_CONNECTION_SETTINGS_UPDATE;

// DPL_INTERNAL_MESSAGE_CONNECT_ACK
//
// Lobby Client <-- Lobbied Application
// 
// This message is sent to acknowledge a connection request.    
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_CONNECT_ACK {
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_CONNECT_ACK
	DPNHANDLE 					hSender;
} DPL_INTERNAL_MESSAGE_CONNECT_ACK, *PDPL_INTERNAL_MESSAGE_CONNECT_ACK;

// DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER
//
// Lobby Client --> Lobbied Application
// 
// This is the header for the connect_req message.
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER
{
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_CONNECT_REQ
	DPNHANDLE					hSender; 
	DWORD						dwSenderPID;
	DWORD						dwLobbyConnectDataOffset;
	DWORD						dwLobbyConnectDataSize;
	DWORD						dwConnectionSettingsSize;
} DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER, *PDPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER;

// DPL_INTERNAL_MESSAGE_CONNECT_REQ
//
// Lobby Client --> Lobbied Application
// 
// This message is sent to request a connection be established.
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_CONNECT_REQ : DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER
{
	DPL_INTERNAL_CONNECTION_SETTINGS dplConnectionSettings;
} DPL_INTERNAL_MESSAGE_CONNECT_REQ, *PDPL_INTERNAL_MESSAGE_CONNECT_REQ;

// DPL_INTERNAL_MESSAGE_DISCONNECT
//
// Lobby Client <--> Lobbied Application
// 
// This message is sent to issue a disconnect.
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_DISCONNECT 
{
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_DISCONNECT
	DWORD						dwPID;
} DPL_INTERNAL_MESSAGE_DISCONNECT, *PDPL_INTERNAL_MESSAGE_DISCONNECT;

// DPL_INTERNAL_MESSAGE_DISCONNECT
//
// Lobby Client <-- Lobbied Application
// 
// This message is sent to update the client of the application's status.  
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_UPDATE_STATUS {
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_DISCONNECT
	DWORD						dwStatus;
} DPL_INTERNAL_MESSAGE_UPDATE_STATUS, *PDPL_INTERNAL_MESSAGE_UPDATE_STATUS;

#pragma pack(pop)

#endif // __DPLPROT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplparam.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplparam.h
 *  Content:    DirectPlayLobby8 Parameter Validation helper routines
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/18/00    rmt     Created
 *  04/25/00    rmt     Bug #s 33138, 33145, 33150 
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *
 ***************************************************************************/
#ifndef __DPLPARAM_H
#define __DPLPARAM_H

#ifndef DPNBUILD_NOPARAMVAL

extern BOOL IsValidDirectPlayLobby8Object( LPVOID lpvObject );

extern HRESULT DPL_ValidateGetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );
extern HRESULT DPL_ValidateSetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );
extern HRESULT DPL_ValidConnectionSettings( const DPL_CONNECTION_SETTINGS * const pdplConnectSettings );
extern HRESULT DPL_ValidateQueryInterface( LPVOID lpv,REFIID riid,LPVOID *ppv ); 
extern HRESULT DPL_ValidateRelease( PVOID pv );
extern HRESULT DPL_ValidateAddRef( PVOID pv );
extern HRESULT DPL_ValidConnectInfo( const DPL_CONNECT_INFO * const dplConnectInfo );
extern HRESULT DPL_ValidProgramDesc( const DPL_PROGRAM_DESC * const dplProgramInfo );

extern HRESULT DPL_ValidateRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								 const DPL_PROGRAM_DESC *const pdplProgramDesc,
								 const DWORD dwFlags);

extern HRESULT DPL_ValidateUnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							   const GUID *pguidApplication,
							   const DWORD dwFlags);

extern HRESULT DPL_ValidateSetAppAvailable(IDirectPlay8LobbiedApplication *pInterface,  const BOOL fAvailable, const DWORD dwFlags);

extern HRESULT DPL_ValidateWaitForConnection(IDirectPlay8LobbiedApplication *pInterface,
								   const DWORD dwMilliseconds, const DWORD dwFlags );

extern HRESULT DPL_ValidateUpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobby,
							  const DWORD dwStatus, const DWORD dwFlags );

extern HRESULT DPL_ValidateEnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
							  const GUID *const pGuidApplication,
							  BYTE *const pEnumData,
							  DWORD *const pdwEnumDataSize,
							  DWORD *const pdwEnumDataItems,
							  const DWORD dwFlags );

extern HRESULT DPL_ValidateConnectApplication(IDirectPlay8LobbyClient *pInterface,
							   const DPL_CONNECT_INFO *const pdplConnectionInfo,
							   const PVOID pvUserApplicationContext,
							   DPNHANDLE *const hApplication,
							   const DWORD dwTimeOut,
							   const DWORD dwFlags);

extern HRESULT DPL_ValidateReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, const DWORD dwFlags );							  


extern HRESULT DPL_ValidateRegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags);

extern HRESULT DPL_ValidateClose(PVOID pv, const DWORD dwFlags );

extern HRESULT DPL_ValidateSend(PVOID pv,
					  const DPNHANDLE hTarget,
					  const BYTE *const pBuffer,
					  const DWORD pBufferSize,
					  const DWORD dwFlags);

#endif // !DPNBUILD_NOPARAMVAL

#endif // __DPLPARAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplparam.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplparam.cpp
 *  Content:    DirectPlayLobby8 Parameter Validation helper routines
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/18/00    rmt     Created
 *  04/25/00    rmt     Bug #s 33138, 33145, 33150  
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *	10/16/01	mjn		Added additional parameter validation (ManBugs 52414, 52168)
 *
 ***************************************************************************/

#include "dnlobbyi.h"

#ifndef DPNBUILD_NOPARAMVAL

extern IUnknownVtbl  DN_LobbyUnknownVtbl;

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateGetConnectionSettings"
HRESULT DPL_ValidateGetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( lpv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hLobbyClient == DPLHANDLE_ALLCONNECTIONS )
    {
        DPFERR( "Cannot specify ALLCONNECTIONS for GetConnectionSettings" );
        return DPNERR_INVALIDHANDLE;
    }

	if( hLobbyClient == 0 )
	{
		DPFERR( "Invalid connection ID" );
		return DPNERR_INVALIDHANDLE;
	}

    if( pdwInfoSize == NULL || !DNVALID_WRITEPTR( pdwInfoSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Invalid pointer specified for infosize" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwInfoSize > 0 && 
        (pdplSessionInfo == NULL || !DNVALID_WRITEPTR( pdplSessionInfo, *pdwInfoSize ) ) )
    {
        DPFERR( "Invalid pointer specified for session info pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }
    
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateSetConnectionSettings"
HRESULT DPL_ValidateSetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags )
{
    HRESULT hr;

    if( !IsValidDirectPlayLobby8Object( lpv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hLobbyClient == 0 )
    {
        DPFERR( "Invalid handle" );
        return DPNERR_INVALIDHANDLE;
    }

    if( pdplSessionInfo != NULL )
    {
        hr = DPL_ValidConnectionSettings( pdplSessionInfo );

        if( FAILED( hr ) )
        {
            DPFERR( "Error validating connectsettings struct" );
            return hr;
        }
    }
    
    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }
    
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateConnectionSettings"
HRESULT DPL_ValidConnectionSettings( const DPL_CONNECTION_SETTINGS * const pdplConnectSettings )
{
    if( pdplConnectSettings == NULL || !DNVALID_READPTR( pdplConnectSettings, sizeof( DPL_CONNECTION_SETTINGS ) ) )
    {
        DPFERR( "Invalid pointer specified for connection settings field" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectSettings->dwSize != sizeof( DPL_CONNECTION_SETTINGS ) )
    {
        DPFERR( "Invalid size specified for dplconnectsettings struct" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdplConnectSettings->dwFlags & ~( DPLCONNECTSETTINGS_HOST ) )
    {
        DPFERR( "Invalid flags specified in connectsettings struct" );
        return DPNERR_INVALIDFLAGS;
    }

	//
	//	Application description
	//
    if( pdplConnectSettings->dpnAppDesc.dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPFERR( "Invalid size specified on app desc" );
        return DPNERR_INVALIDPOINTER;
    }

	if ( (pdplConnectSettings->dpnAppDesc.dwFlags &
			~(DPNSESSION_CLIENT_SERVER|DPNSESSION_MIGRATE_HOST|DPNSESSION_NODPNSVR|DPNSESSION_REQUIREPASSWORD)) ||
			((pdplConnectSettings->dpnAppDesc.dwFlags & DPNSESSION_CLIENT_SERVER) &&
			(pdplConnectSettings->dpnAppDesc.dwFlags & DPNSESSION_MIGRATE_HOST)))
	{
		DPFERR( "Invalid flag(s) specified on app desc" );
		return( DPNERR_INVALIDFLAGS );
	}

    if( pdplConnectSettings->dpnAppDesc.pwszSessionName != NULL && 
        !DNVALID_STRING_W( pdplConnectSettings->dpnAppDesc.pwszSessionName ) )
    {
        DPFERR( "Invalid session name specified on app desc" );
        return DPNERR_INVALIDSTRING;
    }

	if (pdplConnectSettings->dpnAppDesc.dwFlags & DPNSESSION_REQUIREPASSWORD)
	{
		if (pdplConnectSettings->dpnAppDesc.pwszPassword == NULL)
		{
			DPFERR( "Password must be specified" );
			return( DPNERR_INVALIDPARAM );
		}
		else
		{
			if( !DNVALID_STRING_W( pdplConnectSettings->dpnAppDesc.pwszPassword ) )
			{
				DPFERR( "Invalid password specified on app desc" );
				return DPNERR_INVALIDSTRING;
			}
		}
	}
	else
	{
		if (pdplConnectSettings->dpnAppDesc.pwszPassword != NULL)
		{
			DPFERR( "Password not required" );
			return( DPNERR_INVALIDPARAM );
		}
	}

    if( pdplConnectSettings->dpnAppDesc.dwReservedDataSize != 0 && 
        !DNVALID_READPTR( pdplConnectSettings->dpnAppDesc.pvReservedData, pdplConnectSettings->dpnAppDesc.dwReservedDataSize ) )
    {
        DPFERR( "Invalid reserved data specified on app desc" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectSettings->dpnAppDesc.dwApplicationReservedDataSize != 0 && 
        !DNVALID_READPTR( pdplConnectSettings->dpnAppDesc.pvApplicationReservedData, 
                          pdplConnectSettings->dpnAppDesc.dwApplicationReservedDataSize ) )
    {
        DPFERR( "Invalid application reserved data specified on app desc" );
        return DPNERR_INVALIDPOINTER;
    }

	//
	//	Back to connect settings
	//
    if( pdplConnectSettings->dwFlags & DPLCONNECTSETTINGS_HOST )
	{
        if( pdplConnectSettings->pdp8HostAddress != NULL )
	    {
			DPFERR( "Host address must be NULL if description is for host" );
			return DPNERR_INVALIDPARAM;
		}
	}
    else
    {
        if( pdplConnectSettings->pdp8HostAddress == NULL ||
            !DNVALID_READPTR( pdplConnectSettings->pdp8HostAddress, sizeof( IDirectPlay8Address * ) ) )
        {
            DPFERR( "Invalid host address specified" );
            return DPNERR_INVALIDHOSTADDRESS;
        }
    }

    if( pdplConnectSettings->ppdp8DeviceAddresses == NULL ||
        !DNVALID_READPTR( pdplConnectSettings->ppdp8DeviceAddresses, pdplConnectSettings->cNumDeviceAddresses * sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid device addresses specified" );
        return DPNERR_INVALIDDEVICEADDRESS;
    }

    if( pdplConnectSettings->cNumDeviceAddresses == 0 )
    {
        DPFERR( "You must specify at least one device address" );
        return DPNERR_INVALIDPARAM;
    }

	if ((pdplConnectSettings->pwszPlayerName != NULL) && !DNVALID_STRING_W(pdplConnectSettings->pwszPlayerName))
	{
		DPFERR( "Invalid player name specified" );
		return( DPNERR_INVALIDSTRING );
	}

    return DPN_OK;    
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateQueryInterface"
HRESULT DPL_ValidateQueryInterface( LPVOID lpv,REFIID riid,LPVOID *ppv )
{
    if( !IsValidDirectPlayLobby8Object( lpv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( ppv == NULL || !DNVALID_WRITEPTR( ppv, sizeof( void * ) ) )
    {
        DPFERR( "Invalid pointer specified for target of queryinterface" );
        return DPNERR_INVALIDPOINTER;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateRelease"
HRESULT DPL_ValidateRelease( PVOID pv )
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateAddRef"
HRESULT DPL_ValidateAddRef( PVOID pv )
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateRegisterMessageHandler"
HRESULT DPL_ValidateRegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags)
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pfn == NULL )
    {
        DPFERR( "Invalid  pointer for message handler " );
        return DPNERR_INVALIDPOINTER;
    }

	if( pdpnhConnection )
	{
		if( !DNVALID_WRITEPTR( pdpnhConnection, sizeof( DPNHANDLE ) ) )
		{
			DPFERR( "Invalid pointer specified for connection handle" );
			return DPNERR_INVALIDPOINTER;
		}
	}

    if( dwFlags & ~(DPLINITIALIZE_DISABLEPARAMVAL) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateClose"
HRESULT DPL_ValidateClose(PVOID pv, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags specified" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateSend"
HRESULT DPL_ValidateSend(PVOID pv,
					  const DPNHANDLE hTarget,
					  const BYTE *const pBuffer,
					  const DWORD dwBufferSize,
					  const DWORD dwFlags)
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	if( hTarget == 0 )
	{
		DPFERR( "Invalid handle" );
		return DPNERR_INVALIDHANDLE;
	}

    if( pBuffer == NULL || 
        !DNVALID_READPTR( pBuffer, dwBufferSize ) )
    {
        DPFERR( "Invalid pointer specified for buffer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwBufferSize == 0 )
    {
        DPFERR( "Invalid buffer size specified" );
        return DPNERR_INVALIDPARAM;
    }

	if( dwBufferSize > 0x10000 )
	{
		DPFERR( "Queue does not support sends > 0x10000 in size" );
		return DPNERR_SENDTOOLARGE;
	}
        
    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateEnumLocalPrograms"
HRESULT DPL_ValidateEnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
							  const GUID *const pGuidApplication,
							  BYTE *const pEnumData,
							  DWORD *const pdwEnumDataSize,
							  DWORD *const pdwEnumDataItems,
							  const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

    if( pGuidApplication != NULL && !DNVALID_READPTR( pGuidApplication, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer specified for application guid" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdwEnumDataSize == NULL || !DNVALID_WRITEPTR( pdwEnumDataSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Invalid pointer specified for enum data size" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdwEnumDataItems == NULL || !DNVALID_WRITEPTR( pdwEnumDataItems, sizeof( DWORD ) ) ) 
    {
        DPFERR( "Invalid pointer specified for enum data count" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwEnumDataSize > 0 &&
        (pEnumData == NULL || !DNVALID_WRITEPTR( pEnumData, *pdwEnumDataSize ) ) )
    {
        DPFERR( "Invalid enum data pointer specified" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateConnectApplication"
HRESULT DPL_ValidateConnectApplication(IDirectPlay8LobbyClient *pInterface,
							   const DPL_CONNECT_INFO *const pdplConnectionInfo,
							   const PVOID pvUserApplicationContext,
							   DPNHANDLE *const hApplication,
							   const DWORD dwTimeOut,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;
    
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	DPFX(DPFPREP,4,"Validating connect info");
    if( FAILED( hResultCode = DPL_ValidConnectInfo( pdplConnectionInfo ) ) )
    {
        DPFX(DPFPREP,  0, "Error validating connect info hr=0x%x", hResultCode );
        return hResultCode;
    }

    if( hApplication == NULL || 
        !DNVALID_WRITEPTR( hApplication, sizeof( DPNHANDLE ) ) )
    {
        DPFERR( "Invalid pointer specified for application handle" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateReleaseApplication"
HRESULT DPL_ValidateReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, const DWORD dwFlags )
{

    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	if( hApplication == 0 )
	{
		DPFERR( "Invalid handle" );
		return DPNERR_INVALIDHANDLE;
	}

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateUnRegisterProgram"
HRESULT DPL_ValidateUnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							   const GUID *pguidApplication,
							   const DWORD dwFlags)
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

    if( pguidApplication == NULL || 
        !DNVALID_READPTR( pguidApplication, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer to application GUID specified" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateSetAppAvailable"
HRESULT DPL_ValidateSetAppAvailable(IDirectPlay8LobbiedApplication *pInterface, const BOOL fAvailable, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

    if( dwFlags & ~(DPLAVAILABLE_ALLOWMULTIPLECONNECT) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateWaitForConnection"
HRESULT DPL_ValidateWaitForConnection(IDirectPlay8LobbiedApplication *pInterface,
								   const DWORD dwMilliseconds, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags specified" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateUpdateStatus"
HRESULT DPL_ValidateUpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobby,
							  const DWORD dwStatus, 
							  const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

	if( hLobby == 0 )
	{
		DPFERR( "Invalid handle" );
		return DPNERR_INVALIDHANDLE;
	}

    if( dwStatus != DPLSESSION_CONNECTED && 
        dwStatus != DPLSESSION_COULDNOTCONNECT && 
        dwStatus != DPLSESSION_DISCONNECTED && 
        dwStatus != DPLSESSION_TERMINATED && 
		dwStatus != DPLSESSION_HOSTMIGRATED && 
		dwStatus != DPLSESSION_HOSTMIGRATEDHERE )
    {
        DPFERR( "Invalid status specified" );
        return DPNERR_INVALIDPARAM;
    }

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags specified" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateRegisterProgram"
HRESULT DPL_ValidateRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								 const DPL_PROGRAM_DESC *const pdplProgramDesc,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;
    
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DPL_ValidProgramDesc(pdplProgramDesc) ) )
    {
        DPFX(DPFPREP,  0, "Error validating program desc structure hr=0x%x", hResultCode );
        return hResultCode;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidConnectInfo"
HRESULT DPL_ValidConnectInfo( const DPL_CONNECT_INFO * const pdplConnectInfo )
{
    if( pdplConnectInfo == NULL )
    {
        DPFERR( "Invalid pointer specified for connect info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectInfo->dwSize != sizeof( DPL_CONNECT_INFO ) )
    {
        DPFERR( "Wrong size specified for connect info struct" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_READPTR( pdplConnectInfo, pdplConnectInfo->dwSize ) )
    {
        DPFERR( "Invalid pointer specified for connect info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectInfo->dwFlags & ~(DPLCONNECT_LAUNCHNEW | DPLCONNECT_LAUNCHNOTFOUND) )
    {
        DPFERR("Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    if( pdplConnectInfo->dwFlags & DPLCONNECT_LAUNCHNEW && 
        pdplConnectInfo->dwFlags & DPLCONNECT_LAUNCHNOTFOUND )
    {
        DPFERR( "You cannot specify both launchnew and launchnotfound" );
        return DPNERR_INVALIDPARAM;
    }

    GUID guidTmp;

    memset( &guidTmp, 0x00, sizeof( GUID ) );

    if( pdplConnectInfo->guidApplication == guidTmp )
    {
        DPFERR( "Cannot specify GUID_NULL for the application GUID" );
        return DPNERR_INVALIDPARAM;
    }

	if( pdplConnectInfo->pdplConnectionSettings != NULL )
	{
		HRESULT hr = DPL_ValidConnectionSettings( pdplConnectInfo->pdplConnectionSettings );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error validating connection settings field of connect info hr=0x%x", hr );
			return hr;
		}

/*	REMOVE - never implemented
		if (pdplConnectInfo->guidApplication != pdplConnectInfo->pdplConnectionSettings->dpnAppDesc.guidApplication)
		{
			DPFERR( "Different application guids specified in connect info and app desc" );
			return( DPNERR_INVALIDPARAM );
		}
*/
	}

    if( pdplConnectInfo->dwLobbyConnectDataSize > 0 && 
        (pdplConnectInfo->pvLobbyConnectData == NULL || !DNVALID_READPTR( pdplConnectInfo->pvLobbyConnectData, pdplConnectInfo->dwLobbyConnectDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for lobby connect data" );
        return DPNERR_INVALIDPOINTER;
    }

    return DPN_OK;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidProgramDesc"
HRESULT DPL_ValidProgramDesc( const DPL_PROGRAM_DESC * const pdplProgramInfo )
{
    if( pdplProgramInfo == NULL )
    {
        DPFERR( "Invalid pointer specified for program info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplProgramInfo->dwSize != sizeof( DPL_PROGRAM_DESC ) )
    {
        DPFERR( "Wrong size specified for program info struct" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_READPTR( pdplProgramInfo, pdplProgramInfo->dwSize ) )
    {
        DPFERR( "Invalid pointer specified for app info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplProgramInfo->dwFlags != 0  )
    {
        DPFERR("Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    GUID guidTmp;

    memset( &guidTmp, 0x00, sizeof( GUID ) );

    if( pdplProgramInfo->guidApplication == guidTmp )
    {
        DPFERR( "Cannot specify GUID_NULL for the application GUID" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdplProgramInfo->pwszApplicationName == NULL )
    {
        DPFERR( "You must specify an application name" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_STRING_W( pdplProgramInfo->pwszApplicationName ) )
    {
        DPFERR( "Invalid string specified for application name" );
        return DPNERR_INVALIDSTRING;
    }
    
    if( pdplProgramInfo->pwszCommandLine != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszCommandLine ) )
    {
        DPFERR( "Invalid command-line string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszCurrentDirectory != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszCurrentDirectory ) )
    {
        DPFERR( "Invalid current directory string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszDescription != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszDescription ) )
    {
        DPFERR( "Invalid description string specified" );
        return DPNERR_INVALIDSTRING;
    }    
    
    if( pdplProgramInfo->pwszExecutableFilename == NULL )
    {
        DPFERR( "You must specify an executable name" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_STRING_W( pdplProgramInfo->pwszExecutableFilename ) )
    {
        DPFERR( "Invalid string specified for executable name" );
        return DPNERR_INVALIDSTRING;
    }    

    if( pdplProgramInfo->pwszExecutablePath != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszExecutablePath ) )
    {
        DPFERR( "Invalid executable path string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszLauncherFilename != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszLauncherFilename ) )
    {
        DPFERR( "Invalid launcher filename string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszLauncherPath != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszLauncherPath ) )
    {
        DPFERR( "Invalid launcher path string specified" );
        return DPNERR_INVALIDSTRING;
    }    

    return DPN_OK;      
}

#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlayLobby8Object"
BOOL IsValidDirectPlayLobby8Object( LPVOID lpvObject )
{
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DPL_Lobby8ClientVtbl &&
	   pIntList->lpVtbl != &DPL_8LobbiedApplicationVtbl && 
	   pIntList->lpVtbl != &DN_LobbyUnknownVtbl
	   )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad vtable" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8LobbyClient &&
	   pIntList->iid != IID_IDirectPlay8LobbiedApplication && 
	   pIntList->iid != IID_IUnknown )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad iid" );
		return FALSE;
	}

	if( pIntList->pObject == NULL || 
	   !DNVALID_READPTR( pIntList->pObject, sizeof( OBJECT_DATA ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	const DIRECTPLAYLOBBYOBJECT *pdpl = (DIRECTPLAYLOBBYOBJECT *) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdpl == NULL || 
	   !DNVALID_READPTR( pdpl, sizeof( DIRECTPLAYLOBBYOBJECT ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	return TRUE;

}

#endif // !DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplreg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLReg.cpp
 *  Content:    DirectPlay Lobby Registry Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   04/25/00   rmt     Bug #s 33138, 33145, 33150  
 *   05/03/00	rmt		UnRegister was not implemented!  Implementing!
 *   08/05/00   RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *   06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored). 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME 
#define DPF_MODNAME "DPLDeleteProgramDesc"
HRESULT DPLDeleteProgramDesc( const GUID * const pGuidApplication )
{
    HRESULT hResultCode = DPN_OK;
	CRegistry	RegistryEntry;
	CRegistry   SubEntry;
	DWORD       dwLastError;
	HKEY		hkCurrentHive;
	BOOL		fFound = FALSE;
	BOOL		fRemoved = FALSE;
	
	DPFX(DPFPREP, 3, "Removing program desc" );

	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentHive = HKEY_CURRENT_USER;
		}
		else
		{
			hkCurrentHive = HKEY_LOCAL_MACHINE;
		}

		if( !RegistryEntry.Open( hkCurrentHive,DPL_REG_LOCAL_APPL_SUBKEY,FALSE,FALSE,TRUE,DPN_KEY_ALL_ACCESS )  )
		{
			DPFX(DPFPREP, 1, "Failed to open key for remove in pass %i", dwIndex );
			continue;
		}

		// This should be down below the next if block, but 8.0 shipped with a bug
		// which resulted in this function returning DPNERR_NOTALLOWED in cases where
		// the next if block failed.  Need to remain compatible
		fFound = TRUE;

		if( !SubEntry.Open( RegistryEntry, pGuidApplication, FALSE, FALSE,TRUE,DPN_KEY_ALL_ACCESS ) )
		{
			DPFX(DPFPREP, 1, "Failed to open subkey for remove in pass %i", dwIndex );			
			continue;
		}

		SubEntry.Close();

		if( !RegistryEntry.DeleteSubKey( pGuidApplication ) )
		{
			DPFX(DPFPREP, 1, "Failed to delete subkey for remove in pass %i", dwIndex );						
			continue;
		}

		fRemoved = TRUE;

		RegistryEntry.Close();
	}
	
	if( !fFound )
	{
		DPFX(DPFPREP,  0, "Could not find entry" );
		hResultCode = DPNERR_DOESNOTEXIST;
	}
	else if( !fRemoved )
	{
		dwLastError = GetLastError();
		DPFX(DPFPREP,  0, "Error deleting registry sub-key lastError [0x%lx]", dwLastError );
		hResultCode = DPNERR_NOTALLOWED;
	}

	DPFX(DPFPREP, 3, "Removing program desc [0x%x]", hResultCode );	

    return hResultCode;
    
}

//**********************************************************************
// ------------------------------
//	DPLWriteProgramDesc
//
//	Entry:		Nothing
//
//	Exit:		DPN_OK
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLWriteProgramDesc"

HRESULT DPLWriteProgramDesc(DPL_PROGRAM_DESC *const pdplProgramDesc)
{
	HRESULT		hResultCode;
	CRegistry	RegistryEntry;
	CRegistry	SubEntry;
	WCHAR		*pwsz;
	WCHAR		pwszDefault[] = L"\0";
	HKEY		hkCurrentHive = NULL;
	BOOL		fWritten = FALSE;

	DPFX(DPFPREP, 3,"Parameters: pdplProgramDesc [0x%p]",pdplProgramDesc);

	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentHive = HKEY_LOCAL_MACHINE;
		}
		else
		{
			hkCurrentHive = HKEY_CURRENT_USER;
		}

		if (!RegistryEntry.Open(hkCurrentHive,DPL_REG_LOCAL_APPL_SUBKEY,FALSE,TRUE,TRUE,DPN_KEY_ALL_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );
			continue;
		}

		// Get Application name and GUID from each sub key
		if (!SubEntry.Open(RegistryEntry,&pdplProgramDesc->guidApplication,FALSE,TRUE,TRUE,DPN_KEY_ALL_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );			
			continue;
		}

		if (!SubEntry.WriteString(DPL_REG_KEYNAME_APPLICATIONNAME,pdplProgramDesc->pwszApplicationName))
		{
			DPFX( DPFPREP, 1, "Could not write ApplicationName on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszCommandLine != NULL)
		{
			pwsz = pdplProgramDesc->pwszCommandLine;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_COMMANDLINE,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write CommandLine on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszCurrentDirectory != NULL)
		{
			pwsz = pdplProgramDesc->pwszCurrentDirectory;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_CURRENTDIRECTORY,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write CurrentDirectory on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszDescription != NULL)
		{
			pwsz = pdplProgramDesc->pwszDescription;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_DESCRIPTION,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write Description on pass %i", dwIndex );
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszExecutableFilename != NULL)
		{
			pwsz = pdplProgramDesc->pwszExecutableFilename;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_EXECUTABLEFILENAME,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write ExecutableFilename on pass %i", dwIndex );
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszExecutablePath != NULL)
		{
			pwsz = pdplProgramDesc->pwszExecutablePath;
		}
		else
		{
			pwsz = pwszDefault;
		}
		
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_EXECUTABLEPATH,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write ExecutablePath on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszLauncherFilename != NULL)
		{
			pwsz = pdplProgramDesc->pwszLauncherFilename;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_LAUNCHERFILENAME,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write LauncherFilename on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszLauncherPath != NULL)
		{
			pwsz = pdplProgramDesc->pwszLauncherPath;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_LAUNCHERPATH,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write LauncherPath on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (!SubEntry.WriteGUID(DPL_REG_KEYNAME_GUID,pdplProgramDesc->guidApplication))
		{
			DPFX( DPFPREP, 1, "Could not write GUID on pass %i", dwIndex);
			goto LOOP_END;
		}

		fWritten = TRUE;

LOOP_END:

		SubEntry.Close();
		RegistryEntry.Close();
	}

	if( !fWritten )
	{
		DPFERR("Entry could not be written");
		hResultCode = DPNERR_GENERIC;
	}
	else
	{
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	DPLGetProgramDesc
//
//	Entry:		Nothing
//
//	Exit:		DPN_OK
//				DPNERR_BUFFERTOOSMALL
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLGetProgramDesc"

HRESULT DPLGetProgramDesc(GUID *const pGuidApplication,
						  BYTE *const pBuffer,
						  DWORD *const pdwBufferSize)
{
	HRESULT			hResultCode;
	CRegistry		RegistryEntry;
	CRegistry		SubEntry;
	CPackedBuffer	PackedBuffer;
	DWORD			dwEntrySize;
	DWORD           dwRegValueLengths;
    DPL_PROGRAM_DESC	*pdnProgramDesc;
    DWORD           dwValueSize;
	HKEY			hkCurrentHive = NULL;
	BOOL			fFound = FALSE;

	DPFX(DPFPREP, 3,"Parameters: pGuidApplication [0x%p], pBuffer [0x%p], pdwBufferSize [0x%p]",
			pGuidApplication,pBuffer,pdwBufferSize);
	
	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentHive = HKEY_CURRENT_USER;
		}
		else
		{
			hkCurrentHive = HKEY_LOCAL_MACHINE;
		}

		if (!RegistryEntry.Open(hkCurrentHive,DPL_REG_LOCAL_APPL_SUBKEY,TRUE,FALSE,TRUE,DPL_REGISTRY_READ_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );
			continue;
		}

		// Get Application name and GUID from each sub key
		if (!SubEntry.Open(RegistryEntry,pGuidApplication,TRUE,FALSE,TRUE,DPL_REGISTRY_READ_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );			
			continue;
		}

		fFound = TRUE;
		break;

	}

	if( !fFound )
	{
		DPFERR("Entry not found");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DPLGetProgramDesc;
	}

	// Calculate total entry size (structure + data)
	dwEntrySize = sizeof(DPL_PROGRAM_DESC);
	dwRegValueLengths = 0;
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_APPLICATIONNAME,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_COMMANDLINE,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_CURRENTDIRECTORY,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_DESCRIPTION,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_EXECUTABLEFILENAME,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_EXECUTABLEPATH,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_LAUNCHERFILENAME,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_LAUNCHERPATH,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
			
	dwEntrySize += dwRegValueLengths * sizeof( WCHAR );
	DPFX(DPFPREP, 7,"dwEntrySize [%ld]",dwEntrySize);

	// If supplied buffer sufficient, use it
	if (dwEntrySize <= *pdwBufferSize)
	{
		PackedBuffer.Initialize(pBuffer,*pdwBufferSize);

		pdnProgramDesc = static_cast<DPL_PROGRAM_DESC*>(PackedBuffer.GetHeadAddress());
		PackedBuffer.AddToFront(NULL,sizeof(DPL_PROGRAM_DESC));

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszApplicationName = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_APPLICATIONNAME,
				pdnProgramDesc->pwszApplicationName,&dwValueSize))
		{
		    DPFERR( "Unable to get application name for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszApplicationName = NULL;
		}
		
		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszCommandLine = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_COMMANDLINE,
				pdnProgramDesc->pwszCommandLine,&dwValueSize))
		{
		    DPFERR( "Unable to get commandline for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszCommandLine = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszCurrentDirectory = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_CURRENTDIRECTORY,
				pdnProgramDesc->pwszCurrentDirectory,&dwValueSize))
		{
		    DPFERR( "Unable to get current directory filename for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszCurrentDirectory = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszDescription = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_DESCRIPTION,
				pdnProgramDesc->pwszDescription,&dwValueSize))
		{
		    DPFERR( "Unable to get description for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszDescription = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszExecutableFilename = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_EXECUTABLEFILENAME,
				pdnProgramDesc->pwszExecutableFilename,&dwValueSize))
		{
		    DPFERR( "Unable to get executable filename for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszExecutableFilename = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszExecutablePath = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_EXECUTABLEPATH,
				pdnProgramDesc->pwszExecutablePath,&dwValueSize))
		{
		    DPFERR( "Unable to get executable path for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;		    
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszExecutablePath = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszLauncherFilename = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_LAUNCHERFILENAME,
				pdnProgramDesc->pwszLauncherFilename,&dwValueSize))
		{
		    DPFERR( "Unable to get launcher filename for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszLauncherFilename = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszLauncherPath = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_LAUNCHERPATH,
				pdnProgramDesc->pwszLauncherPath,&dwValueSize))
		{
		    DPFERR( "Unable to get launcher path for entry" );
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszLauncherPath = NULL;
		}

		pdnProgramDesc->dwSize = sizeof(DPL_PROGRAM_DESC);
		pdnProgramDesc->dwFlags = 0;
		pdnProgramDesc->guidApplication = *pGuidApplication;

		hResultCode = DPN_OK;
	}
	else
	{
	    hResultCode = DPNERR_BUFFERTOOSMALL;
	}

    SubEntry.Close();
	RegistryEntry.Close();

	if (hResultCode == DPN_OK || hResultCode == DPNERR_BUFFERTOOSMALL)
	{
		*pdwBufferSize = dwEntrySize;
	}

EXIT_DPLGetProgramDesc:

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplreg.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLReg.h
 *  Content:    DirectPlay Lobby Registry Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   05/03/00	rmt		UnRegister was not implemented!  Implementing! 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLREG_H__
#define	__DPLREG_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define DPL_REG_LOCAL_APPL_ROOT				L"Software\\Microsoft\\DirectPlay8"
#define DPL_REG_LOCAL_APPL_SUB				L"\\Applications"
#define	DPL_REG_LOCAL_APPL_SUBKEY			DPL_REG_LOCAL_APPL_ROOT DPL_REG_LOCAL_APPL_SUB
#define	DPL_REG_KEYNAME_APPLICATIONNAME		L"ApplicationName"
#define	DPL_REG_KEYNAME_COMMANDLINE			L"CommandLine"
#define	DPL_REG_KEYNAME_CURRENTDIRECTORY	L"CurrentDirectory"
#define	DPL_REG_KEYNAME_DESCRIPTION			L"Description"
#define	DPL_REG_KEYNAME_EXECUTABLEFILENAME	L"ExecutableFilename"
#define	DPL_REG_KEYNAME_EXECUTABLEPATH		L"ExecutablePath"
#define	DPL_REG_KEYNAME_GUID				L"GUID"
#define	DPL_REG_KEYNAME_LAUNCHERFILENAME	L"LauncherFilename"
#define	DPL_REG_KEYNAME_LAUNCHERPATH		L"LauncherPath"

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DPLWriteProgramDesc(DPL_PROGRAM_DESC *const pdplProgramDesc);

HRESULT DPLDeleteProgramDesc( const GUID * const pGuidApplication );

HRESULT DPLGetProgramDesc(GUID *const pGuidApplication,
						  BYTE *const pBuffer,
						  DWORD *const pdwBufferSize);


#endif	// __DPLREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplproc.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLProc.h
 *  Content:    DirectPlay Lobby Process Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLPROC_H__
#define	__DPLPROC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL DPLCompareFilenames(WCHAR *const pwszFilename1,
						 WCHAR *const pwszFilename2);

HRESULT DPLGetProcessList(WCHAR *const pwszProcess,
						  DWORD *const prgdwPid,
						  DWORD *const pdwNumProcesses);


#endif	// __DPLPROC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dpnlobbyextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnlobbyextern.h
 *  Content:    DirectPlay Lobby Library external functions to be called
 *              by other DirectPlay components.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	 07/20/2001	masonb	Created
 *
 ***************************************************************************/

BOOL DNLobbyInit(HANDLE hModule);
void DNLobbyDeInit();
#ifndef DPNBUILD_NOCOMREGISTER
BOOL DNLobbyRegister(LPCWSTR wszDLLName);
BOOL DNLobbyUnRegister();
#endif // !DPNBUILD_NOCOMREGISTER
#ifndef DPNBUILD_LIBINTERFACE
DWORD DNLobbyGetRemainingObjectCount();

extern IClassFactoryVtbl DPLCF_Vtbl;
#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplproc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLProc.cpp
 *  Content:    DirectPlay Lobby Process Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   05/08/00   rmt     Bug #33616 -- Does not run on Win9X
 *   06/28/00	rmt		Prefix Bug #38082
 *   07/12/00	rmt		Fixed lobby launch so only compares first 15 chars (ToolHelp limitation).
 *   08/05/00   RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#define PROCLIST_MAX_PATH		15

#undef DPF_MODNAME
#define DPF_MODNAME "DPLCompareFilenames"

BOOL DPLCompareFilenames(WCHAR *const pwszFilename1,
						 WCHAR *const pwszFilename2)
{
	WCHAR	*p1;
	WCHAR	*p2;

	DNASSERT(pwszFilename1 != NULL);
	DNASSERT(pwszFilename2 != NULL);

	// Skip path
	if ((p1 = wcsrchr(pwszFilename1,L'\\')) == NULL)
		p1 = pwszFilename1;
	else
		p1++;

	if ((p2 = wcsrchr(pwszFilename2,L'\\')) == NULL)
		p2 = pwszFilename2;
	else
		p2++;

//	if (wcsnicmp(p1,p2,dwLen)==0)
//		return(TRUE);
//	return(FALSE);

	/*dwLen = wcslen(p1);

	if (dwLen == 0 || dwLen != wcslen(p2) )
		return(FALSE);

	while(dwLen)
	{
		if (towupper(*p1) != towupper(*p2))
			return(FALSE);

		p1++;
		p2++;
		dwLen--;
	}*/

	return (_wcsnicmp(p1,p2,PROCLIST_MAX_PATH) == 0);
}




// ToolHelp Function Pointers.
#ifdef WINCE
typedef BOOL (WINAPI *PFNPROCESS32FIRSTW)(HANDLE,LPPROCESSENTRY32);
typedef BOOL (WINAPI *PFNPROCESS32NEXTW)(HANDLE,LPPROCESSENTRY32);
#else
typedef BOOL (WINAPI *PFNPROCESS32FIRSTW)(HANDLE,LPPROCESSENTRY32W);
typedef BOOL (WINAPI *PFNPROCESS32NEXTW)(HANDLE,LPPROCESSENTRY32W);
#endif // WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "DPLGetProcessList"

HRESULT DPLGetProcessList(WCHAR *const pwszProcess,
						  DWORD *const prgdwPid,
						  DWORD *const pdwNumProcesses)
{
	HRESULT			hResultCode;
	BOOL			bReturnCode;
	HANDLE			hSnapshot = NULL;	// System snapshot
	PROCESSENTRY32	processEntry;
	DWORD			dwNumProcesses;
	PWSTR			pwszExeFile = NULL;
	DWORD			dwExeFileLen;

	DPFX(DPFPREP, 3,"Parameters: pwszProcess [0x%p], prgdwPid [0x%p], pdwNumProcesses [0x%p]",
			pwszProcess,prgdwPid,pdwNumProcesses);

	// Set up to run through process list
	hResultCode = DPN_OK;
	dwNumProcesses = 0;
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS|TH32CS_SNAPTHREAD,0);
	if (hSnapshot < 0)
	{
		DPFERR("Could not create Snapshot");
    	hResultCode = DPNERR_OUTOFMEMORY;
    	goto CLEANUP_GETPROCESS; 		
	}

	// Search SnapShot for process list
	dwExeFileLen = 0;
	pwszExeFile = NULL;

    processEntry.dwSize = sizeof(PROCESSENTRY32);

    bReturnCode = Process32First(hSnapshot,&processEntry);	

	DPFX(DPFPREP, 7,"  dwSize  cntUsg       PID  cntThrds      PPID       PCB    Flags  Process");

	while (bReturnCode)
	{
#ifdef UNICODE
		pwszExeFile = processEntry.szExeFile;
#else
		// Grow ANSI string as required
		if (strlen(processEntry.szExeFile) + 1 > dwExeFileLen)
		{
			if (pwszExeFile)
				DNFree(pwszExeFile);

			dwExeFileLen = strlen(processEntry.szExeFile) + 1;
			if ((pwszExeFile = static_cast<WCHAR*>(DNMalloc(dwExeFileLen * sizeof(WCHAR)))) == NULL)
			{
				DPFERR("Could not allocate filename conversion buffer");
				hResultCode = DPNERR_OUTOFMEMORY;
				goto CLEANUP_GETPROCESS;
			}
		}

        if( FAILED( STR_jkAnsiToWide( pwszExeFile, processEntry.szExeFile, dwExeFileLen ) ) )
        {
            DPFERR( "Error converting ANSI filename to Unicode" );
            hResultCode = DPNERR_CONVERSION;
            goto CLEANUP_GETPROCESS;
        }
#endif // !UNICODE

		// Valid process ?
		if (DPLCompareFilenames(pwszProcess,pwszExeFile))
		{
			// Update lpdwProcessIdList array
			if (prgdwPid != NULL && dwNumProcesses < *pdwNumProcesses)
			{
   				prgdwPid[dwNumProcesses] = processEntry.th32ProcessID;
			}
			else
			{
				hResultCode = DPNERR_BUFFERTOOSMALL;
			}

			// Increase valid process count
			dwNumProcesses++;

			DPFX(DPFPREP, 7,"%8lx    %4lx  %8lx      %4lx  %8lx  %8lx  %8lx  %hs",
    			processEntry.dwSize,processEntry.cntUsage,processEntry.th32ProcessID,
    			processEntry.cntThreads,processEntry.th32ParentProcessID,
    			processEntry.pcPriClassBase,processEntry.dwFlags,processEntry.szExeFile);
		}
		// Get next process

       	bReturnCode = Process32Next(hSnapshot,&processEntry);	
	}

	if( *pdwNumProcesses < dwNumProcesses )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}
	
	*pdwNumProcesses = dwNumProcesses;

CLEANUP_GETPROCESS:

    if( hSnapshot != NULL )
	{
#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
        CloseToolhelp32Snapshot(hSnapshot);
#else // !WINCE
		CloseHandle(hSnapshot);
#endif // WINCE
	}

#ifndef UNICODE
	if (pwszExeFile)
	{
		DNFree(pwszExeFile);
	}
#endif // UNICODE

	return hResultCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\sources.inc ===
TARGETNAME=dpnlobby
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnlobbyi.h
PRECOMPILED_PCH=dnlobbyi.pch
PRECOMPILED_OBJ=dnlobbyi.obj

INCLUDES=..\;..\..\inc;..\..\common;..\..\core;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=dplclassfac.cpp \
	dpldllmain.cpp \
	dplapp.cpp \
	dplclient.cpp \
	dplcommon.cpp \
        dplconnect.cpp \
	dplmsgq.cpp \
	dplproc.cpp \
	dplreg.cpp \
        dplglobals.cpp \
	dplconset.cpp \
        dplparam.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\command.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Command.cpp
 *  Content:	This file contains code which implements assorted APIs for the
 *				DirectPlay protocol.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98    ejs     Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/*
**	Update
**
**	Update an SP about host migration
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPUpdate"

HRESULT
DNPUpdateListen(HANDLE hProtocolData,HANDLE hEndPt,DWORD dwFlags)
{
	ProtocolData	*pPData;
	MSD				*pMSD;
	HRESULT			hr=DPNERR_INVALIDFLAGS;
	SPUPDATEDATA	UpdateData;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hEndPt[%p], dwFlags[%p]",hProtocolData,hEndPt,dwFlags);

	DNASSERT(hProtocolData != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT( ! ((dwFlags & DN_UPDATELISTEN_ALLOWENUMS) && (dwFlags & DN_UPDATELISTEN_DISALLOWENUMS)) );

	pPData = (ProtocolData*) hProtocolData;

	pMSD = (MSD*) hEndPt;
	ASSERT_MSD( pMSD );

	DNASSERT( pMSD->pSPD );

	UpdateData.hEndpoint = pMSD->hListenEndpoint;

	if (dwFlags & DN_UPDATELISTEN_HOSTMIGRATE)
	{
		UpdateData.UpdateType = SP_UPDATE_HOST_MIGRATE;
		hr = IDP8ServiceProvider_Update(pMSD->pSPD->IISPIntf,&UpdateData);
	}
	if (dwFlags & DN_UPDATELISTEN_ALLOWENUMS)
	{
		UpdateData.UpdateType = SP_UPDATE_ALLOW_ENUMS;
		hr = IDP8ServiceProvider_Update(pMSD->pSPD->IISPIntf,&UpdateData);
	}
	if (dwFlags & DN_UPDATELISTEN_DISALLOWENUMS)
	{
		UpdateData.UpdateType = SP_UPDATE_DISALLOW_ENUMS;
		hr = IDP8ServiceProvider_Update(pMSD->pSPD->IISPIntf,&UpdateData);
	}

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x]",hr);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return( hr );
}


/*
**		Cancel Command
**
**			This procedure is passed a HANDLE returned from a previous asynchronous
**	DPLAY command.  At the moment,  the handle is a pointer to an internal data
**	structure.  Problem with this is that due to FPM's (fixed pool manager) design
**	they will get recycled very quickly and frequently.  We might want to map them
**	into an external handle table which will force them to recycle much more slowly.
**	Perhaps,  I will let the upper DN layer do this mapping...
**
**		Anyway,  the only check I can do right now is that the HANDLE is currently
**	allocated to something.
**
**		We do not expect cancels to happen very often.  Therefore,  I do not feel
**	bad about walking the global command list to find the Handle.  Of course,  if
**	we do go to a handle mapped system then we should not need to do this walk.
**
**	I THINK - That any cancellable command will be on either MessageList or TimeoutList!
**
**		Things we can cancel and their possible states:
**
**		SEND Datagram
**			On SPD Send Queue
**			On EPD Send Queue
**			In SP call
**			
**		SEND Reliable
**			We can only cancel if it has not started transmitting.  Once its started, the
**				user program must Abort the link to cancel the send.
**
**		CONNECT
**			In SP call
**			On PD list
**
**		LISTEN
**			In SP call
**			On PD list
**
**		Remember,  if we cancel a command in SP then the CommandComplete is supposed to
**	occur.  This means that we should not have to explicitly free the MSD, etc in these
**	cases.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "DNPCancelCommand"

HRESULT 
DNPCancelCommand(HANDLE hProtocolData, HANDLE hCommand)
{
	ProtocolData* pPData;
	PMSD pMSD;
	HRESULT hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hCommand[%p]", hProtocolData, hCommand);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pMSD = (PMSD) hCommand;
	ASSERT_MSD(pMSD);

	Lock(&pMSD->CommandLock);								// Take this early to freeze state of command
	
	// validate instance of MSD
	ASSERT(pMSD->lRefCnt != -1);

	hr = DoCancel(pMSD, DPNERR_USERCANCEL); // Releases CommandLock

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x], pMSD[%p]", hr, pMSD);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}


/*
**		Do Cancel
**
**		This function implements the meat of the cancel asynch operation.  It gets called from
**	two places.  Either from the User cancel API right above,  or from the global timeout handler.
**
**	***This code requires the MSD->CommandLock to be help upon entry, unlocks upon return
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DoCancel"

HRESULT
DoCancel(PMSD pMSD, HRESULT CompletionCode)
{
	PEPD	pEPD;
	HRESULT	hr = DPN_OK;

	DPFX(DPFPREP,7, "Cancelling pMSD=%p", pMSD);

	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	// The MSD better not be back in the pool or our ref counts are wrong
	ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_USE);

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE))
	{
		DPFX(DPFPREP,7, "(%p) MSD is Cancelled or Complete, returning DPNERR_CANNOTCANCEL, pMSD[%p]", pMSD->pEPD, pMSD);
		Unlock(&pMSD->CommandLock);
		return DPNERR_CANNOTCANCEL;
	}

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_CANCELLED;
	
	switch(pMSD->CommandID)
	{
		case COMMAND_ID_SEND_DATAGRAM:
		case COMMAND_ID_SEND_RELIABLE:
		
			pEPD = pMSD->pEPD;
			ASSERT_EPD(pEPD);
			
			Lock(&pEPD->EPLock);
			
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_ABORT | MFLAGS_TWO_TRANSMITTING | MFLAGS_TWO_SEND_COMPLETE))
			{				
				DPFX(DPFPREP,7, "(%p) MSD is Aborted, Transmitting, or Complete, returning DPNERR_CANNOTCANCEL, pMSD[%p]", pEPD, pMSD);
				Unlock(&pEPD->EPLock);					// Link is dropping or DNET is terminating
				hr = DPNERR_CANNOTCANCEL;						// To cancel an xmitting reliable send you
				break;											// must Abort the connection.
			}

			
			pMSD->blQLinkage.RemoveFromList();							// Remove cmd from queue

			ASSERT(pEPD->uiQueuedMessageCount > 0);
			--pEPD->uiQueuedMessageCount;								// keep count of MSDs on all send queues

			// Clear data-ready flag if everything is sent
			if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
			{	
				pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
			}

#ifdef DBG
			ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
			pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif // DBG

			ASSERT(pEPD->pCurrentSend != pMSD);
			pMSD->uiFrameCount = 0;

			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Send cancelled before sending, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

			Unlock(&pEPD->EPLock);

			if (pMSD->CommandID == COMMAND_ID_SEND_DATAGRAM)
			{
				DPFX(DPFPREP,7, "(%p) Completing(cancel) Nonreliable send, pMSD[%p]", pEPD, pMSD);
				CompleteDatagramSend(pMSD->pSPD, pMSD, CompletionCode); // Releases CommandLock
			}
			else
			{
				ASSERT(pMSD->CommandID == COMMAND_ID_SEND_RELIABLE);

				DPFX(DPFPREP,7, "(%p) Completing(cancel) Reliable Send, pMSD[%p]", pEPD, pMSD);
				CompleteReliableSend(pMSD->pSPD, pMSD, CompletionCode); // Releases CommandLock
			}			

			return hr;
			
		case COMMAND_ID_CONNECT:
#ifndef DPNBUILD_NOMULTICAST
		case COMMAND_ID_CONNECT_MULTICAST_SEND:
		case COMMAND_ID_CONNECT_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
			
			if(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER)
			{
				// SP owns the command - issue a cancel and let CompletionEvent clean up command
				
				Unlock(&pMSD->CommandLock);				// We could deadlock if we cancel with lock held

				AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

				DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on Connect, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
				(void) IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
				
				// If the SP Cancel fails it should not matter.  It would usually mean we are
				// in a race with the command completing,  in which case the cancel flag will
				// nip it in the bud.

				return DPN_OK;
			}

			// We will only get here once because the entry to this function checks CANCEL and COMPLETE and sets
			// CANCEL.  CompleteConnect will set COMPLETE as well.

			pEPD = pMSD->pEPD;
			ASSERT_EPD(pEPD);

			Lock(&pEPD->EPLock);
			
			// Unlink the MSD from the EPD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");

			Unlock(&pMSD->CommandLock); // DropLink may call into the SP.

			DropLink(pEPD); // This unlocks the EPLock

			Lock(&pMSD->CommandLock);

			DPFX(DPFPREP,5, "(%p) Connect cancelled, completing Connect, pMSD[%p]", pEPD, pMSD);
			CompleteConnect(pMSD, pMSD->pSPD, NULL, DPNERR_USERCANCEL); // releases command lock

			return DPN_OK;
			
		case COMMAND_ID_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
		case COMMAND_ID_LISTEN_MULTICAST:
#endif // !DPNBUILD_NOMULTICAST

			/*
			**		Cancel Listen
			**
			**		SP will own parts of the MSD until the SPCommandComplete function is called.  We will
			**	defer much of our cancel processing to this handler.
			*/

			// Stop listening in SP -- This will prevent new connections from popping up while we are
			// closing down any left in progress.  Only problem is we need to release command lock to
			// do it.

			Unlock(&pMSD->CommandLock);								// We can deadlock if we hold across this call

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on Listen, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
			(void) IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);

			Lock(&pMSD->CommandLock);								// Lock this down again.
			
			// Are there any connections in progress?
			// For a Listen command, connecting endpoints are held on the blFrameList
			while(!pMSD->blFrameList.IsEmpty())
			{				
				pEPD = CONTAINING_OBJECT(pMSD->blFrameList.GetNext(), EPD, blSPLinkage);
				ASSERT_EPD(pEPD);

				DPFX(DPFPREP,1, "FOUND CONNECT IN PROGRESS ON CANCELLED LISTEN, EPD=%p", pEPD);

				Lock(&pEPD->EPLock);

				// Ensure we don't stay in this loop forever
				pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
				pEPD->blSPLinkage.RemoveFromList();				// Unlink EPD from Listen Queue

				// It is possible that RejectInvalidPacket is happening at the same time as this, so guard against us
				// both doing the same clean up and removing the same reference from the MSD.
				if (!(pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING))
				{
					// We know this only happens once because anyone who does it either transitions us to the
					// CONNECTED or TERMINATING state, and also removes us from the Listen list above.

					// Unlink MSD from EPD
					ASSERT(pEPD->pCommand == pMSD);					// This should be pointing back to this listen
					pEPD->pCommand = NULL;
					DECREMENT_MSD(pMSD, "EPD Ref");					// Unlink from EPD and release associated reference

					Unlock(&pMSD->CommandLock); // DropLink may call into the SP.

					DropLink(pEPD); // releases EPLock

					Lock(&pMSD->CommandLock);						// Lock this down again.
				}
				else
				{
					Unlock(&pEPD->EPLock);
				}
			}	// for each connection in progress
			
			RELEASE_MSD(pMSD, "(Base Ref) Release On Cancel");	// release base reference
			
			return DPN_OK;
	
		case COMMAND_ID_ENUM:
		{
			Unlock(&pMSD->CommandLock);

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on Enum, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
			return IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
			
			// We will pass HRESULT from SP directly to user
		}
		case COMMAND_ID_ENUMRESP:			
		{
			Unlock(&pMSD->CommandLock);

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on EnumResp, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
			return IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
			
			// We will pass HRESULT from SP directly to user
		}

		case COMMAND_ID_DISCONNECT:					// Core guarantees not to cancel a disconnect
		case COMMAND_ID_COPIED_RETRY:				// This should be on FMD's only
		case COMMAND_ID_COPIED_RETRY_COALESCE:		// This should be on FMD's only
		case COMMAND_ID_CFRAME:						// This should be on FMD's only
		case COMMAND_ID_DISC_RESPONSE:				// These are never placed on the global list and aren't cancellable
		case COMMAND_ID_KEEPALIVE:					// These are never placed on the global list and aren't cancellable
		default:
			ASSERT(0);		// Should never get here
			hr = DPNERR_CANNOTCANCEL;
			break;
	}

	Unlock(&pMSD->CommandLock);
	
	return hr;
}


/*
**		Get Listen Info
**
**		Return a buffer full of interesting and provocative tidbits about a particular Listen command.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetListenAddressInfo"

HRESULT
DNPGetListenAddressInfo(HANDLE hProtocolData, HANDLE hListen, PSPGETADDRESSINFODATA pSPData)
{
	ProtocolData*	pPData;
	PMSD			pMSD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hListen[%p], pSPData[%p]", hProtocolData, hListen, pSPData);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pMSD = (PMSD)hListen;
	ASSERT_MSD(pMSD);

#ifndef DPNBUILD_NOMULTICAST
	ASSERT(((pMSD->CommandID == COMMAND_ID_LISTEN) || (pMSD->CommandID == COMMAND_ID_LISTEN_MULTICAST)) && (pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER));
#else // DPNBUILD_NOMULTICAST
	ASSERT(((pMSD->CommandID == COMMAND_ID_LISTEN)) && (pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER));
#endif // ! DPNBUILD_NOMULTICAST

	pSPData->hEndpoint = pMSD->hListenEndpoint;

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->GetAddressInfo, pMSD[%p], hEndpoint[%x], pSPD[%p]", pMSD, pMSD->hListenEndpoint, pMSD->pSPD);
	return IDP8ServiceProvider_GetAddressInfo(pMSD->pSPD->IISPIntf, pSPData);
}

/*
**		Disconnect End Point
**
**		This function is called when the client no longer wishes
**	to communicate with the specified end point.  We will initiate
**	the disconnect protocol with the endpoint,  and when it is
**	acknowleged,  we will disconnect the SP and release the handle.
**
**		Disconnect is defined in Direct Net to allow all previously
**	submitted sends to complete,  but no additional sends to be submitted.
**	Also, any sends the partner has in progress will be delivered,  but
**	no additional sends will be accepted following the indication that
**	a disconnect is in progress on the remote end.
**
**		This implies that two indications will be generated on the remote
**	machine,  Disconnect Initiated and Disconnect Complete.  Only the
**	Complete will be indicated on the issueing side.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPDisconnectEndPoint"

HRESULT
DNPDisconnectEndPoint(HANDLE hProtocolData, HANDLE hEndPoint, VOID* pvContext, HANDLE* phDisconnect, const DWORD dwFlags)
{
	ProtocolData*	pPData;
	PEPD			pEPD;
	PMSD			pMSD;
	HRESULT			hr;
	
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hEndPoint[%x], pvContext[%p], phDisconnect[%p] dwFlags[%u]",
																				hProtocolData, hEndPoint, pvContext, phDisconnect, dwFlags);

	hr = DPNERR_PENDING;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pEPD = (PEPD) hEndPoint;
	ASSERT_EPD(pEPD);

	LOCK_EPD(pEPD, "LOCK (DISCONNECT)");

	Lock(&pEPD->EPLock);

	// If we aren't connected, or we have already initiated a disconnect, don't allow a new disconnect
	if(	(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED) ==0 || 
		(pEPD->ulEPFlags & (EPFLAGS_SENT_DISCONNECT | EPFLAGS_RECEIVED_DISCONNECT 
											| EPFLAGS_HARD_DISCONNECT_SOURCE | EPFLAGS_HARD_DISCONNECT_TARGET)))
	{
		RELEASE_EPD(pEPD, "UNLOCK (Validate EP)"); // Releases EPLock

		DPFX(DPFPREP,1, "Attempt to disconnect already disconnecting endpoint");
		hr = DPNERR_ALREADYDISCONNECTING;
		goto Exit;
	}

		//if the disconnect should be a hard one, then we want to effectively put the endpoint into
		//stasis. We'll free and sends and recvs, cancel all its timers and just sit around long
		//enough to fire off the disconnect frame 3 times
	if (dwFlags & DN_DISCONNECTFLAGS_IMMEDIATE)
	{
			//setting this flag ensures that any incoming frames for the endpoint (other than hard disconnects) 
			//are instantly discarded from this point on
		pEPD->ulEPFlags |= EPFLAGS_HARD_DISCONNECT_SOURCE;
		DNASSERT((pEPD->ulEPFlags2 & EPFLAGS2_HARD_DISCONNECT_COMPLETE)==0);
			//core will never cancel a disconnect so store a NULL command handle
			//if they do try and cancel this we will assert
		*phDisconnect=NULL;
			//store the context we need to complete the disconnect with
		pEPD->pvHardDisconnectContext=pvContext;
			//all following calls are performed with EPD lock held
		CancelEpdTimers(pEPD);
		AbortRecvsOnConnection(pEPD);
		AbortSendsOnConnection(pEPD);
			//above call will have released EPD lock, so retake it
		Lock(&pEPD->EPLock);
			//setup state to send a sequence of hard disconnect frames
		pEPD->uiNumRetriesRemaining=pPData->dwNumHardDisconnectSends-1;
		DNASSERT(pEPD->uiNumRetriesRemaining>0);
		DWORD dwRetryPeriod = pEPD->uiRTT/2;
		if (dwRetryPeriod>pPData->dwMaxHardDisconnectPeriod)
			dwRetryPeriod=pPData->dwMaxHardDisconnectPeriod;
		else if (dwRetryPeriod<MIN_HARD_DISCONNECT_PERIOD)
			dwRetryPeriod=MIN_HARD_DISCONNECT_PERIOD;
		hr=ScheduleProtocolTimer(pEPD->pSPD, dwRetryPeriod, 10, HardDisconnectResendTimeout, pEPD, 
																&pEPD->LinkTimer, &pEPD->LinkTimerUnique);
			//if we fail to schedule a timer we've only got one chance to send a hard disconnect frame, so make it the last
		ULONG ulFFlags;
		if (FAILED(hr))
		{
			ulFFlags=FFLAGS_FINAL_HARD_DISCONNECT;
		}
			//if we did schedule a timer we need to take a reference on the endpoint, which is kept until the timer
			//completes or is cancelled
		else
		{
			ulFFlags=0;
			LOCK_EPD(pEPD, "LOCK (Hard Disconnect Resend Timer)");
		}
		hr=SendCommandFrame(pEPD, FRAME_EXOPCODE_HARD_DISCONNECT, 0, ulFFlags, TRUE);
			//above call will have released EPD lock
			//if we failed to set a timer, then at a minimum we need to drop a reference to the ep
		if (ulFFlags==FFLAGS_FINAL_HARD_DISCONNECT)
		{
			Lock(&pEPD->EPLock);
				//if we also failed to send the hard disconnect frame then we have to complete the
				//disconnect here, since we're not going to get another chance
			if (FAILED(hr))
			{
				CompleteHardDisconnect(pEPD);
					//above call will have release EP lock
				DPFX(DPFPREP,0, "Failed to set timer to schedule hard disconnect sends. hr[%x]", hr);
				hr = DPNERR_OUTOFMEMORY;
			}
			else
			{
				DPFX(DPFPREP,0, "Failed to set timer to schedule hard disconnect sends but sent final hard disconnect frame. hr[%x]", hr);
				hr = DPNERR_PENDING;
			}
		}
		else
		{
			if (FAILED(hr))
			{
				DPFX(DPFPREP,0, "Failed to send hard disconnect frame but scheduled timer for future sends. hr[%x]", hr);
			}
			else
			{
				DPFX(DPFPREP,7, "Sent first hard disconnect frame and scheduled timer for future sends. dwRetryPeriod[%u]", dwRetryPeriod);
			}
			hr = DPNERR_PENDING;
		}
		goto Exit;
	}

		//Its a normal disconnect, rather than a hard disconnect
		//Accept no more sends, but don't scrap link yet
	pEPD->ulEPFlags |= EPFLAGS_SENT_DISCONNECT; 

#ifndef DPNBUILD_NOMULTICAST
	if (pEPD->ulEPFlags2 & (EPFLAGS2_MULTICAST_SEND|EPFLAGS2_MULTICAST_RECEIVE))
	{
		pEPD->ulEPFlags |= EPFLAGS_STATE_TERMINATING;

		//
		//	Create an MSD for the disconnect
		//
		if((pMSD = (PMSD)POOLALLOC(MEMID_MCAST_DISCONNECT_MSD, &MSDPool)) == NULL)
		{
			RELEASE_EPD(pEPD, "UNLOCK (Allocation failed)"); // Releases EPLock

			DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
			hr = DPNERR_OUTOFMEMORY;	
			goto Exit;
		}

		pMSD->pSPD = pEPD->pSPD;
		pMSD->pEPD = pEPD;
	}
	else
#endif	// DPNBUILD_NOMULTICAST
	{
		if((pMSD = BuildDisconnectFrame(pEPD)) == NULL)
		{
			DropLink(pEPD); // releases EPLock

			Lock(&pEPD->EPLock);
			RELEASE_EPD(pEPD, "UNLOCK (Validate EP)"); // releases EPLock

			DPFX(DPFPREP,0, "Failed to build disconnect frame");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}
	}
	
	pMSD->CommandID = COMMAND_ID_DISCONNECT;
	pMSD->Context = pvContext;									// retain user's context value
	*phDisconnect = pMSD;										// pass back command handle

	// We borrow the reference placed above by ValidateEP for this.  It will be released
	// on completion of the Disconnect.
	ASSERT(pEPD->pCommand == NULL);
	pEPD->pCommand = pMSD;										// Store the disconnect command on the endpoint until it is complete

#ifdef DBG
	Lock(&pMSD->pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pMSD->pSPD->SPLock);
#endif // DBG

#ifndef DPNBUILD_NOMULTICAST
	if (pEPD->ulEPFlags2 & (EPFLAGS2_MULTICAST_SEND|EPFLAGS2_MULTICAST_RECEIVE))
	{
		DECREMENT_EPD(pEPD,"Cleanup Multicast");
		RELEASE_EPD(pEPD, "UNLOCK (Validate EP)"); // Releases EPLock
	}
	else
#endif	// DPNBUILD_NOMULTICAST
	{
		DPFX(DPFPREP,5, "(%p) Queueing DISCONNECT message", pEPD);
		EnqueueMessage(pMSD, pEPD);									// Enqueue Disc frame on SendQ

		Unlock(&pEPD->EPLock);
	}

Exit:
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x]", hr);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}

/*
**		Get/Set Protocol Caps
**
**		Return or Set information about the entire protocol.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetProtocolCaps"

HRESULT
DNPGetProtocolCaps(HANDLE hProtocolData, DPN_CAPS* pCaps)
{
	ProtocolData*	pPData;
	
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], pCaps[%p]", hProtocolData, pCaps);
	
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	ASSERT(pCaps->dwSize == sizeof(DPN_CAPS) || pCaps->dwSize == sizeof(DPN_CAPS_EX));
	ASSERT(pCaps->dwFlags == 0);

	pCaps->dwConnectTimeout = pPData->dwConnectTimeout;
	pCaps->dwConnectRetries = pPData->dwConnectRetries;
	pCaps->dwTimeoutUntilKeepAlive = pPData->tIdleThreshhold;

	if (pCaps->dwSize==sizeof(DPN_CAPS_EX))
	{
		DPN_CAPS_EX * pCapsEx=(DPN_CAPS_EX * ) pCaps;
		pCapsEx->dwMaxRecvMsgSize=pPData->dwMaxRecvMsgSize;
		pCapsEx->dwNumSendRetries=pPData->dwSendRetriesToDropLink;
		pCapsEx->dwMaxSendRetryInterval=pPData->dwSendRetryIntervalLimit;
		pCapsEx->dwDropThresholdRate = pPData->dwDropThresholdRate;
		pCapsEx->dwThrottleRate = pPData->dwThrottleRate;
		pCapsEx->dwNumHardDisconnectSends = pPData->dwNumHardDisconnectSends;
		pCapsEx->dwMaxHardDisconnectPeriod=pPData->dwMaxHardDisconnectPeriod;
	}
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNPSetProtocolCaps"

HRESULT
DNPSetProtocolCaps(HANDLE hProtocolData, DPN_CAPS* pCaps)
{
	ProtocolData*	pPData;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], pCaps[%p]", hProtocolData, pCaps);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	ASSERT(pCaps->dwSize == sizeof(DPN_CAPS) || pCaps->dwSize == sizeof(DPN_CAPS_EX));
	ASSERT(pCaps->dwFlags == 0);
	
	pPData->dwConnectTimeout = pCaps->dwConnectTimeout;
	pPData->dwConnectRetries = pCaps->dwConnectRetries;
	pPData->tIdleThreshhold = pCaps->dwTimeoutUntilKeepAlive;

	if (pCaps->dwSize==sizeof(DPN_CAPS_EX))
	{
		DPN_CAPS_EX * pCapsEx=(DPN_CAPS_EX * ) pCaps;

		pPData->dwMaxRecvMsgSize=pCapsEx->dwMaxRecvMsgSize;

		pPData->dwSendRetriesToDropLink=pCapsEx->dwNumSendRetries;
		if (pPData->dwSendRetriesToDropLink>MAX_SEND_RETRIES_TO_DROP_LINK)
		{
			pPData->dwSendRetriesToDropLink=MAX_SEND_RETRIES_TO_DROP_LINK;
		}

		pPData->dwSendRetryIntervalLimit=pCapsEx->dwMaxSendRetryInterval;
		if (pPData->dwSendRetryIntervalLimit>MAX_SEND_RETRY_INTERVAL_LIMIT)
		{
			pPData->dwSendRetryIntervalLimit=MAX_SEND_RETRY_INTERVAL_LIMIT;
		}
		else if (pPData->dwSendRetryIntervalLimit<MIN_SEND_RETRY_INTERVAL_LIMIT)
		{
			pPData->dwSendRetryIntervalLimit=MIN_SEND_RETRY_INTERVAL_LIMIT;
		}
		pPData->dwDropThresholdRate = pCapsEx->dwDropThresholdRate;
		if (pPData->dwDropThresholdRate > 100)
		{
			pPData->dwDropThresholdRate = 100;
		}
		pPData->dwDropThreshold = (32 * pPData->dwDropThresholdRate) / 100;

		pPData->dwThrottleRate = pCapsEx->dwThrottleRate;
		if (pPData->dwThrottleRate > 100)
		{
			pPData->dwThrottleRate = 100;
		}
		pPData->fThrottleRate = ((FLOAT)100.0 - (FLOAT)(pPData->dwThrottleRate)) / (FLOAT)100.0;

		pPData->dwNumHardDisconnectSends=pCapsEx->dwNumHardDisconnectSends;
		if (pPData->dwNumHardDisconnectSends>MAX_HARD_DISCONNECT_SENDS)
		{
			pPData->dwNumHardDisconnectSends=MAX_HARD_DISCONNECT_SENDS;
		}
		else if (pPData->dwNumHardDisconnectSends<MIN_HARD_DISCONNECT_SENDS)
		{
			pPData->dwNumHardDisconnectSends=MIN_HARD_DISCONNECT_SENDS;
		}
		pPData->dwMaxHardDisconnectPeriod=pCapsEx->dwMaxHardDisconnectPeriod;
		if (pPData->dwMaxHardDisconnectPeriod>MAX_HARD_DISCONNECT_PERIOD)
		{
			pPData->dwMaxHardDisconnectPeriod=MAX_HARD_DISCONNECT_PERIOD;
		}
		else if (pPData->dwMaxHardDisconnectPeriod<MIN_HARD_DISCONNECT_PERIOD)
		{
			pPData->dwMaxHardDisconnectPeriod=MIN_HARD_DISCONNECT_PERIOD;
		}
		
		
	}

	return DPN_OK;
}

/*
**		Get Endpoint Caps
**
**		Return information and statistics about a particular endpoint.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetEPCaps"

HRESULT
DNPGetEPCaps(HANDLE hProtocolData, HANDLE hEndpoint, DPN_CONNECTION_INFO* pBuffer)
{
	ProtocolData*	pPData;
	PEPD			pEPD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hEndpoint[%p], pBuffer[%p]", hProtocolData, hEndpoint, pBuffer);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pEPD = (PEPD)hEndpoint;
	ASSERT_EPD(pEPD);

	// This occurs when DropLink has been called, but the Core has not yet been given
	// an IndicateConnectionTerminated.
	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{
		DPFX(DPFPREP,0, "Returning DPNERR_INVALIDENDPOINT - Enpoint is not connected");
		return DPNERR_INVALIDENDPOINT;
	}

	ASSERT(pBuffer != NULL);

	ASSERT(pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO) || 
			pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO_INTERNAL) ||
			pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO_INTERNAL2));
		
    pBuffer->dwRoundTripLatencyMS = pEPD->uiRTT;
    pBuffer->dwThroughputBPS = pEPD->uiPeriodRateB * 4;				// Convert to apx of bytes/second (really bytes/1024 ms)
    pBuffer->dwPeakThroughputBPS = pEPD->uiPeakRateB * 4;

	pBuffer->dwBytesSentGuaranteed = pEPD->uiGuaranteedBytesSent;
	pBuffer->dwPacketsSentGuaranteed = pEPD->uiGuaranteedFramesSent;
	pBuffer->dwBytesSentNonGuaranteed = pEPD->uiDatagramBytesSent;
	pBuffer->dwPacketsSentNonGuaranteed = pEPD->uiDatagramFramesSent;

	pBuffer->dwBytesRetried = pEPD->uiGuaranteedBytesDropped;
	pBuffer->dwPacketsRetried = pEPD->uiGuaranteedFramesDropped;
	pBuffer->dwBytesDropped = pEPD->uiDatagramBytesDropped;
	pBuffer->dwPacketsDropped = pEPD->uiDatagramFramesDropped;

	pBuffer->dwMessagesTransmittedHighPriority = pEPD->uiMsgSentHigh;
	pBuffer->dwMessagesTimedOutHighPriority = pEPD->uiMsgTOHigh;
	pBuffer->dwMessagesTransmittedNormalPriority = pEPD->uiMsgSentNorm;
	pBuffer->dwMessagesTimedOutNormalPriority = pEPD->uiMsgTONorm;
	pBuffer->dwMessagesTransmittedLowPriority = pEPD->uiMsgSentLow;
	pBuffer->dwMessagesTimedOutLowPriority = pEPD->uiMsgTOLow;

	pBuffer->dwBytesReceivedGuaranteed = pEPD->uiGuaranteedBytesReceived;
	pBuffer->dwPacketsReceivedGuaranteed = pEPD->uiGuaranteedFramesReceived;
	pBuffer->dwBytesReceivedNonGuaranteed = pEPD->uiDatagramBytesReceived;
	pBuffer->dwPacketsReceivedNonGuaranteed = pEPD->uiDatagramFramesReceived;
		
	pBuffer->dwMessagesReceived = pEPD->uiMessagesReceived;

	if (pBuffer->dwSize >= sizeof(DPN_CONNECTION_INFO_INTERNAL))
	{
		DPFX(DPFPREP,DPF_CALLIN_LVL, "(%p) Test App requesting extended internal parameters", pEPD);

		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiDropCount = pEPD->uiDropCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiThrottleEvents = pEPD->uiThrottleEvents;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiAdaptAlgCount = pEPD->uiAdaptAlgCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiWindowFilled = pEPD->uiWindowFilled;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiPeriodAcksBytes = pEPD->uiPeriodAcksBytes;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiPeriodXmitTime = pEPD->uiPeriodXmitTime;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->dwLastThroughputBPS = pEPD->uiLastRateB * 4;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiLastBytesAcked = pEPD->uiLastBytesAcked;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiQueuedMessageCount = pEPD->uiQueuedMessageCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiWindowF = pEPD->uiWindowF;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiWindowB = pEPD->uiWindowB;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiUnackedFrames = pEPD->uiUnackedFrames;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiUnackedBytes = pEPD->uiUnackedBytes;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiBurstGap = pEPD->uiBurstGap;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->iBurstCredit = pEPD->iBurstCredit;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodWindowF = pEPD->uiGoodWindowF;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodWindowB = pEPD->uiGoodWindowBI * pEPD->pSPD->uiFrameLength;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodBurstGap = pEPD->uiGoodBurstGap;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodRTT = pEPD->uiGoodRTT;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRestoreWindowF = pEPD->uiRestoreWindowF;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRestoreWindowB = pEPD->uiRestoreWindowBI * pEPD->pSPD->uiFrameLength;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRestoreBurstGap = pEPD->uiRestoreBurstGap;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->bNextSend = pEPD->bNextSend;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->bNextReceive = pEPD->bNextReceive;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulReceiveMask = pEPD->ulReceiveMask;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulReceiveMask2 = pEPD->ulReceiveMask2;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulSendMask = pEPD->ulSendMask;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulSendMask2 = pEPD->ulSendMask2;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiCompleteMsgCount = pEPD->uiCompleteMsgCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRetryTimeout = pEPD->uiRetryTimeout;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulEPFlags = pEPD->ulEPFlags;
	}

	if (pBuffer->dwSize >= sizeof(DPN_CONNECTION_INFO_INTERNAL2))
	{
		DPFX(DPFPREP,DPF_CALLIN_LVL, "(%p) Test App requesting extended internal parameters 2", pEPD);
		((PDPN_CONNECTION_INFO_INTERNAL2)pBuffer)->dwDropBitMask = pEPD->dwDropBitMask;
		#ifdef DBG
		((PDPN_CONNECTION_INFO_INTERNAL2)pBuffer)->uiTotalThrottleEvents = pEPD->uiTotalThrottleEvents;
		#else
		((PDPN_CONNECTION_INFO_INTERNAL2)pBuffer)->uiTotalThrottleEvents = (DWORD ) -1;
		#endif // DBG
	}

	return DPN_OK;
}

/*		
**		Build Disconnect Frame
**
**		Build a DISC frame, a Message actually, because we return an MSD which can be inserted into
**	our reliable stream and will trigger one-side of the disconnect protocol when it is received
**	by a partner.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDisconnectFrame"

PMSD
BuildDisconnectFrame(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;

	// Allocate and fill out a Message Descriptor for this operation
	
	if((pMSD = (PMSD)POOLALLOC(MEMID_DISCONNECT_MSD, &MSDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate MSD");
		return NULL;
	}

	if((pFMD = (PFMD)POOLALLOC(MEMID_DISCONNECT_FMD, &FMDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate FMD");
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Release On FMD Get Failed");
		return NULL;
	}

	// NOTE: Set this to 1 after FMD allocation succeeds
	pMSD->uiFrameCount = 1;
	DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Initialize Frame count, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_END_OF_STREAM;
	pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_LOW_PRIORITY; // Priority is LOW so all previously submitted traffic will be sent
	pMSD->pSPD = pEPD->pSPD;
	pMSD->pEPD = pEPD;

	pFMD->CommandID = COMMAND_ID_SEND_RELIABLE;
	pFMD->ulFFlags |= FFLAGS_END_OF_MESSAGE | FFLAGS_END_OF_STREAM | FFLAGS_DONT_COALESCE;		// Mark this frame as Disconnect
	pFMD->bPacketFlags = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_END_MSG;
	pFMD->uiFrameLength = 0;											// No user data in this frame
	pFMD->blMSDLinkage.InsertAfter( &pMSD->blFrameList);				// Attach frame to MSD
	pFMD->pMSD = pMSD;													// Link frame back to message
	pFMD->pEPD = pEPD;

	return pMSD;
}

/*
**		Abort Sends on Connection
**
**		Walk the EPD's send queues and cancel all sends awaiting service.  We might add
**	code to issue Cancel commands to the SP for frames still owned by SP.  On one hand,
**	we are not expecting a big backlog to develop in SP,  but on the other hand it still
**	might happen.  Esp, if we dont fix behavior I have observed with SP being really pokey
**	about completing transmitted sends.
**
**	**  CALLED WITH EPD->EPLock HELD;  RETURNS WITH LOCK RELEASED  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "AbortSendsOnConnection"

VOID
AbortSendsOnConnection(PEPD pEPD)
{
	PSPD	pSPD = pEPD->pSPD;
	PFMD	pFMD;
	PMSD	pMSD;
	CBilink	*pLink;
	CBilink	TempList;
	PFMD	pRealFMD;

	ASSERT_SPD(pSPD);
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	TempList.Initialize();										// We will empty all send queues onto this temporary list

	do 
	{
		if( (pLink = pEPD->blHighPriSendQ.GetNext()) == &pEPD->blHighPriSendQ)
		{
			if( (pLink = pEPD->blNormPriSendQ.GetNext()) == &pEPD->blNormPriSendQ)
			{
				if( (pLink = pEPD->blLowPriSendQ.GetNext()) == &pEPD->blLowPriSendQ)
				{
					if( (pLink = pEPD->blCompleteSendList.GetNext()) == &pEPD->blCompleteSendList)
					{
						break;										// ALL DONE - No more sends
					}
				}
			}
		}

		// We have found another send on one of our send queues.

		pLink->RemoveFromList();											// Remove it from the queue
		pMSD = CONTAINING_OBJECT(pLink, MSD, blQLinkage);
		ASSERT_MSD(pMSD);
		pMSD->ulMsgFlags2 |= (MFLAGS_TWO_ABORT | MFLAGS_TWO_ABORT_WILL_COMPLETE);	// Do no further processing

#ifdef DBG
		pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif // DBG

		// If this MSD is a Disconnect, it will be caught by the code below that checks
		// pEPD->pCommand.  We don't want to end up putting it on the TempList twice.
		if (pMSD->CommandID != COMMAND_ID_DISCONNECT && pMSD->CommandID != COMMAND_ID_DISC_RESPONSE)
		{
			DPFX(DPFPREP,5, "(%p) ABORT SENDS.  Found (%p)", pEPD, pMSD);

			LOCK_MSD(pMSD, "AbortSends Temp Ref");
			pMSD->blQLinkage.InsertBefore( &TempList);				// Place on the temporary list
		}
	} 
	while (1);

	pEPD->uiQueuedMessageCount = 0;								// keep count of MSDs on all send queues

	if((pMSD = pEPD->pCommand) != NULL)
	{
		// There may be a DISCONNECT command waiting on this special pointer for the final DISC frame
		// from partner to arrive.

		pMSD->ulMsgFlags2 |= (MFLAGS_TWO_ABORT | MFLAGS_TWO_ABORT_WILL_COMPLETE);	// Do no further processing

		if(pMSD->CommandID == COMMAND_ID_DISCONNECT || pMSD->CommandID == COMMAND_ID_DISC_RESPONSE)
		{
			pEPD->pCommand = NULL;

			LOCK_MSD(pMSD, "AbortSends Temp Ref");
			pMSD->blQLinkage.InsertBefore( &TempList);

			// We will be indicating below, so make sure no one else does once we
			// leave the EPLock.
			ASSERT(!(pEPD->ulEPFlags & EPFLAGS_INDICATED_DISCONNECT));

			pEPD->ulEPFlags |= EPFLAGS_INDICATED_DISCONNECT;
		}
		else
		{
			DPFX(DPFPREP,0,"(%p) Any Connect or Listen on pCommand should have already been cleaned up", pEPD);
			ASSERT(!"Any Connect or Listen on pCommand should have already been cleaned up");
		}
	}

	//	If we clear out our SendWindow before we cancel the sends,  then we dont need to differentiate
	//	between sends that have or have not been transmitted.

	while(!pEPD->blSendWindow.IsEmpty())
	{
		pFMD = CONTAINING_OBJECT(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);
		pFMD->ulFFlags &= ~(FFLAGS_IN_SEND_WINDOW);
		pFMD->blWindowLinkage.RemoveFromList();						// Eliminate each frame from the Send Window
		RELEASE_FMD(pFMD, "Send Window");
		DPFX(DPFPREP,5, "(%p) ABORT CONN:  Release frame from Window: pFMD=0x%p", pEPD, pFMD);
	}
	
	pEPD->pCurrentSend = NULL;
	pEPD->pCurrentFrame = NULL;

	while(!pEPD->blRetryQueue.IsEmpty())
	{
		pFMD = CONTAINING_OBJECT(pEPD->blRetryQueue.GetNext(), FMD, blQLinkage);
		ASSERT_FMD(pFMD);
		pFMD->blQLinkage.RemoveFromList();
		pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue

		if ((pFMD->CommandID == COMMAND_ID_SEND_COALESCE) ||
			(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE))
		{
			pLink = pFMD->blCoalesceLinkage.GetNext();
			while (pLink != &pFMD->blCoalesceLinkage)
			{
				pRealFMD = CONTAINING_OBJECT(pLink, FMD, blCoalesceLinkage);
				ASSERT_FMD(pRealFMD);
				ASSERT_MSD(pRealFMD->pMSD);
				pRealFMD->pMSD->uiFrameCount--; // Protected by EPLock, retries count against outstanding frame count
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Coalesced retry frame reference decremented on abort, pMSD[%p], framecount[%u], ID %u", pRealFMD->pMSD, pRealFMD->pMSD->uiFrameCount, pRealFMD->CommandID);

				pLink = pLink->GetNext();

				// If this was a copied retry subframe, remove it from the coalesced list since it will never
				// get a true completion like the originals do (the originals were also in one of the priority
				// send queues).  The release below should be the final reference.
				if (pRealFMD->CommandID == COMMAND_ID_COPIED_RETRY)
				{
					ASSERT(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE);

					DPFX(DPFPREP, 7, "Removing copied retry frame 0x%p from coalesced list (header = 0x%p)", pRealFMD, pFMD);
					// Copied retries don't maintain a reference on their containing header.
					ASSERT(pRealFMD->pCSD == NULL);
					pRealFMD->blCoalesceLinkage.RemoveFromList();
					
					DECREMENT_EPD(pEPD, "UNLOCK (Copy Complete coalesce)"); // SPLock not already held
				}
				else
				{
					ASSERT(pFMD->CommandID == COMMAND_ID_SEND_COALESCE);
				}
				
				RELEASE_FMD(pRealFMD, "SP Submit (coalesce)");
			}
		}
		else
		{
			ASSERT_MSD(pFMD->pMSD);
			pFMD->pMSD->uiFrameCount--; // Protected by EPLock, retries count against outstanding frame count
			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Retry frame reference decremented on abort, pMSD[%p], framecount[%u]", pFMD->pMSD, pFMD->pMSD->uiFrameCount);
		}
		DECREMENT_EPD(pEPD, "UNLOCK (Releasing Retry Frame)"); // SPLock not already held
		if ((pFMD->CommandID == COMMAND_ID_COPIED_RETRY) ||
			(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE))
		{
			DECREMENT_EPD(pEPD, "UNLOCK (Copy Complete)"); // SPLock not already held
		}
		RELEASE_FMD(pFMD, "SP Submit");
	}
	pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
		
	//	Now that we have emptied the EPD's queues we will release the EPLock so we can lock each
	//	MSD before we complete it.
	Unlock(&pEPD->EPLock);

	while(!TempList.IsEmpty())
	{
		pMSD = CONTAINING_OBJECT(TempList.GetNext(), MSD, blQLinkage);
		ASSERT_MSD(pMSD);
		pMSD->blQLinkage.RemoveFromList();					// remove this send from temporary queue

		Lock(&pMSD->CommandLock);							// Complete call will Unlock MSD
		Lock(&pEPD->EPLock);

		ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_USE);
		ASSERT(pMSD->CommandID == COMMAND_ID_DISCONNECT ||
			   pMSD->CommandID == COMMAND_ID_DISC_RESPONSE ||
			   pMSD->CommandID == COMMAND_ID_SEND_RELIABLE ||
			   pMSD->CommandID == COMMAND_ID_KEEPALIVE ||
			   pMSD->CommandID == COMMAND_ID_SEND_DATAGRAM);

		pLink = pMSD->blFrameList.GetNext();
		while (pLink != &pMSD->blFrameList)
		{
			pFMD = CONTAINING_OBJECT(pLink, FMD, blMSDLinkage);
			ASSERT_FMD(pFMD);

			// We don't allow a send to complete to the Core until uiFrameCount goes to zero indicating that all frames
			// of the message are out of the SP.  We need to remove references from uiFrameCount for any frames that 
			// never were transmitted.  Frames and retries that were transmitted will have their references removed in 
			// DNSP_CommandComplete when the SP completes them.
			if (!(pFMD->ulFFlags & FFLAGS_TRANSMITTED))
			{
				pMSD->uiFrameCount--; // Protected by EPLock
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frame count decremented on abort for non-transmitted frame, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
			}

			pLink = pLink->GetNext();
		}
		if (pMSD->uiFrameCount == 0) // Protected by EPLock
		{
			if (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT_WILL_COMPLETE)
			{
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

				DECREMENT_MSD(pMSD, "AbortSends Temp Ref");

				// Decide which completion function to call based on the MSD type
				if (pMSD->CommandID == COMMAND_ID_DISCONNECT || pMSD->CommandID == COMMAND_ID_DISC_RESPONSE)
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing disconnect or disconnect response, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					Unlock(&pEPD->EPLock);
					CompleteDisconnect(pMSD, pSPD, pEPD); // Releases CommandLock
				}
				else if (pMSD->CommandID == COMMAND_ID_SEND_DATAGRAM)
				{
					Unlock(&pEPD->EPLock);
					CompleteDatagramSend(pMSD->pSPD, pMSD, DPNERR_CONNECTIONLOST); // Releases CommandLock
				}
				else
				{
					ASSERT(pMSD->CommandID == COMMAND_ID_SEND_RELIABLE || pMSD->CommandID == COMMAND_ID_KEEPALIVE);
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing Reliable frame, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					// See what error code we need to return
					if(pMSD->ulMsgFlags2 & MFLAGS_TWO_SEND_COMPLETE)
					{
						Unlock(&pEPD->EPLock);
						CompleteReliableSend(pSPD, pMSD, DPN_OK); // This releases the CommandLock
					}
					else
					{
						Unlock(&pEPD->EPLock);
						CompleteReliableSend(pSPD, pMSD, DPNERR_CONNECTIONLOST); // This releases the CommandLock
					}
				}
			}
			else
			{
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "SP Completion has already completed MSD to the Core, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
				Unlock(&pEPD->EPLock);
				RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
			}
		}
		else
		{
			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frames still out, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
			Unlock(&pEPD->EPLock);
			RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
		}
	}
}

/*
**	Protocol Test Functions
**
**	The following functions are used to test the protocol by various test apps.
**
*/

#ifndef DPNBUILD_NOPROTOCOLTESTITF

#undef DPF_MODNAME
#define DPF_MODNAME "SetLinkParms"

VOID SetLinkParms(PEPD pEPD, PINT Data)
{
	if(Data[0])
	{
		pEPD->uiGoodWindowF = pEPD->uiWindowF = Data[0];
		pEPD->uiGoodWindowBI = pEPD->uiWindowBIndex = Data[0];
		
		pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
		DPFX(DPFPREP,7, "** ADJUSTING WINDOW TO %d FRAMES", Data[0]);
	}
	if(Data[1])
	{
	}
	if(Data[2])
	{
		pEPD->uiGoodBurstGap = pEPD->uiBurstGap = Data[2];
		DPFX(DPFPREP,7, "** ADJUSTING GAP TO %d ms", Data[2]);
	}

	pEPD->uiPeriodAcksBytes = 0;
	pEPD->uiPeriodXmitTime = 0;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPDebug"

HRESULT 
DNPDebug(HANDLE hProtocolData, UINT uiOpCode, HANDLE hEndpoint, VOID* pvData)
{
	ProtocolData* pPData;
	PEPD pEPD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], uiOpCode[%d], hEndpoint[%p], pvData[%p]", hProtocolData, uiOpCode, hEndpoint, pvData);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pEPD = (PEPD)hEndpoint;
	if (pEPD != NULL)
	{
		ASSERT_EPD(pEPD);
	}

	switch(uiOpCode)
	{
		case PROTDEBUG_FREEZELINK:
			/* Toggle link frozen state */
			pEPD->ulEPFlags ^= EPFLAGS_LINK_FROZEN;
			break;

		case PROTDEBUG_TOGGLE_KEEPALIVE:
			/* Toggle whether KeepAlives are on or off */
			pEPD->ulEPFlags ^= EPFLAGS_KEEPALIVE_RUNNING;
			break;

		case PROTDEBUG_TOGGLE_ACKS:
			/* Toggle whether delayed acks (via DelayedAckTimeout) are on or off */
			pEPD->ulEPFlags ^= EPFLAGS_NO_DELAYED_ACKS;
			break;

		case PROTDEBUG_SET_ASSERTFUNC:
			/* Set a function to be called when an assert occurs */
			g_pfnAssertFunc = (PFNASSERTFUNC)pvData;
			break;

		case PROTDEBUG_SET_LINK_PARMS:
			/* Manually set link parameters */
			SetLinkParms(pEPD, (int*)pvData);
			break;

		case PROTDEBUG_TOGGLE_LINKSTATE:
			/* Toggle Dynamic/Static Link control */
			pEPD->ulEPFlags ^= EPFLAGS_LINK_STABLE;
			break;

		case PROTDEBUG_TOGGLE_NO_RETRIES:
			/* Toggle whether we send retries or not */
			pEPD->ulEPFlags2 ^= EPFLAGS2_DEBUG_NO_RETRIES;
			break;

		case PROTDEBUG_SET_MEMALLOCFUNC:
			/* Set a function to be called when a memory allocation occurs */
			g_pfnMemAllocFunc = (PFNMEMALLOCFUNC)pvData;
			break;
		case PROTDEBUG_TOGGLE_TIMER_FAILURE:
			/* Toggle whether Scheduling a timer should succeed or fail */
			pPData->ulProtocolFlags^=PFLAGS_FAIL_SCHEDULE_TIMER;
		default:
			return DPNERR_GENERIC;
	}

	return DPN_OK;
}

#endif // !DPNBUILD_NOPROTOCOLTESTITF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\backend.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Backend.cpp
 *  Content:	This file contains the backend (mostly timer- and captive thread-based
 *				processing for the send pipeline.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98    ejs     Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

/*
**		NOTE ABOUT CRITICAL SECTIONS
**
**		It is legal to enter multiple critical sections concurrently,  but to avoid
**	deadlocks,  they must be entered in the correct order.
**
**		MSD CommandLocks should be entered first. That is,  do not attempt to take
**	a command lock with the EPD EPLock held because you may deadlock the protocol.
**
**		ORDER OF PRECEDENCE -  Never take a low # lock while holding a higher # lock
**	
**		1 - CommandLock		// guards an MSD
**		2 - EPLock			// guards EPD queues (and retry timer stuff)
**		3 - SPLock			// guards SP send queue (and Listen command)
**
**		ANOTHER NOTE ABOUT CRIT SECs
**
**		It is also legal in WIN32 for a thread to take a CritSec multiple times, but in
**	this implementation we will NEVER do that.  The debug code will ASSERT that a thread
**	never re-enters a locked critsec even though the OS would allow it.
*/

#include "dnproti.h"


PFMD	CopyFMD(PFMD, PEPD);

#undef DPF_MODNAME
#define DPF_MODNAME "LockEPD"

#ifdef DBG
VOID LockEPD(PEPD pEPD, PTSTR Buf)
{
#else // DBG
VOID LockEPD(PEPD pEPD)
{
#endif // DBG

	if (INTER_INC(pEPD) == 0)
	{
		ASSERT(0); 
	}
	DPFX(DPFPREP,DPF_EP_REFCNT_LVL, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->lRefCnt);
	DNASSERTX(pEPD->lRefCnt < 10000, 2);
}

/*
*	Called with EPLock held, returns with EPLock released
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseEPD"

#ifdef DBG
VOID ReleaseEPD(PEPD pEPD, PTSTR Buf)
{
#else // DBG
VOID ReleaseEPD(PEPD pEPD)
{
#endif // DBG

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);
	ASSERT(pEPD->lRefCnt >= 0); 

	// Someone else can come along and call LOCK_EPD or DECREMENT_EPD while we are here
	// so the decrement has to be interlocked even though we own the EPLock.
	LONG lRefCnt = INTER_DEC(pEPD);

	if (lRefCnt == 0 && !(pEPD->ulEPFlags & EPFLAGS_SP_DISCONNECTED))
	{
		// Make sure no one else does this again
		pEPD->ulEPFlags |= EPFLAGS_SP_DISCONNECTED;

		SPDISCONNECTDATA	Block;
		Block.hEndpoint = pEPD->hEndPt;
		Block.dwFlags = 0;
		Block.pvContext = NULL;

		Unlock(&pEPD->EPLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->Disconnect - hEndpoint[%x], pSPD[%p]", pEPD, Block.hEndpoint, pEPD->pSPD);
		(void) IDP8ServiceProvider_Disconnect(pEPD->pSPD->IISPIntf, &Block);
	}
	else if (lRefCnt < 0)
	{
		Unlock(&pEPD->EPLock);

		Lock(&pEPD->pSPD->SPLock);
		pEPD->blActiveLinkage.RemoveFromList();
		Unlock(&pEPD->pSPD->SPLock);

		EPDPool.Release(pEPD);
	}
	else
	{
		Unlock(&pEPD->EPLock);
	}

	DPFX(DPFPREP,DPF_EP_REFCNT_LVL, "(%p) %s, RefCnt: %d", pEPD, Buf, lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecrementEPD"

#ifdef DBG
VOID DecrementEPD(PEPD pEPD, PTSTR Buf)
{
#else // DBG
VOID DecrementEPD(PEPD pEPD)
{
#endif // DBG

	ASSERT(pEPD->lRefCnt > 0); 

	INTER_DEC(pEPD);
	
	DPFX(DPFPREP,DPF_EP_REFCNT_LVL, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "LockMSD"

#ifdef DBG
VOID LockMSD(PMSD pMSD, PTSTR Buf)
{
#else // DBG
VOID LockMSD(PMSD pMSD)
{
#endif // DBG

	if(INTER_INC(pMSD) == 0) 
	{ 
		ASSERT(0); 
	}

	DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseMSD"

#ifdef DBG
VOID ReleaseMSD(PMSD pMSD, PTSTR Buf)
{
#else // DBG
VOID ReleaseMSD(PMSD pMSD)
{
#endif // DBG

	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);
	ASSERT(pMSD->lRefCnt >= 0); 
	
	if(INTER_DEC(pMSD) < 0)
	{ 
		MSDPool.Release(pMSD); 
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, -1);
	}
	else 
	{ 
		Unlock(&pMSD->CommandLock); 
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->lRefCnt);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecrementMSD"

#ifdef DBG
VOID DecrementMSD(PMSD pMSD, PTSTR Buf)
{
#else // DBG
VOID DecrementMSD(PMSD pMSD)
{
#endif // DBG

	ASSERT(pMSD->lRefCnt > 0); 

	INTER_DEC(pMSD);
	
	DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "LockFMD"

#ifdef DBG
VOID LockFMD(PFMD pFMD, PTSTR Buf)
{
#else // DBG
VOID LockFMD(PFMD pFMD)
{
#endif // DBG

	ASSERT(pFMD->lRefCnt > 0); // FMD_Get is the only function that should make this 1 

	INTER_INC(pFMD);
		
	DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pFMD, Buf, pFMD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseFMD"

#ifdef DBG
VOID ReleaseFMD(PFMD pFMD, PTSTR Buf)
{
#else // DBG
VOID ReleaseFMD(PFMD pFMD)
{
#endif // DBG

	ASSERT(pFMD->lRefCnt > 0); 

	if( INTER_DEC(pFMD) == 0) 
	{ 
		FMDPool.Release(pFMD); 
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pFMD, Buf, 0);
	}
	else
	{
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pFMD, Buf, pFMD->lRefCnt);
	}
}

/*
**		DNSP Command Complete
**
**		Service Provider calls us here to indicate completion of an asynchronous
**	command.  This may be called before the actual command returns,  so we must
**	make sure that our Context value is valid and accessible before calling SP.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_CommandComplete"

HRESULT WINAPI DNSP_CommandComplete(IDP8SPCallback *pIDNSP, HANDLE Handle, HRESULT hr, PVOID Context)
{
	PSPD		pSPD = (PSPD) pIDNSP;
	PFMD		pFMD = (PFMD) Context;
	PEPD		pEPD;
	PMSD		pMSD;
	CBilink*    pbl;

	ASSERT_SPD(pSPD);
	ASSERT(Context);

	DBG_CASSERT(OFFSETOF(FMD, CommandID) == OFFSETOF(MSD, CommandID));

	DPFX(DPFPREP,9, "COMMAND COMPLETE  (%p, ID = %u)", Context, pFMD->CommandID);

	switch(pFMD->CommandID)
	{
		case COMMAND_ID_SEND_COALESCE:
		case COMMAND_ID_COPIED_RETRY_COALESCE:
		{
			ASSERT_FMD(pFMD);
			ASSERT( pFMD->bSubmitted );
			ASSERT( pFMD->SendDataBlock.hCommand == Handle || pFMD->SendDataBlock.hCommand == NULL );

			pEPD = pFMD->pEPD;
			ASSERT_EPD(pEPD);

			DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);

			Lock(&pSPD->SPLock);
			pFMD->blQLinkage.RemoveFromList();
			Unlock(&pSPD->SPLock);

			Lock(&pEPD->EPLock);
		
			// Complete all of the individual frames.
			pbl = pFMD->blCoalesceLinkage.GetNext();
			while (pbl != &pFMD->blCoalesceLinkage)
			{
				PFMD pFMDInner = CONTAINING_OBJECT(pbl, FMD, blCoalesceLinkage);
				ASSERT_FMD(pFMDInner);

				// It's likely that the DNSP_CommandComplete call below or an acknowledgement
				// received shortly thereafter will complete the send for real and pull it out of
				// the coalescence list.  We must grab a pointer to the next item in the list
				// before we drop the lock and complete the frame.
				ASSERT(pbl->GetNext() != pbl);
				pbl = pbl->GetNext();
				
				Unlock(&pEPD->EPLock);

				(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, pFMDInner);

				Lock(&pEPD->EPLock);
			}

			// Set the submitted flag for the coalesce header after all the subframes are complete
			// because we drop the EPD for each subframe.
			pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected by EPLock

			if (pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE)
			{
				DECREMENT_EPD(pEPD, "UNLOCK (Rely Frame Complete (Copy Coalesce))");
			}
			
			RELEASE_EPD(pEPD, "UNLOCK (Coalesce Frame Complete)"); 			// This releases the EPLock

			RELEASE_FMD(pFMD, "Coalesce SP submit release on complete");	// Dec ref count

			break;
		}
		case COMMAND_ID_SEND_DATAGRAM:
		case COMMAND_ID_SEND_RELIABLE:
		case COMMAND_ID_COPIED_RETRY:
		{
			ASSERT_FMD(pFMD);
			ASSERT( pFMD->bSubmitted );
			ASSERT( pFMD->SendDataBlock.hCommand == Handle || pFMD->SendDataBlock.hCommand == NULL );

			pEPD = pFMD->pEPD;
			ASSERT_EPD(pEPD);

			DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for MSD[%p], pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pFMD->pMSD, pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);

			Lock(&pSPD->SPLock);
			pFMD->blQLinkage.RemoveFromList();				// but they dont wait on the PENDING queue
			Unlock(&pSPD->SPLock);

			pMSD = pFMD->pMSD;
			ASSERT_MSD(pMSD);

			Lock(&pMSD->CommandLock);
			Lock(&pEPD->EPLock);

			pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected by EPLock

			// We wait for the Frame count to go to zero on reliables before completing them to the Core so that we know we are done
			// with the user's buffers.
			pMSD->uiFrameCount--; // Protected by EPLock
			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frame count decremented on complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

			if (pMSD->uiFrameCount == 0) // Protected by EPLock
			{
				if (pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM)
				{
					// Datagrams are complete as soon as all of their frames are sent
					// NOTE: This is done again in CompleteDatagramSend...
					pMSD->ulMsgFlags2 |= MFLAGS_TWO_SEND_COMPLETE;
				}

				if (pMSD->ulMsgFlags2 & (MFLAGS_TWO_SEND_COMPLETE|MFLAGS_TWO_ABORT))
				{
					// There is a race condition while abort is between its two holdings of the lock.  If we are completing, 
					// then we need to let AbortSends know that by clearing this flag.
					if (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT_WILL_COMPLETE)
					{
						pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ABORT_WILL_COMPLETE);

						// It is important that we not pull pMSD->blQLinkage off the list in this case since AbortSends is
						// using that to hold it on a temporary list.  If we do pull it off, AbortSends will not release
						// its reference on the MSD and it will leak.
					}
					else
					{
						// Remove the MSD from the CompleteSends list in the normal case
						pMSD->blQLinkage.RemoveFromList();
					}

					if (pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM)
					{
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing Nonreliable frame, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

						Unlock(&pEPD->EPLock);
						CompleteDatagramSend(pSPD, pMSD, hr); // Releases MSDLock
						Lock(&pEPD->EPLock);
					}
					else if ((pMSD->CommandID == COMMAND_ID_DISCONNECT || pMSD->CommandID == COMMAND_ID_DISC_RESPONSE) &&
						     (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT))
					{
						// We got all the pieces we needed to finish a disconnect off earlier, but there were frames
						// still outstanding (probably from retries).  Now that all the frames are done, we can complete
						// this disconnect operation.

						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing disconnect, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

						Unlock(&pEPD->EPLock);
						CompleteDisconnect(pMSD, pSPD, pEPD); // This releases the CommandLock
						Lock(&pEPD->EPLock);
					}
					else
					{
						ASSERT(pFMD->CommandID == COMMAND_ID_SEND_RELIABLE || pFMD->CommandID == COMMAND_ID_COPIED_RETRY);

						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing Reliable frame, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

						// See what error code we need to return
						if(pMSD->ulMsgFlags2 & MFLAGS_TWO_SEND_COMPLETE)
						{
							Unlock(&pEPD->EPLock);
							CompleteReliableSend(pEPD->pSPD, pMSD, DPN_OK); // This releases the CommandLock
							Lock(&pEPD->EPLock);
						}
						else
						{
							Unlock(&pEPD->EPLock);
							CompleteReliableSend(pEPD->pSPD, pMSD, DPNERR_CONNECTIONLOST); // This releases the CommandLock
							Lock(&pEPD->EPLock);
						}
					}
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Message not yet complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					Unlock(&pMSD->CommandLock);
				}
			}
			else
			{
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frames still outstanding, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
				Unlock(&pMSD->CommandLock);
			}

			if (pFMD->CommandID == COMMAND_ID_COPIED_RETRY)
			{
				// In case this was a coalesced retry, remove it from the list because copied coalesced retries don't
				// get true completions of their own (protected by EPD lock).  Copied coalesced retries don't keep
				// a reference to their containing header since they complete at the same time.
				ASSERT(pFMD->pCSD == NULL);
				pFMD->blCoalesceLinkage.RemoveFromList();
				
				DECREMENT_EPD(pFMD->pEPD, "UNLOCK (Rely Frame Complete (Copy))");
			}

			RELEASE_EPD(pFMD->pEPD, "UNLOCK (Frame Complete)"); 		// This releases the EPLock

			RELEASE_FMD(pFMD, "SP Submit release on complete");	// Dec ref count

			break;
		}
		case COMMAND_ID_CONNECT:
		{
			pMSD = (PMSD) Context;

			ASSERT_MSD(pMSD);
			ASSERT(pMSD->hCommand == Handle || pMSD->hCommand == NULL); // Command can complete before hCommmand is set up
			ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER);

			DPFX(DPFPREP,DPF_CALLIN_LVL, "(%p) CommandComplete called for COMMAND_ID_CONNECT, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD->pEPD, pMSD, pSPD, Handle, pMSD->hCommand, hr);

			CompleteSPConnect((PMSD) Context, pSPD, hr);

			break;		
		}
		case COMMAND_ID_CFRAME:
		{
			ASSERT_FMD(pFMD);
			ASSERT( pFMD->bSubmitted );
			ASSERT( pFMD->SendDataBlock.hCommand == Handle || pFMD->SendDataBlock.hCommand == NULL );

			pEPD = pFMD->pEPD;
			ASSERT_EPD(pEPD);

			DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_CFRAME, pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pFMD->pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);
			
			Lock(&pSPD->SPLock);
			pFMD->blQLinkage.RemoveFromList();				// Take the frame off of the pending queue
#pragma BUGBUG(vanceo, "EPD lock is not held?")
			pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SPLock
			Unlock(&pSPD->SPLock);

			Lock(&pEPD->EPLock);
				//if that was the last send in a sequence of hard disconnect frames then we've just completed a hard
				//disconnect and should indicate that plus drop the link
			if (pFMD->ulFFlags & FFLAGS_FINAL_HARD_DISCONNECT)
			{
				DPFX(DPFPREP,7, "(%p) Final HARD_DISCONNECT completed", pEPD);
				CompleteHardDisconnect(pEPD);
					//above call drops the ep lock
				Lock(&pEPD->EPLock);
			}
			else if (pFMD->ulFFlags & FFLAGS_FINAL_ACK)
			{
				pEPD->ulEPFlags |= EPFLAGS_ACKED_DISCONNECT;

				// It is okay if our disconnect hasn't completed in the SP yet, the frame count code will handle that.
				// Note that this would be an abnormal case to have the SP not have completed the frame, but an ACK
				// for it to have already arrived, but it is certainly possible.
				if (pEPD->ulEPFlags & EPFLAGS_DISCONNECT_ACKED)
				{
					DPFX(DPFPREP,7, "(%p) Final ACK completed and our EOS ACK'd, dropping link", pEPD);
					DropLink(pEPD); // Drops EPLock
					Lock(&pEPD->EPLock);
				}
				else
				{
					DPFX(DPFPREP,7, "(%p) Final ACK completed, still awaiting ACK on our EOS", pEPD);
				}
			}

			RELEASE_EPD(pEPD, "UNLOCK (CFrame Cmd Complete)");	// Release EndPoint before releasing frame, releases EPLock
			RELEASE_FMD(pFMD, "Final Release on Complete");								// Release Frame

			break;
		}
		case COMMAND_ID_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
		case COMMAND_ID_LISTEN_MULTICAST:
#endif // ! DPNBUILD_NOMULTICAST
		{
			pMSD = (PMSD) Context;

			ASSERT_MSD(pMSD);
			ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL ); // Command can complete before hCommmand is set up
			ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

			DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_LISTEN, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD, pSPD, Handle, pMSD->hCommand, hr);

			Lock(&pMSD->CommandLock);

			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag

#ifdef DBG
			Lock(&pSPD->SPLock);
			if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
			{
				pMSD->blSPLinkage.RemoveFromList();
				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
			}
			Unlock(&pSPD->SPLock);

			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
			pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
			pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG
			// Leave lock while calling into higher layer
			Unlock( &pMSD->CommandLock );

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteListenTerminate, hr[%x], Core Context[%p]", pMSD, hr, pMSD->Context);
			pSPD->pPData->pfVtbl->CompleteListenTerminate(pSPD->pPData->Parent, pMSD->Context, hr);
			
			// Release the final reference on the MSD AFTER indicating to the Core
			Lock(&pMSD->CommandLock);
			RELEASE_MSD(pMSD, "SP Ref");

			// Base ref will be released when DoCancel completes
			break;
		}
		case COMMAND_ID_ENUM:
		{
			pMSD = static_cast<PMSD>( Context );

			ASSERT_MSD( pMSD );
			ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL );
			ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

			DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_ENUM, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD, pSPD, Handle, pMSD->hCommand, hr);
			
			Lock( &pMSD->CommandLock );

			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DBG
			Lock( &pSPD->SPLock );
			if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
			{
				pMSD->blSPLinkage.RemoveFromList();
				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
			}
			Unlock( &pSPD->SPLock );

			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
			pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
			pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

			// Leave lock while calling into higher layer
			Unlock( &pMSD->CommandLock );

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteEnumQuery, hr[%x], Core Context[%p]", pMSD, hr, pMSD->Context);
			pSPD->pPData->pfVtbl->CompleteEnumQuery(pSPD->pPData->Parent, pMSD->Context, hr);

			// Release the final reference on the MSD AFTER indicating to the Core
			Lock( &pMSD->CommandLock );
			DECREMENT_MSD( pMSD, "SP Ref");				// SP is done
			RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

			break;
		}

		case COMMAND_ID_ENUMRESP:
		{
			pMSD = static_cast<PMSD>( Context );

			ASSERT_MSD( pMSD );
			ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL );
			ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

			DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_ENUMRESP, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD, pSPD, Handle, pMSD->hCommand, hr);

			Lock( &pMSD->CommandLock );

			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DBG
			Lock( &pSPD->SPLock );
			if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
			{
				pMSD->blSPLinkage.RemoveFromList();
				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
			}
			Unlock( &pSPD->SPLock );

			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
			pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
			pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

			// Leave lock while calling into higher layer
			Unlock( &pMSD->CommandLock );

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteEnumResponse, hr[%x], Core Context[%p], hr[%x]", pMSD, hr, pMSD->Context, hr);
			pSPD->pPData->pfVtbl->CompleteEnumResponse(pSPD->pPData->Parent, pMSD->Context, hr);

			// Release the final reference on the MSD AFTER indicating to the Core
			Lock( &pMSD->CommandLock );
			DECREMENT_MSD( pMSD, "SP Ref" );			// SP is done
			RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

			break;
		}

#ifndef DPNBUILD_NOMULTICAST
		case COMMAND_ID_CONNECT_MULTICAST_RECEIVE:
		case COMMAND_ID_CONNECT_MULTICAST_SEND:
		{
			void	*pvContext = NULL;

			pMSD = static_cast<PMSD>( Context );

			ASSERT_MSD( pMSD );
			ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL );
			ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

			DPFX(DPFPREP,DPF_CALLIN_LVL, "(%p) CommandComplete called for COMMAND_ID_MULTICAST_CONNECT, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD->pEPD, pMSD, pSPD, Handle, pMSD->hCommand, hr);

			Lock(&pMSD->CommandLock);						// must do this before clearing IN_SP flag

			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag

#ifdef DBG
			Lock( &pSPD->SPLock );
			if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
			{
				pMSD->blSPLinkage.RemoveFromList();
				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
			}
			Unlock( &pSPD->SPLock );

			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
			pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
			pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

			pEPD = pMSD->pEPD;
			if (pEPD)
			{
				//
				//	We will pass up the endpoint if it exists and remove the EPD reference from the MSD and vice versa
				//
				ASSERT_EPD(pEPD);
				Lock(&pEPD->EPLock);

				ASSERT(pEPD->pCommand == pMSD);
				pEPD->pCommand = NULL;
				DECREMENT_MSD(pMSD, "EPD Ref");						// Release Reference from EPD
				Unlock(&pEPD->EPLock);

				pMSD->pEPD = NULL;
			}

			// Leave lock while calling into higher layer
			Unlock( &pMSD->CommandLock );

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteMulticastConnect, hr[%x], Core Context[%p], endpoint [%x]", pMSD, hr, pMSD->Context, pMSD->hListenEndpoint);
			pSPD->pPData->pfVtbl->CompleteMulticastConnect(pSPD->pPData->Parent, pMSD->Context, hr, pEPD, &pvContext);

			if (pEPD)
			{
				Lock(&pEPD->EPLock);
				pEPD->Context = pvContext;
				Unlock(&pEPD->EPLock);
			}

			// Release the final reference on the MSD AFTER indicating to the Core
			Lock( &pMSD->CommandLock );
			DECREMENT_MSD( pMSD, "SP Ref" );			// SP is done
			RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

			break;
		}
#endif	// DPNBUILD_NOMULTICAST

		default:
		{
			DPFX(DPFPREP,0, "CommandComplete called with unknown CommandID");
			ASSERT(0);
			break;
		}
	} // SWITCH

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return DPN_OK;
}

/*
**		Update Xmit State
**
**		There are two elements to the remote rcv state delivered in each frame.  There is
**	the NSeq number which acknowledges ALL frames with smaller sequence numbers,
**	and there is the bitmask which acknowledges specific frames starting with NSeq+1.
**
**		Frames prior to NSeq can be removed from the SendWindow.  Frames acked by bits
**	should be marked as acknowledged,  but left in the window until covered by NSeq
**	(because a protocol can renege on bit-acked frames).
**
**		We will walk through the send window queue,  starting with the oldest frame,
**	and remove each frame that has been acknowledged by NSeq.  As we hit EOM frames,
**	we will indicate SendComplete for the message.  If the bitmask is non-zero we may
**	trigger retransmission of the missing frames.  I say 'may' because we dont want
**	to send too many retranmissions of the same frame...
**
**	SOME MILD INSANITY:  Doing the DropLink code now.  There are several places where
**	we release the EPD Locks in the code below,  and any time we arent holding the locks
**	someone can start terminating the link.  Therefore,  whenever we retake either EPD lock
**	(State or SendQ) after yielding them,  we must re-verify that EPFLAGS_CONNECTED is still
**	set and be prepared to abort if it is not.  Happily,  the whole EPD wont go away on us
**	because we have a RefCnt on it,  but once CONNECTED has been cleared we dont want to go
**	setting any more timers or submitting frames to the SP.
**
**	RE_WRITE TIME:  We can be re-entered while User Sends are being completed.  This is okay
**	except for the chance that the second thread would blow through here and hit the rest
**	of CrackSequential before us.  CrackSeq would think it got an out of order frame (it had)
**	and would issue a NACK before we could stop him.  Easiest solution is to delay the callback
**	of complete sends until the end of the whole receive operation (when we indicate receives
**	for instance).  Incoming data should have priority over completing sends anyhow...
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateXmitState"

VOID
UpdateXmitState(PEPD pEPD, BYTE bNRcv, ULONG RcvMaskLow, ULONG RcvMaskHigh, DWORD tNow)
{
	PSPD	pSPD;
	PFMD	pFMD, pRealFMD;
	PMSD	pMSD;
	CBilink	*pLink;
	UINT	tDelay;
	UINT	uiRTT;
	BOOL	ack;
	BOOL	fRemoveRetryRef;

	pSPD = pEPD->pSPD;
	ASSERT_SPD(pSPD);

	ack = FALSE;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(RcvMaskLow | RcvMaskHigh)
	{
		DPFX(DPFPREP,7, "(%p) *NACK RCVD* NRcv=%x, MaskL=%x, MaskH=%x", pEPD, bNRcv, RcvMaskLow, RcvMaskHigh);
	}

	// The caller should have checked this
	ASSERT( pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED );

#ifdef	DBG			
	// There should always be a timer running on the first frame in window
	if(!pEPD->blSendWindow.IsEmpty())
	{
		pFMD = CONTAINING_OBJECT(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);
		ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);
	}
	pFMD = NULL;
#endif // DBG
	
	// The send window contains a sorted list of frames that we have sent, but have not received ACKs
	// for. pEPD->uiUnackedFrames contains the count of items in this list.
	while(!pEPD->blSendWindow.IsEmpty())
	{
		// Grab the first item in the list
		pFMD = CONTAINING_OBJECT((pLink = pEPD->blSendWindow.GetNext()), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);

		// Let's try taking one sample from every group of acknowledgements
		// ALWAYS SAMPLE THE HIGHEST NUMBERED FRAME COVERED BY THIS ACK
		if(!(RcvMaskLow | RcvMaskHigh) &&
		   ((PDFRAME) pFMD->ImmediateData)->bSeq == (bNRcv - 1))
		{	
			// Update the bHighestAck member and take a new RTT
			if ((BYTE)(((PDFRAME) pFMD->ImmediateData)->bSeq - pEPD->bHighestAck) <= MAX_RECEIVE_RANGE)
			{
				pEPD->bHighestAck = ((PDFRAME) pFMD->ImmediateData)->bSeq;
				DPFX(DPFPREP, 7, "(%p) Highest ACK is now: %x", pEPD, pEPD->bHighestAck);

				uiRTT = tNow - pFMD->dwFirstSendTime;
				ASSERT(!(uiRTT & 0x80000000));

				UpdateEndPoint(pEPD, uiRTT, tNow);
			}
		}		

		// If bNRcv for the other side is higher than this frame's bSeq, we know the other side has 
		// seen this frame, so it is ACK'd and we will remove it from the Send Window.
		if((BYTE)((bNRcv) - (((PDFRAME) pFMD->ImmediateData)->bSeq + 1)) < (BYTE) pEPD->uiUnackedFrames) 
		{
			ASSERT(pFMD->ulFFlags & FFLAGS_IN_SEND_WINDOW);

			DPFX(DPFPREP,7, "(%p) Removing Frame %x (0x%p, fflags=0x%x) from send window (unacked frames 1/%u, bytes %u/%u)",
				pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD, pFMD->ulFFlags, pEPD->uiUnackedFrames, pFMD->uiFrameLength, pEPD->uiUnackedBytes);
			pFMD->blWindowLinkage.RemoveFromList();				// Remove frame from send window
			pFMD->ulFFlags &= ~(FFLAGS_IN_SEND_WINDOW);			// Clear flag

			//
			//	Mark successful transmission of this frame in drop mask
			//
			if (pEPD->dwDropBitMask)
			{
				if (pEPD->dwDropBitMask & 0x80000000)
				{
					pEPD->uiDropCount--;
				}
				pEPD->dwDropBitMask = pEPD->dwDropBitMask << 1;
				DPFX(DPFPREP,7, "(%p) Drop Count %d, Drop Bit Mask 0x%lx", pEPD,pEPD->uiDropCount,pEPD->dwDropBitMask);
			}

#ifndef DPNBUILD_NOPROTOCOLTESTITF
			if(!(pEPD->ulEPFlags2 & EPFLAGS2_DEBUG_NO_RETRIES))
#endif // !DPNBUILD_NOPROTOCOLTESTITF
			{
				if(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET)
				{
					ASSERT(ack == FALSE);
					ASSERT(pEPD->RetryTimer != 0);
					DPFX(DPFPREP,7, "(%p) Cancelling Retry Timer", pEPD);
					if(CancelProtocolTimer(pSPD, pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
					{
						DECREMENT_EPD(pEPD, "UNLOCK (cancel retry timer)"); // SPLock not already held
					}
					else
					{
						DPFX(DPFPREP,7, "(%p) Cancelling Retry Timer Failed", pEPD);
					}
					pEPD->RetryTimer = 0;							// This will cause event to be ignored if it runs
					pFMD->ulFFlags &= ~(FFLAGS_RETRY_TIMER_SET);
				}
			}

			pEPD->uiUnackedFrames--;							// track size of window
			ASSERT(pEPD->uiUnackedFrames <= MAX_RECEIVE_RANGE);
			pEPD->uiUnackedBytes -= pFMD->uiFrameLength;
			ASSERT(pEPD->uiUnackedBytes <= MAX_RECEIVE_RANGE * pSPD->uiFrameLength);

			pEPD->uiBytesAcked += pFMD->uiFrameLength;

			// If the frame has been queued for a retry, pull it off
			// NOTE: Copied retries of this frame may still be on the retry queue, inefficient to send them out, but okay
			if (pFMD->ulFFlags & FFLAGS_RETRY_QUEUED)
			{
				pFMD->blQLinkage.RemoveFromList();
				pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue

				fRemoveRetryRef = TRUE;

				DECREMENT_EPD(pEPD, "UNLOCK (Releasing Retry Frame)"); // SPLock not already held
				if ((pFMD->CommandID == COMMAND_ID_COPIED_RETRY) ||
					(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE))
				{
					DECREMENT_EPD(pEPD, "UNLOCK (Copy Complete)"); // SPLock not already held
				}
				RELEASE_FMD(pFMD, "SP Submit");
				if (pEPD->blRetryQueue.IsEmpty())
				{
					pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
				}
			}
			else
			{
				fRemoveRetryRef = FALSE;
			}

			// Get the first FMD to work with
			if ((pFMD->CommandID == COMMAND_ID_SEND_COALESCE) ||
				(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE))
			{
				pRealFMD = CONTAINING_OBJECT(pFMD->blCoalesceLinkage.GetNext(), FMD, blCoalesceLinkage);
				ASSERT_FMD(pRealFMD);

				// If there were no reliable frames coalesced, then the list might be empty.
#ifdef DBG
				if (pRealFMD == pFMD)
				{
					ASSERT((pFMD->CommandID == COMMAND_ID_SEND_COALESCE) && (! (pFMD->ulFFlags & FFLAGS_RELIABLE)));
				}
#endif // DBG
			}
			else
			{
				pRealFMD = pFMD;
			}

			// For each FMD in the message, inform it of the ACK
			while(TRUE) 
			{
				if (pRealFMD->tAcked == -1)
				{
					pRealFMD->tAcked = tNow;
				}

				if (fRemoveRetryRef)
				{
					pMSD = pRealFMD->pMSD;
					ASSERT_MSD(pMSD);
					pMSD->uiFrameCount--; // Protected by EPLock, retries count against outstanding frame count
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Retry frame reference decremented on ACK, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					// If this is a coalesced subframe, remove the EPD and FMD references as well.
					if (pRealFMD != pFMD)
					{
						DECREMENT_EPD(pEPD, "UNLOCK (retry rely frame coalesce)");
						RELEASE_FMD(pRealFMD, "SP retry submit (coalesce)");
					}
				}

				// One more send complete
				// We will come down this path for Reliables, KeepAlives, and Disconnects
				// Datagrams are completed upon send completion and do not wait for an ACK
				if((pRealFMD->CommandID != COMMAND_ID_SEND_DATAGRAM) && (pRealFMD->ulFFlags & (FFLAGS_END_OF_MESSAGE | FFLAGS_END_OF_STREAM)))
				{
					if (pRealFMD->CommandID != COMMAND_ID_SEND_COALESCE)
					{
						ASSERT(pRealFMD->CommandID != COMMAND_ID_COPIED_RETRY_COALESCE);
						
						pMSD = pRealFMD->pMSD;
						ASSERT_MSD(pMSD);

						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Flagging Complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
						pMSD->ulMsgFlags2 |= MFLAGS_TWO_SEND_COMPLETE;	// Mark this complete

						if (pMSD->uiFrameCount == 0)					// Protected by EPLock
						{
							pEPD->ulEPFlags |= EPFLAGS_COMPLETE_SENDS;
						}
					}
					else
					{
						// Should only happen for all-datagram coalesced sends (see above).
						ASSERT(pRealFMD == pFMD);
					}
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "ACK for frame 0x%p, command ID %u, flags 0x%08x", pRealFMD, pRealFMD->CommandID, pRealFMD->ulFFlags);
				}

				// If this is a coalesced packet, get the next FMD to work with
				pRealFMD = CONTAINING_OBJECT(pRealFMD->blCoalesceLinkage.GetNext(), FMD, blCoalesceLinkage);
				ASSERT_FMD(pRealFMD);
				if (pRealFMD == pFMD)
				{
					break;
				}
			}
									
			RELEASE_FMD(pFMD, "Send Window");					// Release reference for send window
			ack = TRUE;
		}
		else 
		{
			break;												// First unacked frame,  we can stop checking list
		}
	}					// WHILE (send window not empty)

	// At this point we have completed all of the frames ack'd by NRcv.  We would now like to re-transmit
	// any frames NACK'd by bitmask (and mark the ones ACK'd by bitmask). Now remember,  the first frame in
	// the window is automatically missing by the implied first zero-bit.
	//
	//	We will retransmit ALL frames that appear to be missing.  There may be a timer running on
	//	the first frame,  but only if we did not ACK any frames in the code above (ack == 0).
	//
	//	Hmmm,  if the partner has a fat pipeline we could see this bitmap lots of times.  We need to make
	//	sure we don't trigger a retransmission here a quarter-zillion times during the Ack latency period.
	//	To solve this we will only re-xmit the first time we see this bit.  After that,  we will have to
	//	wait around for the next RetryTimeout.  I think that's just the way its going to have to be.
	//
	//	OTHER THINGS WE KNOW:
	//
	//	There must be at least two frames remaining in the SendWindow. At minimum, first frame missing (always)
	//  and then at least one SACK'd frame after.
	//
	//	pLink = first queue element in SendWindow
	//	pFMD = first frame in SendWindow
	//
	//	We are still Holding EPD->EPLock.  It is okay to take SPD->SPLock while holding it.
	//
	//  One More Problem:  Since SP has changed its receive buffer logic mis-ordering of frames has become
	// quite commonplace.  This means that our assumptions about the state of the SendWindow are not necessarily true.
	// This means that frames NACKed by bitmask may have been acknowleged by a racing frame.  This means that the
	// SendWindow may not be in sync with the mask at all.  This means we need to synchronize the bitmask with the
	// actual send window.  This is done by right-shifting the mask for each frame that's been acknowleged since the
	// bitmask was minted before beginning the Selective Ack process.

	// NOTE: If everything was removed from the Send Window above, then pLink and pFMD will
	// be garbage.  In that case we would expect the mask to be NULL after adjusting below.

	if((RcvMaskLow | RcvMaskHigh) && 
	   (pEPD->uiUnackedFrames > 1) &&
	   (bNRcv == ((PDFRAME) pFMD->ImmediateData)->bSeq) // Check for old ACK, no useful data
	   )
	{
		ASSERT(pLink == pEPD->blSendWindow.GetNext());

#ifndef DPNBUILD_NOPROTOCOLTESTITF
		if(!(pEPD->ulEPFlags2 & EPFLAGS2_DEBUG_NO_RETRIES))
#endif // !DPNBUILD_NOPROTOCOLTESTITF
		{
			// See if the first frame in the window has already been retried
			if(pFMD->uiRetry == 0)
			{
				// Receiving a frame later than the first one in the window tells us that the
				// first frame in the window should have been received by now.  We will
				// cut short the retry timer and only wait a little longer in case the frame
				// is here but got indicated out of order.  If the retry timer had less
				// than 10ms to go, no big deal, we will just add a small amount of delay to it.
				DPFX(DPFPREP,7, "(%p) Resetting Retry Timer for 10ms", pEPD);
				if (pEPD->RetryTimer)
				{
					if(CancelProtocolTimer(pSPD, pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
					{
						DECREMENT_EPD(pEPD, "UNLOCK (cancel retry timer)"); // SPLock not already held
					}
					else
					{
						DPFX(DPFPREP,7, "(%p) Cancelling Retry Timer Failed", pEPD);
					}
				}
				LOCK_EPD(pEPD, "LOCK (retry timer - nack quick set)");		// Could not cancel- therefore we must balance RefCnt
				ScheduleProtocolTimer(pSPD, 10, 5, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique );
				pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;
			}
		}

		// If pLink gets to the end of the list, the receive mask contained more bits than there were
		// items in the send window even after it was adjusted.  This means the packet was bogus, and
		// we have probably hosed our state already, but we will go ahead and attempt to safeguard
		// against having an AV by not entering the loop with a bad pFMD from hitting the end of the list.
		while((RcvMaskLow | RcvMaskHigh) && pLink != &pEPD->blSendWindow)
		{
			pFMD = CONTAINING_OBJECT(pLink, FMD, blWindowLinkage);
			ASSERT_FMD(pFMD);

			pLink = pLink->GetNext();							// Advance pLink to next frame in SendWindow

			// Only update on the highest frame
			if ((RcvMaskLow|RcvMaskHigh) == 1)
			{
				// Update the bHighestAck member
				if ((BYTE)(((PDFRAME) pFMD->ImmediateData)->bSeq - pEPD->bHighestAck) <= MAX_RECEIVE_RANGE)
				{
					pEPD->bHighestAck = ((PDFRAME) pFMD->ImmediateData)->bSeq;
					DPFX(DPFPREP, 7, "(%p) Highest ACK is now: %x", pEPD, pEPD->bHighestAck);

					uiRTT = tNow - pFMD->dwFirstSendTime;
					ASSERT(!(uiRTT & 0x80000000));

					UpdateEndPoint(pEPD, uiRTT, tNow);
				}
				pFMD = NULL;  // Make sure we don't use it again
			}

			RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);			// 64 bit logical shift right, skip the zero
		}					// END WHILE (WORK MASKS NON-ZERO)
	}


	// If we acked a frame above and there is more data outstanding then we may need to start a new Retry timer.
	//
	// Of course,  we want to set the timer on whatever frame is the first in the SendWindow.
#ifndef DPNBUILD_NOPROTOCOLTESTITF
	if(!(pEPD->ulEPFlags2 & EPFLAGS2_DEBUG_NO_RETRIES))
#endif // !DPNBUILD_NOPROTOCOLTESTITF
	{
		if( (pEPD->uiUnackedFrames > 0) && (pEPD->RetryTimer == 0)) 
		{
			ASSERT(ack);

			pFMD = CONTAINING_OBJECT(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
			ASSERT_FMD(pFMD);		

			tDelay = tNow - pFMD->dwLastSendTime;	// How long has this frame been enroute?
			tDelay = (tDelay > pEPD->uiRetryTimeout) ? 0 : pEPD->uiRetryTimeout - tDelay; // Calc time remaining for frame

			DPFX(DPFPREP,7, "(%p) Setting Retry Timer for %dms on Seq=[%x], FMD=[%p]", pEPD, tDelay, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
			LOCK_EPD(pEPD, "LOCK (retry timer)");						// bump RefCnt for timer
			ScheduleProtocolTimer(pSPD, tDelay, 0, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique );
			pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;
		}
	}

	// See if we need to unblock this session
	if((pEPD->uiUnackedFrames < pEPD->uiWindowF) && (pEPD->uiUnackedBytes < pEPD->uiWindowB))
	{
		pEPD->ulEPFlags |= EPFLAGS_STREAM_UNBLOCKED;
		if((pEPD->ulEPFlags & EPFLAGS_SDATA_READY) && ((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0))
		{
			// NOTE: We can get in here if we ack'd something above OR if GrowSendWindow grew the 
			// window as a result of calling UpdateEndpoint.
			DPFX(DPFPREP,7, "(%p) UpdateXmit: ReEntering Pipeline", pEPD);

			pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
			LOCK_EPD(pEPD, "LOCK (pipeline)");
			ScheduleProtocolWork(pSPD, ScheduledSend, pEPD);
		}
	}
	else
	{
		// Make sure that there is at least 1 frame unacked.  We can't assert that the unacked byte count
		// is at least 1 because datagrams have their byte count subtracted when RetryTimeout fires.
		ASSERT(pEPD->uiUnackedFrames > 0);
	}
}


/*
**		Complete Datagram Frame
**
**		A datagram frame has been successfully transmitted.  Free the descriptor and
**	see if the entire send is ready to complete.  Reliable sends are not freed until
**	they are acknowledged,  so they must be handled elsewhere.
**
**		**  This is called with the CommandLock in MSD held, returns with it released **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteDatagramSend"

VOID CompleteDatagramSend(PSPD pSPD, PMSD pMSD, HRESULT hr)
{
	PEPD	pEPD = pMSD->pEPD;
	ASSERT_EPD(pEPD);
	PFMD	pFMD = CONTAINING_OBJECT(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
	ASSERT_FMD(pFMD);
	
	ASSERT(pMSD->uiFrameCount == 0);
#ifdef DBG
	ASSERT((pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED)==0);
#endif // DBG
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	Lock(&pEPD->EPLock); // Need EPLock to change MFLAGS_TWO

	DPFX(DPFPREP,7, "(%p) DG MESSAGE COMPLETE pMSD=%p", pEPD, pMSD);
	
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_SEND_COMPLETE;				// Mark this complete
	
	if(pMSD->TimeoutTimer != NULL)
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
		{
			DECREMENT_MSD(pMSD, "Send Timeout Timer");
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer Failed", pEPD);
		}
		pMSD->TimeoutTimer = NULL;
	}

#ifdef DBG
	Lock(&pSPD->SPLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();						// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
	}
	Unlock(&pSPD->SPLock);

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
	pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

	if(hr == DPNERR_USERCANCEL)
	{
		if(pMSD->ulMsgFlags1 & MFLAGS_ONE_TIMEDOUT)
		{
			hr = DPNERR_TIMEDOUT;
		}
	}

	// If this was a coalesced send, remove it from the list (protected by EPD lock).
	if (pFMD->pCSD != NULL)
	{
		ASSERT(pFMD->blCoalesceLinkage.IsListMember(&pFMD->pCSD->blCoalesceLinkage));
		pFMD->blCoalesceLinkage.RemoveFromList();
		RELEASE_FMD(pFMD->pCSD, "Coalesce linkage (datagram complete)");
		pFMD->pCSD = NULL;
	}

	Unlock(&pEPD->EPLock);

	Unlock(&pMSD->CommandLock); // Leave the lock before calling into another layer

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteSend for NG, hr[%x], pMSD[%p], Core Context[%p]", pEPD, hr, pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->CompleteSend(pSPD->pPData->Parent, pMSD->Context, hr, -1, 0);

	// Release the final reference on the MSD AFTER indicating to the Core
	Lock(&pMSD->CommandLock);

	// Cancels are allowed to come in until the Completion has returned and they will expect a valid pMSD->pEPD
	Lock(&pEPD->EPLock);
	pMSD->pEPD = NULL;   // We shouldn't be using this after this

	// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
	RELEASE_MSD(pMSD, "Release On Complete");			// Return resources, including all frames, release MSDLock
	RELEASE_EPD(pEPD, "UNLOCK (Complete Send Cmd - DG)");	// Every send command bumps the refcnt, releases EPLock
}

/*
**		Complete Reliable Send
**
**		A reliable send has completed processing.  Indicate this
**	to the user and free the resources.  This will either take
**	place on a cancel,  error,  or when ALL of the message's frames
**	have been acknowledged.
**
**		**  This is called with CommandLock in MSD held, and exits with it released  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteReliableSend"

VOID
CompleteReliableSend(PSPD pSPD, PMSD pMSD, HRESULT hr)
{
	PEPD	pEPD = pMSD->pEPD;
	ASSERT_EPD(pEPD);
	PFMD	pFMD = CONTAINING_OBJECT(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
	ASSERT_FMD(pFMD);
	
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	ASSERT(pMSD->uiFrameCount == 0);

	// NORMAL SEND COMPLETES
	if(pMSD->CommandID == COMMAND_ID_SEND_RELIABLE)
	{	
		DPFX(DPFPREP,7, "(%p) Reliable Send Complete pMSD=%p", pEPD, pMSD);

#ifdef DBG
		ASSERT((pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED)==0);
#endif // DBG

		if(pMSD->TimeoutTimer != NULL)
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer, pMSD[%p]", pEPD, pMSD);
			if(CancelProtocolTimer(pSPD, pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
			{
				DECREMENT_MSD(pMSD, "Send Timeout Timer");
			}
			else
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer Failed, pMSD[%p]", pEPD, pMSD);
			}
			pMSD->TimeoutTimer = NULL;
		}

		// ACK code in UpdateXmitState flags this as COMPLETE when the last of the message is received.

#ifdef DBG
		Lock(&pSPD->SPLock);
		if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
		{
			pMSD->blSPLinkage.RemoveFromList();					// Remove MSD from master command list
			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
		}
		Unlock(&pSPD->SPLock);

		ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
		pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
		pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

		Unlock(&pMSD->CommandLock); // Leave the lock before calling into another layer

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteSend for G, hr[%x], pMSD[%p], Core Context[%p], RTT[%d], RetryCount[%d]", pEPD, hr, pMSD, pMSD->Context, pFMD->tAcked == -1 ? -1 : pFMD->tAcked - pFMD->dwFirstSendTime, pFMD->uiRetry);
		pSPD->pPData->pfVtbl->CompleteSend(pSPD->pPData->Parent, pMSD->Context, hr, pFMD->tAcked == -1 ? -1 : pFMD->tAcked - pFMD->dwFirstSendTime, pFMD->uiRetry);

		// Release the final reference on the MSD AFTER indicating to the Core
		Lock(&pMSD->CommandLock);

		// Cancels are allowed to come in until the Completion has returned and they will expect a valid pMSD->pEPD
		Lock(&pEPD->EPLock);
		pMSD->pEPD = NULL;   // We shouldn't be using this after this
		
		// If this was a coalesced send, remove it from the list (protected by EPD lock).
		if (pFMD->pCSD != NULL)
		{
			ASSERT(pFMD->blCoalesceLinkage.IsListMember(&pFMD->pCSD->blCoalesceLinkage));
			pFMD->blCoalesceLinkage.RemoveFromList();
			RELEASE_FMD(pFMD->pCSD, "Coalesce linkage (reliable complete)");
			pFMD->pCSD = NULL;
		}

		// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
		RELEASE_MSD(pMSD, "Release On Complete");				// Return resources, including all frames
		RELEASE_EPD(pEPD, "UNLOCK (Complete Send Cmd - Rely)");	// release hold on EPD for this send, releases EPLock
	}

	// END OF STREAM -OR- KEEPALIVE COMPLETES
	else 
	{												
		// Partner has just ACKed our End Of Stream frame.  Doesn't necessarily mean we are done.
		// Both sides need to send (and have acknowledged) EOS frames before the link can be
		// dropped.  Therefore,  we check to see if we have seen our partner's DISC before
		// releasing the RefCnt on EPD allowing the link to drop.  If partner was idle, his EOS
		// might be the same frame which just ack'd us.  Luckily,  this code will run first so we
		// will not have noticed his EOS yet,  and we will not drop right here.

		ASSERT(pMSD->ulMsgFlags2 & (MFLAGS_TWO_END_OF_STREAM | MFLAGS_TWO_KEEPALIVE));

		Lock(&pEPD->EPLock);
		
		if(pMSD->ulMsgFlags2 & MFLAGS_TWO_KEEPALIVE)
		{
			DPFX(DPFPREP,7, "(%p) Keepalive Complete, pMSD[%p]", pEPD, pMSD);
			
			pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
#ifdef DBG
			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST));
#endif // DBG
			
			pMSD->pEPD = NULL;   // We shouldn't be using this after this

			// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
			RELEASE_MSD(pMSD, "Release On Complete");		// Done with this message, releases MSDLock
			RELEASE_EPD(pEPD, "UNLOCK (rel KeepAlive)");	// Release ref for this MSD, releases EPLock
		}
		else 
		{
			DPFX(DPFPREP,7, "(%p) EndOfStream Complete, pMSD[%p]", pEPD, pMSD);

			pEPD->ulEPFlags |= EPFLAGS_DISCONNECT_ACKED;

			// It is okay if our disconnect hasn't completed in the SP yet, the frame count code will handle that.
			// Note that this would be an abnormal case to have the SP not have completed the frame, but an ACK
			// for it to have already arrived, but it is certainly possible.
			if(pEPD->ulEPFlags & EPFLAGS_ACKED_DISCONNECT)
			{
				DPFX(DPFPREP,7, "(%p) EOS has been ACK'd and we've ACK'd partner's EOS, dropping link", pEPD);

				// We are clear to blow this thing down
				Unlock(&pMSD->CommandLock);

				// This will set our state to terminating
				DropLink(pEPD); // This unlocks the EPLock
			}
			else 
			{
				// Our Disconnect frame has been acknowledged but we must wait until we see his DISC before
				// completing this command and dropping the connection. 
				//
				//	We will use the pCommand pointer to track this disconnect command until we see partner's DISC frame
				//
				//	ALSO,  since our engine has now shutdown,  we might wait forever now for the final DISC from partner
				// if he crashes before transmitting it.  One final safeguard here is to set a timer which will make sure
				// this doesnt happen. * NOTE * no timer is actually being set here, we're depending on the keepalive
				// timeout, see EndPointBackgroundProcess.

				DPFX(DPFPREP,7, "(%p) EOS has been ACK'd, but we're still ACK'ing partner's disconnect", pEPD);
				
				ASSERT(pEPD->blHighPriSendQ.IsEmpty());
				ASSERT(pEPD->blNormPriSendQ.IsEmpty());
				ASSERT(pEPD->blLowPriSendQ.IsEmpty());

				// It is possible that something was already in the process of timing out when the disconnect
				// operation starts such that AbortSends gets called and clears this.
				ASSERT(pEPD->pCommand == NULL || pEPD->pCommand == pMSD);
					
				Unlock(&pEPD->EPLock);

				Unlock(&pMSD->CommandLock);
			}
		}
	}
}


/*
**		Build Data Frame
**
**		Setup the actual network packet header for transmission with our current link state info (Seq, NRcv).
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDataFrame"

UNALIGNED ULONGLONG * BuildDataFrame(PEPD pEPD, PFMD pFMD, DWORD tNow)
{
	PSPD		pSPD = pEPD->pSPD;
	PDFRAME		pFrame;
	UINT		index = 0;
		//if we need a full signature for the frame to be computed we track a pointer to its location
		//in the header using this var. We return this to the caller, allowwing them to tweak the data frame
		//after we've built and before it writes in the final sig
	UNALIGNED ULONGLONG * pullFullSig=NULL;
		//if we're build a coalesced frame we use this to hold the first reliable sub-frame we stick into it
		//(if there is one at all). This is then used if the frame is a candidate to modify the local secret
	PFMD pReliableFMD=NULL;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pFrame = (PDFRAME) pFMD->ImmediateData;
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;
	pFMD->uiRetry = 0;

	pFrame->bCommand = pFMD->bPacketFlags;
	pFrame->bControl = 0;	// this sets retry count to zero as well as clearing flags
	
	if (pFMD->ulFFlags & FFLAGS_END_OF_STREAM) 
	{
		pFrame->bControl |= PACKET_CONTROL_END_STREAM;
			//for pre dx9 protocol then we also have to flip a bit which indicates to receiver we want an immediate ack
			//for dx9 onwards we always assume that anyway for EOS
		if ((pEPD->ulEPFlags2 & EPFLAGS2_SUPPORTS_SIGNING)==0)
		{
			pFrame->bControl |= PACKET_CONTROL_CORRELATE;
		}
		
	}

	//  See if we are desiring an immediate response

	if(pFMD->ulFFlags & FFLAGS_CHECKPOINT)
	{
		pFrame->bCommand |= PACKET_COMMAND_POLL;
	}

	pFrame->bSeq = pEPD->bNextSend++;
	pFrame->bNRcv = pEPD->bNextReceive;		// Acknowledges all previous frames

	DPFX(DPFPREP,7, "(%p) N(S) incremented to %x", pEPD, pEPD->bNextSend);

	//	Piggyback NACK notes
	//
	//		Since the SP is now frequently mis-ordering frames we are enforcing a back-off period before transmitting a NACK after
	// a packet is received out of order. Therefore we have the Delayed Mask Timer which stalls the dedicated NACK.  Now we must
	// also make sure that the new NACK info doesn't get piggybacked too soon.  Therefore we will test the tReceiveMaskDelta timestamp
	// before including piggyback NACK info here,  and make sure that the mask is at least 5ms old.

	ULONG * rgMask=(ULONG * ) (pFrame+1);
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		if((tNow - pEPD->tReceiveMaskDelta) > 4)
		{
			DPFX(DPFPREP,7, "(%p) Installing NACK in DFRAME Seq=%x, NRcv=%x Low=%x High=%x", pEPD, pFrame->bSeq, pFrame->bNRcv, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
			if(pEPD->ulReceiveMask)
			{
				rgMask[index++] = pEPD->ulReceiveMask;
				pFrame->bControl |= PACKET_CONTROL_SACK_MASK1;
			}
			if(pEPD->ulReceiveMask2)
			{
				rgMask[index++] = pEPD->ulReceiveMask2;
				pFrame->bControl |= PACKET_CONTROL_SACK_MASK2;
			}

			pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) DECLINING TO PIGGYBACK NACK WITH SMALL TIME DELTA", pEPD);
		}
	}
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)
	{
		DPFX(DPFPREP,7, "(%p) Installing SENDMASK in DFRAME Seq=%x, Low=%x High=%x", pEPD, pFrame->bSeq, pEPD->ulSendMask, pEPD->ulSendMask2);
		if(pEPD->ulSendMask)
		{
			rgMask[index++] = pEPD->ulSendMask;
			pFrame->bControl |= PACKET_CONTROL_SEND_MASK1;
			pEPD->ulSendMask = 0;
		}
		if(pEPD->ulSendMask2)
		{
			rgMask[index++] = pEPD->ulSendMask2;
			pFrame->bControl |= PACKET_CONTROL_SEND_MASK2;
			pEPD->ulSendMask2 = 0;
		}
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_SENDMASK);
	}
	
	pFMD->uiImmediateLength = sizeof(DFRAME) + (index * sizeof(ULONG));
	pFMD->dwFirstSendTime = tNow;
	pFMD->dwLastSendTime = tNow;

		//if we're fast signing the link we can stuff the local secret straight in after the masks	
	if (pEPD->ulEPFlags2 & EPFLAGS2_FAST_SIGNED_LINK)
	{
		*((UNALIGNED ULONGLONG * ) (pFMD->ImmediateData+ pFMD->uiImmediateLength))=pEPD->ullCurrentLocalSecret;
		pFMD->uiImmediateLength+=sizeof(ULONGLONG);
	}
		//otherwise if we're full signing it we need to reserve a zero'd out space for the sig and then return the offset
		//to this sig. Just before sending the frame we'll then compute the hash and stuff it into this space
	else if (pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK)
	{
		pullFullSig=(UNALIGNED ULONGLONG * ) (pFMD->ImmediateData+ pFMD->uiImmediateLength);
		*pullFullSig=0;
		pFMD->uiImmediateLength+=sizeof(ULONGLONG);
	}
	
	if (pFMD->CommandID == COMMAND_ID_SEND_COALESCE)
	{
		COALESCEHEADER* paCoalesceHeaders;
		DWORD dwNumCoalesceHeaders;
		BUFFERDESC* pBufferDesc;
		CBilink* pLink;
		FMD* pRealFMD;

		
		pFrame->bControl |= PACKET_CONTROL_COALESCE;
		
		ASSERT(pFMD->SendDataBlock.dwBufferCount == 1);
		ASSERT(pFMD->uiFrameLength == 0);

		// Add in coalesce headers and copy the buffer descs for all of the subframes.
		paCoalesceHeaders = (COALESCEHEADER*) (pFMD->ImmediateData + pFMD->uiImmediateLength);
		dwNumCoalesceHeaders = 0;
		pBufferDesc = pFMD->rgBufferList;
		pLink = pFMD->blCoalesceLinkage.GetNext();
		while (pLink != &pFMD->blCoalesceLinkage)
		{
			pRealFMD = CONTAINING_OBJECT(pLink, FMD, blCoalesceLinkage);
			ASSERT_FMD(pRealFMD);
			
			ASSERT((pRealFMD->CommandID == COMMAND_ID_SEND_DATAGRAM) || (pRealFMD->CommandID == COMMAND_ID_SEND_RELIABLE));

			pRealFMD->dwFirstSendTime = tNow;
			pRealFMD->dwLastSendTime = tNow;

				//if we see a reliable subframe then hold onto a pointer to it. We may need its contents to modify
				//the local secret next time we wrap the sequence space
			if (pReliableFMD==NULL && pRealFMD->CommandID == COMMAND_ID_SEND_RELIABLE)
			{
				pReliableFMD=pRealFMD;
			}

			memcpy(&paCoalesceHeaders[dwNumCoalesceHeaders], pRealFMD->ImmediateData, sizeof(COALESCEHEADER));
			ASSERT(dwNumCoalesceHeaders < MAX_USER_BUFFERS_IN_FRAME);
			dwNumCoalesceHeaders++;

			// Change the immediate data buffer desc to point to a zero padding buffer if this packet
			// needs to be DWORD aligned, otherwise remove the immediate data pointer since we
			// don't use it.
			ASSERT(pRealFMD->SendDataBlock.pBuffers == (PBUFFERDESC) &pRealFMD->uiImmediateLength);
			ASSERT(pRealFMD->SendDataBlock.dwBufferCount > 1);
			ASSERT(pRealFMD->lpImmediatePointer == (pRealFMD->ImmediateData + 4));
			ASSERT(*((DWORD*) pRealFMD->lpImmediatePointer) == 0);
			if ((pFMD->uiFrameLength & 3) != 0)
			{
				pRealFMD->uiImmediateLength = 4 - (pFMD->uiFrameLength & 3);
			}
			else
			{
				pRealFMD->uiImmediateLength = 0;
				pRealFMD->SendDataBlock.pBuffers = pRealFMD->rgBufferList;
				pRealFMD->SendDataBlock.dwBufferCount--;
			}
			
			memcpy(pBufferDesc, pRealFMD->SendDataBlock.pBuffers, (pRealFMD->SendDataBlock.dwBufferCount * sizeof(BUFFERDESC)));
			pBufferDesc += pRealFMD->SendDataBlock.dwBufferCount;
			// Assert that this fits in pFMD->rgBufferList (use -1 because pFMD->ImmediateData doesn't count)
			ASSERT((pFMD->SendDataBlock.dwBufferCount - 1) + pRealFMD->SendDataBlock.dwBufferCount <= MAX_USER_BUFFERS_IN_FRAME);
			pFMD->SendDataBlock.dwBufferCount += pRealFMD->SendDataBlock.dwBufferCount;

			ASSERT(pFMD->uiImmediateLength + sizeof(COALESCEHEADER) <= sizeof(pFMD->ImmediateData));
			pFMD->uiImmediateLength += sizeof(COALESCEHEADER);
			
			ASSERT(pFMD->uiFrameLength + pRealFMD->uiImmediateLength + pRealFMD->uiFrameLength < pSPD->uiUserFrameLength);
			pFMD->uiFrameLength += pRealFMD->uiImmediateLength + pRealFMD->uiFrameLength;
			
			pLink = pLink->GetNext();
		}

		ASSERT(dwNumCoalesceHeaders > 0);
		paCoalesceHeaders[dwNumCoalesceHeaders - 1].bCommand |= PACKET_COMMAND_END_COALESCE;

		// If there's an odd number of coalescence headers, add zero padding so data starts
		// with DWORD alignment.
		DBG_CASSERT(sizeof(COALESCEHEADER) == 2);
		if ((dwNumCoalesceHeaders & 1) != 0)
		{
			*((WORD*) (&paCoalesceHeaders[dwNumCoalesceHeaders])) = 0;
			pFMD->uiImmediateLength += 2;
		}
	}
	else if ((pFMD->pMSD->CommandID == COMMAND_ID_KEEPALIVE) &&
			(pEPD->ulEPFlags2 & EPFLAGS2_SUPPORTS_SIGNING))
	{
			//if we've got a link that could be using signed then we need to send one of the new type of keep alives
			//that includes the session identity as data
		*((DWORD * ) (pFMD->ImmediateData+pFMD->uiImmediateLength))=pEPD->dwSessID;
		pFMD->uiImmediateLength+=sizeof(DWORD);
			//flip the bit that marks this frame as a keep alive
		pFrame->bControl |= PACKET_CONTROL_KEEPALIVE;
	}
		
	pFMD->uiFrameLength += pFMD->uiImmediateLength;

	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

	// Stop delayed mask timer
	if((pEPD->DelayedMaskTimer != 0)&&((pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)==0))
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMaskTimer)"); // SPLock not already held
			pEPD->DelayedMaskTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
	}
	
	// Stop delayed ack timer
	if(pEPD->DelayedAckTimer != 0)
	{					
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAckTimer)"); // SPLock not already held
			pEPD->DelayedAckTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
	}

		//if we've just built a reliable frame and we're fully signing the link then its a potential candidate for 
		//being used to modify the local secret
	if ((pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK) && (pFrame->bCommand & PACKET_COMMAND_RELIABLE) &&
		((pFrame->bControl  &  PACKET_CONTROL_KEEPALIVE)==0) && (pFrame->bSeq<pEPD->byLocalSecretModifierSeqNum))
	{
			//for a coalesced frame we'll have taken a pointer to the first reliable subframe we stored in it
			//otherwise we'll just use the existing frame
		if (pReliableFMD==NULL)
		{
			DNASSERT(pFMD->CommandID != COMMAND_ID_SEND_COALESCE);
			pReliableFMD=pFMD;
		}
		pEPD->byLocalSecretModifierSeqNum=pFrame->bSeq;
			//slight complication here is that a coalesced FMD may not have an immediate header, and hence its buffer count
			//will simply reflect the number of user data buffers. Hence, we test for this case and adjust accordingly
			//We only want to modify the secret using the reliable user data
		pEPD->ullLocalSecretModifier=GenerateLocalSecretModifier(pReliableFMD->rgBufferList, 
				(pReliableFMD->uiImmediateLength == 0) ? pReliableFMD->SendDataBlock.dwBufferCount :
																		pReliableFMD->SendDataBlock.dwBufferCount-1);
	}
		

	return pullFullSig;
}

/*
**		Build Retry Frame
**
**		Reinitialize those fields in the packet header that need to be recalculated for a retransmission.
**
**		Called and returns with EP lock held
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildRetryFrame"

UNALIGNED ULONGLONG * BuildRetryFrame(PEPD pEPD, PFMD pFMD)
{
	PSPD		pSPD = pEPD->pSPD;
	ULONG *		rgMask;
	UINT		index = 0;
	PDFRAME		pDFrame=(PDFRAME) pFMD->ImmediateData;
		//if we need a full signature for the frame to be computed we track a pointer to its location
		//in the header using this var. We return this to the caller, allowing them to tweak the data in the 
		//packet before writing in the final sig.
	UNALIGNED ULONGLONG * pullFullSig=NULL;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pDFrame->bNRcv = pEPD->bNextReceive;		// Use up-to-date ACK info

		//preserve the current EOS, coalescence and keep alive/correlate flags. All the sack and send masks are cleared 
	pDFrame->bControl &= PACKET_CONTROL_END_STREAM | PACKET_CONTROL_COALESCE | PACKET_CONTROL_KEEPALIVE;	

		//tag packet as a retry
	pDFrame->bControl |= PACKET_CONTROL_RETRY;

		//take a pointer to memory immediately after the dframe header. This is where
		//we'll store our ack masks
	rgMask = (ULONG *) (pDFrame+1);

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		if(pEPD->ulReceiveMask)
		{
			rgMask[index++] = pEPD->ulReceiveMask;
			pDFrame->bControl |= PACKET_CONTROL_SACK_MASK1;
		}
		if(pEPD->ulReceiveMask2)
		{
			rgMask[index++] = pEPD->ulReceiveMask2;
			pDFrame->bControl |= PACKET_CONTROL_SACK_MASK2;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
	}

	//	MUST NOT transmit the SendMasks with a retry because they are based on the CURRENT bNextSend value which is not
	// the N(S) that appears in this frame.  We could theoretically shift the mask to agree with this frame's sequence
	// number,  but that might shift relevent bits out of the mask.  Best thing to do is to let the next in-order send carry
	// the bit-mask or else wait for the timer to fire and send a dedicated packet.
	
	//	PLEASE NOTE -- Although we may change the size of the immediate data below we did not update the FMD->uiFrameLength
	// field.  This field is used to credit the send window when the frame is acknowledged,  and we would be wise to credit
	// the same value that we debited back when this frame was first sent.  We could adjust the debt now to reflect the new
	// size of the frame, but seriously, why bother?
	
	pFMD->uiImmediateLength = sizeof(DFRAME) + (index * 4);

		//if we're fast signing the link we can stuff the local secret straight in after the masks	
	if (pEPD->ulEPFlags2 & EPFLAGS2_FAST_SIGNED_LINK)
	{
		*((UNALIGNED ULONGLONG * ) (pFMD->ImmediateData+ pFMD->uiImmediateLength))=pEPD->ullCurrentLocalSecret;
		pFMD->uiImmediateLength+=sizeof(ULONGLONG);
	}
		//otherwise if we're full signing it we need to reserve a zero'd out space for the sig and store the offset of where
		//the caller to this function should place the final sig
	else if (pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK)
	{
		pullFullSig=(UNALIGNED ULONGLONG * ) (pFMD->ImmediateData+ pFMD->uiImmediateLength);
		*pullFullSig=0;
		pFMD->uiImmediateLength+=sizeof(ULONGLONG);
	}

	// Rebuild the coalesce header information, since we may have stripped some non-guaranteed data, or we may have just
	// changed the masks and overwritten our previous array.
	if (pDFrame->bControl & PACKET_CONTROL_COALESCE)
	{
		COALESCEHEADER* paCoalesceHeaders;
		DWORD dwNumCoalesceHeaders;
		DWORD dwUserDataSize;
		BUFFERDESC* pBufferDesc;
		CBilink* pLink;
		FMD* pRealFMD;


		// Reset the buffer count back to a single immediate data buffer.
		pFMD->SendDataBlock.dwBufferCount = 1;
		
		// Add in coalesce headers and copy the buffer descs for all of the subframes.
		paCoalesceHeaders = (COALESCEHEADER*) (pFMD->ImmediateData + pFMD->uiImmediateLength);
		dwNumCoalesceHeaders = 0;
		dwUserDataSize = 0;
		pBufferDesc = pFMD->rgBufferList;
		pLink = pFMD->blCoalesceLinkage.GetNext();
		while (pLink != &pFMD->blCoalesceLinkage)
		{
			pRealFMD = CONTAINING_OBJECT(pLink, FMD, blCoalesceLinkage);
			ASSERT_FMD(pRealFMD);
			
			// Datagrams get pulled out of the list as soon as they complete sending, and if the frame
			// hadn't finished sending when the retry timeout occurred we would have made a copy.
			// So we shouldn't see any datagrams here.
			ASSERT((pRealFMD->CommandID == COMMAND_ID_SEND_RELIABLE) || (pRealFMD->CommandID == COMMAND_ID_COPIED_RETRY));

			ASSERT(! pRealFMD->bSubmitted);
			pRealFMD->bSubmitted = TRUE;

			memcpy(&paCoalesceHeaders[dwNumCoalesceHeaders], pRealFMD->ImmediateData, sizeof(COALESCEHEADER));
			ASSERT(dwNumCoalesceHeaders < MAX_USER_BUFFERS_IN_FRAME);
			dwNumCoalesceHeaders++;

			// Change the immediate data buffer desc to point to a zero padding buffer if this packet
			// needs to be DWORD aligned, otherwise remove the immediate data pointer since we
			// don't use it.
			ASSERT(pRealFMD->lpImmediatePointer == (pRealFMD->ImmediateData + 4));
			ASSERT(*((DWORD*) pRealFMD->lpImmediatePointer) == 0);
			if ((dwUserDataSize & 3) != 0)
			{
				if (pRealFMD->SendDataBlock.pBuffers != (PBUFFERDESC) &pRealFMD->uiImmediateLength)
				{
					ASSERT(pRealFMD->SendDataBlock.pBuffers == pRealFMD->rgBufferList);
					pRealFMD->SendDataBlock.pBuffers = (PBUFFERDESC) &pRealFMD->uiImmediateLength;
					pRealFMD->SendDataBlock.dwBufferCount++;
				}
				else
				{
					ASSERT(pRealFMD->SendDataBlock.dwBufferCount > 1);
				}
				pRealFMD->uiImmediateLength = 4 - (dwUserDataSize & 3);
			}
			else
			{
				if (pRealFMD->SendDataBlock.pBuffers != pRealFMD->rgBufferList)
				{
					ASSERT(pRealFMD->SendDataBlock.pBuffers == (PBUFFERDESC) &pRealFMD->uiImmediateLength);
					pRealFMD->SendDataBlock.pBuffers = pRealFMD->rgBufferList;
					pRealFMD->SendDataBlock.dwBufferCount--;
					pRealFMD->uiImmediateLength = 0;
				}
				else
				{
					ASSERT(pRealFMD->SendDataBlock.dwBufferCount >= 1);
					ASSERT(pRealFMD->uiImmediateLength == 0);
				}
			}
			
			memcpy(pBufferDesc, pRealFMD->SendDataBlock.pBuffers, (pRealFMD->SendDataBlock.dwBufferCount * sizeof(BUFFERDESC)));
			pBufferDesc += pRealFMD->SendDataBlock.dwBufferCount;
			ASSERT((pFMD->SendDataBlock.dwBufferCount - 1) + pRealFMD->SendDataBlock.dwBufferCount <= MAX_USER_BUFFERS_IN_FRAME);	// don't include coalesce header frame immediate data
			pFMD->SendDataBlock.dwBufferCount += pRealFMD->SendDataBlock.dwBufferCount;

			ASSERT(pFMD->uiImmediateLength + sizeof(COALESCEHEADER) <= sizeof(pFMD->ImmediateData));
			pFMD->uiImmediateLength += sizeof(COALESCEHEADER);

			ASSERT(dwUserDataSize <= pFMD->uiFrameLength);
			dwUserDataSize += pRealFMD->uiImmediateLength + pRealFMD->uiFrameLength;
			
			pLink = pLink->GetNext();
		}

		ASSERT(dwNumCoalesceHeaders > 0);
		paCoalesceHeaders[dwNumCoalesceHeaders - 1].bCommand |= PACKET_COMMAND_END_COALESCE;

		// If there's an odd number of coalescence headers, add zero padding so data starts
		// with DWORD alignment.
		DBG_CASSERT(sizeof(COALESCEHEADER) == 2);
		if ((dwNumCoalesceHeaders & 1) != 0)
		{
			*((WORD*) (&paCoalesceHeaders[dwNumCoalesceHeaders])) = 0;
			pFMD->uiImmediateLength += 2;
		}
	}
	else if ((pDFrame->bControl & PACKET_CONTROL_KEEPALIVE) && (pEPD->ulEPFlags2 & EPFLAGS2_SUPPORTS_SIGNING))
	{
			//if we're sending one of the new style keep alives with a session id in it, we need to re-write the session id,
			//since we've potentially altered the length of the various send/ack masks before it
		*((DWORD * ) (pFMD->ImmediateData+pFMD->uiImmediateLength))=pEPD->dwSessID;
		pFMD->uiImmediateLength+=sizeof(DWORD);
	}

	pFMD->bSubmitted = TRUE;							// protected by EPLock
	
	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

	// Stop delayed ack timer
	if(pEPD->DelayedAckTimer != 0)
	{						
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAckTimer)");
			pEPD->DelayedAckTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
	}
	// Stop delayed mask timer
	if(((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)&&(pEPD->DelayedMaskTimer != 0))
	{	
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMaskTimer)"); // SPLock not already held
			pEPD->DelayedMaskTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
	}

	return pullFullSig;
}

/*
**		Build Coalesce Frame
**
**		Setup the sub-header for a single frame within a coalesced frame
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildCoalesceFrame"

VOID BuildCoalesceFrame(PFMD pCSD, PFMD pFMD)
{
	PCOALESCEHEADER		pSubFrame;

	pSubFrame = (PCOALESCEHEADER) pFMD->ImmediateData;

	// Make sure the DATA, NEW_MSG, and END_MSG flags are set.
	ASSERT((pFMD->bPacketFlags & (PACKET_COMMAND_DATA | PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG)) == (PACKET_COMMAND_DATA | PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG));
	// Turn off DATA, NEW_MSG and END_MSG because they are implied for coalesced subframes and we
	// use the same bits for coalesce specific info.
	// Turn off POLL flag, we use that bit for extended size information and it's not meaningful on subframes.
	pSubFrame->bCommand = pFMD->bPacketFlags & ~(PACKET_COMMAND_DATA | PACKET_COMMAND_POLL | PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG);
	ASSERT(! (pSubFrame->bCommand & (PACKET_COMMAND_END_COALESCE | PACKET_COMMAND_COALESCE_BIG_1 | PACKET_COMMAND_COALESCE_BIG_2 | PACKET_COMMAND_COALESCE_BIG_3)));

	ASSERT((pFMD->uiFrameLength > 0) && (pFMD->uiFrameLength <= MAX_COALESCE_SIZE));
	// Get the least significant 8 bits of the size.
	pSubFrame->bSize = (BYTE) pFMD->uiFrameLength;
	// Enable the 3 PACKET_COMMAND_COALESCE_BIG flags based on overflow from the size byte.
	pSubFrame->bCommand |= (BYTE) ((pFMD->uiFrameLength & 0x0000FF00) >> 5);

	// Change the immediate data buffer desc to point to a zero padding buffer in case this packet
	// needs to be DWORD aligned.
	ASSERT(pFMD->lpImmediatePointer == pFMD->ImmediateData);
	DBG_CASSERT(sizeof(COALESCEHEADER) <= 4);
	pFMD->lpImmediatePointer = pFMD->ImmediateData + 4;
	*((DWORD*) pFMD->lpImmediatePointer) = 0;
	ASSERT(pFMD->SendDataBlock.pBuffers == (PBUFFERDESC) &pFMD->uiImmediateLength);
	ASSERT(pFMD->SendDataBlock.dwBufferCount > 1);


	pCSD->bPacketFlags |= pFMD->bPacketFlags;
	pCSD->ulFFlags |= pFMD->ulFFlags;


	LOCK_FMD(pCSD, "Coalesce linkage");			// keep the container around until all subframes complete
	pFMD->pCSD = pCSD;
	pFMD->blCoalesceLinkage.InsertBefore(&pCSD->blCoalesceLinkage);

	LOCK_FMD(pFMD, "SP Submit (coalescence)");	// Bump RefCnt when submitting send
}

/*
**			Service Command Traffic
**
**		Presently this transmits all CFrames and Datagrams queued to the specific
**	Service Provider.  We may want to split out the datagrams from this so that
**	C frames can be given increased send priority but not datagrams.  With this
**	implementation DGs will get inserted into reliable streams along with Cframes.
**	This may or may not be what we want to do...
**
**	WE ENTER AND EXIT WITH SPD->SENDLOCK HELD,  although we release it during actual
**	calls to the SP.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "ServiceCmdTraffic"

VOID ServiceCmdTraffic(PSPD pSPD)
{
	CBilink	*pFLink;
	PFMD	pFMD;
	HRESULT	hr;

	AssertCriticalSectionIsTakenByThisThread(&pSPD->SPLock, TRUE);

	// WHILE there are frames ready to send
	while((pFLink = pSPD->blSendQueue.GetNext()) != &pSPD->blSendQueue)
	{	
		pFLink->RemoveFromList();												// Remove frame from queue

		pFMD = CONTAINING_OBJECT(pFLink,  FMD,  blQLinkage);		// get ptr to frame structure

		ASSERT_FMD(pFMD);

		// Place frame on pending queue before making call in case it completes really fast

#pragma BUGBUG(vanceo, "EPD lock is not held?")
		ASSERT(!pFMD->bSubmitted);
		pFMD->bSubmitted = TRUE;
		ASSERT(pFMD->blQLinkage.IsEmpty());
		pFMD->blQLinkage.InsertBefore( &pSPD->blPendingQueue);		// Place frame on pending queue
		Unlock(&pSPD->SPLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->SendData for FMD[%p], pSPD[%p]", pFMD->pEPD, pFMD, pSPD);
/*send*/if((hr = IDP8ServiceProvider_SendData(pSPD->IISPIntf, &pFMD->SendDataBlock)) != DPNERR_PENDING)
		{
			(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, (PVOID) pFMD);
		}

		Lock(&pSPD->SPLock);
	}	// While SENDs are on QUEUE
}

/*
**		Run Send Thread
**
**		There is work for this SP's send thread.  Keep running until
**	there is no more work to do.
**
**		Who gets first priority, DG or Seq traffic?  I will  say DG b/c its
**	advertised as lowest overhead...
**
**		Datagram packets get Queued on the SP when they are ready to ship.
**	Reliable packets are queued on the EPD.  Therefore,  we will queue the
**	actual EPD on the SPD when they have reliable traffic to send,  and then
**	we will service individual EPDs from this loop.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RunSendThread"

VOID CALLBACK RunSendThread(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique)
{
	PSPD	pSPD = (PSPD) pvUser;
	ASSERT_SPD(pSPD);

	DPFX(DPFPREP,7, "Send Thread Runs pSPD[%p]", pSPD);

	Lock(&pSPD->SPLock);

	if(!pSPD->blSendQueue.IsEmpty())
	{
		ServiceCmdTraffic(pSPD);
	}

	pSPD->ulSPFlags &= ~(SPFLAGS_SEND_THREAD_SCHEDULED);

	Unlock(&pSPD->SPLock);
}

/*
**		Scheduled Send
**
**		If this EPD is still unentitled to send, start draining frames.  Otherwise transition
**	link to IDLE state.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ScheduledSend"

VOID CALLBACK
ScheduledSend(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique)
{
	PEPD	pEPD = (PEPD) pvUser;
	const SPD*	pSPD = pEPD->pSPD;

	ASSERT_EPD(pEPD);
	ASSERT_SPD(pSPD);

	Lock(&pEPD->EPLock);
	
	pEPD->SendTimer = 0;

	DPFX(DPFPREP,7, "(%p) Scheduled Send Fires", pEPD);

	ASSERT(pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE);

	// Test that all three flags are set before starting to transmit

	if( (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED) && (
			((pEPD->ulEPFlags & (EPFLAGS_STREAM_UNBLOCKED | EPFLAGS_SDATA_READY)) == (EPFLAGS_STREAM_UNBLOCKED | EPFLAGS_SDATA_READY))
			|| (pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED))) 
	{
		ServiceEPD(pEPD->pSPD, pEPD); // releases EPLock
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Session leaving pipeline", pEPD);
		
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);
		
		RELEASE_EPD(pEPD, "UNLOCK (leaving pipeline, SchedSend done)"); // releases EPLock
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "HandlePerFrameState"

VOID HandlePerFrameState(PMSD pMSD, PFMD pFMD)
{
	PEPD pEPD;
	CBilink* pFLink;

	pEPD = pFMD->pEPD;
	
	LOCK_EPD(pEPD, "LOCK (Send Data Frame)");				// Keep EPD around while xmitting frame
	
	pFLink = pFMD->blMSDLinkage.GetNext();					// Get next frame in Msg

	// Was this the last frame in Msg?
	if(pFLink == &pMSD->blFrameList)
	{						
		// Last frame in message has been sent.
		//
		// We used to setup the next frame now,  but with the multi-priority queues it makes more sense to look for the
		// highest priority send when we are ready to send it.
		
		pEPD->pCurrentSend = NULL;
		pEPD->pCurrentFrame = NULL;

		// When completing a send,  set the POLL flag if there are no more sends on the queue

#ifndef DPNBUILD_NOMULTICAST
		if (!(pEPD->ulEPFlags2 & (EPFLAGS2_MULTICAST_SEND|EPFLAGS2_MULTICAST_RECEIVE)))
#endif // !DPNBUILD_NOMULTICAST
		{	
			// Request immediate reply if no more data to send
			if(pEPD->uiQueuedMessageCount == 0)
			{					
				((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; 
			}
		}
	}
	else 
	{
		pEPD->pCurrentFrame = CONTAINING_OBJECT(pFLink, FMD, blMSDLinkage);
		ASSERT_FMD(pEPD->pCurrentFrame);
	}

	ASSERT(!pFMD->bSubmitted);
	pFMD->bSubmitted = TRUE;								// Protected by EPLock
	ASSERT(! (pFMD->ulFFlags & FFLAGS_TRANSMITTED));
	pFMD->ulFFlags |= FFLAGS_TRANSMITTED;					// Frame will be owned by SP
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetNextEligibleMessage"

PMSD GetNextEligibleMessage(PEPD pEPD)
{
	PMSD pMSD;
	CBilink* pLink;

	if( (pLink = pEPD->blHighPriSendQ.GetNext()) == &pEPD->blHighPriSendQ)
	{
		if( (pLink = pEPD->blNormPriSendQ.GetNext()) == &pEPD->blNormPriSendQ)
		{
			if( (pLink = pEPD->blLowPriSendQ.GetNext()) == &pEPD->blLowPriSendQ)
			{
				return NULL;
			}
		}
	}
	pMSD = CONTAINING_OBJECT(pLink, MSD, blQLinkage);
	ASSERT_MSD(pMSD);

	return pMSD;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CanCoalesceMessage"

BOOL CanCoalesceMessage(PEPD pEPD, PMSD pMSD, DWORD * pdwSubFrames, DWORD * pdwBuffers, DWORD * pdwUserFrameLength)
{
	PFMD pTempFMD;
	DWORD dwAdditionalBuffers;
	DWORD dwAdditionalUserFrameLength;
	DWORD dwComparisonFrameLength;
	
	if (pMSD->uiFrameCount > 1)
	{
		DPFX(DPFPREP, 3, "(%p) Message 0x%p spans %u frames, declining", pEPD, pMSD, pMSD->uiFrameCount);
		return FALSE;
	}

	pTempFMD = CONTAINING_OBJECT(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
	ASSERT_FMD(pTempFMD);
	ASSERT(pTempFMD->blMSDLinkage.GetNext() == &pMSD->blFrameList);

	if (pTempFMD->ulFFlags & FFLAGS_DONT_COALESCE)
	{
		DPFX(DPFPREP, 3, "(%p) Message 0x%p frame 0x%p should not be coalesced (flags 0x%x)", pEPD, pMSD, pTempFMD, pTempFMD->ulFFlags);
		return FALSE;
	}

	if (pTempFMD->uiFrameLength > MAX_COALESCE_SIZE)
	{
		DPFX(DPFPREP, 3, "(%p) Message 0x%p frame 0x%p is %u bytes, declining", pEPD, pMSD, pTempFMD, pTempFMD->uiFrameLength);
		return FALSE;
	}

	// Find out how many buffers currently exist and would need to be added.
	// We may need to pad the end of a previous coalesce framed so that this one is aligned.
	// Keep in mind that dwBufferCount already includes an immediate data header.
	dwAdditionalBuffers = pTempFMD->SendDataBlock.dwBufferCount - 1;
	dwAdditionalUserFrameLength = pTempFMD->uiFrameLength;
	if ((*pdwUserFrameLength & 3) != 0)
	{
		dwAdditionalBuffers++;
		dwAdditionalUserFrameLength += 4 - (*pdwUserFrameLength & 3);
	}
	dwComparisonFrameLength = ((*pdwSubFrames) * sizeof(COALESCEHEADER)) + *pdwUserFrameLength + dwAdditionalUserFrameLength;
	DBG_CASSERT(sizeof(COALESCEHEADER) == 2);
	if ((*pdwSubFrames & 1) != 0)
	{
		dwComparisonFrameLength += 2;
	}
	
	if ((dwAdditionalBuffers + *pdwBuffers) > MAX_USER_BUFFERS_IN_FRAME)
	{
		DPFX(DPFPREP, 3, "(%p) Message 0x%p frame 0x%p %u buffers + %u existing buffers exceeds max, declining", pEPD, pMSD, pTempFMD, dwAdditionalBuffers, *pdwBuffers);
		return FALSE;
	}

	if (dwComparisonFrameLength > pEPD->pSPD->uiUserFrameLength)
	{
		DPFX(DPFPREP, 3, "(%p) Message 0x%p frame 0x%p %u bytes (%u existing, %u added user bytes) exceeds max frame size %u, declining",
			pEPD, pMSD, pTempFMD, dwComparisonFrameLength, *pdwUserFrameLength, dwAdditionalUserFrameLength, pEPD->pSPD->uiUserFrameLength);
		return FALSE;
	}

	*pdwSubFrames += 1;
	*pdwBuffers += dwAdditionalBuffers;
	*pdwUserFrameLength += dwAdditionalUserFrameLength;

	return TRUE;
}

/*
**		Service EndPointDescriptor
**
**		This includes reliable,  datagram,  and re-transmit
**	frames.  Retransmissions are ALWAYS transmitted first,  regardless of the orginal message's
**	priority.  After that datagrams and reliable messages are taken in priority order, in FIFO
**	order within a priority class.
**
**		The number of frames drained depends upon the current window parameters.
**
**		If the pipeline goes idle or the stream gets blocked we will still schedule the next
**	send.  This way if we unblock or un-idle before the gap has expired we will not get to cheat
**	and defeat the gap.  The shell routine above us (ScheduledSend) will take care of removing us
**	from the pipeline if the next burst gets scheduled and we are still not ready to send.
**
**
**	** CALLED WITH EPD->EPLock HELD;  Returns with EPLock RELEASED **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ServiceEPD"

VOID ServiceEPD(PSPD pSPD, PEPD pEPD)
{
	PMSD		pMSD;
	PFMD		pFMD;
	PFMD		pCSD = NULL;  // Descriptor for coalesence
	DWORD		dwSubFrames = 0;
	DWORD		dwBuffers = 0;
	DWORD		dwUserFrameLength = 0;
	UNALIGNED ULONGLONG * pullFrameSig=NULL;
#ifdef DBG
	UINT		uiFramesSent = 0;
	UINT		uiRetryFramesSent = 0;
	UINT		uiCoalescedFramesSent = 0;
#endif // DBG
	HRESULT		hr;
	DWORD		tNow = GETTIMESTAMP();
#ifndef DPNBUILD_NOMULTICAST
	PMCASTFRAME	pMCastFrame;
#endif // !DPNBUILD_NOMULTICAST


	/*
	** 		Now we will drain reliable traffic from EPDs on the pipeline list
	*/

	// The caller should have checked this
	ASSERT( pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED );

	// Burst Credit can either be positive or negative depending upon how much of our last transmit slice we used

	DPFX(DPFPREP,7, "(%p) BEGIN UNLIMITED BURST", pEPD);

	//	 Transmit a burst from this EPD,  as long as its unblocked and has data ready.  We do not re-init
	// burst counter since any retries sent count against our burst limit
	//
	//	This has become more complex now that we are interleaving datagrams and reliable frames.  There are two
	// sets of priority-based send queues.  The first is combined DG and Reliable and the second is datagram only.
	// when the reliable stream is blocked we will feed from the DG only queues,  otherwise we will take from the
	// interleaved queue.
	//	This is further complicated by the possibility that a reliable frame can be partially transmitted at any time.
	// So before looking at the interleaved queues we must check for a partially completed reliable send (EPD.pCurrentSend).
	//
	//	** pEPD->EPLock is held **

	while(((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED) && (pEPD->ulEPFlags & EPFLAGS_SDATA_READY)) 
		  || (pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED))
	{
		// Always give preference to shipping retries before new data
		if(pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED)
		{
			pFMD = CONTAINING_OBJECT(pEPD->blRetryQueue.GetNext(), FMD, blQLinkage);
			ASSERT_FMD(pFMD);
			pFMD->blQLinkage.RemoveFromList();
			pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue
			if(pEPD->blRetryQueue.IsEmpty())
			{
				pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
			}

			// pMSD->uiFrameCount will be decremented when this completes

			pullFrameSig=BuildRetryFrame(pEPD, pFMD);							// Place current state information in retry frame

			DPFX(DPFPREP,7, "(%p) Shipping RETRY frame: Seq=%x, FMD=%p Size=%d", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD, pFMD->uiFrameLength);

#ifdef DBG
			uiFramesSent++;
			uiRetryFramesSent++;
#endif // DBG
		}
		else 
		{
			if((pMSD = pEPD->pCurrentSend) != NULL)
			{
				// We won't allow coalesence for multi-frame messages since they are composed mostly of 
				// full frames already.
				ASSERT_MSD(pMSD);
				pFMD = pEPD->pCurrentFrame;						// Get the next frame due to send

				DPFX(DPFPREP, 7, "(%p) Continuing multi-frame message 0x%p with frame 0x%p.", pEPD, pMSD, pFMD);

				HandlePerFrameState(pMSD, pFMD);
			}
			else 
			{
				pMSD = GetNextEligibleMessage(pEPD);
				if( pMSD == NULL )
				{
					goto EXIT_SEND;								// All finished sending for now
				}
				
				while (TRUE)
				{
					pFMD = CONTAINING_OBJECT(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
					ASSERT_FMD(pFMD);

#ifdef DBG
					ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
					pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif // DBG

					pMSD->blQLinkage.RemoveFromList();
					ASSERT(pEPD->uiQueuedMessageCount > 0);
					--pEPD->uiQueuedMessageCount;						// keep count of MSDs on all send queues
					
					pMSD->ulMsgFlags2 |= MFLAGS_TWO_TRANSMITTING;		// We have begun to transmit frames from this Msg

					pEPD->pCurrentSend = pMSD;
					pEPD->pCurrentFrame = pFMD;
					pFMD->bPacketFlags |= PACKET_COMMAND_NEW_MSG;
					pMSD->blQLinkage.InsertBefore( &pEPD->blCompleteSendList);	// Place this on PendingList now so we can keep track of it

					HandlePerFrameState(pMSD, pFMD);

					if (pEPD->ulEPFlags2 & EPFLAGS2_NOCOALESCENCE)
					{
						DPFX(DPFPREP, 1, "(%p) Coalescence is disabled, sending single message in frame", pEPD);
						break;
					}
					
#if (! defined(DPNBUILD_NOMULTICAST))
					if (pEPD->ulEPFlags2 & EPFLAGS2_MULTICAST_SEND)
					{	
						DPFX(DPFPREP, 7, "(%p) Endpoint is multicast, sending single message in frame", pEPD);
						break;
					}
					ASSERT(! pEPD->ulEPFlags2 & EPFLAGS2_MULTICAST_RECEIVE)
#endif

					// The first time through we won't have a CSD yet
					if (pCSD == NULL)
					{
						// See if this first message can be coalesced.
						if (!CanCoalesceMessage(pEPD, pMSD, &dwSubFrames, &dwBuffers, &dwUserFrameLength))
						{
							break;
						}
					
						// Get the next potential message.
						pMSD = GetNextEligibleMessage(pEPD);
						if (pMSD == NULL)
						{
							DPFX(DPFPREP, 7, "(%p) No more messages in queue to coalesce", pEPD);
							break;
						}
						ASSERT_MSD(pMSD);
						
						// See if the next potential message can be coalesced.
						if (!CanCoalesceMessage(pEPD, pMSD, &dwSubFrames, &dwBuffers, &dwUserFrameLength))
						{
							break;
						}

						if((pCSD = (PFMD)POOLALLOC(MEMID_COALESCE_FMD, &FMDPool)) == NULL)
						{
							// Oh well, we just don't get to coalesce this time
							DPFX(DPFPREP, 0, "(%p) Unable to allocate FMD for coalescing, won't coalesce this round", pEPD);
							break;
						}

						pCSD->CommandID = COMMAND_ID_SEND_COALESCE;
						pCSD->uiFrameLength = 0;
						pCSD->bSubmitted = TRUE;
						pCSD->pMSD = NULL;
						pCSD->pEPD = pEPD;
						
						LOCK_EPD(pEPD, "LOCK (send data frame coalesce header)");	// Keep EPD around while xmitting frame

						// Attach this individual frame onto the coalescence descriptor
						DPFX(DPFPREP,7, "(%p) Beginning coalesced frame 0x%p with %u bytes in %u buffers from frame 0x%p (flags 0x%x)", pEPD, pCSD, pFMD->uiFrameLength, (pFMD->SendDataBlock.dwBufferCount - 1), pFMD, pFMD->bPacketFlags);
						BuildCoalesceFrame(pCSD, pFMD);
#ifdef DBG
						uiCoalescedFramesSent++;		// Count coalesced frames sent this burst
#endif // DBG
					}
					else
					{
						ASSERT_FMD(pCSD);

						// Attach this individual frame onto the coalescence descriptor
						DPFX(DPFPREP,7, "(%p) Coalescing frame 0x%p (flags 0x%x) with %u bytes in %u buffers into header 0x%p (subframes=%u, buffers=%u, framelength=%u)", pEPD, pFMD, pFMD->bPacketFlags, pFMD->uiFrameLength, (pFMD->SendDataBlock.dwBufferCount - 1), pCSD, dwSubFrames, dwBuffers, dwUserFrameLength);
						BuildCoalesceFrame(pCSD, pFMD);
#ifdef DBG
						uiCoalescedFramesSent++;		// Count coalesced frames sent this burst
#endif // DBG
					
						// Get the next potential message.
						pMSD = GetNextEligibleMessage(pEPD);
						if (pMSD == NULL)
						{
							DPFX(DPFPREP, 7, "(%p) No more messages in queue to coalesce", pEPD);
							break;
						}
						ASSERT_MSD(pMSD);
	
						// See if the next potential message can be coalesced, too.
						if (!CanCoalesceMessage(pEPD, pMSD, &dwSubFrames, &dwBuffers, &dwUserFrameLength))
						{
							break;
						}
					}
				} // while (attempting to coalesce)
			}
			ASSERT_FMD(pFMD);
			ASSERT(pFMD->bSubmitted);

			// When we get here we either have a single frame to send in pFMD, or
			// multiple frames to coalesce into one frame in pCSD.
			if (pCSD != NULL)
			{
				ASSERT_FMD(pCSD);
				ASSERT(pCSD->bSubmitted);
				pFMD = pCSD;
			}

#ifndef DPNBUILD_NOMULTICAST
			if (pEPD->ulEPFlags2 & (EPFLAGS2_MULTICAST_SEND|EPFLAGS2_MULTICAST_RECEIVE))
			{	
				// Build the protocol header for the multicast frame
				pFMD->uiImmediateLength = sizeof(MCASTFRAME);
				pMCastFrame = (PMCASTFRAME)pFMD->ImmediateData;
				pMCastFrame->dwVersion = DNET_VERSION_NUMBER;
				do
				{
					pMCastFrame->dwSessID = DNGetGoodRandomNumber();
				}
				while (pMCastFrame->dwSessID==0);
				pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;
				pFMD->uiFrameLength += pFMD->uiImmediateLength;

				DPFX(DPFPREP,7, "(%p) Shipping Multicast Frame: FMD=%p", pEPD, pFMD);
			}
			else
#endif // !DPNBUILD_NOMULTICAST
			{
				pullFrameSig=BuildDataFrame(pEPD, pFMD, tNow);								// place current state info in frame
				
				pFMD->blWindowLinkage.InsertBefore( &pEPD->blSendWindow); // Place at trailing end of send window
				pFMD->ulFFlags |= FFLAGS_IN_SEND_WINDOW;
				LOCK_FMD(pFMD, "Send Window");							// Add reference for send window

				pEPD->uiUnackedBytes += pFMD->uiFrameLength;				// Track the unacknowleged bytes in the pipeline

				// We can always go over the limit, but will be blocked until we drop below the limit again.
				if(pEPD->uiUnackedBytes >= pEPD->uiWindowB)
				{				
					pEPD->ulEPFlags &= ~(EPFLAGS_STREAM_UNBLOCKED);	
					pEPD->ulEPFlags |= EPFLAGS_FILLED_WINDOW_BYTE;		// Tells us to increase window if all is well
					
	  				((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; // Request immediate reply
				}
				
				// Count frames in the send window
				if((++pEPD->uiUnackedFrames) >= pEPD->uiWindowF)
				{			
					pEPD->ulEPFlags &= ~(EPFLAGS_STREAM_UNBLOCKED);
					((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; // Request immediate reply
					pEPD->ulEPFlags |= EPFLAGS_FILLED_WINDOW_FRAME;		// Tells us to increase window if all is well
				}
				
				// We will only run one retry timer for each EndPt.  If we already have one running then do nothing.

#ifndef DPNBUILD_NOPROTOCOLTESTITF
				if(!(pEPD->ulEPFlags2 & EPFLAGS2_DEBUG_NO_RETRIES))
#endif // !DPNBUILD_NOPROTOCOLTESTITF
				{
					// If there was already a frame in the pipeline it should already have a clock running
					if(pEPD->uiUnackedFrames == 1)
					{
						ASSERT(pEPD->RetryTimer == 0);
						pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;			// This one is being measured
						LOCK_EPD(pEPD, "LOCK (set retry timer)");										// bump RefCnt for timer
						DPFX(DPFPREP,7, "(%p) Setting Retry Timer on Seq=0x%x, FMD=%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
						ScheduleProtocolTimer(pSPD, pEPD->uiRetryTimeout, 0, RetryTimeout, 
																(PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique);
					}
					else
					{
						ASSERT(pEPD->RetryTimer != 0);
					}
				}

				DPFX(DPFPREP,7, "(%p) Shipping Dataframe: Seq=%x, NRcv=%x FMD=%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, ((PDFRAME) pFMD->ImmediateData)->bNRcv, pFMD);
			}

				//track the number of bytes we're about to send
			if(pFMD->ulFFlags & FFLAGS_RELIABLE)
			{
				pEPD->uiGuaranteedFramesSent++;
				pEPD->uiGuaranteedBytesSent += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
			}
			else 
			{
					// Note that multicast sends will use these values for statistics as will datagrams
				pEPD->uiDatagramFramesSent++;
				pEPD->uiDatagramBytesSent += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
			}
			LOCK_FMD(pFMD, "SP Submit");							// Bump RefCnt when submitting send
		}

		ASSERT(pFMD->bSubmitted);
#ifdef DBG
		uiFramesSent++;											// Count frames sent this burst
#endif // DBG

			//if we're fully signing links we have to generate the sig for this frame
			//we might also have to update our local secret if we've just about to wrap our sequence space
		if (pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK)
		{
			PDFRAME pDFrame=(PDFRAME) pFMD->ImmediateData;
				//since we're fully signed the Build*Frame function must have given us an offset to write
				//the signature into
			DNASSERT(pullFrameSig);
				//if the next frame is a retry then we might have to sign using our old local secret
			if (pDFrame->bControl & PACKET_CONTROL_RETRY)
			{
					//corner case here is when we've already wrapped into the 1st quarter of the send window
					//but this retry had a sequence number in the final quarter of the send window
				if (pEPD->bNextSend<SEQ_WINDOW_1Q && pDFrame->bSeq>=SEQ_WINDOW_3Q)
				{
					*pullFrameSig=GenerateOutgoingFrameSig(pFMD, pEPD->ullOldLocalSecret);
				}
					//otherwise simply sign the retry with the current local secret
				else
				{
					*pullFrameSig=GenerateOutgoingFrameSig(pFMD, pEPD->ullCurrentLocalSecret);
				}
			}
			else
			{
					//for none retries we always sign with the current secret
				*pullFrameSig=GenerateOutgoingFrameSig(pFMD, pEPD->ullCurrentLocalSecret);
					//If this is the last frame in the current sequence space we should evolve our local secret
				if (pDFrame->bSeq==(SEQ_WINDOW_4Q-1))
				{
					pEPD->ullOldLocalSecret=pEPD->ullCurrentLocalSecret;
					pEPD->ullCurrentLocalSecret=GenerateNewSecret(pEPD->ullCurrentLocalSecret, pEPD->ullLocalSecretModifier);
						//reset the message seq num we talk the modifier value from. We'll use the lowest reliable message
						//sent in this next sequence space as the next modifier for the local secret
					pEPD->byLocalSecretModifierSeqNum=SEQ_WINDOW_3Q;
				}	
			}
		}
				

		// We guarantee to the SP that we will never have a zero lead byte
		ASSERT(pFMD->ImmediateData[0] != 0);

		// Make sure anything after the header is DWORD aligned.
		ASSERT((pFMD->uiImmediateLength % 4) == 0);

		// Make sure we're giving the SP something.
		ASSERT(pFMD->uiFrameLength > 0);

		// Make sure we're not giving the SP something it says it can't support.
		ASSERT(pFMD->uiFrameLength <= pSPD->uiFrameLength);

		// bSubmitted must not be set to true for a data frame without the EPLock being held, because
		// the retry logic will be checking bSubmitted with only the EPLock held.
		Unlock(&pEPD->EPLock); 

		// PROCEED WITH TRANSMISSION...

		Lock(&pSPD->SPLock);
		ASSERT(pFMD->blQLinkage.IsEmpty());
		pFMD->blQLinkage.InsertBefore( &pSPD->blPendingQueue);	// Place frame on pending queue
		Unlock(&pSPD->SPLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->SendData for FMD[%p]", pEPD, pFMD);
/*send*/if((hr = IDP8ServiceProvider_SendData(pSPD->IISPIntf, &pFMD->SendDataBlock)) != DPNERR_PENDING)
		{
			(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, (PVOID) pFMD);
		}

		// We don't track coalescence headers in an MSD, so we don't need the initial reference.
		if (pCSD != NULL)
		{
			ASSERT(pCSD == pFMD);
			RELEASE_FMD(pCSD, "Coalescence header local reference");
			pCSD = NULL;
			dwSubFrames = 0;
			dwBuffers = 0;
			dwUserFrameLength = 0;
		}

		Lock(&pEPD->EPLock);
		
	}	// WHILE (unblocked, undrained, & bandwidth credit avail)

EXIT_SEND:

	ASSERT(pCSD == NULL);

	if((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED)==0)
	{
		pEPD->uiWindowFilled++;								// Count the times we filled the window
	}

	// Clear data-ready flag if everything is sent
	if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
	{	
		pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
	}


	// As commented in procedure-header above,  we will remain on the pipeline for one timer-cycle
	// so that if we unblock or un-idle we will not send until the gap is fullfilled.
	if((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED)) == (EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED))
	{		// IF BOTH flags are set
		DPFX(DPFPREP,7, "(%p) %d (%d, %d) frame BURST COMPLETED - Sched next send in %dms, N(Seq)=%x",
			pEPD, uiFramesSent, uiRetryFramesSent, uiCoalescedFramesSent, pEPD->uiBurstGap, pEPD->bNextSend);
	}
	else if((pEPD->ulEPFlags & EPFLAGS_SDATA_READY)==0)
	{
		DPFX(DPFPREP,7, "(%p) %d (%d, %d) frame BURST COMPLETED (%d/%d) - LINK IS IDLE N(Seq)=%x",
			pEPD, uiFramesSent, uiRetryFramesSent, uiCoalescedFramesSent, pEPD->uiUnackedFrames, pEPD->uiWindowF, pEPD->bNextSend);
	}
	else
	{
		ASSERT((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED) == 0);
		DPFX(DPFPREP,7, "(%p) %d (%d, %d) frame BURST COMPLETED (%d/%d) - STREAM BLOCKED N(Seq)=%x",
			pEPD, uiFramesSent, uiRetryFramesSent, uiCoalescedFramesSent, pEPD->uiUnackedFrames, pEPD->uiWindowF, pEPD->bNextSend);
	}

	ASSERT(pEPD->SendTimer == 0);

	if(pEPD->uiBurstGap != 0)
	{
		DPFX(DPFPREP,7, "(%p) Setting Scheduled Send Timer for %d ms", pEPD, pEPD->uiBurstGap);
		ScheduleProtocolTimer(pSPD, pEPD->uiBurstGap, 4, ScheduledSend, (PVOID) pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
		Unlock(&pEPD->EPLock);

		// NOTE: We still hold the pipeline reference
	}
	else 
	{
		DPFX(DPFPREP,7, "(%p) Session leaving pipeline", pEPD);
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);

		RELEASE_EPD(pEPD, "UNLOCK (leaving pipeline)"); // releases EPLock
	}
}	

/*
**			Retry Timeout
**
**		Retry timer fires when we have not seen an acknowledgement for a packet
**	we sent in more then twice (actually 1.25 X) our measured RTT.  Actually,  that is
**	just our base calculation.  We will also measure empirical ACK times and adjust our timeout
**	to some multiple of that.  Remember that our partner may be delaying his Acks to wait for back-traffic.
**
**  Or we can measure avg deviation of Tack and base retry timer on that.
**
**		In any case,  its time to re-transmit the base frame in our send window...
**
**		Important note:  Since we can generate retries via bitmask in return traffic,  it is possible that
**	we have just retried when the timer fires.
**
**		Note on Locks:  Since the retry timer is directly associated with an entry on the EPD SendQueue,
**	we always protect retry-related operations with the EPD->SPLock.   We only hold the EPD->StateLock
**	when we mess with link state variables (NRcv,  DelayedAckTimer).
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RetryTimeout"

#ifdef DBG
LONG g_RetryCount[MAX_SEND_RETRIES_TO_DROP_LINK+1]={0};
#endif // DBG

VOID CALLBACK
RetryTimeout(void * const pvUser, void * const uID, const UINT Unique)
{
	PEPD	pEPD = (PEPD) pvUser;
	PSPD	pSPD = pEPD->pSPD;
	PProtocolData pPData = pSPD->pPData;
	PFMD	pFMD;
	DWORD	tNow = GETTIMESTAMP(), tDelta;
	UINT	delta;
	CBilink	*pLink;
	PFMD	pRealFMD;

	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	DPFX(DPFPREP,7, "(%p) Retry Timeout fires", pEPD);

#ifndef DPNBUILD_NOPROTOCOLTESTITF
	ASSERT(!(pEPD->ulEPFlags2 & EPFLAGS2_DEBUG_NO_RETRIES));
#endif // !DPNBUILD_NOPROTOCOLTESTITF

	// Make sure link is still active
	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{				
		DPFX(DPFPREP,7, "(%p) Not connected, exiting", pEPD);
		pEPD->RetryTimer = 0;

		RELEASE_EPD(pEPD, "UNLOCK (retry timer not-CONN)");		// Decrement RefCnt for timer, releases EPLock
		return;
	}

	// Its possible when we schedule a new retry timer that the previous timer cannot be cancelled. In this
	// case the timer Handle &| Unique field will be different,  and we do not want to run the event.

	// Make sure this isn't a leftover event
	if((pEPD->RetryTimer != uID) || (pEPD->RetryTimerUnique != Unique))
	{	
		DPFX(DPFPREP,7, "(%p) Stale retry timer, exiting", pEPD);

		RELEASE_EPD(pEPD, "UNLOCK (stale retry timer)"); // releases EPLock
		return;
	}

	pEPD->RetryTimer = 0;

	// Make sure that we still have transmits in progress

	if(pEPD->uiUnackedFrames > 0) 
	{
		ASSERT(!pEPD->blSendWindow.IsEmpty());
		pFMD = CONTAINING_OBJECT(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);	// Top frame in window

		ASSERT_FMD(pFMD);
		ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);

		//	First we must make sure that the TO'd packet is still hanging around.  Since the first packet
		// in the window might have changed while the TO was being scheduled,  the easiest thing to do is
		// just recalculate the top packets expiration time and make sure its really stale.

		tDelta = tNow - pFMD->dwLastSendTime;		// When did we last send this frame?

		if(tDelta > pEPD->uiRetryTimeout)
		{
			// Its a genuine timeout.  Lets retransmit the frame!

			DPFX(DPFPREP,7, "(%p) RETRY TIMEOUT %d on Seq=%x, pFMD=0x%p", pEPD, (pFMD->uiRetry + 1), ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);

			// Count a retry
			if(++pFMD->uiRetry > pPData->dwSendRetriesToDropLink)
			{					
				// BOOM!  No more retries.  We are finished.  Link is going DOWN!
				DPFX(DPFPREP,1, "(%p) DROPPING LINK, retries exhausted", pEPD);

				DECREMENT_EPD(pEPD, "UNLOCK (retry timer drop)");// Release reference for this timer

				DropLink(pEPD);		// releases EPLock

				return;
			}

#ifdef DBG
			DNInterlockedIncrement(&g_RetryCount[pFMD->uiRetry]); 
#endif // DBG

			// calculate timeout for next retry
			if(pFMD->uiRetry == 1)
			{
				// do a retry at the same timeout - this is games after all.
				tDelta = pEPD->uiRetryTimeout;
			} 
			else if (pFMD->uiRetry <= 3) 
			{
				// do a couple of linear backoffs - this is a game after all
				tDelta = pEPD->uiRetryTimeout * pFMD->uiRetry;
			}
			else if (pFMD->uiRetry < 8)
			{
				// doh, bad link, bad bad link, do exponential backoffs
				tDelta = pEPD->uiRetryTimeout * (1 << pFMD->uiRetry);
			} 
			else 
			{
				// don't give up too quickly.
				tDelta = pPData->dwSendRetryIntervalLimit;
			}
			
			if(tDelta >=pPData->dwSendRetryIntervalLimit)
			{
				// CAP TOTAL DROP TIME AT 50 seconds unless the RTT is huge
				tDelta = _MAX(pPData->dwSendRetryIntervalLimit, pEPD->uiRTT);
			}

			// Unreliable frame!
			if ((pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM) ||
				((pFMD->CommandID == COMMAND_ID_SEND_COALESCE) && (! (pFMD->ulFFlags & FFLAGS_RELIABLE))))
			{		
				// When an unreliable frame is NACKed we will not retransmit the data.  We will instead send
				// a mask so that the other side knows to cancel it.

				DPFX(DPFPREP,7, "(%p) RETRY TIMEOUT for UNRELIABLE FRAME", pEPD);

				// We get to credit the frame as out of the window.
				pEPD->uiUnackedBytes -= pFMD->uiFrameLength;

				// Only count a datagram drop on the first occurance
				if(pFMD->uiRetry == 1)
				{
					pEPD->uiDatagramFramesDropped++;	
					pEPD->uiDatagramBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
					EndPointDroppedFrame(pEPD, tNow);
				}

				// Diff between next send and this send.
				delta = (pEPD->bNextSend - ((PDFRAME) pFMD->ImmediateData)->bSeq) & 0xFF ; 

				ASSERT(delta != 0);
				ASSERT(delta < (MAX_RECEIVE_RANGE + 1));

				if(delta < 33)
				{
					pEPD->ulSendMask |= (1 << (delta - 1));
				}
				else
				{
					pEPD->ulSendMask2 |= (1 << (delta - 33));
				}

				pFMD->uiFrameLength = 0;
				pEPD->ulEPFlags |= EPFLAGS_DELAYED_SENDMASK;
				
				if(pEPD->DelayedMaskTimer == 0)
				{
					DPFX(DPFPREP,7, "(%p) Setting Delayed Mask Timer", pEPD);
					LOCK_EPD(pEPD, "LOCK (delayed mask timer - send retry)");
					ScheduleProtocolTimer(pSPD, DELAYED_SEND_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD,
															&pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
				}
			}

			// RELIABLE FRAME -- Send a retry	
			else 
			{		
				pEPD->uiGuaranteedFramesDropped++;							// Keep count of lost frames
				pEPD->uiGuaranteedBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);	// Keep count of lost frames
				pFMD->dwLastSendTime = tNow;

				pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);		// No longer waiting to send Ack info

				// Stop delayed ack timer
				if(pEPD->DelayedAckTimer != 0)
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
					if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
					{
						DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAck)"); // SPLock not already held
					}
					else
					{
						DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					}
					pEPD->DelayedAckTimer = 0;
				}

				EndPointDroppedFrame(pEPD, tNow);

				if(pFMD->ulFFlags & FFLAGS_RETRY_QUEUED)
				{
					// It's still on the Retry Queue.  This should not happen when everything is working
					// properly.  Timeouts should be greater than RTT and the BurstGap should be less than RTT.

					DPFX(DPFPREP,1, "(%p) RETRY FIRES WHILE FMD IS STILL IN RETRY QUEUE pFMD=%p", pEPD, pFMD);

					pFMD = NULL;
				}
				else if(pFMD->bSubmitted)
				{
					// Woe on us.  We would like to retry a frame that has not been completed by the SP!
					//
					//		This will most typically happen when we are debugging which delays processing
					//	of the Complete,  but it could also happen if the SP is getting hammered.  We need
					//	to copy the FMD into a temporary descriptor which can be discarded upon completion...

					DPFX(DPFPREP,1,"(%p) RETRYING %p but its still busy. Substituting new FMD", pEPD, pFMD);
					pFMD = CopyFMD(pFMD, pEPD);							// We will substitute new FMD in rest of procedure
				}
				else 
				{
					DPFX(DPFPREP,7, "(%p) Sending Retry of N(S)=%x, pFMD=0x%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
					LOCK_FMD(pFMD, "SP retry submit");
				}

				if(pFMD)
				{
					LOCK_EPD(pEPD, "LOCK (retry rely frame)");
					pEPD->ulEPFlags |= EPFLAGS_RETRIES_QUEUED;
					pFMD->ulFFlags |= FFLAGS_RETRY_QUEUED;

					// Increment the frame count for all relevant FMDs.
					if ((pFMD->CommandID == COMMAND_ID_SEND_COALESCE) ||
						(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE))
					{
						// Loop through each subframe and update its state.
						pLink = pFMD->blCoalesceLinkage.GetNext();
						while (pLink != &pFMD->blCoalesceLinkage)
						{
							pRealFMD = CONTAINING_OBJECT(pLink, FMD, blCoalesceLinkage);
							ASSERT_FMD(pRealFMD);
							
							// Datagrams get pulled out of the list as soon as they complete sending, and if the frame
							// hadn't finished sending we would have made a copy above.  So we shouldn't see any
							// datagrams here.
							ASSERT((pRealFMD->CommandID == COMMAND_ID_SEND_RELIABLE) || (pRealFMD->CommandID == COMMAND_ID_COPIED_RETRY));

							LOCK_EPD(pEPD, "LOCK (retry rely frame coalesce)");

							// Add a frame reference if it's not a temporary copy.
							if (pRealFMD->CommandID != COMMAND_ID_COPIED_RETRY)
							{
								LOCK_FMD(pRealFMD, "SP retry submit (coalesce)");
							}

							ASSERT_MSD(pRealFMD->pMSD);
							pRealFMD->pMSD->uiFrameCount++; // Protected by EPLock, retries prevent completion until they complete
							DPFX(DPFPREP, DPF_FRAMECNT_LVL, "(%p) Frame count incremented on coalesced retry timeout, pMSD[%p], framecount[%u]", pEPD, pRealFMD->pMSD, pRealFMD->pMSD->uiFrameCount);

							pLink = pLink->GetNext();
						}

						DPFX(DPFPREP, 7, "(0x%p) Coalesced retry frame 0x%p (original was %u bytes in %u buffers).", pEPD, pFMD, pFMD->uiFrameLength, pFMD->SendDataBlock.dwBufferCount);

#pragma TODO(vanceo, "Would be nice to credit window")
						/*
						// Similar to uncoalesced datagram sends, we get to credit the non-reliable part of this frame
						// as being out of the window.  We won't update the nonguaranteed stats, the data was
						// counted in the guaranteed stats update above.
						pEPD->uiUnackedBytes -= uiOriginalFrameLength - pFMD->uiFrameLength;
						ASSERT(pEPD->uiUnackedBytes <= MAX_RECEIVE_RANGE * pSPD->uiFrameLength);
						ASSERT(pEPD->uiUnackedBytes > 0);
						ASSERT(pEPD->uiUnackedFrames > 0);
						*/
					}
					else
					{
						ASSERT_MSD(pFMD->pMSD);
						pFMD->pMSD->uiFrameCount++; // Protected by EPLock, retries prevent completion until they complete
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "(%p) Frame count incremented on retry timeout, pMSD[%p], framecount[%u]", pEPD, pFMD->pMSD, pFMD->pMSD->uiFrameCount);
					}
					ASSERT(pFMD->blQLinkage.IsEmpty());
					pFMD->blQLinkage.InsertBefore( &pEPD->blRetryQueue);		// Place frame on Send queue

					if((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
					{
						DPFX(DPFPREP,7, "(%p) Scheduling Send", pEPD);
						pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
						LOCK_EPD(pEPD, "LOCK (pipeline)");
						ScheduleProtocolWork(pSPD, ScheduledSend, pEPD);
					}
				}
			}	// ENDIF RETRY
		}
		else 
		{
			tDelta = pEPD->uiRetryTimeout - tDelta;
		}

		DPFX(DPFPREP,7, "(%p) Setting Retry Timer for %d ms", pEPD, tDelta); 
		//	Dont LOCK_EPD here because we never released the lock from the timer which scheduled us here
		pEPD->RetryTimer=uID;
		RescheduleProtocolTimer(pSPD, pEPD->RetryTimer, tDelta, 20, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimerUnique);

		Unlock(&pEPD->EPLock);
	}
	else 
	{
		RELEASE_EPD(pEPD, "UNLOCK (RetryTimer no frames out)");	// drop RefCnt since we dont restart timer, releases EPLock
	}
}

/*
**		Copy FMD
**
**			This routine allocates a new Frame Descriptor and copies all fields from the provided
**		FMD into it.  All fields except CommandID,  RefCnt,  and Flags.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CopyFMD"

PFMD CopyFMD(PFMD pFMD, PEPD pEPD)
{
	PFMD	pNewFMD;
	CBilink	*pLink;
	PFMD	pSubFrame;
	PFMD	pNewSubFrame;

	if((pNewFMD = (PFMD)(POOLALLOC(MEMID_COPYFMD_FMD, &FMDPool))) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate new FMD");
		return NULL;
	}

	LOCK_EPD(pEPD, "LOCK (CopyFMD)");

	memcpy(pNewFMD, pFMD, sizeof(FMD));

	// Undo the copying of these members
	pNewFMD->blMSDLinkage.Initialize();
	pNewFMD->blQLinkage.Initialize();
	pNewFMD->blWindowLinkage.Initialize();
	pNewFMD->blCoalesceLinkage.Initialize();

	if ((pFMD->CommandID == COMMAND_ID_SEND_COALESCE) ||
		(pFMD->CommandID == COMMAND_ID_COPIED_RETRY_COALESCE))
	{
		pNewFMD->CommandID = COMMAND_ID_COPIED_RETRY_COALESCE;

		// We need to make copies of all the reliable subframes.
		ASSERT(! pFMD->blCoalesceLinkage.IsEmpty());
		pLink = pFMD->blCoalesceLinkage.GetNext();
		while (pLink != &pFMD->blCoalesceLinkage)
		{
			pSubFrame = CONTAINING_OBJECT(pLink, FMD, blCoalesceLinkage);
			ASSERT_FMD(pSubFrame);

			if (pSubFrame->CommandID != COMMAND_ID_SEND_DATAGRAM)
			{
				ASSERT((pSubFrame->CommandID == COMMAND_ID_SEND_RELIABLE) || (pSubFrame->CommandID == COMMAND_ID_COPIED_RETRY));
				
				pNewSubFrame = CopyFMD(pSubFrame, pEPD);
				if(pNewSubFrame == NULL)
				{
					DPFX(DPFPREP,0, "Failed to copy new subframe FMD");

					// Free all the subframes we've successfully copied so far.
					while (! pNewFMD->blCoalesceLinkage.IsEmpty())
					{
						pNewSubFrame = CONTAINING_OBJECT(pNewFMD->blCoalesceLinkage.GetNext(), FMD, blCoalesceLinkage);
						ASSERT_FMD(pNewSubFrame);
						pNewSubFrame->blCoalesceLinkage.RemoveFromList();
						RELEASE_FMD(pNewSubFrame, "Final subframe release on mem fail");
					}

					// Free the copied coalescence header.
					RELEASE_FMD(pNewFMD, "Final release on mem fail");
					return NULL;
				}
				
				// Change the immediate data buffer desc to point to a zero padding buffer in case this
				// packet needs to be DWORD aligned.
				ASSERT(pNewSubFrame->lpImmediatePointer == pNewSubFrame->ImmediateData);
				DBG_CASSERT(sizeof(COALESCEHEADER) <= 4);
				pNewSubFrame->lpImmediatePointer = pNewSubFrame->ImmediateData + 4;
				*((DWORD*) pNewSubFrame->lpImmediatePointer) = 0;
				ASSERT(pNewSubFrame->SendDataBlock.pBuffers == (PBUFFERDESC) &pNewSubFrame->uiImmediateLength);
				if (pSubFrame->SendDataBlock.pBuffers != (PBUFFERDESC) &pSubFrame->uiImmediateLength)
				{
					ASSERT(pSubFrame->SendDataBlock.pBuffers == pSubFrame->rgBufferList);
					pNewSubFrame->SendDataBlock.pBuffers = pNewSubFrame->rgBufferList;
				}
				else
				{
					ASSERT(pNewSubFrame->SendDataBlock.dwBufferCount > 1);
				}

				// Copied coalesced retries don't maintain a reference on their containing header.
				pNewSubFrame->pCSD = NULL;
				pNewSubFrame->blCoalesceLinkage.InsertBefore(&pNewFMD->blCoalesceLinkage);
			}			
			else
			{
				// Datagrams should get pulled out of the list as soon as they complete so we normally we
				// wouldn't see them at retry time.  But we're making a copy because the original frame
				// is still in the SP, so there could be uncompleted datagrams still here.
				DPFX(DPFPREP, 1, "(0x%p) Not including datagram frame 0x%p that's still in the SP", pEPD, pSubFrame);
			}
			
			pLink = pLink->GetNext();
		}
	}
	else
	{
		ASSERT((pFMD->CommandID == COMMAND_ID_SEND_RELIABLE) || (pFMD->CommandID == COMMAND_ID_COPIED_RETRY));
		pNewFMD->CommandID = COMMAND_ID_COPIED_RETRY;
	}
	pNewFMD->lRefCnt = 1;
	pNewFMD->ulFFlags = 0;
	pNewFMD->bSubmitted = FALSE;

	pNewFMD->lpImmediatePointer = (LPVOID) pNewFMD->ImmediateData;
	pNewFMD->SendDataBlock.pBuffers = (PBUFFERDESC) &pNewFMD->uiImmediateLength;
	pNewFMD->SendDataBlock.pvContext = pNewFMD;
	pNewFMD->SendDataBlock.hCommand = 0;
	ASSERT(	pNewFMD->pEPD == pEPD);

	DPFX(DPFPREP,7, "COPYFMD -- replacing FMD %p with copy %p", pFMD, pNewFMD);

	return pNewFMD;
}

/*			
**			Send Command Frame
**
**		Build a CFrame addressed to the specified EndPoint, and Queue it on the SPD
**	to be sent.
**
**	** THIS FUNCTION CALLED WITH EPD->EPLOCK HELD. IF bSendDirect IS FALSE IT RETURNS		**
**	** WITH THE LOCK STILL HELD. IF bSendDirect IS TRUE IT RETURNS WITH THE EPD LOCK RELEASED **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendCommandFrame"

HRESULT	SendCommandFrame(PEPD pEPD, BYTE ExtOpcode, BYTE RspID, ULONG ulFFlags, BOOL bSendDirect)
{
	PSPD		pSPD = pEPD->pSPD;
	PFMD		pFMD;
	PCFRAME		pCFrame;
	PCHKPT		pChkPt;
	DWORD		tNow = GETTIMESTAMP();

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Frame already initialized to 1 buffer
	if((pFMD = (PFMD)POOLALLOC(MEMID_SENDCMD_FMD, &FMDPool)) == NULL)
	{				
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD", pEPD);
		if (bSendDirect)
		{
			Unlock(&pEPD->EPLock);
		}
		return DPNERR_OUTOFMEMORY;
	}

	pCFrame = (PCFRAME)pFMD->ImmediateData;
	pCFrame->bCommand = 0;

	// If this frame requires a response (or if we are specifically asked to) we will build
	// a Checkpoint structure which will be stored to correlate the eventual response with
	// the original frame.
	if(	(pEPD->ulEPFlags & EPFLAGS_CHECKPOINT_INIT)||
		(ExtOpcode == FRAME_EXOPCODE_CONNECT)) 
	{
		if((pChkPt = (PCHKPT)POOLALLOC(MEMID_CHKPT, &ChkPtPool)) != NULL)
		{
			pChkPt->bMsgID = pEPD->bNextMsgID;				// Note next ID in CP structure
			pCFrame->bCommand |= PACKET_COMMAND_POLL;		// make this frame a CP
			pEPD->ulEPFlags &= ~EPFLAGS_CHECKPOINT_INIT;
			pChkPt->tTimestamp = tNow;
			pChkPt->blLinkage.Initialize();
			pChkPt->blLinkage.InsertBefore(&pEPD->blChkPtQueue);
		}
		else
		{
			// If we need a checkpoint and don't get one, then the operation can't succeed
			// because the response won't be able to be correllated.
			DPFX(DPFPREP,0, "(%p) Failed to allocate new CHKPT", pEPD);
			RELEASE_FMD(pFMD, "Final Release on Mem Fail");
			if (bSendDirect)
			{
				Unlock(&pEPD->EPLock);
			}
			return DPNERR_OUTOFMEMORY;
		}
	}

	pFMD->pEPD = pEPD;										// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (Prep Cmd Frame)");				// Bump RefCnt on EPD until send is completed
	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;										// this will indicate a NON-Data frame
	pFMD->uiImmediateLength = sizeof(CFRAME);				// standard size for C Frames
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;			// Place address in frame
	
	pFMD->ulFFlags=ulFFlags;								//whatever flags for frame caller has specified

	pCFrame->bCommand |= PACKET_COMMAND_CFRAME;
	pCFrame->bExtOpcode = ExtOpcode;
	pCFrame->dwVersion = DNET_VERSION_NUMBER;
	pCFrame->bRspID = RspID;
	pCFrame->dwSessID = pEPD->dwSessID;
	pCFrame->tTimestamp = tNow;
	pCFrame->bMsgID = pEPD->bNextMsgID++;					// include MsgID in frame

		//if we're sending a hard disconnect and the link is signed then we also need to sign the hard disconnect frame
	if ((ExtOpcode==FRAME_EXOPCODE_HARD_DISCONNECT) && (pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK))
	{
		UNALIGNED ULONGLONG * pullSig=(UNALIGNED ULONGLONG * ) (pFMD->ImmediateData+ pFMD->uiImmediateLength);
		pFMD->uiImmediateLength+=sizeof(ULONGLONG);
			//fast signing is trivial, simply store the local secret as the sig in the outgoing frame 
		if (pEPD->ulEPFlags2 & EPFLAGS2_FAST_SIGNED_LINK)
		{
			*pullSig=pEPD->ullCurrentLocalSecret;
		}
			//otherwise if we're full signing it we need to hash the frame to generate the sig
		else
		{
			DNASSERT(pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK);
				//we stuff the next data frame sequence num in each hard disconnects response id
				//this allows the receiver to work out what secret it should be using to check the signature
			pCFrame->bRspID = pEPD->bNextSend;
				//zero the space where this sig goes so we have a known packet state to hash over
			*pullSig=0;
			*pullSig=GenerateOutgoingFrameSig(pFMD, pEPD->ullCurrentLocalSecret);													
				
		}
	}

	pFMD->uiFrameLength = pFMD->uiImmediateLength ;

		//take SP lock and queue frame up for sending
	Lock(&pSPD->SPLock);	
	ASSERT(pFMD->blQLinkage.IsEmpty());
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
		//if we want to commit the send immediately then do so, otherwise schedule worker thread
		//to do the send if necessary
	if (bSendDirect)
	{
		Unlock(&pEPD->EPLock);
			//call with SP lock held and EPD lock released
		ServiceCmdTraffic(pSPD); 
			//returns with SP lock still held
			
	}
	else
	{
		if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
		{
			DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
			pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
			ScheduleProtocolWork(pSPD, RunSendThread, pSPD);
		}
	}
	Unlock(&pSPD->SPLock);
	return DPN_OK;
}

/*
**	SendConnectedSignedFrame
**
**	Sends a connected signed cframe in response to receiving one
**	This is called when this side is connecting (as opposed to listening) and we've just
** 	receiveived a CONNECTEDSIGNED frame from the listener.
**
** 	Called with EP lock held and returns with it held
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendConnectedSignedFrame"

HRESULT SendConnectedSignedFrame(PEPD pEPD, CFRAME_CONNECTEDSIGNED * pCFrameRecv, DWORD tNow)
{
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	PSPD		pSPD = pEPD->pSPD;

		//get a frame to send
	PFMD pFMD=(PFMD) POOLALLOC(MEMID_SENDCMD_FMD, &FMDPool);
	if (pFMD== NULL)
	{				
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD", pEPD);
		return DPNERR_OUTOFMEMORY;
	}

	pFMD->pEPD = pEPD;									// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (Prep Cmd Frame)");				// Bump RefCnt on EPD until send is completed
	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;											// this will indicate a NON-Data frame
	pFMD->uiImmediateLength = sizeof(CFRAME_CONNECTEDSIGNED);			
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;					// Place address in frame
	pFMD->uiFrameLength = sizeof(CFRAME_CONNECTEDSIGNED);		// Never have user data in Cframe
	pFMD->ulFFlags=0;

		//fill out fields common to all CFRAMES
	CFRAME_CONNECTEDSIGNED * pCFrameSend = (CFRAME_CONNECTEDSIGNED *) pFMD->ImmediateData;
	pCFrameSend->bCommand = PACKET_COMMAND_CFRAME;
	pCFrameSend->bExtOpcode = FRAME_EXOPCODE_CONNECTED_SIGNED;
	pCFrameSend->dwVersion = DNET_VERSION_NUMBER;
	pCFrameSend->bRspID = 0;
	pCFrameSend->dwSessID = pCFrameRecv->dwSessID;
	pCFrameSend->tTimestamp = tNow;
	pCFrameSend->bMsgID = pEPD->bNextMsgID++;	

		//and fill out fields specific to CONNECTEDSIGNED frames
	pCFrameSend->ullConnectSig=pCFrameRecv->ullConnectSig;
	pCFrameSend->ullSenderSecret=pEPD->ullCurrentLocalSecret;
	pCFrameSend->ullReceiverSecret=pEPD->ullCurrentRemoteSecret;
	pCFrameSend->dwSigningOpts=pCFrameRecv->dwSigningOpts;
	pCFrameSend->dwEchoTimestamp=pCFrameRecv->tTimestamp;

		//take SP lock and queue frame up for sending
	Lock(&pSPD->SPLock);	
	ASSERT(pFMD->blQLinkage.IsEmpty());
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
	if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
	{
		DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
		pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
		ScheduleProtocolWork(pSPD, RunSendThread, pSPD);
	}
	Unlock(&pSPD->SPLock);
	return DPN_OK;
}

/*
**		Send Ack Frame
**
**		This routine is called to immediately transmit our current receive
**	state to the indicated EndPoint.  This is equivalent to acknowledging
**	all received frames.  We may want to change this routine so that it
**	will attempt to piggyback the ack if there is data waiting to be sent.
**
**		THIS ROUTINE IS CALLED WITH EDP->EPLOCK HELD, BUT RELEASES IT IF DirectFlag IS SET
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendAckFrame"

VOID SendAckFrame(PEPD pEPD, BOOL DirectFlag, BOOL fFinalAck/* = FALSE*/)
{
	PSPD		pSPD = pEPD->pSPD;
	PFMD		pFMD;
	UINT		index = 0;
	PSACKFRAME8		pSackFrame;
	ASSERT_SPD(pSPD);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Frame already initialized to 1 buffer
	if((pFMD = (PFMD)POOLALLOC(MEMID_ACK_FMD, &FMDPool)) == NULL)
	{		
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD", pEPD);
		if(DirectFlag)
		{
			Unlock(&pEPD->EPLock);
		}
		return;
	}

	// We can stop all delayed Ack timers since we are sending full status here.
	if(pEPD->DelayedAckTimer != 0)
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAck timer)");
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
		pEPD->DelayedAckTimer = 0;
	}
	if(pEPD->DelayedMaskTimer != 0)
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMask timer)");
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
		pEPD->DelayedMaskTimer = 0;
	}

	if (fFinalAck)
	{
		pFMD->ulFFlags |= FFLAGS_FINAL_ACK;
	}

	pFMD->pEPD = pEPD;								// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (SendAckFrame)");			// Bump RefCnt on EPD until send is completed

	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;								// this will indicate a NON-Data frame
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;

	// Now that DG and S have been merged,  there are no longer 3 flavors of ACK frame.  We are back to only
	// one flavor that may or may not have detailed response info on one frame.  Actually,  I think we can
	// always include response info on the last ack'd frame.

	pSackFrame = (PSACKFRAME8) pFMD->ImmediateData;

	pSackFrame->bCommand = PACKET_COMMAND_CFRAME;
	pSackFrame->bExtOpcode = FRAME_EXOPCODE_SACK;
	pSackFrame->bNSeq = pEPD->bNextSend;
	pSackFrame->bNRcv = pEPD->bNextReceive;
	pSackFrame->bFlags = 0;
	pSackFrame->bReserved1 = 0;
	pSackFrame->bReserved2 = 0;
	pSackFrame->tTimestamp = pEPD->tLastDataFrame;

	ULONG * rgMask=(ULONG * ) (pSackFrame+1);

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		DPFX(DPFPREP,7, "(%p) SENDING SACK WITH *NACK* N(R)=%x Low=%x High=%x", pEPD, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
		if(pEPD->ulReceiveMask)
		{
			rgMask[index++] = pEPD->ulReceiveMask;
			pSackFrame->bFlags |= SACK_FLAGS_SACK_MASK1;
		}
		if(pEPD->ulReceiveMask2)
		{
			rgMask[index++] = pEPD->ulReceiveMask2;
			pSackFrame->bFlags |= SACK_FLAGS_SACK_MASK2;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
	}
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)
	{
		DPFX(DPFPREP,7, "(%p) SENDING SACK WITH SEND MASK N(S)=%x Low=%x High=%x", pEPD, pEPD->bNextSend, pEPD->ulSendMask, pEPD->ulSendMask2);
		if(pEPD->ulSendMask)
		{
			rgMask[index++] = pEPD->ulSendMask;
			pSackFrame->bFlags |= SACK_FLAGS_SEND_MASK1;
			pEPD->ulSendMask = 0;
		}
		if(pEPD->ulSendMask2)
		{
			rgMask[index++] = pEPD->ulSendMask2;
			pSackFrame->bFlags |= SACK_FLAGS_SEND_MASK2;
			pEPD->ulSendMask2 = 0;
		}
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_SENDMASK);
	}

	pSackFrame->bFlags |= SACK_FLAGS_RESPONSE;			// time fields are always valid now

#ifdef DBG
	ASSERT(pEPD->bLastDataSeq == (BYTE) (pEPD->bNextReceive - 1));
#endif // DBG

	pSackFrame->bRetry = pEPD->bLastDataRetry;
	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);

	pFMD->uiImmediateLength = sizeof(SACKFRAME8) + (index * sizeof(ULONG));
		//if we've got a signed link we'd better sign this frame. Signature goes at the end after the various masks
	if (pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK)
	{
		UNALIGNED ULONGLONG * pullSig=(UNALIGNED ULONGLONG * ) (pFMD->ImmediateData+ pFMD->uiImmediateLength);
		pFMD->uiImmediateLength+=sizeof(ULONGLONG);
			//fast signed link is trivial simply insert the local secret as the sig			
		if (pEPD->ulEPFlags2 & EPFLAGS2_FAST_SIGNED_LINK)
		{
			*pullSig=pEPD->ullCurrentLocalSecret;
		}
		else
		{
				//otherwise if we're full signing it we need to hash the frame to generate the sig
			DNASSERT(pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK);
			*pullSig=0;
			*pullSig=GenerateOutgoingFrameSig(pFMD, pEPD->ullCurrentLocalSecret);
		}
	}
	pFMD->uiFrameLength = pFMD->uiImmediateLength;
	
	DPFX(DPFPREP,7, "(%p) SEND SACK FRAME N(Rcv)=%x, EPD->LDRetry=%d, pFrame->Retry=%d pFMD=%p", pEPD, pEPD->bNextReceive, pEPD->bLastDataRetry, pSackFrame->bRetry, pFMD);
	
	// We can either schedule a worker thread to do the send or else we can do the work ourselves.  
	// The DirectFlag tells us whether we are in a time-crit section,  like processing
	// receive data, or whether we are free to call the SP ourselves.

	Lock(&pSPD->SPLock);								// Place SACK frame on send queue
	ASSERT(pFMD->blQLinkage.IsEmpty());
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
	
	if(DirectFlag)
	{
		// ServiceCmdTraffic will call into the SP so we must not hold the EPD lock
		Unlock(&pEPD->EPLock);
		ServiceCmdTraffic(pSPD); // Called with SPLock held
	}
	else 
	{
		if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
		{
			DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
			pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
			ScheduleProtocolWork(pSPD, RunSendThread, pSPD);
		}
	}
	Unlock(&pSPD->SPLock);
}

/*
**		Delayed Ack Timeout
**
**			We are waiting for a chance to piggyback a reliable frame acknowledgement,
**		but the sands have run out.  Its time to send a dedicated Ack now.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DelayedAckTimeout"

VOID CALLBACK DelayedAckTimeout(void * const pvUser, void * const uID, const UINT uMsg)
{
	PEPD	pEPD = (PEPD) pvUser;

	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	DPFX(DPFPREP,7, "(%p) Delayed Ack Timer fires", pEPD);
	if((pEPD->DelayedAckTimer == uID)&&(pEPD->DelayedAckTimerUnique == uMsg))
	{
		pEPD->DelayedAckTimer = 0;
	}
	else if((pEPD->DelayedMaskTimer == uID)&&(pEPD->DelayedMaskTimerUnique == uMsg))
	{
		pEPD->DelayedMaskTimer = 0;
	}
	else
	{
		// Stale timer, ignore
		DPFX(DPFPREP,7, "(%p) Stale Delayed Ack Timer, ignoring", pEPD);
		RELEASE_EPD(pEPD, "UNLOCK (DelayedAck complete)");	// release reference for timer, releases EPLock
		return;
	}

#ifndef DPNBUILD_NOPROTOCOLTESTITF
	if (pEPD->ulEPFlags & EPFLAGS_NO_DELAYED_ACKS)
	{
		DPFX(DPFPREP,7, "(%p) DEBUG: Skipping delayed ACK due to test request", pEPD);
	}
	else
#endif // !DPNBUILD_NOPROTOCOLTESTITF
	{
		if( (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED) && (pEPD->ulEPFlags & (EPFLAGS_DELAY_ACKNOWLEDGE | EPFLAGS_DELAYED_NACK | EPFLAGS_DELAYED_SENDMASK)))
		{
			DPFX(DPFPREP,7, "(%p) Sending ACK frame", pEPD);
			SendAckFrame(pEPD, 0); 
		}	
		else
		{
			DPFX(DPFPREP,7, "(%p) Nothing to do, ACK already occurred or no longer connected", pEPD);
		}
	}

	RELEASE_EPD(pEPD, "UNLOCK (DelayedAck complete)");	// release reference for timer, releases EPLock
}


/*
**		Send Keep Alive
**
**		When we have not received anything from an endpoint in a long time (default 60 sec)
**	will will initiate a checkpoint to make sure that the partner is still connected.  We do
**	this by inserting a zero-data frame into the reliable pipeline.  Thereby,  the standard
**	timeout & retry mechanisms will either confirm or drop the link as appropriate.  Logic above
**	this routine will have already verified that we are not already sending reliable traffic, which
**	would eliminate the need for a keep alive frame.
**
**	*** EPD->EPLock is held on Entry and return
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendKeepAlive"

VOID
SendKeepAlive(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(pEPD->ulEPFlags & EPFLAGS_KEEPALIVE_RUNNING)
	{
		DPFX(DPFPREP,7, "Ignoring duplicate KeepAlive");
		return;
	}

	pEPD->ulEPFlags |= EPFLAGS_KEEPALIVE_RUNNING;

	if( (pMSD = (PMSD)POOLALLOC(MEMID_KEEPALIVE_MSD, &MSDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "(%p) Failed to allocate new MSD");
		pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
		return;
	}

	if((pFMD = (PFMD)POOLALLOC(MEMID_KEEPALIVE_FMD, &FMDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD");
		Lock(&pMSD->CommandLock);								// An MSD must be locked to be released
		RELEASE_MSD(pMSD, "Release On FMD Get Failed");
		pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
		return;
	}
	
	// Initialize the frame count AFTER we are sure we have a frame or MSD_Release will assert
	pMSD->uiFrameCount = 1;
	DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Initialize Frame count, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_KEEPALIVE;

	pMSD->pEPD = pEPD;
	pMSD->pSPD = pEPD->pSPD;
	LOCK_EPD(pEPD, "LOCK (SendKeepAlive)");						// Add a reference for this checkpoint

	pFMD->ulFFlags |= FFLAGS_CHECKPOINT | FFLAGS_END_OF_MESSAGE | FFLAGS_DONT_COALESCE;
	pFMD->bPacketFlags = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_END_MSG;
	pFMD->uiFrameLength = 0;									// No user data in this frame
	pFMD->blMSDLinkage.InsertAfter( &pMSD->blFrameList);		// Attach frame to MSD
	pFMD->pMSD = pMSD;											// Link frame back to message
	pFMD->pEPD = pEPD;
	pFMD->CommandID = COMMAND_ID_SEND_RELIABLE;
	pMSD->CommandID = COMMAND_ID_KEEPALIVE;	// Mark MSD for completion handling
		//N.B. We set the priority has high to handle a problem with the signed connect sequence
		//Basically if we drop one of the CONNECTEDSIGNED packets then the initial keep alive packet
		//acts to re-trigger the connect sequence at this listener. The only penalty to doing this is
		//if we suddently get a flood of medium/high priority data immediately we've queued a keep alive 
		//we'll send the keep alive first. This is a pretty unlikely event, and hence not a big problem
	pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_HIGH_PRIORITY; 
	
	DPFX(DPFPREP,7,"(%p) Sending KEEPALIVE", pEPD);
	
	EnqueueMessage(pMSD, pEPD);									// Insert this message into the stream
}


/*
**		Endpoint Background Process
**
**		This routine is run for each active endpoint every minute or so.  This will initiate
**	a KeepAlive exchange if the link has been idle since the last run of the procedure.  We
**	will also look for expired timeouts and perhaps this will be an epoch delimiter for links
**	in a STABLE state of being.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EndPointBackgroundProcess"

VOID CALLBACK
EndPointBackgroundProcess(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique)
{
	PEPD	pEPD = (PEPD) pvUser;
	PSPD	pSPD = pEPD->pSPD;
	DWORD	tNow = GETTIMESTAMP();
	DWORD	dwIdleInterval;

	DPFX(DPFPREP,7, "(%p) BACKGROUND PROCESS for EPD; RefCnt=%d; WindowF=%d; WindowB=%d", 
										pEPD, pEPD->lRefCnt, pEPD->uiWindowF, pEPD->uiWindowBIndex);

	Lock(&pEPD->EPLock);

	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{
		DPFX(DPFPREP,7, "Killing Background Process, endpoint is not connected. Flags = 0x%x", pEPD->ulEPFlags);
		pEPD->BGTimer = 0;

		RELEASE_EPD(pEPD, "UNLOCK (release BG timer)");	// release reference for this timer, releases EPLock
		return;
	}

	dwIdleInterval = pEPD->pSPD->pPData->tIdleThreshhold;

	// Do we need to start a KeepAlive cycle?

	if(	((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_KEEPALIVE_RUNNING))==0) &&
		((tNow - pEPD->tLastPacket) > dwIdleInterval)) 
	{
		// We are not sending data and we havent heard from our partner in a long time.
		// We will send a keep alive packet which he must respond to.  We will insert a
		// NULL data packet into the reliable stream so ack/retry mechanisms will either
		// clear the keep-alive or else timeout the link.
		//
		// There's also the special case where we've started a graceful disconnect and
		// our request has been acknowledged, but somehow our partner's got lost.
		// There currently is no timer set for that, so if we detect the link in that
		// condition, our keepalive will almost certainly fail; the other side knows
		// we're shutting down, so has probably already dropped the link and wouldn't
		// respond.  So to prevent the person from having to wait for the entire idle
		// timeout _plus_ reliable message timeout, just drop the link now.
		if (pEPD->ulEPFlags & EPFLAGS_DISCONNECT_ACKED)
		{
			// If all three parts happened, why is the link still up!?
			ASSERT(! (pEPD->ulEPFlags & EPFLAGS_ACKED_DISCONNECT));


			DPFX(DPFPREP,1, "(%p) EPD has been waiting for partner disconnect for %u ms (idle threshold = %u ms), dropping link.",
					pEPD, (tNow - pEPD->tLastPacket), dwIdleInterval);
			
			// We don't need to reschedule a timer, so clear it.  This also prevents
			// drop link from trying to cancel the one we're in now.  That error is
			// ignored, but no point in doing it.
			pEPD->BGTimer = 0;

			DECREMENT_EPD(pEPD, "UNLOCK (release BGTimer)");

			// Since we're just hanging out waiting for partner to send his disconnect,
			// he's probably gone now.  Drop the link.
			DropLink(pEPD);									// releases EPLock

			return;
		}
			//else if we haven't sent a disconnect, and no hard disconnect sequence is in progress then send a keep alive
		else if ((pEPD->ulEPFlags & 
				(EPFLAGS_SENT_DISCONNECT | EPFLAGS_HARD_DISCONNECT_SOURCE |EPFLAGS_HARD_DISCONNECT_TARGET))==0)
		{
			DPFX(DPFPREP,5, "(%p) Sending KEEPALIVE...", pEPD);
			SendKeepAlive(pEPD);	
		}
		else
		{
			// The EndOfStream message will either get ACK'd or timeout, we allow no further sends, even KeepAlives
			DPFX(DPFPREP,5, "(%p) KeepAlive timeout fired, but we're in a disconnect sequence, ignoring", pEPD);
		}
	}

	// Reschedule next interval

	// Cap the background process interval at this value.
	if (dwIdleInterval > ENDPOINT_BACKGROUND_INTERVAL)
	{
		dwIdleInterval = ENDPOINT_BACKGROUND_INTERVAL;
	}

	DPFX(DPFPREP,7, "(%p) Setting Endpoint Background Timer for %u ms", pEPD, dwIdleInterval);
	RescheduleProtocolTimer(pSPD, pEPD->BGTimer, dwIdleInterval, 1000, EndPointBackgroundProcess, (PVOID) pEPD, &pEPD->BGTimerUnique);

	Unlock(&pEPD->EPLock);
}

/*
**	Hard Disconnect Resend
**
**		This routine is run when an endpoint is hard disconnecting. It is used to send a single hard disconnect frame
**	at a period of rtt/2. 
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "HardDisconnectResendTimeout"

VOID CALLBACK
HardDisconnectResendTimeout(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique)
{
	PEPD pEPD=(PEPD) pvUser;
	PProtocolData pPData=pEPD->pSPD->pPData;

	DPFX(DPFPREP,7, "(%p) Entry. pvTimerData[%p] uiTimerUnique[%u] EPD::RefCnt[%d], EPD::uiNumRetriesRemaining[%u]", 
						pEPD, pvTimerData, uiTimerUnique, pEPD->lRefCnt, pEPD->uiNumRetriesRemaining);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, FALSE);
	Lock(&pEPD->EPLock);

	DNASSERT(pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_SOURCE);
	DNASSERT((pEPD->ulEPFlags & EPFLAGS_SENT_DISCONNECT)==0);

		//if this is a stale timer then we've nothing more to do
	if (pEPD->LinkTimerUnique!=uiTimerUnique || pEPD->LinkTimer!=pvTimerData)
	{
		DPFX(DPFPREP,7, "Timer is Stale. EPD::LinkTimer[%p], EPD::LinkTimerUnique[%u]", pEPD->LinkTimer, pEPD->LinkTimerUnique);
		RELEASE_EPD(pEPD, "UNLOCK (Hard Disconnect Resend Timer)");
			// above call releases reference for this timer and releases EPLock
		return;
	}

		//whatever happens now, we've processed this timer
	pEPD->LinkTimerUnique=0;
	pEPD->LinkTimer=NULL;

		//if endpoint is being terminated then we shouldn't attempt to touch it
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{
		DPFX(DPFPREP,7, "Endpoint is terminating. Flags = 0x%x", pEPD->ulEPFlags);
		RELEASE_EPD(pEPD, "UNLOCK (Hard Disconnect Resend Timer)");
			// above call releases reference for this timer and releases EPLock
		return;
	}

		//looks like we've got a valid timer on a valid endpoint, update the number of retries we have left to send
	pEPD->uiNumRetriesRemaining--;
	DNASSERT(pEPD->uiNumRetriesRemaining<0x80000000);		//ensure we haven't gone negative on retries remaining
	ULONG ulFFlags;
		//if we hit zero retries remaining then we'll make this the last hard disconnect frame we send out
	if (pEPD->uiNumRetriesRemaining==0)
	{
		ulFFlags=FFLAGS_FINAL_HARD_DISCONNECT;
		DPFX(DPFPREP,7, "(%p) Sending final hard disconnect", pEPD);
	}
		//otherwise we'll need to reschedule the timer to send the next retry
	else
	{
		ulFFlags=0;
		DWORD dwRetryPeriod=pEPD->uiRTT/2;
		if (dwRetryPeriod>pPData->dwMaxHardDisconnectPeriod)
			dwRetryPeriod=pPData->dwMaxHardDisconnectPeriod;
		else if (dwRetryPeriod<MIN_HARD_DISCONNECT_PERIOD)
			dwRetryPeriod=MIN_HARD_DISCONNECT_PERIOD;
		pEPD->LinkTimer=pvTimerData;
		RescheduleProtocolTimer(pEPD->pSPD, pvTimerData, dwRetryPeriod, 10, HardDisconnectResendTimeout, 
																		pEPD,  &pEPD->LinkTimerUnique);
		DPFX(DPFPREP,7, "(%p) Rescheduled timer for next hard disconnect send", pEPD);
	}
	HRESULT hr=SendCommandFrame(pEPD, FRAME_EXOPCODE_HARD_DISCONNECT, 0, ulFFlags, TRUE);
		//since we selected send direct EP lock will have been released by above call
 		//if that was the last disconnect frame we won't have rescheduled the timer, and should therefore
 		//drop the ep reference that the timer holds
	if (ulFFlags==FFLAGS_FINAL_HARD_DISCONNECT)
	{
		Lock(&pEPD->EPLock);
			//if the send failed on the last hard disconnect frame we'll have to drop the link now
			//as we won't be getting a completition back from the sp for it
		if (FAILED(hr))
		{
			CompleteHardDisconnect(pEPD);
				//above call will have release EP lock
			Lock(&pEPD->EPLock);
			DPFX(DPFPREP,0, "Failed to send final hard disconnect frame. Dropping link. hr[%x]", hr);
		}
		RELEASE_EPD(pEPD, "UNLOCK (Hard Disconnect Resend Timer)");
	}

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\dnprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DnProt.h
 *  Content:	This file contains structure definitions for the Direct Net protocol
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#ifndef	_DNPROT_INCLUDED_
#define	_DNPROT_INCLUDED_


#define	VOL		volatile
/*
**		Internal Constants
*/

//frames come in 1 of 2 forms, either data frames or cframes. 

//cframes
//cframes come in 3 different sizes.
//connect, connected and hard disconnect are all just a single CFRAME header. If the link is signed then hard disconnect frames
//will also be followed by a signature value. On the wire these therefore look like:
//<CFRAME header><optional signature (8 bytes)>
//connected_signed frames extend the standard CFRAME with a fixed number of additional members. On the wire these frames look like:
//<CFRAME_CONNECTEDSIGNED header>
//sackframes have a fixed initial header and then between 0 and 4 ULONG values giving sack/send masks. If they're sent over
//a signed link they also have a signature value appended. On the wire these frames look like:
//<SACKFRAME header><optional sack/send masks (0 to 16 bytes)><optional signature (8 bytes)>

//These define the largest possible size of header for each cframe type
#define 		MAX_SEND_CFRAME_STANDARD_HEADER_SIZE					(sizeof(CFRAME)+sizeof(ULONGLONG))
#define		MAX_SEND_CFRAME_CONNECTEDSIGNED_HEADER_SIZE			(sizeof(CFRAME_CONNECTEDSIGNED))
#define		MAX_SEND_CFRAME_SACKFRAME_HEADER_SIZE				(sizeof(SACKFRAME8)+sizeof(ULONG)*4+sizeof(ULONGLONG))

//These respectively define the size of the smallest and largest possible cframe header
#define		MIN_SEND_CFRAME_HEADER_SIZE					(_MIN(sizeof(SACKFRAME8), _MIN(sizeof(CFRAME), sizeof(CFRAME_CONNECTEDSIGNED))))
#define		MAX_SEND_CFRAME_HEADER_SIZE					(_MAX(MAX_SEND_CFRAME_CONNECTEDSIGNED_HEADER_SIZE, _MAX(MAX_SEND_CFRAME_STANDARD_HEADER_SIZE, MAX_SEND_CFRAME_SACKFRAME_HEADER_SIZE)))

//dframes
//All dframes have a single fixed initial header (DFRAME). Depending on the data encapsulated there may be a number of additional
//variable length data blocks following this.
//Firstly, there may be 0 to 4 ULONG values giving sack/send masks. The presence or absence of these is determined by
//the PACKET_CONTROL_SACK_MASK1/2 and PACKET_CONTROL_SEND_MASK1/2 bit flags within the bControl member of the DFRAME header
//For a non-coalesced data message, there may then follow a signature (for signed links), followed by all the use data.
//Hence, the packet on the wire looks like:
//<DFRAME header><optional sack/send masks (0 to 16 bytes)><optional signature (8 bytes)><user data>
//A coalesced data message is identified by the PACKET_CONTROL_COALESCE bit flag being set in the bControl member of the DFRAME header
//For a coalesced data message, following the optional masks is an optional signature field (for a signed link). After this 
//is a set of coalesce headers. There are between 2 and MAX_USER_BUFFERS_IN_FRAME of these. Finally, at the end of the frame
//is the coalesced user data. If necessary padding is inserted before and between the user data to ensure each block of user data 
//is DWORD aligned. 
//Hence, on the wire a coalesced data packet looks like:
//<DFRAME header><optional sack/send masks (0 to 16 bytes)><optional signature (8 bytes)><coalesce header (2 bytes)>
//				<coalesce header (2 bytes)>.......<padding (0 or 2 bytes)><user data><padding (0 to 3 bytes)><user data>........
//Finally, a dframe may be a keep alive, and not contain any user data at all. These frames are identified by the PACKET_CONTROL_KEEPALIVE
//flag being flipped on in the frames bControl field. A keep alive contains the optional sack/send masks, a signature if the link is signed
//and the session identity.
//On the wire a keep alive packet looks like:
//<DFRAME header><optional sack/send masks (0 to 16 bytes)><optional signature (8 bytes)><session identity (4 bytes)>

//This defines the maximum number of user buffers we can send in a coalesced dframe
#define		MAX_USER_BUFFERS_IN_FRAME						32			// this number * sizeof(COALESCEHEADER) should stay DWORD aligned 
//This defines the maximum size of a user buffer than can be placed in a coalesced message
//Anything larger than this can't be coalesced. For most SPs (i.e. IP) since we use an MTU smaller than this, we never
//get close to reaching this value anyway
#define		MAX_COALESCE_SIZE								2047		// 1 byte + 3 bits = 11 bits worth of data

//These define the largest possible size of header for each dframe  type
#define		MAX_SEND_DFRAME_NOCOALESCE_HEADER_SIZE		(sizeof(DFRAME)+sizeof(ULONG)*4+sizeof(ULONGLONG))
#define		MAX_SEND_DFRAME_COALESCE_HEADER_SIZE			(sizeof(DFRAME)+sizeof(ULONG)*4+(MAX_USER_BUFFERS_IN_FRAME * sizeof(COALESCEHEADER))+(MAX_USER_BUFFERS_IN_FRAME * 3)+sizeof(ULONGLONG))
#define		MAX_SEND_DFRAME_KEEPALIVE_HEADER_SIZE			(sizeof(DFRAME)+sizeof(ULONG)*4+sizeof(ULONG)+sizeof(ULONGLONG))

//These respectively define the size of the smallest and the largest possible dframe header.
#define 		MIN_SEND_DFRAME_HEADER_SIZE					(sizeof(DFRAME))
#define		MAX_SEND_DFRAME_HEADER_SIZE					(_MAX(MAX_SEND_DFRAME_NOCOALESCE_HEADER_SIZE, _MAX(MAX_SEND_DFRAME_COALESCE_HEADER_SIZE, MAX_SEND_DFRAME_KEEPALIVE_HEADER_SIZE)))



//This defines the largest protocol header we can create.
//Its the largest value out of the biggest possible cframe header and the biggest possible dframe header
#define		MAX_SEND_HEADER_SIZE							(_MAX(MAX_SEND_DFRAME_HEADER_SIZE, MAX_SEND_CFRAME_HEADER_SIZE))

//We must be able to send our largest cframe as a single packet and a keep alive as a single packet
//N.B. since a keep alive is a standard DFRAME with a 4 byte payload this also guarantees we can send a none coalesced dframe
#define		MIN_SEND_MTU									(_MAX(MAX_SEND_CFRAME_HEADER_SIZE, MAX_SEND_DFRAME_KEEPALIVE_HEADER_SIZE))

#define		SMALL_BUFFER_SIZE								(1024 * 2)
#define		MEDIUM_BUFFER_SIZE								(1024 * 4)
#define		LARGE_BUFFER_SIZE								(1024 * 16)


/*
**		Signatures for data structures
*/

#define		PPD_SIGN		' DPP'					// Protocol Data
#define		SPD_SIGN		' DPS'					// Service Provider Descriptor
#define		EPD_SIGN		' DPE'					// End Point Descriptor
#define		MSD_SIGN		' DSM'					// Message Descriptor
#define		FMD_SIGN		' DMF'					// Frame Descriptor
#define		RCD_SIGN		' DCR'					// Receive Descriptor

/*
**		Internal Data Structures
**
*/

typedef	struct	protocoldata	ProtocolData, *PProtocolData;
typedef struct	spdesc			SPD, *PSPD;
typedef	struct	endpointdesc 	EPD, *PEPD;
typedef struct	checkptdata		CHKPT, *PCHKPT;
typedef struct	messagedesc 	MSD, *PMSD;
typedef struct	framedesc		FMD, *PFMD;
typedef struct	recvdesc		RCD, *PRCD;

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

/*	
**	Protocol Data
**
**		This structure contains all of the global state information for the
**	operating protocol.  It is grouped into a structure for (in)convenience
**	against the unlikely possibility that we ever need to run multiple instances
**	out of the same code.
*/


#define		PFLAGS_PROTOCOL_INITIALIZED			0x00000001
#define		PFLAGS_FAIL_SCHEDULE_TIMER			0x00000002	//DEBUG flag. Allows scheduling of timers to be failed

struct protocoldata 
{
	ULONG							ulProtocolFlags;	// State info about DN protocol
	PVOID							Parent;				// Direct Play Object
	UINT							Sign;
	LONG							lSPActiveCount;		// Number of SPs currently bound to protocol

	DWORD							tIdleThreshhold;	// How long will we allow a link to be idle before Checkpointing
	
	DWORD							dwConnectTimeout;	// These two parameter control new connection commands
	DWORD							dwConnectRetries;

	DWORD							dwMaxRecvMsgSize;			//largest message we accept on a receive
	DWORD							dwSendRetriesToDropLink;		//number of send retry attempts before
																//we decide link has died
	DWORD							dwSendRetryIntervalLimit;		//limit for the period between send retries
	
	DWORD							dwDropThresholdRate;			// Percentage of frames allowed to drop before throttling
	DWORD							dwDropThreshold;				// Actual number of frames allowed to drop before throttling
	DWORD							dwThrottleRate;				// Percentage backoff when throttling
	FLOAT							fThrottleRate;					// Actual backoff when throttling (0.0 - 1.0)
	DWORD							dwNumHardDisconnectSends;	// Number of hard disconnect frames sent when hard closing
	DWORD							dwMaxHardDisconnectPeriod;	// Maximum period between hard disconnect sends
	DWORD							dwInitialFrameWindowSize;		// Size of the initial frame window for a connection

	PDN_PROTOCOL_INTERFACE_VTBL		pfVtbl;				// Table of indication entry points in CORE

	IDirectPlay8ThreadPoolWork		*pDPThreadPoolWork;	// Pointer to thread pool interface

#ifdef DBG
	// For Debugging we will track the total number of receives outstanding in the higher layers
	// at all times.
	long ThreadsInReceive;
	long BuffersInReceive;
#endif // DBG
};

/*
**	Service Provider Descriptor
**
**		This structure describes a Service Provider that we are bound to.  It
**	contains at a minimum the vector table to call the SP,  and the SPID that
**	is combined with player IDs to make external DPIDs.  The SPID should also
**	be the index in the SPTable where this descriptor lives.
**
**		We will have one send thread per service provider,  so the thread handle
**	and its wait-event will live in this structure too.
**
**		Lower Edge Protocol Object
**
**		We will also use the SPD as the COM Object given to SP for our lower edge
**	interface.  This means that our Lower Vector Table must be the first field in
**	this structure,  and ref count must be second.
*/

// The following are functions that the Service Providers can call in the Protocol
extern HRESULT WINAPI DNSP_IndicateEvent(IDP8SPCallback*, SP_EVENT_TYPE, PVOID);
extern HRESULT WINAPI DNSP_CommandComplete(IDP8SPCallback*, HANDLE, HRESULT, PVOID);


#define	SPFLAGS_SEND_THREAD_SCHEDULED	0x0001	// SP has scheduled a thread to service command frames
#define	SPFLAGS_TERMINATING				0x4000	// SP is being removed

struct spdesc 
{
	IDP8SPCallbackVtbl	*LowerEdgeVtable;	// table used by this SP to call into us, MUST BE FIRST!!!
	UINT				Sign;
	ULONG				ulSPFlags;			// Flags describing this service provider
	IDP8ServiceProvider	*IISPIntf;			// ptr to SP Object
	PProtocolData		pPData;				// Ptr to owning protocol object
	UINT				uiFrameLength;		// Frame size available to us
	UINT				uiUserFrameLength;	// Frame size available to application
	UINT				uiLinkSpeed;		// Local link speed in BPS

	CBilink				blSendQueue;		// List of wire-ready packets to transmit over this SP
	CBilink				blPendingQueue;		// List of packets owned by SP - Shares Lock w/SendQ
	CBilink				blEPDActiveList;	// List of in use End Point Descriptors for this SP

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	SPLock;			// Guard access to sendQ
#endif // !DPNBUILD_ONLYONETHREAD

#ifdef DBG
	CBilink				blMessageList;		// List of in use Message Descriptors
#endif // DBG
};

/*
**	End Point Descriptor
**
**		An 'EPD' describes a Direct Network instance that we can communicate with.
**	This structure includes all session related information, statistics,  queues,  etc.
**	It will manage any of the three types of service simultaneously.
*/

#define	EPFLAGS_END_POINT_IN_USE		0x0001	// This EndPoint is allocated

// We are always in exactly one of these 4 states
#define	EPFLAGS_STATE_DORMANT			0x0002	// Connection protocol has not yet run
#define	EPFLAGS_STATE_CONNECTING		0x0004	// Attempting to establish reliable link
#define	EPFLAGS_STATE_CONNECTED			0x0008	// Reliable link established
#define	EPFLAGS_STATE_TERMINATING		0x0010	// This end point is being closed down

#define	EPFLAGS_SP_DISCONNECTED			0x0020  // Set when the SP has called ProcessSPDisconnect

#define	EPFLAGS_IN_RECEIVE_COMPLETE		0x0040	// A thread is running in ReceiveComplete routine
#define	EPFLAGS_LINKED_TO_LISTEN		0x0080	// During CONNECT this EPD is linked into the Listen MSD's queue

#define	EPFLAGS_LINK_STABLE				0x0100	// We think we have found the best current transmit parameters
#define	EPFLAGS_STREAM_UNBLOCKED		0x0200	// Reliable traffic is stopped (window or throttle)
#define	EPFLAGS_SDATA_READY				0x0400	// Reliable traffic in the pipe
#define	EPFLAGS_IN_PIPELINE				0x0800	// Indicates that EPD is in the SPD pipeline queue

#define	EPFLAGS_CHECKPOINT_INIT			0x1000	// Need to send a check point packet
#define	EPFLAGS_DELAYED_SENDMASK		0x2000	// unacked check point on wire
#define	EPFLAGS_DELAYED_NACK			0x4000	// Need to send masks for missing receives
#define	EPFLAGS_DELAY_ACKNOWLEDGE		0x8000	// We are waiting for back-traffic before sending ACK frame

#define	EPFLAGS_KEEPALIVE_RUNNING	0x00010000	// Checkpoint is running (borrowed in debug to turn off keepalives)
#define	EPFLAGS_SENT_DISCONNECT		0x00020000	// We have sent a DISCONNECT and are waiting for confirm
#define	EPFLAGS_RECEIVED_DISCONNECT	0x00040000	// We have received a DISCONNECT and will send confirm when done sending
#define	EPFLAGS_DISCONNECT_ACKED	0x00080000	// We sent a DISCONNECT and it has been confirmed

#define	EPFLAGS_COMPLETE_SENDS		0x00100000	// There are Reliable MSDs waiting to be called back
#define	EPFLAGS_FILLED_WINDOW_BYTE	0x00200000	// Filled Byte-Based send window
#define	EPFLAGS_FILLED_WINDOW_FRAME	0x00400000	// We have filled the frame-based SendWindow at least once during last period
#ifndef DPNBUILD_NOPROTOCOLTESTITF
#define EPFLAGS_NO_DELAYED_ACKS		0x00800000	// DEBUG_FLAG -- Turn off DelayedAckTimeout
#endif // !DPNBUILD_NOPROTOCOLTESTITF

#define	EPFLAGS_ACKED_DISCONNECT	0x01000000	// Partner sent a DISCONNECT and we have confirmed it
#define	EPFLAGS_RETRIES_QUEUED		0x02000000	// Frames are waiting for retransmission
#define	EPFLAGS_THROTTLED_BACK		0x04000000	// temporary throttle is engaged to relieve congestion

#ifndef DPNBUILD_NOPROTOCOLTESTITF
#define	EPFLAGS_LINK_FROZEN				0x08000000	// DEBUG FLAG -- Do not run dynamic algorithm on this link
#endif // !DPNBUILD_NOPROTOCOLTESTITF

#define	EPFLAGS_INDICATED_DISCONNECT		0x10000000	// Ensure that we onlly call CORE once to indicate disconnection
#define	EPFLAGS_TESTING_GROWTH			0x20000000	// We are currently taking a growth sample
#define	EPFLAGS_HARD_DISCONNECT_SOURCE	0x40000000	// We're the source for a hard disconnect sequence
														// i.e. Core has instigated a hard close on this ep
#define	EPFLAGS_HARD_DISCONNECT_TARGET	0x80000000	// We're the target for a hard disconnect sequence
														// i.e. We're received a hard disconnect request from remote ep

#define	MAX_RECEIVE_RANGE			64		// largest # of frames we will retain past a missing frame
#define	MAX_FRAME_OFFSET			(MAX_RECEIVE_RANGE - 1)

	//sequence window as split into 4 quarters
#define	SEQ_WINDOW_1Q				64
#define	SEQ_WINDOW_2Q				128
#define	SEQ_WINDOW_3Q				192
#define	SEQ_WINDOW_4Q				256

#define	INITIAL_STATIC_PERIOD		(10 * 1000)		// How long does link remain static after finding set-point.
													// This value will double every time link finds the same set-point.

#ifndef DPNBUILD_NOMULTICAST
#define	EPFLAGS2_MULTICAST_SEND			0x00000001		// multicast send placeholder endpoint
#define	EPFLAGS2_MULTICAST_RECEIVE			0x00000002		// multicast receive placeholder endpoint
#endif	// DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_NOPROTOCOLTESTITF
#define EPFLAGS2_DEBUG_NO_RETRIES			0x00000004
#endif // !DPNBUILD_NOPROTOCOLTESTITF
#define EPFLAGS2_NOCOALESCENCE				0x00000008    	// We are talking to an older partner and must not use coalescence
#define EPFLAGS2_KILLED						0x00000010		// Someone has removed the 'base' reference to make this go away
															// We dont want to let this happen twice...
#define EPFLAGS2_HARD_DISCONNECT_COMPLETE	0x00000020
#define EPFLAGS2_SUPPORTS_SIGNING			0x00000040		// Remote partner supports signing on packets
															// This doesn't mean packets actually are signed, it just means
															// that their protocol version would support it
#define EPFLAGS2_FAST_SIGNED_LINK			0x00000080		// Packets over link should be fast signed
#define EPFLAGS2_FULL_SIGNED_LINK			0x00000100		// Packets over link should be fully signed
#define EPFLAGS2_SIGNED_LINK					0x00000180		// Combination of both above flags


struct endpointdesc 
{
	HANDLE				hEndPt;				// Together with SP index uniquely defines an End Point we can reach
	LONG 				lRefCnt;			// Reference count
	UINT				Sign;				// Signature to validate data structure
	PSPD				pSPD;				// specifies the SP on which this remote instance lives
	ULONG VOL			ulEPFlags;			// End Point Flags
	ULONG VOL			ulEPFlags2;			// Extra endpoint flags
	PVOID				Context;			// Context value returned with all indications
	PMSD				pCommand;			// Connect or Listen command with which this end point was created or Disconnect cmd
	CBilink				blActiveLinkage;	// linkage for SPD list of active EndPoints
	CBilink				blSPLinkage;		// linkage to listen command during connect
	CBilink				blChkPtQueue;		// linkage for active CheckPoints

	UINT				uiUserFrameLength;	// Largest frame we can transmit

	UINT				uiRTT;				// Current RTT --  Integer portion
	UINT				fpRTT;				// Fixed Point 16.16 RTT
	
	UINT				uiDropCount;		// localized packet drop count (recent drops)
	DWORD				dwDropBitMask;		// bit mask of dropped frames (32 frame max)
	DWORD				tThrottleTime;		// Timestamp when last Checking occured
	UINT				uiThrottleEvents;	// count of temporary backoffs for all reasons
	
	UINT				uiAdaptAlgCount;	// Acknowledge count remaining before running adaptive algorithm
	DWORD				tLastPacket;		// Timestamp when last packet arrived
	
	UINT				uiWindowFilled;		// Count of times we fill the send window
	
	UINT				uiPeriodAcksBytes;	// frames acked since change in tuning
	UINT				uiPeriodXmitTime;	// time link has been transmitting since change in tuning
	UINT				uiPeriodRateB;
	UINT				uiPeakRateB;		// Largest sample we ever measure

	PVOID				pvHardDisconnectContext;	//The context value passed down to us when a hard disconnect has been requested
												//For a normal disconnect this is stored as part of the disconnect MSD, but since
												//we don't have one of those for a hard disconnect it has to be added here

	//Signing. We store 2 secret values for signing, the local one for us to use when signing our packets, and the remote one
	//we use to check incoming packets. The type of signing is controlled by the EPFLAGS2_FAST/FULL_SIGNED_LINK flags
	//For full signing, where we update the secret's each time the sequence space wraps, we also store the values of the old
	//secret. This is needed when we send retries (old local secret) or we received delayed incoming packets (old remote secret)

	//We also track modifier values for the secrets. These are derived from the signatures of reliable messages we've sent (for local
	//modifier) or received (for remote modifier). Each time the sequence space is wrapped we update the secrets using the modifiers
	//to prevent replay attacks

	ULONGLONG			ullCurrentLocalSecret;
	ULONGLONG			ullOldLocalSecret;
	ULONGLONG			ullCurrentRemoteSecret;
	ULONGLONG			ullOldRemoteSecret;

	ULONGLONG			ullLocalSecretModifier;
	ULONGLONG			ullRemoteSecretModifier;
	BYTE				byLocalSecretModifierSeqNum;
	BYTE				byRemoteSecretModifierSeqNum;
	
	// While we are in DYNAMIC state we want to remember stats from our previous xmit parameters,  at this
	// point that means RTT and AvgSendRate.  This lets us compare the measurements at our new rate so we can
	// ensure that thruput increases with sendrate,  and that RTT is not growing out of proportion.
	//
	//   If either thru-put stops improving or RTT grows unreasonably then we can plateau our xmit parameters
	// and transition to STABLE state.

	UINT				uiLastRateB;
	UINT				uiLastBytesAcked;
	DWORD				tLastThruPutSample;

	// Connection State		-	 State of reliable connection
	//
	//	Send Queuing is getting somewhat complex.  Let me spell it out in Anglish.
	//
	//	blXPriSendQ		is the list of MSDs awaiting shipment (and being shipped)
	//	CurrentSend		pts to the MSD we are currently pulling frames out of.
	//  CurrentFrame 	pts to the next FMD that we will put on the wire.
	//	blSendWindow	is a bilinked list of transmitted but unacknowledged frames.  This list may span multi MSDs
	//
	//	WindowF			is our current MAX window size expressed in frames
	//	WindowB			is our current MAX window size expressed in bytes
	//
	//	UnAckedFrames	is the count of unacknowledged frames on the wire (actual window size)
	//	UnAckedBytes	is the count of unacknowledged bytes on the wire

	DWORD				uiQueuedMessageCount;	// How many MSDs are waiting on all three send queues

	CBilink				blHighPriSendQ;		// These are now mixed Reliable and Datagram traffic
	CBilink				blNormPriSendQ;
	CBilink				blLowPriSendQ;
	CBilink				blCompleteSendList;	// Reliable messages completed and awaiting indication to user

	DWORD				dwSessID;			// Session ID so we can detect re-started links
	PMSD				pCurrentSend;		// Head of queue is lead edge of window.  window can span multiple frames.
	PFMD				pCurrentFrame;		// frame currently transmitting. this will be trailing edge of window
	CBilink				blSendWindow;
	CBilink				blRetryQueue;		// Packets waiting for re-transmission

	//		Lost Packet Lists
	//
	//		When we need to retry a packet and we discover that it is not reliable,  then we need to inform partner
	//	that he can stop waiting for the data.  We will piggyback this info on another frame if possible

	//		Current Transmit Parameters:
	
	UINT				uiWindowF;			// window size (frames)
	UINT				uiWindowB;			// window size (bytes)
	UINT				uiWindowBIndex;		// index (scaler) for byte-based window
	UINT				uiUnackedFrames;	// outstanding frame count
	UINT				uiUnackedBytes;		// outstanding byte count

	UINT				uiBurstGap;			// number of ms to wait between bursts
	INT					iBurstCredit;		// Either credit or deficit from previous Transmit Burst

	// 		Last Known Good Transmit Parameters --  Values which we believe are safe...

	UINT				uiGoodWindowF;
	UINT				uiGoodWindowBI;
	UINT				uiGoodBurstGap;
	UINT				uiGoodRTT;
	
	UINT				uiRestoreWindowF;
	UINT				uiRestoreWindowBI;
	UINT				uiRestoreBurstGap;
	DWORD				tLastDelta;			// Timestamp when we last modified xmit parms

	// 		Reliable Link State

	BYTE VOL			bNextSend;			// Next serial number to assign
	BYTE VOL			bNextReceive;		// Next frame serial we expect to receive

	// Group BYTE members for good packing
	BYTE VOL			bNextMsgID;			// Next ID for datagram frames ! NOW USED FOR CFRAMES ONLY
	BYTE				bLastDataRetry;		// Retry count on frame N(R) - 1

	BYTE				bHighestAck;		// The highest sequence number that has been ACK'd.  This may not be the first frame in the SendWindow due to masks.

	//	The following fields are all for tracking reliable receives

	//  The next two fields allow us to return more state with every ACK packet.  Since each ack explicitly
	// names one frame,  the highest in-sequenced packet received so far,  we want to remember the arrival time
	// and the Retry count of this packet so we can report it in each ACK.  It will be the transmitter's
	// responsibility to ensure that a single data-point never gets processed more then once,  skewing our calcs.
	
	DWORD				tLastDataFrame;		// Timestamp from the arrival of N(R) - 1

	ULONG				ulReceiveMask;		// mask representing first 32 frames in our rcv window
	ULONG				ulReceiveMask2;		// second 32 frames in our window
	DWORD				tReceiveMaskDelta;	// timestamp when a new bit was last set in ReceiveMask (full 64-bit mask)

	ULONG				ulSendMask;			// mask representing unreliable send frames that have timed out and need
	ULONG				ulSendMask2;		// to be reported to receiver as missing.

	PRCD				pNewMessage;		// singly linked list of message elements
	PRCD				pNewTail;			// tail pointer for singly linked list of msg elements
	CBilink				blOddFrameList;		// Out Of Order frames
	CBilink				blCompleteList;		// List of MESSAGES ready to be indicated
	UINT				uiCompleteMsgCount;	// Count of messages on the CompleteList

	PVOID				SendTimer;			// Timer for next send-burst opportunity
	UINT				SendTimerUnique;

	UINT				uiNumRetriesRemaining;	// This  is used during CONNECT and HARD_DISCONNECT processing
												//to track how many more times we should retry either the connect or 
												//hard disconnect
	UINT				uiRetryTimeout;		// Current T1 timer value
	
	PVOID				LinkTimer;		// Used to generate timer events when link is connecting and hard disconnecting
	UINT				LinkTimerUnique;
	
	PVOID				RetryTimer;			// window to receive Ack
	UINT				RetryTimerUnique;	
	
	PVOID				DelayedAckTimer;	// wait for piggyback opportunity before sending Ack
	UINT				DelayedAckTimerUnique;

	PVOID				DelayedMaskTimer;	// wait for piggyback opportunity before sending
	UINT				DelayedMaskTimerUnique;
	
	PVOID				BGTimer;			// Periodic background timer
	UINT				BGTimerUnique;		// serial for background timer

	UINT				uiBytesAcked;
	
	//	Link statistics
	//
	//	All of the following stuff is calculated and stored here for the purpose of reporting in the ConnectionInfo structure
	
	UINT 				uiMsgSentHigh;
	UINT 				uiMsgSentNorm;
	UINT 				uiMsgSentLow;
	UINT 				uiMsgTOHigh;
	UINT 				uiMsgTONorm;
	UINT 				uiMsgTOLow;
	
	UINT 				uiMessagesReceived;

	UINT				uiGuaranteedFramesSent;
	UINT				uiGuaranteedBytesSent;
	UINT				uiDatagramFramesSent;
	UINT				uiDatagramBytesSent;

	UINT				uiGuaranteedFramesReceived;
	UINT				uiGuaranteedBytesReceived;
	UINT				uiDatagramFramesReceived;
	UINT				uiDatagramBytesReceived;

	UINT				uiDatagramFramesDropped;	// datagram frame we failed to  deliver
	UINT				uiDatagramBytesDropped;		// datagram bytes we didnt deliver
	UINT				uiGuaranteedFramesDropped;
	UINT				uiGuaranteedBytesDropped;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	EPLock;				// Serialize all access to Endpoint
#endif // !DPNBUILD_ONLYONETHREAD

#ifdef DBG
	UINT				uiTotalThrottleEvents;
	BYTE				bLastDataSeq;		// for DEBUG porpoises
	CHAR				LastPacket[MAX_SEND_HEADER_SIZE + 4]; 	// record first portion of last packet received on EPD
#endif // DBG
};

/*
**		Check Point Data
**
**		Keeps track of local-end info about a checkpoint in-progress.
*/

struct checkptdata 
{
	CBilink			blLinkage;				// Linkage for list of CPs on an EndPoint
	DWORD			tTimestamp;				// Local time at start of checkpoint
	UCHAR			bMsgID;					// Msg ID expected in CP response
};

/*
**	Descriptor IDs
**
**		Any Descriptor that may be submitted to an SP as a context must have
**	a field which allows us to determine which structure is returned in a
**	completion call.  This field must obviously be in a uniform place in all
**	structures,  and could be expanded to be a command specifier as well.
**	Done!  Lets call it a command ID.
*/

typedef enum CommandID 
{
	COMMAND_ID_NONE,
	COMMAND_ID_SEND_RELIABLE,
	COMMAND_ID_SEND_DATAGRAM,
	COMMAND_ID_SEND_COALESCE,
	COMMAND_ID_CONNECT,
	COMMAND_ID_LISTEN,
	COMMAND_ID_ENUM,
	COMMAND_ID_ENUMRESP,
	COMMAND_ID_DISCONNECT,
	COMMAND_ID_DISC_RESPONSE,
	COMMAND_ID_CFRAME,
	COMMAND_ID_KEEPALIVE,
	COMMAND_ID_COPIED_RETRY,
	COMMAND_ID_COPIED_RETRY_COALESCE,
#ifndef DPNBUILD_NOMULTICAST
	COMMAND_ID_LISTEN_MULTICAST,
	COMMAND_ID_CONNECT_MULTICAST_SEND,
	COMMAND_ID_CONNECT_MULTICAST_RECEIVE,
#endif	// DPNBUILD_NOMULTICAST
} COMMANDID;


/*	Message Descriptor
**
**		An 'MSD' describes a message being sent or received by the protocol.  It keeps track
**	of the message elements, tracking which have been sent/received/acknowledged.
*/

//	Flags ONE field is protected by the MSD->CommandLock

#define		MFLAGS_ONE_IN_USE					0x0001
#define		MFLAGS_ONE_IN_SERVICE_PROVIDER	0x0002	// This MSD is inside an SP call
#define		MFLAGS_ONE_CANCELLED				0x0004	// command was cancelled while owned by SP
#define		MFLAGS_ONE_TIMEDOUT				0x0008	// sends only: timed out while event was scheduled
#define		MFLAGS_ONE_COMPLETE				0x0010	// connect only: operation is complete and indicated to Core
#define		MFLAGS_ONE_FAST_SIGNED				0x0020	// listen only. Links should be established with fast signing
#define		MFLAGS_ONE_FULL_SIGNED				0x0040	// listen only. Links should be established with full signing													
#define		MFLAGS_ONE_SIGNED					(MFLAGS_ONE_FULL_SIGNED |MFLAGS_ONE_FAST_SIGNED) 	
														// combination of above two flags. Allows to check for signing easily
#ifdef DBG
#define		MFLAGS_ONE_COMPLETED_TO_CORE	0x4000
#define		MFLAGS_ONE_ON_GLOBAL_LIST		0x8000
#endif // DBG

// Flags TWO field is protected by the EPD->EPLock

#define		MFLAGS_TWO_TRANSMITTING			0x0001
#define		MFLAGS_TWO_SEND_COMPLETE		0x0002	// send command completed
#define		MFLAGS_TWO_ABORT				0x0004	// Send/Disconnect has been aborted. Do no further processing
#define		MFLAGS_TWO_END_OF_STREAM		0x0008	// This MSD is an EOS frame. Could be a user cmd or a response
#define		MFLAGS_TWO_KEEPALIVE			0x0010	// This MSD is an empty frame to exercise the reliable engine
#define		MFLAGS_TWO_ABORT_WILL_COMPLETE	0x0020	// AbortSendsOnConnection intends to complete this to the core, other functions can clear it

#ifdef DBG
#define		MFLAGS_TWO_ENQUEUED				0x1000	// This MSD is on one of the EPD SendQs
#endif // DBG

#pragma TODO(simonpow, "Should union some members of the structure below to share memory between those used in sends, connects and listen")

struct messagedesc 
{
	COMMANDID			CommandID;				// THIS MUST BE FIRST FIELD
	LONG				lRefCnt;				// Reference count
	UINT				Sign;					// Signature
	ULONG VOL			ulMsgFlags1;			// State info serialized by MSD->CommandLock
	ULONG VOL			ulMsgFlags2;			// State info serialized by EPD->EPLock
	PEPD				pEPD;					// Destination End Point
	PSPD				pSPD;					// SP fielding this command
	PVOID				Context;				// User provided context value
	ULONG VOL			ulSendFlags;			// Flags submitted by User in send call
	INT					iMsgLength;				// Total length of user data
	UINT VOL			uiFrameCount;			// Number of frames needed to xmit data, protected by EPLock for reliables
	CBilink				blFrameList;			// List of frames to transport this message, or for a Listen, endpoints that are connecting
	CBilink				blQLinkage;				// linkage for various sendQs
	CBilink				blSPLinkage;			// linkage for SP command list, protected by SP->SPLock

	HANDLE				hCommand;				// handle when submitted to SP (used for connect & listen)
	DWORD				dwCommandDesc;			// Descriptor associated with hCommand
	HANDLE				hListenEndpoint;
	
	PVOID				TimeoutTimer;
	UINT				TimeoutTimerUnique;

		//used for listen commands when signing is enabled
		//we periodically change the connect secret and hence have to keep the last one in case
		//an incoming connection straddles this change
	ULONGLONG			ullCurrentConnectSecret;
	ULONGLONG			ullLastConnectSecret;
	DWORD				dwTimeConnectSecretChanged;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION		CommandLock;
#endif // !DPNBUILD_ONLYONETHREAD

#ifdef DBG
	CCallStack			CallStackCoreCompletion;
#endif // DBG
};

/*
**		Frame Descriptor
**
**		There are two non-obvious things about the FMD structure.  First is that the built-in Buffer Descriptor array
**	has two elements defined in front of it.  The first element,  Reserved1 and Reserved2 are present to allow the Service
**	Provider to pre-pend a header buffer,  and the second element,  ImmediateLength and ImmediatePointer are for this
**	protocol to prepend its header.  The ImmediatePointer is initialized to point to the ImmediateData field.
**
**		The second thing is that the ulFFlags field is serialized with the ENDPOINTLOCK of the EPD which this frame is linked to.
**	This is good because every time the FFlags fields is modified we have already taken the EPLock already.  The exception to this
**	rule is when we are initializing the FMD.  In this case the FMD has not been loosed on the world yet so there cannot be any
**	contention for it.  We have seperated out the one flag,  FRAME_SUBMITTED, into its own BOOL variable because this one is
**	protected by the SP's SPLock,  and like the EPLock above,  it is already claimed when this flag gets modified.
*/

//#define		FFLAGS_IN_USE				0x0001
#define		FFLAGS_TRANSMITTED			0x0002
#define		FFLAGS_END_OF_MESSAGE		0x0004
#define		FFLAGS_END_OF_STREAM		0x0008

//#define		FFLAGS_FRAME_SUBMITTED		0x0010	// SP Currently owns this frame
#define		FFLAGS_RETRY_TIMER_SET		0x0020	// Just what it sounds like
//#define		FFLAGS_NACK_RETRANSMIT_SENT	0x0040	// We sent a NACK initiated retry.
#define		FFLAGS_IN_SEND_WINDOW		0x0080	// This reliable frame has been transmitted and is waiting for Ack

#define		FFLAGS_CHECKPOINT			0x0100	// We are asking for a response
//#define		FFLAGS_KEEPALIVE			0x0200
//#define		FFLAGS_ACKED_BY_MASK		0x0400	// This has been acked out-of-order so its still in the SendWindow
#define		FFLAGS_RETRY_QUEUED			0x0800	// Frame currently sitting on the retry queue


//#define		FFLAGS_NEW_MESSAGE			0x00010000
#define		FFLAGS_RELIABLE					0x00020000
//#define		FFLAGS_SEQUENTIAL			0x00040000
#define		FFLAGS_FINAL_ACK				0x00080000
#define		FFLAGS_DONT_COALESCE			0x00100000
#define 		FFLAGS_FINAL_HARD_DISCONNECT	0x00200000

struct framedesc 
{
	COMMANDID		CommandID;					// THIS MUST BE FIRST FIELD to match MSD
	LONG			lRefCnt;					// Reference count
	UINT			Sign;
	UINT			uiFrameLength;
	ULONG VOL		ulFFlags;					// Protected by EPLock
	BOOL VOL		bSubmitted;					// Pull out this one flag for protection by EPLock (data frames only)
	PMSD			pMSD;						// owning message
	PEPD			pEPD;						// owning link;  ONLY VALID ON COMMAND FRAMES!
	BYTE			bPacketFlags;
	CBilink			blMSDLinkage;
	CBilink			blQLinkage;
	CBilink			blWindowLinkage;	
	CBilink			blCoalesceLinkage;
	PFMD			pCSD;						// pointer to containing coalesce header frame descriptor (non-retry coalesced frames only)
	
	UINT			uiRetry;					// number of times this frame has been transmitted
	DWORD			dwFirstSendTime;			// time when we first send the frame
	DWORD			dwLastSendTime;			// time when we last sent the frame (starts == to dwFirstSendTime and
											// updates on each resend)
	DWORD			tAcked;
	
	SPSENDDATA		SendDataBlock;				// Block to submit frame to SP
	CHAR			ImmediateData[MAX_SEND_HEADER_SIZE];

	// DO NOT MODIFY LAST FIVE FIELDS IN FRAME STRUCTURE

	UINT			uiReserved1;		// two resv fields are buf..
	LPVOID			lpReserved2;		// ..desc for SP to add header
	UINT			uiImmediateLength;			// These two lines constitute buffer descriptor
	LPVOID			lpImmediatePointer;			// for immediate data (our protocol headers)
	BUFFERDESC	 	rgBufferList[MAX_USER_BUFFERS_IN_FRAME];	// KEEP THIS FIELD AT END SO WE CAN ADD BUFFERS DYNAMICALLY
};


/*
**		Receive Descriptor
**
**		This data structure tracks a  single buffer received from the network.
**	It may or may not constitute an entire message.
*/

typedef	enum 
{
	RBT_SERVICE_PROVIDER_BUFFER,
	RBT_SERVICE_PROVIDER_BUFFER_COALESCE,
	RBT_PROTOCOL_NORM_BUFFER,
	RBT_PROTOCOL_MED_BUFFER,
	RBT_PROTOCOL_BIG_BUFFER,
	RBT_DYNAMIC_BUFFER
}	BUFFER_TYPE;

//#define		RFLAGS_FRAME_OUT_OF_ORDER		0x0001	// This buffer was received out-of-order
#define		RFLAGS_FRAME_INDICATED_NONSEQ	0x0002	// This buffer was indicated out of order, but is still in Out of Order list
//#define		RFLAGS_ON_OUT_OF_ORDER_LIST		0x0004	//
//#define		RFLAGS_IN_COMPLETE_PROCESS		0x0008
#define		RFLAGS_FRAME_LOST				0x0010	// This RCD represents and Unreliable frame that has been lost

struct recvdesc 
{
	DWORD				tTimestamp;					// timestamp upon packets arrival
	LONG				lRefCnt;
	UINT				Sign;						// Signature to identify data structure
	UINT				uiDataSize;					// data in this frame
	UINT				uiFrameCount;				// frames in message
	UINT				uiMsgSize;					// total byte count of message
	BYTE				bSeq;						// Sequence number of this frame
	BYTE				bFrameFlags;				// Flag field from actual frame
	BYTE				bFrameControl;
	PBYTE				pbData;						// pointer to actual data
	UINT				ulRFlags;					// Receive flags
	CBilink				blOddFrameLinkage;			// BILINKage for queues
	CBilink				blCompleteLinkage;			// 2nd Bilink so RCD can remain in Out Of Order Queue after indication
	PRCD				pMsgLink;					// Single link for frame in message
	DWORD				dwNumCoalesceHeaders;		// number of coalesce headers in message
	PSPRECEIVEDBUFFER	pRcvBuff;					// ptr to SP's receive data structure
};

typedef	struct buf		BUF, *PBUF;
typedef struct medbuf	MEDBUF, *PMEDBUF;
typedef	struct bigbuf	BIGBUF, *PBIGBUF;
typedef	struct dynbuf	DYNBUF, *PDYNBUF;

// NOTE: These structures Type members must stay lined up with the dwProtocolData member
// of an SPRECEIVEDBUFFER!!!
struct buf 
{
	PVOID			pvReserved;
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[SMALL_BUFFER_SIZE];		// 2K small buffer for combining multi-frame sends
};

struct medbuf 
{
	PVOID			pvReserved;
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[MEDIUM_BUFFER_SIZE];		// 4K mid size buffer
};

struct bigbuf 
{
	PVOID			pvReserved;
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[LARGE_BUFFER_SIZE];		// ARBITRARY SIZE OF MAX SEND (16K)
};

struct dynbuf 
{
	PVOID			pvReserved;
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
};

#endif // _DNPROT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\connect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Connect.cpp
 *  Content:	This file contains support for the CONNECT/DISCONNECT protocol in DirectNet.
 *				It is organized with FrontEnd routines first (Connect, Listen),
 *				and Backend handlers (timeouts,  frame crackers) after.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/11/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/***  FRONT END  ***/

/*
**		Connect
**
**			This function attempts to make a connection to a specified address.
**		The function establishes the existance of a DirectNet entity and maps
**		an EndPoint handle.  Then we exchange CONNECT packets which allows each
**		side to establish a baseline RTT.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPConnect"

HRESULT 
DNPConnect(HANDLE hProtocolData, IDirectPlay8Address* paLocal, IDirectPlay8Address* paRemote, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, VOID* pvSessionData, DWORD dwSessionDataSize, PHANDLE phConnectHandle)
{
	ProtocolData*	pPData;
	PSPD			pSPD;						// Service Provider to handle this connect
	PMSD			pMSD;
	SPCONNECTDATA	ConnData;					// Parameter Block
	HRESULT			hr;
#ifdef DBG
	ULONG			ulAllowedFlags;
#endif // DBG

	// Determine which SP will take this call
	//

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], paLocal[%p], paRemote[%p], hSPHandle[%x], ulFlags[%x], pvContext[%p], pvSessionData[%p], dwSessionDataSize[%u], phConnectHandle[%p]", hProtocolData, paLocal, paRemote, hSPHandle, ulFlags, pvContext, pvSessionData, dwSessionDataSize, phConnectHandle);

	hr = DPNERR_PENDING;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this op even though it isn't technically a message
	if((pMSD = (PMSD)POOLALLOC(MEMID_CONNECT_MSD, &MSDPool)) == NULL)
	{	
		DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
		hr = DPNERR_OUTOFMEMORY;	
		goto Exit;
	}

	pMSD->CommandID = COMMAND_ID_CONNECT;
	pMSD->pSPD = pSPD;
	pMSD->Context = pvContext;

	ASSERT(pMSD->pEPD == NULL); // MSD_Get/Release ensures this, and IndicateConnect requires it.

	// Prepare to call SP to map the endpoint.
	ConnData.pAddressDeviceInfo = paLocal;
	ConnData.pAddressHost = paRemote;
	ConnData.dwReserved = 0;  // Never used

#ifdef DBG
	ulAllowedFlags = DN_CONNECTFLAGS_SESSIONDATA;
#ifndef DPNBUILD_NOSPUI
	ulAllowedFlags |= DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING;
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_ONLYONEADAPTER
	ulAllowedFlags |= DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS;
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOMULTICAST
	ulAllowedFlags |= DN_CONNECTFLAGS_MULTICAST_SEND | DN_CONNECTFLAGS_MULTICAST_RECEIVE;
#endif // ! DPNBUILD_NOMULTICAST

	DNASSERT( ( ulFlags & ~(ulAllowedFlags) ) == 0 );
#ifndef DPNBUILD_NOMULTICAST
	DNASSERT( ! ( ( ulFlags & DN_CONNECTFLAGS_MULTICAST_SEND ) && ( ulFlags & DN_CONNECTFLAGS_MULTICAST_RECEIVE ) ) );
#endif // ! DPNBUILD_NOMULTICAST
#endif // DBG

	ConnData.dwFlags = 0;
#ifndef DPNBUILD_NOSPUI
	if ( ( ulFlags & DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING ) != 0 )
	{
		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
	}
#endif // ! DPNBUILD_NOSPUI

#ifndef DPNBUILD_ONLYONEADAPTER
	if ( ( ulFlags & DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS ) != 0 )
	{
		ConnData.dwFlags |= DPNSPF_ADDITIONALMULTIPLEXADAPTERS;
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifndef DPNBUILD_NOMULTICAST
	if ( ( ulFlags & DN_CONNECTFLAGS_MULTICAST_SEND ) != 0 )
	{
		pMSD->CommandID = COMMAND_ID_CONNECT_MULTICAST_SEND;
		ConnData.dwFlags |= DPNSPF_CONNECT_MULTICAST_SEND;
	}
	if ( ( ulFlags & DN_CONNECTFLAGS_MULTICAST_RECEIVE ) != 0 )
	{
		pMSD->CommandID = COMMAND_ID_CONNECT_MULTICAST_RECEIVE;
		ConnData.dwFlags |= DPNSPF_CONNECT_MULTICAST_RECEIVE;
	}
#endif	// DPNBUILD_NOMULTICAST

	if ( ( ulFlags & DN_CONNECTFLAGS_SESSIONDATA ) != 0 )
	{
		ConnData.dwFlags |= DPNSPF_SESSIONDATA;
		ConnData.pvSessionData = pvSessionData;
		ConnData.dwSessionDataSize = dwSessionDataSize;
	}

	ConnData.pvContext = pMSD;
	ConnData.hCommand = 0;

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;

#ifdef DBG
	// Hook up MSD before calling into SP
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);	// Put this on cmd list
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif // DBG

	*phConnectHandle = pMSD;

	// SP Connect call is guaranteed to return immediately

	LOCK_MSD(pMSD, "SP Ref");												// Add reference for call into SP
	LOCK_MSD(pMSD, "Temp Ref");

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Connect, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_Connect(pSPD->IISPIntf, &ConnData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// SP Connect should always be asynchronous so if it isnt PENDING then it must have failed
		DPFX(DPFPREP,1, "SP->Connect did not return DPNERR_PENDING, assuming failure, hr[%x]", hr);

		// DPNERR_PENDING is the only success code we accept
		ASSERT(FAILED(hr));

		Lock(&pMSD->CommandLock);								// This will be unlocked by final RELEASE_MSD

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);		// clear InSP flag

#ifdef DBG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();								// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif // DBG

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");									// Remove one ref for SP call
		RELEASE_MSD(pMSD, "Release On Fail");							// Remove one ref to free resource

		goto Exit;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = ConnData.hCommand;							// retain SP command handle
	pMSD->dwCommandDesc = ConnData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

Exit:
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x], pMSD[%p]", hr, pMSD);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}

/*
**		Listen
**
**		This command tells DN that it should start to accept connection requests.
**	This command will return pending,  and will continue to indicate connections
**	until it is explicitly cancelled.  It may be desireable to establish a limit
**	mechanism of some sort,  but for the time being this will do.
**
**		Now it is desirable to Listen on multiple ports on a single adapter.  This
**	means that we need to accept multiple concurrent Listen commands on each adapter.
**	Another fact of life is that we need to crack the Target address far enough to
**	determine which SP to submit the Listen on.
*/



#undef DPF_MODNAME
#define DPF_MODNAME "DNPListen"

HRESULT 
DNPListen(HANDLE hProtocolData, IDirectPlay8Address* paTarget, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, VOID* pvSessionData, DWORD dwSessionDataSize, HANDLE* phListenHandle)
{
	ProtocolData*	pPData;
	PSPD			pSPD;
	PMSD			pMSD;
	SPLISTENDATA	ListenData;
	HRESULT			hr;
#ifdef DBG
	ULONG			ulAllowedFlags;
#endif // DBG

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], paTarget[%p], hSPHandle[%p], ulFlags[%x], pvContext[%p], pvSessionData[%p], dwSessionDataSize[%u], phListenHandle[%p]", hProtocolData, paTarget, hSPHandle, ulFlags, pvContext, pvSessionData, dwSessionDataSize, phListenHandle);

	hr = DPNERR_PENDING;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this op even though it isn't technically a message
	if((pMSD = (PMSD)POOLALLOC(MEMID_LISTEN_MSD, &MSDPool)) == NULL)
	{	
		DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
		hr = DPNERR_OUTOFMEMORY;	
		goto Exit;
	}

	pMSD->CommandID = COMMAND_ID_LISTEN;
	pMSD->pSPD = pSPD;
	pMSD->Context = pvContext;

	ListenData.pAddressDeviceInfo = paTarget;

#ifdef DBG

	ulAllowedFlags =	DN_LISTENFLAGS_DISALLOWENUMS | DN_LISTENFLAGS_SESSIONDATA |
					DN_LISTENFLAGS_FASTSIGNED | DN_LISTENFLAGS_FULLSIGNED;
#ifndef DPNBUILD_NOSPUI
	ulAllowedFlags |= DN_LISTENFLAGS_OKTOQUERYFORADDRESSING;
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_NOMULTICAST
	ulAllowedFlags |= DN_LISTENFLAGS_MULTICAST | DN_LISTENFLAGS_ALLOWUNKNOWNSENDERS;
#endif // ! DPNBUILD_NOMULTICAST

	DNASSERT( ( ulFlags & ~(ulAllowedFlags) ) == 0 );
	DNASSERT(((ulFlags & DN_LISTENFLAGS_FASTSIGNED) && (ulFlags & DN_LISTENFLAGS_FULLSIGNED))==0);
	
#endif // DBG

		//if we've got signing on pick initial connect secrets, otherwise zero out the secrets
	pMSD->ullCurrentConnectSecret=0;
	if (ulFlags & DN_LISTENFLAGS_FASTSIGNED)
	{
		pMSD->ulMsgFlags1|=MFLAGS_ONE_FAST_SIGNED;
		DNGetGoodRandomData(&pMSD->ullCurrentConnectSecret, sizeof(pMSD->ullCurrentConnectSecret));
	}
	else if (ulFlags & DN_LISTENFLAGS_FULLSIGNED)
	{
		pMSD->ulMsgFlags1|=MFLAGS_ONE_FULL_SIGNED;
		DNGetGoodRandomData(&pMSD->ullCurrentConnectSecret, sizeof(pMSD->ullCurrentConnectSecret));
	}
	pMSD->ullLastConnectSecret=pMSD->ullCurrentConnectSecret;
	pMSD->dwTimeConnectSecretChanged=GETTIMESTAMP();

	ListenData.dwFlags = 0;
#ifndef DPNBUILD_NOSPUI
	if ( ( ulFlags & DN_LISTENFLAGS_OKTOQUERYFORADDRESSING ) != 0 )
	{
		ListenData.dwFlags |= DPNSPF_OKTOQUERY;
	}
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_NOMULTICAST
	if ( ( ulFlags & DN_LISTENFLAGS_MULTICAST ) != 0 )
	{
		pMSD->CommandID = COMMAND_ID_LISTEN_MULTICAST;
		ListenData.dwFlags |= DPNSPF_LISTEN_MULTICAST;
		if ( ( ulFlags & DN_LISTENFLAGS_ALLOWUNKNOWNSENDERS ) != 0 )
		{
			ListenData.dwFlags |= DPNSPF_LISTEN_ALLOWUNKNOWNSENDERS;
		}
	}
#endif // ! DPNBUILD_NOMULTICAST
	if ( ( ulFlags & DN_LISTENFLAGS_SESSIONDATA ) != 0 )
	{
		ListenData.dwFlags |= DPNSPF_SESSIONDATA;
		ListenData.pvSessionData = pvSessionData;
		ListenData.dwSessionDataSize = dwSessionDataSize;
	}
	if ( (ulFlags & DN_LISTENFLAGS_DISALLOWENUMS ) != 0 )
	{
		ListenData.dwFlags |= DPNSPF_LISTEN_DISALLOWENUMS;
	}
	ListenData.pvContext = pMSD;
	ListenData.hCommand = 0;

	*phListenHandle = pMSD;

	// SP Listen call is guarenteed to return immediately
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;

#ifdef DBG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);		// Dont support timeouts for Listen
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif // DBG

	LOCK_MSD(pMSD, "SP Ref");											// AddRef for SP
	LOCK_MSD(pMSD, "Temp Ref");

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Listen, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_Listen(pSPD->IISPIntf, &ListenData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// SP Listen should always be asynchronous so if it isnt PENDING then it must have failed
		DPFX(DPFPREP,1, "SP->Listen did not return DPNERR_PENDING, assuming failure, hr[%x]", hr);

		// DPNERR_PENDING is the only success code we accept
		ASSERT(FAILED(hr));

		Lock(&pMSD->CommandLock);

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DBG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif // DBG

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");						// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");				// release again to return resource

		goto Exit;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = ListenData.hCommand;			// retail SP command handle
	pMSD->dwCommandDesc = ListenData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

Exit:
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x], pMSD[%p]", hr, pMSD);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}

/***  BACKEND ROUTINES  ***/

/*
**		Complete Connect
**
**		The user's Connect operation has completed.  Clean everything up
**	and signal the user.
**
**		THIS IS ALWAYS CALLED WITH THE COMMAND LOCK HELD IN MSD, LEAVES WITH IT RELEASED
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteConnect"

VOID CompleteConnect(PMSD pMSD, PSPD pSPD, PEPD pEPD, HRESULT hr)
{
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	// We expect to never get here twice
	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETE;

	// Connects cannot have timeout timers
	ASSERT(pMSD->TimeoutTimer == NULL);

#ifdef DBG
	Lock(&pSPD->SPLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();							// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
	}
	Unlock(&pSPD->SPLock);

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
	pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

	pMSD->pEPD = NULL;
	Unlock(&pMSD->CommandLock);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	if(pEPD)
	{
		ASSERT(hr == DPN_OK);
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteConnect, pMSD[%p], Core Context[%p], hr[%x], pEPD[%p]", pEPD, pMSD, pMSD->Context, hr, pEPD);
		pSPD->pPData->pfVtbl->CompleteConnect(pSPD->pPData->Parent, pMSD->Context, hr, (PHANDLE) pEPD, &pEPD->Context);

		Lock(&pEPD->EPLock);
		ReceiveComplete(pEPD);		// Complete any, releases EPLock
	}
	else
	{
		ASSERT(hr != DPN_OK);
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling Core->CompleteConnect with NULL EPD, pMSD[%p], Core Context[%p], hr[%x]", pMSD, pMSD->Context, hr);
		pSPD->pPData->pfVtbl->CompleteConnect(pSPD->pPData->Parent, pMSD->Context, hr, NULL, NULL);
	}

	// Release the final reference on the MSD AFTER indicating to the Core
	Lock(&pMSD->CommandLock);
	RELEASE_MSD(pMSD, "Final Release On Complete");		// Finished with this one, releases CommandLock
}

/*
**		Complete Disconnect
**
**		THIS IS ALWAYS CALLED WITH THE COMMAND LOCK HELD IN MSD
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteDisconnect"

VOID CompleteDisconnect(PMSD pMSD, PSPD pSPD, PEPD pEPD)
{
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	// We expect to never get here twice
	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETE;

	// Disconnects cannot have timeout timers
	ASSERT(pMSD->TimeoutTimer == NULL);

#ifdef DBG
	Lock(&pSPD->SPLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();							// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
	}
	Unlock(&pSPD->SPLock);

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
	pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif // DBG

	// No one else should use this
	pMSD->pEPD = NULL;

	if(pMSD->CommandID == COMMAND_ID_DISCONNECT)
	{
		Unlock(&pMSD->CommandLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteDisconnect, DPN_OK, pMSD[%p], Core Context[%p]", pEPD, pMSD, pMSD->Context);
		pSPD->pPData->pfVtbl->CompleteDisconnect(pSPD->pPData->Parent, pMSD->Context, DPN_OK);
	}
	else
	{
		Unlock(&pMSD->CommandLock);

		ASSERT(pMSD->CommandID == COMMAND_ID_DISC_RESPONSE);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateConnectionTerminated, DPN_OK, Core Context[%p]", pEPD, pEPD->Context);
		pSPD->pPData->pfVtbl->IndicateConnectionTerminated(pSPD->pPData->Parent, pEPD->Context, DPN_OK);
	}

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
	RELEASE_MSD(pMSD, "Final Release On Complete");	// Finished with this one, releases CommandLock
	RELEASE_EPD(pEPD, "UNLOCK (DISC COMMAND)");		// release hold on EPD, releases EPLock
}

/*
**		Complete Hard Disconnect
**
**		CALLED WITH EP LOCK HELD. RETURNS WITH EP LOCK RELEASED
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteHardDisconnect"

VOID CompleteHardDisconnect(PEPD pEPD)
{
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	DNASSERT(pEPD->ulEPFlags & (EPFLAGS_HARD_DISCONNECT_SOURCE | EPFLAGS_HARD_DISCONNECT_TARGET));

		//potentially multiple threads can try and complete the hard disconnect
		//e.g. We might get a hard disconnect response at the same time we complete the send
		//of our final hard disconnect frame. This flag+guard ensures we only complete it once
	if (pEPD->ulEPFlags2 & EPFLAGS2_HARD_DISCONNECT_COMPLETE)
	{
		DPFX(DPFPREP, 7, "(%p) Ignoring. Hard disconnect already completed", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}
	pEPD->ulEPFlags2|=EPFLAGS2_HARD_DISCONNECT_COMPLETE;
		//if we've got a timer running to send more hard disconnect frames then cancel it
	if (pEPD->LinkTimer)
	{
		if (CancelProtocolTimer(pEPD->pSPD, pEPD->LinkTimer, pEPD->LinkTimerUnique)==DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP LINK RETRY)"); 
		}
		pEPD->LinkTimer=NULL;
		pEPD->LinkTimerUnique=0;
	}
	DPFX(DPFPREP, 7, "(%p) Completed hard disconnect sequence, dropping link.", pEPD);
		//actually completing/indicating the disconnection to core is handled in the drop link function
	DropLink(pEPD);
		//ep lock released by above call

		//finally drop the reference placed on the ep either when disconnect was called or when
		//it received its first hard disconnect frame
	Lock(&pEPD->EPLock);
	RELEASE_EPD(pEPD, "UNLOCK (HARD DISCONNECT)");		// release hold on EPD, releases EPLock
}

/*
**		Complete SP Connect
**
**		A Connect Command has completed in the Service Provider.  This does not mean our
**	work is done...  this means we now have a mapped EndPoint so we can exchange packets
**	with this partner.  We will now ping this partner to get an initial RTT and make sure
**	there really is a protocol over there that will talk to us.
**
**		Of course,  if SP does not return success then we can nip this whole thing in
**	the proverbial bud.
**
*/


#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSPConnect"

VOID CompleteSPConnect(PMSD pMSD, PSPD pSPD, HRESULT hr)
{
	PEPD		pEPD;

	DPFX(DPFPREP,5, "SP Completes Connect, pMSD[%p])", pMSD);

	pEPD = pMSD->pEPD;

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETE));

	if(hr != DPN_OK)
	{
		// This will only happen once since DoCancel will not have done it because the IN_SP flag was set, and
		// ConnectRetryTimeout has never yet been set.
		if (pEPD)
		{
			ASSERT_EPD(pEPD);
			Lock(&pEPD->EPLock);

			// Unlink EPD from MSD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");						// Release Reference from EPD

			DropLink(pEPD); // This releases the EPLock
		}
	
		Lock(&pMSD->CommandLock);						// must do this before clearing IN_SP flag

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag
		DECREMENT_MSD(pMSD, "SP Ref");							// Dec ref count w/o release lock

		DPFX(DPFPREP,5, "SP failed Connect, completing Connect, pMSD[%p], hr[%x]", pMSD, hr);
		CompleteConnect(pMSD, pSPD, NULL, hr);				// SP failed the connect call, unlocks CommandLock
		return;
	}

	// After a successful connect, we should have an endpoint
	ASSERT_EPD(pEPD);

	Lock(&pMSD->CommandLock);						// must do this before clearing IN_SP flag
	Lock(&pEPD->EPLock);

	// The endpoint should have already been linked to this MSD
	ASSERT(pEPD->pCommand == pMSD);

	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		// We get here when someone called DoCancel while we were still in the SP.  As above:
		// This will only happen once since DoCancel will not have done it because the IN_SP flag was set, and
		// ConnectRetryTimeout has never yet been set.

		// Unlink EPD from MSD
		ASSERT(pEPD->pCommand == pMSD);
		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "EPD Ref");						// Release Reference from EPD

		Unlock(&pMSD->CommandLock);						// DropLink may call into the SP

		DropLink(pEPD); // This releases the EPLock
		
		Lock(&pMSD->CommandLock);						// must do this before clearing IN_SP flag

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag
		DECREMENT_MSD(pMSD, "SP Ref");							// Dec ref count w/o release lock

		DPFX(DPFPREP,5, "(%p) Command is cancelled or timed out, Complete Connect, pMSD[%p]", pEPD, pMSD);
		CompleteConnect(pMSD, pSPD, NULL, DPNERR_USERCANCEL);
		return;
	}

	pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag
	DECREMENT_MSD(pMSD, "SP Ref");							// Dec ref count w/o release lock

	// Set up End Point Data /////////////////////////////////////////////////////////////////

	// Transition state
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTING;

	// Send CONNECT
	do
	{
		pEPD->dwSessID = DNGetGoodRandomNumber();
	} while (pEPD->dwSessID==0);
	
	DPFX(DPFPREP,5, "(%p) Sending CONNECT Frame, SessionID = %x", pEPD, pEPD->dwSessID);
	(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECT, 0, 0, FALSE);

	// Set timer for reply,  then wait for reply or TO. 
	pEPD->uiRetryTimeout = pSPD->pPData->dwConnectTimeout;
	pEPD->uiNumRetriesRemaining = pSPD->pPData->dwConnectRetries;	

	LOCK_EPD(pEPD, "LOCK (CONN Retry Timer)");						// Create reference for timer
	DPFX(DPFPREP,5, "(%p) Setting Connect Retry Timer", pEPD);
	ScheduleProtocolTimer(pSPD, pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, 
																&pEPD->LinkTimer, &pEPD->LinkTimerUnique);

	Unlock(&pEPD->EPLock);
	Unlock(&pMSD->CommandLock);
}

/*
**		Connect Retry Timeout
**
**		Retry timer has expired on a Connect operation.  This one function
**	is shared by Calling and Listening partners.  Complexity is due to the
**	fact that cancel code cannot always ensure that this handler will not
**	run,  so there are flags to signal various edge conditions (cancel, abort,
**	completion, high-level timeout).
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ConnectRetryTimeout"

VOID CALLBACK
ConnectRetryTimeout(void * const pvUser, void * const pvHandle, const UINT uiUnique)
{
	PMSD	pMSD;
	PEPD	pEPD = (PEPD) pvUser;
	PSPD	pSPD = pEPD->pSPD;

	DPFX(DPFPREP,5, "ENTER Connect Retry Timeout pEPD=%p", pEPD);

	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	if((pEPD->LinkTimer != pvHandle)||(pEPD->LinkTimerUnique != uiUnique))
	{
		// Timer been reset!  This is a spurious fire and should be ignored.
		RELEASE_EPD(pEPD, "UNLOCK: (Spurious (ie late) firing of CONNECT timer)"); // releases EPLock
		DPFX(DPFPREP,7, "(%p) Ignoring late CONNECT timer", pEPD);
		return;
	}
	
	pMSD = pEPD->pCommand;

	if(pMSD == NULL)
	{
		pEPD->LinkTimer = 0;
		RELEASE_EPD(pEPD, "UNLOCK: (Conn retry timer - after completion)"); // releases EPLock
		return;
	}
	
	ASSERT_MSD(pMSD);

	// Make sure this doesn't go away when we leave the lock
	LOCK_MSD(pMSD, "Hold For Lock");
	Unlock(&pEPD->EPLock); // Release before taking higher level lock

	// Take both locks in the proper order
	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	pEPD->LinkTimer = 0;

	// This timer should only be running in a CONNECTING state
	if(	(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE)) || 
		(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING)))
	{
		// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
		RELEASE_MSD(pMSD, "Hold for lock");						// Remove temporary reference and release lock
		RELEASE_EPD(pEPD, "UNLOCK (Conn Retry Timer)");			// Remove reference for timer, releases EPLock
		return;													// and thats all for now
	}

	// IF more retries are allowed and command is still active, send another CONNECT frame

	if(pEPD->uiNumRetriesRemaining-- > 0)
	{	
		pEPD->uiRetryTimeout = _MIN(pEPD->uiRetryTimeout * 2, 5000);	// exp backoff to a max of 5000ms until we establish our first RTT

		if(pMSD->CommandID == COMMAND_ID_CONNECT)
		{
			DPFX(DPFPREP,5, "(%p) Sending CONNECT Frame", pEPD);
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECT, 0, 0, FALSE);
		}
		// Listen -- retry CONNECTED frame
		else 
		{
			pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;	// We will expect a reply to this frame
			DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame", pEPD);
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, 0, 0, FALSE);
		}

		// Send the next ping
		DPFX(DPFPREP,7, "(%p) Setting Connect Retry Timer", pEPD);
		pEPD->LinkTimer = pvHandle;
		RescheduleProtocolTimer(pSPD, pvHandle, pEPD->uiRetryTimeout, 100, 
											ConnectRetryTimeout, (PVOID) pEPD, &pEPD->LinkTimerUnique);

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold for lock");						// Remove temporary reference and release lock

		// Since we have re-started timer, we don't adjust refcount
	}
	else
	{
		// We got no response and timed out.

		if(pMSD->CommandID == COMMAND_ID_CONNECT)
		{
			DECREMENT_EPD(pEPD, "UNLOCK: (Connect Timer (Failure Path))");// Dec Ref for this timer, releases EPLock

			// This will only happen once since we know DoCancel has not been called due to our CANCELLED check above,
			// and if it is now called it will see our CANCELLED flag set below.  We also know that the success case hasn't
			// happened or COMPLETE above would have been set.  We also have not had two timers get here because of the
			// CANCELLED check above and set here.
			pMSD->ulMsgFlags1 |= MFLAGS_ONE_CANCELLED;

			// Unlink EPD from MSD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");					// Release Reference from EPD

			Unlock(&pMSD->CommandLock); // DropLink may call into the SP.

			DropLink(pEPD);// Releases EPLock
			
			DECREMENT_MSD(pMSD, "Hold for lock");					// Remove temporary reference

			Lock(&pMSD->CommandLock);

			DPFX(DPFPREP,1, "(%p) Connect retries exhausted, completing Connect, pMSD[%p]", pEPD, pMSD);
			CompleteConnect(pMSD, pMSD->pSPD, NULL, DPNERR_NORESPONSE);			// releases CommandLock
		}

		// Listen - clean up associated state info,  then blow away end point
		else 
		{
			DPFX(DPFPREP,1, "(%p) Connect retries exhausted on Listen, Kill Connection, pMSD[%p]", pEPD, pMSD);

			if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
			{
				pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
				pEPD->blSPLinkage.RemoveFromList();					// Unlink EPD from Listen Queue
			}

			ASSERT(pEPD->pCommand != NULL);
			pEPD->pCommand = NULL;									// Unlink listen from EPD
			DECREMENT_MSD(pMSD, "EPD Ref");							// release reference for link to EPD
			RELEASE_MSD(pMSD, "Hold for lock");						// Remove temporary reference and release lock

			DECREMENT_EPD(pEPD, "UNLOCK: (Connect Timer (Failure Path))");// Dec Ref for this timer, SPLock not already held
			DropLink(pEPD);
		}
	}
}

/*
**		Process Connection Request
**
**		Somebody wants to connect to us.  If we have a listen posted we will
**	fill out a checkpoint structure to correlate his response and we will fire
**	off a CONNECTED frame ourselves
**
**		Since our connection will not be up until we receive a CONNECTED response
**	to our response we will need to set up a retry timer ourselves.
**
** 	Called with ep lock held. Returns with ep lock released
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectRequest"

VOID ProcessConnectRequest(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame)
{
	PMSD	pMSD = NULL;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "CONNECT REQUEST RECEIVED; EPD=%p SessID=%x", pEPD, pCFrame->dwSessID);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if((pMSD = pEPD->pCommand) == NULL)
	{
		// There are two cases: we are a connecting endpoint or we are a listening endpoint.  In the connecting
		// case we will fail in the following 'if' because we do not allow connections on non-listening endpoints.
		// In the listening case, the fact that pMSD is NULL means that we have received the other side's 
		// CONNECTED packet, which also tells us that they have seen our CONNECTED packet.  The only reason we
		// would now be seeing a CONNECT is if a) there was a stale, late-delivered packet on the wire, or b)
		// some malicious user is spoofing packets to us.  In both cases, ignoring the packet is the right 
		// thing to do.
		// There is a third possibility for the listening endpoint case, and that is that the other side went down
		// and we didn't realize it, and they are now attempting to reconnect.  The best we can do is wait the full
		// timeout until the link is torn down on our side, and let their retries make the connection for them at 
		// that time.  If we cut the timeout short, we have no way to know that a malicious user can't force 
		// legitimate connections closed by spoofing CONNECT packets.
		DPFX(DPFPREP,1, "(%p) CONNECT Frame received on CONNECTED link, ignoring", pEPD);
		DNASSERTX(FALSE, 3);

		Unlock(&pEPD->EPLock);
		return;
	}

	ASSERT_MSD(pMSD);
	LOCK_MSD(pMSD, "LOCK: Hold For Lock");		// Place reference on Cmd until we can lock it
	Unlock(&pEPD->EPLock);

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);											// Serialize access to EPD (this may not really be new sess)

	// Make sure this endpoint was listening for connections
	// This could be a Connect in which case this is a malicious packet.  It could also be a Disonnect or Disconnect Response
	// if the endpoint is being disconnected.  In any case we just need to ignore the connect packet.
	if(pMSD->CommandID != COMMAND_ID_LISTEN)
	{
		DPFX(DPFPREP,1, "(%p) PROTOCOL RECEIVED CONNECT REQUEST ON A NON-LISTENING ENDPOINT, IGNORING, pMSD[%p]", pEPD, pMSD);
		DNASSERTX(FALSE, 3);
		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		return;
	}

	// Make sure we can work with this version
	if((pCFrame->dwVersion >> 16) != (DNET_VERSION_NUMBER >> 16))
	{
		DPFX(DPFPREP,1, "(%p) PROTOCOL RECEIVED CONNECT REQUEST FROM AN INCOMPATIBLE VERSION(theirs %x, ours %x), DROPPING LINK", pEPD, pCFrame->dwVersion, DNET_VERSION_NUMBER);
		DNASSERTX(FALSE, 2);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		RejectInvalidPacket(pEPD);
			//above call will release ep lock
		return;
	}

	// Make sure we've been sent a valid session identity
	// N.B. We only added the fact that session ids couldn't be zero when signing was added
	if (VersionSupportsSigning(pCFrame->dwVersion) && pCFrame->dwSessID==0)
	{
		DPFX(DPFPREP,1, "(%p) Protocol received an invalid session identity", pEPD);
		DNASSERTX(FALSE, 2);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		RejectInvalidPacket(pEPD);
			//above call will release ep lock
		return;
	}

	// Make sure the listen command is still valid
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		DPFX(DPFPREP,1, "(%p) PROTOCOL RECEIVED CONNECT REQUEST ON A LISTEN THAT IS CANCELLED, DROPPING LINK, pMSD[%p]", pEPD, pMSD);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		RejectInvalidPacket(pEPD); // This releases the EPLock
		return;												
	}

	// We shouldn't use the pMSD past here since this will unlock it
	RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");

	// Are we already connected?
	if(pEPD->ulEPFlags & (EPFLAGS_STATE_CONNECTED | EPFLAGS_STATE_TERMINATING)) 
	{						
		DPFX(DPFPREP,1, "(%p) CONNECT Frame received on Connected or Terminating link, ignoring", pEPD);

		// If connection has been completed then we don't need to do more work

		// This can happen if we failed to cancel the connect timer in ProcessConnectedResponse and a CONNECT packet
		// comes in.
		Unlock(&pEPD->EPLock);
		return;
	}

	// If we are already in a CONNECTING state then this is not the first CONNECT frame we have seen.  If the SessID's
	// match, then the partner probably didn't hear our first response, so we will resend it.  If the SessID's don't
	// match, then either the partner aborted and is starting with a new SessID, or a malicious party is spoofing the
	// partner's address, and sending a bogus packet.  In either of these cases we will ignore the connect.  A partner 
	// aborting a connect mid-way probably crashed anyway, and waiting for us to timeout the first connect attempt 
	// will be the least of their worries.

	if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING) 
	{						
		if(pCFrame->dwSessID != pEPD->dwSessID)
		{
			DPFX(DPFPREP,1, "(%p) Received non-matching SessionID, ignoring CONNECT", pEPD);
			Unlock(&pEPD->EPLock);
			return;
		}

		// Unexpected CONNECT Frame has same Session ID.  Partner probably lost our response.  We will
		// respond again to this one.
		
		DPFX(DPFPREP,1, "(%p) Received duplicate CONNECT request. Sending another response...", pEPD);

		// Listen side must set this before sending CONNECTED
		pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;					// We will expect a reply to this frame

		// If this fails they will be sending another CONNECT anyway, so we do nothing
		(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID, 0, FALSE);

		Unlock(&pEPD->EPLock);
		return;
	}

	// Transition state
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTING;

	// If version number is high enough then mark the fact that this link could potentially use signing
	// The fact we're handling a CONNECT here (rather than in unconnected data) indicates that the session
	// is actually unsigned, but flicking this bit ensure we'll use the new style keep alives
	if (VersionSupportsSigning(pCFrame->dwVersion) && VersionSupportsSigning(DNET_VERSION_NUMBER))
	{
		pEPD->ulEPFlags2|=EPFLAGS2_SUPPORTS_SIGNING;
	}
	
	pEPD->dwSessID = pCFrame->dwSessID;							// Use this SessID in all C-traffic
	pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;					// We will expect a reply to this frame

	DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame", pEPD);
	(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID, 0, FALSE);

	pEPD->uiRetryTimeout = pSPD->pPData->dwConnectTimeout;		// Got to start somewhere
	pEPD->uiNumRetriesRemaining = pSPD->pPData->dwConnectRetries;		// w/exponential wait

	LOCK_EPD(pEPD, "LOCK: (CONNECT RETRY TIMER)");				// Create reference for timer
	DPFX(DPFPREP,5, "(%p) Setting Connect Timer", pEPD);
	ScheduleProtocolTimer(pSPD, pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, 
																&pEPD->LinkTimer, &pEPD->LinkTimerUnique);
	if (pEPD->LinkTimer == 0)
	{
		DPFX(DPFPREP,1, "(%p) Setting Connect Retry Timer failed", pEPD);

		// If we can't even set timers due to low memory, then the best we can do is
		// abandon this new connection and hope to give good service to our existing
		// connections.
		DECREMENT_EPD(pEPD, "UNLOCK: (CONNECT RETRY TIMER)");

		pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
		pEPD->blSPLinkage.RemoveFromList();						// Unlink EPD from Listen Queue

		// Unlink the MSD from the EPD
		ASSERT(pEPD->pCommand == pMSD);
		pEPD->pCommand = NULL;

		DropLink(pEPD); // This releases EPLock

		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "EPD Ref");

		return;
	}

	Unlock(&pEPD->EPLock);
}


/*
**		CompleteConnectedResponse
**
**	This is completes a connection response: marking the link as in use, initialize the send/recv parameters and
**	indicates the connection to the core. Its called from both ProcessConnectedResponse and 
**	ProcessConnnectedSignedResponse, performing the link setup that common to both
**
** 	Called with both EP Lock and MSD Command Lock held. Returns with both released.
**/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteConnectedResponse"

void CompleteConnectedResponse(PProtocolData pPData, PEPD pEPD, PMSD pMSD, PCFRAME pCFrame, DWORD dwInitialRTT, DWORD tNow)
{
	DNASSERT((pEPD->ulEPFlags & (EPFLAGS_STATE_DORMANT | EPFLAGS_STATE_CONNECTING | EPFLAGS_STATE_TERMINATING))==0);
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	PSPD pSPD=pEPD->pSPD;

		//mark that the link is connected and ready to send
	pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTED | EPFLAGS_STREAM_UNBLOCKED;

		//clip the measured RTT to within a sensible range
	if (((int) dwInitialRTT) <= 0)
	{
		DPFX(DPFPREP,1, "(%p) dwInitialRTT measured as %d, using 1ms instead", pEPD, dwInitialRTT);
		dwInitialRTT = 1;
	}
	else if (dwInitialRTT>pPData->dwSendRetryIntervalLimit/2)
	{
		dwInitialRTT=pPData->dwSendRetryIntervalLimit/2;
	}

	if (VersionSupportsCoalescence(pCFrame->dwVersion)==FALSE)
	{
		DPFX(DPFPREP,1, "(%p) Partner does not support coalescence", pEPD);
		pEPD->ulEPFlags2 |= EPFLAGS2_NOCOALESCENCE;
	}
#ifdef DPNBUILD_COALESCENEVER
	else
	{
		DPFX(DPFPREP,7, "(%p) Disabling coalescence sends even though partner supports them.", pEPD);
		pEPD->ulEPFlags2 |= EPFLAGS2_NOCOALESCENCE;
	}
#endif // DPNBUILD_COALESCENEVER

	if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
	{
		pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
		pEPD->blSPLinkage.RemoveFromList();							// Unlink EPD from Listen Queue
	}

	DPFX(DPFPREP,1, "(%p) Partner Reported Version: %x, Our Version: %x, tNow %u Initial RTT %u",
								pEPD, pCFrame->dwVersion, DNET_VERSION_NUMBER, tNow, dwInitialRTT);
	
		//set up EP ready to received and send with some sensible initial state	
	InitLinkParameters(pEPD, dwInitialRTT, tNow);
	
	DPFX(DPFPREP,5, "(%p) N(R) = 0, N(S) = 0", pEPD);
	pEPD->bNextSend = 0;
	pEPD->bNextReceive = 0;
	pEPD->bHighestAck = 0xFF;
			
	
	/*
	**	It turns out that the first RTT measurement is a very bad one (slow) because because
	**	it includes overhead for opening and binding a new socket,  endpoint creation,  etc.
	**	Therefore each side will take another quick sample right away.  The initial calculations
	**	above will still serve as an initial RTT until this better sample is available
	*/

	// Take another RTT sample
	DPFX(DPFPREP,7,"(%p) Performing Checkpoint", pEPD);
	SendKeepAlive(pEPD);

	// Cleanup connect operation
	if(pMSD->CommandID == COMMAND_ID_CONNECT)
	{
		// There was a CONNECT Command issued that now must be completed

		DECREMENT_MSD(pMSD, "Hold For Lock");				// Remove temporary reference from above.
		
		// This will not happen twice because both COMPLETE and CANCELLED are checked above, and the
		// call to CompleteConnect will set COMPLETE.

		// Unlink the MSD from the EPD
		ASSERT(pEPD->pCommand == pMSD);
		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "EPD Ref");							// Release reference for EPD link

		Unlock(&pEPD->EPLock);

		CompleteConnect(pMSD, pSPD, pEPD, DPN_OK);			// This releases the MSD Lock
	}
	else 
	{		// LISTENING
		// We were the listener.  We will indicate a Connect event on the listen
		// command w/o completing the Listen

		ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);

		// We know this will only happen once because the person who does it will transition us out
		// of the CONNECTING state, and we can't get here unless we are in that state.

		// Unlink the MSD from the EPD
		ASSERT(pEPD->pCommand == pMSD);
		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "EPD Ref");							// Release reference for EPD link

		Unlock(&pEPD->EPLock);

		Unlock(&pMSD->CommandLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateConnect, pMSD[%p], Core Context[%p]", pEPD, pMSD, pMSD->Context);
		pSPD->pPData->pfVtbl->IndicateConnect(pSPD->pPData->Parent, pMSD->Context, (PHANDLE) pEPD, &pEPD->Context);

		// Complete any receives that queued while waiting for IndicateConnect
		Lock(&pEPD->EPLock);
		ReceiveComplete(pEPD);	// releases EPLock

		// Release the final reference on the MSD AFTER indicating to the Core
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Hold For Lock");					// release temp MSD (releases lock)
	}		
}


/*
**		Process Connected Response
**
**		A response to a connection request has arrived (or a response to
**	our connection response).  Now the connection is officially up (on
**	our end of the circuit).  Set the link-state according to our first
**	RTT sample and get ready to party.
**
**		If we are the originating party,  we will want to send a
**	CONNECTED frame to our partner, even though the connection is
**	complete from our perspective.  This will allow partner to establish
**	his baseline RTT and clock bias as we can do here.  In this case,  he
**	will have his POLL bit set in the frame we just received.
**
**		Now, we might get additional CONNECTED frames after the first one
**	where we startup the link.  This would most likely be due to our CONNECTED
**	response getting lost.  So if we get a CONNECTED frame with POLL set
**	after our link is up,  we will just go ahead and respond again without
**	adjusting our state.
**
**		Note about Locks:
**
**		This code is complicated by the precedence of CritSec ownership.  To simplify
**	as much as possible we will take the Listen command lock at the very start of the
**	procedure (when appropriate) because it has the highest level lock.  This prevents
**	us from completing the whole connection process and then finding that the Listen
**	went away so we can't indicate it to the user.
**
**		We keep a RefCnt on the Listen so it won't go away while a new session
**	is pending on it.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectedResponse"

VOID ProcessConnectedResponse(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame, DWORD tNow)
{
	PCHKPT		pCP;
	PMSD		pMSD;
	DWORD		dwInitialRTT;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "CONNECT RESPONSE RECEIVED (pEPD=0x%p)", pEPD);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// If the link has not seen a CONNECT or issued a CONNECT, we do not expect a CONNECTED.  
	// Since this is the only reason this EPD was created, we will tear it down by rejecting
	// the connection.
	if (pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED response received on a dormant link, dropping link", pEPD);
		RejectInvalidPacket(pEPD);
			//ep lock will be released by above function
		return;
	}

	// There is a possibility that the link is in the terminating state.  If so, we don't
	// care about CONNECTED packets.
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED response received on a terminating link, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}

	// At this point either we are connecting and this is a response, or someone has connected to us, and this is
	// the reply to our response.  Note that this could be a duplicate of one of these cases, so we may already
	// be in a connected state.  There is also the possiblity that these are malicious packets.
	ASSERT(pEPD->ulEPFlags & (EPFLAGS_STATE_CONNECTING | EPFLAGS_STATE_CONNECTED));

	// If the SessID does not match, ignore the CONNECTED packet.  This is either a malicious attempt at messing
	// up a legitimate connection, or our partner aborted and has come back in with a new session ID.
	if(pEPD->dwSessID != pCFrame->dwSessID)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED response has bad SessID, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}
		
	//	If we have completed our side of the connection then our only responsibility is to send responses
	// if our partner is still POLLING us.
	
	if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED)
	{
		// A Listen will set POLL on the CONNECTED packet, a Connect will not
		// If we're a signed link then this is a bogus packet, since we should only get CONNECTEDSIGNED responses
		// hence we do nothing in that case
		if ((pCFrame->bCommand & PACKET_COMMAND_POLL) && ((pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK)==0))
		{	
			DPFX(DPFPREP,5, "(%p) Duplicate CONNECTED frame, sending another response...", pEPD);

			// If this fails we will let the partner's retry catch it.
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID, 0, FALSE);
		}
		Unlock(&pEPD->EPLock);
		return;
	}

	// Since we are not CONNECTED yet, we must be in a CONNECTING state in order to receive a 
	// CONNECTED response.
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING);

	// MSD should not be NULL if we are in the CONNECTING state
	pMSD = pEPD->pCommand;
	ASSERT_MSD(pMSD);
	LOCK_MSD(pMSD, "Hold For Lock");		// Place reference on Cmd until we can lock it
	Unlock(&pEPD->EPLock);

 	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	// Since we left the EPLock, we must verify that we are still in the connecting state
	if (!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING))
	{	
		DPFX(DPFPREP,1, "(%p) EPD left the CONNECTING state while we were out of the lock, ignoring CONNECTED frame", pEPD);

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock"); // This releases the command lock
		return;
	}

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE))
	{
		DPFX(DPFPREP,1, "(%p) Connect/Listen command cancelled or complete, ignoring CONNECTED frame", pEPD);

		// Whoever cancelled the Listen should be disconnecting this connection too
		// so all we have to do here is bail out.

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock"); // This releases the command lock
		return;
	}
		
	// Next, take care of this guy's reply if we still owe him one

	// A Listen will set POLL on the CONNECTED packet, a Connect will not
	if(pCFrame->bCommand & PACKET_COMMAND_POLL)
	{				
		DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame", pEPD);
		if(SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID, 0, FALSE) != DPN_OK)
		{
			DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame Failed", pEPD);

			// We cannot complete the connection...  we will just let things time out
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);					// Protect the pCommand field
			return;
		}
	}

	// Now we can setup our new link,  but only if this frame Correlates to a checkpoint we have outstanding
	// so we can seed our state variables.

	// Can we correlate resp?
	pCP = LookupCheckPoint(pEPD, pCFrame->bRspID);
	if (pCP==NULL)
	{
		/*
		**		Uncorrelated CONNECTED frame.  How can this happen?  Parter's response must
		**	have been dropped,  so he is retrying his CONN frame.  Since we are trying to
		**	measure an accurate RTT we dont want to use his retry against our original
		**	request,  so he zeros out his Resp correlator.  We will eventually retry with
		**	new correlator and hopefully that frame will get through.
		*/

		DPFX(DPFPREP,1, "(%p) Uncorrelated CONNECTED frame arrives", pEPD);
		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock");
		return;
	}
	
		// We are connected, so shut off retry timer
	if(pEPD->LinkTimer != 0)
	{
		DPFX(DPFPREP,5, "(%p) Cancelling Connect Timer", pEPD);
		if(CancelProtocolTimer(pSPD, pEPD->LinkTimer, pEPD->LinkTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK: (Conn Retry Timer - Connect Complete)");		//  remove reference for timer, SPLock not already held
		}
		else 
		{
			DPFX(DPFPREP,5, "(%p) Cancelling Connect Timer Failed", pEPD);
		}
		pEPD->LinkTimer = 0;	// This will prevent timer from trying to do any work if it couldn't cancel
	}

		//twiddle the connecting bit off. We'll set the CONNECTED bit when we complete the connected response
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING);
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_CONNECTING);

	// If version number is high enough then mark the fact that this link could potentially use signing
	// We've obviously got an unsigned link (because we got a CONNECT rather than a CONNECTSIGNED), but
	// this'll ensure we use the new style Keep Alives rather than the old
	// N.B. The listening side may have already flicked this bit when it got the initial CONNECT. So this 
	// is only really necessary for the connecting side. But there's no point doing an extra check for a harmless or op.
	if (VersionSupportsSigning(pCFrame->dwVersion) && VersionSupportsSigning(DNET_VERSION_NUMBER))
	{
		pEPD->ulEPFlags2|=EPFLAGS2_SUPPORTS_SIGNING;
	}

		//compute the initial RTT based on the checkpoint and then clean the checkpoint state up
	dwInitialRTT = tNow - pCP->tTimestamp;
	ChkPtPool.Release(pCP);
	FlushCheckPoints(pEPD);		// Make sure we do this before the InitCheckPoint

		//Finally set link up and indicate connect to the core
		//This runs the code path common to both CONNECTED and CONNECTEDSIGNED responses
	CompleteConnectedResponse(pSPD->pPData, pEPD, pMSD, pCFrame, dwInitialRTT, tNow);
		//above call releases both EP lock and MSD command lock
}



/*
**		ProcessConnectedSignedResponse
**
**	This is called when a CONNECTEDSIGNED cframe is received and we're either already connected/connecting
**	or we've just completed the 3 way handshake using unconnected data and are now ready to complete
**	the connection.
**
** 	Called with the EP Lock held. Returns with it released.
**/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectedSignedResponse"

VOID ProcessConnectedSignedResponse(PSPD pSPD, PEPD pEPD, CFRAME_CONNECTEDSIGNED * pCFrame, DWORD tNow)
{
	PMSD		pMSD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "CONNECT SIGNED response received (pEPD=0x%p)", pEPD);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

		//If the link is already being terminated (possibly this is a repeat reponse from a listener, 
		//so we've already indicated that the link is up and then torn it down) then ignore this frame
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED SIGNED response received on a terminating link, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}

		//If endpoint has already got a session identity it must match the one presented in this frame
		//anything else indicates a malicious packet. Also the supplied sesion identity must be none zero
	if ((pCFrame->dwSessID==0) || (pEPD->dwSessID && pEPD->dwSessID!=pCFrame->dwSessID))
	{
		DPFX(DPFPREP,1, "(%p) CONNECTED SIGNED response received with invalid session identity "
							"pCFrame->dwSessID[%u] pEPD->dwSessID[%u]", pEPD, pCFrame->dwSessID, pEPD->dwSessID);
		RejectInvalidPacket(pEPD);
			//above call will release EP lock
		return;
	}

		//there are basically 3 conditions we care about.
		//1. Endpoint is already connected. In this case we're probably the connector and our original
		//connected signed frame to the listener was dropped. We just need to resend that response
		//2. Endpoint is connecting. In this case we're the connector and we've just got our first response
		//to our initial CONNECT frame. Time to complete the connection and make endpoint connected
		//3. Endpoint is dormant. In this case we're the listener and we've just completed the three way
		//handshake for a valid connection. Time to complete the connection and make endpoint connected
	

		//connected case is simplest to handle
	if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED)
	{
			//if the poll bit is set it means the frame originated from a listening side, so we should
			//send a response back to them. If endpoint isn't marked as already being in a signed session
			//then something is screwy and we should ignore this frame
		if((pCFrame->bCommand & PACKET_COMMAND_POLL) &&
			(pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK))
		{	
			DPFX(DPFPREP,5, "(%p) Duplicate CONNECTED SIGNED frame, sending another response...", pEPD);

			SendConnectedSignedFrame(pEPD, pCFrame, tNow);
		}
		Unlock(&pEPD->EPLock);
		return;
	}
		//we're going to need to complete the connection as we must have either just got a response to our CONNECT
		//(CONNECTING case) or we're completed the 3 way initial connect handshake (DORMANT case)
	DNASSERT(pEPD->ulEPFlags & (EPFLAGS_STATE_DORMANT | EPFLAGS_STATE_CONNECTING));

		//The MSD will either refer to a listen or a connect. We have to fiddle around with locking order
		//at this point, to ensure we take the MSD lock before the EP lock
	pMSD = pEPD->pCommand;
	ASSERT_MSD(pMSD);
	LOCK_MSD(pMSD, "Hold For Lock");		// Place reference on Cmd until we can lock it
	Unlock(&pEPD->EPLock);

 	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

		// Since we left the EPLock, we must verify that we are still good to process this frame
	if ((pEPD->ulEPFlags & (EPFLAGS_STATE_DORMANT | EPFLAGS_STATE_CONNECTING))==0)
	{	
		DPFX(DPFPREP,1, "(%p) EPD now in invalid state to process CONNECTED SIGNED frame", pEPD);
		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock"); // This releases the command lock
		return;
	}
	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE))
	{
		DPFX(DPFPREP,1, "(%p) Connect/Listen command cancelled or complete, ignoring CONNECTED SIGNED frame", pEPD);

		// Whoever cancelled the Connect/Listen should be disconnecting this connection too
		// so all we have to do here is bail out.

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock"); // This releases the command lock
		return;
	}

	DWORD dwInitialRTT;

		//if we're making the connection then we need to send a response back to the listener to confirm we're
		//a valid host, compute what the RTT we just saw was and shut off the timer we were using to send CONNECT frames
	if (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING)
	{
			//check the signing options we've been sent from the listener make sense
			//we should have a single signing type specified (and not both)
			//and we're responsible for picking the secrets, so the values specified in the frame should be zero
		if (((pCFrame->dwSigningOpts & (PACKET_SIGNING_FAST | PACKET_SIGNING_FULL))==0) ||
				((pCFrame->dwSigningOpts & (PACKET_SIGNING_FAST | PACKET_SIGNING_FULL))==
																(PACKET_SIGNING_FAST | PACKET_SIGNING_FULL)) ||
							pCFrame->ullSenderSecret!=0 || pCFrame->ullReceiverSecret!=0)
		{
			DPFX(DPFPREP, 0, "Ignoring CONNECTED_SIGNED cframe with invalid signing options");
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);
			return;
		}
			//find the check point associated with the initial connect so we can assess RTT
			//if we can't find one something is screwy so we'll just ignore this frame			
		PCHKPT pCP = LookupCheckPoint(pEPD, pCFrame->bRspID);
		if (pCP==NULL)
		{
			DPFX(DPFPREP,5, "(%p) Failed to find checkpoint. Ignoring frame", pEPD);
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);
			return;
		}
			//listener should always respond with the poll bit set. If its not set this is some bogus packet and we should ignore it
		if ((pCFrame->bCommand & PACKET_COMMAND_POLL)==0)
		{
			DPFX(DPFPREP,5, "(%p) Ignoring CONNECTED SIGNED response with clear POLL bit", pEPD);
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);
			return;
		}

			//generate both the local and the remote secret. These'll both be sent back to the listener in the CONNECTED SIGNED
			//response we're going to send out immediately after this. Note we only generate these values once and they
			//can never be zero
		while (pEPD->ullCurrentLocalSecret==0)
		{
			DNGetGoodRandomData(&pEPD->ullCurrentLocalSecret, sizeof(pEPD->ullCurrentLocalSecret));
		}
		while (pEPD->ullCurrentRemoteSecret==0)
		{
			DNGetGoodRandomData(&pEPD->ullCurrentRemoteSecret, sizeof(pEPD->ullCurrentRemoteSecret));
		}
		pEPD->ullOldLocalSecret=pEPD->ullCurrentLocalSecret;
		pEPD->ullOldRemoteSecret=pEPD->ullCurrentRemoteSecret;
		pEPD->ullLocalSecretModifier=pEPD->ullCurrentLocalSecret;
		pEPD->ullRemoteSecretModifier=pEPD->ullCurrentRemoteSecret;
		
			//Also if we fail to send the response frame then we shouldn't evolve our state. We'll retransmit a new CONNECT
			//at some point and we can try the whole process again then
		DPFX(DPFPREP,5, "(%p) Sending CONNECTED SIGNED Frame", pEPD);
		if (SendConnectedSignedFrame(pEPD, pCFrame, tNow)!=DPN_OK)
		{
			DPFX(DPFPREP,5, "(%p) Failed to send CONNECTED SIGNED response", pEPD);
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);
			return;
		}
			//connect has succeeded so clean up the link timer
		if(pEPD->LinkTimer != 0)
		{
			DPFX(DPFPREP,5, "(%p) Cancelling Connect Timer", pEPD);
			if(CancelProtocolTimer(pSPD, pEPD->LinkTimer, pEPD->LinkTimerUnique) == DPN_OK)
			{
					//  remove reference for timer, SPLock not already held
				DECREMENT_EPD(pEPD, "UNLOCK: (Conn Retry Timer - Connect Complete)");		
			}
			else 
			{
				DPFX(DPFPREP,5, "(%p) Cancelling Connect Timer Failed", pEPD);
			}
			pEPD->LinkTimer = 0;	// This will prevent timer from trying to do any work if it couldn't cancel
		}
			//compute the initial RTT, and then clear up the check point objects
		dwInitialRTT = tNow - pCP->tTimestamp;
		ChkPtPool.Release(pCP);
		FlushCheckPoints(pEPD);	
			
			//twiddle the connecting bit off. We'll flick the connected bit on in CompleteConnectedResponse
		pEPD->ulEPFlags &= ~(EPFLAGS_STATE_CONNECTING);
		
	}
		//else if we've got a dormant endpoint then this endpoint has been created as a result of completing a
		//3 way handshake with unconnected data. We can now complete the connection
	else if (pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT)
	{
			//N.B. By the time we get here we'll have already checked the version number, the signing options,
			//the connect signature and the session identity for validity
			//twiddle the dormant bit off. We'll flick the connected bit on in CompleteConnectedResponse
		pEPD->ulEPFlags &= ~(EPFLAGS_STATE_DORMANT);
			//compute the RTT based on our original timestamp thats been echoed back to us
		dwInitialRTT=tNow-pCFrame->dwEchoTimestamp;
			//store the session identity indicated by the frame we just received
		pEPD->dwSessID=pCFrame->dwSessID;
			//and store the secrets we should be using to sign the link
		pEPD->ullCurrentLocalSecret=pCFrame->ullReceiverSecret;
		pEPD->ullOldLocalSecret=pCFrame->ullReceiverSecret;
		pEPD->ullLocalSecretModifier=pCFrame->ullReceiverSecret;	
		pEPD->ullCurrentRemoteSecret=pCFrame->ullSenderSecret;
		pEPD->ullOldRemoteSecret=pCFrame->ullSenderSecret;
		pEPD->ullRemoteSecretModifier=pCFrame->ullSenderSecret;
	}	
		//else endpoint is in some weird undetermined condition
	else
	{
		DPFX(DPFPREP, 0, "(%p) In unknown state when processing CONNECTED SIGNED", pEPD);
		DNASSERT(0);
		RELEASE_MSD(pMSD, "Hold For Lock");
		Unlock(&pEPD->EPLock);
		return;
	}



		//mark the endpoint with the relevant signing flags
	pEPD->ulEPFlags2|=EPFLAGS2_SUPPORTS_SIGNING;
	if (pCFrame->dwSigningOpts & PACKET_SIGNING_FAST)
	{
		DPFX(DPFPREP, 7, "(%p) Marking endpoint as fast signed local secret %x-%x remote secret %x-%x", 
				pEPD, DPFX_OUTPUT_ULL(pEPD->ullCurrentLocalSecret), DPFX_OUTPUT_ULL(pEPD->ullCurrentRemoteSecret));
		pEPD->ulEPFlags2|=EPFLAGS2_FAST_SIGNED_LINK;
	}
	else
	{
		DPFX(DPFPREP, 7, "(%p) Marking endpoint as full signed local current secret %x-%x old secret %x-%x modifier %x-%x remote current secret %x-%x old secret %x-%x modifier %x-%x",
				pEPD, DPFX_OUTPUT_ULL(pEPD->ullCurrentLocalSecret), DPFX_OUTPUT_ULL(pEPD->ullOldLocalSecret), 
				DPFX_OUTPUT_ULL(pEPD->ullLocalSecretModifier), DPFX_OUTPUT_ULL(pEPD->ullCurrentRemoteSecret),
				DPFX_OUTPUT_ULL(pEPD->ullOldRemoteSecret), DPFX_OUTPUT_ULL(pEPD->ullRemoteSecretModifier));
		pEPD->ulEPFlags2|=EPFLAGS2_FULL_SIGNED_LINK;

			//start looking for frames in the first 3/4's of the sequence space we can use to modify the secrets
		pEPD->byRemoteSecretModifierSeqNum=SEQ_WINDOW_3Q;
		pEPD->byLocalSecretModifierSeqNum=SEQ_WINDOW_3Q;		
	}
	
		//and complete the connection setup processing
		//this runs the code common to both CONNECTED and CONNECTEDSIGNED paths
	CompleteConnectedResponse(pSPD->pPData, pEPD, pMSD, (PCFRAME ) pCFrame, dwInitialRTT, tNow);
		//above call releases both EP lock and MSD command lock

}


/*
**		Drop Link
**
**			For whatever reason we are dropping an active link.  This requires us to
**		Cancel any outstanding commands and give an indication to the user.
**
**
**		**  CALLED WITH EPD->EPLOCK HELD;  RETURNS WITH LOCK RELEASED  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DropLink"

VOID DropLink(PEPD pEPD)
{
	DPFX(DPFPREP,2, "Drop Link %p (refcnt=%d)", pEPD, pEPD->lRefCnt);

	ASSERT_EPD(pEPD);
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	PSPD	pSPD = pEPD->pSPD;

	//	First set/clear flags to prevent any new commands from issueing

	// We will not indicate disconnect if the Core never knew about the connetion
	BOOL fIndicateDisconnect = (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED);
	// By default if we indicate disconnection from this function it'll be the connection terminated type
	//the only exception is if ep is the source of a hard disconnect
	BOOL fDisconnectTypeTermination=TRUE;

	// Transition state
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_CONNECTING | EPFLAGS_STATE_DORMANT | EPFLAGS_STATE_CONNECTED | 
						 EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED);	// Link is now down
	pEPD->ulEPFlags |= EPFLAGS_STATE_TERMINATING; // Accept no new commands

	// I am creating a RefCnt bump for the send pipeline,  which means we will no longer pull EPDs off
	// the pipeline here.  The clearing of the flags above will cause the EPD to be dropped from the
	// pipeline the next time it is due to be serviced.  We CAN still clean up all the frames'n'stuff
	// because the send loop doesnt need to actually DO anything with this EPD.  This behavior allows
	// the SendThread to loop through the pipeline queue, surrendering locks, without having the queue
	// changing beneath it.

		//cancel all the timers on an endpoint
	CancelEpdTimers(pEPD);
		//EPLock is still held when this returns

		//cancel all pending sends
	AbortSendsOnConnection(pEPD);	
		//EPLock is released when this returns
		
	Lock(&pEPD->EPLock);
	
	// Connects, Listens, and Disconnects are associated with an EPD through the pCommand member.  AbortSends will
	// have removed any Disconnects, and no Connects or Listens should still be hanging on when we call DropLink.
	ASSERT(pEPD->pCommand == NULL);

		// Now we clean up any receives in progress.  We throw away any partial or mis-ordered messages.
		//This returns all the recv buffers (if any) on a single list we can pass back to the SP once we unlock the EPD
	SPRECEIVEDBUFFER * pRcvBuff = AbortRecvsOnConnection(pEPD);
		//EPLock is still held when this returns

	IDP8ServiceProvider	*pSPIntf = pSPD->IISPIntf;

		//if we had a COMMAND_ID_DISCONNECT or COMMAND_ID_DISC_RESPONSE  msg held in EPD::pCommand then 
		//during AbortSendsOnConnection we'll have handled completing the connection. Alternatively if this is a hard disconnect
		//or the link has dropped in an untidy way, we'll have to indicate the disconnect here.
		//N.B. Its possible if we started a soft disconnect, and the remote end started a hard disconnect, then although we'll
		//actually drop due to the hard disconnect, we'll do the disconect completition using the soft disconnect msg
		//i.e. Indicating completition in the AbortSendsOnConnection using the COMMAND_ID_DISCONNECT msg
	if (!(pEPD->ulEPFlags & EPFLAGS_INDICATED_DISCONNECT))
	{
		if (fIndicateDisconnect)
		{
			// Make sure we are the only one that indicates the disconnect
			pEPD->ulEPFlags |= EPFLAGS_INDICATED_DISCONNECT;
			// If this endpoint was the source of a hard disconnect we should indicate disconection as a completition
			// rather than a termination
			if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_SOURCE)
			{
				fDisconnectTypeTermination=FALSE;
			}
		}
	}
	else
	{
		// Someone else beat us to it.
		fIndicateDisconnect = FALSE;
	}

	// We need to make sure that we don't allow DNPRemoveServiceProvider to complete until we are out of the Core
	// and SP.  This reference will do that, and is released at the end of this function.
	LOCK_EPD(pEPD, "Drop Link Temp Ref");

	// Remove the base reference if it still exists
	if(!(pEPD->ulEPFlags2 & EPFLAGS2_KILLED))
	{
		pEPD->ulEPFlags2 |= EPFLAGS2_KILLED;

		RELEASE_EPD(pEPD, "UNLOCK (KILLCONN - Base Ref)"); // RELEASE the EPD, releases EPLock
	}
	else
	{
		Unlock(&pEPD->EPLock);
	}

	if(pRcvBuff)
	{
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->ReturnReceiveBuffers, pSPD[%p], pRcvBuff[%p]", pEPD, pSPD, pRcvBuff);
		IDP8ServiceProvider_ReturnReceiveBuffers(pSPIntf, pRcvBuff);
	}

	// Tell user that session is over

	// If the Core previously knew about this endpoint, and we have not yet indicated disconnect to the 
	// Core, we need to do it now.
	//N.B. For hard disconnects this is always where the disconnection is indicated, since we don't have a disconnect MSG
	//store in the pCommand member which might have been picked up elsewhere
	if(fIndicateDisconnect)
	{
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		if (fDisconnectTypeTermination)
		{
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateConnectionTerminated, DPNERR_CONNECTIONLOST, Core Context[%p]", pEPD, pEPD->Context);
			pSPD->pPData->pfVtbl->IndicateConnectionTerminated(pSPD->pPData->Parent, pEPD->Context, DPNERR_CONNECTIONLOST);
		}
		else
		{
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteDisconnect, DPN_OK, Core Context[%p]", pEPD,  pEPD->pvHardDisconnectContext);
			pSPD->pPData->pfVtbl->CompleteDisconnect(pSPD->pPData->Parent, pEPD->pvHardDisconnectContext, DPN_OK);
		}
	}

	Lock(&pEPD->EPLock);
	RELEASE_EPD(pEPD, "Drop Link Temp Ref");
}

/*
**		Cancel Epd Timers
**
**			This clears all timers that an endpoint potentially creates. Called either when
**		we're dropping the link or hard disconnecting the link. Its possible a timer won't
**		by cancellable, in which case we assume it'll fire and then pick up the new endpoint
**		state (i.e. Its been terminated).
**
**		**  CALLED WITH EPD->EPLOCK HELD;  RETURNS WITH EPD->EPLOCK HELD  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CancelEpdTimers"

VOID CancelEpdTimers(PEPD pEPD)
{
	PSPD pSPD=pEPD->pSPD;
	
	if(pEPD->RetryTimer)
	{
		if(CancelProtocolTimer(pSPD, pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP RETRY)"); // SPLock not already held
		}
		pEPD->RetryTimer = 0;
	}
	if(pEPD->LinkTimer)
	{
		if(CancelProtocolTimer(pSPD, pEPD->LinkTimer, pEPD->LinkTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP LINK RETRY)"); // SPLock not already held
		}
		pEPD->LinkTimer = 0;
	}
	if(pEPD->DelayedAckTimer)
	{
		if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP DELAYEDACK)"); // SPLock not already held
		}
		pEPD->DelayedAckTimer = 0;
	}
	if(pEPD->DelayedMaskTimer)
	{
		if(CancelProtocolTimer(pSPD, pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP DELAYED MASK)"); // SPLock not already held
		}
		pEPD->DelayedMaskTimer = 0;
	}
	if(pEPD->SendTimer)
	{
		if(CancelProtocolTimer(pSPD, pEPD->SendTimer, pEPD->SendTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP SENDTIMER)"); // SPLock not already held
			pEPD->SendTimer = 0;
		}
	}
	if(pEPD->BGTimer)
	{
		if(CancelProtocolTimer(pSPD, pEPD->BGTimer, pEPD->BGTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP BG TIMER)"); // SPLock not already held
			pEPD->BGTimer = 0;
		}
	}
}

/*
**		Abort Recvs on Connection
**
**			This messages we've queued on a connection (misordered, partial, complete, whatever)
**		Called when we're dropping the link or when we're hard disconnecting it
**
**		**  CALLED WITH EPD->EPLOCK HELD;  RETURNS WITH EPD->EPLOCK HELD  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "AbortRecvsOnConnection"

SPRECEIVEDBUFFER * AbortRecvsOnConnection(PEPD pEPD)
{
	PRCD				pRCD, pNext;
	CBilink *				pLink;
	SPRECEIVEDBUFFER *	pRcvBuff=NULL;

	while((pRCD = pEPD->pNewMessage) != NULL)
	{
		ASSERT_RCD(pRCD);

		pEPD->pNewMessage = pRCD->pMsgLink;
		if(pRCD->pRcvBuff == NULL)
		{
			ASSERT(pRCD->ulRFlags & (RFLAGS_FRAME_INDICATED_NONSEQ | RFLAGS_FRAME_LOST));
		}

		RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);

		RELEASE_RCD(pRCD);
	}

	while(!pEPD->blOddFrameList.IsEmpty())
	{
		pLink = pEPD->blOddFrameList.GetNext();
		pRCD = CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage);
		ASSERT_RCD(pRCD);

		pLink->RemoveFromList();

		if(pRCD->pRcvBuff == NULL)
		{
			ASSERT(pRCD->ulRFlags & (RFLAGS_FRAME_INDICATED_NONSEQ | RFLAGS_FRAME_LOST));
		}

		RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);

		RELEASE_RCD(pRCD);
	}

	while(!pEPD->blCompleteList.IsEmpty())
	{
		pLink = pEPD->blCompleteList.GetNext();
		pRCD = CONTAINING_OBJECT(pLink, RCD, blCompleteLinkage);
		ASSERT_RCD(pRCD);

		pLink->RemoveFromList();
		
		ASSERT(pEPD->uiCompleteMsgCount > 0);
		pEPD->uiCompleteMsgCount--;
		
		while(pRCD != NULL)
		{
			ASSERT_RCD(pRCD);
			pNext = pRCD->pMsgLink;
			
			RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);
			
			RELEASE_RCD(pRCD);
			pRCD = pNext;
		}
	}
	
	return pRcvBuff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\dnproti.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnproti.h
 *  Content:    DirectPlay Protocol master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *	06/06/01	minara	include comutil.h for COM usage
 *
 ***************************************************************************/

#ifndef __DNPROTI_H__
#define __DNPROTI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <mmsystem.h>
#include <stdlib.h> // for srand/rand
#include <stdio.h> // for sprintf
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpsp8.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "classbilink.h"
#include "fixedpool.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "comutil.h"

// 
// Protocol private includes
//
#include "frames.h"
#include "dnprot.h"
#include "dnpextern.h"
#include "internal.h"
#include "mytimer.h"

#endif // __DNPROTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\dnpextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnpextern.h
 *  Content:    This header exposes protocol entry points to the rest of Direct Network
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/1998	ejs		Created
 *  07/01/2000	masonb	Assumed Ownership
 *
 ***************************************************************************/


#ifdef	__cplusplus
extern	"C" {
#endif	// __cplusplus

//	FOLLOWING FLAGS GO INTO PUBLIC HEADER FILE

#ifndef DPNBUILD_NOSPUI
#define	DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING			0x00000001
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_ONLYONEADAPTER
#define	DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS		0x00000002	// there will be more adapters for this connect operation
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOMULTICAST
#define	DN_CONNECTFLAGS_MULTICAST_SEND					0x00000004	// Multicast send connect operation
#define	DN_CONNECTFLAGS_MULTICAST_RECEIVE				0x00000008	// Multicast receive connect operation
#endif	// DPNBUILD_NOMULTICAST
#define	DN_CONNECTFLAGS_SESSIONDATA					0x00000010	// connect operation has session data available

#ifndef DPNBUILD_NOSPUI
#define	DN_LISTENFLAGS_OKTOQUERYFORADDRESSING		0x00000001
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_NOMULTICAST
#define	DN_LISTENFLAGS_MULTICAST						0x00000002	// Multicast listen operation
#define	DN_LISTENFLAGS_ALLOWUNKNOWNSENDERS			0x00000004	// listen operation should allow data from unknown senders
#endif // ! DPNBUILD_NOMULTICAST
#define	DN_LISTENFLAGS_SESSIONDATA						0x00000008	// listen operation has session data available
#define	DN_LISTENFLAGS_DISALLOWENUMS					0x00000010	// don't allow enums to come in on the listen
#define	DN_LISTENFLAGS_FASTSIGNED						0x00000020	// create all incoming links as fast signed
#define	DN_LISTENFLAGS_FULLSIGNED						0x00000040	// create all incoming links as full signed

#ifndef DPNBUILD_NOSPUI
#define	DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING		0x00000001
#endif // ! DPNBUILD_NOSPUI
#define	DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK			0x00000002
#ifndef DPNBUILD_ONLYONEADAPTER
#define	DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS	0x00000004	// there will be more adapters for this enum operation
#endif // ! DPNBUILD_ONLYONEADAPTER
#define	DN_ENUMQUERYFLAGS_SESSIONDATA				0x00000008	// enum query operation has session data available



#define	DN_SENDFLAGS_RELIABLE			0x00000001			// Deliver Reliably
#define	DN_SENDFLAGS_NON_SEQUENTIAL		0x00000002			// Deliver Upon Arrival
#define	DN_SENDFLAGS_HIGH_PRIORITY		0x00000004
#define	DN_SENDFLAGS_LOW_PRIORITY		0x00000008
#define	DN_SENDFLAGS_SET_USER_FLAG		0x00000040			// Protocol will deliver these two...
#define	DN_SENDFLAGS_SET_USER_FLAG_TWO	0x00000080			// ...flags to receiver
#define	DN_SENDFLAGS_COALESCE			0x00000100			// send is coalescable

#define	DN_UPDATELISTEN_HOSTMIGRATE		0x00000001
#define	DN_UPDATELISTEN_ALLOWENUMS		0x00000002
#define	DN_UPDATELISTEN_DISALLOWENUMS	0x00000004

#define	DN_DISCONNECTFLAGS_IMMEDIATE	0x00000001

//	END OF PUBLIC FLAGS

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

struct IDirectPlay8ThreadPoolWork;

//
// structure used to pass enum data from the protocol to DPlay
//
typedef	struct	_PROTOCOL_ENUM_DATA
{
	IDirectPlay8Address	*pSenderAddress;		//
	IDirectPlay8Address	*pDeviceAddress;		//
	BUFFERDESC			ReceivedData;			//
	HANDLE				hEnumQuery;				// handle of this query, returned in enum response

} PROTOCOL_ENUM_DATA;


typedef	struct	_PROTOCOL_ENUM_RESPONSE_DATA
{
	IDirectPlay8Address	*pSenderAddress;
	IDirectPlay8Address	*pDeviceAddress;
	BUFFERDESC			ReceivedData;
	DWORD				dwRoundTripTime;

} PROTOCOL_ENUM_RESPONSE_DATA;

// Service Provider interface
typedef struct IDP8ServiceProvider       IDP8ServiceProvider;
// Service Provider info data strucure
typedef	struct	_SPGETADDRESSINFODATA SPGETADDRESSINFODATA, *PSPGETADDRESSINFODATA;
// Service Provider event type
typedef enum _SP_EVENT_TYPE SP_EVENT_TYPE;


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constants that define limits for parameters passed to protocol
// 
/////////////////////////////////////////////////////////////////////////////////////////////////


#define MAX_SEND_RETRIES_TO_DROP_LINK		256			//maximum number of send retries user can request
														//when setting via SetCaps
#define MAX_SEND_RETRY_INTERVAL_LIMIT		60000		//maximum limit user can request on the interval
														//betwen send retries when setting via SetCaps
#define MIN_SEND_RETRY_INTERVAL_LIMIT		10			//minimum limit user can set on  the interval
														//betwen send retries when setting via SetCaps
#define MAX_HARD_DISCONNECT_SENDS			50			//Maximum number of hard disconnect frames that can be sent
#define MIN_HARD_DISCONNECT_SENDS			2			//Minimum number of hard disconnect frames that can be sent
#define MAX_HARD_DISCONNECT_PERIOD			5000		//Maximum period between hard disconnect sends
#define MIN_HARD_DISCONNECT_PERIOD			10			//Minimum period between hard disconnect sends


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// The following are functions that the Core can call in the Protocol
// 
/////////////////////////////////////////////////////////////////////////////////////////////////

// These are called at module load and unload time so that the Protocol can create and destroy its pools
extern BOOL  DNPPoolsInit(HANDLE hModule);
extern VOID  DNPPoolsDeinit();

// These are called to create or destroy a Protocol object
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
extern HRESULT DNPProtocolCreate(const XDP8CREATE_PARAMS * const pDP8CreateParams, VOID** ppvProtocol);
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
extern HRESULT DNPProtocolCreate(VOID** ppvProtocol);
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
extern VOID DNPProtocolDestroy(HANDLE hProtocolData);

// These are called to initialize or shutdown a Protocol object
extern HRESULT DNPProtocolInitialize(HANDLE hProtocolData, PVOID pCoreContext, PDN_PROTOCOL_INTERFACE_VTBL pVtbl, IDirectPlay8ThreadPoolWork* pDPThreadPoolWork, BOOL bAssumeLANConnections);
extern HRESULT DNPProtocolShutdown(HANDLE hProtocolData);

// These are called to add or remove a service provider for use with a Protocol object
extern HRESULT DNPAddServiceProvider(HANDLE hProtocolData, IDP8ServiceProvider* pISP, HANDLE* phSPContext, DWORD dwFlags);
extern HRESULT DNPRemoveServiceProvider(HANDLE hProtocolData, HANDLE hSPContext);

// Connect establish and teardown functions
extern HRESULT DNPConnect(HANDLE hProtocolData, IDirectPlay8Address* paLocal, IDirectPlay8Address* paRemote, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, VOID* pvSessionData, DWORD dwSessionDataSize, HANDLE* phConnectHandle);
extern HRESULT DNPListen(HANDLE hProtocolData, IDirectPlay8Address* paTarget, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, VOID* pvSessionData, DWORD dwSessionDataSize, HANDLE* phListenHandle);
extern HRESULT DNPDisconnectEndPoint(HANDLE hProtocolData, HANDLE hEndPoint, VOID* pvContext, HANDLE* phDisconnect, const DWORD dwFlags);

// Data sending functions
extern HRESULT DNPSendData(HANDLE hProtocolData, HANDLE hDestination, UINT uiBufferCount, PBUFFERDESC pBufferDesc, UINT uiTimeout, ULONG ulFlags, VOID* pvContext,	HANDLE* phSendHandle);

// Get information about an endpoint
extern HRESULT DNPCrackEndPointDescriptor(HANDLE hProtocolData, HANDLE hEndPoint, PSPGETADDRESSINFODATA pSPData);
#ifndef DPNBUILD_NOMULTICAST
HRESULT DNPGetEndPointContextFromAddress(HANDLE hProtocolData, HANDLE hSPHandle, IDirectPlay8Address* paEndpointAddress, IDirectPlay8Address* paDeviceAddress, VOID** ppvContext);
#endif // ! DPNBUILD_NOMULTICAST

// Update the SP
extern HRESULT DNPUpdateListen(HANDLE hProtocolData,HANDLE hEndPt,DWORD dwFlags);

// Cancel a pending operation
extern HRESULT DNPCancelCommand(HANDLE hProtocolData, HANDLE hCommand);

// Enumeration functions
extern HRESULT DNPEnumQuery(HANDLE hProtocolData, IDirectPlay8Address* paHostAddress, IDirectPlay8Address* paDeviceAddress, HANDLE hSPHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwRetryCount, DWORD dwRetryInterval, DWORD dwTimeout, DWORD dwFlags, VOID* pvUserContext, VOID* pvSessionData, DWORD dwSessionDataSize, HANDLE* phEnumHandle);
extern HRESULT DNPEnumRespond(HANDLE hProtocolData, HANDLE hSPHandle, HANDLE hQueryHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwFlags, VOID* pvUserContext, HANDLE* phEnumHandle);

// Miscellaneous functions
extern HRESULT DNPReleaseReceiveBuffer(HANDLE hProtocolData, HANDLE hBuffer);
extern HRESULT DNPGetListenAddressInfo(HANDLE hProtocolData, HANDLE hListen, PSPGETADDRESSINFODATA pSPData);
extern HRESULT DNPGetEPCaps(HANDLE hProtocolData, HANDLE hEndpoint, DPN_CONNECTION_INFO* pBuffer);
extern HRESULT DNPSetProtocolCaps(HANDLE hProtocolData, DPN_CAPS* pCaps);
extern HRESULT DNPGetProtocolCaps(HANDLE hProtocolData, DPN_CAPS* pCaps);

// Function for debugging
#ifndef DPNBUILD_NOPROTOCOLTESTITF
extern HRESULT DNPDebug(HANDLE hProtocolData, UINT uiOpCode, HANDLE hEndPoint, VOID* pvData);

// This is a function that can be passed to Debug(PROTDEBUG_SET_ASSERTFUNC) that will be called when an assert 
// would occur.  The function should throw/catch if it wants to terminate upon the assert.
typedef VOID (*PFNASSERTFUNC)(PSTR psz);

// This is a function that can be passed to Debug(PROTDEBUG_SET_MEMALLOCFUNC) that will be called when memory 
// allocation occurs.  The function should return FALSE if it wants to fail the allocation.
typedef BOOL (*PFNMEMALLOCFUNC)(ULONG ulAllocID);

// Debug opcodes
#define PROTDEBUG_FREEZELINK 			1
#define PROTDEBUG_TOGGLE_KEEPALIVE 		2
#define PROTDEBUG_TOGGLE_ACKS 			3
#define PROTDEBUG_SET_ASSERTFUNC		4
#define PROTDEBUG_SET_LINK_PARMS		5
#define PROTDEBUG_TOGGLE_LINKSTATE		6
#define PROTDEBUG_TOGGLE_NO_RETRIES	7
#define PROTDEBUG_SET_MEMALLOCFUNC		8
#define PROTDEBUG_TOGGLE_TIMER_FAILURE	9

// Memory Allocation IDs
#define MEMID_SPD					1
#define MEMID_PPD					2
#define MEMID_HUGEBUF				3
#define MEMID_COPYFMD_FMD			4
#define MEMID_SENDCMD_FMD			5
#define MEMID_CHKPT					6
#define MEMID_ACK_FMD				7
#define MEMID_KEEPALIVE_MSD			8
#define MEMID_KEEPALIVE_FMD			9
#define MEMID_DISCONNECT_MSD		10
#define MEMID_DISCONNECT_FMD		11
#define MEMID_CONNECT_MSD			12
#define MEMID_LISTEN_MSD			13
#define MEMID_EPD					14
#define MEMID_ENUMQUERY_MSD			15
#define MEMID_ENUMRESP_MSD			16
#define MEMID_RCD					17
#define MEMID_SMALLBUFF				18
#define MEMID_MEDBUFF				19
#define MEMID_BIGBUFF				20
#define MEMID_CANCEL_RCD			21
#define MEMID_SEND_MSD				22
#define MEMID_SEND_FMD				23
#define MEMID_COALESCE_FMD          24

#define MEMID_MCAST_DISCONNECT_MSD	100
#define MEMID_MCAST_SEND_MSD		101
#define MEMID_MCAST_SEND_FMD		102


#endif // !DPNBUILD_NOPROTOCOLTESTITF


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// The following are functions that the Protocol calls in the Core
// 
/////////////////////////////////////////////////////////////////////////////////////////////////

typedef HRESULT (*PFN_PINT_INDICATE_ENUM_QUERY)(void *const pvUserContext, void *const pvEndPtContext, const HANDLE hCommand, void *const pvEnumQueryData, const DWORD dwEnumQueryDataSize);
typedef HRESULT (*PFN_PINT_INDICATE_ENUM_RESPONSE)(void *const pvUserContext,const HANDLE hCommand,void *const pvCommandContext,void *const pvEnumResponseData,const DWORD dwEnumResponseDataSize);
typedef HRESULT (*PFN_PINT_INDICATE_CONNECT)(void *const pvUserContext,void *const pvListenContext,const HANDLE hEndPt,void **const ppvEndPtContext);
typedef HRESULT (*PFN_PINT_INDICATE_DISCONNECT)(void *const pvUserContext,void *const pvEndPtContext);
typedef HRESULT (*PFN_PINT_INDICATE_CONNECTION_TERMINATED)(void *const pvUserContext,void *const pvEndPtContext,const HRESULT hr);
typedef HRESULT (*PFN_PINT_INDICATE_RECEIVE)(void *const pvUserContext,void *const pvEndPtContext,void *const pvData,const DWORD dwDataSize,const HANDLE hBuffer,const DWORD dwFlags);
typedef HRESULT (*PFN_PINT_COMPLETE_LISTEN)(void *const pvUserContext,void **const ppvCommandContext,const HRESULT hr,const HANDLE hCommand);
typedef HRESULT (*PFN_PINT_COMPLETE_LISTEN_TERMINATE)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_ENUM_QUERY)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_ENUM_RESPONSE)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_CONNECT)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hr,const HANDLE hEndPt,void **const ppvEndPtContext);
typedef HRESULT (*PFN_PINT_COMPLETE_DISCONNECT)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_SEND)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hr,DWORD dwFirstFrameRTT,DWORD dwFirstFrameRetryCount);
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_CONNECT)(void *const pvUserContext, void *const pvCommandContext, const HRESULT hr, IDirectPlay8Address *const pHostAddress, IDirectPlay8Address *const pDeviceAddress );
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_ENUM)(void *const pvUserContext, void *const pvCommandContext, const HRESULT hr, IDirectPlay8Address *const pHostAddress, IDirectPlay8Address *const pDeviceAddress );
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_LISTEN)(void *const pvUserContext, void *const pvCommandContext, const HRESULT hr, IDirectPlay8Address *const pDeviceAddress );
#ifndef DPNBUILD_NOMULTICAST
typedef HRESULT (*PFN_PINT_INDICATE_RECEIVE_UNKNOWN_SENDER)(void *const pvUserContext,void *const pvListenCommandContext,IDirectPlay8Address *const pSenderAddress,void *const pvData,const DWORD dwDataSize,const HANDLE hBuffer);
typedef HRESULT (*PFN_PINT_COMPLETE_JOIN)(void *const pvUserContext,void *const pvCommandContext,const HRESULT hrProt,const HANDLE hEndPt,void **const ppvEndPtContext);
#endif	// DPNBUILD_NOMULTICAST

struct _DN_PROTOCOL_INTERFACE_VTBL
{
	PFN_PINT_INDICATE_ENUM_QUERY			IndicateEnumQuery;
	PFN_PINT_INDICATE_ENUM_RESPONSE			IndicateEnumResponse;
	PFN_PINT_INDICATE_CONNECT				IndicateConnect;
	PFN_PINT_INDICATE_DISCONNECT			IndicateDisconnect;
	PFN_PINT_INDICATE_CONNECTION_TERMINATED	IndicateConnectionTerminated;
	PFN_PINT_INDICATE_RECEIVE				IndicateReceive;
	PFN_PINT_COMPLETE_LISTEN				CompleteListen;
	PFN_PINT_COMPLETE_LISTEN_TERMINATE		CompleteListenTerminate;
	PFN_PINT_COMPLETE_ENUM_QUERY			CompleteEnumQuery;
	PFN_PINT_COMPLETE_ENUM_RESPONSE			CompleteEnumResponse;
	PFN_PINT_COMPLETE_CONNECT				CompleteConnect;
	PFN_PINT_COMPLETE_DISCONNECT			CompleteDisconnect;
	PFN_PINT_COMPLETE_SEND					CompleteSend;
	PFN_PINT_ADDRESS_INFO_CONNECT			AddressInfoConnect;
	PFN_PINT_ADDRESS_INFO_ENUM				AddressInfoEnum;
	PFN_PINT_ADDRESS_INFO_LISTEN			AddressInfoListen;
#ifndef DPNBUILD_NOMULTICAST
	PFN_PINT_INDICATE_RECEIVE_UNKNOWN_SENDER	IndicateReceiveUnknownSender;
	PFN_PINT_COMPLETE_JOIN					CompleteMulticastConnect;
#endif	// DPNBUILD_NOMULTICAST
};

#ifdef	__cplusplus
}
#endif	// __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\endpt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		EndPt.cpp
 *  Content:	This file contains EndPoint management routines.
 *				An End Point is a DirectNet instance that we know about and may communicate
 *				with.  An End Point Descriptor (EPD) tracks each known End Point and was mapped
 *				onto an hEndPoint by a hash table. Now, the SP maintains the mapping and hands
 *				us our EPD address as a context with each indication ReceiveEvent.
 *
 *				In addition to EndPoint creation and destruction,  this file contains routines
 *				which handle link tuning.  This is described in detailed comments below.
 *
 *  History:
 *   Date			By			Reason
 *   ====		==			======
 *  11/06/98		ejs			Created
 *  07/01/2000  	masonb  		Assumed Ownership
 *  13/06/2002  	simonpow	MANBUG #56703 Capped burst gap growth
 *
 ****************************************************************************/

#include "dnproti.h"


VOID	RunAdaptiveAlg(PEPD, DWORD);
VOID	ThrottleBack(PEPD, DWORD);

/*
**		Crack EndPoint Descriptor
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPCrackEndPointDescriptor"

HRESULT 
DNPCrackEndPointDescriptor(HANDLE hProtocolData, HANDLE hEndPoint, PSPGETADDRESSINFODATA pSPData)
{
	ProtocolData*	pPData;
	PEPD			pEPD;
	PSPD			pSPD;
	HRESULT			hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hEndPoint[%p], pSPData[%p]", hProtocolData, hEndPoint, pSPData);
	
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pEPD = (PEPD) hEndPoint;
	ASSERT_EPD(pEPD);

	LOCK_EPD(pEPD, "LOCK (Crack EPD)");

	Lock(&pEPD->EPLock);
	if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED)
	{
		pSPD = pEPD->pSPD;
		ASSERT_SPD(pSPD);

		pSPData->hEndpoint = pEPD->hEndPt;
		
		Unlock(&pEPD->EPLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->GetAddressInfo, pSPD[%p]", pEPD, pSPD);
		hr = IDP8ServiceProvider_GetAddressInfo(pSPD->IISPIntf, pSPData);

		Lock(&pEPD->EPLock);
	}
	else
	{
		hr = DPNERR_INVALIDENDPOINT;
	}


	RELEASE_EPD(pEPD, "UNLOCK (Crack EPD)"); // releases EPLock

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x], pEPD[%p]", hr, pEPD);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}


#ifndef DPNBUILD_NOMULTICAST
/*
**		Get an EndPoint context from an Address
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetEndPointContextFromAddress"

HRESULT 
DNPGetEndPointContextFromAddress(HANDLE hProtocolData, HANDLE hSPHandle, IDirectPlay8Address* paEndpointAddress, IDirectPlay8Address* paDeviceAddress, VOID** ppvContext)
{
	ProtocolData*	pPData;
	PSPD			pSPD;
	PEPD			pEPD;
	HRESULT			hr;
	SPGETENDPOINTBYADDRESSDATA	spdata;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hSPHandle[%p], paEndpointAddress[%p], paDeviceAddress[%p], ppvContext[%p]", hProtocolData, hSPHandle, paEndpointAddress, paDeviceAddress, ppvContext);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pSPD = (PSPD)hSPHandle;
	ASSERT_SPD(pSPD);

	//
	//	Set up to get endpoint
	//
	memset(&spdata,0,sizeof(SPGETENDPOINTBYADDRESSDATA));
	spdata.pAddressHost = paEndpointAddress;
	spdata.pAddressDeviceInfo = paDeviceAddress;

	//
	//	Get endpoint from SP
	//
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->GetEndpointByAddress, pSPD[%p]", pSPD);
	hr = IDP8ServiceProvider_GetEndpointByAddress(pSPD->IISPIntf, &spdata);

	//
	//	Get context from endpoint
	if (hr == DPN_OK)
	{
		pEPD = (PEPD)spdata.pvEndpointContext;
		ASSERT_EPD(pEPD);

		Lock(&pEPD->EPLock);
		*ppvContext = pEPD->Context;
		Unlock(&pEPD->EPLock);
	}

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x]", hr);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}
#endif // ! DPNBUILD_NOMULTICAST


/*
**		INTERNAL - EndPoint management functions
*/

/*
**		New End Point
**
**		Everytime a packet is indicated with an address that we dont recognize we will allocate
**	an EPD for it and add it to our tables.  It is a higher layer's responsibility to tell
**	us when it no longer wants to talk to the EP so that we can clear it out of our
**	(and the SP's) table.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "NewEndPoint"

PEPD NewEndPoint(PSPD pSPD, HANDLE hEP)
{
	PEPD	pEPD;

	if((pEPD = (PEPD)POOLALLOC(MEMID_EPD, &EPDPool)) == NULL)
	{	
		DPFX(DPFPREP,0, "Failed to allocate new EPD");
		return NULL;
	}

	ASSERT(hEP != INVALID_HANDLE_VALUE);

	pEPD->hEndPt = hEP;								// Record ID in structure
	pEPD->pSPD = pSPD;

	pEPD->bNextMsgID = 0;
	
	pEPD->uiRTT = 0;
	pEPD->uiBytesAcked = 0;

	pEPD->ullCurrentLocalSecret=0;
	pEPD->ullCurrentRemoteSecret=0;
	pEPD->ullOldLocalSecret=0;
	pEPD->ullOldRemoteSecret=0;
	pEPD->ullLocalSecretModifier=0;
	pEPD->ullRemoteSecretModifier=0;
	pEPD->byLocalSecretModifierSeqNum=0;
	pEPD->byRemoteSecretModifierSeqNum=0;
	
	pEPD->uiQueuedMessageCount = 0;
#ifdef DBG
	pEPD->bLastDataSeq = 0xFF;
#endif // DBG

	// We track a byte-window and a frame-window separately. 
	// We start a byte window that is set to half the maximum frame size * the frame window
													
	pEPD->uiWindowF = pSPD->pPData->dwInitialFrameWindowSize;
	pEPD->uiWindowBIndex = pSPD->pPData->dwInitialFrameWindowSize/2;
	pEPD->uiWindowB = pEPD->uiWindowBIndex*pSPD->uiFrameLength;	
	pEPD->uiUnackedFrames = 0;						// outstanding frame count
	pEPD->uiUnackedBytes = 0;						// outstanding byte count
	pEPD->uiBurstGap = 0;							// For now assume we dont need a burst gap
	pEPD->dwSessID = 0;

	// ReceiveComplete flag prevents received data from being indicated to core until after new connection is indicated
	// Initialize state
	pEPD->ulEPFlags = EPFLAGS_END_POINT_IN_USE | EPFLAGS_STATE_DORMANT | EPFLAGS_IN_RECEIVE_COMPLETE; // Initialize state
	pEPD->ulEPFlags2 = 0;

	ASSERT(pEPD->lRefCnt == 0);					// WE NOW HAVE A -1 BASED REFCNT INSTEAD OF ZERO BASED (FOR EPDs)

	pEPD->SendTimer = 0;							// Timer for next send-burst opportunity
	pEPD->RetryTimer = 0;							// window to receive Ack
	pEPD->LinkTimer = 0;
	pEPD->DelayedAckTimer = 0;						// wait for piggyback opportunity before sending Ack
	pEPD->DelayedMaskTimer = 0;						// wait for piggyback opportunity before sending Mask frame
	pEPD->BGTimer = 0;								// Periodic background timer
	pEPD->uiCompleteMsgCount = 0;

	LOCK_EPD(pEPD, "SP reference"); // We will not remove this reference until the SP tells us to go away.

	Lock(&pSPD->SPLock);
	pEPD->blActiveLinkage.InsertAfter( &pSPD->blEPDActiveList); // Place this guy in active list
	Unlock(&pSPD->SPLock);
	
	return pEPD;
}

/*
**		Initial Link Parameters
**
**		we have kept a checkpoint structure matching everying frame we sent in the Connect
**	handshake so that we can match a response to a specific frame or retry.  This allows us
**	to measure a single sample Round Trip Time (RTT),  which we will use below to generate
**	initial values for our link-state variables.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "InitLinkParameters"

VOID InitLinkParameters(PEPD pEPD, UINT uiRTT, DWORD tNow)
{
	PSPD	pSPD = pEPD->pSPD;
	DWORD	dwTimerInterval;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(uiRTT == 0)
	{
		uiRTT = 1;
	}
		
	pEPD->uiRTT = uiRTT;										// we know the base RTT
	pEPD->fpRTT = TO_FP(uiRTT);									// 16.16 fixed point version
	pEPD->uiDropCount = 0;
	pEPD->dwDropBitMask = 0;

	pEPD->uiThrottleEvents = 0;									// Count times we throttle-back for all reasons
#ifdef DBG
	pEPD->uiTotalThrottleEvents = 0;
#endif // DBG

	pEPD->uiBurstGap = 0;	// For now assume we dont need a burst gap

	pEPD->uiMsgSentHigh = 0;
	pEPD->uiMsgSentNorm = 0;
	pEPD->uiMsgSentLow = 0;
	pEPD->uiMsgTOHigh = 0;
	pEPD->uiMsgTONorm = 0;
	pEPD->uiMsgTOLow = 0;
	
	pEPD->uiMessagesReceived = 0;

	pEPD->uiGuaranteedFramesSent = 0;
	pEPD->uiGuaranteedBytesSent = 0;
	pEPD->uiDatagramFramesSent = 0;
	pEPD->uiDatagramBytesSent = 0;
	
	pEPD->uiGuaranteedFramesReceived = 0;
	pEPD->uiGuaranteedBytesReceived = 0;
	pEPD->uiDatagramFramesReceived = 0;
	pEPD->uiDatagramBytesReceived = 0;
	
	pEPD->uiGuaranteedFramesDropped = 0;
	pEPD->uiGuaranteedBytesDropped = 0;
	pEPD->uiDatagramFramesDropped = 0;
	pEPD->uiDatagramBytesDropped = 0;

	pEPD->uiGoodBurstGap = 0;									// No Known Good Gap!
	pEPD->uiGoodRTT = 60000; // We need this to initially be artificially high
	pEPD->uiGoodWindowF = (pEPD->pSPD->pPData->dwInitialFrameWindowSize*3)/4;
	pEPD->uiGoodWindowBI = pEPD->uiGoodWindowF;
	pEPD->iBurstCredit = 0;
	pEPD->tLastDelta = tNow;
	pEPD->uiWindowFilled = 0;
	
	pEPD->tLastThruPutSample = tNow;

	pEPD->uiLastBytesAcked = 0;

	pEPD->uiPeriodAcksBytes = 0;
	pEPD->uiPeriodXmitTime = 0;

	pEPD->uiPeriodRateB = 0;
	pEPD->uiPeakRateB = 0;
	pEPD->uiLastRateB = 0;
	
	pEPD->ulReceiveMask = 0;
	pEPD->ulReceiveMask2 = 0;
	pEPD->tReceiveMaskDelta = 0;
	
	pEPD->ulSendMask = 0;
	pEPD->ulSendMask2 = 0;
	
	pEPD->Context = NULL;
	DPFX(DPFPREP,7, "CONNECTION ESTABLISHED pEPD = 0x%p RTT = %dms, BurstGap=%dms", pEPD, pEPD->uiRTT, pEPD->uiBurstGap);

	// We set the IdleThreshhold very low to generate a little bit of traffic for initial link tuning in case the
	// application doesnt do any right away

//	pEPD->ulEPFlags |= EPFLAGS_USE_POLL_DELAY;					// always assume balanced traffic at start-up
	
	pEPD->uiAdaptAlgCount = 4;									// start running adpt alg fairly often
	
	// Calc a retry timeout value based upon the measured RTT (2.5 * RTT) + MAX_DELAY
	pEPD->uiRetryTimeout = ((pEPD->uiRTT + (pEPD->uiRTT >> 2)) * 2) + DELAYED_ACK_TIMEOUT;

	// don't want to get more aggressive because we drop a frame.
	if(pEPD->uiRetryTimeout < pEPD->uiBurstGap)
	{
		pEPD->uiRetryTimeout = pEPD->uiBurstGap;	
	}
	

	pEPD->uiUserFrameLength = pEPD->pSPD->uiUserFrameLength;
	
	if(pEPD->BGTimer == 0)
	{
		if (pEPD->pSPD->pPData->tIdleThreshhold > ENDPOINT_BACKGROUND_INTERVAL)
		{
			dwTimerInterval = ENDPOINT_BACKGROUND_INTERVAL;
		}
		else
		{
			dwTimerInterval = pEPD->pSPD->pPData->tIdleThreshhold;
		}

		DPFX(DPFPREP,7, "(%p) Setting Endpoint Background Timer for %u ms", pEPD, dwTimerInterval);
		ScheduleProtocolTimer(pSPD, dwTimerInterval, 1000, EndPointBackgroundProcess, 
												(PVOID) pEPD, &pEPD->BGTimer, &pEPD->BGTimerUnique);
		LOCK_EPD(pEPD, "LOCK (BG Timer)");												// create reference for this timer
	}
}


/****************
*
*			Link Tuning
*
*		Here are current ideas about link tuning.  Idea is to track Round Trip Time of key-frames and throttle
*	based upon changes in this measured RTT when possible.  This would benefit us in determining link saturation
*	before packet loss occurs, instead of waiting for the inevitable packet loss before throttling back.
*
*		On high-speed media,  the average RTT is small compared to the standard deviations making it hard to
*	predict anything useful from them.  In these cases,  we must look at packet drops.  Except for one exception:
*	We will look for large spikes in RTT and we will respond to these with an immediate, temporary throttle back.
*	This will allow a bottle-neck to clear hopefully without packet-loss.  So far,  I have not been able to verfify
*	any benefit from this behavior on reliable links.  It is more likely to be beneficial with datagram traffic
*	where send windows do not limit write-ahead.
*
*		I would like to take a measurement of the through-put acheived compared to the transmission rate,  but I
*	havent yet come up with a good way to measure this.  What I do calculate is packet acknowledgement rate,  which
*	can be calculated without any additional input from the remote side.  We will store AckRates acheived at the
*	previous transmission rate,  so we can look for improvements in Acks as we increase Transmissions.  When we
*	no longer detect AckRate improvements then we assume we have plateaued and we stop trying to increase the rate.
*
*	TRANSMISSION RATE
*
*		Transmission rate is controlled by two distinct parameters: Insertion Rate and Window Size.  Where a
*	conventional protocol would dump a window full of packets onto the wire in one burst,  we would like to
*	spread the packet insertions out over the full RTT so that the window never completely fills and hence
*	blocks the link from transmitting.  This has a wide array of potential benefits:  Causes less congestions
*	throughout the network path; Allows more balanced access to the wire to all Endpoints (especially on
*	slower media); Allows MUCH more accurate measurements to be made of trasmission times when packets
*	spend less time enqueued locally;  Allows retry timers to be set much lower giving us quicker error
*	recovery (because there is less queue time fudged into the timer);  Allows recovery to be made more
*	quickly when we don't have a lot of data enqueued in SP (both our own data and other Endpoint's data).
*	...And I am sure there are more.
*
*		So,  we would like to trickle out packets just fast enough to fill the window as the next ACK is received.
*	We will grow the window fairly liberally and let the burst rate increase more cautiously.
*	
*		On high-speed media the insertion time becomes fairly small (near zero) and we are less likely to queue
*	up large quantities of data.  Therefore we may allow insertion rate to go max and use the window alone to
*	control flow. I will experiment with this more.
*
******************/

#define		RTT_SLOW_WEIGHT					8					// fpRTT gain = 1/8
#define		THROTTLE_EVENT_THRESHOLD		20

/*
**		Update Endpoint
**
**		We will let the sliding window control the flow
**	and increase the window as long as through-put continues to increase and frames continue to get delivered without
**	excessive droppage.
**	
**		We still calculate RTT for the purpose of determining RetryTimer values.  For cases with large RTTs we may still
**	implement an inter-packet gap,  but we will try to make it an aggressive gap (conservatively small) because we would
**	rather feed the pipe too quickly than artificially add latency by letting the pipe go idle with data ready to be sent.
**
**		** CALLED WITH EPD STATELOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateEndPoint"

VOID UpdateEndPoint(PEPD pEPD, UINT uiRTT, DWORD tNow)
{
	UINT	fpRTT;
	INT		fpDiff;
	
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Don't allow zero RTTs
	if(uiRTT == 0)
	{												
		uiRTT = 1;
	}
	
	// Filter out HUGE samples,  they often popup during debug sessions
	else if(uiRTT > (pEPD->uiRTT * 128))
	{
		DPFX(DPFPREP,7, "Tossing huge sample (%dms, base %dms)", uiRTT, pEPD->uiRTT);
		return;
	}

	// Perform next iteration of math on new RTT sample in 16.16 fixed point

	fpRTT = TO_FP(uiRTT);										// Fixed point sample
	fpDiff = fpRTT - pEPD->fpRTT;								// Current Delta (signed)

	pEPD->fpRTT = pEPD->fpRTT + (fpDiff / RTT_SLOW_WEIGHT);		// .0625 weighted avg
	pEPD->uiRTT = FP_INT(pEPD->fpRTT);							// Store integer portion

	// Calc a retry timeout value based upon the measured RTT (2.5 * RTT) + MAX_DELAY
	pEPD->uiRetryTimeout = ((pEPD->uiRTT + (pEPD->uiRTT >> 2)) * 2) + DELAYED_ACK_TIMEOUT;

	// don't want to get more aggressive because we drop a frame.
	if(pEPD->uiRetryTimeout < pEPD->uiBurstGap)
	{
		pEPD->uiRetryTimeout = pEPD->uiBurstGap;	
	}
	
	DPFX(DPFPREP,7, "(%p) RTT SAMPLE: RTT = %d, Avg = %d <<<<", pEPD, uiRTT, FP_INT(pEPD->fpRTT));

	// If throttle is engaged we will see if we can release it yet
	
	if(pEPD->ulEPFlags & EPFLAGS_THROTTLED_BACK)
	{
		if((tNow - pEPD->tThrottleTime) > (pEPD->uiRTT * 8)) 
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_THROTTLED_BACK);
			pEPD->uiDropCount = 0;
			pEPD->dwDropBitMask = 0;
			pEPD->uiBurstGap = pEPD->uiRestoreBurstGap;
			pEPD->uiWindowF =  pEPD->uiRestoreWindowF;
			pEPD->uiWindowBIndex = pEPD->uiRestoreWindowBI;
			pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;

			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "** (%p) RECOVER FROM THROTTLE EVENT: Window(F:%d,B:%d); Gap=%d", pEPD, pEPD->uiWindowF, pEPD->uiWindowBIndex, pEPD->uiBurstGap);
			pEPD->tLastDelta = tNow;							// Enforce waiting period after back-off before tuning up again
		}
	}
	// Throttle Event tracks how often a packet-drop has caused us to throttle back transmission rate.  We will let this value
	// decay over time.  If throttle events happen faster then the decay occurs then this value will grow un-bounded.  This
	// growth is what causes a decrease in the actual send window/transmit rate that will persist beyond the throttle event.
	
	else if(pEPD->uiThrottleEvents)
	{
		pEPD->uiThrottleEvents--;								// Let this decay...
	}

	if(--pEPD->uiAdaptAlgCount == 0)
	{
		RunAdaptiveAlg(pEPD, tNow);
	}
}

/*
**		Grow Send Window
**
**		The two parallel send windows,  frame-based and byte-based,  can grow and shrink independently.  In this
**	routine we will grow one or both windows.  We will grow each window providing that it has been filled in the
**	last period, during which we have determined that thru-put has increased.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "GrowSendWindow"

BOOL
GrowSendWindow(PEPD pEPD, DWORD tNow)
{
	UINT	delta = 0;

	pEPD->tLastDelta = tNow;

	// first store current good values for a restore
	pEPD->uiGoodWindowF = pEPD->uiWindowF;
	pEPD->uiGoodWindowBI = pEPD->uiWindowBIndex;
	pEPD->uiGoodRTT = pEPD->uiRTT;
	pEPD->uiGoodBurstGap = pEPD->uiBurstGap;

	if(pEPD->uiBurstGap)
	{
		// cut the burst gap by 25% if less than 3 ms go to 0.
		if(pEPD->uiBurstGap > 3)
		{
			pEPD->uiBurstGap -= pEPD->uiBurstGap >> 2;
		} 
		else 
		{
			pEPD->uiBurstGap = 0;
		}

		pEPD->uiLastRateB = pEPD->uiPeriodRateB;
		pEPD->uiPeriodAcksBytes = 0;
		pEPD->uiPeriodXmitTime = 0;

		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), burst gap set to %d ms", pEPD, pEPD->uiBurstGap);
	} 
	else 
	{
		if((pEPD->ulEPFlags & EPFLAGS_FILLED_WINDOW_FRAME) && (pEPD->uiWindowF < MAX_RECEIVE_RANGE))
		{
			pEPD->uiWindowF++;
			delta = 1;
		}
		if((pEPD->ulEPFlags & EPFLAGS_FILLED_WINDOW_BYTE) && (pEPD->uiWindowBIndex < MAX_RECEIVE_RANGE))
		{
			pEPD->uiWindowBIndex++;
			pEPD->uiWindowB += pEPD->pSPD->uiFrameLength;
			delta = 1;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE);
		pEPD->uiWindowFilled = 0;

		if(delta)
		{
			pEPD->uiLastRateB = pEPD->uiPeriodRateB;
			pEPD->uiPeriodAcksBytes = 0;
			pEPD->uiPeriodXmitTime = 0;
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) ** GROW SEND WINDOW to %d frames and %d (%d) bytes", pEPD, pEPD->uiWindowF, pEPD->uiWindowB, pEPD->uiWindowBIndex);
		}
		else 
		{
			// We get here if we have already max'd out the window
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) GROW SEND WINDOW -- Nothing to grow. Transition to Stable!", pEPD);
			pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;

			return FALSE;
		}
	}

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "RunAdaptiveAlg"

VOID
RunAdaptiveAlg(PEPD pEPD, DWORD tNow)
{
	LONG	tDelta;											// Time the link was transmitting since last run of AdaptAlg
	UINT	uiBytesAcked;
	UINT	uiNewSum;

	// Calculate the time during which this link was actually transmitting to make sure we have enough
	// data to run the Adaptive Alg.  This is easy unless we are currently idle...

	tDelta = tNow - pEPD->tLastThruPutSample;

	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Adaptive Alg tDelta = %d", pEPD, tDelta);

	// THIS PROBABLY IS UNNECESSARY NOW...
	if(tDelta <= 0)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "DELAYING Adaptive Alg");
		pEPD->uiAdaptAlgCount = 4;
		return;
	}

	//  Calculate current throughput acheived
	//
	//		We will determine the amount of time the link was not idle and then number of bytes (& frames) which
	//	were acknowleged by our partner.
	//
	//	tDelta = Time since last calculation minus the time the link was idle.
	
	uiBytesAcked = pEPD->uiBytesAcked - pEPD->uiLastBytesAcked;

	uiNewSum = pEPD->uiPeriodAcksBytes + (uiBytesAcked * 256);

	if(uiNewSum < pEPD->uiPeriodAcksBytes)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "THRUPUT is about to wrap. Correcting...");
		pEPD->uiPeriodAcksBytes /= 2;
		pEPD->uiPeriodXmitTime /= 2;
		pEPD->uiPeriodAcksBytes += (uiBytesAcked * 256);
	}
	else 
	{
		pEPD->uiPeriodAcksBytes = uiNewSum;
	}

	pEPD->uiPeriodXmitTime += tDelta;								// Track complete values for this period
	pEPD->tLastThruPutSample = tNow;
	
	pEPD->uiLastBytesAcked = pEPD->uiBytesAcked;
	pEPD->uiPeriodRateB = pEPD->uiPeriodAcksBytes / pEPD->uiPeriodXmitTime;

	if(pEPD->uiPeriodRateB > pEPD->uiPeakRateB)
	{
		pEPD->uiPeakRateB = pEPD->uiPeriodRateB;					// Track the largest value we ever measure
	}
	
	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) PERIOD COUNT BYTES = %u, XmitTime = %u, Thruput=(%u bytes/s), RTT=%u, Window=(%u,%u)", pEPD, pEPD->uiPeriodAcksBytes, pEPD->uiPeriodXmitTime, pEPD->uiPeriodRateB * 4, pEPD->uiRTT, pEPD->uiWindowF, pEPD->uiWindowB);

#ifndef DPNBUILD_NOPROTOCOLTESTITF
	if (pEPD->ulEPFlags & EPFLAGS_LINK_FROZEN)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Test App requests that dynamic algorithm not be run, skipping", pEPD);
		pEPD->uiAdaptAlgCount = 32; // Make sure the throughput numbers get updated from time to time
		return;
	}
#endif // !DPNBUILD_NOPROTOCOLTESTITF

	if(pEPD->ulEPFlags & EPFLAGS_LINK_STABLE)
	{
		/*		We are in a STABLE state,  meaning we think we are transmitting at an optimal
		**	rate for the current network conditions.  Conditions may change.  If things slow down
		**	or grow congested a Backoff will trigger normally.  Since conditions might also change
		**	for the better,  we will still want to periodically probe higher rates,  but much less
		**	often than when we are in DYNAMIC mode,  which means we are searching for an optimal rate.
		*/
		
		pEPD->uiAdaptAlgCount = 32;		// tNow + (pEPD->uiRTT * 32) + 32;

		if((tNow - pEPD->tLastDelta) > INITIAL_STATIC_PERIOD)
		{
			if(pEPD->ulEPFlags & (EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE))
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) RETURNING LINK TO DYNAMIC MODE", pEPD);
				
				pEPD->ulEPFlags &= ~(EPFLAGS_LINK_STABLE);

				pEPD->uiPeriodAcksBytes = 0;
				pEPD->uiPeriodXmitTime = 0;

				pEPD->uiWindowFilled = 0;
				pEPD->ulEPFlags &= ~(EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE);
				pEPD->uiAdaptAlgCount = 12;
			}
			else 
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) NO WINDOWS FILLED,  Not returning to Dynamic Mode", pEPD);
				pEPD->tLastDelta = tNow;
			}
		}
		else
		{
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) STILL IN STATIC PERIOD, time=%u, period=%u", pEPD, tNow - pEPD->tLastDelta, INITIAL_STATIC_PERIOD);
		}
	}

	// DYNAMIC STATE LINK
	else 
	{  
		pEPD->uiAdaptAlgCount = 8;

		// Possibly increase transmission rates.  We will not do this if we have had a ThrottleEvent
		// in recent memory,  or if we have not been actually transmitting for enough of the interval
		// to have collected worthwhile data
		//
		//		Also,  we dont want to even consider growing the send window unless we are consistantly
		// filling it.  Since one job of the window is to prevent us from flooding the net during a backup,
		// we dont want to grow the window following each backup.  The best way to distinguish between a 
		// backup and too small of a window is that the small window should fill up regularly while the
		// backups should only occur intermittantly.  The hard part is coming up with the actual test.
		// Truth is,  we can be fairly lax about allowing growth because it will also have to meet the increased
		// bandwidth test before the larger window is accepted.  So a crude rule would be to fix a number like 3.
		// Yes, crude but probably effective.  Perhaps a more reasonable figure would be a ratio of the total
		// number of packets sent divided by the window size.  I.e., if your window size is 10 frames then one
		// packet in ten should fill the window.  Of course, this would have to be calculated in bytes...

		if((pEPD->uiWindowFilled > 12)&&(pEPD->uiThrottleEvents == 0))
		{
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) DYNAMIC ALG: Window Fills: %d; B-Ack = (%x vs %x)", pEPD, pEPD->uiWindowFilled, pEPD->uiPeriodRateB, pEPD->uiLastRateB);
									
			pEPD->uiWindowFilled = 0;	

			if (!(pEPD->ulEPFlags & EPFLAGS_TESTING_GROWTH))
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) GROWING WINDOW", pEPD);
				
				// In the case that GrowSendWindow doesn't grow anything because we are already max'd out
				// it will return FALSE, and it should have transitioned us to STABLE.
				if (GrowSendWindow(pEPD, tNow))
				{
					pEPD->ulEPFlags |= EPFLAGS_TESTING_GROWTH;
				}
				else
				{
					ASSERT(pEPD->ulEPFlags & EPFLAGS_LINK_STABLE);
				}

				return;
			}
			
			// GETTING HERE means that we have used our current transmit parameters long enough
			// to have an idea of their performance.  We will now compare this to the performance
			// of the previous transmit parameters and we will either Revert to the previous set if
			// the perf is not improved,  or else we will advance to faster parameters if we did see
			// a jump.

			// In order to keep higher transmit parameters we need to see an increase in throughput 
			// with no corresponding rise in RTT.  We will want to see this twice just to be sure
			// since the cost of incorrect growth is so high on a modem.

			if( (pEPD->uiPeriodRateB > pEPD->uiLastRateB) && 
				(pEPD->uiRTT <= (pEPD->uiGoodRTT + 10))
				)
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Throughput increased after window growth, keeping new parameters", pEPD);

				pEPD->ulEPFlags &= ~(EPFLAGS_TESTING_GROWTH);

				pEPD->uiPeriodAcksBytes = 0;
				pEPD->uiPeriodXmitTime = 0;
			}
			else 
			{
				// We did not see a thru-put improvement so we will back off the previous value
				// and transition the link to STABLE state.

				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) INSUFFICENT INCREASE IN THRUPUT, BACK OFF AND TRANSITION TO STABLE", pEPD);

				// Because we have over-transmitted for at least one period, we may have put excess data
				// on the link in a buffer.  This will have the effect of gradually growing our RTT if we
				// don't bleed that data off which we will do here by backing off two steps where we 
				// previously grew one step.

				if (pEPD->uiBurstGap != pEPD->uiGoodBurstGap)
				{
					// increase the burst gap by 25%, clipping it to the max retry interval/2
					pEPD->uiBurstGap = pEPD->uiGoodBurstGap + (pEPD->uiGoodBurstGap >> 2);
					DWORD dwMaxBurstGap=pEPD->pSPD->pPData->dwSendRetryIntervalLimit/2;
					if (pEPD->uiBurstGap>dwMaxBurstGap)
					{
						pEPD->uiBurstGap=dwMaxBurstGap;
						DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Clipped burst gap to value %u", pEPD, pEPD->uiBurstGap);
					}

				}
					
				if (pEPD->uiWindowF != pEPD->uiGoodWindowF)
				{
					if (pEPD->uiGoodWindowF > 2)
					{
						pEPD->uiWindowF = _MAX(pEPD->uiGoodWindowF - 1, 1);
					}
					else
					{
						pEPD->uiWindowF = pEPD->uiGoodWindowF;
					}
				}
				if (pEPD->uiWindowBIndex != pEPD->uiGoodWindowBI)
				{
					pEPD->uiWindowBIndex = _MAX(pEPD->uiGoodWindowBI - 1, 1);
					pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
				}

				pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;				// TRANSITION TO STABLE STATE
				
				pEPD->ulEPFlags &= ~(EPFLAGS_TESTING_GROWTH);

				pEPD->uiPeriodAcksBytes = 0;
				pEPD->uiPeriodXmitTime = 0;
				
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) ** TUNING LINK:  BurstGap=%d; FWindow=%d, BWindow=%d (%d)",pEPD, pEPD->uiBurstGap, pEPD->uiWindowF, pEPD->uiWindowB, pEPD->uiWindowBIndex);
			}
		}
		else 
		{
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) DYN ALG -- Not trying to increase:  WindowFills = %d, ThrottleCount = %d", pEPD, pEPD->uiWindowFilled, pEPD->uiThrottleEvents);
		}
	}	// END IF DYNAMIC STATE LINK
}


/*
**		End Point Dropped Frame
**
**		We have two levels of Backoff.  We have an immediate BackOff implemented
**	upon first detection of a drop-event in order to relieve the congestion which
**	caused the drop.  An immediate backoff will resume transmitting at the original
**	rate without going through slow-start again after the congestion event has passed.
**	If we have multiple immediate-backoffs in a certain interval we will have a
**	hard backoff which will not restore.
**
**	CALLED WITH EPD->SPLock held (and sometimes with StateLock held too)
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EndPointDroppedFrame"

VOID
EndPointDroppedFrame(PEPD pEPD, DWORD tNow)
{
	//
	//	Don't change count if "expiring" drop rolls off
	//
	if (!(pEPD->dwDropBitMask & 0x80000000))
	{
		pEPD->uiDropCount++;
	}

	//
	//	Adjust mask
	//
	pEPD->dwDropBitMask = (pEPD->dwDropBitMask << 1) + 1;

	DPFX(DPFPREP,7, "(%p) Drop Count %d, Drop Bit Mask 0x%lx", pEPD,pEPD->uiDropCount,pEPD->dwDropBitMask);

	//
	//	Should we throttle ?
	//
	if (pEPD->uiDropCount > pEPD->pSPD->pPData->dwDropThreshold)
	{
		DPFX(DPFPREP,7, "(%p) THROTTLING BACK", pEPD);
		ThrottleBack(pEPD, tNow);

		//
		//	Reset drop count
		//
		pEPD->dwDropBitMask = 0;
		pEPD->uiDropCount = 0;
	}
}

/*
**		Throttle Back
**
**		We suspect network congestion due to dropped frames ((or a spike in latency)).  We want
**	to quickly scale back our transmit rate to releive the congestion and avoid further packet drops.
**	This is a temporary backoff and we will resume our current transmit rate when the congestions
**	clears.
**
**		If we find that we are throttling back frequently then we may conclude that our current xmit
**	rate is higher then optimal and we will BackOff to a lower rate,  and transition to a STABLE link
**	state (if not already there) to indicate that we have plateaued.
**
**		A note on convergence.  The ThrottleEvents variable is incremented 10 points each time a throttle
**	event is triggered.  This variable also decays slowly when the link is running without events.  So if
**	the variable grows faster then it decays we will eventually trigger a switch to STABLE state
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ThrottleBack"

VOID
ThrottleBack(PEPD pEPD, DWORD tNow)
{
#ifndef DPNBUILD_NOPROTOCOLTESTITF
	if (pEPD->ulEPFlags & EPFLAGS_LINK_FROZEN)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Test App requests that throttle code not be run, skipping", pEPD);
		return;
	}
#endif // !DPNBUILD_NOPROTOCOLTESTITF

	pEPD->ulEPFlags |= EPFLAGS_THROTTLED_BACK;		// Set link to THROTTLED state
	pEPD->uiThrottleEvents += 10;					// Count times we throttle-back for all reasons
	pEPD->tThrottleTime = tNow;						// Remember time that throttle was engaged
	
#ifdef DBG
	pEPD->uiTotalThrottleEvents++;					// Count times we throttle-back for all reasons
#endif // DBG

	pEPD->uiRestoreBurstGap = pEPD->uiBurstGap;
	pEPD->uiRestoreWindowF = pEPD->uiWindowF;
	pEPD->uiRestoreWindowBI = pEPD->uiWindowBIndex;

	if(pEPD->uiWindowF == 1)
	{
		if(pEPD->uiBurstGap == 0)
		{
			pEPD->uiBurstGap = _MAX(1,pEPD->uiRTT/2);
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), first burst gap, set to %d ms", pEPD, pEPD->uiBurstGap);
		} 
		else 
		{
			pEPD->uiBurstGap = pEPD->uiBurstGap*2;						
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), burst gap doubled to %d ms", pEPD, pEPD->uiBurstGap);
		}
		pEPD->uiBurstGap = _MIN(pEPD->uiBurstGap, pEPD->pSPD->pPData->dwSendRetryIntervalLimit/2);
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), burst gap is now %d ms", pEPD, pEPD->uiBurstGap);
	}

	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) THROTTLE WINDOW from %d frames", pEPD, pEPD->uiWindowF);
	pEPD->uiWindowF = _MAX((UINT)(pEPD->uiWindowF * pEPD->pSPD->pPData->fThrottleRate), 1);	// be sure window remains > 0.
	pEPD->uiWindowBIndex = _MAX((UINT)(pEPD->uiWindowBIndex * pEPD->pSPD->pPData->fThrottleRate), 1);
	pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) THROTTLE WINDOW to %d frames", pEPD, pEPD->uiWindowF);

	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) THROTTLE ENGAGED (%d):  Backoff to Window=%d; Gap=%d", pEPD, pEPD->uiThrottleEvents, pEPD->uiWindowF, pEPD->uiBurstGap);
	
	if(pEPD->uiThrottleEvents > THROTTLE_EVENT_THRESHOLD)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) ** DETECT TRANSMIT CEILING ** Reducing 'good' speed and marking link STABLE", pEPD);

		// We have already reduced our current transmit rates.  Here we will reduce the "good" rates that
		// we will restore to when we clear the throttled state.
		
		pEPD->uiThrottleEvents = 0;

		pEPD->uiRestoreWindowF = _MAX((pEPD->uiRestoreWindowF - 1), 1);
		pEPD->uiRestoreWindowBI = _MAX((pEPD->uiRestoreWindowBI - 1), 1);

		if (pEPD->uiRestoreBurstGap)
		{
			UINT t;
			t=pEPD->uiRestoreBurstGap;
			pEPD->uiRestoreBurstGap = (t+1) + (t >> 2); // 1.25*pEPD->uiRestoreBurstGap
		}

		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) New Restore Values:  Window=%d; Gap=%d", pEPD, pEPD->uiRestoreWindowF, pEPD->uiRestoreBurstGap);

		pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;
		pEPD->ulEPFlags &= ~(EPFLAGS_TESTING_GROWTH);
	}
}


/*
**		EPD Pool Support Routines
**
**		These are the functions called by Fixed Pool Manager as it handles EPDs.
*/

//	Allocate is called when a new EPD is first created

#define	pELEMENT	((PEPD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Allocate"

BOOL EPD_Allocate(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,7, "(%p) Allocating new EPD", pELEMENT);
	
	pELEMENT->blHighPriSendQ.Initialize();				// Can you beleive there are SIX send queues per Endpoint?
	pELEMENT->blNormPriSendQ.Initialize();				// Six send queues.  
	pELEMENT->blLowPriSendQ.Initialize();				// Well,  it beats sorting the sends into the queues upon submission.
	pELEMENT->blCompleteSendList.Initialize();
	
	pELEMENT->blSendWindow.Initialize();
	pELEMENT->blRetryQueue.Initialize();
	pELEMENT->blCompleteList.Initialize();
	pELEMENT->blOddFrameList.Initialize();
	pELEMENT->blChkPtQueue.Initialize();
	pELEMENT->blSPLinkage.Initialize();
	pELEMENT->blActiveLinkage.Initialize();

	if (DNInitializeCriticalSection(&pELEMENT->EPLock) == FALSE)
	{
		DPFX(DPFPREP, 0, "Failed to initialize endpoint CS");
		return FALSE;
	}
	DebugSetCriticalSectionRecursionCount(&pELEMENT->EPLock, 0);
	DebugSetCriticalSectionGroup(&pELEMENT->EPLock, &g_blProtocolCritSecsHeld);

	pELEMENT->Sign = EPD_SIGN;
	pELEMENT->pCurrentSend = NULL;
	pELEMENT->pCurrentFrame = NULL;
	pELEMENT->pCommand = NULL;

	pELEMENT->RetryTimer = 0;
	pELEMENT->LinkTimer = 0;
	pELEMENT->DelayedAckTimer = 0;

	pELEMENT->ulEPFlags = 0;	// EPFLAGS_STATE_CLEAR - make this line show up in state searches
	pELEMENT->ulEPFlags2 = 0;

	return TRUE;
}

//	Get is called each time an EPD is used

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Get"

VOID EPD_Get(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,DPF_EP_REFCNT_FINAL_LVL, "CREATING EPD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->hEndPt = INVALID_HANDLE_VALUE;
	pELEMENT->lRefCnt = 0; // We are -1 based, so place the first reference on the endpoint

	pELEMENT->pNewMessage = NULL;
	pELEMENT->pNewTail = NULL;
	
	ASSERT_EPD(pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Release"

VOID EPD_Release(PVOID pElement)
{
	PCHKPT pCP;

	ASSERT_EPD(pELEMENT);

	DPFX(DPFPREP,DPF_EP_REFCNT_FINAL_LVL, "RELEASING EPD %p", pELEMENT);

	ASSERT((pELEMENT->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)==0);

	// Clear any checkpoints still waiting on EP

	while(!pELEMENT->blChkPtQueue.IsEmpty())
	{
		pCP = CONTAINING_OBJECT(pELEMENT->blChkPtQueue.GetNext(), CHKPT, blLinkage);
		pCP->blLinkage.RemoveFromList();
		ChkPtPool.Release(pCP);
	}

	// These lists should be empty before End Point is released...
	ASSERT(pELEMENT->blOddFrameList.IsEmpty());
	ASSERT(pELEMENT->blCompleteList.IsEmpty());

	ASSERT(pELEMENT->blHighPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blNormPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blLowPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blCompleteSendList.IsEmpty());
	
	ASSERT(pELEMENT->blSendWindow.IsEmpty());
	ASSERT(pELEMENT->blRetryQueue.IsEmpty());
	ASSERT(pELEMENT->blActiveLinkage.IsEmpty());
	ASSERT(pELEMENT->blSPLinkage.IsEmpty());
	ASSERT(pELEMENT->blChkPtQueue.IsEmpty());

	ASSERT(pELEMENT->pCurrentSend == NULL);
	ASSERT(pELEMENT->pCurrentFrame == NULL);

	pELEMENT->ulEPFlags = 0;	// EPFLAGS_STATE_CLEAR - make this line show up in state searches
	pELEMENT->ulEPFlags2 = 0;

	pELEMENT->pCommand = NULL;
	pELEMENT->Context = NULL;

	pELEMENT->hEndPt = INVALID_HANDLE_VALUE; 

}

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Free"

VOID EPD_Free(PVOID pElement)
{
	DNDeleteCriticalSection(&pELEMENT->EPLock);
}

#undef	ELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\frames.h ===
/*===
		Direct Network Protocl   --   Frame format header file


		Evan Schrier	10/98

*/



/*	
		Direct Network Protocol

| MEDIA HEADER | Var Len DN Header | Client Data |

There are two types of packets that may be exchanged between Direct Network
endpoints:

	Data Packets				(D Frame)	User data transmission
	Control Packets				(C Frame)	Internal link-state packets with no user data



*/

/*
	COMMAND FIELD

		The command field is the first byte of all frames.  The first BIT of the command frame is always
	the COMMAND FRAME vs DATA FRAME opcode.  The seven high bits of the Command field are flags.  We have
	a requirement that the command field of all protocol packets must never be all zeros.  Therefore,  when
	the opcode bit is zero (COMMAND FRAME) we must be sure that one flag bit is always set.  The highest flag bit,
	the USER2 flag is not relevant to COMMAND frames so we will always set the most significant bit when the opcode
	bit is zero.

		The seven command field flag bits are defined as follows:

	RELIABLE	-	Data delivery of this frame is guarenteed
	SEQUENTIAL	-	Data in this frame must be delivered in the order it was sent, with respect to other SEQ frames
	POLL		-	Protocol requests an immediate acknowledgement to this frame
	NEW MESSAGE	-	This frame is the first or only frame in a message
	END MESSAGE -	This frame is the last or only frame in a message
	USER1		-	First flag controlled by the higher layer (direct play core)
	USER2		-	Second flag controlled by core.  These flags are specified in the send API and are delivered with the data


	DATA FRAMES

		Data frames are between 4 and 20 bytes in length.  They should typically be only 4 bytes.  Following the
	Command byte in all data frames in the Control byte.  This byte contains a 3-bit retry counter and 5 additional
	flags.  The Control byte flags are defined as follows:

	END OF STREAM	-	This frame is the last data frame the transmitting partner will send.
	SACK_MASK_ONE	-	The low 32-bit Selective Acknowledgment mask is present in this header
	SACK_MASK_TWO	-	The high 32-bit Selective Acknowledgment mask is present in this header
	SEND_MASK_ONE	-	The low 32-bit Cancel Send mask is present in this header
	SEND_MASK_TWO	-	The high 32-bit Cancel Send mask is present in this header

		After Control byte come two one byte values:  Sequence number for this frame, and Next Receive sequence number
	expected by this partner.  After these two bytes comes zero through four bitmasks as specified by the control flags.
	After the bitmasks,  the rest of the frame is user data to be delivered to the direct play core.
*/
#ifndef	_DNET_FRAMES_
#define	_DNET_FRAMES_

/*
	Command FRAME Extended Opcodes

	A CFrame without an opcode is a vehicle for non-piggybacked acknowledgement
	information.  The following sub-commands are defined at this time:

	SACK			- Only Ack/Nack info present
	CONNECT 		- Initialize a reliable connection
	CONNECTED		- Response to CONNECT request, or CONNECTED depending on which side of the handshake
*/

#define		FRAME_EXOPCODE_CONNECT				1
#define		FRAME_EXOPCODE_CONNECTED				2
#define		FRAME_EXOPCODE_CONNECTED_SIGNED		3
#define		FRAME_EXOPCODE_HARD_DISCONNECT		4 
#define		FRAME_EXOPCODE_SACK					6

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)

typedef UNALIGNED struct dataframe				DFRAME, *PDFRAME;
typedef UNALIGNED struct cframe					CFRAME, *PCFRAME;
typedef UNALIGNED struct sackframe8				SACKFRAME8, *PSACKFRAME8;
typedef UNALIGNED struct cframe_connectedsigned	CFRAME_CONNECTEDSIGNED, * PCFRAME_CONNECTEDSIGNED;

#ifndef DPNBUILD_NOMULTICAST
typedef UNALIGNED struct multicastframe		MCASTFRAME, *PMCASTFRAME;
#endif // !DPNBUILD_NOMULTICAST

typedef UNALIGNED struct coalesceheader		COALESCEHEADER, *PCOALESCEHEADER;

//	Packet Header is common to all frame formats

#define	PACKET_COMMAND_DATA			0x01			// Frame contains user data
#define	PACKET_COMMAND_END_COALESCE	0x01			// This is the last coalesced subframe
#define	PACKET_COMMAND_RELIABLE		0x02			// Frame should be delivered reliably
#define	PACKET_COMMAND_SEQUENTIAL	0x04			// Frame should be indicated sequentially
#define	PACKET_COMMAND_POLL			0x08			// Partner should acknowlege immediately
#define	PACKET_COMMAND_COALESCE_BIG_1		0x08	// This coalesced subframe is over 255 bytes
#define	PACKET_COMMAND_NEW_MSG		0x10			// Data frame is first in message
#define	PACKET_COMMAND_COALESCE_BIG_2		0x10	// This coalesced subframe is over 511 bytes
#define	PACKET_COMMAND_END_MSG		0x20			// Data frame is last in message
#define	PACKET_COMMAND_COALESCE_BIG_3		0x20	// This coalesced subframe is over 1023 bytes
#define	PACKET_COMMAND_USER_1		0x40			// First user controlled flag
#define	PACKET_COMMAND_USER_2		0x80			// Second user controlled flag
#define	PACKET_COMMAND_CFRAME		0x80			// Set high-bit on command frames because first byte must never be zero

#define	PACKET_CONTROL_RETRY		0x01			// This flag designates this frame as a retry of a previously xmitted frame
#define	PACKET_CONTROL_KEEPALIVE	0x02			// Designates this frame as a keep alive frame for dx9 and onwards
#define	PACKET_CONTROL_CORRELATE	0x02			// For pre-dx9 this bit in a frame meant 'please send an immediate ack'
#define	PACKET_CONTROL_COALESCE		0x04			// This packet contains multiple coalesced packets
#define	PACKET_CONTROL_END_STREAM	0x08			// This packet serves as Disconnect frame.
#define	PACKET_CONTROL_SACK_MASK1	0x10			// The low 32-bit SACK mask is included in this frame.
#define	PACKET_CONTROL_SACK_MASK2	0x20			// The high 32 bit SACK mask is present
#define	PACKET_CONTROL_SEND_MASK1	0x40			// The low 32-bit SEND mask is included in this frame
#define	PACKET_CONTROL_SEND_MASK2	0x80			// The high 32-bit SEND mask is included in this frame

#define	PACKET_CONTROL_VARIABLE_MASKS	0xF0	// All four mask bits above

// Options for signing in connected signed frames (cframe_connectedsigned::dwSigningOpts)

#define	PACKET_SIGNING_FAST			0x00000001			//packets over link should be fast signed
#define	PACKET_SIGNING_FULL				0x00000002			//packets over link should be full signed


/*		NEW DATA FRAMES
**
**		Here in the new unified world we have only two frame types!  CommandFrames and DataFrames...
**
*/

struct	dataframe 
{
	BYTE	bCommand;
	BYTE	bControl;
	BYTE	bSeq;
	BYTE	bNRcv;
};


/*	
**		COMMAND FRAMES
**
**		Command frames are everything that is not part of the reliable stream.  This is most of the control traffic
**	although some control traffic is part of the stream (keep-alive, End-of-Stream)
*/

struct	cframe 
{
	BYTE	bCommand;
	BYTE	bExtOpcode;				// CFrame sub-command
	BYTE	bMsgID;					// Correlator in case ExtOpcode requires a response
	BYTE	bRspID;					// Correlator in case this is a response
									// For Hard Disconnects this is set to the seq # of the next dataframe that would be sent
	DWORD	dwVersion;				// Protocol version #
	DWORD	dwSessID;				// Session identifier
	DWORD	tTimestamp;				// local tick count
};

struct	cframe_connectedsigned
{
		//first set of members match cframe exactly
	BYTE	bCommand;
	BYTE	bExtOpcode;				// CFrame sub-command. Always FRAME_EXOPCODE_CONNECTED_SIGNED
	BYTE	bMsgID;					// Correlator in case ExtOpcode requires a response
	BYTE	bRspID;					// Correlator in case this is a response
	DWORD	dwVersion;				// Protocol version #
	DWORD	dwSessID;				// Session identifier
	DWORD	tTimestamp;				// local tick count

		//additional members for cframe_signedconnected
	ULONGLONG	ullConnectSig;			// used to verify the connect sequence
	ULONGLONG	ullSenderSecret;		// secret used to sign packets by the sender of this frame
	ULONGLONG	ullReceiverSecret;		// secret that should be used to sign packets by the receiver of this frame
	DWORD		dwSigningOpts;		// used to signal the signing settings
	DWORD		dwEchoTimestamp;		// contains the original timestamp from the connect or connectsigned that
									// provoked this frame as a reply. Allows the receiver to calculate the RTT
};

/*	
**	Selective Acknowledgement packet format
**
**		When a specific acknowledgement frame is sent there may be two additional pieces
**	of data included with the frame.  One is a bitmask allowing selective acknowledgment
**	of non-sequential frames.  The other is timing information about the last frame acked
**  by this ACK (NRcv - 1).  Specifically,  it includes the lowest Retry number that this
**  node received,  and the ms delay between that packets arrival and the sending of this
**	Ack.
*/


#define		SACK_FLAGS_RESPONSE			0x01	// indicates that Retry and Timestamp fields are valid
#define		SACK_FLAGS_SACK_MASK1		0x02
#define		SACK_FLAGS_SACK_MASK2		0x04
#define		SACK_FLAGS_SEND_MASK1		0x08
#define		SACK_FLAGS_SEND_MASK2		0x10

//	First format is used when DATAGRAM_INFO flag is clear

struct	sackframe8 
{	
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;
	BYTE		bNSeq;					// Since this frame has no sequence number, this is the next Seq we will send
	BYTE		bNRcv;					// As above
	BYTE		bReserved1;				// We shipped DX8 with bad packing, so these were actually there
	BYTE		bReserved2;				// We shipped DX8 with bad packing, so these were actually there
	DWORD		tTimestamp;				// Local timestamp when packet (NRcv - 1) arrived
};


#ifndef DPNBUILD_NOMULTICAST
struct multicastframe
{
	DWORD	dwVersion;				// Protocol version #
	DWORD	dwSessID;				// Session identifier
};
#endif // !DPNBUILD_NOMULTICAST

struct coalesceheader
{
	BYTE bSize;						// The 8 least significant bits of the size of the data for this coalesced message
	BYTE bCommand;					// PACKET_COMMAND_XXX values
};

#pragma pack(pop)

#endif // _DNET_FRAMES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\enum.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Enum.cpp
 *  Content:	This file contains support enuming sessions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  01/10/00	jtk		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


/*
**		Send Enum Query
**
**		This routine will send out a broadcast to everyone that can hear
**  indicating this side's interest in finding listening connections.
**  Interested connections will respond through IndicateEnumResponse.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPEnumQuery"

HRESULT 
DNPEnumQuery(HANDLE hProtocolData, IDirectPlay8Address* paHostAddress, IDirectPlay8Address* paDeviceAddress, HANDLE hSPHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwRetryCount, DWORD dwRetryInterval, DWORD dwTimeout, DWORD dwFlags, VOID* pvUserContext, VOID* pvSessionData, DWORD dwSessionDataSize, HANDLE* phEnumHandle)
{
	ProtocolData*	pPData;
	PSPD			pSPD;
	PMSD			pMSD;
	SPENUMQUERYDATA	EnumData;
	HRESULT			hr;
#ifdef DBG
	ULONG			ulAllowedFlags;
#endif // DBG

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], paHostAddress[%p], paDeviceAddress[%p], hSPHandle[%p], pBuffers[%p], dwBufferCount[%x], dwRetryCount[%x], dwRetryInterval[%x], dwTimeout[%x], dwFlags[%x], pvUserContext[%p], pvSessionData[%p], dwSessionDataSize[%u], phEnumHandle[%p]", hProtocolData, paHostAddress, paDeviceAddress, hSPHandle, pBuffers, dwBufferCount, dwRetryCount, dwRetryInterval, dwTimeout, dwFlags, pvUserContext, pvSessionData, dwSessionDataSize, phEnumHandle);

	hr = DPNERR_PENDING;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this Op even though it isn't technically a message
	if((pMSD = (PMSD)POOLALLOC(MEMID_ENUMQUERY_MSD, &MSDPool)) == NULL)
	{	
		DPFX(DPFPREP,0, "Failed to allocate MSD");
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

	pMSD->CommandID = COMMAND_ID_ENUM;
	pMSD->pSPD = pSPD;
	pMSD->Context = pvUserContext;

	EnumData.pAddressHost = paHostAddress;
	EnumData.pAddressDeviceInfo = paDeviceAddress;
	EnumData.pBuffers = pBuffers;
	EnumData.dwBufferCount = dwBufferCount;
	EnumData.dwTimeout = dwTimeout;
	EnumData.dwRetryCount = dwRetryCount;
	EnumData.dwRetryInterval = dwRetryInterval;

#ifdef DBG
	ulAllowedFlags = DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK | DN_ENUMQUERYFLAGS_SESSIONDATA;
#ifndef DPNBUILD_NOSPUI
	ulAllowedFlags |= DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING;
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_ONLYONEADAPTER
	ulAllowedFlags |= DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS;
#endif // ! DPNBUILD_ONLYONEADAPTER

	DNASSERT( ( dwFlags & ~(ulAllowedFlags) ) == 0 );
#endif // DBG

	EnumData.dwFlags = 0;
#ifndef DPNBUILD_NOSPUI
	if ( ( dwFlags & DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
	}
#endif // ! DPNBUILD_NOSPUI

	if ( ( dwFlags & DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_NOBROADCASTFALLBACK;
	}

#ifndef DPNBUILD_ONLYONEADAPTER
	if ( ( dwFlags & DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_ADDITIONALMULTIPLEXADAPTERS;
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	if ( ( dwFlags & DN_ENUMQUERYFLAGS_SESSIONDATA) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_SESSIONDATA;
		EnumData.pvSessionData = pvSessionData;
		EnumData.dwSessionDataSize = dwSessionDataSize;
	}

	EnumData.pvContext = pMSD;
	EnumData.hCommand = NULL;

	*phEnumHandle = pMSD;

#ifdef DBG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);		// Dont support timeouts for Listen
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif // DBG

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	LOCK_MSD(pMSD, "SP Ref");											// AddRef for SP
	LOCK_MSD(pMSD, "Temp Ref");

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->EnumQuery, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_EnumQuery(pSPD->IISPIntf, &EnumData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// This should always Pend or else be in error
		DPFX(DPFPREP,1, "Calling SP->EnumQuery Failed, return is not DPNERR_PENDING, hr[%x], pMSD[%p], pSPD[%p]", hr, pMSD, pSPD);

		// DPNERR_PENDING is the only success code we accept
		ASSERT(FAILED(hr));

		Lock(&pMSD->CommandLock);
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DBG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif // DBG

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");				// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");		// release again to return resource

		goto Exit;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = EnumData.hCommand;			// retain SP command handle
	pMSD->dwCommandDesc = EnumData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

Exit:
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x], pMSD[%p]", hr, pMSD);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}


/*
**		Enum Respond
**
**		This routine will send out a response to a received enum query.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPEnumRespond"

HRESULT 
DNPEnumRespond(HANDLE hProtocolData, HANDLE hSPHandle, HANDLE hQueryHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwFlags, VOID* pvUserContext, HANDLE* phEnumHandle)
{
	ProtocolData*		pPData;
	PSPD				pSPD;
	PMSD				pMSD;
	SPENUMRESPONDDATA	EnumRespondData;
	HRESULT				hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hSPHandle[%p], hQueryHandle[%p], pBuffers[%p], dwBufferCount[%x], dwFlags[%x], pvUserContext[%p], phEnumHandle[%p]", hProtocolData, hSPHandle, hQueryHandle, pBuffers, dwBufferCount, dwFlags, pvUserContext, phEnumHandle);

	hr = DPNERR_PENDING;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pSPD = (PSPD)hSPHandle;
	ASSERT_SPD(pSPD);

	ASSERT(hQueryHandle);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this Op even though it isn't technically a message
	if((pMSD = (PMSD)POOLALLOC(MEMID_ENUMRESP_MSD, &MSDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate MSD");
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

	pMSD->CommandID = COMMAND_ID_ENUMRESP;
	pMSD->pSPD = pSPD;
	pMSD->Context = pvUserContext;

	EnumRespondData.pBuffers = pBuffers;
	EnumRespondData.dwBufferCount = dwBufferCount;
	EnumRespondData.dwFlags = dwFlags;
	EnumRespondData.pvContext = pMSD;
	EnumRespondData.hCommand = NULL;
	EnumRespondData.pQuery = (SPIE_QUERY*)hQueryHandle;

	*phEnumHandle = pMSD;

#ifdef DBG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif // DBG

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	LOCK_MSD(pMSD, "SP Ref");										// AddRef for SP
	LOCK_MSD(pMSD, "Temp Ref");

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->EnumRespond, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_EnumRespond(pSPD->IISPIntf, &EnumRespondData);		/** CALL SP **/

	// This should always Pend or else be in error
	if(hr != DPNERR_PENDING)
	{
		DPFX(DPFPREP,1, "Calling SP->EnumRespond, return is not DPNERR_PENDING, hr[%x], pMSD[%p], pSPD[%p]", hr, pMSD, pSPD);

		// DPNERR_PENDING is the only success code we accept
		ASSERT(FAILED(hr));

		Lock(&pMSD->CommandLock);
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DBG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif // DBG

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");				// release once for SP
		RELEASE_MSD(pMSD, "Release On Non-Pend");	// release again to return resource

		goto Exit;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = EnumRespondData.hCommand;				// retain SP command handle
	pMSD->dwCommandDesc = EnumRespondData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

Exit:
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x], pMSD[%p]", hr, pMSD);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\internal.h ===
/*
**		Direct Network Protocol
**
**		This file contains internal prototypes and global definitions.
*/

// Protocol Version History /////////////////////////////////////////////////////////////
//
//	1.0 - DPlay8 original
//	1.1 - Fix SACK frame bogus 2 bytes caused by bad packing (DPlay 8.1 beta period only)
//	1.2 - Revert to original sack behavior with packing fixed, ie same as DPlay 8.0 (shipped in DPlay 8.1)
//	1.3 - Increment for PocketPC release (RTM prior to DX9 Beta1)
//	1.4 - DX9 Beta1 only
//	1.5 - Add coalescence and hard disconnect support
//	1.5 - .NET Server RTM
//	1.6 - Added packet signing, new style keep alive and connection spoof prevention
//	1.6 - DX9 Beta2 through RTM
/////////////////////////////////////////////////////////////////////////////////////////

//	Global Constants
#define DNET_VERSION_NUMBER                             0x00010005      // The current protocol version
#define DNET_COALESCE_VERSION                           0x00010005      // The first version with coalescence
#define DNET_SIGNING_VERSION                            0x00010006      // The first version with signing

#define DELAYED_ACK_TIMEOUT					100			// Delay before sending dedicated ACK packet
#define SHORT_DELAYED_ACK_TIMEOUT			20			// Delay before sending dedicated NACK packet
#define DELAYED_SEND_TIMEOUT				40			// Delay before sending dedicated SEND_INFO packet

#define CONNECT_DEFAULT_TIMEOUT				(200)		// At .1 we saw too many retries, users can set in SetCaps
#define CONNECT_DEFAULT_RETRIES				14			// Users can set in SetCaps
#define DEFAULT_MAX_RECV_MSG_SIZE			0xFFFFFFFF	//default maximum packet we accept
#define DEFAULT_SEND_RETRIES_TO_DROP_LINK	10			//default number of send retries we attempt before link is dead
#define DEFAULT_SEND_RETRY_INTERVAL_LIMIT	5000		//limit on period in msec between retries
#define DEFAULT_HARD_DISCONNECT_SENDS		3			//default number of hard disconnect frames we send out
														//The value must be at least 2.
#define DEFAULT_HARD_DISCONNECT_MAX_PERIOD	500		//The default for the maximum period we allow between
														//sending out hard disconnect frames
#define DEFAULT_INITIAL_FRAME_WINDOW_SIZE		2		//The default initial frame window size
#define LAN_INITIAL_FRAME_WINDOW_SIZE			32		//The initial frame window size if we asssume a LAN connection

#define STANDARD_LONG_TIMEOUT_VALUE		30000
#define DEFAULT_KEEPALIVE_INTERVAL		60000
#define ENDPOINT_BACKGROUND_INTERVAL	STANDARD_LONG_TIMEOUT_VALUE		// this is really what its for...

#define CONNECT_SECRET_CHANGE_INTERVAL		60000		//period between creations of new connect secrets

#define	DEFAULT_THROTTLE_BACK_OFF_RATE          25              // Percent throttle (backoff) rate
#define	DEFAULT_THROTTLE_THRESHOLD_RATE         7               // Percent packets dropped (out of 32)

#define DPF_TIMER_LVL			9 // The level at which to spew calls into the Protocol

#define DPF_CALLIN_LVL			2 // The level at which to spew calls into the Protocol
#define DPF_CALLOUT_LVL			3 // The level at which to spew calls out of the Protocol

#define DPF_ADAPTIVE_LVL		6 // The level at which to spew Adaptive Algorithm spew
#define DPF_FRAMECNT_LVL		7 // The level at which to spew Adaptive Algorithm spew

#define DPF_REFCNT_LVL			8 // The level at which to spew ref counts
#define DPF_REFCNT_FINAL_LVL	5 // The level at which to spew creation and destruction ref counts

// Separate ones for endpoints
#define DPF_EP_REFCNT_LVL		8 // The level at which to spew ref counts
#define DPF_EP_REFCNT_FINAL_LVL	2 // The level at which to spew creation and destruction ref counts

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_PROTOCOL

	//handy macro for dumping a ULONGLONG out to a debug line
#define DPFX_OUTPUT_ULL(ull)  ((DWORD ) ull) , ((DWORD ) (ull>>32))

typedef	void CALLBACK LPCB(UINT, UINT, DWORD, DWORD, DWORD);

//	Global Variable definitions

extern CFixedPool	ChkPtPool;
extern CFixedPool	EPDPool;
extern CFixedPool	MSDPool;
extern CFixedPool	FMDPool;
extern CFixedPool	RCDPool;
extern CFixedPool	BufPool;
extern CFixedPool	MedBufPool;
extern CFixedPool	BigBufPool;

// Pool functions
BOOL			Buf_Allocate(PVOID, PVOID pvContext);
VOID			Buf_Get(PVOID, PVOID pvContext);
VOID			Buf_GetMed(PVOID, PVOID pvContext);
VOID			Buf_GetBig(PVOID, PVOID pvContext);
BOOL			EPD_Allocate(PVOID, PVOID pvContext);
VOID			EPD_Get(PVOID, PVOID pvContext);
VOID			EPD_Release(PVOID);
VOID			EPD_Free(PVOID);
BOOL			FMD_Allocate(PVOID, PVOID pvContext);
VOID			FMD_Get(PVOID, PVOID pvContext);
VOID			FMD_Release(PVOID);
VOID			FMD_Free(PVOID);
BOOL			MSD_Allocate(PVOID, PVOID pvContext);
VOID			MSD_Get(PVOID, PVOID pvContext);
VOID			MSD_Release(PVOID);
VOID			MSD_Free(PVOID);
BOOL			RCD_Allocate(PVOID, PVOID pvContext);
VOID			RCD_Get(PVOID, PVOID pvContext);
VOID			RCD_Release(PVOID);
VOID			RCD_Free(PVOID);


#ifdef DBG
extern CBilink		g_blProtocolCritSecsHeld;
#endif // DBG

// Internal function prototypes /////////////////////////////////

// Timers
VOID CALLBACK	ConnectRetryTimeout(void * const pvUser, void * const pvHandle, const UINT uiUnique);
VOID CALLBACK	DelayedAckTimeout(void * const pvUser, void * const uID, const UINT uMsg);
VOID CALLBACK	EndPointBackgroundProcess(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique);
VOID CALLBACK	RetryTimeout(void * const pvUser, void * const uID, const UINT Unique);
VOID CALLBACK	ScheduledSend(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique);
VOID CALLBACK	TimeoutSend(void * const pvUser, void * const uID, const UINT uMsg);
VOID CALLBACK 	HardDisconnectResendTimeout(void * const pvUser, void * const pvTimerData, const UINT uiTimerUnique);


VOID				AbortSendsOnConnection(PEPD);
SPRECEIVEDBUFFER * 	AbortRecvsOnConnection(PEPD);
VOID			CancelEpdTimers(PEPD);
ULONG WINAPI 	BackgroundThread(PVOID);
HRESULT			DoCancel(PMSD, HRESULT);
VOID 			CompleteConnect(PMSD, PSPD, PEPD, HRESULT);
VOID			CompleteDisconnect(PMSD pMSD, PSPD pSPD, PEPD pEPD);
VOID 			CompleteHardDisconnect(PEPD pEPD);
VOID 			CompleteDatagramSend(PSPD, PMSD, HRESULT);
VOID			CompleteReliableSend(PSPD, PMSD, HRESULT);
VOID			CompleteSPConnect(PMSD, PSPD, HRESULT);
VOID			DisconnectConnection(PEPD);
VOID			DropLink(PEPD);
PMSD			BuildDisconnectFrame(PEPD);
VOID			EndPointDroppedFrame(PEPD, DWORD);
VOID			EnqueueMessage(PMSD, PEPD);
VOID 			FlushCheckPoints(PEPD);
VOID 			InitLinkParameters(PEPD, UINT, DWORD);
PCHKPT			LookupCheckPoint(PEPD, BYTE);
PEPD			NewEndPoint(PSPD, HANDLE);
VOID			SendKeepAlive(PEPD pEPD);
VOID			ReceiveComplete(PEPD);
VOID			SendAckFrame(PEPD, BOOL, BOOL fFinalAck = FALSE);
HRESULT			SendCommandFrame(PEPD, BYTE, BYTE, ULONG, BOOL);
HRESULT 		SendConnectedSignedFrame(PEPD pEPD, CFRAME_CONNECTEDSIGNED * pCFrameRecv, DWORD tNow);
ULONG WINAPI 	SendThread(PVOID);
VOID			ServiceCmdTraffic(PSPD);
VOID			ServiceEPD(PSPD, PEPD);
VOID 			UpdateEndPoint(PEPD, UINT, DWORD);
VOID			UpdateXmitState(PEPD, BYTE, ULONG, ULONG, DWORD);
VOID			RejectInvalidPacket(PEPD);

ULONGLONG GenerateConnectSig(DWORD dwSessID, DWORD dwAddressHash, ULONGLONG ullConnectSecret);
ULONGLONG GenerateOutgoingFrameSig(PFMD pFMD, ULONGLONG ullSecret);
ULONGLONG GenerateIncomingFrameSig(BYTE * pbyFrame, DWORD dwFrameSize, ULONGLONG ullSecret);
ULONGLONG GenerateNewSecret(ULONGLONG ullCurrentSecret, ULONGLONG ullSecretModifier);
ULONGLONG GenerateLocalSecretModifier(BUFFERDESC * pBuffers, DWORD dwNumBuffers);
ULONGLONG GenerateRemoteSecretModifier(BYTE * pbyData, DWORD dwDataSize);

	//returns TRUE if supplied protocol version number indicates signing is supported
inline BOOL VersionSupportsSigning(DWORD dwVersion)
{
	return (((dwVersion>>16)==1) && ((dwVersion & 0xFFFF) >= (DNET_SIGNING_VERSION & 0xFFFF)));
}

	//returns TRUE if supplied protocol version number indicates coalescence is supported
inline BOOL VersionSupportsCoalescence(DWORD dwVersion)
{
	return (((dwVersion>>16)==1) && ((dwVersion & 0xFFFF) >= (DNET_COALESCE_VERSION & 0xFFFF)));
}

#ifndef DPNBUILD_NOPROTOCOLTESTITF
extern PFNASSERTFUNC g_pfnAssertFunc;
extern PFNMEMALLOCFUNC g_pfnMemAllocFunc;
#endif // !DPNBUILD_NOPROTOCOLTESTITF

//	Internal Macro definitions

#undef ASSERT

#ifndef DBG
#define	ASSERT(EXP)		DNASSERT(EXP)
#else // DBG
#define	ASSERT(EXP) \
	if (!(EXP)) \
	{ \
		if (g_pfnAssertFunc) \
		{ \
			g_pfnAssertFunc(#EXP); \
		} \
		DNASSERT(EXP); \
	}
#endif // !DBG

#ifdef DPNBUILD_NOPROTOCOLTESTITF

#define MEMALLOC(memid, dwpSize) DNMalloc(dwpSize)
#define POOLALLOC(memid, pool) (pool)->Get()

#else // !DPNBUILD_NOPROTOCOLTESTITF

#define MEMALLOC(memid, dwpSize) MemAlloc(memid, dwpSize)
#define POOLALLOC(memid, pool) PoolAlloc(memid, pool)
__inline VOID* MemAlloc(ULONG ulAllocID, DWORD_PTR dwpSize)
{
	if (g_pfnMemAllocFunc)
	{
		if (!g_pfnMemAllocFunc(ulAllocID))
		{
			return NULL;
		}
	}
	return DNMalloc(dwpSize);
}		
__inline VOID* PoolAlloc(ULONG ulAllocID, CFixedPool* pPool)
{
	if (g_pfnMemAllocFunc)
	{
		if (!g_pfnMemAllocFunc(ulAllocID))
		{
			return NULL;
		}
	}
	return pPool->Get();
}

#endif // DPNBUILD_NOPROTOCOLTESTITF

#define	Lock(P)			DNEnterCriticalSection(P)
#define	Unlock(P)		DNLeaveCriticalSection(P)

#define	ASSERT_PPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == PPD_SIGN)
#define	ASSERT_SPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == SPD_SIGN)
#define	ASSERT_EPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == EPD_SIGN)
#define	ASSERT_MSD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == MSD_SIGN)
#define	ASSERT_FMD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == FMD_SIGN)
#define	ASSERT_RCD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == RCD_SIGN)

#define	INTER_INC(PTR)	DNInterlockedIncrement(&(PTR)->lRefCnt)
#define	INTER_DEC(PTR)	DNInterlockedDecrement(&(PTR)->lRefCnt)

#ifdef DBG

VOID	LockEPD(PEPD, PTSTR);
VOID	ReleaseEPD(PEPD, PTSTR);
VOID	DecrementEPD(PEPD, PTSTR);
VOID	LockMSD(PMSD, PTSTR);
VOID	ReleaseMSD(PMSD, PTSTR);
VOID	DecrementMSD(PMSD, PTSTR);
VOID	ReleaseFMD(PFMD, PTSTR);
VOID	LockFMD(PFMD, PTSTR);

#define	LOCK_EPD(a, b)				LockEPD(a, _T(b))
#define	RELEASE_EPD(a, b)			ReleaseEPD(a, _T(b))
#define	DECREMENT_EPD(a, b)			DecrementEPD(a, _T(b))
#define	LOCK_MSD(a, b)				LockMSD(a, _T(b))
#define RELEASE_MSD(a, b)			ReleaseMSD(a, _T(b))
#define DECREMENT_MSD(a, b)			DecrementMSD(a, _T(b))
#define	RELEASE_FMD(a, b)			ReleaseFMD(a, _T(b))
#define	LOCK_FMD(a, b)				LockFMD(a, _T(b))

#else // !DBG

VOID	LockEPD(PEPD);
VOID	ReleaseEPD(PEPD);
VOID	DecrementEPD(PEPD);
VOID	LockMSD(PMSD);
VOID	ReleaseMSD(PMSD);
VOID	DecrementMSD(PMSD);
VOID	ReleaseFMD(PFMD);
VOID	LockFMD(PFMD);

#define	LOCK_EPD(a, b)				LockEPD(a)
#define	RELEASE_EPD(a, b)			ReleaseEPD(a)
#define	DECREMENT_EPD(a, b)			DecrementEPD(a)
#define	LOCK_MSD(a, b)				LockMSD(a)
#define RELEASE_MSD(a, b)			ReleaseMSD(a)
#define DECREMENT_MSD(a, b)			DecrementMSD(a)
#define	RELEASE_FMD(a, b)			ReleaseFMD(a)
#define	LOCK_FMD(a, b)				LockFMD(a)

#endif // DBG

#define	LOCK_RCD(PTR)		(INTER_INC(PTR))
#define	RELEASE_RCD(PTR)	ASSERT((PTR)->lRefCnt > 0); if( INTER_DEC(PTR) == 0) { RCDPool.Release((PTR)); }

// This links the passed in pRcvBuff onto a passed in list
#define	RELEASE_SP_BUFFER(LIST, PTR) if((PTR) != NULL) { (PTR)->pNext = (LIST); (LIST) = (PTR); (PTR) = NULL;}

#define	RIGHT_SHIFT_64(HIGH_MASK, LOW_MASK) { ((LOW_MASK) >>= 1); if((HIGH_MASK) & 1){ (LOW_MASK) |= 0x80000000; } ((HIGH_MASK) >>= 1); }

//	CONVERT TO AND FROM 16.16 FIXED POINT REPRESENTATION

#define	TO_FP(X)		(((X) << 16) & 0xFFFF0000)
#define	FP_INT(X)		(((X) >> 16) & 0x0000FFFF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\lower_mn.cpp ===
#include "dnproti.h"


//	Now, a little bit of probably unnecesary junk for our lower edge

/*
 * DNSP_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

STDMETHODIMP DNSP_QueryInterface(
				IDP8SPCallback	*pDNPI,
                REFIID riid,
                LPVOID *ppvObj )
{
	HRESULT		hr = S_OK;


#ifndef DPNBUILD_LIBINTERFACE
	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8SPCallback)))
	{
		*ppvObj = NULL;
		hr = E_NOINTERFACE;		
	}
	else
#endif // ! DPNBUILD_LIBINTERFACE
	{
#ifdef DPNBUILD_LIBINTERFACE
		DNASSERT(! "Querying interface when using DPNBUILD_LIBINTERFACE!");
#endif // DPNBUILD_LIBINTERFACE
		*ppvObj = pDNPI;
	}

	return hr;
}

/*
 * DNP_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8SPCallback *pDNPI)
{
    return 1;
}

/*
 * DNP_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8SPCallback *pDNPI )
{
	return 1;
}

IDP8SPCallbackVtbl DNPLowerEdgeVtbl =
{
        DNSP_QueryInterface,
        DNSP_AddRef,
        DNSP_Release,
		DNSP_IndicateEvent,
		DNSP_CommandComplete
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\initialize.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Initialize.cpp
 *  Content:	This file contains code to both initialize and shutdown the
 *				protocol,  as well as to Add and Remove service providers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/*
**		GLOBAL VARIABLES
**
**			There are two kinds of global variables.  Instance specific globals
**	(not really global,  i know) which are members of the ProtocolData structure,
**	and true globals which are shared among all instances.  The following
**	definitions are true globals,  such as FixedPools and Timers.
*/

CFixedPool			ChkPtPool;		// Pool of CheckPoint data structure
CFixedPool			EPDPool;		// Pool of End Point descriptors
CFixedPool			MSDPool;		// Pool of Message Descriptors
CFixedPool			FMDPool;		// Pool of Frame Descriptors
CFixedPool			RCDPool;		// Pool of Receive Descriptors

CFixedPool			BufPool;		// Pool of buffers to store rcvd frames
CFixedPool			MedBufPool;
CFixedPool			BigBufPool;

#ifdef DBG
CBilink				g_blProtocolCritSecsHeld;
#endif // DBG

#ifndef DPNBUILD_NOPROTOCOLTESTITF
PFNASSERTFUNC g_pfnAssertFunc = NULL;
PFNMEMALLOCFUNC g_pfnMemAllocFunc = NULL;
#endif // !DPNBUILD_NOPROTOCOLTESTITF


//////////////////////////////////
#define CHKPTPOOL_INITED	0x00000001
#define EPDPOOL_INITED		0x00000002
#define MSDPOOL_INITED		0x00000004
#define FMDPOOL_INITED		0x00000008
#define RCDPOOL_INITED		0x00000010
#define BUFPOOL_INITED		0x00000020
#define MEDBUFPOOL_INITED	0x00000040
#define BIGBUFPOOL_INITED	0x00000080

DWORD			g_dwProtocolInitFlags = 0;
//////////////////////////////////


/*
**		Pools Initialization
**
**		This procedure should be called once at Dll load
*/
#undef DPF_MODNAME
#define DPF_MODNAME "DNPPoolsInit"

BOOL  DNPPoolsInit(HANDLE hModule)
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Enter");

#ifdef DBG
	g_blProtocolCritSecsHeld.Initialize();
#endif // DBG

	if(!ChkPtPool.Initialize(sizeof(CHKPT), NULL, NULL, NULL, NULL))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= CHKPTPOOL_INITED;
	if(!EPDPool.Initialize(sizeof(EPD), EPD_Allocate, EPD_Get, EPD_Release, EPD_Free))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= EPDPOOL_INITED;
	if(!MSDPool.Initialize(sizeof(MSD), MSD_Allocate, MSD_Get, MSD_Release, MSD_Free))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= MSDPOOL_INITED;
	if(!FMDPool.Initialize(sizeof(FMD), FMD_Allocate, FMD_Get, FMD_Release, FMD_Free))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= FMDPOOL_INITED;
	if(!RCDPool.Initialize(sizeof(RCD), RCD_Allocate, RCD_Get, RCD_Release, RCD_Free))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= RCDPOOL_INITED;
	if(!BufPool.Initialize(sizeof(BUF), Buf_Allocate, Buf_Get, NULL, NULL))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= BUFPOOL_INITED;
	if(!MedBufPool.Initialize(sizeof(MEDBUF), Buf_Allocate, Buf_GetMed, NULL, NULL))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= MEDBUFPOOL_INITED;
	if(!BigBufPool.Initialize(sizeof(BIGBUF), Buf_Allocate, Buf_GetBig, NULL, NULL))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_dwProtocolInitFlags |= BIGBUFPOOL_INITED;

    return TRUE;
}

/*
**		Pools Deinitialization
**
**		This procedure should be called by DllMain at shutdown time
*/
#undef DPF_MODNAME
#define DPF_MODNAME "DNPPoolsDeinit"

void  DNPPoolsDeinit()
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Enter");

	if(g_dwProtocolInitFlags & CHKPTPOOL_INITED)
	{
		ChkPtPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & EPDPOOL_INITED)
	{
		EPDPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & MSDPOOL_INITED)
	{
		MSDPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & FMDPOOL_INITED)
	{
		FMDPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & RCDPOOL_INITED)
	{
		RCDPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & BUFPOOL_INITED)
	{
		BufPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & MEDBUFPOOL_INITED)
	{
		MedBufPool.DeInitialize();
	}
	if(g_dwProtocolInitFlags & BIGBUFPOOL_INITED)
	{
		BigBufPool.DeInitialize();
	}
	g_dwProtocolInitFlags = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolCreate"

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT DNPProtocolCreate(const XDP8CREATE_PARAMS * const pDP8CreateParams, VOID** ppvProtocol)
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT DNPProtocolCreate(VOID** ppvProtocol)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	ASSERT(ppvProtocol);

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	ASSERT(pDP8CreateParams);
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pDP8CreateParams[%p], ppvProtocol[%p]", pDP8CreateParams, ppvProtocol);
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: ppvProtocol[%p]", ppvProtocol);
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifndef DPNBUILD_NOPROTOCOLTESTITF
	g_pfnAssertFunc = NULL;
	g_pfnMemAllocFunc = NULL;
#endif // !DPNBUILD_NOPROTOCOLTESTITF

	if ((*ppvProtocol = MEMALLOC(MEMID_PPD, sizeof(ProtocolData))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		return(E_OUTOFMEMORY);
	}
	memset(*ppvProtocol, 0, sizeof(ProtocolData));

	// The sign needs to be valid by the time DNPProtocolInitialize is called
	((ProtocolData*)*ppvProtocol)->Sign = PPD_SIGN;
	
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DWORD	dwNumToAllocate;
	DWORD	dwAllocated;

#ifdef _XBOX
#define MAX_FRAME_SIZE		1462	// Note we are hard coding the expected frame size.
#else // ! _XBOX
#define MAX_FRAME_SIZE		1472	// Note we are hard coding the expected frame size.
#endif // ! _XBOX

	dwNumToAllocate = (pDP8CreateParams->dwMaxNumPlayers - 1);
	dwAllocated = ChkPtPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u checkpoints!", dwAllocated, dwNumToAllocate);
		DNFree(*ppvProtocol);
		*ppvProtocol = NULL;
		return(E_OUTOFMEMORY);
	}

	dwNumToAllocate = (pDP8CreateParams->dwMaxNumPlayers - 1);
	dwAllocated = EPDPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u EPDs!", dwAllocated, dwNumToAllocate);
		DNFree(*ppvProtocol);
		*ppvProtocol = NULL;
		return(E_OUTOFMEMORY);
	}

	dwNumToAllocate = pDP8CreateParams->dwMaxSendsPerPlayer
						* (pDP8CreateParams->dwMaxNumPlayers - 1);
	dwNumToAllocate += pDP8CreateParams->dwNumSimultaneousEnumHosts;
	dwNumToAllocate += 1; // one for a listen operation
	dwAllocated = MSDPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u MSDs!", dwAllocated, dwNumToAllocate);
		DNFree(*ppvProtocol);
		*ppvProtocol = NULL;
		return(E_OUTOFMEMORY);
	}

	dwNumToAllocate = pDP8CreateParams->dwMaxSendsPerPlayer
						* (pDP8CreateParams->dwMaxNumPlayers - 1);
	// Include the possiblity of having to split a message across multiple frames.
	dwNumToAllocate *= pDP8CreateParams->dwMaxMessageSize / MAX_FRAME_SIZE;
	dwNumToAllocate += pDP8CreateParams->dwNumSimultaneousEnumHosts;
	dwAllocated = FMDPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u FMDs!", dwAllocated, dwNumToAllocate);
		DNFree(*ppvProtocol);
		*ppvProtocol = NULL;
		return(E_OUTOFMEMORY);
	}

	dwNumToAllocate = pDP8CreateParams->dwMaxReceivesPerPlayer
						* (pDP8CreateParams->dwMaxNumPlayers - 1);
	dwAllocated = RCDPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u RCDs!", dwAllocated, dwNumToAllocate);
		DNFree(*ppvProtocol);
		*ppvProtocol = NULL;
		return(E_OUTOFMEMORY);
	}

	if (pDP8CreateParams->dwMaxMessageSize > MAX_FRAME_SIZE)
	{
		dwNumToAllocate = pDP8CreateParams->dwMaxReceivesPerPlayer
							* (pDP8CreateParams->dwMaxNumPlayers - 1);
		dwAllocated = BufPool.Preallocate(dwNumToAllocate, NULL);
		if (dwAllocated < dwNumToAllocate)
		{
			DPFX(DPFPREP, 0, "Only allocated %u of %u small receive buffers!", dwAllocated, dwNumToAllocate);
			DNFree(*ppvProtocol);
			*ppvProtocol = NULL;
			return(E_OUTOFMEMORY);
		}

		if (pDP8CreateParams->dwMaxMessageSize > MEDIUM_BUFFER_SIZE)
		{
			dwNumToAllocate = pDP8CreateParams->dwMaxReceivesPerPlayer
								* (pDP8CreateParams->dwMaxNumPlayers - 1);
			dwAllocated = MedBufPool.Preallocate(dwNumToAllocate, NULL);
			if (dwAllocated < dwNumToAllocate)
			{
				DPFX(DPFPREP, 0, "Only allocated %u of %u medium receive buffers!", dwAllocated, dwNumToAllocate);
				DNFree(*ppvProtocol);
				*ppvProtocol = NULL;
				return(E_OUTOFMEMORY);
			}

			if (pDP8CreateParams->dwMaxMessageSize > LARGE_BUFFER_SIZE)
			{
				dwNumToAllocate = pDP8CreateParams->dwMaxReceivesPerPlayer
									* (pDP8CreateParams->dwMaxNumPlayers - 1);
				dwAllocated = BigBufPool.Preallocate(dwNumToAllocate, NULL);
				if (dwAllocated < dwNumToAllocate)
				{
					DPFX(DPFPREP, 0, "Only allocated %u of %u big receive buffers!", dwAllocated, dwNumToAllocate);
					DNFree(*ppvProtocol);
					*ppvProtocol = NULL;
					return(E_OUTOFMEMORY);
				}
			}
		}
	} // end if (messages may span multiple frames)
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolDestroy"

VOID DNPProtocolDestroy(VOID* pvProtocol)
{
	if (pvProtocol)
	{
		DNFree(pvProtocol);
	}
}

/*
**		Protocol Initialize
**
**		This procedure should be called by DirectPlay at startup time before
**	any other calls in the protocol are made.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolInitialize"

HRESULT DNPProtocolInitialize(HANDLE hProtocolData, PVOID pCoreContext, PDN_PROTOCOL_INTERFACE_VTBL pVtbl, 
												IDirectPlay8ThreadPoolWork *pDPThreadPoolWork, BOOL bAssumeLANConnections)
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pCoreContext[%p], hProtocolData[%p], pVtbl[%p], pDPThreadPoolWork[%p]", hProtocolData, pCoreContext, pVtbl, pDPThreadPoolWork);

//	DPFX(DPFPREP,0, "Sizes: endpointdesc[%d], framedesc[%d], messagedesc[%d], protocoldata[%d], recvdesc[%d], spdesc[%d], _MyTimer[%d]", sizeof(endpointdesc), sizeof(framedesc), sizeof(messagedesc), sizeof(protocoldata), sizeof(recvdesc), sizeof(spdesc), sizeof(_MyTimer));

	ProtocolData* pPData;

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	IDirectPlay8ThreadPoolWork_AddRef(pDPThreadPoolWork);
	pPData->pDPThreadPoolWork = pDPThreadPoolWork;

	pPData->ulProtocolFlags = 0;
	pPData->Parent = pCoreContext;
	pPData->pfVtbl = pVtbl;

	pPData->lSPActiveCount = 0;
	
	pPData->tIdleThreshhold = DEFAULT_KEEPALIVE_INTERVAL;	// 60 second keep-alive interval
	pPData->dwConnectTimeout = CONNECT_DEFAULT_TIMEOUT;
	pPData->dwConnectRetries = CONNECT_DEFAULT_RETRIES;
	pPData->dwMaxRecvMsgSize=DEFAULT_MAX_RECV_MSG_SIZE;
	pPData->dwSendRetriesToDropLink=DEFAULT_SEND_RETRIES_TO_DROP_LINK;
	pPData->dwSendRetryIntervalLimit=DEFAULT_SEND_RETRY_INTERVAL_LIMIT;
	pPData->dwNumHardDisconnectSends=DEFAULT_HARD_DISCONNECT_SENDS;
	pPData->dwMaxHardDisconnectPeriod=DEFAULT_HARD_DISCONNECT_MAX_PERIOD;
	pPData->dwInitialFrameWindowSize = bAssumeLANConnections ? 
											LAN_INITIAL_FRAME_WINDOW_SIZE : DEFAULT_INITIAL_FRAME_WINDOW_SIZE;

	pPData->dwDropThresholdRate = DEFAULT_THROTTLE_THRESHOLD_RATE;
	pPData->dwDropThreshold = (32 * DEFAULT_THROTTLE_THRESHOLD_RATE) / 100;
	pPData->dwThrottleRate = DEFAULT_THROTTLE_BACK_OFF_RATE;
	pPData->fThrottleRate = (100.0 - (FLOAT)DEFAULT_THROTTLE_BACK_OFF_RATE) / 100.0;
	DPFX(DPFPREP, 2, "pPData->fThrottleRate [%f]", pPData->fThrottleRate);

#ifdef DBG
	pPData->ThreadsInReceive = 0;
	pPData->BuffersInReceive = 0;
#endif // DBG
	
	pPData->ulProtocolFlags |= PFLAGS_PROTOCOL_INITIALIZED;

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return DPN_OK;
}

/*
**		Protocol Shutdown
**
**		This procedure should be called at termination time,  and should be the
**	last call made to the protocol.
**
**		All SPs should have been removed prior to this call which in turn means
**	that we should not have any sends pending in a lower layer.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolShutdown"

HRESULT DNPProtocolShutdown(HANDLE hProtocolData)
{
	ProtocolData* pPData;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p]", hProtocolData);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	ASSERT(pPData->lSPActiveCount == 0);

	IDirectPlay8ThreadPoolWork_Release(pPData->pDPThreadPoolWork);
	pPData->pDPThreadPoolWork = NULL;
	
#ifdef DBG
	if (pPData->BuffersInReceive != 0)
	{
		DPFX(DPFPREP,0, "*** %d receive buffers were leaked", pPData->BuffersInReceive);	
	}
#endif // DBG

	pPData->ulProtocolFlags = 0;

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return DPN_OK;
}

/*
**		Add Service Provider
**
**		This procedure is called by Direct Play to bind us to a service provider.
**	We can bind up to 256 service providers at one time,  although I would not ever
**	expect to do so.  This procedure will fail if Protocol Initialize has not
**	been called.
**
**
**		We check the size of the SP table to make sure we have a slot free.  If table
**	is full we double the table size until we reach maximum size.  If table cannot grow
**	then we fail the AddServiceProvider call.
*/

extern	IDP8SPCallbackVtbl DNPLowerEdgeVtbl;

#undef DPF_MODNAME
#define DPF_MODNAME "DNPAddServiceProvider"

HRESULT 
DNPAddServiceProvider(HANDLE hProtocolData, IDP8ServiceProvider* pISP, 
											HANDLE* phSPContext, DWORD dwFlags)
{
	ProtocolData*		pPData;
	PSPD				pSPD;
	SPINITIALIZEDATA	SPInitData;
	SPGETCAPSDATA		SPCapsData;
	HRESULT				hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], pISP[%p], phSPContext[%p]", hProtocolData, pISP, phSPContext);

	hr = DPN_OK;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	if(pPData->ulProtocolFlags & PFLAGS_PROTOCOL_INITIALIZED)
	{
		if ((pSPD = (PSPD)MEMALLOC(MEMID_SPD, sizeof(SPD))) == NULL)
		{
			DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - couldn't allocate SP Descriptor");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}

		// MAKE THE INITIALIZE CALL TO THE Service Provider...  give him our Object

		memset(pSPD, 0, sizeof(SPD));				// init to zero

		pSPD->LowerEdgeVtable = &DNPLowerEdgeVtbl;	// Put Vtbl into the interface Object
		pSPD->Sign = SPD_SIGN;

		SPInitData.pIDP = (IDP8SPCallback *) pSPD;
		SPInitData.dwFlags = dwFlags;

		if (DNInitializeCriticalSection(&pSPD->SPLock) == FALSE)
		{
			DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - couldn't initialize SP CS, pSPD[%p]", pSPD);
			DNFree(pSPD);
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}
		DebugSetCriticalSectionRecursionCount(&pSPD->SPLock, 0);
		DebugSetCriticalSectionGroup(&pSPD->SPLock, &g_blProtocolCritSecsHeld);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Initialize, pSPD[%p]", pSPD);
		if((hr = IDP8ServiceProvider_Initialize(pISP, &SPInitData)) != DPN_OK)
		{
			if (hr == DPNERR_UNSUPPORTED)
			{
				DPFX(DPFPREP,1, "SP unsupported, pSPD[%p]", pSPD);
			}
			else
			{
				DPFX(DPFPREP,0, "Returning hr=%x - SP->Initialize failed, pSPD[%p]", hr, pSPD);
			}
			DNDeleteCriticalSection(&pSPD->SPLock);
			DNFree(pSPD);
			goto Exit;
		}

		pSPD->blSendQueue.Initialize();
		pSPD->blPendingQueue.Initialize();
		pSPD->blEPDActiveList.Initialize();
#ifdef DBG
		pSPD->blMessageList.Initialize();
#endif // DBG
		

		// MAKE THE SP GET CAPS CALL TO FIND FRAMESIZE AND LINKSPEED

		SPCapsData.dwSize = sizeof(SPCapsData);
		SPCapsData.hEndpoint = INVALID_HANDLE_VALUE;
		
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->GetCaps, pSPD[%p]", pSPD);
		if((hr = IDP8ServiceProvider_GetCaps(pISP, &SPCapsData)) != DPN_OK)
		{
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "SP->GetCaps failed - hr[%x], Calling SP->Close, pSPD[%p]", hr, pSPD);
			IDP8ServiceProvider_Close(pISP);
			DNDeleteCriticalSection(&pSPD->SPLock);

			DPFX(DPFPREP,0, "Returning hr=%x - SP->GetCaps failed, pSPD[%p]", hr, pSPD);

			DNFree(pSPD);
			goto Exit;
		}

		pSPD->uiLinkSpeed = SPCapsData.dwLocalLinkSpeed;
		pSPD->uiFrameLength = SPCapsData.dwUserFrameSize;
		if (pSPD->uiFrameLength < MIN_SEND_MTU)
		{
			DPFX(DPFPREP,0, "SP MTU isn't large enough to support protocol pSPD[%p] Required MTU[%u] Available MTU[%u] "
											"Returning DPNERR_UNSUPPORTED", pSPD, MIN_SEND_MTU, pSPD->uiFrameLength);
			IDP8ServiceProvider_Close(pISP);
			DNDeleteCriticalSection(&pSPD->SPLock);
			DNFree(pSPD);
			hr=DPNERR_UNSUPPORTED;
			goto Exit;
		}
		pSPD->uiUserFrameLength = pSPD->uiFrameLength - MAX_SEND_DFRAME_NOCOALESCE_HEADER_SIZE;
		DPFX(DPFPREP, 3, "SPD 0x%p frame length = %u, single user frame length = %u.", pSPD, pSPD->uiFrameLength, pSPD->uiUserFrameLength);

		//	Place new SP in table

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->AddRef, pSPD[%p]", pSPD);
		IDP8ServiceProvider_AddRef(pISP);
		pSPD->IISPIntf = pISP;
		pSPD->pPData = pPData;
		DNInterlockedIncrement(&pPData->lSPActiveCount);
	}
	else
	{
		pSPD = NULL;

		DPFX(DPFPREP,0, "Returning DPNERR_UNINITIALIZED - DNPProtocolInitialize has not been called");
		hr = DPNERR_UNINITIALIZED;
		goto Exit;
	}

	*phSPContext = pSPD;

Exit:
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}

/*
**		Remove Service Provider
**
**			It is higher layer's responsibility to make sure that there are no pending commands
**		when this function is called,  although we can do a certain amount of cleanup ourselves.
**		For the moment we will ASSERT that everything is in fact finished up.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPRemoveServiceProvider"

HRESULT DNPRemoveServiceProvider(HANDLE hProtocolData, HANDLE hSPHandle)
{
	ProtocolData*	pPData;
	PSPD			pSPD;
	PFMD			pFMD;
	DWORD			dwInterval;

#ifdef DBG
	PEPD			pEPD;
	PMSD			pMSD;
#endif // DBG

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hSPHandle[%x]", hProtocolData, hSPHandle);

	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// There are several steps to shutdown:
	// 1. All Core initiated commands must be cancelled prior to this function being called.
	//    We will assert in debug that the Core has done this.
	// 2. All endpoints must be terminated by the Core prior to this function being called.
	//    We will assert in debug that the Core has done this.
	// Now there are things on the SPD->SendQueue and SPD->PendingQueue that are not owned
	// by any Command or Endpoint, and there may also be a SendThread Timer running held
	// on SPD->SendHandle.  No one else can clean these up, so these are our responsibility
	// to clean up here.  Items on the queues will be holding references to EPDs, so the 
	// EPDs will not be able to go away until we do this.
	// 3. Cancel SPD->SendHandle Send Timer.  This prevents items on the SendQueue from
	//    being submitted to the SP and moved to the PendingQueue.
	// 4. Empty the SendQueue.
	// 5. If we fail to cancel the SendHandle Send Timer, wait for it to run and figure out
	//    that we are going away.  We do this after emptying the SendQueue for simplicity
	//    since the RunSendThread code checks for an empty SendQueue to know if it has work
	//    to do.
	// 6. Wait for all messages to drain from the PendingQueue as the SP completes them.
	// 7. Wait for any active EPDs to go away.
	// 8. Call SP->Close only after all of the above so that we can ensure that we will make
	//    no calls to the SP after Close.

	Lock(&pSPD->SPLock);
	pSPD->ulSPFlags |= SPFLAGS_TERMINATING;				// Nothing new gets in...

#ifdef DBG

	// Check for uncancelled commands, SPLock held
	CBilink* pLink = pSPD->blMessageList.GetNext();
	while (pLink != &pSPD->blMessageList)
	{
		pMSD = CONTAINING_OBJECT(pLink, MSD, blSPLinkage);
		ASSERT_MSD(pMSD);
		ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST);
		DPFX(DPFPREP,0, "There are un-cancelled commands remaining on the Command List, Core didn't clean up properly - pMSD[%p], Context[%x]", pMSD, pMSD->Context);
		ASSERT(0); // This is fatal, we can't make the guarantees we need to below under these conditions.

		pLink = pLink->GetNext();
	}

	// Check for EPDs that have not been terminated, SPLock still held
	pLink = pSPD->blEPDActiveList.GetNext();
	while (pLink != &pSPD->blEPDActiveList)
	{
		pEPD = CONTAINING_OBJECT(pLink, EPD, blActiveLinkage);
		ASSERT_EPD(pEPD);

		if (!(pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING))
		{
			DPFX(DPFPREP,0, "There are non-terminated endpoints remaining on the Endpoint List, Core didn't clean up properly - pEPD[%p], Context[%x]", pEPD, pEPD->Context);
			ASSERT(0); // This is fatal, we can't make the guarantees we need to below under these conditions.
		}

		pLink = pLink->GetNext();
	}

#endif // DBG

	// Clean off the Send Queue, SPLock still held
	while(!pSPD->blSendQueue.IsEmpty())
	{
		pFMD = CONTAINING_OBJECT(pSPD->blSendQueue.GetNext(), FMD, blQLinkage);
		ASSERT_FMD(pFMD);

		ASSERT_EPD(pFMD->pEPD);

		DPFX(DPFPREP,1, "Cleaning FMD off of SendQueue pSPD[%p], pFMD[%p], pEPD[%p]", pSPD, pFMD, pFMD->pEPD);

		pFMD->blQLinkage.RemoveFromList();

		// RELEASE_EPD will need to have the EPD lock, so we cannot hold the SPLock while calling it.
		Unlock(&pSPD->SPLock);

		Lock(&pFMD->pEPD->EPLock);
		RELEASE_EPD(pFMD->pEPD, "UNLOCK (Releasing Leftover CMD FMD)"); // releases EPLock
		RELEASE_FMD(pFMD, "SP Submit");

		Lock(&pSPD->SPLock);
	}

	// In case we failed to cancel the SendHandle Timer above, wait for the send thread to run and figure
	// out that we are going away.  We want to be outside the SPLock while doing this.
	dwInterval = 10;
	while(pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)
	{
		Unlock(&pSPD->SPLock);
		IDirectPlay8ThreadPoolWork_SleepWhileWorking(pPData->pDPThreadPoolWork, dwInterval, 0);
		dwInterval += 5;
		ASSERT(dwInterval < 500);
		Lock(&pSPD->SPLock);
	}

	// Clean off the Pending Queue, SPLock still held
	dwInterval = 10;
	while (!pSPD->blPendingQueue.IsEmpty())
	{
		Unlock(&pSPD->SPLock);
		IDirectPlay8ThreadPoolWork_SleepWhileWorking(pPData->pDPThreadPoolWork, dwInterval, 0);
		dwInterval += 5;
		ASSERT(dwInterval < 500);
		Lock(&pSPD->SPLock);
	}

	// By now we are only waiting for the SP to do any final calls to CommandComplete that are needed to take
	// our EPD ref count down to nothing.  We will wait while the SP does this.
	dwInterval = 10;
	while(!(pSPD->blEPDActiveList.IsEmpty()))
	{
		Unlock(&pSPD->SPLock);
		IDirectPlay8ThreadPoolWork_SleepWhileWorking(pPData->pDPThreadPoolWork, dwInterval, 0);
		dwInterval += 5;
		ASSERT(dwInterval < 500);
		Lock(&pSPD->SPLock);
	}

	// By this time everything pending had better be gone!
	ASSERT(pSPD->blEPDActiveList.IsEmpty());	// Should not be any Endpoints left
	ASSERT(pSPD->blSendQueue.IsEmpty());		// Should not be any frames on sendQ.
	ASSERT(pSPD->blPendingQueue.IsEmpty());		// Should not be any frame in SP either

	// Leave SPLock for the last time
	Unlock(&pSPD->SPLock);

	// Now that all frames are cleared out of SP,  there should be no more End Points waiting around to close.
	// We are clear to tell the SP to go away.

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Close, pSPD[%p]", pSPD);
	IDP8ServiceProvider_Close(pSPD->IISPIntf);
	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Release, pSPD[%p]", pSPD);
	IDP8ServiceProvider_Release(pSPD->IISPIntf);

	// Clean up the SPD object
	DNDeleteCriticalSection(&pSPD->SPLock);
	DNFree(pSPD);

	// Remove the reference of this SP from the main Protocol object
	ASSERT(pPData->lSPActiveCount > 0);
	DNInterlockedDecrement(&pPData->lSPActiveCount);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\receive.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Receive.cpp
 *  Content:	This file contains code which receives indications of incoming data
 *				from a ServiceProvider,  cracks the data,  and handles it appropriately.
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


// local protos

BOOL	CancelFrame(PEPD, BYTE, DWORD tNow, PSPRECEIVEDBUFFER* ppRcvBuffToFree);
VOID	CompleteSends(PEPD);
VOID 	DropReceive(PEPD, PRCD, PSPRECEIVEDBUFFER* ppRcvBuffToFree);
HRESULT IndicateReceive(PSPD, PSPIE_DATA);
#ifndef DPNBUILD_NOMULTICAST
HRESULT IndicateReceiveUnknownSender(PSPD, PSPIE_DATA_UNKNOWNSENDER);
#endif // ! DPNBUILD_NOMULTICAST
HRESULT	ProcessUnconnectedData(PSPD, PSPIE_DATA_UNCONNECTED);
HRESULT	IndicateConnect(PSPD, PSPIE_CONNECT);
HRESULT	ProcessEnumQuery( PSPD, PSPIE_QUERY );
HRESULT	ProcessQueryResponse( PSPD, PSPIE_QUERYRESPONSE );
VOID	ProcessConnectedResponse(PSPD, PEPD, PCFRAME, DWORD);
VOID 	ProcessConnectedSignedResponse(PSPD, PEPD, CFRAME_CONNECTEDSIGNED * , DWORD);
VOID	ProcessConnectRequest(PSPD, PEPD, PCFRAME);
VOID	ProcessEndOfStream(PEPD);
VOID	ProcessListenStatus(PSPD, PSPIE_LISTENSTATUS);
VOID	ProcessConnectAddressInfo(PSPD, PSPIE_CONNECTADDRESSINFO);
VOID	ProcessEnumAddressInfo(PSPD, PSPIE_ENUMADDRESSINFO);
VOID	ProcessListenAddressInfo(PSPD, PSPIE_LISTENADDRESSINFO);
VOID	ProcessSendMask(PEPD, BYTE, ULONG, ULONG, DWORD tNow, PSPRECEIVEDBUFFER* ppRcvBuffToFree);
VOID	ProcessSPDisconnect(PSPD, PSPIE_DISCONNECT);
VOID 	ReceiveInOrderFrame(PEPD, PRCD, PSPRECEIVEDBUFFER* ppRcvBuffToFree);
VOID 	ReceiveOutOfOrderFrame(PEPD, PRCD, ULONG, PSPRECEIVEDBUFFER* ppRcvBuffToFree);
VOID 	ProcessHardDisconnect(PEPD);
HRESULT	CreateConnectedSignedReply(void * pvReplyBuffer, DWORD * pdwReplySize, DWORD dwSessID, DWORD dwAddressHash,
											ULONGLONG ullConnectSecret, DWORD dwSigningFlags, DWORD tNow);
BOOL ValidateIncomingFrameSig(PEPD pEPD, BYTE * pbyFrame, DWORD dwFrameSize, BYTE bSeq, UNALIGNED ULONGLONG * pullFrameSig);
HRESULT	CrackCommand(PSPD, PEPD, PSPRECEIVEDBUFFER, DWORD, PSPRECEIVEDBUFFER* ppRcvBuffToFree);
HRESULT	CrackDataFrame(PSPD, PEPD, PSPRECEIVEDBUFFER, DWORD, PSPRECEIVEDBUFFER* ppRcvBuffToFree);


/*
** 		GetDFrameMaskHeaderSize
**
**	Returns the size in bytes of the send/sack mask header in a dframe, when give
**	the control byte from the dframe header.
**/

#undef DPF_MODNAME
#define DPF_MODNAME "GetDFrameMaskHeaderSize"

inline DWORD GetDFrameMaskHeaderSize(BYTE bControl)
{
	DWORD dwLen=0;
	if (bControl & PACKET_CONTROL_SACK_MASK1)
	{
		dwLen += sizeof(DWORD);
	}
	if (bControl & PACKET_CONTROL_SACK_MASK2)
	{
		dwLen += sizeof(DWORD);
	}
	if (bControl & PACKET_CONTROL_SEND_MASK1)
	{
		dwLen += sizeof(DWORD);
	}
	if (bControl & PACKET_CONTROL_SEND_MASK2)
	{
		dwLen += sizeof(DWORD);
	}
	return dwLen;
}


 /*
**		Indicate Receive
**
**			Service Provider calls this entry when data arrives on the network.
**		We will quickly validate the frame and then figure what to do with it...
**
**			Poll/Response activity should be handled before data is indicated to
**		clients.  We want to measure the network latency up to delivery,  not including
**		delivery.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_IndicateEvent"

HRESULT WINAPI DNSP_IndicateEvent(IDP8SPCallback *pIDNSP, SP_EVENT_TYPE Opcode, PVOID DataBlock)
{
	HRESULT hr;
	PSPD pSPD;
	
	hr = DPN_OK;
	pSPD = (PSPD)pIDNSP;
	ASSERT_SPD(pSPD);
	
	switch(Opcode)
	{
		case SPEV_DATA:
			hr = IndicateReceive(pSPD, (PSPIE_DATA) DataBlock);
			break;
		case SPEV_CONNECT:
			hr = IndicateConnect(pSPD, (PSPIE_CONNECT) DataBlock);
			break;
		case SPEV_ENUMQUERY:
			hr = ProcessEnumQuery( pSPD, (PSPIE_QUERY) DataBlock );
			break;
		case SPEV_QUERYRESPONSE:
			hr = ProcessQueryResponse( pSPD, (PSPIE_QUERYRESPONSE) DataBlock );
			break;
		case SPEV_DISCONNECT:
			ProcessSPDisconnect(pSPD, (PSPIE_DISCONNECT) DataBlock);
			break;
		case SPEV_LISTENSTATUS:
			ProcessListenStatus(pSPD, (PSPIE_LISTENSTATUS) DataBlock);
			break;
		case SPEV_LISTENADDRESSINFO:
			ProcessListenAddressInfo(pSPD, (PSPIE_LISTENADDRESSINFO) DataBlock);
			break;
		case SPEV_CONNECTADDRESSINFO:
			ProcessConnectAddressInfo(pSPD, (PSPIE_CONNECTADDRESSINFO) DataBlock);
			break;
		case SPEV_ENUMADDRESSINFO:
			ProcessEnumAddressInfo(pSPD, (PSPIE_ENUMADDRESSINFO) DataBlock);
			break;
		case SPEV_DATA_UNCONNECTED:
			hr = ProcessUnconnectedData(pSPD, (PSPIE_DATA_UNCONNECTED) DataBlock);
			break;

#ifndef DPNBUILD_NOMULTICAST
		case SPEV_DATA_UNKNOWNSENDER:
			hr = IndicateReceiveUnknownSender(pSPD, (PSPIE_DATA_UNKNOWNSENDER) DataBlock);
			break;
#endif // ! DPNBUILD_NOMULTICAST

		// SP passed something unexpected
		default:
			DPFX(DPFPREP,0, "Unknown Event indicated by SP");
			ASSERT(0);
			break;
	}

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}


/*
**	Process Unconnected Data
**
**		This event is indicated when the SP receives data from a sender
**	for which we don't have a connected endpoint.  We return DPN_OK to
**	allow the SP to connect an endpoint and indicate the data again off the
**	new endpoint.  Alternatively we can have the SP reply to the sender
**	without allocating an endpoint, or we can return DPNERR_ABORTED to
**	ignore the data.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessUnconnectedData"

HRESULT	ProcessUnconnectedData(PSPD pSPD, PSPIE_DATA_UNCONNECTED pUnconnectedData)
{
	PMSD pMSD = (PMSD) pUnconnectedData->pvListenCommandContext;
	BYTE byPktCommand=*pUnconnectedData->pReceivedData->BufferDesc.pBufferData;
	DWORD dwDataLength = pUnconnectedData->pReceivedData->BufferDesc.dwBufferSize;

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pUnconnectedData[%p] - pMSD[%p]", pSPD, pUnconnectedData, pMSD);

		//if we've been told to remove the service provider we shouldn't process anything else.
		//Tell sp to dump this incoming data
	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		DPFX(DPFPREP, 5, "SP is terminating, returning DPNERR_ABORTED, pSPD[%p]", pSPD);
		return DPNERR_ABORTED;
	}

		//check that we still have a valid listen running to handle this data
	Lock(&pMSD->CommandLock);

		//make sure this actually is a listen command
		//Note sure if its possible for it to be anything else, but we'll code robustly
	if(pMSD->CommandID != COMMAND_ID_LISTEN)
	{
		DPFX(DPFPREP,0, "Received unconnected data and MSD not marked as LISTEN pMSD[%p] "
											"pMSD->CommandID[%u]", pMSD, (DWORD ) pMSD->CommandID);
		DNASSERTX(FALSE, 0);
		Unlock(&pMSD->CommandLock);
		return DPNERR_ABORTED;
	}

		//if the listen has already been cancelled then drop incoming data on the floor
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		DPFX(DPFPREP, 5, "Received unconnected data on a cancelled listen pSPD[%p] pMSD[%p]", pSPD, pMSD);
		Unlock(&pMSD->CommandLock);
		return DPNERR_ABORTED;												
	}

		//store the session signing type and the connect secrets
	DWORD dwSigningType=0;
	ULONGLONG ullLastConnectSecret, ullCurrentConnectSecret;
	DWORD tNow=GETTIMESTAMP();
	if (pMSD->ulMsgFlags1 & MFLAGS_ONE_SIGNED)
	{
		if  (pMSD->ulMsgFlags1 & MFLAGS_ONE_FAST_SIGNED)
		{
			dwSigningType=PACKET_SIGNING_FAST;
		}
		else
		{
			DNASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_FULL_SIGNED);
			dwSigningType=PACKET_SIGNING_FULL;
		}
			//check how much time has elapsed since we last updated the connect secret.
			//if its exceed a pre-determined amount then lets pick a new connect secret
		if ((tNow-pMSD->dwTimeConnectSecretChanged)>CONNECT_SECRET_CHANGE_INTERVAL)
		{
			pMSD->ullLastConnectSecret=pMSD->ullCurrentConnectSecret;
			DNGetGoodRandomData(&pMSD->ullCurrentConnectSecret, sizeof(pMSD->ullCurrentConnectSecret));
			pMSD->dwTimeConnectSecretChanged=tNow;
		}
			//store the current connect secrets locally. 
		ullLastConnectSecret=pMSD->ullLastConnectSecret;
		ullCurrentConnectSecret=pMSD->ullCurrentConnectSecret;
	}
		//we're done with the MSD now so can unlock its
	Unlock(&pMSD->CommandLock);
	
		//once we get here we've got a valid SP reporting data for a valid listen.
		//now need to check if the frame is actually interesting.
		//The only things we care about are the cframes CONNECT and CONNECTED_SIGNED and the dframe keep alives

		//N.B. We pick up on keep alives because of the possible connect sequence
		//Connect recv, ConnectedSigned sent, ConnectSigned should be recv but is dropped
		//in this case the connector will think the link is valid but the listener will have no record of them
		//we therefore use the keep alive the connector will send at first as a clue to send another ConnectedSigned from the
		//listening side

		//have we got a dframe?
	if( (dwDataLength >= MIN_SEND_DFRAME_HEADER_SIZE) &&		
		(byPktCommand & PACKET_COMMAND_DATA))
	{
		PDFRAME pDFrame=(PDFRAME) pUnconnectedData->pReceivedData->BufferDesc.pBufferData;

			//if we haven't got a signed session then we don't care what sort of dframe this is. This clearly isn't
			//the start of a connection and we don't have to handle the ConnectedSigned dropped case outlined above
		if ((dwSigningType & (PACKET_SIGNING_FAST | PACKET_SIGNING_FULL))==0)
		{
			DPFX(DPFPREP, 5, "Rejecting unconnected dframe received for an unsigned session");
			return DPNERR_ABORTED;
		}
			//only unconnected dframe we care about in a signed session is a new style keep alive.
			//i.e. one with a session identity in it, rather than simple zero data
			//The control flags for this kind of keep alive are retry=don't care, keepalive=set, coalesce=clear and eos=clear
			//it should also have a zero sequence count, since we only care about the keep alive sent on a new connection
		if (((pDFrame->bControl & PACKET_CONTROL_KEEPALIVE)==0) ||
			(pDFrame->bControl & (PACKET_CONTROL_END_STREAM | PACKET_CONTROL_COALESCE)) ||
			pDFrame->bSeq!=0)
		{
			DPFX(DPFPREP, 5, "Rejecting unconnected dframe that doesn't look like a keep alive");
			return DPNERR_ABORTED;
		}
			//size must be at least big enough to hold data that we require
			//i.e. DFRAME header, whatever the mask size is, the signature, and then the DWORD session identity
		DWORD dwRequiredSize=sizeof(DFRAME)+GetDFrameMaskHeaderSize(pDFrame->bControl)+sizeof(ULONGLONG)+sizeof(DWORD);
		if (dwDataLength<dwRequiredSize)
		{
			DPFX(DPFPREP, 0, "Rejected unconnected keep alive dframe that's too short");
			return DPNERR_ABORTED;
		}
			//looks like we've got a keep alive that meets all our criteria for sending a CONNECTED_SIGNED response
		return CreateConnectedSignedReply(pUnconnectedData->pvReplyBuffer, &pUnconnectedData->dwReplyBufferSize, 
				*((DWORD * ) ((((BYTE* ) pDFrame)+dwRequiredSize-sizeof(DWORD)))), pUnconnectedData->dwSenderAddressHash, 
					ullCurrentConnectSecret, dwSigningType, tNow);
	}

		//have we got a cframe?
	if ((dwDataLength >= MIN_SEND_CFRAME_HEADER_SIZE) &&		
		     ((byPktCommand == PACKET_COMMAND_CFRAME) || 
			  (byPktCommand == (PACKET_COMMAND_CFRAME|PACKET_COMMAND_POLL))))
	{
			//looks like we've got a command frame. 
		PCFRAME pCFrame=(PCFRAME ) pUnconnectedData->pReceivedData->BufferDesc.pBufferData;
			//if its not a type we're interested in then dump it
			//N.B. We ignore FRAME_EXOPCODE_CONNECTED frames. If we haven't got a signed session we fall
			//back to the connect data path on receiving a CONNECT. Hence, by the time we get the CONNECTED
			//we should always have an associated endpoint
		if (pCFrame->bExtOpcode!=FRAME_EXOPCODE_CONNECT &&
			pCFrame->bExtOpcode!=FRAME_EXOPCODE_CONNECTED_SIGNED)
		{
			DPFX(DPFPREP, 5, "Rejecting unconnected cframe that is neither a CONNECT or CONNECTEDSIGNED");
			return DPNERR_ABORTED;
		}
			//If the major version number doesn't match ours we can ignore this
		if((pCFrame->dwVersion >> 16) != (DNET_VERSION_NUMBER >> 16))
		{
			DPFX(DPFPREP,1, "Received unconnected CFrame from incompatible version (theirs %x, ours %x)", 
																	pCFrame->dwVersion, DNET_VERSION_NUMBER);
			return DPNERR_ABORTED;
		}
			//if we've got a bogus session identity we can also throw this frame away
		if (VersionSupportsSigning(pCFrame->dwVersion) && pCFrame->dwSessID==0)
		{
			DPFX(DPFPREP,1, "Received unconnected CFrame with invalid session identity");
			return DPNERR_ABORTED;
		}
		if (pCFrame->bExtOpcode==FRAME_EXOPCODE_CONNECT)
		{
				//if the session isn't signed then fall back to the old code path of allocating an endpoint up front
				//and kicking off the connect sequence
			if ((dwSigningType & (PACKET_SIGNING_FAST | PACKET_SIGNING_FULL))==0)
			{
				DPFX(DPFPREP, 5, "Received CONNECT frame for unsigned session. Instructing SP to indicate an endpoint. "
																"pSPD[%p] pMSD[%p]", pSPD, pMSD);
				return DPN_OK;			
			}
				//We've got a connect request to a signed session. Better make sure they support signing
			if (VersionSupportsSigning(pCFrame->dwVersion)==FALSE)
			{
					//N.B. This approach means we'll appear unresponsive to far end and it'll time out the connect
					//It would be nice to send a reject packet, but unfortunately the protocol has no support for that
				DPFX(DPFPREP, 1, "Ignoring incoming CONNECT from protocol version that doesn't support signing. "
						"pSPD[%p] Their Minor Version [%u]", pSPD, pCFrame->dwVersion & 0xFFFF);
				return DPNERR_ABORTED;
			}
				//Looks like everything is valid and we should respond to the CONNECT with a CONNECTEDSIGNED cframe
			return CreateConnectedSignedReply(pUnconnectedData->pvReplyBuffer, &pUnconnectedData->dwReplyBufferSize, 
											pCFrame->dwSessID, pUnconnectedData->dwSenderAddressHash, 
											ullCurrentConnectSecret, dwSigningType, tNow);
		}
		
		DNASSERT(pCFrame->bExtOpcode==FRAME_EXOPCODE_CONNECTED_SIGNED);
			//make sure size matches minimum we expect
		if (dwDataLength<sizeof(CFRAME_CONNECTEDSIGNED))
		{
			DPFX(DPFPREP, 0, "Rejecting CONNECTED_SIGNED cframe that is too short");
			return DPNERR_ABORTED;
		}
			//make sure the signing type matches what we've got for the session
		if ((((CFRAME_CONNECTEDSIGNED * ) pCFrame)->dwSigningOpts & (PACKET_SIGNING_FAST | PACKET_SIGNING_FULL))
																								!=dwSigningType)
		{
			DPFX(DPFPREP, 0, "Rejecting CONNECTED_SIGNED cframe with invalid signing options");
			return DPNERR_ABORTED;
		}	
			//we need to check the connect signature to ensure that we're seeing is a genuine response
			//to an original CONNECTED_SIGNED frame we sent out
		ULONGLONG ullConnectSig=GenerateConnectSig(pCFrame->dwSessID, 
													pUnconnectedData->dwSenderAddressHash, ullCurrentConnectSecret);
		if (ullConnectSig!=((CFRAME_CONNECTEDSIGNED * ) pCFrame)->ullConnectSig)
		{
				//possible we're seeing a connect response that's overlapped with a change in the connect secret
				//so lets check the previous connect secret
			ullConnectSig=GenerateConnectSig(pCFrame->dwSessID, 
													pUnconnectedData->dwSenderAddressHash, ullLastConnectSecret);
			if (ullConnectSig!=((CFRAME_CONNECTEDSIGNED * ) pCFrame)->ullConnectSig)
			{
				DPFX(DPFPREP, 0, "Rejecting CONNECTED_SIGNED cframe that has an invalid connection signature");
				return DPNERR_ABORTED;
			}
		}
			//looks like we've got a valid CONNECTEDSIGNED response. This tells us that the original connect wasn't from 
			//a fake IP and we've got a valid remote host to form the connection with. Return OK to tell the SP to allocate
			//an endpoint for this connection
		return DPN_OK;
	}

		//looks like we got something weird that was neither a dframe or a cframe
	DPFX(DPFPREP, 0, "Rejecting unconnected cframe that is neither a dframe or cframe");
	return DPNERR_ABORTED;
}


/*
**	Indicate Connect
**
**		This event is indicated for both calling and listening sides.  The
**	calling side will do most of its work when the SP Connect call completes
**	and the listening side will do most of its work when the CONNECT frame
**	gets delivered.  All we do here is allocate the EPD and attach it to the
**	MSD (for calling case)
**
**		Since we have a connect protocol,  there will always be a CONNECT
**	frame following closely on the heels of this indication.  Therefore,
**	there is not a whole lot of stuff that we need to do here.  We will
**	allocate the EndPoint and leave it dormant.
**
**		Synchronization Issue:  We have decided that if an SP Listen command is cancelled,
**	the cancel call will not complete until all ConnectIndications have returned from the
**	protocol.  This means that we are GUARANTEED that the Listen command in the context
**	will be valid throughout this call.  This is important because now we can add a reference
**	to the Listen's MSD here and now and we will know that it wont disappear on us before we
**	do it.  Truth,  however,  is that there will be a race until SP fixes itself to follow
**	this behavior.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "IndicateConnect"

HRESULT	IndicateConnect(PSPD pSPD, PSPIE_CONNECT pConnData)
{
	PEPD	pEPD;
	PMSD	pMSD;

	pMSD = (PMSD) pConnData->pCommandContext;
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pConnData[%p] - pMSD[%p]", pSPD, pConnData, pMSD);

	Lock(&pMSD->CommandLock);
	
	LOCK_MSD(pMSD, "EPD Ref");				// Place a reference on the command object.  This prevents it from
											// going away during the Connect Protocol,  an assumption which simplifies
											// life extraordinarily.  We will want to ASSERT this fact,  however,  to make
											// sure that SP is playing by our rules.

	if ((pMSD->CommandID != COMMAND_ID_CONNECT) && (pMSD->CommandID != COMMAND_ID_LISTEN)
#ifndef DPNBUILD_NOMULTICAST
		&& (pMSD->CommandID != COMMAND_ID_CONNECT_MULTICAST_SEND) && (pMSD->CommandID != COMMAND_ID_CONNECT_MULTICAST_RECEIVE)
#endif	// DPNBUILD_NOMULTICAST
		)
	{
		DPFX(DPFPREP,1, "Connect Rejected - CommandID is not Connect or Listen, returning DPNERR_ABORTED, pMSD[%p]", pMSD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;
	}
	
	if ((pMSD->CommandID == COMMAND_ID_CONNECT
#ifndef DPNBUILD_NOMULTICAST
		|| (pMSD->CommandID == COMMAND_ID_CONNECT_MULTICAST_SEND)
		|| (pMSD->CommandID == COMMAND_ID_CONNECT_MULTICAST_RECEIVE)
#endif	// DPNBUILD_NOMULTICAST
		) && (pMSD->pEPD != NULL))
	{
		DPFX(DPFPREP,1, "Connect Rejected - Connect command already has an endpoint, returning DPNERR_ABORTED, pMSD[%p], pEPD[%p]", pMSD, pMSD->pEPD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;
	}

	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		DPFX(DPFPREP,1, "Connect Rejected - Command is cancelled, returning DPNERR_ABORTED, pMSD[%p]", pMSD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;
	}

	if((pEPD = NewEndPoint(pSPD, pConnData->hEndpoint)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate new EPD, returning DPNERR_ABORTED, pMSD[%p]", pMSD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;	// This error will implicitly DISCONNECT from Endpoint
	}

	// Associate either the Connect or Listen with this Endpoint, this will be removed when the connection is complete.
	// The EPD Ref placed above will be carried around until this is NULL'd.
	pEPD->pCommand = pMSD;	

	if(pMSD->CommandID == COMMAND_ID_CONNECT)
	{
		DPFX(DPFPREP,5, "INDICATE CONNECT (CALLING) -- EPD = %p, pMSD[%p]", pEPD, pMSD);
		pMSD->pEPD = pEPD;
	}
#ifndef DPNBUILD_NOMULTICAST
	else if (pMSD->CommandID == COMMAND_ID_CONNECT_MULTICAST_SEND)
	{
		DPFX(DPFPREP,5, "INDICATE MULTICAST SEND CONNECT (CALLING) -- EPD = %p, pMSD[%p]", pEPD, pMSD);
		pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTED | EPFLAGS_STREAM_UNBLOCKED;
		pEPD->ulEPFlags2 |= EPFLAGS2_MULTICAST_SEND;
		pMSD->pEPD = pEPD;
	}
	else if (pMSD->CommandID == COMMAND_ID_CONNECT_MULTICAST_RECEIVE)
	{
		DPFX(DPFPREP,5, "INDICATE MULTICAST RECEIVE CONNECT (CALLING) -- EPD = %p, pMSD[%p]", pEPD, pMSD);
		pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTED | EPFLAGS_STREAM_UNBLOCKED;
		pEPD->ulEPFlags2 |= EPFLAGS2_MULTICAST_RECEIVE;
		pMSD->pEPD = pEPD;
	}
#endif	// DPNBUILD_NOMULTICAST
	else
	{
		DPFX(DPFPREP,5, "INDICATE CONNECT (LISTENING) -- EPD = %p, pMSD[%p]", pEPD, pMSD);

		ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);
		ASSERT((pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)==0);

		// For a Listen command, connecting endpoints are held on the blFrameList
		pEPD->blSPLinkage.InsertBefore( &pMSD->blFrameList);
		pEPD->ulEPFlags |= EPFLAGS_LINKED_TO_LISTEN;
	}

	pConnData->pEndpointContext = pEPD;

	Unlock(&pMSD->CommandLock);

	return DPN_OK;
}

/*
**		Indicate Receive
**
**		A frame has been delivered by the service provider.  We are Guaranteed to
**	have an active Endpoint in our hash table (or else something is wrong).  I have not
**	decided whether I will respond to POLL bits at this high level or else let
**	each handler repond in its own particular... eh...  idiom.
**
**		Our return value controls whether SP will recycle the receive buffer, or whether
**	we can keep the buffer around until we are ready to indicate it to higher levels
**	later on.   If we return DPN_OK then we are done with the buffer and it will be recycled.
**	If we return DPNERR_PENDING then we may hold on to the buffer until we release them later.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "IndicateReceive"

HRESULT IndicateReceive(PSPD pSPD, PSPIE_DATA pDataBlock)
{
	PEPD 			pEPD;
	HRESULT			hr;
	BYTE			byPktCommand;
	DWORD			tNow;
	DWORD			dwDataLength;
	PSPRECEIVEDBUFFER pRcvBuffToFree;

	pEPD = (PEPD)pDataBlock->pEndpointContext;
	byPktCommand=*pDataBlock->pReceivedData->BufferDesc.pBufferData;
	dwDataLength = pDataBlock->pReceivedData->BufferDesc.dwBufferSize;
	tNow = GETTIMESTAMP();
	pRcvBuffToFree = NULL;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pEPD[%p]", pSPD, pDataBlock, pEPD);

	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		DPFX(DPFPREP,1, "(%p) SP is terminating, returning DPN_OK, pSPD[%p]", pEPD, pSPD);
		return DPN_OK;
	}

	ASSERT_EPD(pEPD);
	ASSERT(pEPD->pSPD == pSPD);
	ASSERT(pDataBlock->hEndpoint == pEPD->hEndPt);

#ifndef	DPNBUILD_NOMULTICAST
	if (pEPD->ulEPFlags2 & EPFLAGS2_MULTICAST_RECEIVE)
	{
		PSPRECEIVEDBUFFER	pRcvBuffer;

		pRcvBuffer = pDataBlock->pReceivedData;
		DNASSERT(pRcvBuffer != NULL);
		
		DNASSERT(pRcvBuffer->pNext == NULL);
		DNASSERT(pRcvBuffer->dwProtocolData == 0);
		DNASSERT(pRcvBuffer->pServiceProviderDescriptor == NULL);

		pRcvBuffer->dwProtocolData = RBT_SERVICE_PROVIDER_BUFFER;
		pRcvBuffer->pServiceProviderDescriptor = pSPD;

		DEBUG_ONLY(DNInterlockedIncrement(&pSPD->pPData->ThreadsInReceive));
		DEBUG_ONLY(DNInterlockedIncrement(&pSPD->pPData->BuffersInReceive));

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceive(multicast), Core Context[%p]", pEPD, pEPD->Context);
		hr = pSPD->pPData->pfVtbl->IndicateReceive( pSPD->pPData->Parent,
													pEPD->Context,
													pRcvBuffer->BufferDesc.pBufferData,
													pRcvBuffer->BufferDesc.dwBufferSize,
													pRcvBuffer,
													0);
		if(hr == DPN_OK)
		{
			DEBUG_ONLY(DNInterlockedDecrement(&pSPD->pPData->BuffersInReceive));
		}
		else
		{
			ASSERT(hr == DPNERR_PENDING);
		}
		DEBUG_ONLY(DNInterlockedDecrement(&pSPD->pPData->ThreadsInReceive));
	}
	else
	{
#endif	// DPNBUILD_NOMULTICAST

	// Hold a reference throughout the operation so we don't have to deal with the EPD going away.
	LOCK_EPD(pEPD, "LOCK (IND RECEIVE)");

	pEPD->tLastPacket = tNow;								// Track last time each guy writes to us

#ifdef DBG
	// copy this frame to buffer in EPD so we can look after a break.
	DWORD dwLen = _MIN(sizeof(pEPD->LastPacket), pDataBlock->pReceivedData->BufferDesc.dwBufferSize);
	memcpy(pEPD->LastPacket, pDataBlock->pReceivedData->BufferDesc.pBufferData, dwLen);
#endif // DBG

		//take lock on endpoint
	Lock(&pEPD->EPLock);

	// A valid data packet is one that meets the length requirements and has the Data flag set.
	// All other flags are allowed on a data frame (NOTE: even PACKET_COMMAND_CFRAME is allowed
	// as it shares its value with PACKET_COMMAND_USER_2).
	if( (dwDataLength >= MIN_SEND_DFRAME_HEADER_SIZE) &&		// Validate the length first
		(byPktCommand & PACKET_COMMAND_DATA))				// Data goes this way
	{
			//if endpoint is marked as either hard disconnect source or target it won't process further data frames
		if (pEPD->ulEPFlags & (EPFLAGS_HARD_DISCONNECT_SOURCE | EPFLAGS_HARD_DISCONNECT_TARGET))
		{
			Unlock(&pEPD->EPLock);
			hr=DPN_OK;
		}
		else
		{
			hr = CrackDataFrame(pSPD, pEPD, pDataBlock->pReceivedData, tNow, &pRcvBuffToFree);
				//above call will release ep lock
		}
	}
	else if ((dwDataLength >= MIN_SEND_CFRAME_HEADER_SIZE) &&		// Validate the length first
		     ((byPktCommand == PACKET_COMMAND_CFRAME) || 		// Only the CFRAME and POLL flags are allowed on a CFrame
			  (byPktCommand == (PACKET_COMMAND_CFRAME|PACKET_COMMAND_POLL))))
	{
		hr = CrackCommand(pSPD, pEPD, pDataBlock->pReceivedData, tNow, &pRcvBuffToFree);
			//above call will release ep lock
	}
	else
	{
		DPFX(DPFPREP,1, "(%p) Received frame that is neither Command nor Data, rejecting", pEPD);
		DNASSERTX(FALSE, 2);
		RejectInvalidPacket(pEPD);
			//above call will release ep lock
		hr = DPN_OK;
	}

	// Free any buffers created during the receive
	if (pRcvBuffToFree != NULL)
	{
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->ReturnReceiveBuffers, pSPD[%p], pRcvBuffToFree[%p]", pEPD, pSPD, pRcvBuffToFree);
		IDP8ServiceProvider_ReturnReceiveBuffers(pSPD->IISPIntf, pRcvBuffToFree);
	}

	Lock(&pEPD->EPLock);
	RELEASE_EPD(pEPD, "UNLOCK (IND RCV DONE)"); // Releases EPLock

#ifndef	DPNBUILD_NOMULTICAST
	}
#endif	// DPNBUILD_NOMULTICAST

	// This is either DPN_OK or DPNSUCCESS_PENDING.  If it is pending we have to return the buffer later.
	return hr;
}

#ifndef DPNBUILD_NOMULTICAST
/*
**		Indicate Receive from an Unknown Sender
**
**		A frame has been delivered by the service provider from some multicast sender for which
**	we do not have an endpoint.
**
**		Our return value controls whether SP will recycle the receive buffer, or whether
**	we can keep the buffer around until we are ready to indicate it to higher levels
**	later on.   If we return DPN_OK then we are done with the buffer and it will be recycled.
**	If we return DPNERR_PENDING then we may hold on to the buffer until we release them later.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "IndicateReceiveUnknownSender"

HRESULT IndicateReceiveUnknownSender(PSPD pSPD, PSPIE_DATA_UNKNOWNSENDER pDataBlock)
{
	HRESULT				hr;
	PMSD				pMSD;
	PSPRECEIVEDBUFFER	pRcvBuffer;
	
	pMSD = (PMSD) pDataBlock->pvListenCommandContext;
	
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN_MULTICAST);

	pRcvBuffer = pDataBlock->pReceivedData;
	DNASSERT(pRcvBuffer != NULL);
	
	DNASSERT(pRcvBuffer->pNext == NULL);
	DNASSERT(pRcvBuffer->dwProtocolData == 0);
	DNASSERT(pRcvBuffer->pServiceProviderDescriptor == NULL);

	pRcvBuffer->dwProtocolData = RBT_SERVICE_PROVIDER_BUFFER;
	pRcvBuffer->pServiceProviderDescriptor = pSPD;

	DEBUG_ONLY(DNInterlockedIncrement(&pSPD->pPData->ThreadsInReceive));
	DEBUG_ONLY(DNInterlockedIncrement(&pSPD->pPData->BuffersInReceive));

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceiveUnknownSender, Core Context[%p]", pMSD, pMSD->Context);
	hr = pSPD->pPData->pfVtbl->IndicateReceiveUnknownSender(pSPD->pPData->Parent,
														pMSD->Context,
														pDataBlock->pSenderAddress,
														pRcvBuffer->BufferDesc.pBufferData,
														pRcvBuffer->BufferDesc.dwBufferSize,
														pRcvBuffer);
	if(hr == DPN_OK)
	{
		DEBUG_ONLY(DNInterlockedDecrement(&pSPD->pPData->BuffersInReceive));
	}
	else
	{
		ASSERT(hr == DPNERR_PENDING);
	}
	DEBUG_ONLY(DNInterlockedDecrement(&pSPD->pPData->ThreadsInReceive));
	
	return hr;
}
#endif // ! DPNBUILD_NOMULTICAST


/*
**		Process Enum Query
**
**		A frame has been delivered by the service provider representing an enumereation
**	query.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEnumQuery"

HRESULT ProcessEnumQuery( PSPD pSPD, PSPIE_QUERY pQueryBlock )
{
	MSD		*pMSD;
	PROTOCOL_ENUM_DATA	EnumData;

	pMSD = static_cast<MSD*>( pQueryBlock->pUserContext );
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pQueryBlock[%p] - pMSD[%p]", pSPD, pQueryBlock, pMSD);

	EnumData.pSenderAddress = pQueryBlock->pAddressSender;
	EnumData.pDeviceAddress = pQueryBlock->pAddressDevice;
	EnumData.ReceivedData.pBufferData = pQueryBlock->pReceivedData->BufferDesc.pBufferData;
	EnumData.ReceivedData.dwBufferSize = pQueryBlock->pReceivedData->BufferDesc.dwBufferSize;
	EnumData.hEnumQuery = pQueryBlock;

	DBG_CASSERT( sizeof( &EnumData ) == sizeof( PBYTE ) );

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateEnumQuery, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->IndicateEnumQuery(	pSPD->pPData->Parent,
												pMSD->Context,
												pMSD,
												reinterpret_cast<PBYTE>( &EnumData ),
												sizeof( EnumData ));

	return	DPN_OK;
}

/*
**		Process Query Response
**
**		A frame has been delivered by the service provider representing a response to an enum.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ProcessQueryResponse"

HRESULT ProcessQueryResponse( PSPD pSPD, PSPIE_QUERYRESPONSE pQueryResponseBlock)
{
	MSD		*pMSD;
	PROTOCOL_ENUM_RESPONSE_DATA	EnumResponseData;

	pMSD = static_cast<MSD*>( pQueryResponseBlock->pUserContext );
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pQueryResponseBlock[%p] - pMSD[%p]", pSPD, pQueryResponseBlock, pMSD);

	EnumResponseData.pSenderAddress = pQueryResponseBlock->pAddressSender;
	EnumResponseData.pDeviceAddress = pQueryResponseBlock->pAddressDevice;
	EnumResponseData.ReceivedData.pBufferData = pQueryResponseBlock->pReceivedData->BufferDesc.pBufferData;
	EnumResponseData.ReceivedData.dwBufferSize = pQueryResponseBlock->pReceivedData->BufferDesc.dwBufferSize;
	EnumResponseData.dwRoundTripTime = pQueryResponseBlock->dwRoundTripTime;

	DBG_CASSERT( sizeof( &EnumResponseData ) == sizeof( PBYTE ) );
	
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateEnumResponse, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->IndicateEnumResponse(	pSPD->pPData->Parent,
												pMSD,
												pMSD->Context,
												reinterpret_cast<PBYTE>( &EnumResponseData ),
												sizeof( EnumResponseData ));

	return	DPN_OK;
}


/*
**		Reject Invalid Packet
**
**		Called with EP Lock held. Returns with lock released
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RejectInvalidPacket"

VOID RejectInvalidPacket(PEPD pEPD)
{
	PMSD pMSD;
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT)
	{
		// Unlink MSD from EPD, there should always be one if we are in the DORMANT state
		pMSD = pEPD->pCommand;
		ASSERT_MSD(pMSD);

		if (pMSD->CommandID == COMMAND_ID_LISTEN)
		{
			pEPD->pCommand = NULL;
			LOCK_EPD(pEPD, "Temp Ref");

			DPFX(DPFPREP,1, "(%p) Received invalid frame on a dormant, listening endpoint, dropping link", pEPD);
			DropLink(pEPD); // This will release the EPLock

			// The order here is important.  We call DropLink first without ever leaving the EPLock because
			// we need to ensure no new packets try to come in.  After calling DropLink we know we stay in the
			// TERMINATING state until returning to the pool, so state is not an issue after that call.

			Lock(&pMSD->CommandLock);
			Lock(&pEPD->EPLock);

			// If a cancel on a listen comes in at the same time as this happens, it is possible that the cancel came
			// through and already unlinked this EPD from the Listen while we were outside the lock.  If so, removing
			// it from the pMSD->blFrameList twice is harmless.
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();							// Unlink EPD from Listen Queue

			// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
			RELEASE_MSD(pMSD, "EPD Ref");	// Releases CommandLock
			RELEASE_EPD(pEPD, "Temp Ref");	// Releases EPLock
		}
		else
		{
			DPFX(DPFPREP,1, "(%p) Received invalid frame on a dormant, connecting endpoint, ignoring", pEPD);
			Unlock(&pEPD->EPLock);
		}
	}
	else
	{
		DPFX(DPFPREP,1, "(%p) Received invalid frame on a non-dormant endpoint, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
	}
}

/*
**		Crack Command
**
**			This frame is a maintainance frame containing no user data
**
**	Called with EP lock held, returns with EP lock released
**
*/
#undef DPF_MODNAME
#define DPF_MODNAME "CrackCommand"

HRESULT CrackCommand(PSPD pSPD, PEPD pEPD, PSPRECEIVEDBUFFER pRcvBuffer, DWORD tNow, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	DWORD 			dwDataLength = pRcvBuffer->BufferDesc.dwBufferSize;
	UNALIGNED ULONG	*array_ptr;
	ULONG			mask1, mask2;
	
	union 
	{
		BYTE *			pbyFrame;
		PCFRAME			pCFrame;
		PSACKFRAME8	pSack;
	} pData;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pData.pCFrame = (PCFRAME) pRcvBuffer->BufferDesc.pBufferData;

		//if ep is marked as a hard disconnect target then it ignore all CFRAMES. Its going to 
		//drop the link any moment now
	if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_TARGET)
	{
		DPFX(DPFPREP, 7, "(%p) Ignoring CFRAME on hard disconnect target ep bExtOpcode[%u]", pEPD, 
																(DWORD ) pData.pCFrame->bExtOpcode);
		Unlock(&pEPD->EPLock);
		return DPN_OK;
	}

		//hard disconnects are handled as a special case, as they're the only CFrame that
		//an ep mark as a hard disconnect source is interested in. Hence, we process them
		//here before making that check
	if (pData.pCFrame->bExtOpcode==FRAME_EXOPCODE_HARD_DISCONNECT)
	{
		DPFX(DPFPREP,7, "(%p) HARD_DISCONECT Frame Received", pEPD);
			//obviously we have to be connected to care about a disconnect event
		if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
		{				
			DPFX(DPFPREP,1, "(%p) Received HARD_DISCONECT on non-connected endpoint, rejecting...", pEPD);
			RejectInvalidPacket(pEPD);
				//returns with EP lock released
			return DPN_OK;
		}
			//validate size of frame and its signature (if relevant)
		if (pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK)
		{
			if (dwDataLength < (sizeof(CFRAME)+sizeof(ULONGLONG)))
			{
				DPFX(DPFPREP,1, "(%p) Received short signed HARD DISCONNECT frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				return DPN_OK;
			}
				//for purposes of signing the sender places the next send seq number in the bRespID filed of the hard
				//disconnect frame. This is effectively tells us what signature version the hard disconnect was signed with
			if (ValidateIncomingFrameSig(pEPD, pData.pbyFrame, dwDataLength, pData.pCFrame->bRspID, 
									(UNALIGNED ULONGLONG * ) (pData.pbyFrame+sizeof(CFRAME)))==FALSE)
			{
				DPFX(DPFPREP,1, "(%p) Dropping incorrectly signed hard disconnect  frame", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				return DPN_OK;
			}
		}
		else	if (dwDataLength < sizeof(CFRAME))
		{
			DPFX(DPFPREP,1, "(%p) Received short HARD DISCONNECT  frame, rejecting...", pEPD);
			DNASSERTX(FALSE, 2);
			RejectInvalidPacket(pEPD);
				//returns with EP lock released
			return DPN_OK;
		}
			//looks like we've got a valid response to a hard disconnect sequence we instigated
		ProcessHardDisconnect(pEPD);
			//above call release ep lock
		return DPN_OK;
	}

		//as stated above, if ep is marked as a hard disconnect source then it ignores all other CFRAMES. 
		//Hence, in that case we need proceed no further
	if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_SOURCE)
	{
		DPFX(DPFPREP, 7, "(%p) Ignoring CFRAME on hard disconnected source ep bExtOpcode[%u]", pEPD, 
																				(DWORD ) pData.pCFrame->bExtOpcode);
		RejectInvalidPacket(pEPD);
			//returns with EP lock released
		return DPN_OK;
	}
					
	switch(pData.pCFrame->bExtOpcode)
	{
		case FRAME_EXOPCODE_SACK:
			DPFX(DPFPREP,7, "(%p) SACK Frame Received", pEPD);

			// Check state
			if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
			{				
				DPFX(DPFPREP,1, "(%p) Received SACK on non-connected endpoint, rejecting...", pEPD);
				DNASSERTX(FALSE, 4);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				break;
			}

			// Drop short frames (should not happen)
			DWORD dwRequiredLength;
			dwRequiredLength = sizeof(SACKFRAME8);
			array_ptr = (ULONG * ) (pData.pSack+1);
			if (pData.pSack->bFlags & SACK_FLAGS_SACK_MASK1)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pData.pSack->bFlags & SACK_FLAGS_SACK_MASK2)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pData.pSack->bFlags & SACK_FLAGS_SEND_MASK1)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pData.pSack->bFlags & SACK_FLAGS_SEND_MASK2)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK)
			{
				dwRequiredLength += sizeof(ULONGLONG);
			}
			
			if (dwDataLength < dwRequiredLength)
			{
				DPFX(DPFPREP,1, "(%p) Dropping short ack frame on connected link", pEPD);
				DNASSERTX(FALSE, 2);
				Unlock(&pEPD->EPLock);
				return DPN_OK;					
			}

				//for purposes of signing we use the next send sequence number of the sack frame as an indication
				//of what secret it was signed with. i.e. If the sack tells us that the next send is 27 then we treat it
				//as being signed the same as data frame 27 will be
			if ((pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK) && 
					ValidateIncomingFrameSig(pEPD, pData.pbyFrame, dwDataLength, pData.pSack->bNSeq, 
						(UNALIGNED ULONGLONG * ) (pData.pbyFrame+dwRequiredLength-sizeof(ULONGLONG)))==FALSE)
			{
				DPFX(DPFPREP,1, "(%p) Dropping incorrectly signed ack frame", pEPD);
				DNASSERTX(FALSE, 2);
				Unlock(&pEPD->EPLock);
				return DPN_OK;	
			}


			if( pData.pSack->bFlags & SACK_FLAGS_RESPONSE )
			{
				DPFX(DPFPREP,7, "(%p) ACK RESP RCVD: Retry=%d, N(R)=0x%02x", pEPD, pData.pSack->bRetry, pData.pSack->bNRcv);
			}

			mask1 = pData.pSack->bFlags & SACK_FLAGS_SACK_MASK1 ? *array_ptr++ : 0;
			mask2 = pData.pSack->bFlags & SACK_FLAGS_SACK_MASK2 ? *array_ptr++ : 0;
			
			DPFX(DPFPREP,7, "(%p) UpdateXmitState - N(R) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD)pData.pSack->bNRcv, mask2, mask1);
			UpdateXmitState(pEPD, pData.pSack->bNRcv, mask1, mask2, tNow);

			mask1 = pData.pSack->bFlags & SACK_FLAGS_SEND_MASK1 ? *array_ptr++ : 0;
			mask2 = pData.pSack->bFlags & SACK_FLAGS_SEND_MASK2 ? *array_ptr++ : 0;

			if(mask1 | mask2)
			{
				DPFX(DPFPREP,7, "(%p) Processing Send Mask N(S) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD) pData.pSack->bNSeq, mask2, mask1);
				ProcessSendMask(pEPD, pData.pSack->bNSeq, mask1, mask2, tNow, ppRcvBuffToFree);
			}
			
			if (! pEPD->blCompleteList.IsEmpty())
			{
				if (! (pEPD->ulEPFlags & EPFLAGS_IN_RECEIVE_COMPLETE))
				{
					DPFX(DPFPREP,8, "(%p) Completing Receives...", pEPD);
					pEPD->ulEPFlags |= EPFLAGS_IN_RECEIVE_COMPLETE;	// ReceiveComplete will clear this flag when done
					ReceiveComplete(pEPD); 							// Deliver the goods,  returns with EPLock released
				}
				else 
				{
					DPFX(DPFPREP,7, "(%p) Already in ReceiveComplete, letting other thread handle receives", pEPD);
					Unlock(&pEPD->EPLock);
				}
			}
			else
			{
				Unlock(&pEPD->EPLock);
			}

			DPFX(DPFPREP,8, "(%p) Completing Sends...", pEPD);
			CompleteSends(pEPD);

			break;

		case FRAME_EXOPCODE_CONNECT:
			DPFX(DPFPREP,7, "(%p) CONNECT Frame Received", pEPD);
			if (dwDataLength < sizeof(CFRAME))
			{
				DPFX(DPFPREP,1, "(%p) Received short CONNECT frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				return DPN_OK;
			}
			ProcessConnectRequest(pSPD, pEPD, pData.pCFrame);
				//returns with EP lock released
			break;

		case FRAME_EXOPCODE_CONNECTED:
			DPFX(DPFPREP,7, "(%p) CONNECTED Frame Received", pEPD);
			if (dwDataLength < sizeof(CFRAME))
			{
				DPFX(DPFPREP,1, "(%p) Received short CONNECTED frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				return DPN_OK;
			}
			ProcessConnectedResponse(pSPD, pEPD, pData.pCFrame, tNow);
			break;
		case FRAME_EXOPCODE_HARD_DISCONNECT:
			DPFX(DPFPREP,7, "(%p) HARD_DISCONECT Frame Received", pEPD);
			if (dwDataLength < sizeof(CFRAME))
			{
				DPFX(DPFPREP,1, "(%p) Received short HARD_DISCONECT frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				return DPN_OK;
			}
			if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
			{				
				DPFX(DPFPREP,1, "(%p) Received HARD_DISCONECT on non-connected endpoint, rejecting...", pEPD);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				break;
			}
			ProcessHardDisconnect(pEPD);
				//returns with EP lock released
			break;
		case FRAME_EXOPCODE_CONNECTED_SIGNED:
			DPFX(DPFPREP,7, "(%p) CONNECTEDSIGNED Frame Received", pEPD);
			if (dwDataLength < sizeof(CFRAME_CONNECTEDSIGNED))
			{
				DPFX(DPFPREP,1, "(%p) Received short CONNECTEDSIGNED frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD);
					//returns with EP lock released
				return DPN_OK;
			}
			ProcessConnectedSignedResponse(pSPD, pEPD, (CFRAME_CONNECTEDSIGNED * ) pData.pCFrame, tNow);
			break;
		default:
			DPFX(DPFPREP,1, "(%p) Received invalid CFrame, rejecting...", pEPD);
			DNASSERTX(FALSE, 2);
			RejectInvalidPacket(pEPD);
				//above call will release ep lock
			break;
	}

	return DPN_OK;
}

/*
**		Crack Data Frame
**
**			In addition to delivering data contained in the frame,  we also must
**	use the included state info to drive the transmission process.  We will update
**	our link state according to this info and see if we need to put this session
**	back into the sending pipeline.
**
**		Of course, data will only be delivered if we have completed an entire message.
**
**	This is called with EP lock held and returns with it released.
**	CRITICAL SECTION NOTE -- It might seem rather lavish the way we hold the EPD->StateLock
**		thru this entire routine,  but anything less would require an obscene level of complexity
**		to keep ironed out.  This is why I defer all ReceiveIndications and buffer mappings until
**		the end of the routine when the Lock can be released.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CrackDataFrame"

HRESULT CrackDataFrame(PSPD pSPD, PEPD pEPD, PSPRECEIVEDBUFFER pRcvBuffer, DWORD tNow, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	DWORD 	dwDataLength = pRcvBuffer->BufferDesc.dwBufferSize;
	PDFRAME	pFrame = (PDFRAME) (pRcvBuffer->BufferDesc.pBufferData);
	DWORD	dwNumCoalesceHeaders = 0;
	PRCD	pRCD;
	ULONG	bit;
	UINT	count;
	UNALIGNED ULONG	*array_ptr;
	ULONG	MaskArray[4];
	ULONG	mask;
		//This is the DFrame header+Masks+Signature (if present), it doesn't include the coalesence headers (if present)
	DWORD	dwHeaderSize;		
		//As we walk the coalesce headers validating the packet we store a pointer to the first reliable
		//coalesced data block we see. This is then used if we're full signing and this frame is a candidate
		//for modifying the remote secret we don't have to walk the packet againt to find the relevant user data
	BYTE * pbyRelData=NULL;
	DWORD	dwRelDataSize;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);
	
	//	Data on an unconnected link
	//
	//	There are two possibilities (as I see it today).  Either we have dropped our link because partner
	//	went silent,  but now he has started sending again.  OR We have disconnected and are now reconnecting
	//  but there are some old data frames bouncing around (less likely).
	//
	//	If we have dropped and partner is just figuring it out,  we must kill the endpoint or else it will hang
	//	around forever after partner stops bothering us.  We can help out partner by sending him a DISC frame
	//  so he knows that we arent playing anymore,  buts its not technically necessary.
	//
	//	In the second case,  we do not want to close the EP because that will crush the session startup that
	//	is supposedly in progress.  Therefore,  if we are not in a DORMANT state,  then we know a session
	//	startup is in progress,  and we will let the EP remain open.

	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{				
		DPFX(DPFPREP,1, "(%p) Received data on non-connected endpoint, rejecting...", pEPD);
		DNASSERTX(FALSE, 4);
		RejectInvalidPacket(pEPD);
			//above call will release ep lock
		return DPN_OK;										// do not accept data before we have connected
	}

	BYTE	bSeq = pFrame->bSeq;

	DPFX(DPFPREP,7, "(%p) Data Frame Arrives Seq=%x; N(R)=%x", pEPD, bSeq, pEPD->bNextReceive);

	DWORD dwRequiredLength = sizeof(DFRAME) + GetDFrameMaskHeaderSize(pFrame->bControl);
	if (dwDataLength < dwRequiredLength)
	{
		DPFX(DPFPREP,1, "(%p) Dropping short frame on connected link", pEPD);
		DNASSERTX(FALSE, 2);
		Unlock(&pEPD->EPLock);
		return DPN_OK;					
	}

		//if we've got a signed link, then the next thing in the header should be the signature
	if (pEPD->ulEPFlags2 & EPFLAGS2_SIGNED_LINK)
	{
		UNALIGNED ULONGLONG * pullSig=(UNALIGNED ULONGLONG * ) (((BYTE * ) pFrame)+dwRequiredLength);
		dwRequiredLength+=sizeof(ULONGLONG);
		if (dwDataLength<dwRequiredLength)
		{
			DPFX(DPFPREP,1, "(%p) Dropping data frame too short to contain signature on signed link", pEPD);
			DNASSERTX(FALSE, 2);
			Unlock(&pEPD->EPLock);
			return DPN_OK;					
		}
			//check if the signature is valid
		if (ValidateIncomingFrameSig(pEPD, (BYTE * ) pFrame, dwDataLength, pFrame->bSeq, pullSig)==FALSE)
		{
			DPFX(DPFPREP,1, "(%p) Dropping data frame with invalid signature on signed link", pEPD);
			DNASSERTX(FALSE, 2);
			Unlock(&pEPD->EPLock);
			return DPN_OK;					
		}
	}

		//at this point the dwRequiredLength is equal to the size of DFrame header, plus masks, plus signature (if present)
	dwHeaderSize=dwRequiredLength;

		//If we've got a link that supports signing then we'll expect new style keep alives that contain
		//a DWORD session identity as data. These frames are marked by a KEEPALIVE control bit being flipped
	if ((pEPD->ulEPFlags2 & EPFLAGS2_SUPPORTS_SIGNING) && (pFrame->bControl & PACKET_CONTROL_KEEPALIVE))
	{
			//take pointer to where the session identity should be in the keep alive
		DWORD * pdwKeepAliveSessID=(DWORD * ) (((BYTE * ) pFrame)+dwRequiredLength);
			//ensure that the frame is big enough to hold the required data
		dwRequiredLength+=sizeof(DWORD);
		if (dwDataLength < dwRequiredLength)
		{
			DPFX(DPFPREP,1, "(%p) Dropping short keepalive frame on connected link", pEPD);
			DNASSERTX(FALSE, 2);
			Unlock(&pEPD->EPLock);
			return DPN_OK;					
		}
			//We should screen out keep alives whose session identity doesn't match what we expect.
			//This handles the case when one end has stopped and then restarted. Rather than responding
			//to what is now an outdated KeepAlive we'll ignore it, causing the other end to hopefully time out
		if (*pdwKeepAliveSessID!=pEPD->dwSessID)
		{
			DPFX(DPFPREP,1, "(%p) Dropping outdated keepalive frame on connected link KeepAliveSessID[%u] dwSessId[%u]",
																	pEPD, *pdwKeepAliveSessID, pEPD->dwSessID);
			Unlock(&pEPD->EPLock);
			return DPN_OK;					
		}
	}
	else	if (pFrame->bControl & PACKET_CONTROL_COALESCE)
	{
		PCOALESCEHEADER pCoalesceHeaders = (PCOALESCEHEADER)((BYTE*)pFrame + dwRequiredLength);
		DWORD dwCoalesceFrameSize;
		BYTE bCommand;
		DWORD dwTotalCoalesceDataSize=0;

		// Keep looping until we see the last coalesce header.
		do
		{
				// See if we can have a coalesce header
			dwRequiredLength+=sizeof(COALESCEHEADER);
			if (dwDataLength < dwRequiredLength )
			{
				DPFX(DPFPREP,1, "(%p) Dropping short coalesce frame (hdr) on connected link", pEPD);
				DNASSERTX(FALSE, 2);
				Unlock(&pEPD->EPLock);
				return DPN_OK;					
			}
			
 				// Now that we know it's valid we can touch the header. Figure out the size.
			dwCoalesceFrameSize = pCoalesceHeaders[dwNumCoalesceHeaders].bSize;
 			bCommand = pCoalesceHeaders[dwNumCoalesceHeaders].bCommand;
			dwCoalesceFrameSize |= (DWORD) (bCommand & (PACKET_COMMAND_COALESCE_BIG_1 | PACKET_COMMAND_COALESCE_BIG_2 | PACKET_COMMAND_COALESCE_BIG_3)) << 5;

			if (dwCoalesceFrameSize == 0)
			{
				DPFX(DPFPREP,1, "(%p) Dropping 0 byte coalesce frame on connected link", pEPD);
				DNASSERTX(FALSE, 2);
				Unlock(&pEPD->EPLock);
				return DPN_OK;					
			}

				//if we've hit the first reliable coalesced frame then store the offset from
				//the end of the coalesce headers to the start of its data
			if (pbyRelData==NULL && (bCommand & PACKET_COMMAND_RELIABLE))
			{
				pbyRelData=((BYTE * ) pFrame)+dwTotalCoalesceDataSize;
				dwRelDataSize=dwCoalesceFrameSize;
			}

			// Round frame size up to the nearest DWORD alignment unless it's the last subframe.
			if (! (bCommand & PACKET_COMMAND_END_COALESCE))
			{
				dwCoalesceFrameSize = (dwCoalesceFrameSize + 3) & (~3);
			}
			dwTotalCoalesceDataSize+=dwCoalesceFrameSize;
			dwNumCoalesceHeaders++;
		}
		while (! (bCommand & PACKET_COMMAND_END_COALESCE));

		// If we have an odd number of coalesce headers, there needs to be padding for DWORD
		// alignment.
		DBG_CASSERT(sizeof(COALESCEHEADER) == 2);
		if ((dwNumCoalesceHeaders & 1) != 0)
		{
			dwRequiredLength += 2;
		}
			//if we found a reliable coalesce header in there, shift the offset to its data by dwRequiredLength
			//this adjustment is necessary because when we first assign the pointer we ignore the presence of
			//any headers, hence its off by packet header+coalesce header sizes
		if (pbyRelData)
		{
			pbyRelData+=dwRequiredLength;
		}
			//check that the frame holds all the coalesced user data we expect it to
		dwRequiredLength+=dwTotalCoalesceDataSize;
		if (dwDataLength < dwRequiredLength)
		{
			DPFX(DPFPREP,1, "(%p) Dropping short coalesce frame (user data) on connected link", pEPD);
			DNASSERTX(FALSE, 2);
			Unlock(&pEPD->EPLock);
			return DPN_OK;					
		}
	}

	// Make sure that new frame is within our receive window
	if((BYTE)(bSeq - pEPD->bNextReceive) >= (BYTE) MAX_FRAME_OFFSET)
	{	
		DPFX(DPFPREP,1, "(%p) Rejecting frame that is out of receive window SeqN=%x, N(R)=%x", pEPD, bSeq, pEPD->bNextReceive);

		pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

		if(pFrame->bCommand & PACKET_COMMAND_POLL)
		{
			// Is he asking for an immediate response
			DPFX(DPFPREP,7, "(%p) Sending Ack Frame", pEPD);
			SendAckFrame(pEPD, 1); 						// This unlocks the EPLock since param 2 is 1
		}
		else if(pEPD->DelayedAckTimer == 0)
		{	
			// If timer is not running better start it now
			LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");								// Bump RefCnt for new timer
			DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
			ScheduleProtocolTimer(pSPD, SHORT_DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, 
											(PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
			Unlock(&pEPD->EPLock);		
		}
		else
		{
			Unlock(&pEPD->EPLock);		
		}
		return DPN_OK;
	}

	// Determine what's in the variable length header
	mask = (pFrame->bControl & PACKET_CONTROL_VARIABLE_MASKS) / PACKET_CONTROL_SACK_MASK1;
	
	if(mask)
	{
		array_ptr = (ULONG * ) (pFrame+1);
		for(count = 0; count < 4; count++, mask >>= 1)
		{
			MaskArray[count] = (mask & 1) ? *array_ptr++ : 0;
		}

		// See if this frame Acknowledges any of our outstanding data
		DPFX(DPFPREP,7, "(%p) UpdateXmitState - N(R) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD)pFrame->bNRcv, MaskArray[1], MaskArray[0]);
		UpdateXmitState(pEPD, pFrame->bNRcv, MaskArray[0], MaskArray[1], tNow);				// Do this before taking StateLock

		// Determine if there is a SendMask in this frame which identifies dropped frames as unreliable
		if(pFrame->bControl & (PACKET_CONTROL_SEND_MASK1 | PACKET_CONTROL_SEND_MASK2))
		{
			DPFX(DPFPREP,7, "(%p) Processing Send Mask N(S) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD)pFrame->bSeq, MaskArray[3], MaskArray[2]);
			ProcessSendMask(pEPD, pFrame->bSeq, MaskArray[2], MaskArray[3], tNow, ppRcvBuffToFree);

			// NOTE: ProcessSendMask may have advanced N(R)

			// Re-verify that the new frame is within our receive window
			if((BYTE)(bSeq - pEPD->bNextReceive) >= (BYTE) MAX_FRAME_OFFSET)
			{
				DPFX(DPFPREP,1, "(%p) ProcessSendMask advanced N(R) such that the current frame is out of window, rejecting receive, N(R)=0x%02x, Seq=0x%02x", pEPD, (DWORD)pEPD->bNextReceive, (DWORD)pFrame->bSeq);
				Unlock(&pEPD->EPLock);
				return DPN_OK;
			}
		}

	}
	else 
	{
		DPFX(DPFPREP,7, "(%p) UpdateXmitState - N(R) 0x%02x No Mask", pEPD, (DWORD)pFrame->bNRcv);
		UpdateXmitState(pEPD, pFrame->bNRcv, 0, 0, tNow);			// Do this before taking StateLock
	}

		// We can receive this frame.  
		// If we're full signing, its got reliable data in it and its earlier in the sequence space than the current frame we're proposing
		// to modify the remote secret with, then its the new candidate for being the remote secret modifier
	if ((pEPD->ulEPFlags2 &  EPFLAGS2_FULL_SIGNED_LINK) && (pFrame->bCommand & PACKET_COMMAND_RELIABLE) &&
		(pFrame->bSeq<pEPD->byRemoteSecretModifierSeqNum) && (pFrame->bControl & PACKET_CONTROL_KEEPALIVE)==0)
	{
			//if it was a coalesced frame then we'll already have an offset to a block of reliable data
			//if it wasn't then we simply pick the entire user data contents
		if (pbyRelData==NULL)
		{
			DNASSERT((pFrame->bControl & PACKET_CONTROL_COALESCE)==0);
			pbyRelData=((PBYTE) pFrame) + dwHeaderSize;
			dwRelDataSize=dwDataLength - dwHeaderSize;
		}
		pEPD->byRemoteSecretModifierSeqNum=pFrame->bSeq;
		pEPD->ullRemoteSecretModifier=GenerateRemoteSecretModifier(pbyRelData, dwRelDataSize);
	}


	//Copy relevant info into Receive descriptor
	if((pRCD = (PRCD)POOLALLOC(MEMID_RCD, &RCDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "(%p) Failed to allocate new RCD", pEPD);
		Unlock(&pEPD->EPLock);
		return DPN_OK;
	}

	pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;	// State has changed.  Make sure it gets sent.

	DNASSERT(pRcvBuffer->pNext == NULL);
	DNASSERT(pRcvBuffer->dwProtocolData == 0);
	DNASSERT(pRcvBuffer->pServiceProviderDescriptor == 0);

 	pRCD->bSeq = bSeq;
	pRCD->bFrameFlags = pFrame->bCommand;
 	pRCD->bFrameControl = pFrame->bControl;
	pRCD->pbData = (PBYTE) (((PBYTE) pFrame) + dwHeaderSize);
	pRCD->uiDataSize = dwDataLength - dwHeaderSize;
	pRCD->tTimestamp = tNow;
	pRCD->dwNumCoalesceHeaders = dwNumCoalesceHeaders;
	pRCD->pRcvBuff = pRcvBuffer;

	// Update our receiving state info.
	//
	//	RCDs go onto one of two queues.  If it is the next numbered (expected) frame then it is
	// placed on the ReceiveList (in EPD).  If this frame completes a message it can now be
	// indicated.  If this frame fills a hole left by previous frames then a condensation with
	// the second list must occur.
	//	If it is not the next numbered frame then it is placed,  in order,  on the MisOrdered frame
	// list,  and the bitmask is updated.
	//
	//	Condensation of lists is performed by testing the LSB of the ReceiveMask. Each time LSB is set,
	// the first frame on the list can be moved to the ReceiveList, and the mask is shifted right.
	// As each frame is moved to the ReceiveList,  the EOM flag must be checked for and if set,  then
	// everything on the ReceiveList should be moved to the CompleteList for indication to the user.

	BOOL fPoll = pFrame->bCommand & PACKET_COMMAND_POLL;
	BOOL fSendInstantAck = pFrame->bControl & PACKET_CONTROL_END_STREAM;

	if(bSeq == pEPD->bNextReceive)
	{
		// Frame is the next expected # in sequence

		DPFX(DPFPREP,8, "(%p) Receiving In-Order Frame, pRCD[%p]", pEPD, pRCD);
		ReceiveInOrderFrame(pEPD, pRCD, ppRcvBuffToFree);	// Build frame into message AND move adjacent frames off OddFrameList

		// NOTE: ReceiveInOrderFrame may have caused the frame to be freed via DropReceive
		// so we absolutely must not use pFrame past this point!

		// See if we need to respond right away...
		//
		//	Because there are lots of way to generate POLL bits (full window, empty queue, poll count) we sometimes find ourselves
		// generating too much dedicated ack-traffic.  Therefore,  we will treat the POLL not as Respond-Immediately but instead as
		// Respond-Soon. We will not wait the full Delayed_Ack_Timeout interval but we will wait long enough to allow a quick piggyback
		// response (say 5ms) (we may want this longer on a slow connection...)

		// Is he asking for an instant response?
		if(fSendInstantAck)
		{
			DPFX(DPFPREP,7, "(%p) Sending Ack Frame", pEPD);
			SendAckFrame(pEPD, 0);						// Send Ack w/timing info
		}
		// Is he asking for a response soon?
		else if(fPoll)
		{
			if(pEPD->DelayedAckTimer != NULL)
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
				if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique)!= DPN_OK)
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					LOCK_EPD(pEPD, "LOCK (re-start delayed ack timer)");
				}
			}
			else 
			{
				LOCK_EPD(pEPD, "LOCK (start short delayed ack timer)");
			}
			DPFX(DPFPREP,7, "Delaying POLL RESP");
			pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

			DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
			ScheduleProtocolTimer(pSPD, 4, 4, DelayedAckTimeout, (PVOID) pEPD,
													&pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}
		else if(pEPD->DelayedAckTimer == 0)
		{
			// If timer is not running better start it now
			LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");	// Bump RefCnt for timer
			ScheduleProtocolTimer(pSPD, DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, 
														&pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}
	}		// IF frame is in order

	else 
	{	
		// Frame arrives out of order

		// bit location in mask for this frame
		bit = (BYTE) ((bSeq - pEPD->bNextReceive) - 1);						

		// Make sure this is not a duplicate frame
		if( ((bit < 32) && (pEPD->ulReceiveMask & (1 << bit))) || ((bit > 31) && (pEPD->ulReceiveMask2 & (1 << (bit - 32)))) ) 
		{
			DPFX(DPFPREP,7, "(%p) REJECT DUPLICATE OUT-OF-ORDER Frame Seq=%x", pEPD, bSeq);
		
			Unlock(&pEPD->EPLock);
			pRCD->pRcvBuff = NULL;
			RELEASE_RCD(pRCD);
			return DPN_OK;
		}
		
		DPFX(DPFPREP,8, "(%p) Receiving Out-of-Order Frame, pRCD[%p]", pEPD, pRCD);
		ReceiveOutOfOrderFrame(pEPD, pRCD, bit, ppRcvBuffToFree);

		// NOTE: ReceiveOutOfOrderFrame may have caused the frame to be freed via DropReceive
		// so we absolutely must not use pFrame past this point!

		if(fPoll)
		{
			if(pEPD->DelayedAckTimer != NULL)
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
				if(CancelProtocolTimer(pSPD, pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique)!= DPN_OK)
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					LOCK_EPD(pEPD, "LOCK (re-start delayed ack timer)");
				}

				// Start an abreviated delayed ack timer in case NACK gets cancelled
			}
			else 
			{
				LOCK_EPD(pEPD, "LOCK (start short delayed ack timer)");
			}

			DPFX(DPFPREP,7, "Delaying POLL RESP");
			pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

			DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
			ScheduleProtocolTimer(pSPD, 5, 5, DelayedAckTimeout, (PVOID) pEPD, 
															&pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}

	}	
	// EPD->StateLock is still HELD
	//
	// We use a FLAG for exclusive access to ReceiveComplete routine. This is safe because the flag is only
	// tested and modified while holding the EPD->StateLock.  Lets be sure to keep it that way...

	if (! pEPD->blCompleteList.IsEmpty())
	{
		if (! (pEPD->ulEPFlags & EPFLAGS_IN_RECEIVE_COMPLETE))
		{
			DPFX(DPFPREP,8, "(%p) Completing Receives...", pEPD);
			pEPD->ulEPFlags |= EPFLAGS_IN_RECEIVE_COMPLETE;	// ReceiveComplete will clear this flag when done
			ReceiveComplete(pEPD); 							// Deliver the goods,  returns with EPLock released
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Already in ReceiveComplete, letting other thread handle receives", pEPD);
			Unlock(&pEPD->EPLock);
		}
	}
	else
	{
		Unlock(&pEPD->EPLock);
	}

	DPFX(DPFPREP,8, "(%p) Completing Sends...", pEPD);
	CompleteSends(pEPD);

	return DPNERR_PENDING;
}

/*
**		Receive In Order Frame
**
**		The interesting part of this function is moving frames off of the OddFrameList that
**	the new frame adjoins.  This may also be called with a NULL frame which will happen when
**	a cancelled frame is the next-in-order receive.
**
**		One result of having cancelled frames running around is that we may miss the SOM or EOM
**	flags which delimit messages.  Therefore, we must watch as we assemble messages that we do not
**	see unexpected flags,  ie a new message w/o an SOM on first frame which means that part of the
**	message must have been lost,  and the whole thing must be trashed...
**
**	** EPLOCK is HELD through this entire function **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveInOrderFrame"

VOID
ReceiveInOrderFrame(PEPD pEPD, PRCD pRCD, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	PSPD	pSPD = pEPD->pSPD;
	CBilink	*pLink;
	UINT	flag;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Condensing Loop  WHILE (Next In-Order Frame has been received)
	do 
	{	
		ASSERT(pRCD->bSeq == pEPD->bNextReceive);

		pEPD->tLastDataFrame = pRCD->tTimestamp;		// Always keep the receive time of (N(R) - 1)
		pEPD->bLastDataRetry = (pRCD->bFrameControl & PACKET_CONTROL_RETRY);
#ifdef DBG
		pEPD->bLastDataSeq = pRCD->bSeq;
#endif // DBG
		pRCD->pMsgLink = NULL;
		if(pEPD->pNewMessage == NULL)
		{				
			// Add this frame to the in-order rcv list

			// pNewMessage implies we have no current message, head or tail
			ASSERT(pEPD->pNewTail ==  NULL);		

			if(!(pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG))
			{
				// There is no NEW_MESSAGE flag on the first frame we see. We must
				// have lost the first frame or this is an invalid packet.  We can throw
				// this frame away...
				DPFX(DPFPREP,1, "(%p) NEW_MESSAGE flag not set on first frame of message, scrapping frame (%x)", pEPD, pRCD->bSeq);

				pRCD->ulRFlags |= RFLAGS_FRAME_LOST;
				pRCD->bFrameFlags |= PACKET_COMMAND_END_MSG;			// Turn this on so we will release buffer right away
			}
				//N.B. We don't bother checking to see if the first frame exceeds the maximum message size
				//we accept. If its a single frame message then we'll handle scanning out oversize messages
				//in the ReceiveComplete function. If its the start of a message spread over multiple frames
				//then we'll drop everything when the second frame arrives

			// Even if we get rid of it, we will need these below
			pEPD->pNewMessage = pRCD;				
			pEPD->pNewTail = pRCD;
			pRCD->uiFrameCount = 1;
			pRCD->uiMsgSize = pRCD->uiDataSize;

			DPFX(DPFPREP,8, "(%p) Queuing Frame (NEW MESSAGE) (%x)", pEPD, pRCD->bSeq);
		}
		else
		{
			if (pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)
			{
				// We are getting the start of a new message in the start of an existing message, drop it all
				DPFX(DPFPREP,1, "(%p) NEW_MESSAGE flag set in the middle of existing message, scrapping message (%x, %x)", pEPD, pEPD->pNewMessage->bSeq, pRCD->bSeq);

				pRCD->ulRFlags |= RFLAGS_FRAME_LOST;
				pRCD->bFrameFlags |= PACKET_COMMAND_END_MSG;			// Turn this on so we will release buffer right away
			}

			ASSERT((pEPD->pNewTail->bSeq) == (BYTE)(pRCD->bSeq - 1)); // Make sure they stay sequential
			
			pEPD->pNewTail->pMsgLink = pRCD;
			pEPD->pNewMessage->uiFrameCount++;
			pEPD->pNewMessage->uiMsgSize += pRCD->uiDataSize;
			pEPD->pNewMessage->ulRFlags |= (pRCD->ulRFlags & RFLAGS_FRAME_LOST);// UNION FRAME_LOST flag from all frames of a message
			pEPD->pNewTail = pRCD;

			if (pEPD->pNewMessage->uiMsgSize>pSPD->pPData->dwMaxRecvMsgSize)
			{
				DPFX(DPFPREP,1, "(%p) Message size exceeds maximum accepted. Dropping frames in middle of multipart "
							"receive uiMsgSize[%u], MaxRecvMsgSize[%u]", pEPD, pEPD->pNewMessage->uiMsgSize, 
																		pSPD->pPData->dwMaxRecvMsgSize);

				pRCD->ulRFlags |= RFLAGS_FRAME_LOST;
				pRCD->bFrameFlags |= PACKET_COMMAND_END_MSG;			// Turn this on so we will release buffer right away
			}

			DPFX(DPFPREP,8, "(%p) Queuing Frame (ON TAIL) (%x)", pEPD, pRCD->bSeq);
		}

		if(pRCD->bFrameFlags & PACKET_COMMAND_END_MSG) 
		{
			// Either this frame completes a message or we decided to drop this one above

			// All frames on the ReceiveList should now be removed and delivered

			// Get either the message we are dropping above, or the beginning of the sequence of messages we are completing
			pRCD = pEPD->pNewMessage;
			pEPD->pNewMessage = NULL;

			if(pRCD->ulRFlags & RFLAGS_FRAME_LOST)
			{
				// We need to throw this away
				DPFX(DPFPREP,7, "(%p) Throwing away message with missing frames (%x, %x)", pEPD, pRCD->bSeq, pEPD->pNewTail->bSeq);
				pEPD->pNewTail = NULL;
				DropReceive(pEPD, pRCD, ppRcvBuffToFree);
			}
			else
			{
				// We need to complete this sequence
				pRCD->blCompleteLinkage.InsertBefore( &pEPD->blCompleteList);	// place on end of Completion list
				DPFX(DPFPREP,7, "(%p) Adding msg to complete list FirstSeq=%x, LastSeq=%x QueueSize=%d", 
										pEPD, pRCD->bSeq, pEPD->pNewTail->bSeq, pEPD->uiCompleteMsgCount);
				pEPD->pNewTail = NULL;
				pEPD->uiCompleteMsgCount++;

#ifdef DBG
				// This is guaranteed to at least be 1 since we just incremented it above
				if ((pEPD->uiCompleteMsgCount % 128) == 0)
				{
					DPFX(DPFPREP, 1, "(%p) Receives waiting to be completed count has grown to %d, app is slow processing receives", pEPD, pEPD->uiCompleteMsgCount);
				}
#endif // DBG
			}
		}

		// 		Since we are allowing out of order indication of receives it is possible that frames later than
		// the new one have already been indicated.  This means that there may be bits set in the ReceiveMask
		// whose correlating frames do not need to be indicated.  The most straightforward way to implement this
		// is to leave the early-indicated frames in the list,  but mark them as INDICATED_NONSEQ.  So inside this
		// master DO loop there will be an inner DO loop which passes over INDICATED frames and just takes them off
		// the list.
		//
		//		Now its possible that a NonSeq indicated frame is still sitting on the CompleteList awaiting indication,
		// so I am using a ref count.  An extra ref is added when a frame is completed non-seq.  When a completed frame
		// is removed below we will release one reference,  and the indication code will release one reference when it
		// finishes on that end.  Happily,  we can release the actual buffers while the RCD turd is still sitting on the
		// OddFrameList.

		BOOL fIndicatedNonSeq = FALSE;
		do 
		{
			flag = pEPD->ulReceiveMask & 1;				// set flag if next frame in stream is present

			pEPD->bNextReceive += 1;					// Update receive window
			RIGHT_SHIFT_64(pEPD->ulReceiveMask2, pEPD->ulReceiveMask);// shift mask because base has changed
			DPFX(DPFPREP,7, "(%p) N(R) incremented to %x, Mask %x %x", pEPD, pEPD->bNextReceive, pEPD->ulReceiveMask2, pEPD->ulReceiveMask);

				//if we're fully signing the link and we just we got 3/4's way through the sequence space then
				//we're now in a position to modify the remote secret. We'll still need to hang onto the
				//existing secret because for the next 1/4 of the sequence space we'll still need to use it
				//to validate incoming data
			if ((pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK) && (pEPD->bNextReceive==SEQ_WINDOW_3Q))
			{
				pEPD->ullOldRemoteSecret=pEPD->ullCurrentRemoteSecret;
				pEPD->byRemoteSecretModifierSeqNum=SEQ_WINDOW_3Q;
				pEPD->ullCurrentRemoteSecret=GenerateNewSecret(pEPD->ullCurrentRemoteSecret, pEPD->ullRemoteSecretModifier);
			}

			if(flag) 
			{
				// The next frame in the sequence has arrived already since low bit of ulReceiveMask was set

				// Several things can happen here:
				// 1) We are in the middle of a message, in which case, its next piece is on the out of order list
				// 2) We have just finished a message, which leaves two subcases:
				//		a) We are beginning a new message.  In this case our first piece is on the out of order list
				//		b) Out-of-order non-sequential messages have completed while we were completing our in-order message
				//		   In this case there are some already indicated RCDs on the out of order list, and a new partial
				//		   message may or may not follow.
				pLink = pEPD->blOddFrameList.GetNext();

				ASSERT(pLink != &pEPD->blOddFrameList); // Make sure we didn't run out of RCDs on the list
				pRCD = CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage);
				ASSERT_RCD(pRCD);
				pLink->RemoveFromList();							// take next frame out of OddFrameList

				// Make sure everything previous got removed from the odd frame list, and it is sorted correctly
				ASSERT(pRCD->bSeq == pEPD->bNextReceive);

				if (pRCD->ulRFlags & RFLAGS_FRAME_INDICATED_NONSEQ)
				{
					if (pEPD->pNewMessage)
					{
						// We need to throw this away
						PRCD pRCDTemp = pEPD->pNewMessage;
						pEPD->pNewMessage = NULL;

						DPFX(DPFPREP,1, "(%p) Throwing away non-ended message (%x, %x)", pEPD, pRCDTemp->bSeq, pEPD->pNewTail->bSeq);

						pEPD->pNewTail = NULL;
						DropReceive(pEPD, pRCDTemp, ppRcvBuffToFree);
					}

					fIndicatedNonSeq = TRUE;

					DPFX(DPFPREP,7, "(%p) Pulling Indicated-NonSequential message off of Out-of-Order List Seq=%x", pEPD, pRCD->bSeq);

					pEPD->tLastDataFrame = pRCD->tTimestamp;		// Always keep the receive time of (N(R) - 1)
					pEPD->bLastDataRetry = (pRCD->bFrameControl & PACKET_CONTROL_RETRY);
					DEBUG_ONLY(pEPD->bLastDataSeq = pRCD->bSeq);

					RELEASE_RCD(pRCD);
				}
				else
				{
					// In the case of cancelling one of the messages in the middle of a large message,
					// we will drop all previous, drop that one, and then we will get to a situation where we aren't
					// currently working on a new message (pNewMessage was NULL'ed in the cancelling) and the current 
					// message does not have the NEW_MSG flag, in which case we scrap it above.

					ASSERT(!fIndicatedNonSeq || (pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG) ||
						(!pEPD->pNewMessage && !(pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)));

					// go ahead and move this to the receive list
					DPFX(DPFPREP,7, "(%p) Moving OutOfOrder frame to received list Seq=%x", pEPD, pRCD->bSeq);

					ASSERT(pRCD->bSeq == pEPD->bNextReceive);

					break; // Back to the top
				} 
			}
		} 
		while (flag);	// DO WHILE (There are still in order frames that have already arrived with no incomplete messages)
	} 
	while (flag);		// DO WHILE (There are still in order frames that have already arrived with an incomplete message)

	if((pEPD->ulReceiveMask | pEPD->ulReceiveMask2)==0)
	{
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
		if(((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)&&(pEPD->DelayedMaskTimer != NULL))
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
			if(CancelProtocolTimer(pSPD, pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
			{
				DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMask)"); // SPLock not already held
				pEPD->DelayedMaskTimer = 0;
			}
			else
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
			}
		}
	}
}

/*
**		Receive Out Of Order Frame
**
**		Its like the title says.  We must set the appropriate bit in the 64-bit ReceiveMask
**	and then place it into the OddFrameList in its proper sorted place.  After that,  we must
**	scan to see if a complete message has been formed and see if we are able to indicate it
**	early.
**
**	** EPLOCK is HELD through this entire function **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveOutOfOrderFrame"

VOID
ReceiveOutOfOrderFrame(PEPD pEPD, PRCD pRCD, ULONG bit, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	PSPD	pSPD = pEPD->pSPD;
	PRCD	pRCD1;
	PRCD	pRCD2;
	CBilink	*pLink;
	BYTE	NextSeq;
	ULONG	highbit;
	ULONG	Mask;
	ULONG	WorkMaskHigh;
	ULONG	WorkMaskLow;
	ULONG	MaskHigh;
	ULONG	MaskLow;
	BOOL	nack = FALSE;
	UINT	count;
	BOOL	lost = FALSE;

	UINT	frame_count = 0;
	UINT	msg_length = 0;

	DPFX(DPFPREP,8,"(%p) Received out of order frame, Seq=%x, bit=%x", pEPD, pRCD->bSeq, bit);

	// Bit shouldn't be more than 64 (MAX_RECEIVE_RANGE)
	ASSERT(bit <= MAX_RECEIVE_RANGE);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	//	RECEIVE OUT OF ORDER FRAME
	//
	//  DO WE SEND IMMEDIATE ACK FOR THIS OUT OF ORDER FRAME?
	//
	//		When we receive an OutOfOrder frame it is almost certainly because the missing frame has been lost.
	// So we can accelerate the re-transmission process greatly by telling partner right away that frames
	// are missing. HOWEVER,  with a large send window we will get many mis-ordered frames for each drop,
	// but we only want to send a Negative Ack once.  SO, we will only initiate a NACK here if we have
	// created a NEW HOLE in our receive mask!
	//
	// 		First,  we will not have created a new hole unless we added to the END of the OddFrameList.
	//		Second, we will not have created a new hole unless the FIRST BIT TO THE RIGHT of the new bit
	//	is CLEAR.
	//
	//	So we will only generate an immediate NACK frame if both of the above cases are true!
	//	NOTE - if this is the only OoO frame, then we should always send a NACK
	//
	//  ANOTHER NOTE.  SP  implementation has been changed so that it frequently misorders receives in close
	// proximity.  One effect of this is that we must not immediately send a NACK for an out of order frame, but
	// instead should wait a short period (say ~5ms) and see if the missing frame hasn't shown up.

	// Make sure this RCD is within the receive window
	// NOTE: Presume SACK arrives with bNSeq of 84, N(R) is 20, and all bits are set except the one representing 20.
	// In that case, pRCD->bSeq - pEPD->bNextReceive will be equal to 63 (ie MAX_FRAME_OFFSET).
	ASSERT((BYTE)(pRCD->bSeq - pEPD->bNextReceive) <= (BYTE)MAX_FRAME_OFFSET);
		
	// We will insert frame in OddFrameList maintaining sort by Seq number
	//
	// We can optimize for most likely case,  which is new frames are added to END of list.  We can
	// check for this first case by investigating whether the new bit is the left-most bit in the mask.
	// If it is LMB,  then it trivially gets added to the END of the list.
	//
	// Please note that both this and the following algorithms assume that we have already verified
	// that the new frame is NOT already in the list

	MaskLow = pEPD->ulReceiveMask;					// Get scratch copy of Mask
	MaskHigh = pEPD->ulReceiveMask2;

	if(bit < 32)
	{									
		// Frame is within 32 of N(Rcv)	
		WorkMaskLow = 1 << bit;						// Find bit in mask for new frame
		WorkMaskHigh = 0;
		pEPD->ulReceiveMask |= WorkMaskLow;			// Set appropriate bit in mask

		// check immediately preceeding bit for NACK determination
		if( (MaskLow & (WorkMaskLow >> 1)) == 0)
		{	
			nack = TRUE;							// preceeding bit is not set
		}
	}
	else 
	{
		highbit = bit - 32;
		WorkMaskHigh = 1 << highbit;
		WorkMaskLow = 0;
		pEPD->ulReceiveMask2 |= WorkMaskHigh;		// Set appropriate bit in mask

		if(highbit)
		{
			// check preceeding bit for NACK determination
			if( (MaskHigh & (WorkMaskHigh >> 1)) == 0)
			{	
				nack = TRUE;						// preceeding bit is not set
			}
		}
		else
		{
			if( (MaskLow & 0x80000000) == 0)
			{
				nack = TRUE;
			}
		}
	}

	// Insert frame in sorted OddFrameList.
	//
	//		First test for trivial insert at tail condition.  True if new bit is LEFTMOST set bit in
	// both masks.

	if( (WorkMaskHigh > MaskHigh) || ( (MaskHigh == 0) && (WorkMaskLow > MaskLow) ) )
	{	
		// TAIL INSERTION
		DPFX(DPFPREP,7, "(%p) Received %x OUT OF ORDER - INSERT AT TAIL NRcv=%x MaskL=%x MaskH=%x",
							pEPD, pRCD->bSeq, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
		pLink = &pEPD->blOddFrameList;

		// Make sure this is either the only RCD in the list, or it is farther in the window than the last one
		ASSERT(pLink->IsEmpty() || ((BYTE)(CONTAINING_OBJECT(pLink->GetPrev(), RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));
		pRCD->blOddFrameLinkage.InsertBefore( pLink);

		// Check to see if we should NACK (negative acknowledge) any frames.  We only want to NACK a given
		// frame once so we will NACK if this is the first frame added to the OOF list, or if the immediately
		// preceeding frame is missing.  First condition is trivial to test.

		if( ((MaskLow | MaskHigh) == 0) || (nack == 1) )
		{
			pEPD->ulEPFlags |= EPFLAGS_DELAYED_NACK;
			
			if(pEPD->DelayedMaskTimer == 0)
			{
				DPFX(DPFPREP,7, "(%p) Setting Delayed Mask Timer", pEPD);
				LOCK_EPD(pEPD, "LOCK (DelayedMaskTimer)");	// Bump RefCnt for timer
				ScheduleProtocolTimer(pSPD, SHORT_DELAYED_ACK_TIMEOUT, 5, DelayedAckTimeout, 
												(PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
				pEPD->tReceiveMaskDelta = GETTIMESTAMP();
			}
			else 
			{
				DPFX(DPFPREP,7, "(%p) *** DELAYED NACK *** Timer already running", pEPD);
			}
		}
	}
	else 
	{	
		// NOT TAIL INSERTION

		// This is the non-trivial case,  ie new frame goes at beginning or in middle of OddFrameList.
		// So we need to count the ONE bits that are to the RIGHT of the new bit in the ReceiveMask.
		// We will mask off bits higher then the New Bit and then do a quick bit-count...

		DPFX(DPFPREP,7, "(%p) Receive OUT OF ORDER - Walking Frame List (Seq=%x, NRcv=%x) MaskL=%x MaskH=%x", 	pEPD, pRCD->bSeq, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);

		// If we are inserting into high mask,  we must count all one-bits in low mask
		//
		// We will test for the special case of all-bits-set at the outset...

		pLink = pEPD->blOddFrameList.GetNext();			// pLink = First frame in list; we will walk list as we count

		if(WorkMaskHigh)
		{
			// new frame in high mask. only count bits to right of new bit
			WorkMaskHigh -= 1;						// Convert to mask preserving all bits to right of new bit
			WorkMaskHigh &= MaskHigh;				// WMH now represents all bits to right of new bit
			while(WorkMaskHigh)
			{
				// Make sure this is farther in the window than the one we are skipping
				ASSERT(((BYTE)(CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

				// Count bits in WMH
				Mask = WorkMaskHigh - 1;
				WorkMaskHigh &= Mask;
				pLink = pLink->GetNext();
			}
			if(MaskLow == 0xFFFFFFFF)
			{
				// special case if low mask is full
				for(count = 0; count < 32; count++)
				{
					// Make sure this is farther in the window than the one we are skipping
					ASSERT(((BYTE)(CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

					pLink = pLink->GetNext();
				}
			}
			else
			{					
				// else count all bits in lower mask
				while(MaskLow)
				{
					// Make sure this is farther in the window than the one we are skipping
					ASSERT(((BYTE)(CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

					Mask = MaskLow - 1;
					MaskLow &= Mask;			// Mask off low 1-bit
					pLink = pLink->GetNext();
				}
			}
		}
		else 
		{
			WorkMaskLow -= 1;
			WorkMaskLow &= MaskLow;					// WML == bits to the right of new bit

			while(WorkMaskLow)
			{
				// Make sure this is farther in the window than the one we are skipping
				ASSERT(((BYTE)(CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

				Mask = WorkMaskLow - 1;
				WorkMaskLow &= Mask;				// Mask off low 1-bit
				pLink = pLink->GetNext();
			}
		}

		// Make sure this is farther in the window than the last one
		ASSERT(((BYTE)(CONTAINING_OBJECT(pLink->GetPrev(), RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

		pRCD->blOddFrameLinkage.InsertBefore( pLink);		// Insert new frame in sorted list

	}  // Receive not at tail

#ifdef DBG
	// Dump the contents of the Out of Order Frame List for verification.  There are at most 64 frames.
	{
		BYTE bCurSeq = pEPD->bNextReceive + 1;
		ULONG64 ulMask = ((ULONG64)pEPD->ulReceiveMask2 << 32) | ((ULONG64)pEPD->ulReceiveMask);
		CBilink* pTemp;
		TCHAR szOOFL[256];
		szOOFL[0] = 0;
		pTemp = pEPD->blOddFrameList.GetNext();
		while (pTemp != &pEPD->blOddFrameList)
		{
			while (ulMask != 0 && !(ulMask & 1))
			{
				ulMask >>= 1;
				bCurSeq++;
			}
			ASSERT(ulMask != 0);

			PRCD pRCDTemp = CONTAINING_OBJECT(pTemp, RCD, blOddFrameLinkage);
			ASSERT_RCD(pRCDTemp);

			ASSERT(bCurSeq == pRCDTemp->bSeq);

			wsprintf(szOOFL, _T("%s %02x"), szOOFL, pRCDTemp->bSeq);

			ulMask >>= 1;
			bCurSeq++;
			pTemp = pTemp->GetNext();
		}
		DPFX(DPFPREP, 7, "OOFL contents: %s", szOOFL);
	}
#endif // DBG

	// 	**	Non-Sequential Indication
	//
	//		This is the Non-Trivial implementation of non-sequential receive indication.
	//	We will work from the assumption that we  only need to complete messages that are touched by the new frame.
	//	So we must back up in the OddFrame list until we see either a gap or a Start of Message marker. Then we must work
	// 	forward looking for an End of Message...
	//
	//		One more complication is the fact that dropped packets might in the list via place-holding dummies.  Since we
	//	do not know what SOM/EOM flags would have been present on a dropped frame,  we can consider them to have BOTH flags.
	//	Then we also need to be aware that frames bordering on dropped frames without a delimiter (SOM or EOM) are fragments
	//	and therefore count as dropped data too.  I think to keep this from getting too complex,  we wont probe further for
	//	neighbors of lost data frames.  We will discover them when we are building a message later.
	//
	//	pLink = Item after new element in Out of Order list
	//	pRCD  = new Item

	// IF this frame is not marked as SEQUENTIAL
	if((pRCD->bFrameFlags & PACKET_COMMAND_SEQUENTIAL)==0)
	{	
		DPFX(DPFPREP,7, "(%p) Received Non-Seq %x out of order; flags=%x", pEPD, pRCD->bSeq, pRCD->bFrameFlags);
		NextSeq = pRCD->bSeq;
			
		// NOTE: The first pLink will be the passed in RCD so we will have included that in the frame_count and msg_length after leaving this while
		while ( (pLink = pLink->GetPrev()) != &pEPD->blOddFrameList )
		{
			pRCD1 = CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage);
			ASSERT_RCD(pRCD1);

			frame_count++;
			msg_length += pRCD1->uiDataSize;

			if((pRCD1->bFrameFlags & PACKET_COMMAND_NEW_MSG) || (pRCD1->bSeq != NextSeq))
			{
				break;		// Stop probing when we find a NEW_MSG flag OR a gap in the frame sequence numbers
			}
			--NextSeq;
		}

		// We have either found a NEW_MSG or a sequence gap.  If its a NEW_MSG, then we probe forward for an END_MSG
		if((pRCD1->bFrameFlags & PACKET_COMMAND_NEW_MSG) && (pRCD1->bSeq == NextSeq))
		{
			// So far so good.  We have a sequential message start frame
			//
			//	pRCD  = frame just arrived
			//	pRCD1 = Start of message frame
			//	pLink = Start of message linkage

			pLink = &pRCD->blOddFrameLinkage;
			NextSeq = pRCD->bSeq;

			// Look for the message end or a sequence gap
			while ( ( (pRCD->bFrameFlags & PACKET_COMMAND_END_MSG)==0 ) && (pRCD->bSeq == NextSeq))
			{
				// Stop if we hit the end of the OddFrameList
				if((pLink = pLink->GetNext()) == &pEPD->blOddFrameList)
				{
					break;
				}

				// NOTE: the first pLink here will be the one after the passed in RCD.  If there is a gap that won't 
				// matter because we are out of here after the next if.  If it is the next message we will continue until
				// we hit the END_MSG and have a proper frame_count and msg_length.
				pRCD = CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage);
				ASSERT_RCD(pRCD);
				frame_count++;
				msg_length += pRCD->uiDataSize;
				NextSeq++;
			}

			// pLink should not be used after this point due to the way the above while could have left it either valid
			// or at &pEPD->blOddFrameList.
			pLink = NULL;

			if((pRCD->bFrameFlags & PACKET_COMMAND_END_MSG) && (pRCD->bSeq == NextSeq))
			{
				// We have completed a message
				//
				// pRCD1 = First frame in message
				// pRCD = Last frame in message

				DPFX(DPFPREP,7, "(%p) Completed Non-Seq Msg: First=%x, Last=%x", pEPD, pRCD1->bSeq, pRCD->bSeq);

				lost = FALSE;

				pRCD->ulRFlags |= RFLAGS_FRAME_INDICATED_NONSEQ;
				pRCD->pMsgLink = NULL;
				lost |= pRCD->ulRFlags & RFLAGS_FRAME_LOST;
				
				// Get the pointer to the next to last message so we can remove the last
				pLink = pRCD->blOddFrameLinkage.GetPrev();
				LOCK_RCD(pRCD); // ReceiveInOrderFrame must remove this

				// Walk from the last message to the first message accumulating lost flags, linking messages, 
				// setting indicated flag, and pulling off of the odd frame list
				while (pRCD != pRCD1)
				{
					ASSERT(pLink != &pEPD->blOddFrameList); // Make sure we didn't run out of RCDs on the list
					pRCD2 = CONTAINING_OBJECT(pLink, RCD, blOddFrameLinkage);
					ASSERT_RCD(pRCD2);
					pRCD2->pMsgLink = pRCD;
					LOCK_RCD(pRCD2); // ReceiveInOrderFrame must remove this

					pRCD2->ulRFlags |= RFLAGS_FRAME_INDICATED_NONSEQ;
					lost |= pRCD2->ulRFlags & RFLAGS_FRAME_LOST;
					pLink = pRCD2->blOddFrameLinkage.GetPrev();

					pRCD = pRCD2;
				}
				
				// Both RCD and RCD1 point to the first message now

				// If any were lost, drop the receive, otherwise complete it
				if(!lost)
				{
					pRCD->uiFrameCount = frame_count;
					pRCD->uiMsgSize = msg_length;
					DPFX(DPFPREP,7, "(%p) Adding msg to complete list FirstSeq=%x QueueSize=%d", pEPD, pRCD->bSeq, pEPD->uiCompleteMsgCount);
					pRCD->blCompleteLinkage.InsertBefore( &pEPD->blCompleteList);
					pEPD->uiCompleteMsgCount++;
				}
				else
				{
					DPFX(DPFPREP,7, "(%p) Complete Non-Seq MSG is dropped due to missing frames", pEPD);
					DropReceive(pEPD, pRCD, ppRcvBuffToFree);
				}
			}
		} // else  there is nothing to complete at this time...
	}	// IF NON SEQUENTIAL
}

/*
**		Drop Receive
**
**			One or more frames composing a message have been dropped,  so the entire message can be scrapped.
**		If this was determined during an out of order receive then the RCDs will remain on the OddFrameList
**		as usual.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DropReceive"

VOID
DropReceive(PEPD pEPD, PRCD pRCD, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	PRCD 					pNext;
	
	while(pRCD != NULL)
	{
		ASSERT_RCD(pRCD);

		if (pRCD->bFrameFlags & PACKET_COMMAND_RELIABLE)
		{
			DPFX(DPFPREP,1, "(%p) Dropping G receive frame %x!!!", pEPD, pRCD->bSeq);
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Dropping NG receive frame %x", pEPD, pRCD->bSeq);
		}

		RELEASE_SP_BUFFER(*ppRcvBuffToFree, pRCD->pRcvBuff);

		pNext = pRCD->pMsgLink;
		RELEASE_RCD(pRCD);
		pRCD = pNext;
	}
}

/*
**		Receive Complete
**
**		We have received an entire reliable message,  potentially spanning
**	multiple messages.  We are still on the receive thread right now so depending
**	upon our desired indication behavior we will either indicate it directly or
**	else queue it to be indicated on a background thread of some sort.
**
**		Messages spanning multiple frames (for now) will be copied into a contiguous
**	buffer for delivery.  CODEWORK -- Server implementations should be able to receive
**	large messages as buffer chains (or arrays of BufDescs).
**
**		This is also where we must notice that an End Of Stream flag is set in a message,
**	indicating that the connection is being closed.
**
**	*** CALLED WITH EPD->STATELOCK HELD *** RETURNS WITH STATELOCK RELEASED  ***
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveComplete"

VOID
ReceiveComplete(PEPD pEPD)
{
	CBilink					*pLink;
	PRCD					pRCD;
	PRCD					pNext;
	PSPRECEIVEDBUFFER		pRcvBuff = NULL;
	PBIGBUF					pBuf;
	PBYTE					write;
	UINT					length;
	UINT					frames;
	DWORD					flag;
	UINT					MsgSize;
	HRESULT					hr;
	PProtocolData				pPData=pEPD->pSPD->pPData;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	while((pLink = pEPD->blCompleteList.GetNext()) != &pEPD->blCompleteList)
	{
		pLink->RemoveFromList();
		ASSERT(pEPD->uiCompleteMsgCount > 0);
		pEPD->uiCompleteMsgCount--;
		
		Unlock(&pEPD->EPLock);
		pRCD = CONTAINING_OBJECT(pLink, RCD, blCompleteLinkage);
		ASSERT_RCD(pRCD);
		
		// Handle easy case first
		if(pRCD->uiFrameCount == 1) // message is only 1 frame
		{
				//if data length is zero we've either got an old style keep alive or an EOS
				//alternatively if link supports signing and the keep alive bit is flicked we've
				//got a new style keep alive
			if (pRCD->uiDataSize==0 ||
				((pEPD->ulEPFlags2 & EPFLAGS2_SUPPORTS_SIGNING) && (pRCD->bFrameControl & PACKET_CONTROL_KEEPALIVE)))
			{
				DNASSERT(!(pRCD->bFrameControl & PACKET_CONTROL_COALESCE));
					//for EOS or old style keep alive there will be no data
					//for a new style keep alive there should be a DWORD session identity
				DNASSERT(pRCD->uiDataSize==0 || (pRCD->uiDataSize==sizeof(DWORD)));

					//if marked as end of stream handle the closure case
				if(pRCD->bFrameControl & PACKET_CONTROL_END_STREAM)
				{  
					// END OF STREAM indicated
					DPFX(DPFPREP,7, "(%p) Processing EndOfStream, pRCD[%p]", pEPD, pRCD);
					ProcessEndOfStream(pEPD);
				}
				
				RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);	// Really only queues it to be released
			}
				//else we've got some user data to indicate up
			else
			{
				DNASSERT(pRCD->pRcvBuff->pNext == NULL);
				pRCD->pRcvBuff->pServiceProviderDescriptor = pEPD->pSPD;

				if (pRCD->bFrameControl & PACKET_CONTROL_COALESCE)
				{
					PCOALESCEHEADER pCoalesceHeaders = (PCOALESCEHEADER) pRCD->pbData;
					DWORD dwSubFrame;
					BYTE* pbData;
					DWORD dwCoalesceDataSize;

					// Find the start of the data.  Skip the alignment padding, if there is any.
					pbData = (BYTE*) (pCoalesceHeaders + pRCD->dwNumCoalesceHeaders);
					DBG_CASSERT(sizeof(COALESCEHEADER) == 2);
					if ((pRCD->dwNumCoalesceHeaders & 1) != 0)
					{
						pbData += 2;
					}

					// We will borrow pNext to use as a ref count.  We must add one ref at the top of this
					// loop to ensure that the count doesn't go to zero before we indicate all of the 
					// pieces to the Core.
					pRCD->pRcvBuff->pNext = (_SPRECEIVEDBUFFER*)1;
					pRCD->pRcvBuff->dwProtocolData = RBT_SERVICE_PROVIDER_BUFFER_COALESCE;

					for(dwSubFrame = 0; dwSubFrame < pRCD->dwNumCoalesceHeaders; dwSubFrame++)
					{
						dwCoalesceDataSize = pCoalesceHeaders[dwSubFrame].bSize;
						dwCoalesceDataSize |= (DWORD) (pCoalesceHeaders[dwSubFrame].bCommand & (PACKET_COMMAND_COALESCE_BIG_1 | PACKET_COMMAND_COALESCE_BIG_2 | PACKET_COMMAND_COALESCE_BIG_3)) << 5;
						ASSERT((UINT) ((UINT_PTR) (pbData + dwCoalesceDataSize - pRCD->pbData)) <= pRCD->uiDataSize);

							//if message size exceeds the maximum size we just skip this subframe
							//otherwise update stats and indicate it up to core
						if (dwCoalesceDataSize>pPData->dwMaxRecvMsgSize)
						{
							DPFX(DPFPREP, 1, "(%p) Message size exceeds maximum accepted. Skipping subframe "
										"MsgSize[%u], MaxRecvMsgSize[%u]", pEPD, dwCoalesceDataSize, pPData->dwMaxRecvMsgSize);
						}
						else
						{
							DNInterlockedIncrement((LONG*)&pRCD->pRcvBuff->pNext);
							
							pEPD->uiMessagesReceived++;
						
							if(pCoalesceHeaders[dwSubFrame].bCommand & PACKET_COMMAND_RELIABLE)
							{
								pEPD->uiGuaranteedFramesReceived++;
								pEPD->uiGuaranteedBytesReceived += dwCoalesceDataSize;
							}
							else
							{
								pEPD->uiDatagramFramesReceived++;
								pEPD->uiDatagramBytesReceived += dwCoalesceDataSize;
							}
						
							flag = (((DWORD) pCoalesceHeaders[dwSubFrame].bCommand) & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);

							DEBUG_ONLY(DNInterlockedIncrement(&pEPD->pSPD->pPData->ThreadsInReceive));
							DEBUG_ONLY(DNInterlockedIncrement(&pEPD->pSPD->pPData->BuffersInReceive));

							AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

							DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceive (coalesced), pRCD[%p] (data 0x%p, %u, %u/%u), Core Context[%p]", pEPD, pRCD, pbData, dwCoalesceDataSize, dwSubFrame, pRCD->dwNumCoalesceHeaders, pEPD->Context);
							hr = pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pbData, dwCoalesceDataSize, pRCD->pRcvBuff, flag);
							if(hr == DPN_OK)
							{
								ASSERT(*((LONG*)&pRCD->pRcvBuff->pNext) > 1);
								DNInterlockedDecrement((LONG*)&pRCD->pRcvBuff->pNext);
							}
							else
							{
								ASSERT(hr == DPNERR_PENDING);
							}
							DEBUG_ONLY(DNInterlockedDecrement(&pEPD->pSPD->pPData->ThreadsInReceive));
						}
							
						// If this isn't the last packet, round up to the nearest DWORD alignment.
						if (! (pCoalesceHeaders[dwSubFrame].bCommand & PACKET_COMMAND_END_COALESCE))
						{
							dwCoalesceDataSize = (dwCoalesceDataSize + 3) & (~3);
						}

						pbData += dwCoalesceDataSize;
						ASSERT((UINT) ((UINT_PTR) (pbData - pRCD->pbData)) <= pRCD->uiDataSize);
					}
					DNPReleaseReceiveBuffer(pEPD->pSPD->pPData, pRCD->pRcvBuff);

					// The Core owns it now and is responsible for calling DNPReleaseReceiveBuffer to free it
					pRCD->pRcvBuff = NULL;
				}
				else
				{
						//if message size exceeds the maximum we accept then simply release the SP buffer
					if (pRCD->uiDataSize>pPData->dwMaxRecvMsgSize)
					{
						DPFX(DPFPREP, 1, "(%p) Message size exceeds maximum accepted. Dropping single frame "
							"MsgSize[%u], MaxRecvMsgSize[%u]", pEPD, pRCD->uiDataSize, pPData->dwMaxRecvMsgSize);
						RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);
					}
					else
					{
						pRCD->pRcvBuff->dwProtocolData = RBT_SERVICE_PROVIDER_BUFFER;

						pEPD->uiMessagesReceived++;
						
						if(pRCD->bFrameFlags & PACKET_COMMAND_RELIABLE)
						{
							pEPD->uiGuaranteedFramesReceived++;
							pEPD->uiGuaranteedBytesReceived += pRCD->uiDataSize;
						}
						else
						{
							pEPD->uiDatagramFramesReceived++;
							pEPD->uiDatagramBytesReceived += pRCD->uiDataSize;
						}
						
						flag = (((DWORD) pRCD->bFrameFlags) & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);

						DEBUG_ONLY(DNInterlockedIncrement(&pEPD->pSPD->pPData->ThreadsInReceive));
						DEBUG_ONLY(DNInterlockedIncrement(&pEPD->pSPD->pPData->BuffersInReceive));

						AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

						DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceive, pRCD[%p], Core Context[%p]", pEPD, pRCD, pEPD->Context);
						hr = pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pRCD->pbData, pRCD->uiDataSize, pRCD->pRcvBuff, flag);
						if(hr == DPN_OK)
						{
							RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);		// Really only queues it to be released
							DEBUG_ONLY(DNInterlockedDecrement(&pEPD->pSPD->pPData->BuffersInReceive));
						}
						else
						{
							ASSERT(hr == DPNERR_PENDING);

							// The Core owns it now and is responsible for calling DNPReleaseReceiveBuffer to free it
							pRCD->pRcvBuff = NULL;
						}
						DEBUG_ONLY(DNInterlockedDecrement(&pEPD->pSPD->pPData->ThreadsInReceive));
					}
				}
			}
			
			RELEASE_RCD(pRCD);								// Release reference for Complete Processing
			pRCD = NULL;
		}
		else // Message spans multiple frames
		{											
			ASSERT(!(pRCD->bFrameControl & PACKET_CONTROL_COALESCE));

				//if the message exceeds the maximum size permitted then don't allocate a buffer
				//otherwise get a single buffer large enough to hold data from multiple buffers
			MsgSize = pRCD->uiMsgSize;
			if (MsgSize>pPData->dwMaxRecvMsgSize)
			{
				DPFX(DPFPREP, 1, "(%p) Message size exceeds maximum accepted. Dropping multiple frames "
							"MsgSize[%u], MaxRecvMsgSize[%u]", pEPD, MsgSize, pPData->dwMaxRecvMsgSize);
				pBuf=NULL;
			}
			else if (MsgSize<= SMALL_BUFFER_SIZE)
			{
				pBuf = (PBIGBUF)POOLALLOC(MEMID_SMALLBUFF, &BufPool);
			}
			else if (MsgSize <= MEDIUM_BUFFER_SIZE)
			{
				pBuf = (PBIGBUF)POOLALLOC(MEMID_MEDBUFF, &MedBufPool);
			}
			else if (MsgSize <= LARGE_BUFFER_SIZE)
			{
				pBuf = (PBIGBUF)POOLALLOC(MEMID_BIGBUFF, &BigBufPool);
			}
			else
			{
				DPFX(DPFPREP,7, "(%p) RECEIVE HUGE MESSAGE", pEPD);
				// Receive is larger then our biggest static receive buffer.  This means we have to allocate a dynamic buffer.
				pBuf = (PBIGBUF) MEMALLOC(MEMID_HUGEBUF, MsgSize + sizeof(DYNBUF));
				if(pBuf)
				{
					pBuf->Type = RBT_DYNAMIC_BUFFER;
				}	
			}
			
			if(pBuf == NULL)
			{
				DPFX(DPFPREP,0, "(%p) Either mem alloc failed or message too large.  Cannot deliver data", pEPD);
				while(pRCD != NULL)
				{
					ASSERT_RCD(pRCD);
					pNext = pRCD->pMsgLink;
					RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);
					RELEASE_RCD(pRCD);
					pRCD = pNext;
				}
				Lock(&pEPD->EPLock);
				continue;								// blow it off!
			}
			write = pBuf->data;							// initialize write pointer
			length = 0;
			frames = 0;
			while(pRCD != NULL)
			{
				ASSERT_RCD(pRCD);
				memcpy(write, pRCD->pbData, pRCD->uiDataSize);
				write += pRCD->uiDataSize;
				length += pRCD->uiDataSize;
				frames++;
				pNext = pRCD->pMsgLink;
				flag = (DWORD) pRCD->bFrameFlags;
				RELEASE_SP_BUFFER(pRcvBuff, pRCD->pRcvBuff);
				RELEASE_RCD(pRCD);
				pRCD = pNext;
			}
			
			pEPD->uiMessagesReceived++;
			if(flag & PACKET_COMMAND_RELIABLE)
			{
				pEPD->uiGuaranteedFramesReceived += frames;
				pEPD->uiGuaranteedBytesReceived += length;
			}
			else
			{
				pEPD->uiDatagramFramesReceived += frames;
				pEPD->uiDatagramBytesReceived += length;
			}
			
			flag = (flag & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceive, Core Context[%p]", pEPD, pEPD->Context);
			hr = pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pBuf->data, length, pBuf, flag);
			if(hr == DPN_OK)
			{
				DNPReleaseReceiveBuffer(pEPD->pSPD->pPData, pBuf);
			}
			else
			{
				ASSERT(hr == DPNERR_PENDING);
			}
		}
		Lock(&pEPD->EPLock);
	}

	ASSERT(pEPD->blCompleteList.IsEmpty());
	pEPD->ulEPFlags &= ~(EPFLAGS_IN_RECEIVE_COMPLETE);	// Clear this before releasing Lock final time
	Unlock(&pEPD->EPLock);

	if(pRcvBuff != NULL)
	{
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->ReturnReceiveBuffers, pSPD[%p]", pEPD, pEPD->pSPD);
		IDP8ServiceProvider_ReturnReceiveBuffers(pEPD->pSPD->IISPIntf, pRcvBuff);
	}
}


/*
**		Process Send Mask
**
**		The send mask is what our partner uses to tell us to stop waiting for particular frames.
**	This will happen after an Unreliable frame is dropped.  Instead of retransmitting the unreliable
**	frame,  the sender will forward the appropriate bit in a send mask.  In this routine,  we attempt
**	to update our receive state pursuant to the newly received mask.
**
**		THIS IS CALLED WITH STATELOCK HELD AND RETURNS WITH STATELOCK HELD
**
**		suffice it to say that we should not release statelock anywhere in the following
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessSendMask"

VOID
ProcessSendMask(PEPD pEPD, BYTE bSeq, ULONG MaskLow, ULONG MaskHigh, DWORD tNow, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	PSPD	pSPD = pEPD->pSPD;
	INT		deltaS;
	ULONG	workmaskS;
	BYTE	bThisFrame;
	UINT	skip;

	ASSERT(MaskLow | MaskHigh);

	DPFX(DPFPREP,7, "(%p) PROCESS SEND MASK  N(R)=%x, bSeq=%x, MaskL=%x, MaskH=%x", pEPD, pEPD->bNextReceive, bSeq, MaskLow, MaskHigh);

	// The mask can only refer to frames earlier than the Seq number in this frame.  So if this frame
	// is the next In-Order then the mask can have nothing interesting in it.
	//
	// The SendMask is coded with decending frame numbers starting at the Seq in this frame - 1.
	// The ReceiveMask is coded with ascending frame numbers start at N(Rcv) + 1.
	//
	// We will walk forward through the rcvmask and backward through the sendmask looking for the magic combo
	// of a bit clear in the rcvmask and the corresponding bit set in the sendmask.  For each of these matches,
	// a dummy cancel frame can be 'received' for that sequence number.
	//
	// This would be fairly straightforward if it wasn't for the fact that both masks are 64 bits so the code has
	// to track which DWORD of each mask we are dealing with at any given time. 
	//
	// NOTE: It is perfectly legitimate for a SACK to come in with a bNSeq at MAX_FRAME_OFFSET from pEPD->bNextReceive.  Consider
	// the case where pEPD->bNextReceive is 0 and the sender has sent and timed out 0-63.  A SACK would arrive with a bNSeq of 64
	// and both masks fully set.

top:

	if (bSeq != pEPD->bNextReceive)
	{
		deltaS = (INT) (((BYTE)(bSeq - pEPD->bNextReceive)) - 1);			// count of frames between first missing frame and sequence base of mask
		bThisFrame = pEPD->bNextReceive;

		if ( deltaS <= MAX_FRAME_OFFSET ) 
		{
			// If the difference is greater then 32 frames then we need to look at the high mask first and
			// then fall through to the low mask.  Otherwise,  we can ignore the highmask and start with the low.
			while((deltaS > 31) && (MaskHigh)) // Any work to do in the upper bits?
			{
				workmaskS = 1 << (deltaS - 32); 	// walks bit positions backward in send mask
				
				// See if the next frame we are interested in is covered by this mask
				if(workmaskS & MaskHigh)
				{
					CancelFrame(pEPD, bThisFrame, tNow, ppRcvBuffToFree);
					MaskHigh &= ~workmaskS;

					// N(R) may have been bumped up multiple times by CancelFrame, reset to make sure we work with
					// up to date information.
					goto top;
				}
				else
				{
					bThisFrame++;
					deltaS--;
				}
			}

			if(deltaS > 31)
			{
				skip = deltaS - 31;								// how many bit positions did we skip
				bThisFrame += (BYTE) skip;
				deltaS -= skip;
			}

			while((deltaS >= 0) && (MaskLow)) // Any work to do in the lower bits?
			{
				workmaskS = 1 << deltaS;

				if(workmaskS & MaskLow)
				{
					CancelFrame(pEPD, bThisFrame, tNow, ppRcvBuffToFree);
					MaskLow &= ~workmaskS;

					// N(R) may have been bumped up multiple times by CancelFrame, reset to make sure we work with
					// up to date information.
					goto top;
				}
				else
				{
					bThisFrame++;
					deltaS--;
				}
			}
		}
	}

	// We need to ACK every time a send mask.  Consider the case of one way Non-Guaranteed traffic.  If data or an ACK gets lost,
	// this will be the only way we get back in sync with the other side.

	// If timer is not running better start it now
	if(pEPD->DelayedAckTimer == 0)
	{	
		LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");		// Bump RefCnt for timer
		pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;
		DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
		ScheduleProtocolTimer(pSPD, DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, 
								(PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "BuildCancelledRCD"

PRCD
BuildCancelledRCD(PEPD pEPD, BYTE bSeq, DWORD tNow)
{
	PRCD	pRCD;
	
	if((pRCD = (PRCD)POOLALLOC(MEMID_CANCEL_RCD, &RCDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate RCD");
		return NULL;
	}
	
 	pRCD->bSeq = bSeq;
	pRCD->bFrameFlags = PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG;
 	pRCD->bFrameControl = 0;
	pRCD->pbData = NULL;
	pRCD->uiDataSize = 0;
	pRCD->tTimestamp = tNow;
	pRCD->pRcvBuff = NULL;
	pRCD->ulRFlags = RFLAGS_FRAME_LOST;

	return pRCD;
}

/*			Cancel Frame
**
**		An unreliable frame has been reported as lost by sender.  This means we should consider it acknowledged
**	and remove it from our receive window.  This may require us to place a dummy receive descriptor in the OddFrameList
**	to hold its place until the window moves past it.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CancelFrame"

BOOL
CancelFrame(PEPD pEPD, BYTE bSeq, DWORD tNow, PSPRECEIVEDBUFFER* ppRcvBuffToFree)
{
	PRCD	pRCD;
	ULONG	bit;

	DPFX(DPFPREP,7, "(%p) CANCEL FRAME: Seq=%x", pEPD, bSeq);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Trivial case is when the cancelled frame is at the front of the window.  In this case we can complete not only
	// this frame but any contiguous frames following it in the OddFrameList
	
	if(pEPD->bNextReceive == bSeq)
	{
		if((pRCD = BuildCancelledRCD(pEPD, bSeq, tNow)) == NULL)
		{
			return FALSE;
		}
		ReceiveInOrderFrame(pEPD, pRCD, ppRcvBuffToFree);
	}

	// Here we have to place a dummy node on the OddFrameList to represent this frame.
	else 
	{
		// bit location in mask for this frame
		bit = (BYTE) ((bSeq - pEPD->bNextReceive) - 1);						

		// Make sure this is not a duplicate frame
		if( ((bit < 32) && (pEPD->ulReceiveMask & (1 << bit))) || ((bit > 31) && (pEPD->ulReceiveMask2 & (1 << (bit - 32)))) ) 
		{
			DPFX(DPFPREP,7, "(%p) Received CancelMask for frame that's already received Seq=%x", pEPD, bSeq);
			return FALSE;
		}
		
		if((pRCD = BuildCancelledRCD(pEPD, bSeq, tNow)) == NULL)
		{
			return FALSE;
		}
		ReceiveOutOfOrderFrame(pEPD, pRCD, bit, ppRcvBuffToFree);
	}

	return TRUE;
}


/*
**		Release Receive Buffer
**
**		The core calls this function to return buffers previously handed
**	over in an IndicateUserData call.  This call may be made before the
**	actual indication returns.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPReleaseReceiveBuffer"

HRESULT
DNPReleaseReceiveBuffer(HANDLE hProtocolData, HANDLE hBuffer)
{
	ProtocolData*	pPData;
	PSPD			pSPD;
	HRESULT			hr;
	union 
	{
		PBIGBUF 			pBuf;
		PSPRECEIVEDBUFFER	pRcvBuff;
	} pBuffer;

	DBG_CASSERT(OFFSETOF(buf, Type) == OFFSETOF(SPRECEIVEDBUFFER, dwProtocolData));
	DBG_CASSERT(sizeof(BUFFER_TYPE) == sizeof(DWORD));

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hBuffer[%p]", hProtocolData, hBuffer);

	hr = DPN_OK;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pBuffer.pBuf = (PBIGBUF) hBuffer;

	// NOTE: This is expecting pRcvBuff->pNext to be NULL and for RBT_SERVICE_PROVIDER_BUFFER to equal zero 
	// to work.
	switch(pBuffer.pBuf->Type)
	{
		case RBT_SERVICE_PROVIDER_BUFFER:
			pSPD = (PSPD)pBuffer.pRcvBuff->pServiceProviderDescriptor;
			ASSERT_SPD(pSPD);

			DEBUG_ONLY(DNInterlockedDecrement(&pSPD->pPData->BuffersInReceive));

			pBuffer.pRcvBuff->pNext = NULL;

			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->ReturnReceiveBuffers, pRcvBuff[%p], pSPD[%p]", pBuffer.pRcvBuff, pSPD);
			IDP8ServiceProvider_ReturnReceiveBuffers(pSPD->IISPIntf, pBuffer.pRcvBuff);
			break;

		case RBT_SERVICE_PROVIDER_BUFFER_COALESCE:
			// For coalesced packets we borrow pNext as a ref count.  When the ref count gets to zero,
			// we change the buffer back to a normal SP buffer and free it.
			pSPD = (PSPD)pBuffer.pRcvBuff->pServiceProviderDescriptor;
			ASSERT_SPD(pSPD);

			DEBUG_ONLY(DNInterlockedDecrement(&pSPD->pPData->BuffersInReceive));

			if (DNInterlockedDecrement((LONG*)&pBuffer.pRcvBuff->pNext) == 0)
			{
				pBuffer.pBuf->Type = RBT_SERVICE_PROVIDER_BUFFER;
				hr = DNPReleaseReceiveBuffer(hProtocolData, hBuffer);
			}

			break;
			
		case RBT_PROTOCOL_NORM_BUFFER:
			BufPool.Release(pBuffer.pBuf);
			break;

		case RBT_PROTOCOL_MED_BUFFER:
			MedBufPool.Release(pBuffer.pBuf);
			break;

		case RBT_PROTOCOL_BIG_BUFFER:
			BigBufPool.Release(pBuffer.pBuf);
			break;

		case RBT_DYNAMIC_BUFFER:
			DNFree(hBuffer);
			break;

		default:
			DPFX(DPFPREP,0, "RELEASE RECEIVE BUFFER CALLED WITH BAD PARAMETER");
			DNASSERT(FALSE);
			hr = DPNERR_INVALIDPARAM;
			break;
	}

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning hr[%x]", hr);

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}

/*
**		Complete Sends
**
**		Reliable sends are completed upon acknowlegement.  Acknowlegements are discovered inside
**	the UpdateXmitState routine while walking through the pending window.  Since the actual completion
**	event requires the user to be called,  state can change.  So the easiest thing to do is defer these
**	completion callbacks until we are finished walking and can release any state locks.  Also,  this way
**	we can defer the callbacks until after we have indicated any data which the acks were piggybacking on,
**	something which ought to have priority anyway.
**
**		So we will place all completed reliable sends onto a complete list and after all other processing
**	we will come here and callback everything on the list.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSends"

VOID CompleteSends(PEPD pEPD)
{
	PMSD	pMSD;
	CBilink	*pLink;

	Lock(&pEPD->EPLock);

	pLink = pEPD->blCompleteSendList.GetNext();

	while((pEPD->ulEPFlags & EPFLAGS_COMPLETE_SENDS) &&
		  (pLink != &pEPD->blCompleteSendList))
	{
		pMSD = CONTAINING_OBJECT(pLink, MSD, blQLinkage);
		ASSERT_MSD(pMSD);

		if(pMSD->CommandID != COMMAND_ID_SEND_DATAGRAM)
		{
			// Reliables, Keepalives, and Disconnects will come down this path
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_SEND_COMPLETE|MFLAGS_TWO_ABORT))
			{
				if (pMSD->uiFrameCount == 0)
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					pLink->RemoveFromList();

					Unlock(&pEPD->EPLock);
					Lock(&pMSD->CommandLock);
					CompleteReliableSend(pEPD->pSPD, pMSD, DPN_OK); // This releases the CommandLock
					
					Lock(&pEPD->EPLock);
				
					pLink = pEPD->blCompleteSendList.GetNext();
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frames still out, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					pLink = pLink->GetNext();
				}
			}
			else 
			{
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Message not yet complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
				break;		// These will complete in order, so stop checking when we see one that's not Complete.
			}
		}
		else
		{
			// Datagrams will come down this path
			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Skipping datagram frame on complete list, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
			pLink = pLink->GetNext();
		}
	}
#ifdef DBG
	// In DBG we want to assert that no one one the list could have been completed if we are leaving here
	pLink = pEPD->blCompleteSendList.GetNext();
	while(pLink != &pEPD->blCompleteSendList)
	{
		pMSD = CONTAINING_OBJECT(pLink, MSD, blQLinkage);
		ASSERT_MSD(pMSD);

		ASSERT(!(pMSD->ulMsgFlags2 & (MFLAGS_TWO_SEND_COMPLETE|MFLAGS_TWO_ABORT)) || pMSD->uiFrameCount != 0);

		pLink = pLink->GetNext();
	}
#endif // DBG

	pEPD->ulEPFlags &= ~(EPFLAGS_COMPLETE_SENDS);
	
	Unlock(&pEPD->EPLock);
}

/*
**		Lookup CheckPoint
**
**		Walk the EndPoint's list of active CPs looking for one with the provided
**	response correlator.
**		We keep the CKPT queue sorted by age so the matches should be at the front
**	of the queue.  So as we pass by entries at the head we will check the age of each
**	and timeout the ones that are 4(RTT) or greater.
**		Since DG drops are reported by the partner,  we dont need to do any booking about
**	the orphaned checkpoints.
**
**		*!* This link's StateLock must be held on entry
*/

#ifdef	DBG
#undef DPF_MODNAME
#define DPF_MODNAME "DumpChkPtList"

VOID
DumpChkPtList(PEPD pEPD)
{
	CBilink	*pLink;
	PCHKPT	pCP;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	DPFX(DPFPREP,1, "==== DUMPING CHECKPOINT LIST ==== (pEPD = %p)", pEPD);
	
	pLink = pEPD->blChkPtQueue.GetNext();
	while(pLink != &pEPD->blChkPtQueue) 
	{
		pCP = CONTAINING_OBJECT(pLink, CHKPT, blLinkage);
		DPFX(DPFPREP,1, "(%p) MsgID=%x; Timestamp=%x", pEPD, pCP->bMsgID, pCP->tTimestamp);
		pLink = pLink->GetNext();
	}
}
#endif // DBG

#undef DPF_MODNAME
#define DPF_MODNAME "LookupCheckPoint"

PCHKPT LookupCheckPoint(PEPD pEPD, BYTE bRspID)
{
	CBilink	*pLink;
	PCHKPT	pCP;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pCP = CONTAINING_OBJECT((pLink = pEPD->blChkPtQueue.GetNext()), CHKPT, blLinkage);
	while(pLink != &pEPD->blChkPtQueue) 
	{
		// Look for checkpoint that matches correlator
		if(pCP->bMsgID == bRspID)
		{	
			pLink->RemoveFromList();
			return pCP;		
		}
		// We have passed the spot for this correlator!		
		else if ((bRspID - pCP->bMsgID) & 0x80)
		{				
			DPFX(DPFPREP,1, "(%p) CHECKPOINT NOT FOUND - Later Chkpt found in list (%x)", pEPD, bRspID);
			return NULL;
		}
		else 
		{
			pLink = pLink->GetNext();								// Remove ChkPts prior to the one received
			pCP->blLinkage.RemoveFromList();							// ..target and remove the stale ones.
			ChkPtPool.Release(pCP);					// we expect them to complete in order of queue
			pCP = CONTAINING_OBJECT(pLink, CHKPT, blLinkage);
		}
	}

	DPFX(DPFPREP,1, "(%p) CHECKPOINT NOT FOUND -  EXHAUSTED LIST W/O MATCH (%x)", pEPD, bRspID);
#ifdef DBG
	DumpChkPtList(pEPD);
#endif // DBG
	return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushCheckPoints"

VOID FlushCheckPoints(PEPD pEPD)
{
	PCHKPT	pCP;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	while(!pEPD->blChkPtQueue.IsEmpty())
	{
		pCP = CONTAINING_OBJECT(pEPD->blChkPtQueue.GetNext(), CHKPT, blLinkage);
		pCP->blLinkage.RemoveFromList();
		ChkPtPool.Release(pCP);
	}
}

/*
**		Process End Of Stream
**
**		Our partner has initiated an orderly link termination.  He will not be
**	sending us any more data.  We are allowed to finish sending any data in our
**	pipeline, but should not allow any new sends to be accepted.  When our send
**	pipeline is emptied,  we should send an EOS frame and take down our
**	link.  Easiest way to do this is enqueue the EOS at the end of send queue now.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEndOfStream"

VOID ProcessEndOfStream(PEPD pEPD)
{
	PMSD	pMSD;

	Lock(&pEPD->EPLock);
	
	// Since an EOS comes in as a data packet, and we must be Connected to receive data, we know
	// we can now be in either the Connected or Terminating state.  If we are in the Terminating
	// state, someone is already attempting to destroy the link and we will ignore this EOS, and
	// let that termination finish.  Otherwise, we expect to be in the Connected state, and this
	// is a normal disconnect.
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{
		DPFX(DPFPREP,7, "(%p) Received EndOfStream on an already terminating link, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED);

	DPFX(DPFPREP,7, "(%p) Process EndOfStream", pEPD);

		//we should never get both an EOS and a hard disconnect, since the remote ep should only
		//ever attempt one type of disconnect, but lets code robustly and guard the case anyway
	if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_TARGET)
	{
		DPFX(DPFPREP, 0, "(%p) Received both EOS and hard disconnect", pEPD);
		DNASSERT(0);
		Unlock(&pEPD->EPLock);
		return;
	}

		//Possible that remote end start closing at the same time we started hard disconnect
		//In which case we should ignore this EOS, as the hard disconnect takes priority
		//We can't treat the EOS as the equivelant to a hard disconnect response because the sequence
		// 1. Send Hard Disconnect. 2. Hard Disconnect Dropped. 3. Receive EOS and drop link
		// would leave the far end hung until it timed out. Sending more hard disconnects will resolve this (hopefully!)
	if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_SOURCE)
	{
		DPFX(DPFPREP, 7, "(%p) Received EOS with hard disconnect already started. Ignoring EOS", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}

		//if we've already received a disconnect then the close sequence will already have begun on this side
		//hence nothing to do in this case
	if(pEPD->ulEPFlags & EPFLAGS_RECEIVED_DISCONNECT)
	{
		DPFX(DPFPREP, 7, "(%p) Received another EOS. Ignoring this one", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}		
		// Our side has not started closing yet,  so our partner must have initiated a Disconnect.
		// We are allowed to finish sending all data in our pipeline,  but we should not accept
		// any new data.  We must deliver an indication to the application telling him that
		// Disconnection is now underway.
		//
		// Please note that we do not set the TERMINATING flag until the Disconnecting indication
		// returns.  This allows the application to send any final messages (last words) before
		// the gate is slammed shut.

	DPFX(DPFPREP,7, "(%p) Partner Disconnect received (refcnt=%d)", pEPD, pEPD->lRefCnt);

	// Don't let anyone else in here again.
	pEPD->ulEPFlags |= EPFLAGS_RECEIVED_DISCONNECT;	

	// Force 3 disconnect ACKs now since we are going away.
	// Setting fFinalAck to TRUE on last ACK so CommandComplete will drop if appropriate
	DPFX(DPFPREP,7, "(%p) ACK'ing Partner's Disconnect", pEPD);
	SendAckFrame(pEPD, 0);	
	SendAckFrame(pEPD, 0);			
	SendAckFrame(pEPD, 0, TRUE);			

	// There is the possibility that this side initiated a disconnect, and is now receiving a
	// disconnect from the other side simultaneously.  In this case, we do not want to tell the
	// Core on our side about the disconnect, because the Core on our side is already disconnecting
	// anyway.  We also do not need to send an EOS, because we have sent one already, and can
	// just wait for that one to be ACK'd.
	if(!(pEPD->ulEPFlags & EPFLAGS_SENT_DISCONNECT))
	{
		// We know we won't get in here twice because of EPFLAGS_RECEIVED_DISCONNECT above.
		Unlock(&pEPD->EPLock);

		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateDisconnect, Core Context[%p]", pEPD, pEPD->Context);
		pEPD->pSPD->pPData->pfVtbl->IndicateDisconnect(pEPD->pSPD->pPData->Parent, pEPD->Context);

		Lock(&pEPD->EPLock);

		// This will prevent any new sends, so don't set it until after calling IndicateDisconnect.
		pEPD->ulEPFlags |= EPFLAGS_SENT_DISCONNECT;			

		if((pMSD = BuildDisconnectFrame(pEPD)) == NULL)
		{	
			DropLink(pEPD);									// DROPLINK will release EPLock for us
			return;
		}

		pMSD->CommandID = COMMAND_ID_DISC_RESPONSE;			// Mark MSD so we know its not a user command

		LOCK_EPD(pEPD, "LOCK (DISC RESP)");					// Add reference for this frame
		pEPD->pCommand = pMSD;								// Store the DisconnectResp on the Endpoint until it is complete

		DPFX(DPFPREP,7, "(%p) Responding to Disconnect. pMSD=0x%p", pEPD, pMSD);
		EnqueueMessage(pMSD, pEPD);							// Enqueue the DISC frame at end of sendQ
	}

	Unlock(&pEPD->EPLock);
}

/*
**		Process SP Disconnect
**
**		Service Provider has told us that an endpoint has gone away.  This is probably
**	because we have Disconnected it ourselves, in which case the IN_USE flag will be
**	clear.  Otherwise,  we need to clean this thing up ourselves...
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessSPDisconnect"

VOID
ProcessSPDisconnect(PSPD pSPD, PSPIE_DISCONNECT pDataBlock)
{
	PEPD 	pEPD = static_cast<PEPD>( pDataBlock->pEndpointContext );
	ASSERT_EPD(pEPD);
	ASSERT(pEPD->pSPD == pSPD);
	ASSERT(pDataBlock->hEndpoint == pEPD->hEndPt);
	PMSD	pMSD = NULL;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pEPD[%p]", pSPD, pDataBlock, pEPD);

	Lock(&pEPD->EPLock);

	// Make sure ReleaseEPD knows that this occurred
	pEPD->ulEPFlags |= EPFLAGS_SP_DISCONNECTED;

	if (!(pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING))
	{
		DECREMENT_EPD(pEPD, "SP reference"); // Remove the SP reference

		// If there is an outstanding connection, clean it up
		if (pEPD->ulEPFlags & (EPFLAGS_STATE_CONNECTING|EPFLAGS_STATE_DORMANT))
		{
			// Even if this is COMMAND_ID_CONNECT this is safe to do
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();						// Unlink EPD from Listen Queue

			// We know this will only happen once because the person who does it will transition us out
			// of the CONNECTING state, and we can't get here unless we are in that state.
			pMSD = pEPD->pCommand;
			pEPD->pCommand = NULL;
		}

		DropLink(pEPD); // This will release the EPLock

		if (pMSD)
		{
			Lock(&pMSD->CommandLock);
			RELEASE_MSD(pMSD, "EPD Ref");
		}
	}
	else
	{
#ifndef DPNBUILD_NOMULTICAST
		if (pEPD->ulEPFlags2 & (EPFLAGS2_MULTICAST_SEND|EPFLAGS2_MULTICAST_RECEIVE))
		{
			//
			//	We will need to generate a completion to the core
			//
			pMSD = pEPD->pCommand;
			Unlock(&pEPD->EPLock);

			Lock(&pMSD->CommandLock);
			CompleteDisconnect(pMSD,pSPD,pEPD);

			pMSD = NULL;
		}
		else
#endif	// DPNBUILD_NOMULTICAST
		{
			RELEASE_EPD(pEPD, "SP reference"); // releases EPLock
		}
	}
}

/*
**		Process Listen Status
**
**		This call tells us that a submitted Listen command has become active.  Truth is, we
**	dont care.  We are just interested in seeing the Connect indications as they arrive.  What we
**	do care about,  however, is the Endpoint handle associated with this listen in case we are
**	later asked about the address associated with the listen.  So we will pull it out of the
**	data block and save it in our MSD.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessListenStatus"

VOID
ProcessListenStatus(PSPD pSPD, PSPIE_LISTENSTATUS pDataBlock)
{
	PMSD	pMSD;
	
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - hr=%x", pSPD, pDataBlock, pDataBlock->hResult);

	pMSD = (PMSD) pDataBlock->pUserContext;

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
#ifdef DPNBUILD_NOMULTICAST
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);
#else // ! DPNBUILD_NOMULTICAST
	ASSERT((pMSD->CommandID == COMMAND_ID_LISTEN) || (pMSD->CommandID == COMMAND_ID_LISTEN_MULTICAST));
#endif // ! DPNBUILD_NOMULTICAST
	ASSERT(pDataBlock->hCommand == pMSD->hCommand || pMSD->hCommand == NULL);

	pMSD->hListenEndpoint = pDataBlock->hEndpoint;

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling Core->CompleteListen, pMSD[%p], Core Context[%p], hr[%x]", pMSD, pMSD->Context, pDataBlock->hResult);
	pSPD->pPData->pfVtbl->CompleteListen(pSPD->pPData->Parent, &pMSD->Context, pDataBlock->hResult, pMSD);
	
	if(pDataBlock->hResult != DPN_OK)
	{
		// Release the final reference on the MSD AFTER indicating to the Core
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Release On Complete");
	}

	return;
}

/*
**		Process Connect Address Info
**
**		This call tells us what addressing information has been used to start a connect.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectAddressInfo"

VOID
ProcessConnectAddressInfo(PSPD pSPD, PSPIE_CONNECTADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
#ifdef DPNBUILD_NOMULTICAST
	ASSERT(pMSD->CommandID == COMMAND_ID_CONNECT);
#else // ! DPNBUILD_NOMULTICAST
	ASSERT((pMSD->CommandID == COMMAND_ID_CONNECT) || (pMSD->CommandID == COMMAND_ID_CONNECT_MULTICAST_SEND) || (pMSD->CommandID == COMMAND_ID_CONNECT_MULTICAST_RECEIVE));
#endif // ! DPNBUILD_NOMULTICAST

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->AddressInfoConnect, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->AddressInfoConnect( pSPD->pPData->Parent,
											  pMSD->Context,
											  pDataBlock->hCommandStatus,
											  pDataBlock->pHostAddress,
											  pDataBlock->pDeviceAddress );
	
	return;
}


/*
**		Process Enum Address Info
**
**		This call tells us what addressing information has been used to start an enum.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEnumAddressInfo"

VOID
ProcessEnumAddressInfo(PSPD pSPD, PSPIE_ENUMADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);
	
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
	ASSERT(pMSD->CommandID == COMMAND_ID_ENUM );

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->AddressInfoEnum, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->AddressInfoEnum( pSPD->pPData->Parent,
										   pMSD->Context,
										   pDataBlock->hCommandStatus,
										   pDataBlock->pHostAddress,
										   pDataBlock->pDeviceAddress );
	
	return;
}

/*
**		Process Listen Address Info
**
**		This call tells us what addressing information has been used to start a listen.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessListenAddressInfo"

VOID
ProcessListenAddressInfo(PSPD pSPD, PSPIE_LISTENADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
#ifdef DPNBUILD_NOMULTICAST
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);
#else // ! DPNBUILD_NOMULTICAST
	ASSERT((pMSD->CommandID == COMMAND_ID_LISTEN) || (pMSD->CommandID == COMMAND_ID_LISTEN_MULTICAST));
#endif // ! DPNBUILD_NOMULTICAST

	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->AddressInfoListen, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->AddressInfoListen( pSPD->pPData->Parent,
											 pMSD->Context,
											 pDataBlock->hCommandStatus,
											 pDataBlock->pDeviceAddress );
	
	return;
}

/*
**		Process Hard Disconnect 
**
**	Called when we receive a hard disconnect frame
**	CALLED WITH EPLOCK HELD;  RETURNS WITH EPLOCK RELEASED	
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessHardDisconnect"

VOID
ProcessHardDisconnect(PEPD pEPD)
{

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

		//if the ep is in the process of terminating we should do nothing
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{
		DPFX(DPFPREP, 7, "(%p) Ignoring Hard Disconnect on terminating endpoint", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}

		//if we're the source for this hard disconnect sequence then this is our cue to drop the 
		//link and complete the disconnect
		//N.B. Its possible both sides attempted a hard disconnect at the same time. In which case
		//they'll both assume each other hard disconnect frames were actually responses to what
		//they sent, and everything proceeds swimmingly
	if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_SOURCE)
	{
		CompleteHardDisconnect(pEPD);
			//above call will release EP lock
		return;
	}

		//if we've already received a hard disconnect frame then we'll already have started
		//the respond/drop link sequence, so can ignore this new request
	if (pEPD->ulEPFlags & EPFLAGS_HARD_DISCONNECT_TARGET)
	{
		DPFX(DPFPREP, 7, "(%p) Ignoring Hard Disconnect. Already marked as hard disconnect target", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}

		//looks like remote ep wants to kick off a hard disconnect sequence
	pEPD->ulEPFlags|=EPFLAGS_HARD_DISCONNECT_TARGET;
	DNASSERT((pEPD->ulEPFlags2 & EPFLAGS2_HARD_DISCONNECT_COMPLETE)==0);

		//add a reference to the endpoint to make sure it hangs around whilst we complete our response
		//this is dropped in the CompleteHardDisconnect function
	LOCK_EPD(pEPD, "LOCK (HARD DISCONNECT RESPONSE)");

		//now send 3 hard disconnects back to the other side immediately
		//assuming 1 of them gets through this'll tell the originator of the hard disconnect
		//he can stop sending hard disconnect frames to us. If they all drop it doesn't matter too much,
		//as the originator will give up sending at some point pretty soon anyway
	SendCommandFrame(pEPD, FRAME_EXOPCODE_HARD_DISCONNECT, 0, 0, FALSE);
	SendCommandFrame(pEPD, FRAME_EXOPCODE_HARD_DISCONNECT, 0, 0, FALSE);
		//N.B. The final send command frame has the bSendDirect flag set to TRUE
		//this causes the queued send frames to be commited to the SP. It also has the final hard disconnect flag
		//set. This ensures when the SP completes the send of this command frame we know to drop the link
	HRESULT hr=SendCommandFrame(pEPD, FRAME_EXOPCODE_HARD_DISCONNECT,
															0, FFLAGS_FINAL_HARD_DISCONNECT, TRUE);
		//EP lock is released by above call (since bSendDirect==TRUE)
		//if the final send fails then we can't wait for the send completition from the sp to complete the disconnect
		//hence we have to do it now
	if (FAILED(hr))
	{
		Lock(&pEPD->EPLock);
		DPFX(DPFPREP, 0, "(%p) Failed to send final HARD_DISCONNECT. Completing disconnect immediately hr[0x%x]", pEPD, hr);
		CompleteHardDisconnect(pEPD);
			//above call will release ep lock
	}
}



/*
**		Create Connected Signed Reply
**
**	Called when we're listening for connections to a signed session and we either get a CONNECT or a KEEPALIVE that looks
**	like the first KEEPALIVE in a session. We want to return a CONNECTEDSIGNED response in the supplied reply buffer
**	
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CreateConnectedSignedFrame"

HRESULT	CreateConnectedSignedReply(void * pvReplyBuffer, DWORD * pdwReplySize, DWORD dwSessID, DWORD dwAddressHash,
							ULONGLONG ullConnectSecret, DWORD dwSigningOpts, DWORD tNow)
{
		//if the reply buffer isn't large enough to send our response then tell the SP to do nothing
	if (*pdwReplySize<sizeof(CFRAME_CONNECTEDSIGNED))
	{
		DPFX(DPFPREP, 0, "Unconnected data reply buffer too small to send CONNECTEDSIGNED response");
		DNASSERT(0);
		return DPNERR_ABORTED;
	}

	*pdwReplySize=sizeof(CFRAME_CONNECTEDSIGNED);
	CFRAME_CONNECTEDSIGNED * pCFrame=(CFRAME_CONNECTEDSIGNED * ) pvReplyBuffer;

		//Set members common to all CFrames
		//N.B. We set the poll bit to indicate that this is the reponse from the listening side
		//When the connector sends its CONNECTSIGNED frame it won't set this bit
	pCFrame->bCommand = PACKET_COMMAND_CFRAME | PACKET_COMMAND_POLL;
	pCFrame->bExtOpcode = FRAME_EXOPCODE_CONNECTED_SIGNED;
	pCFrame->dwVersion = DNET_VERSION_NUMBER;
	pCFrame->bRspID = 0;
	pCFrame->dwSessID = dwSessID;
	pCFrame->tTimestamp = tNow;
	pCFrame->bMsgID = 0;

		//set members specific just to CONNECTEDSIGNED frames
		//N.B. We let the connector pick the secrets, so we zero out the ones we send. And the EchoTimestamp is 
		//unused because the connecting endpoint will use a checkpoint to track the RTT. 
	pCFrame->ullConnectSig=GenerateConnectSig(dwSessID, dwAddressHash, ullConnectSecret);
	pCFrame->ullSenderSecret=0;
	pCFrame->ullReceiverSecret=0;
	pCFrame->dwSigningOpts=dwSigningOpts;
	pCFrame->dwEchoTimestamp=0;

		//tell the sp to send the data we've placed in the reply buffer
	return DPNSUCCESS_PENDING;
}


#undef DPF_MODNAME
#define DPF_MODNAME "ValidateIncomingFrameSig"

BOOL ValidateIncomingFrameSig(PEPD pEPD, BYTE * pbyFrame, DWORD dwFrameSize, BYTE bSeq, UNALIGNED ULONGLONG * pullFrameSig)
{
		//fast signing is trivial, simply check for a match on the (not very) secret
	if (pEPD->ulEPFlags2 & EPFLAGS2_FAST_SIGNED_LINK)
	{
		if (*pullFrameSig!=pEPD->ullCurrentRemoteSecret)
		{
			DPFX(DPFPREP,1, "(%p) Invalid signature on fast signed link", pEPD);
			return FALSE;
		}
		return TRUE;
	}
	
	DNASSERT(pEPD->ulEPFlags2 & EPFLAGS2_FULL_SIGNED_LINK);
		//store the sig from the packet and then zero it out. This ensures the state of the packet
		//matches what it should have been when it was originally signed
	ULONGLONG ullSuppliedSig=*pullFrameSig;
	*pullFrameSig=0;
		//sig to use depends on where we are in the sequence space and where the packet is
	if ((pEPD->bNextReceive>=SEQ_WINDOW_3Q || pEPD->bNextReceive<SEQ_WINDOW_1Q) && (bSeq>=SEQ_WINDOW_3Q))
	{
		if (GenerateIncomingFrameSig(pbyFrame, dwFrameSize, pEPD->ullOldRemoteSecret)!=ullSuppliedSig)
		{
			DPFX(DPFPREP,1, "(%p) Invalid signature on full signed link", pEPD);
			return FALSE;
		}
	}
	else
	{
		if (GenerateIncomingFrameSig(pbyFrame, dwFrameSize, pEPD->ullCurrentRemoteSecret)!=ullSuppliedSig)
		{
			DPFX(DPFPREP,1, "(%p) Invalid signature on full signed link", pEPD);
			return FALSE;
		}
	}
	return TRUE;
}



/*************************************
**
**		RECEIVE BUFFER MANAGEMENT
**
**		When multiple frame messages arrive we *may* have to copy them in to a  single contiguous
**	buffer.  We are supporting an OPTIONAL scatter-receive option which would allow sophisticated
**	clients to receive a BUFFER_DESCRIPTOR array instead of a single cont-buffer,  and avoiding
**	a large datacopy.
**
**		For clients which dont support scatter-receive,  we need a pooling strategy for large receive
**	buffers.  We will only need buffers LARGER then our frame limit because smaller receives are delivered
**	in the SPs buffer.
**
**		Try placing receives into generally sized buffers.  If frame size is usu 1.4K bytes, 2K is a small
**	buffer, 4K, 16K, 32K, 64K.  If frame size is <1K we can have 1K buffers too.
**
**
*************************************/


/***********************
========SPACER==========
************************/

/*
**		RCD Pool support routines
**
**		These are the functions called by Fixed Pool Manager as it handles RCDs.
*/

#define	pELEMENT		((PRCD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Allocate"

BOOL RCD_Allocate(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,7, "(%p) Allocating new RCD", pELEMENT);

	pELEMENT->blOddFrameLinkage.Initialize();
	pELEMENT->blCompleteLinkage.Initialize();
	pELEMENT->Sign = RCD_SIGN;

	return TRUE;
}

//	Get is called each time an MSD is used

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Get"

VOID RCD_Get(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "CREATING RCD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->pRcvBuff = NULL;
	pELEMENT->lRefCnt = 1;
	pELEMENT->ulRFlags = 0;

	ASSERT( pELEMENT->blOddFrameLinkage.IsEmpty());
	ASSERT( pELEMENT->blCompleteLinkage.IsEmpty());

	ASSERT_RCD(pELEMENT);
}

//	RCD Release  --  This release call will release an entire chain of RCDs
// 	that are linked together... or then again maybe not.

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Release"

VOID RCD_Release(PVOID pElement)
{
	ASSERT_RCD(pELEMENT);

	ASSERT(pELEMENT->lRefCnt == 0);
	ASSERT(pELEMENT->pRcvBuff == NULL);

	ASSERT( pELEMENT->blOddFrameLinkage.IsEmpty());
	ASSERT( pELEMENT->blCompleteLinkage.IsEmpty());

	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "RELEASING RCD %p", pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Free"

VOID RCD_Free(PVOID pElement)
{
}

#undef	pELEMENT

/*
**		Buffer pool support
**
**
*/

#define	pELEMENT		((PBUF) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_Allocate"

BOOL	Buf_Allocate(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,7, "(%p) Allocating new Buf", pElement);

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_Get"

VOID Buf_Get(PVOID pElement, PVOID pvContext)
{
	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->Type = RBT_PROTOCOL_NORM_BUFFER;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_GetMed"

VOID Buf_GetMed(PVOID pElement, PVOID pvContext)
{
	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->Type = RBT_PROTOCOL_MED_BUFFER;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_GetBig"

VOID Buf_GetBig(PVOID pElement, PVOID pvContext)
{
	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->Type = RBT_PROTOCOL_BIG_BUFFER;
}

#undef	pELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\send.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Send.cpp
 *  Content:	This file contains code which implements the front end of the
 *				SendData API.  It also contains code to Get and Release Message
 *				Descriptors (MSD) with the FPM package.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/*
**		Direct Net Protocol  --  Send Data
**
**		Data is always address to a PlayerID,  which is represented internally
**	by an End Point Descriptor (EPD).
**
**		Data can be sent reliably or unreliably using the same API with the appropriate
**	class of service flag set.
**
**		Sends are never delivered directly to the SP because there will always be
**	a possibility that the thread might block.  So to guarentee immediate return
**	we will always queue the packet and submit it on our dedicated sending thread.
*/


#if (DN_SENDFLAGS_SET_USER_FLAG - PACKET_COMMAND_USER_1)
This will not compile.  Flags must be equal
#endif
#if (DN_SENDFLAGS_SET_USER_FLAG_TWO - PACKET_COMMAND_USER_2)
This will not compile.  Flags must be equal
#endif

//	locals

VOID	SendDatagram(PMSD, PEPD);
VOID	SendReliable(PMSD, PEPD);

#undef		DPF_MODNAME
#define		DPF_MODNAME		"PROTOCOL"

/*
**		Send Data
**
**		This routine will initiate a data transfer with the specified endpoint.  It will
**	normally start the operation and then return immediately,  returning a handle used to
**	indicate completion of the operation at a later time.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPSendData"

HRESULT
DNPSendData(HANDLE hProtocolData, HANDLE hDestination, UINT uiBufferCount, PBUFFERDESC pBufferDesc, UINT uiTimeout, ULONG ulFlags, VOID* pvContext,	HANDLE* phSendHandle)
{
	HRESULT			hr;
	ProtocolData*	pPData;
	PEPD 			pEPD;
	PMSD			pMSD;
	PFMD			pFMD;
	UINT			i;
	UINT			Length = 0;
	PSPD			pSPD;
	ULONG			ulFrameFlags;
	BYTE			bCommand;
	//  Following variables are used for mapping buffers to frames
	PBUFFERDESC		FromBuffer, ToBuffer;
	UINT			TotalRemain, FromRemain, ToRemain, size;
	PCHAR			FromPtr;
#ifdef DBG
	INT			FromBufferCount;
#endif // DBG
	// End of variables for mapping frames
#ifndef DPNBUILD_NOMULTICAST
	BOOL			fMulticastSend;
#endif // !DPNBUILD_NOMULTICAST

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hProtocolData[%p], hDestination[%x], uiBufferCount[%x], pBufferDesc[%p], uiTimeout[%x], ulFlags[%x], pvContext[%p], phSendHandle[%p]", hProtocolData, hDestination, uiBufferCount, pBufferDesc, uiTimeout, ulFlags, pvContext, phSendHandle);

	hr = DPNERR_PENDING;
	pPData = (ProtocolData*)hProtocolData;
	ASSERT_PPD(pPData);

	pEPD = (PEPD) hDestination;
	ASSERT_EPD(pEPD);

	// Unified Send Processing -- Do this for all classes of service

	// We will do all of the work to build up the frames and create the send command before we check
	// the state of the EPD, that way we don't have to have complicated code to handle an endpoint that
	// goes away between the top and bottom of this function and we don't have to hold the EPDLock while
	// we do all of the buffer manipulation.
	
	// Hold a reference throughout the operation so we don't have to deal with the EPD going away.
	LOCK_EPD(pEPD, "LOCK (SEND)");

	// Count the bytes in all user buffers
	for(i=0; i < uiBufferCount; i++)
	{
		Length += pBufferDesc[i].dwBufferSize;
	}
	if (Length == 0)
	{
		DPFX(DPFPREP,0, "Attempt to send zero length packet, returning DPNERR_GENERIC");
		return DPNERR_GENERIC;
	}

#ifndef DPNBUILD_NOMULTICAST
	fMulticastSend = pEPD->ulEPFlags2 & (EPFLAGS2_MULTICAST_SEND|EPFLAGS2_MULTICAST_RECEIVE);
	if (fMulticastSend && Length > pEPD->uiUserFrameLength)
	{
		DPFX(DPFPREP,0, "Multicast send too large to fit in one frame, returning DPNERR_SENDTOOLARGE");
		Lock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (SEND)");
		return DPNERR_SENDTOOLARGE;
	}
#endif // !DPNBUILD_NOMULTICAST

	// Allocate and fill out a Message Descriptor for this operation
	if((pMSD = (PMSD)POOLALLOC(MEMID_SEND_MSD, &MSDPool)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate MSD, returning DPNERR_OUTOFMEMORY");
		Lock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (SEND)");
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

	// Copy SendData parameters into the Message Descriptor
	pMSD->ulSendFlags = ulFlags;					// Store the actual flags passed into the API call
	pMSD->Context = pvContext;
	pMSD->iMsgLength = Length;

	pMSD->uiFrameCount = (Length + pEPD->uiUserFrameLength - 1) / pEPD->uiUserFrameLength; // round up
	DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Initialize Frame count, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

#ifndef DPNBUILD_NOMULTICAST
	ASSERT(!fMulticastSend || pMSD->uiFrameCount == 1);
#endif // !DPNBUILD_NOMULTICAST

	if(ulFlags & DN_SENDFLAGS_RELIABLE)
	{
#ifndef DPNBUILD_NOMULTICAST
		ASSERT(!fMulticastSend);
#endif // !DPNBUILD_NOMULTICAST
		pMSD->CommandID = COMMAND_ID_SEND_RELIABLE;
		ulFrameFlags = FFLAGS_RELIABLE;
		bCommand = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE;
	}
	else 
	{
		pMSD->CommandID = COMMAND_ID_SEND_DATAGRAM;
		ulFrameFlags = 0;
		bCommand = PACKET_COMMAND_DATA;
	}

	if(!(ulFlags & DN_SENDFLAGS_COALESCE))
	{
#ifdef DPNBUILD_COALESCEALWAYS
		DPFX(DPFPREP,7, "(%p) Attempting to coalesce send despite missing flag.", pEPD);
#else // ! DPNBUILD_COALESCEALWAYS
		ulFrameFlags |= FFLAGS_DONT_COALESCE;
#endif // ! DPNBUILD_COALESCEALWAYS
	}

	if(!(ulFlags & DN_SENDFLAGS_NON_SEQUENTIAL))
	{
#ifndef DPNBUILD_NOMULTICAST
		ASSERT(!fMulticastSend);
#endif // !DPNBUILD_NOMULTICAST
		bCommand |= PACKET_COMMAND_SEQUENTIAL;
	}

	bCommand |= (ulFlags & (DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO));	// preserve user flag values

	// Map user buffers directly into frame's buffer descriptors
	//
	//	We will loop through each required frame,  filling out buffer descriptors
	// from those provided as parameters.  Frames may span user buffers or vice-versa...

	TotalRemain = Length;
#ifdef DBG
	FromBufferCount = uiBufferCount - 1;				// sanity check
#endif // DBG
	FromBuffer = pBufferDesc;
	FromRemain = FromBuffer->dwBufferSize;
	FromPtr = reinterpret_cast<PCHAR>( (FromBuffer++)->pBufferData );				// note post-increment to next descriptor
	
	for(i=0; i<pMSD->uiFrameCount; i++)
	{
		ASSERT(TotalRemain > 0);
		
		// Grab a new frame
		if((pFMD = (PFMD)POOLALLOC(MEMID_SEND_FMD, &FMDPool)) == NULL)
		{	
			// MSD_Release will clean up any previous frames if this isn't the first.
			// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
			Lock(&pMSD->CommandLock);
			pMSD->uiFrameCount = 0;			// reset to prevent assert in pool release function
			RELEASE_MSD(pMSD, "Base Ref");	// MSD Release operation will also free frames
			Lock(&pEPD->EPLock);
			RELEASE_EPD(pEPD, "UNLOCK (SEND)");
			DPFX(DPFPREP,0, "Failed to allocate FMD, returning DPNERR_OUTOFMEMORY");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}

		pFMD->pMSD = pMSD;								// Link frame back to message
		pFMD->pEPD = pEPD;
		pFMD->CommandID = pMSD->CommandID;
		pFMD->bPacketFlags = bCommand;					// save packet flags for each frame
		pFMD->blMSDLinkage.InsertBefore( &pMSD->blFrameList);
		ToRemain = pEPD->uiUserFrameLength;
		ToBuffer = pFMD->rgBufferList;					// Address first user buffer desc
		
		pFMD->uiFrameLength = pEPD->uiUserFrameLength;	// Assume we fill frame- only need to change size of last one
		pFMD->ulFFlags = ulFrameFlags;					// Set control flags for frame (Sequential, Reliable)

		// Until this frame is full
		while((ToRemain != 0) && (TotalRemain != 0) && (pFMD->SendDataBlock.dwBufferCount <= MAX_USER_BUFFERS_IN_FRAME))
		{	
 			size = _MIN(FromRemain, ToRemain);			// choose smaller of framesize or buffersize
			FromRemain -= size;
			ToRemain -= size;
			TotalRemain -= size;

			ToBuffer->dwBufferSize = size;				// Fill in the next frame descriptor
			(ToBuffer++)->pBufferData = reinterpret_cast<BYTE*>( FromPtr );		// note post-increment
			ASSERT(pFMD->SendDataBlock.dwBufferCount <= MAX_USER_BUFFERS_IN_FRAME);	// remember we already have 1 immediate data buffer
			pFMD->SendDataBlock.dwBufferCount++;		// Count buffers as we add them

			// Get next user buffer
			if((FromRemain == 0) && (TotalRemain != 0))
			{
				FromRemain = FromBuffer->dwBufferSize;
				FromPtr = reinterpret_cast<PCHAR>( (FromBuffer++)->pBufferData );	// note post-increment to next descriptor
#ifdef DBG		
				FromBufferCount--;						// Keep this code honest...
				ASSERT(FromBufferCount >= 0);
#endif // DBG
			}
			else 
			{										// Either filled this frame,  or have mapped the whole send
				FromPtr += size;						// advance ptr to start next frame (if any)
				pFMD->uiFrameLength = pEPD->uiUserFrameLength - ToRemain;		// wont be full at end of message
			}
		}	// While (frame not full)
	}  // For (each frame in message)

	pFMD->ulFFlags |= FFLAGS_END_OF_MESSAGE;			// Mark last frame with EOM
	pFMD->bPacketFlags |= PACKET_COMMAND_END_MSG;		// Set EOM in frame
	
#ifdef DBG
	ASSERT(FromBufferCount == 0);
	ASSERT(TotalRemain == 0);
#endif // DBG

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	// Don't allow sends if we are not connected or if a disconnect has been initiated
	if( ((pEPD->ulEPFlags & (EPFLAGS_END_POINT_IN_USE | EPFLAGS_STATE_CONNECTED)) !=
														(EPFLAGS_END_POINT_IN_USE | EPFLAGS_STATE_CONNECTED))
		|| (pEPD->ulEPFlags & (EPFLAGS_SENT_DISCONNECT | EPFLAGS_HARD_DISCONNECT_SOURCE))) 
	{
		// Release MSD before EPD since final EPD will call out to SP and we don't want any locks held
		pMSD->uiFrameCount = 0;
		RELEASE_MSD(pMSD, "Base Ref");	// MSD Release operation will also free frames, releases CommandLock
		RELEASE_EPD(pEPD, "UNLOCK (SEND)"); // Releases EPLock

		DPFX(DPFPREP,0, "(%p) Rejecting Send on invalid EPD, returning DPNERR_INVALIDENDPOINT", pEPD);
		hr = DPNERR_INVALIDENDPOINT;
		goto Exit;
	}

	pSPD = pEPD->pSPD;
	ASSERT_SPD(pSPD);

	pMSD->pSPD = pSPD;
	pMSD->pEPD = pEPD;

	// hang the message off a global command queue

#ifdef DBG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif // DBG

	*phSendHandle = pMSD;									// We will use the MSD as our handle.

	// Enqueue the message before setting the timeout
	EnqueueMessage(pMSD, pEPD);
	Unlock(&pEPD->EPLock);

	if(uiTimeout != 0)
	{
		LOCK_MSD(pMSD, "Send Timeout Timer");							// Add reference for timer
		DPFX(DPFPREP,7, "(%p) Setting Timeout Send Timer", pEPD);
		ScheduleProtocolTimer(pSPD, uiTimeout, 100, TimeoutSend, pMSD, &pMSD->TimeoutTimer, &pMSD->TimeoutTimerUnique);
	}

	Unlock(&pMSD->CommandLock);

Exit:
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blProtocolCritSecsHeld);

	return hr;
}



/*
**		Enqueue Message
**
**		Add complete MSD to the appropriate send queue,  and kick start sending process if necessary.
**
**		** This routine is called and returns with EPD->EPLOCK held **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EnqueueMessage"

VOID
EnqueueMessage(PMSD pMSD, PEPD pEPD)
{
	PSPD	pSPD = pEPD->pSPD;

	//	Place Message in appriopriate priority queue.  Datagrams get enqueued twice (!).  They get put in the Master
	// queue where they are processed FIFO with all messages of the same priority.  Datagrams also get placed in a priority
	// specific queue of only datagrams which is drawn from when the reliable stream is blocked.
	
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pEPD->uiQueuedMessageCount++;
	if(pMSD->ulSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
	{
		DPFX(DPFPREP,7, "(%p) Placing message on High Priority Q (total queued = %u)", pEPD, pEPD->uiQueuedMessageCount);
		pMSD->blQLinkage.InsertBefore( &pEPD->blHighPriSendQ);
		pEPD->uiMsgSentHigh++;
	}
	else if (pMSD->ulSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
	{
		DPFX(DPFPREP,7, "(%p) Placing message on Low Priority Q (total queued = %u)", pEPD, pEPD->uiQueuedMessageCount);
		pMSD->blQLinkage.InsertBefore( &pEPD->blLowPriSendQ);
		pEPD->uiMsgSentLow++;
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Placing message on Normal Priority Q (total queued = %u)", pEPD, pEPD->uiQueuedMessageCount);
		pMSD->blQLinkage.InsertBefore( &pEPD->blNormPriSendQ);
		pEPD->uiMsgSentNorm++;
	}

#ifdef DBG
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_ENQUEUED;
#endif // DBG

	pEPD->ulEPFlags |= EPFLAGS_SDATA_READY;							// Note that there is *something* in one or more queues

	// If the session is not currently in the send pipeline then we will want to insert it here as long as the
	// the stream is not blocked.

	if(((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0) && (pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED))
	{
		ASSERT(pEPD->SendTimer == NULL);
		DPFX(DPFPREP,7, "(%p) Send On Idle Link -- Returning to pipeline", pEPD);
	
		pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
		LOCK_EPD(pEPD, "LOCK (pipeline)");								// Add Ref for pipeline Q

		// We dont call send on users thread,  but we dont have a dedicated send thread either. Use a thread
		// from the timer-worker pool to submit the sends to SP

		DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
		ScheduleProtocolWork(pSPD, ScheduledSend, pEPD);
	}
	else if ((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
	{
		DPFX(DPFPREP,7, "(%p) Declining to re-enter pipeline on blocked stream", pEPD);
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Already in pipeline", pEPD);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "TimeoutSend"

VOID CALLBACK
TimeoutSend(void * const pvUser, void * const uID, const UINT uMsg)
{
	PMSD	pMSD = (PMSD) pvUser;
	PEPD	pEPD = pMSD->pEPD;

	DPFX(DPFPREP,7, "(%p) Timeout Send pMSD=%p,  RefCnt=%d", pEPD, pMSD, pMSD->lRefCnt);

	Lock(&pMSD->CommandLock);
	
	if((pMSD->TimeoutTimer != uID)||(pMSD->TimeoutTimerUnique != uMsg))
	{
		DPFX(DPFPREP,7, "(%p) Ignoring late send timeout timer, pMSD[%p]", pEPD, pMSD);
		RELEASE_MSD(pMSD, "Timeout Timer"); // releases EPLock
		return;
	}

	pMSD->TimeoutTimer = NULL;

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_TIMEDOUT))
	{
		DPFX(DPFPREP,7, "(%p) Timed out send has completed already pMSD=%p", pEPD, pMSD);
		RELEASE_MSD(pMSD, "Send Timout Timer"); // Releases CommandLock
		return;
	}

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_TIMEDOUT;

	DPFX(DPFPREP,7, "(%p) Calling DoCancel to cancel pMSD=%p", pEPD, pMSD);

	if(DoCancel(pMSD, DPNERR_TIMEDOUT) == DPN_OK) // Releases CommandLock
	{
		ASSERT_EPD(pEPD);

		if(pMSD->ulSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pEPD->uiMsgTOHigh++;
		}
		else if(pMSD->ulSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pEPD->uiMsgTOLow++;
		}
		else
		{
			pEPD->uiMsgTONorm++;
		}
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) DoCancel did not succeed pMSD=%p", pEPD, pMSD);
	}

	Lock(&pMSD->CommandLock);
	RELEASE_MSD(pMSD, "Send Timout Timer");							// Release Ref for timer
}


/***********************
========SPACER==========
************************/

/*
**		MSD Pool support routines
**
**		These are the functions called by Fixed Pool Manager as it handles MSDs.
*/

#define	pELEMENT		((PMSD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Allocate"

BOOL MSD_Allocate(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,7, "(%p) Allocating new MSD", pELEMENT);

	ZeroMemory(pELEMENT, sizeof(messagedesc));

	if (DNInitializeCriticalSection(&pELEMENT->CommandLock) == FALSE)
	{
		DPFX(DPFPREP,0, "Failed to initialize MSD CS");
		return FALSE;		
	}
	DebugSetCriticalSectionRecursionCount(&pELEMENT->CommandLock,0);
	DebugSetCriticalSectionGroup(&pELEMENT->CommandLock, &g_blProtocolCritSecsHeld);
	
	pELEMENT->blFrameList.Initialize();
	pELEMENT->blQLinkage.Initialize();
	pELEMENT->blSPLinkage.Initialize();
	pELEMENT->Sign = MSD_SIGN;
	pELEMENT->lRefCnt = -1;

	// NOTE: pELEMENT->pEPD NULL'd by ZeroMemory above

	return TRUE;
}

//	Get is called each time an MSD is used


#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Get"

VOID MSD_Get(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "CREATING MSD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->CommandID = COMMAND_ID_NONE;
	pELEMENT->ulMsgFlags1 = MFLAGS_ONE_IN_USE;	// Dont need InUse flag since we have RefCnt
	pELEMENT->lRefCnt = 0; // One initial reference
	pELEMENT->hCommand = 0;

	ASSERT_MSD(pELEMENT);
}

/*
**	MSD Release
**
**		This is called with the CommandLock held.  The Lock should not be
**	freed until the INUSE flag is cleared.  This is to synchronize with
**	last minute Cancel threads waiting on lock.
**
**		When freeing a message desc we will free all frame descriptors
**	attached to it first.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Release"

VOID MSD_Release(PVOID pElement)
{
	CBilink	*pLink;
	PFMD	pFMD;

#ifdef DBG
	ASSERT_MSD(pELEMENT);

	AssertCriticalSectionIsTakenByThisThread(&pELEMENT->CommandLock, TRUE);

	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "RELEASING MSD %p", pELEMENT);

	ASSERT(pELEMENT->ulMsgFlags1 & MFLAGS_ONE_IN_USE);
	ASSERT(pELEMENT->lRefCnt == -1);
	ASSERT((pELEMENT->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)==0);
#endif // DBG

	while( (pLink = pELEMENT->blFrameList.GetNext()) != &pELEMENT->blFrameList)
	{
		pLink->RemoveFromList();							// remove from bilink

		pFMD = CONTAINING_OBJECT(pLink, FMD, blMSDLinkage);
		ASSERT_FMD(pFMD);
		RELEASE_FMD(pFMD, "MSD Frame List");								// If this is still submitted it will be referenced and wont be released here.
	}

	ASSERT(pELEMENT->blFrameList.IsEmpty());
	ASSERT(pELEMENT->blQLinkage.IsEmpty());
	ASSERT(pELEMENT->blSPLinkage.IsEmpty());

	ASSERT(pELEMENT->uiFrameCount == 0);

	pELEMENT->ulMsgFlags1 = 0;
	pELEMENT->ulMsgFlags2 = 0;

	ASSERT(pELEMENT->pEPD == NULL); // This should have gotten cleaned up before here.

	Unlock(&pELEMENT->CommandLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Free"

VOID MSD_Free(PVOID pElement)
{
	DNDeleteCriticalSection(&pELEMENT->CommandLock);
}

#undef	pELEMENT

/*
**		FMD Pool support routines
*/

#define	pELEMENT		((PFMD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Allocate"

BOOL FMD_Allocate(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,7, "(%p) Allocating new FMD", pELEMENT);

	pELEMENT->Sign = FMD_SIGN;
	pELEMENT->ulFFlags = 0;
	pELEMENT->lRefCnt = 0;

	pELEMENT->blMSDLinkage.Initialize();
	pELEMENT->blQLinkage.Initialize();
	pELEMENT->blWindowLinkage.Initialize();
	pELEMENT->blCoalesceLinkage.Initialize();
	pELEMENT->pCSD = NULL;
	
	return TRUE;
}

//	Get is called each time an MSD is used
//
//	Probably dont need to do this everytime,  but some random SP might
//	munch the parameters someday and that could be bad if I dont...

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Get"

VOID FMD_Get(PVOID pElement, PVOID pvContext)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "CREATING FMD %p", pELEMENT);

	pELEMENT->CommandID = COMMAND_ID_NONE;
	pELEMENT->lpImmediatePointer = (LPVOID) pELEMENT->ImmediateData;
	pELEMENT->SendDataBlock.pBuffers = (PBUFFERDESC) &pELEMENT->uiImmediateLength;
	pELEMENT->SendDataBlock.dwBufferCount = 1;				// always count one buffer for immediate data
	pELEMENT->SendDataBlock.dwFlags = 0;
	pELEMENT->SendDataBlock.pvContext = pElement;
	pELEMENT->SendDataBlock.hCommand = 0;
	pELEMENT->ulFFlags = 0;
	pELEMENT->bSubmitted = FALSE;
	pELEMENT->bPacketFlags = 0;
	pELEMENT->tAcked = -1;
	
	pELEMENT->lRefCnt = 1;						// Assign first reference

	ASSERT_FMD(pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Release"

VOID FMD_Release(PVOID pElement)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "RELEASING FMD %p", pELEMENT);

	ASSERT_FMD(pELEMENT);
	ASSERT(pELEMENT->lRefCnt == 0);
	ASSERT(pELEMENT->bSubmitted == FALSE);
	pELEMENT->pMSD = NULL;

	ASSERT(pELEMENT->blMSDLinkage.IsEmpty());
	ASSERT(pELEMENT->blQLinkage.IsEmpty());
	ASSERT(pELEMENT->blWindowLinkage.IsEmpty());
	ASSERT(pELEMENT->blCoalesceLinkage.IsEmpty());
	ASSERT(pELEMENT->pCSD == NULL);
}

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Free"

VOID FMD_Free(PVOID pElement)
{
}

#undef	pELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\mytimer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		mytimer.h
 *  Content:	This file contains code for the Protocol's timers
 *
 *  History:
 *   Date		By			Reason
 *   ====	==			======
 *  06/04/98	aarono  		Original
 *  07/01/00	masonb  		Assumed Ownership
 *  06/25/02	simonpow	Modified to use inline functions calling into the standard threadpool
 *
 ****************************************************************************/

#pragma TODO(vanceo, "Select CPU for these functions")

	//N.B. The 3rd param for ScheduleProtocolTimer and  RescheduleProtocolTimer (the unused DWORD) takes the accuracy
	//we require for the timer. This isn't supported in the current thread pool, but I've left the option there in case we ever
	//implement this functionality

inline HRESULT ScheduleProtocolTimer(PSPD pSPD, DWORD dwDelay, DWORD , const PFNDPTNWORKCALLBACK pfnWorkCallback,
									void * pvCallbackContext, void ** ppvTimerData, UINT *const pdwTimerUnique)
{
#ifndef DPNBUILD_NOPROTOCOLTESTITF
	if (pSPD->pPData->ulProtocolFlags & PFLAGS_FAIL_SCHEDULE_TIMER)
		return DPNERR_OUTOFMEMORY;
#endif
	return IDirectPlay8ThreadPoolWork_ScheduleTimer(pSPD->pPData->pDPThreadPoolWork, 
						-1, dwDelay, pfnWorkCallback, pvCallbackContext, ppvTimerData, pdwTimerUnique, 0);
}

inline HRESULT RescheduleProtocolTimer(PSPD pSPD, void * pvTimerData, DWORD dwDelay, DWORD, 
					const PFNDPTNWORKCALLBACK pfnWorkCallback, void * pvCallbackContext, UINT *const pdwTimerUnique)
{
	return IDirectPlay8ThreadPoolWork_ResetCompletingTimer(pSPD->pPData->pDPThreadPoolWork, pvTimerData,
						 dwDelay, pfnWorkCallback, pvCallbackContext, pdwTimerUnique, 0);
}

inline HRESULT CancelProtocolTimer(PSPD pSPD, void * pvTimerData, DWORD dwTimerUnique)
{
	return IDirectPlay8ThreadPoolWork_CancelTimer(pSPD->pPData->pDPThreadPoolWork, pvTimerData, dwTimerUnique, 0);
}

inline HRESULT ScheduleProtocolWork(PSPD pSPD, const PFNDPTNWORKCALLBACK pfnWorkCallback, 
																	void * const pvCallbackContext)
{
	return IDirectPlay8ThreadPoolWork_QueueWorkItem(pSPD->pPData->pDPThreadPoolWork, -1, 
																pfnWorkCallback, pvCallbackContext, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\sources.inc ===
TARGETNAME=protocol
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnproti.h
PRECOMPILED_PCH=dnproti.pch
PRECOMPILED_OBJ=dnproti.obj

INCLUDES=..\;..\..\common;..\..\inc;..\..\dnaddress;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= backend.cpp \
	 command.cpp \
	 connect.cpp \
	 endpt.cpp \
        	 enum.cpp \
	 initialize.cpp \
	 lower_mn.cpp \
 	 receive.cpp \
	 send.cpp\
	 SHA1Hashing.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\commanddata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CommandData.h
 *  Content:	Declaration of class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/99	jtk		Derived from SPData.h
 ***************************************************************************/

#ifndef __COMMAND_DATA_H__
#define __COMMAND_DATA_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

typedef	enum
{
	COMMAND_STATE_UNKNOWN,					// unknown state
	COMMAND_STATE_PENDING,					// command waiting to be processed
	COMMAND_STATE_INPROGRESS,				// command is executing
	COMMAND_STATE_INPROGRESS_CANNOT_CANCEL,	// command is executing, can't be cancelled
	COMMAND_STATE_CANCELLING,				// command is already being cancelled
} COMMAND_STATE;

typedef	enum
{	
	COMMAND_TYPE_UNKNOWN,		// unknown command
	COMMAND_TYPE_CONNECT,		// connect command
	COMMAND_TYPE_LISTEN,		// listen command
	COMMAND_TYPE_ENUM_QUERY,	// enum command
	COMMAND_TYPE_SEND,			// data send command (enum, enum query, send)
} COMMAND_TYPE;

#define	NULL_DESCRIPTOR		0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CModemEndpoint;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
class	CModemCommandData
{
	public:
		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		DWORD	GetDescriptor( void ) const { return m_dwDescriptor; }
		void	SetDescriptor( void )
		{
			m_dwDescriptor = m_dwNextDescriptor;
			m_dwNextDescriptor++;
			if ( m_dwNextDescriptor == NULL_DESCRIPTOR )
			{
				m_dwNextDescriptor++;
			}

			SetState( COMMAND_STATE_UNKNOWN );
		}

		COMMAND_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemCommandData::SetState"
		void			SetState( const COMMAND_STATE State )
		{
			DNASSERT( ( ( m_State == COMMAND_STATE_UNKNOWN ) || ( State == COMMAND_STATE_UNKNOWN ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_INPROGRESS ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_CANCELLING ) ) ||
					  ( ( m_State == COMMAND_STATE_INPROGRESS ) && ( State == COMMAND_STATE_CANCELLING ) ) );
			m_State = State;
		}

		COMMAND_TYPE	GetType( void ) const { return m_Type; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemCommandData::SetType"
		void			SetType( const COMMAND_TYPE Type )
		{
			DNASSERT( ( m_Type == COMMAND_TYPE_UNKNOWN ) || ( Type == COMMAND_TYPE_UNKNOWN ) );
			m_Type = Type;
		}

		CModemEndpoint	*GetEndpoint( void ) { return m_pEndpoint; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemCommandData::SetEndpoint"
		void		SetEndpoint( CModemEndpoint *const pEndpoint )
		{
			DNASSERT( ( m_pEndpoint == NULL ) || ( pEndpoint == NULL ) );
			m_pEndpoint = pEndpoint;
		}

		void	*GetUserContext( void ){ return m_pUserContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemCommandData::SetUserContext"
		void	SetUserContext( void *const pUserContext )
		{
			DNASSERT( ( m_pUserContext == NULL ) || ( pUserContext == NULL ) );
			m_pUserContext = pUserContext;
		}

		void	AddToActiveCommandList( CBilink *const pLinkage ) { m_CommandListLinkage.InsertAfter( pLinkage ); }
		void	RemoveFromActiveCommandList( void ) { m_CommandListLinkage.RemoveFromList(); }

		void	Reset( void );

		//
		// pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemCommandData::AddRef"
		void	AddRef( void ) 
		{ 
			DPFX(DPFPREP, 8, "AddRef CModemCommandData (%p), refcount = %d", this, m_iRefCount + 1);

			DNASSERT( m_iRefCount != 0 );
			DNInterlockedIncrement( &m_iRefCount ); 
		}
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemCommandData::DecRef"
		void	DecRef( void )
		{
			DPFX(DPFPREP, 8, "DecRef CModemCommandData (%p), refcount = %d", this, m_iRefCount - 1);

			DNASSERT( m_iRefCount != 0 );
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

	protected:

	private:
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION		m_Lock;
#endif // !DPNBUILD_ONLYONETHREAD
		CBilink					m_CommandListLinkage;

		volatile DWORD			m_dwDescriptor;
		volatile DWORD			m_dwNextDescriptor;
		volatile COMMAND_STATE	m_State;
		COMMAND_TYPE			m_Type;
		CModemEndpoint*				m_pEndpoint;
		void*					m_pUserContext;
		volatile LONG			m_iRefCount;

		//
		// prevent unwarranted copies
		//
		CModemCommandData( const CModemCommandData & );
		CModemCommandData& operator=( const CModemCommandData & );
};

#undef DPF_MODNAME

#endif	// __COMMAND_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\comportui.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPortUI.cpp
 *  Content:	Serial service provider UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/24/99	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// default size of temp strings used to add stuff to dialog
//
#define	DEFAULT_DIALOG_STRING_SIZE	100

#define	DEFAULT_DEVICE_SELECTION_INDEX			0
#define	DEFAULT_BAUD_RATE_SELECTION_INDEX		11
#define	DEFAULT_STOP_BITS_SELECTION_INDEX		0
#define	DEFAULT_PARITY_SELECTION_INDEX			0
#define	DEFAULT_FLOW_CONTROL_SELECTION_INDEX	0

//
// expected return from comport dialog
//
static const INT_PTR	g_iExpectedComPortDialogReturn = 0x12345678;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
static HRESULT	SetDialogDevice( const HWND hDlg, const CModemEndpoint *const pComEndpoint );
static HRESULT	SetDialogBaudRate( const HWND hDlg, const CModemEndpoint *const pComEndpoint );
static HRESULT	SetDialogStopBits( const HWND hDlg, const CModemEndpoint *const pComEndpoint );
static HRESULT	SetDialogParity( const HWND hDlg, const CModemEndpoint *const pComEndpoint );
static HRESULT	SetDialogFlowControl( const HWND hDlg, const CModemEndpoint *const pComEndpoint );
static HRESULT	GetDialogData( const HWND hDlg, CModemEndpoint *const pComEndpoint );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayComPortDialog - dialog for comport settings
//
// Entry:		Pointer to CModemEndpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayComPortSettingsDialog"

void	DisplayComPortSettingsDialog( void *const pContext )
{
	INT_PTR			iDlgReturn;
	CModemEndpoint	*pComEndpoint;


	DNASSERT( pContext != NULL );

	//	
	// intialize
	//
	pComEndpoint = static_cast<CModemEndpoint*>( pContext );

	DBG_CASSERT( sizeof( pComEndpoint ) == sizeof( LPARAM ) );
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hModemDLLInstance,							// handle of module for resources
								 MAKEINTRESOURCE( IDD_SERIAL_SETTINGS ),	// resource for dialog
								 NULL,										// parent (none)
								 SettingsDialogProc,						// dialog message proc
								 reinterpret_cast<LPARAM>( pComEndpoint )	// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedComPortDialogReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start comport settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pComEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// StopComPortSettingsDialog - stop dialog dialog for serial settings
//
// Entry:		Handle of dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StopComPortSettingsDialog"

void	StopComPortSettingsDialog( const HWND hDlg )
{
	DNASSERT( hDlg != NULL );
	if ( PostMessage( hDlg, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to stop dialog!" );
		DisplayErrorCode( 0, dwError );
		DNASSERT( FALSE );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SettingsDialogProc - dialog proc serial settings
//
// Entry:		Window handle
//				Message
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SettingsDialogProc"

static	INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	HRESULT			hr;
	CModemEndpoint	*pComEndpoint;


	//
	// initialize
	//
	hr = DPN_OK;
	pComEndpoint = NULL;

	//
	// note the active comport pointer
	//
	DBG_CASSERT( sizeof( pComEndpoint ) == sizeof( ULONG_PTR ) );
	pComEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDlg, GWLP_USERDATA ) );

	switch ( uMsg )
	{
		// initialize dialog
		case WM_INITDIALOG:
		{
			//
			// since this is the first dialog message, the default code to set
			// pComEndpoint didn't get valid data so we need to update the pointer
			//
			DBG_CASSERT( sizeof( pComEndpoint ) == sizeof( lParam ) );
			pComEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
			pComEndpoint->SetActiveDialogHandle( hDlg );

			//
			// SetWindowLong() returns NULL in case of error.  It's possible that
			// the old value from SetWindowLong() was really NULL in which case it's not
			// an error.  To be safe, clear any residual error code before calling
			// SetWindowLong().
			//
			SetLastError( 0 );
			if ( SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam ) == NULL )
			{
				DWORD	dwError;


				dwError = GetLastError();
				if ( dwError != ERROR_SUCCESS )
				{
					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
					DisplayErrorCode( 0, dwError );
					hr = DPNERR_GENERIC;
					goto Failure;
				}
			}

			//
			// set dialog parameters
			//
			hr = SetDialogDevice( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting device in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogBaudRate( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting baud rate in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogStopBits( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting stop bits in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogParity( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting parity in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogFlowControl( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting flow control in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			return	TRUE;

			break;
		}

		// a control did something
		case WM_COMMAND:
		{
			// what was the control?
			switch ( LOWORD( wParam ) )
			{
				case IDOK:
				{
					hr = GetDialogData( hDlg, pComEndpoint );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem getting UI data!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					// pass any error code on to 'DialogComplete'
					pComEndpoint->SettingsDialogComplete( hr );
					EndDialog( hDlg, g_iExpectedComPortDialogReturn );

					break;
				}

				case IDCANCEL:
				{
					pComEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
					EndDialog( hDlg, g_iExpectedComPortDialogReturn );

					break;
				}

				default:
				{
					break;
				}
			}

			break;
		}

		// window is closing
		case WM_CLOSE:
		{
			break;
		}
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pComEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pComEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDlg, g_iExpectedComPortDialogReturn );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogDevice - set serial device field
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogDevice"

static	HRESULT	SetDialogDevice( const HWND hDlg, const CModemEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fPortAvailable[ MAX_DATA_PORTS ];
	DWORD		dwPortCount;
	TCHAR		TempBuffer[ DEFAULT_DIALOG_STRING_SIZE ];
	BOOL		fSelectionSet;
	HWND		hSerialDeviceComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	fSelectionSet = FALSE;
	hSerialDeviceComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_DEVICE );
	if ( hSerialDeviceComboBox == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem getting handle of serial device combo box!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	//
	// get list of available com ports
	//
	hr = GenerateAvailableComPortList( fPortAvailable, ( LENGTHOF( fPortAvailable ) - 1 ), &dwPortCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem generating vaild port list!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	uIndex = LENGTHOF( fPortAvailable );
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		//
		// only output all adapters on incoming settings
		//
		if ( fPortAvailable[ uIndex ] != FALSE )
		{
			DNASSERT( uIndex != 0 );	// ALL_ADAPTERS is not valid!
			ComDeviceIDToString( TempBuffer, uIndex );

			DBG_CASSERT( sizeof( &TempBuffer[ 0 ] ) == sizeof( LPARAM ) );
			lSendReturn = SendMessage( hSerialDeviceComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( TempBuffer ) );
			switch ( lSendReturn )
			{
				case CB_ERR:
				{
					hr = DPNERR_GENERIC;
					DPFX(DPFPREP,  0, "Problem adding serial device to combo box!" );
					goto Failure;

					break;
				}

				case CB_ERRSPACE:
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Out of memory when ading serial device to combo box!" );
					goto Failure;


					break;
				}

				//
				// we added the string OK, set the associated device id and check
				// to see if this is the current value to set selection
				//
				default:
				{	
					LRESULT	lTempReturn;


					lTempReturn = SendMessage ( hSerialDeviceComboBox, CB_SETITEMDATA, lSendReturn, uIndex );
					if ( lTempReturn == CB_ERR )
					{
						DWORD	dwError;


						hr = DPNERR_OUTOFMEMORY;
						dwError = GetLastError();
						DPFX(DPFPREP,  0, "Problem setting device info!" );
						DisplayErrorCode( 0, dwError );
						goto Failure;
					}

					if ( pComEndpoint->GetDeviceID() == uIndex )
					{
						lTempReturn = SendMessage( hSerialDeviceComboBox, CB_SETCURSEL, lSendReturn, 0 );
						switch ( lTempReturn )
						{
							case CB_ERR:
							{
								DWORD	dwError;


								hr = DPNERR_GENERIC;
								dwError = GetLastError();
								DPFX(DPFPREP,  0, "Problem setting default serial device selection!" );
								DisplayErrorCode( 0, dwError );
								DNASSERT( FALSE );
								goto Failure;

								break;
							}

							default:
							{
								fSelectionSet = TRUE;
								break;
							}
						}
					}

					break;
				}
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial device not set, using default!" );

		lSendReturn = SendMessage( hSerialDeviceComboBox, CB_SETCURSEL, DEFAULT_DEVICE_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial device selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogBaudRate - set serial baud rate fields
//
// Entry:		Window handle
//				Pointer to com port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogBaudRate"

static	HRESULT	SetDialogBaudRate( const HWND hDlg, const CModemEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hBaudRateComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwBaudRateCount;
	fSelectionSet = FALSE;
	hBaudRateComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_BAUDRATE );
	if ( hBaudRateComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial baud rate combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_BaudRate[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hBaudRateComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_BaudRate[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding baud rate to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding baud rate to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK, attemt to set the item data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hBaudRateComboBox, CB_SETITEMDATA, lSendReturn, g_BaudRate[ uIndex ].dwEnumValue );
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set baud rate item data!" );
					goto Failure;
				}

				if ( pComEndpoint->GetBaudRate() == g_BaudRate[ uIndex ].dwEnumValue )
				{
					// set current selection to this item
					lTempReturn = SendMessage( hBaudRateComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default serial baud rate selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial baud rate not set, using default!" );

		lSendReturn = SendMessage( hBaudRateComboBox, CB_SETCURSEL, DEFAULT_BAUD_RATE_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial baud rate selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogStopBits - set serial stop bits fields
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogStopBits"

static	HRESULT	SetDialogStopBits( const HWND hDlg, const CModemEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hStopBitsComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwStopBitsCount;
	fSelectionSet = FALSE;
	hStopBitsComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_STOPBITS );
	if ( hStopBitsComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial stop bits combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_StopBits[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hStopBitsComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_StopBits[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding stop bits to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding stop bits to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK attempt to set the associated data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hStopBitsComboBox, CB_SETITEMDATA, lSendReturn, g_StopBits[ uIndex ].dwEnumValue);
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set associated data for stop bits!" );
					goto Failure;
				}

				if ( pComEndpoint->GetStopBits() == g_StopBits[ uIndex ].dwEnumValue )
				{
					// set current selection to this item
					lTempReturn = SendMessage( hStopBitsComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default serial stop bits selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial stop bits not set, using default!" );

		lSendReturn = SendMessage( hStopBitsComboBox, CB_SETCURSEL, DEFAULT_STOP_BITS_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial stop bits selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogParity - set serial parity fields
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogParity"

static	HRESULT	SetDialogParity( const HWND hDlg, const CModemEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hParityComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwParityCount;
	fSelectionSet = FALSE;
	hParityComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_PARITY );
	if ( hParityComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial parity combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_Parity[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hParityComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_Parity[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding parity to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding parity to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK, attempt to set the associated data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hParityComboBox, CB_SETITEMDATA, lSendReturn, g_Parity[ uIndex ].dwEnumValue );
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set associated data for parity." );
					goto Failure;
				}

				if ( pComEndpoint->GetParity() == g_Parity[ uIndex ].dwEnumValue )
				{
					//
					// set current selection to this item
					//
					lTempReturn = SendMessage( hParityComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default serial parity selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial parity not set, using default!" );

		lSendReturn = SendMessage( hParityComboBox, CB_SETCURSEL, DEFAULT_PARITY_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial parity selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogFlowControl - set serial flow control
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogFlowControl"

static	HRESULT	SetDialogFlowControl( const HWND hDlg, const CModemEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hFlowControlComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwFlowControlCount;
	fSelectionSet = FALSE;
	hFlowControlComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_FLOWCONTROL );
	if ( hFlowControlComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial flow control combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_FlowControl[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hFlowControlComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_FlowControl[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding flow control to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding flow control to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK, attempt to set the associated data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hFlowControlComboBox, CB_SETITEMDATA, lSendReturn, g_FlowControl[ uIndex ].dwEnumValue );
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set associated data for flow control!" );
					goto Failure;
				}

				if ( pComEndpoint->GetFlowControl() == static_cast<SP_FLOW_CONTROL>( g_FlowControl[ uIndex ].dwEnumValue ) )
				{
					// set current selection to this item
					lTempReturn = SendMessage( hFlowControlComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default flow control selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial flow control not set, using default!" );

		lSendReturn = SendMessage( hFlowControlComboBox, CB_SETCURSEL, DEFAULT_FLOW_CONTROL_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial flow control selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDialogData - set ComEndpoint data from serial dialog
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDialogData"

static	HRESULT	GetDialogData( const HWND hDlg, CModemEndpoint *const pComEndpoint )
{
	HRESULT	hr;
	LRESULT	lSelection;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// get comm device
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_DEVICE ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial device selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_DEVICE ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated device data!" );
				DNASSERT( FALSE );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			DNASSERT( lItemData != 0 );
			
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetDeviceID( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get baud rate
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_BAUDRATE ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial baud rate selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			DNASSERT( hr == DPN_OK );
			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_BAUDRATE ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated baudrate data!" );
				DNASSERT( FALSE );
				goto Failure;
			}
			
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetBaudRate( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get stop bits
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_STOPBITS ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial stop bits selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_STOPBITS ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated stop bits data!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetStopBits( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get parity
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_PARITY ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial parity selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_PARITY ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated parity data!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetParity( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get flow control
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_FLOWCONTROL ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial flow control selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_FLOWCONTROL ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated flow control data!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			hTempResult = pComEndpoint->SetFlowControl( static_cast<SP_FLOW_CONTROL>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\comportdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   ComPortData.cpp
 *  Content:	Serial communications port data management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 *	04/25/2000	jtk		Derived from ComPort class
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

////
//// number of BITS in a serial BYTE
////
//#define	BITS_PER_BYTE	8
//
////
//// maximum size of baud rate string
////
//#define	MAX_BAUD_STRING_SIZE	7
//
////
//// default size of buffers when parsing
////
//#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000
//
////
//// device ID assigned to 'all adapters'
////
//#define	ALL_ADAPTERS_DEVICE_ID	0
//
////
//// NULL token
////
//#define	NULL_TOKEN	'\0'

//**********************************************************************
// Macro definitions
//**********************************************************************

#define DPNA_BAUD_RATE_9600_W				L"9600"
#define DPNA_BAUD_RATE_14400_W				L"14400"
#define DPNA_BAUD_RATE_19200_W				L"19200"
#define DPNA_BAUD_RATE_38400_W				L"38400"
#define DPNA_BAUD_RATE_56000_W				L"56000"
#define DPNA_BAUD_RATE_57600_W				L"57600"
#define DPNA_BAUD_RATE_115200_W				L"115200"

// values for baud rate
#define DPNA_BAUD_RATE_9600_A				"9600"
#define DPNA_BAUD_RATE_14400_A				"14400"
#define DPNA_BAUD_RATE_19200_A				"19200"
#define DPNA_BAUD_RATE_38400_A				"38400"
#define DPNA_BAUD_RATE_56000_A				"56000"
#define DPNA_BAUD_RATE_57600_A				"57600"
#define DPNA_BAUD_RATE_115200_A				"115200"

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// list of baud rates
//
STRING_BLOCK	g_BaudRate[] =
{
	{ CBR_9600,		DPNA_BAUD_RATE_9600_W,		( LENGTHOF( DPNA_BAUD_RATE_9600_W ) - 1 ),		DPNA_BAUD_RATE_9600_A,		( LENGTHOF( DPNA_BAUD_RATE_9600_A ) - 1 )	},
	{ CBR_14400,	DPNA_BAUD_RATE_14400_W, 	( LENGTHOF( DPNA_BAUD_RATE_14400_W ) - 1 ),		DPNA_BAUD_RATE_14400_A, 	( LENGTHOF( DPNA_BAUD_RATE_14400_A ) - 1 )	},
	{ CBR_19200,	DPNA_BAUD_RATE_19200_W, 	( LENGTHOF( DPNA_BAUD_RATE_19200_W ) - 1 ),		DPNA_BAUD_RATE_19200_A, 	( LENGTHOF( DPNA_BAUD_RATE_19200_A ) - 1 )	},
	{ CBR_38400,	DPNA_BAUD_RATE_38400_W, 	( LENGTHOF( DPNA_BAUD_RATE_38400_W ) - 1 ),		DPNA_BAUD_RATE_38400_A, 	( LENGTHOF( DPNA_BAUD_RATE_38400_A ) - 1 )	},
	{ CBR_56000,	DPNA_BAUD_RATE_56000_W,		( LENGTHOF( DPNA_BAUD_RATE_56000_W ) - 1 ),		DPNA_BAUD_RATE_56000_A,		( LENGTHOF( DPNA_BAUD_RATE_56000_A ) - 1 )	},
	{ CBR_57600,	DPNA_BAUD_RATE_57600_W,		( LENGTHOF( DPNA_BAUD_RATE_57600_W ) - 1 ),		DPNA_BAUD_RATE_57600_A,		( LENGTHOF( DPNA_BAUD_RATE_57600_A ) - 1 )	},
	{ CBR_115200,	DPNA_BAUD_RATE_115200_W,	( LENGTHOF( DPNA_BAUD_RATE_115200_W ) - 1 ),	DPNA_BAUD_RATE_115200_A,	( LENGTHOF( DPNA_BAUD_RATE_115200_A ) - 1 )	},
};
const DWORD	g_dwBaudRateCount = LENGTHOF( g_BaudRate );

//
// list of stop bit types
//
STRING_BLOCK	g_StopBits[] =
{
	{ ONESTOPBIT,	DPNA_STOP_BITS_ONE,			( LENGTHOF( DPNA_STOP_BITS_ONE ) - 1 ),			DPNA_STOP_BITS_ONE_A,		( LENGTHOF( DPNA_STOP_BITS_ONE_A ) - 1 )		},
	{ ONE5STOPBITS,	DPNA_STOP_BITS_ONE_FIVE,	( LENGTHOF( DPNA_STOP_BITS_ONE_FIVE ) - 1 ),	DPNA_STOP_BITS_ONE_FIVE_A,	( LENGTHOF( DPNA_STOP_BITS_ONE_FIVE_A ) - 1 )	},
	{ TWOSTOPBITS,	DPNA_STOP_BITS_TWO, 		( LENGTHOF( DPNA_STOP_BITS_TWO ) - 1 ),			DPNA_STOP_BITS_TWO_A, 		( LENGTHOF( DPNA_STOP_BITS_TWO_A ) - 1 )		}
};
const DWORD	g_dwStopBitsCount = LENGTHOF( g_StopBits );

//
// list of parity types
//
STRING_BLOCK	g_Parity[] =
{	
	{ EVENPARITY,	DPNA_PARITY_EVEN,	( LENGTHOF( DPNA_PARITY_EVEN ) - 1 ),	DPNA_PARITY_EVEN_A,		( LENGTHOF( DPNA_PARITY_EVEN_A ) - 1 )		},
	{ MARKPARITY,	DPNA_PARITY_MARK,	( LENGTHOF( DPNA_PARITY_MARK ) - 1 ),	DPNA_PARITY_MARK_A,		( LENGTHOF( DPNA_PARITY_MARK_A ) - 1 )		},
	{ NOPARITY, 	DPNA_PARITY_NONE,	( LENGTHOF( DPNA_PARITY_NONE ) - 1 ),	DPNA_PARITY_NONE_A,		( LENGTHOF( DPNA_PARITY_NONE_A ) - 1 )		},
	{ ODDPARITY,	DPNA_PARITY_ODD,	( LENGTHOF( DPNA_PARITY_ODD ) - 1 ),	DPNA_PARITY_ODD_A,		( LENGTHOF( DPNA_PARITY_ODD_A ) - 1 )		},
	{ SPACEPARITY,	DPNA_PARITY_SPACE,	( LENGTHOF( DPNA_PARITY_SPACE ) - 1 ),	DPNA_PARITY_SPACE_A,	( LENGTHOF( DPNA_PARITY_SPACE_A ) - 1 )		}
};
const DWORD	g_dwParityCount = LENGTHOF( g_Parity );

//
// list of flow control types
//
STRING_BLOCK	g_FlowControl[] =
{
	{ FLOW_NONE,	DPNA_FLOW_CONTROL_NONE,		( LENGTHOF( DPNA_FLOW_CONTROL_NONE ) - 1 ),		DPNA_FLOW_CONTROL_NONE_A,		( LENGTHOF( DPNA_FLOW_CONTROL_NONE_A ) - 1 )	},
	{ FLOW_XONXOFF,	DPNA_FLOW_CONTROL_XONXOFF,	( LENGTHOF( DPNA_FLOW_CONTROL_XONXOFF ) - 1 ),	DPNA_FLOW_CONTROL_XONXOFF_A,	( LENGTHOF( DPNA_FLOW_CONTROL_XONXOFF_A ) - 1 )	},
	{ FLOW_RTS,		DPNA_FLOW_CONTROL_RTS,		( LENGTHOF( DPNA_FLOW_CONTROL_RTS ) - 1 ),		DPNA_FLOW_CONTROL_RTS_A,		( LENGTHOF( DPNA_FLOW_CONTROL_RTS_A ) - 1 )		},
	{ FLOW_DTR,		DPNA_FLOW_CONTROL_DTR,		( LENGTHOF( DPNA_FLOW_CONTROL_DTR ) - 1 ),		DPNA_FLOW_CONTROL_DTR_A,		( LENGTHOF( DPNA_FLOW_CONTROL_DTR_A ) - 1 )		},
	{ FLOW_RTSDTR,	DPNA_FLOW_CONTROL_RTSDTR,	( LENGTHOF( DPNA_FLOW_CONTROL_RTSDTR ) - 1 ),	DPNA_FLOW_CONTROL_RTSDTR_A,		( LENGTHOF( DPNA_FLOW_CONTROL_RTSDTR_A ) - 1 )	}
};
const DWORD	g_dwFlowControlCount = LENGTHOF( g_FlowControl );

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::CComPortData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::CComPortData"

CComPortData::CComPortData():
	m_dwDeviceID( INVALID_DEVICE_ID ),
    m_BaudRate( CBR_57600 ),
    m_StopBits( ONESTOPBIT ),
    m_Parity( NOPARITY ),
    m_FlowControl( FLOW_NONE )
{
	//
	// verify that the DPlay8 address baud rate #defines match those in Windows
	//
	DBG_CASSERT( CBR_9600 == DPNA_BAUD_RATE_9600 );
	DBG_CASSERT( CBR_14400 == DPNA_BAUD_RATE_14400 );
	DBG_CASSERT( CBR_19200 == DPNA_BAUD_RATE_19200 );
	DBG_CASSERT( CBR_38400 == DPNA_BAUD_RATE_38400 );
	DBG_CASSERT( CBR_56000 == DPNA_BAUD_RATE_56000 );
	DBG_CASSERT( CBR_57600 == DPNA_BAUD_RATE_57600 );
	DBG_CASSERT( CBR_115200 == DPNA_BAUD_RATE_115200 );

    memset( m_ComPortName, 0x00, sizeof( m_ComPortName ));
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::~CComPortData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::~CComPortData"

CComPortData::~CComPortData()
{
    DNASSERT( m_dwDeviceID == INVALID_DEVICE_ID );
	DNASSERT( m_BaudRate == CBR_57600 );
    DNASSERT( m_StopBits == ONESTOPBIT );
    DNASSERT( m_Parity == NOPARITY );
    DNASSERT( m_FlowControl == FLOW_NONE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ComPortDataFromDP8Addresses - initialize ComPortData from a DirectPlay8 address
//
// Entry:		Pointer to host address (may be NULL)
//				Pointer to device address
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ComPortDataFromDP8Addresses"

HRESULT	CComPortData::ComPortDataFromDP8Addresses( IDirectPlay8Address *const pHostAddress,
												   IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	CParseClass	ParseClass;
	const PARSE_KEY	ParseKeyList[] =
	{
		{ DPNA_KEY_DEVICE, LENGTHOF( DPNA_KEY_DEVICE ) - 1, this, ParseDevice },
		{ DPNA_KEY_BAUD, LENGTHOF( DPNA_KEY_BAUD) - 1, this, ParseBaud },
		{ DPNA_KEY_STOPBITS, LENGTHOF( DPNA_KEY_STOPBITS ) - 1, this, ParseStopBits },
		{ DPNA_KEY_PARITY, LENGTHOF( DPNA_KEY_PARITY ) - 1, this, ParseParity },
		{ DPNA_KEY_FLOWCONTROL, LENGTHOF( DPNA_KEY_FLOWCONTROL ) - 1, this, ParseFlowControl }
	};


	DNASSERT( pDeviceAddress != NULL );

	//		
	// initialize
	//
	hr = DPN_OK;

	//
	// reset parsing flags and parse
	//
	uIndex = LENGTHOF( m_ComponentInitializationState );
	while ( uIndex > 0 )
	{
		uIndex--;
		m_ComponentInitializationState[ uIndex ] = SP_ADDRESS_COMPONENT_UNINITIALIZED;
	}
	
	hr = ParseClass.ParseDP8Address( pDeviceAddress,
									 &CLSID_DP8SP_SERIAL,
									 ParseKeyList,
									 LENGTHOF( ParseKeyList )
									 );
	//
	// There are two addresses to parse for a comport.  The device address will
	// be present for all commands, so do it first.  The host address will be
	// parsed if it's available.
	//
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed address parse!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	if ( pHostAddress != NULL )
	{
		hr = ParseClass.ParseDP8Address( pHostAddress,
										 &CLSID_DP8SP_SERIAL,
										 ParseKeyList,
										 LENGTHOF( ParseKeyList )
										 );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed parse of host address!" );
			DisplayDNError( 0, hr );
			goto Exit;
		}
	}

	//
	// check for all parameters being initialized, or fail if one of the
	// parameters failed to initialize.
	//
	DNASSERT( hr == DPN_OK );
	uIndex = COMPORT_PARSE_KEY_MAX;
	while ( uIndex > 0 )
	{
		uIndex--;
		switch ( m_ComponentInitializationState[ uIndex ] )
		{
			//
			// This component was initialized properly.  Continue checking
			// for other problems.
			//
			case SP_ADDRESS_COMPONENT_INITIALIZED:
			{
				break;
			}

			//
			// This component was not initialized, note that the address was
			// incomplete and that the user will need to be queried.  Keep
			// checking components for other problems.
			//
			case SP_ADDRESS_COMPONENT_UNINITIALIZED:
			{
				hr = DPNERR_INCOMPLETEADDRESS;
				break;
			}

			//
			// initialization of this component failed, fail the parse.
			//
			case SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED:
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  8, "DataPortFromDNAddress: parse failure!" );
				goto Failure;

				break;
			}
		}
	}

	//
	// do we indicate an attempt at initialization?
	//
	DNASSERT( ( hr == DPN_OK ) || ( hr == DPNERR_INCOMPLETEADDRESS ) );

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CComPortData::ComPortDataFromDNAddress()" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::DP8AddressFromComPortData - convert a ComPortData to a DirectPlay8 address
//
// Entry:		Address type
//
// Exit:		Pointer to DirecctPlayAddress
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::DP8AddressFromComPortData"

IDirectPlay8Address	*CComPortData::DP8AddressFromComPortData( const ADDRESS_TYPE AddressType ) const
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	GUID		DeviceGuid;
	const WCHAR	*pComponentString;
	DWORD		dwComponentStringSize;
	IDirectPlay8Address	*pAddress;


	DNASSERT( ( AddressType == ADDRESS_TYPE_REMOTE_HOST ) ||
			  ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER ) ||
			  ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT ) );

	//
	// initialize
	//
	pAddress = NULL;

	uIndex = COMPORT_PARSE_KEY_MAX;
	while ( uIndex > 0 )
	{
		uIndex--;
		if ( m_ComponentInitializationState[ uIndex ] != SP_ADDRESS_COMPONENT_INITIALIZED )
		{
			DPFX(DPFPREP,  0, "Attempt made to extract partial ComPortData information!" );
			DNASSERT( FALSE );
			goto Failure;
		}
	}

	//
	// create output address
	//
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address,
						   reinterpret_cast<void**>( &pAddress ), FALSE );
	if ( hr != S_OK )
	{
		DNASSERT( pAddress == NULL );
		DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to create Address when converting data port to address!" );
		goto Failure;
	}


	//
	// set the SP guid
	//
	hr = IDirectPlay8Address_SetSP( pAddress, &CLSID_DP8SP_SERIAL );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to set service provider GUID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// All serial settings are part of the local adapter.  Host settings return
	// just the SP type.
	//
	if ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER )
	{
		DeviceIDToGuid( &DeviceGuid, GetDeviceID(), &g_SerialSPEncryptionGuid );
		hr = IDirectPlay8Address_SetDevice( pAddress, &DeviceGuid );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add device GUID!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
		
		//
		// set baud rate
		//
		DBG_CASSERT( sizeof( SP_BAUD_RATE ) == sizeof( DWORD ) );
		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_BAUD,
											   &m_BaudRate,
											   sizeof( SP_BAUD_RATE ),
											   DPNA_DATATYPE_DWORD );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add baud rate!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


		//
		// set stop bits
		//
		if ( ValueToString( &pComponentString,			// pointer to value string
							&dwComponentStringSize,		// pointer to length of value string
							GetStopBits(),				// enum value
							g_StopBits,					// pointer to enum-string array
							g_dwStopBitsCount			// length of enum-string array
							) == FALSE )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to convert baud rate!" );
			DNASSERT( FALSE );
			goto Failure;
		}

		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_STOPBITS,
											   pComponentString,
											   ( ( dwComponentStringSize + 1 ) * sizeof( WCHAR ) ),
											   DPNA_DATATYPE_STRING );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add stop bits!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


		//
		// set parity
		//
		if ( ValueToString( &pComponentString,			// pointer to value string
							&dwComponentStringSize,		// pointer to length of value string
							GetParity(),				// enum value
							g_Parity,					// pointer to enum-string array
							g_dwParityCount				// length of enum-string array
							) == FALSE )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to convert parity!" );
			DNASSERT( FALSE );
			goto Failure;
		}

		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_PARITY,
											   pComponentString,
											   ( ( dwComponentStringSize + 1 ) * sizeof( WCHAR ) ),
											   DPNA_DATATYPE_STRING );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add parity!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


		//
		// set flow control
		//
		if ( ValueToString( &pComponentString,			// pointer to value string
							&dwComponentStringSize,		// pointer to length of value string
							GetFlowControl(),			// enum value
							g_FlowControl,				// pointer to enum-string array
							g_dwFlowControlCount		// length of enum-string array
							) == FALSE )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to convert flow control!" );
			DNASSERT( FALSE );
			goto Failure;
		}

		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_FLOWCONTROL,
											   pComponentString,
											   ( ( dwComponentStringSize + 1 ) * sizeof( WCHAR ) ),
											   DPNA_DATATYPE_STRING );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add flow control!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

Exit:
	return	pAddress;

Failure:
	if ( pAddress != NULL )
	{
		IDirectPlay8Address_Release( pAddress );
		pAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetDeviceID - set device ID
//
// Entry:		Device ID
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetDeviceID"

HRESULT	CComPortData::SetDeviceID( const DWORD dwDeviceID )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( ( dwDeviceID > MAX_DATA_PORTS ) ||
		 ( dwDeviceID == 0 ) )
	{
		if ( dwDeviceID != INVALID_DEVICE_ID )
		{
			hr = DPNERR_ADDRESSING;
		}
		else
		{
			m_dwDeviceID = INVALID_DEVICE_ID;
			DNASSERT( hr == DPN_OK );
		}

		goto Exit;
	}

	m_dwDeviceID = dwDeviceID;
	ClearComPortName();
	ComDeviceIDToString( ComPortName(), m_dwDeviceID );
	m_ComponentInitializationState[ COMPORT_PARSE_KEY_DEVICE ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetBaudRate - set baud rate
//
// Entry:		Baud rate
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetBaudRate"

HRESULT	CComPortData::SetBaudRate( const SP_BAUD_RATE BaudRate )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( BaudRate )
    {
    	//
    	// valid rates
    	//
    	case CBR_110:
    	case CBR_300:
    	case CBR_600:
    	case CBR_1200:
    	case CBR_2400:
    	case CBR_4800:
    	case CBR_9600:
    	case CBR_14400:
    	case CBR_19200:
    	case CBR_38400:
    	case CBR_56000:
    	case CBR_57600:
    	case CBR_115200:
    	case CBR_128000:
    	case CBR_256000:
    	{
    		m_BaudRate = BaudRate;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_BAUDRATE ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Invalid baud rate (%d)!", BaudRate );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetStopBits - set stop bits
//
// Entry:		Stop bits
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetStopBits"

HRESULT	CComPortData::SetStopBits( const SP_STOP_BITS StopBits )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( StopBits )
    {
    	//
    	// valid settings
    	//
    	case ONESTOPBIT:
    	case ONE5STOPBITS:
    	case TWOSTOPBITS:
    	{
    		m_StopBits = StopBits;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_STOPBITS ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Ivalid stop bit setting (0x%x)!", StopBits );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetParity - set parity
//
// Entry:		Parity
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetParity"

HRESULT	CComPortData::SetParity( const SP_PARITY_TYPE Parity )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( Parity )
    {
    	//
    	// valid settings
    	//
    	case NOPARITY:
    	case EVENPARITY:
    	case ODDPARITY:
    	case MARKPARITY:
    	case SPACEPARITY:
    	{
    		m_Parity = Parity;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_PARITY ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Invalid parity (0x%x)!", Parity );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetFlowControl - set flow control
//
// Entry:		Flow control
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetFlowControl"

HRESULT	CComPortData::SetFlowControl( const SP_FLOW_CONTROL FlowControl )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( FlowControl )
    {
    	//
    	// valid settings
    	//
    	case FLOW_NONE:
    	case FLOW_XONXOFF:
    	case FLOW_RTS:
    	case FLOW_DTR:
    	case FLOW_RTSDTR:
    	{
    		m_FlowControl = FlowControl;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_FLOWCONTROL ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Invalid flow control (0x%x)!", FlowControl );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::IsEqual - is this comport data block equal to another?
//
// Entry:		Pointer to other data block
//
// Exit:		Boolean indicating equality
//				TRUE = is equal
//				FALSE = is not equal
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::IsEqual"

BOOL	CComPortData::IsEqual( const CComPortData *const pOtherPort ) const
{
	BOOL	fReturn;


	fReturn = TRUE;

	if ( ( GetDeviceID() != pOtherPort->GetDeviceID() ) ||
		 ( GetBaudRate() != pOtherPort->GetBaudRate() ) ||
		 ( GetStopBits() != pOtherPort->GetStopBits() ) ||
		 ( GetParity() != pOtherPort->GetParity() ) ||
		 ( GetFlowControl() != pOtherPort->GetFlowControl() ) )
	{
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::Copy - copy from another data block
//
// Entry:		Pointer to other data block
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::Copy"

void	CComPortData::Copy( const CComPortData *const pOtherPort )
{
	HRESULT	hr;


	DNASSERT( pOtherPort != NULL );

// 	DBG_CASSERT( sizeof( m_ComPortName ) == sizeof( pOtherPort->m_ComPortName ) );
//	memcpy( m_ComPortName, pOtherPort->m_ComPortName, sizeof( m_ComPortName ) );
	
	hr = SetDeviceID( pOtherPort->GetDeviceID() );
	DNASSERT( hr == DPN_OK );

	hr = SetBaudRate( pOtherPort->GetBaudRate() );
	DNASSERT( hr == DPN_OK );
	
	hr = SetStopBits( pOtherPort->GetStopBits() );
	DNASSERT( hr == DPN_OK );
	
	hr = SetParity( pOtherPort->GetParity() );
	DNASSERT( hr == DPN_OK );
	
	hr = SetFlowControl( pOtherPort->GetFlowControl() );
	DNASSERT( hr == DPN_OK );

	//
	// no need to copy comport name because it was set with the device ID
	//
//	DBG_CASSERT( sizeof( m_ComPortName ) == sizeof( pOtherPort->m_ComPortName ) );
//	memcpy( m_ComPortName, pOtherPort->m_ComPortName, sizeof( m_ComPortName ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseDevice - get comport device from string
//
// Entry:		Pointer to address component
//				Size of address component
//				Component type
//				Pointer to context (this obejct)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseDevice"

HRESULT	CComPortData::ParseDevice( const void *const pAddressComponent,
								   const DWORD dwComponentSize,
								   const DWORD dwComponentType,
								   void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;
	const GUID	*pDeviceGuid;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// is this a COM port, and is the name small enough?
	//
	if ( dwComponentSize != sizeof( *pDeviceGuid ) )
	{
		DNASSERT( FALSE );
		hr = DPNERR_ADDRESSING;
		goto Exit;
	}

	pDeviceGuid = reinterpret_cast<const GUID*>( pAddressComponent );

	hr = pThisComPortData->SetDeviceID( GuidToDeviceID( pDeviceGuid, &g_SerialSPEncryptionGuid ) );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  8, "ParseDevice: couldn't set device ID." );
		DisplayDNError( 8, hr );
		goto Exit;
	}

	DNASSERT( hr == DPN_OK );
	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_DEVICE ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	//
	// note initialization failures
	//
	if ( hr != DPN_OK )
	{
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_DEVICE ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseBaud - get baud rate from string
//
// Entry:		Pointer to address component
//				Size of component
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseBaud"

HRESULT CComPortData::ParseBaud( const void *const pAddressComponent,
								 const DWORD dwComponentSize,
								 const DWORD dwComponentType,
								 void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;
	const SP_BAUD_RATE	*pBaudRate;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );
	DNASSERT( sizeof( *pBaudRate ) == dwComponentSize );
	pBaudRate = static_cast<const SP_BAUD_RATE*>( pAddressComponent );

	hr = pThisComPortData->SetBaudRate( *pBaudRate );
	if ( hr != DPN_OK )
	{
	    hr = DPNERR_ADDRESSING;
	    pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_BAUDRATE ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
	    goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_BAUDRATE ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseStopBits - get stop bits from string
//
// Entry:		Pointer to address component
//				Component size
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseStopBits"

HRESULT CComPortData::ParseStopBits( const void *const pAddressComponent,
									 const DWORD dwComponentSize,
									 const DWORD dwComponentType,
									 void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// convert string to value
	//
	if ( StringToValue( static_cast<const WCHAR*>( pAddressComponent ),		// pointer to string
						( ( dwComponentSize / sizeof( WCHAR ) ) - 1 ),		// length of string
						&pThisComPortData->m_StopBits,						// pointer to destination
						g_StopBits,											// pointer to string/enum pairs
						g_dwStopBitsCount									// number of string/enum pairs
						) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_STOPBITS ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
		goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_STOPBITS ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseParity - get parity from string
//
// Entry:		Pointer to address component
//				Component size
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseParity"

HRESULT CComPortData::ParseParity( const void *const pAddressComponent,
								   const DWORD dwComponentSize,
								   const DWORD dwComponentType,
								   void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// convert string to value
	//
	if ( StringToValue( static_cast<const WCHAR*>( pAddressComponent ),		// pointer to string
						( ( dwComponentSize / sizeof( WCHAR ) ) - 1 ),		// length of string
						&pThisComPortData->m_Parity,						// pointer to destination
						g_Parity,											// pointer to string/enum pairs
						g_dwParityCount										// number of string/enum pairs
						) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_PARITY ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
		goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_PARITY ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseFlowControl - get flow control from string
//
// Entry:		Pointer to address component
//				Component size
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseFlowControl"

HRESULT CComPortData::ParseFlowControl( const void *const pAddressComponent,
										const DWORD dwComponentSize,
										const DWORD dwComponentType,
										void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// convert string to value
	//
	DBG_CASSERT( sizeof( pThisComPortData->m_FlowControl ) == sizeof( VALUE_ENUM_TYPE ) );
	if ( StringToValue( static_cast<const WCHAR*>( pAddressComponent ),		// pointer to string
						( ( dwComponentSize / sizeof( WCHAR ) ) - 1 ),		// length of string
						reinterpret_cast<VALUE_ENUM_TYPE*>( &pThisComPortData->m_FlowControl ),	// pointer to destination
						g_FlowControl,										// pointer to string/enum pairs
						g_dwFlowControlCount								// number of string/enum pairs
						) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_FLOWCONTROL ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
		goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_FLOWCONTROL ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\comportui.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPortUI.h
 *  Content:	Serial service provider comport UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/25/99	jtk		Created
 ***************************************************************************/

#ifndef __COM_PORT_UI_H__
#define __COM_PORT_UI_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CModemEndpoint;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
void	DisplayComPortSettingsDialog( void *const pContext );
void	StopComPortSettingsDialog( const HWND hDlg );

#endif	// __COM_PORT_UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\protocol\sha1hashing.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Hashing.cpp
 *  Content:	This file contains code to support hashing operations on protocol data
 *
 *  History:
 *   Date			By			Reason
 *   ====		==			======
 *  07/15/02	  	simonpow 	Created
 *
 ****************************************************************************/

#include "dnproti.h"

 /*********************************************************************************************
 **	Following is standard code for the SHA1 hashing algo.
 **	Taken from RFC 3174 (http://www.ietf.org/rfc/rfc3174.txt)
 **	Minor tweaks have been made to reduce unecessary error checking
  */

#define SHA1HashSize 20

typedef DWORD uint32_t;
typedef BYTE   uint8_t;
typedef int int_least16_t;

/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
	uint32_t Intermediate_Hash[SHA1HashSize/4];		/* Message Digest  */
	uint32_t Length_Low;							/* Message length in bits      */
	uint32_t Length_High;							/* Message length in bits      */
	int_least16_t Message_Block_Index;		 		/* Index into message block array   */
	uint8_t Message_Block[64];     					/* 512-bit message blocks      */
	int Computed;									/* Is the digest computed?         */
} SHA1Context;


/*
  *  Function Prototypes
  */

void SHA1Reset(  SHA1Context *);
void SHA1Input(  SHA1Context *, const uint8_t *, unsigned int);
void SHA1Result( SHA1Context *,  uint8_t Message_Digest[SHA1HashSize]);


/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1CircularShift(bits,word) \
                (((word) << (bits)) | ((word) >> (32-(bits))))

/* Local Function Prototyptes */
void SHA1PadMessage(SHA1Context *);
void SHA1ProcessMessageBlock(SHA1Context *);

/*
 *  SHA1Reset
 *
 *  Description:
 *      This function will initialize the SHA1Context in preparation
 *      for computing a new SHA1 message digest.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "SHA1Reset" 
 
void SHA1Reset(SHA1Context *context)
{
	DNASSERT(context);

	context->Length_Low             = 0;
	context->Length_High            = 0;
	context->Message_Block_Index    = 0;

	context->Intermediate_Hash[0]   = 0x67452301;
	context->Intermediate_Hash[1]   = 0xEFCDAB89;
	context->Intermediate_Hash[2]   = 0x98BADCFE;
	context->Intermediate_Hash[3]   = 0x10325476;
	context->Intermediate_Hash[4]   = 0xC3D2E1F0;

	context->Computed   = 0;
}

/*
 *  SHA1Result
 *
 *  Description:
 *      This function will return the 160-bit message digest into the
 *      Message_Digest array  provided by the caller.
 *      NOTE: The first octet of hash is stored in the 0th element,
 *            the last octet of hash in the 19th element.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to use to calculate the SHA-1 hash.
 *      Message_Digest: [out]
 *          Where the digest is returned.
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME "SHA1Result" 
 
void SHA1Result( SHA1Context *context,
                uint8_t Message_Digest[SHA1HashSize])
{
    int i;

    if (!context->Computed)
    {
        SHA1PadMessage(context);
        for(i=0; i<64; ++i)
        {
            /* message may be sensitive, clear it out */
            context->Message_Block[i] = 0;
        }
        context->Length_Low = 0;    /* and clear length */
        context->Length_High = 0;
        context->Computed = 1;

    }

    for(i = 0; i < SHA1HashSize; ++i)
    {
        Message_Digest[i] = (uint8_t ) (context->Intermediate_Hash[i>>2] >> 8 * ( 3 - ( i & 0x03 ) ));
    }
}

/*
 *  SHA1Input
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update
 *      message_array: [in]
 *          An array of characters representing the next portion of
 *          the message.
 *      length: [in]
 *          The length of the message in message_array
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME "SHA1Input"
 
void SHA1Input(    SHA1Context    *context,
                  const uint8_t  *message_array,
                  unsigned       length)
{
 
	while(length--)
	{
		context->Message_Block[context->Message_Block_Index++] =(*message_array & 0xFF);

		context->Length_Low += 8;
		if (context->Length_Low == 0)
		{
			context->Length_High++;
			DNASSERT(context->Length_High!=0);
		}

		if (context->Message_Block_Index == 64)
		{
			SHA1ProcessMessageBlock(context);
		}

		message_array++;
	}
}

/*
 *  SHA1ProcessMessageBlock
 *
 *  Description:
 *      This function will process the next 512 bits of the message
 *      stored in the Message_Block array.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Nothing.
 *
 *  Comments:

 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the
 *      names used in the publication.
 *
 *
 */
void SHA1ProcessMessageBlock(SHA1Context *context)
{
    const uint32_t K[] =    {       /* Constants defined in SHA-1   */
                            0x5A827999,
                            0x6ED9EBA1,
                            0x8F1BBCDC,
                            0xCA62C1D6
                            };
    int           t;                 /* Loop counter                */
    uint32_t      temp;              /* Temporary word value        */
    uint32_t      W[80];             /* Word sequence               */
    uint32_t      A, B, C, D, E;     /* Word buffers                */

    /*
     *  Initialize the first 16 words in the array W
     */
    for(t = 0; t < 16; t++)
    {
        W[t] = context->Message_Block[t * 4] << 24;
        W[t] |= context->Message_Block[t * 4 + 1] << 16;
        W[t] |= context->Message_Block[t * 4 + 2] << 8;
        W[t] |= context->Message_Block[t * 4 + 3];
    }

    for(t = 16; t < 80; t++)
    {
       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
    }

    A = context->Intermediate_Hash[0];
    B = context->Intermediate_Hash[1];
    C = context->Intermediate_Hash[2];
    D = context->Intermediate_Hash[3];
    E = context->Intermediate_Hash[4];

    for(t = 0; t < 20; t++)
    {
        temp =  SHA1CircularShift(5,A) +
                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);

        B = A;
        A = temp;
    }

    for(t = 20; t < 40; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }

    for(t = 40; t < 60; t++)
    {
        temp = SHA1CircularShift(5,A) +
               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }

    for(t = 60; t < 80; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }

    context->Intermediate_Hash[0] += A;
    context->Intermediate_Hash[1] += B;
    context->Intermediate_Hash[2] += C;
    context->Intermediate_Hash[3] += D;
    context->Intermediate_Hash[4] += E;

    context->Message_Block_Index = 0;
}

/*
 *  SHA1PadMessage
 *

 *  Description:
 *      According to the standard, the message must be padded to an even
 *      512 bits.  The first padding bit must be a '1'.  The last 64
 *      bits represent the length of the original message.  All bits in
 *      between should be 0.  This function will pad the message
 *      according to those rules by filling the Message_Block array
 *      accordingly.  It will also call the ProcessMessageBlock function
 *      provided appropriately.  When it returns, it can be assumed that
 *      the message digest has been computed.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to pad
 *      ProcessMessageBlock: [in]
 *          The appropriate SHA*ProcessMessageBlock function
 *  Returns:
 *      Nothing.
 *
 */

void SHA1PadMessage(SHA1Context *context)
{
    /*
     *  Check to see if the current message block is too small to hold
     *  the initial padding bits and length.  If so, we will pad the
     *  block, process it, and then continue padding into a second
     *  block.
     */
    if (context->Message_Block_Index > 55)
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 64)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }

        SHA1ProcessMessageBlock(context);

        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    else
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 56)
        {

            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }

    /*
     *  Store the message length as the last 8 octets
     */
    context->Message_Block[56] = (uint8_t ) (context->Length_High >> 24);
    context->Message_Block[57] = (uint8_t ) (context->Length_High >> 16);
    context->Message_Block[58] = (uint8_t ) (context->Length_High >> 8);
    context->Message_Block[59] = (uint8_t ) (context->Length_High);
    context->Message_Block[60] = (uint8_t ) (context->Length_Low >> 24);
    context->Message_Block[61] = (uint8_t ) (context->Length_Low >> 16);
    context->Message_Block[62] = (uint8_t ) (context->Length_Low >> 8);
    context->Message_Block[63] = (uint8_t ) (context->Length_Low);

    SHA1ProcessMessageBlock(context);
}


 /*
 **	Above was all standard SHA1 hash code taken from RFC 3174
  **********************************************************************************************/

union HashResult
{
		//all 160 bits of the result
	uint8_t val_160[SHA1HashSize];
		//the first 64 bits of the result
	ULONGLONG val_64;
};


/*
**		Generate Connect Signature
**
**		This takes a session identity, an address hash, and a connect secret and hashes them together to create 
**		a signature we can pass back to a connecting host that it can use to identify itself
*/

#undef DPF_MODNAME
#define DPF_MODNAME "GenerateConnectSig"

ULONGLONG GenerateConnectSig(DWORD dwSessID, DWORD dwAddressHash, ULONGLONG ullConnectSecret)
{
		//arrange all the supplied input parameters into a single data block
	struct InputBuffer
	{
		DWORD dwSessID;
		DWORD dwAddressHash;
		ULONGLONG ullConnectSecret;
	} inputData = { dwSessID, dwAddressHash, ullConnectSecret };

	HashResult result;
	SHA1Context context;

		//create a context for the hash and add in the input data
	SHA1Reset(&context);
	SHA1Input(&context, (const uint8_t * ) &inputData, sizeof(inputData));
		//get result of the hash and return the first 64 bits as the result
	SHA1Result(&context, result.val_160);

	DPFX(DPFPREP, 7, "Connect Sig %x-%x", DPFX_OUTPUT_ULL(result.val_64));
	return result.val_64;
}


#undef DPF_MODNAME
#define DPF_MODNAME "GenerateOutgoingFrameSig"

ULONGLONG GenerateOutgoingFrameSig(PFMD pFMD, ULONGLONG ullSecret)
{
	SHA1Context context;
	HashResult result;
	BUFFERDESC * pBuffers=pFMD->SendDataBlock.pBuffers;


		//create context for hash and then iterate over all the frames we're going to send 
	SHA1Reset(&context);
	for (DWORD dwLoop=0; dwLoop<pFMD->SendDataBlock.dwBufferCount; dwLoop++)
	{
		SHA1Input(&context, (const uint8_t * ) pBuffers[dwLoop].pBufferData, pBuffers[dwLoop].dwBufferSize);
	}
		
		//also hash in our secret, and return the first 64 bits of the result
	SHA1Input(&context, (const uint8_t * ) &ullSecret, sizeof(ullSecret));
	SHA1Result(&context, result.val_160);

	DPFX(DPFPREP, 7, "Outgoing Frame Sig %x-%x", DPFX_OUTPUT_ULL(result.val_64));
	return result.val_64;
}


#undef DPF_MODNAME
#define DPF_MODNAME "GenerateIncomingFrameSig"

ULONGLONG GenerateIncomingFrameSig(BYTE * pbyFrame, DWORD dwFrameSize, ULONGLONG ullSecret)
{
	SHA1Context context;
	HashResult result;

		//create context for hash and add in packet data followed by the secret	
	SHA1Reset(&context);
	SHA1Input(&context, (const uint8_t * ) pbyFrame, dwFrameSize);
	SHA1Input(&context, (const uint8_t * ) &ullSecret, sizeof(ullSecret));
		
		//get result of hash and return its first 64 bits as the result
	SHA1Result(&context, result.val_160);

	DPFX(DPFPREP, 7, "Incoming Frame Sig %x-%x", DPFX_OUTPUT_ULL(result.val_64));
	return result.val_64;
}


#undef DPF_MODNAME
#define DPF_MODNAME "GenerateNewSecret"

ULONGLONG GenerateNewSecret(ULONGLONG ullCurrentSecret, ULONGLONG ullSecretModifier)
{
	SHA1Context context;
	HashResult result;

		//create context for hash and combine secret followed by modifier
	SHA1Reset(&context);
	SHA1Input(&context, (const uint8_t * ) &ullCurrentSecret, sizeof(ullCurrentSecret));
	SHA1Input(&context, (const uint8_t * ) &ullSecretModifier, sizeof(ullSecretModifier));

		//get result and return first 64 bits as the result
	SHA1Result(&context, result.val_160);

	DPFX(DPFPREP, 5, "Combined current secret %x-%x with modifier %x-%x to create new secret %x-%x", 
							DPFX_OUTPUT_ULL(ullCurrentSecret), DPFX_OUTPUT_ULL(ullSecretModifier),	DPFX_OUTPUT_ULL(result.val_64));
	
	return result.val_64;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GenerateRemoteSecretModifier"

ULONGLONG GenerateRemoteSecretModifier(BYTE * pbyData, DWORD dwDataSize)
{
	SHA1Context context;
	HashResult result;

		//create context for hash and hash supplied data
	SHA1Reset(&context);
	SHA1Input(&context, (const uint8_t * ) pbyData, dwDataSize);
		//get result and return first 64 bits as the result
	SHA1Result(&context, result.val_160);

	DPFX(DPFPREP, 5, "New  Remote Secret Modifier %x-%x", DPFX_OUTPUT_ULL(result.val_64));
	return result.val_64;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GenerateLocalSecretModifier"

ULONGLONG GenerateLocalSecretModifier(BUFFERDESC * pBuffers, DWORD dwNumBuffers)
{
	SHA1Context context;
	HashResult result;

		//create context for hash and hash supplied data
	SHA1Reset(&context);
	for (DWORD dwLoop=0; dwLoop<dwNumBuffers; dwLoop++)
	{
		SHA1Input(&context, (const uint8_t * ) pBuffers[dwLoop].pBufferData, pBuffers[dwLoop].dwBufferSize);
	}
		//get result and return first 64 bits as the result
	SHA1Result(&context, result.val_160);

	DPFX(DPFPREP, 5, "New Local Secret Modifier %x-%x", DPFX_OUTPUT_ULL(result.val_64));
	return result.val_64;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\commanddata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CommandData.cpp
 *  Content:	Class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/1999	jtk		Derived from SPData.h
 *	04/16/2000	jtk		Derived from CommandData.h
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemCommandData::Reset - reset this command
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemCommandData::Reset"

void	CModemCommandData::Reset( void )
{
	m_State = COMMAND_STATE_UNKNOWN;
	m_dwDescriptor = NULL_DESCRIPTOR;
	m_Type = COMMAND_TYPE_UNKNOWN;
	m_pEndpoint = NULL;
	m_pUserContext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemCommandData::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemCommandData::PoolAllocFunction"

BOOL	CModemCommandData::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CModemCommandData* pCmdData = (CModemCommandData*)pvItem;
	BOOL	fReturn;

	fReturn = TRUE;

	pCmdData->m_State = COMMAND_STATE_UNKNOWN;
	pCmdData->m_dwDescriptor = NULL_DESCRIPTOR;
	pCmdData->m_dwNextDescriptor = NULL_DESCRIPTOR + 1;
	pCmdData->m_Type = COMMAND_TYPE_UNKNOWN;
	pCmdData->m_pEndpoint = NULL;
	pCmdData->m_pUserContext = NULL;
	pCmdData->m_iRefCount = 0;
	pCmdData->m_CommandListLinkage.Initialize();
	
	if ( DNInitializeCriticalSection( &pCmdData->m_Lock ) == FALSE )
	{
		fReturn = FALSE;
	}

	DebugSetCriticalSectionGroup( &pCmdData->m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemCommandData::PoolInitFunction - function called when item is created in pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemCommandData::PoolInitFunction"

void	CModemCommandData::PoolInitFunction( void* pvItem, void* pvContext )
{
	CModemCommandData* pCmdData = (CModemCommandData*)pvItem;

	DNASSERT( pCmdData->GetState() == COMMAND_STATE_UNKNOWN );
	DNASSERT( pCmdData->GetType() == COMMAND_TYPE_UNKNOWN );
	DNASSERT( pCmdData->GetEndpoint() == NULL );
	DNASSERT( pCmdData->GetUserContext() == NULL );

	pCmdData->m_dwDescriptor = pCmdData->m_dwNextDescriptor;
	pCmdData->m_dwNextDescriptor++;
	if ( pCmdData->m_dwNextDescriptor == NULL_DESCRIPTOR )
	{
		pCmdData->m_dwNextDescriptor++;
	}

	DNASSERT(pCmdData->m_iRefCount == 0);
	pCmdData->m_iRefCount = 1; 

	DPFX(DPFPREP, 8, "Retrieve new CModemCommandData (%p), refcount = 1", pCmdData);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemCommandData::PoolReleaseFunction - function called when returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemCommandData::PoolReleaseFunction"

void	CModemCommandData::PoolReleaseFunction( void* pvItem )
{
	CModemCommandData* pCmdData = (CModemCommandData*)pvItem;

	DPFX(DPFPREP, 8, "Return CModemCommandData (%p), refcount = 0", pCmdData);

	pCmdData->SetState( COMMAND_STATE_UNKNOWN );
	pCmdData->SetType( COMMAND_TYPE_UNKNOWN );
	pCmdData->SetEndpoint( NULL );
	pCmdData->SetUserContext( NULL );
	pCmdData->m_dwDescriptor = NULL_DESCRIPTOR;
	DNASSERT( pCmdData->m_iRefCount == 0 );

	DNASSERT( pCmdData->m_CommandListLinkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemCommandData::PoolDeallocFunction - function called when deleted from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemCommandData::PoolDeallocFunction"

void	CModemCommandData::PoolDeallocFunction( void* pvItem )
{
	CModemCommandData* pCmdData = (CModemCommandData*)pvItem;

	DNASSERT( pCmdData->m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( pCmdData->m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( pCmdData->m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( pCmdData->m_pEndpoint == NULL );
	DNASSERT( pCmdData->m_pUserContext == NULL );
	DNASSERT( pCmdData->m_CommandListLinkage.IsEmpty() != FALSE );
	DNASSERT( pCmdData->m_iRefCount == 0 );

	DNDeleteCriticalSection( &pCmdData->m_Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemCommandData::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemCommandData::ReturnSelfToPool"

void	CModemCommandData::ReturnSelfToPool( void )
{
	g_ModemCommandDataPool.Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\comportdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPortData.h
 *  Content:	Serial communications port data management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1998	jtk		Created
 *	04/25/2000	jtk		Derived from ComPort class
 ***************************************************************************/

#ifndef __COM_PORT_DATA_H__
#define __COM_PORT_DATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum length of comport string
//
#define	MAX_COMPORT_LENGTH	10

//
// enumerated values for noting which components have been initialized
//
typedef enum	_COMPORT_PARSE_KEY_INDEX
{
	COMPORT_PARSE_KEY_DEVICE = 0,
	COMPORT_PARSE_KEY_BAUDRATE,
	COMPORT_PARSE_KEY_STOPBITS,
	COMPORT_PARSE_KEY_PARITY,
	COMPORT_PARSE_KEY_FLOWCONTROL,

	// this must be the last item
	COMPORT_PARSE_KEY_MAX
} COMPORT_PARSE_KEY_INDEX;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// string blocks for parsing com port parameters
//
typedef	enum	_ADDRESS_TYPE	ADDRESS_TYPE;
typedef	struct	_STRING_BLOCK	STRING_BLOCK;

extern STRING_BLOCK			g_BaudRate[];
extern const DWORD			g_dwBaudRateCount;
extern STRING_BLOCK			g_StopBits[];
extern const DWORD			g_dwStopBitsCount;
extern STRING_BLOCK			g_Parity[];
extern const DWORD			g_dwParityCount;
extern STRING_BLOCK			g_FlowControl[];
extern const DWORD			g_dwFlowControlCount;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CComPortData
{
	public:
		CComPortData();
		~CComPortData();

		HRESULT	CComPortData::ComPortDataFromDP8Addresses( IDirectPlay8Address *const pHostAddress,
														   IDirectPlay8Address *const pDeviceAddress );
		IDirectPlay8Address	*CComPortData::DP8AddressFromComPortData( const ADDRESS_TYPE AddressType ) const;
		
		DWORD	GetDeviceID( void ) const { return m_dwDeviceID; }
		HRESULT	SetDeviceID( const DWORD dwDeviceID );

		SP_BAUD_RATE	GetBaudRate( void ) const { return m_BaudRate; }
		HRESULT	SetBaudRate( const SP_BAUD_RATE BaudRate );

		SP_STOP_BITS	GetStopBits( void ) const { return m_StopBits; }
		HRESULT	SetStopBits( const SP_STOP_BITS StopBits );

		SP_PARITY_TYPE	GetParity( void ) const  { return m_Parity; }
		HRESULT	SetParity( const SP_PARITY_TYPE Parity );

		SP_FLOW_CONTROL	GetFlowControl( void ) const { return m_FlowControl; }
		HRESULT	SetFlowControl( const SP_FLOW_CONTROL FlowControl );

		void	ClearComPortName( void ) { memset( &m_ComPortName, 0x00, sizeof( m_ComPortName ) ); }
		TCHAR	*ComPortName( void ) { return m_ComPortName; }
		
		BOOL	IsEqual ( const CComPortData *const pOtherData ) const;
		void	Copy( const CComPortData *const pOtherData );

		void	Reset( void )
		{
			SetDeviceID( INVALID_DEVICE_ID );
			SetBaudRate( CBR_57600 );
			SetStopBits( ONESTOPBIT );
			SetParity( NOPARITY );
			SetFlowControl( FLOW_NONE );
			memset( &m_ComponentInitializationState, 0x00, sizeof( m_ComponentInitializationState ) );
		}

	protected:

	private:
		DWORD	m_dwDeviceID;

		//
		// com port information
		//
		TCHAR	m_ComPortName[ MAX_COMPORT_LENGTH ];	// name of com port

		//
		// communications parameters
		//
		SP_BAUD_RATE	    m_BaudRate;			// baud rate
		SP_STOP_BITS	    m_StopBits;			// stop bits
		SP_PARITY_TYPE	    m_Parity;			// parity
		SP_FLOW_CONTROL	    m_FlowControl;		// flow control

		//
		// values indicating which components have been initialized
		//
		SP_ADDRESS_COMPONENT_STATE	m_ComponentInitializationState[ COMPORT_PARSE_KEY_MAX ];
		
		static HRESULT	ParseDevice( const void *const pAddressComponent,
									 const DWORD dwComponentSize,
									 const DWORD dwComponentType,
									 void *const pContext );
		
		static HRESULT	ParseBaud( const void *const pAddressComponent,
								   const DWORD dwComponentSize,
								   const DWORD dwComponentType,
								   void *const pContext );
		
		static HRESULT	ParseStopBits( const void *const pAddressComponent,
									   const DWORD dwComponentSize,
									   const DWORD dwComponentType,
									   void *const pContext );
		
		static HRESULT	ParseParity( const void *const pAddressComponent,
									 const DWORD dwComponentSize,
									 const DWORD dwComponentType,
									 void *const pContext );
		
		static HRESULT	ParseFlowControl( const void *const pAddressComponent,
										  const DWORD dwComponentSize,
										  const DWORD dwComponentType,
										  void *const pContext );

		// prevent unwarranted copies
		CComPortData( const CComPortData & );
		CComPortData& operator=( const CComPortData & );
};

#endif	// __COM_PORT_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\crc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CRC.h
 *  Content:	CRC Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/18/98	johnkan	Copied from DPlay 6.x and fixed up
 *@@END_MSINTERNAL
 ***************************************************************************/

#ifndef	__CRC_H__
#define	__CRC_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
//void	GenerateCRCTable( void );
DWORD	GenerateCRC( const BYTE *const pBuffer, const DWORD dwBufferSize );
DWORD	GenerateMultiBufferCRC( const BUFFERDESC *const pBuffers, const DWORD dwBufferCount );

#ifdef DBG
void	ValidateCRCTable( void );
#endif // DBG

#endif	// __CRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\crc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1996-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CRC.cpp
 *  Content:	CRC Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/18/98	johnkan	Copied from DPlay 6.x and fixed up
 *@@END_MSINTERNAL
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// uncomment the following to validate CRC table each time a CRC function is called
//#define	VALIDATE_CRC_TABLE

// defines for 32-bit CRC
///*
//  Name   : "CRC-32"
//   Width  : 32
//   Poly   : 04C11DB7
//   Init   : FFFFFFFF
//   RefIn  : True
//   RefOut : True
//   XorOut : FFFFFFFF
//   Check  : CBF43926
//
//  This is supposedly what Ethernet uses
//*/
//
//#define WIDTH		32
//#define POLY		0x04C11DB7
//#define INITVALUE	0xFFFFFFFF
//#define REFIN		TRUE
//#define XOROUT		0xFFFFFFFF
//#define CHECK		0xCBF43926
//#define WIDMASK		0xFFFFFFFF		// value is (2^WIDTH)-1


/*
  Name   : "CRC-16"
   Width  : 16
   Poly   : 8005
   Init   : 0000
   RefIn  : True
   RefOut : True
   XorOut : 0000
   Check  : BB3D
*/
#define WIDTH		16
#define POLY		0x8005
#define INITVALUE	0
#define REFIN		TRUE
#define XOROUT		0
#define CHECK		0xBB3D
#define WIDMASK		0x0000FFFF		// value is (2^WIDTH)-1

//**********************************************************************
// Macro definitions
//**********************************************************************

#define BITMASK(X) (1L << (X))

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

// precomputed CRC table values from GenerateCRC()
static	DWORD	g_CRCTable[ 256 ] =
{
	0x0, 0xc0c1, 0xc181, 0x140, 0xc301, 0x3c0, 0x280, 0xc241,
	0xc601, 0x6c0, 0x780, 0xc741, 0x500, 0xc5c1, 0xc481, 0x440,
	0xcc01, 0xcc0, 0xd80, 0xcd41, 0xf00, 0xcfc1, 0xce81, 0xe40,
	0xa00, 0xcac1, 0xcb81, 0xb40, 0xc901, 0x9c0, 0x880, 0xc841,
	0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
	0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
	0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
	0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
	0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
	0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
	0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
	0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
	0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
	0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
	0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
	0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
	0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
	0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
	0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
	0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
	0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
	0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
	0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
	0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
	0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
	0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
	0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
	0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
	0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
	0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
	0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
	0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
};

// since the talbe is static, no reason for this variable
//static	BOOL	g_fTableCreated = FALSE;

//**********************************************************************
// Function prototypes
//**********************************************************************
static	DWORD	crc_reflected( LPBYTE blk_adr, DWORD blk_len, const DWORD *crctable );

#ifdef DBG
static	DWORD	reflect( DWORD v, int b );
static	DWORD	cm_tab( int index );
#endif // DBG

//**********************************************************************
// Function definitions
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// crc_normal - generate a normal CRC
////
//// Entry:		Pointer to input data block
////				Size of data block
////				Pointer to CRC table
////
//// Exit:		32-bit CRC
//// ------------------------------
//static	DWORD	crc_normal( LPBYTE blk_adr, DWORD blk_len, DWORD crctable[] )
//{
//	DWORD	crc = INITVALUE;
//
//	while (blk_len--)
//		crc = crctable[((crc>>24) ^ *blk_adr++) & 0xFFL] ^ (crc << 8);
//
//	return (crc ^ XOROUT);
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// crc_reflected - generate a reflected CRC
//
// Entry:		Pointer to input data block
//				Size of data block
//				Pointer to CRC table
//
// Exit:		32-bit CRC
// ------------------------------
static	DWORD	crc_reflected( BYTE *blk_adr, DWORD blk_len, const DWORD *crctable )
{
	DWORD	crc = INITVALUE;
	DEBUG_ONLY( DWORD	dwOffset = 0 );


//	DPFX(DPFPREP,  9, "Enter crc_reflected" );

	while (blk_len--)
	{
		crc = crctable[(crc ^ *blk_adr) & 0xFFL] ^ (crc >> 8);
//		DPFX(DPFPREP,  8, "TempCRC: 0x%x\tOffset: %d\tChar 0x%x", crc, dwOffset, *blk_adr );
		blk_adr++;
		DEBUG_ONLY( dwOffset++ );
	}

	crc ^= XOROUT;
//	DPFX(DPFPREP,  8, "Computed CRC: 0x%x", crc );

//	DPFX(DPFPREP,  9, "Leave crc_reflected" );

	return crc;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// GenerateCRCTable - create CRC table
////
//// Entry:		Nothing
////
//// Exit:		Nothing
//// ------------------------------
//void	GenerateCRCTable( void )
//{
//	DWORD	i;
//
//
//	// had the table been built?
//	if ( g_fTableCreated == FALSE )
//	{
//		for (i = 0; i < 256; i++)
//		{
//			g_CRCTable[i] = cm_tab(i);
//		}
//
//		// note that the table has been built
//		g_fTableCreated = TRUE;
//	}
//
//	// code to pregenerate CRC table
//	DPFX(DPFPREP,  0, "\nHexDump:\n" );
//	for( i = 0; i < 256; i+=8 )
//	{
//		DPFX(DPFPREP,  3, "0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x,", g_CRCTable[ i ],
//																   g_CRCTable[ i + 1 ],
//																   g_CRCTable[ i + 2 ],
//																   g_CRCTable[ i + 3 ],
//																   g_CRCTable[ i + 4 ],
//																   g_CRCTable[ i + 5 ],
//																   g_CRCTable[ i + 6 ],
//																   g_CRCTable[ i + 7 ] );
//
//	}
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateCRC - generate a CRC
//
// Entry:		Pointer to data
//				Size of data
//
// Exit:		CRC
// ------------------------------
DWORD	GenerateCRC( const BYTE *const pBuffer, const DWORD dwBufferSize )
{
//	DNASSERT( g_fTableCreated != FALSE );

#ifdef VALIDATE_CRC_TABLE
	ValidateCRCTable();
#endif // VALIDATE_CRC_TABLE

	return ( crc_reflected( const_cast<BYTE*>( pBuffer ), dwBufferSize, g_CRCTable ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateMultiBufferCRC - generate a CRC from multiple buffers
//
// Entry:		Pointer to buffer descriptions
//				Count of buffers
//
// Exit:		CRC
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GenerateMultiBufferCRC"

DWORD GenerateMultiBufferCRC( const BUFFERDESC *const pBuffer, const DWORD dwBufferCount )
{
	DWORD	TempCRC;
//	DWORD	crc = INITVALUE;
	DWORD	Count;
//	DNASSERT( g_fTableCreated != FALSE );


//	DPFX(DPFPREP,  9, "Entering GenerateMultiBufferCRC" );

	// initialize
	TempCRC = INITVALUE;

	// generate CRC
	for ( Count = 0; Count < dwBufferCount; Count++ )
	{
		LPBYTE	pWorkingByte;
		DWORD	dwBufferSize;

		// initialize
		dwBufferSize = pBuffer[ Count ].dwBufferSize;
		pWorkingByte = static_cast<BYTE*>( pBuffer[ Count ].pBufferData );

		// CRC this block
		while ( dwBufferSize > 0 )
		{
			TempCRC = g_CRCTable[ ( TempCRC ^ (*pWorkingByte) ) & 0xFFL ] ^ ( TempCRC >> 8 );

//			DPFX(DPFPREP,  8, "TempCRC: 0x%x\tOffset: %d\tChar: 0x%x",
//					TempCRC,
//					( pWorkingByte - static_cast<BYTE*>( pBuffer[ Count ].lpBufferData ) ),
//					*pWorkingByte
//					);

			pWorkingByte++;
			dwBufferSize--;
		}
	}

	TempCRC ^= XOROUT;
//	DPFX(DPFPREP,  8, "Computed CRC: 0x%x", TempCRC );

//	DPFX(DPFPREP,  9, "Leaving GenerateMultiBufferCRC" );

	return TempCRC;
}
//**********************************************************************


#ifdef DBG
//**********************************************************************
// ------------------------------
// reflect - reflect the bottom N bits of a DWORD
//
// Entry:		Input DWORD
//				Number of bits to reflect
//
// Exit:		Reflected value
//
// Returns the value v with the bottom b [0,32] bits reflected.
// Example: reflect(0x3e23L,3) == 0x3e26
// -----------------------------
static	DWORD	reflect( DWORD v, int b )
{
	int		i;
	DWORD	t = v;

	for (i = 0; i < b; i++)
	{
		if (t & 1L)
			v |=  BITMASK((b-1)-i);
		else
			v &= ~BITMASK((b-1)-i);
		t >>= 1;
	}
	return v;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// cm_tab - do something
//
// Entry:		Index
//
// Exit:		DWORD
// ------------------------------
static	DWORD	cm_tab( int index )
{
	int   i;
	DWORD r;
	DWORD topbit = (DWORD) BITMASK(WIDTH-1);
	DWORD inbyte = (DWORD) index;

	if (REFIN)
		inbyte = reflect(inbyte, 8);

	r = inbyte << (WIDTH-8);
	for (i = 0; i < 8; i++)
	{
		if (r & topbit)
			r = (r << 1) ^ POLY;
		else
			r <<= 1;
	}

	if (REFIN)
		r = reflect(r, WIDTH);

	return (r & WIDMASK);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ValidateCRCTable - validate that the CRC table is correct
//
// Entry:		Nothing
//				Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCRCTable"

void	ValidateCRCTable( void )
{
	DWORD	i;

	for (i = 0; i < LENGTHOF( g_CRCTable ); i++)
	{
		DNASSERT( g_CRCTable[ i ] == cm_tab(i) );
	}
}
//**********************************************************************
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dataport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   DataPort.cpp
 *  Content:	Serial communications port management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 *	09/14/99	jtk		Derived from ComPort.cpp
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// number of BITS in a serial BYTE
//
#define	BITS_PER_BYTE	8

//
// maximum size of baud rate string
//
#define	MAX_BAUD_STRING_SIZE	7

//
// default size of buffers when parsing
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//
// device ID assigned to 'all adapters'
//
#define	ALL_ADAPTERS_DEVICE_ID	0

//
// NULL token
//
#define	NULL_TOKEN	'\0'

//
// modem state flags
//
#define	STATE_FLAG_CONNECTED					0x00000001
#define	STATE_FLAG_OUTGOING_CALL_DIALING		0x00000002
#define	STATE_FLAG_OUTGOING_CALL_PROCEEDING		0x00000004
#define	STATE_FLAG_INCOMING_CALL_NOTIFICATION	0x00000008
#define	STATE_FLAG_INCOMING_CALL_OFFERED		0x00000010
#define	STATE_FLAG_INCOMING_CALL_ACCEPTED		0x00000020

//
// default size of buffers when parsing
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//
// number of milliseconds in one day
//
#define	ONE_DAY		86400000

//
// number of BITS in a serial BYTE
//
#define	BITS_PER_BYTE	8

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CDataPort::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::ReturnSelfToPool"

void	CDataPort::ReturnSelfToPool( void )
{
	if (m_fModem)
	{
		g_ModemPortPool.Release( this );
	}
	else
	{
		g_ComPortPool.Release( this );
	}
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CDataPort::EndpointAddRef - increment endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::EndpointAddRef"

void	CDataPort::EndpointAddRef( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	Lock();

	DNASSERT( m_EndpointRefCount != -1 );
	m_EndpointRefCount++;
	
	AddRef();

	Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::EndpointDecRef - decrement endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Endpoint reference count
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::EndpointDecRef"

DWORD	CDataPort::EndpointDecRef( void )
{
	DWORD	dwReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	DNASSERT( m_EndpointRefCount != 0 );
	DNASSERT( ( GetState() == DATA_PORT_STATE_RECEIVING ) ||
			  ( GetState() == DATA_PORT_STATE_INITIALIZED ) );

	Lock();

	DNASSERT( m_EndpointRefCount != 0 );
	m_EndpointRefCount--;
	dwReturn = m_EndpointRefCount;
	if ( m_EndpointRefCount == 0 )
	{
		SetState( DATA_PORT_STATE_UNBOUND );
		UnbindFromNetwork();
	}

	Unlock();
	
	DecRef();

	return	dwReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::SetPortCommunicationParameters - set generate communication parameters
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::SetPortCommunicationParameters"

HRESULT	CDataPort::SetPortCommunicationParameters( void )
{
	HRESULT	hr;
	COMMTIMEOUTS	CommTimeouts;


	//
	// set timeout values for serial port
	//
	hr = DPN_OK;
	memset( &CommTimeouts, 0x00, sizeof( CommTimeouts ) );
	CommTimeouts.ReadIntervalTimeout = ONE_DAY;					// read timeout interval (none)
	CommTimeouts.ReadTotalTimeoutMultiplier = ONE_DAY;			// return immediately
	CommTimeouts.ReadTotalTimeoutConstant = 0;					// return immediately
	CommTimeouts.WriteTotalTimeoutMultiplier = 0;				// no multiplier
	CommTimeouts.WriteTotalTimeoutConstant = WRITE_TIMEOUT_MS;	// write timeout interval

	if ( SetCommTimeouts( HANDLE_FROM_DNHANDLE(m_hFile), &CommTimeouts ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		// report error (there's no cleanup)
		DPFX(DPFPREP,  0, "Unable to set comm timeouts!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	//
	// clear any outstanding communication data
	//
	if ( PurgeComm( HANDLE_FROM_DNHANDLE(m_hFile), ( PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ) ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem with PurgeComm() when opening com port!" );
		DisplayErrorCode( 0, dwError );
	}

	//
	// set communication mask to listen for character receive
	//
	if ( SetCommMask( HANDLE_FROM_DNHANDLE(m_hFile), EV_RXCHAR ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Error setting communication mask!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;

	}

Exit:	
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::StartReceiving - start receiving
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::StartReceiving"

HRESULT	CDataPort::StartReceiving( void )
{
	HRESULT	hr;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this);

	//
	// initialize
	//
	hr = DPN_OK;
	Lock();

	switch ( GetState() )
	{
		//
		// port is initialized, but not receiving yet, start receiving
		//
		case DATA_PORT_STATE_INITIALIZED:
		{
			hr = Receive();
			if ( ( hr == DPNERR_PENDING ) ||
				 ( hr == DPN_OK ) )
			{
				SetState( DATA_PORT_STATE_RECEIVING );

				//
				// the receive was successful, return success for this function
				//
				hr = DPN_OK;
			}
			else
			{
				DPFX(DPFPREP,  0, "Failed initial read!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

		//
		// data port is already receiving, nothing to do
		//
		case DATA_PORT_STATE_RECEIVING:
		{
			break;
		}

		//
		// data port is closing, we shouldn't be here!
		//
		case DATA_PORT_STATE_UNBOUND:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// bad state
		//
		case DATA_PORT_STATE_UNKNOWN:
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Unlock();

Exit:
	
	DPFX(DPFPREP, 7, "(0x%p) Return: [0x%lx]", this, hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::Receive - read from file
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::Receive"

HRESULT	CDataPort::Receive( void )
{
	HRESULT	hr;
	BOOL	fReadReturn;


	//
	// initialize
	//
	hr = DPN_OK;
	AddRef();
	
Reread:
	//
	// if there is no pending read, get one from the pool
	//
	if ( m_pActiveRead == NULL )
	{
		m_pActiveRead = m_pSPData->GetThreadPool()->CreateReadIOData();
		if ( m_pActiveRead == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed to get buffer for read!" );
			goto Failure;
		}

		m_pActiveRead->SetDataPort( this );
	}

	//
	// check the state of the read and perform the appropriate action
	//
	DNASSERT( m_pActiveRead != NULL );
	switch ( m_pActiveRead->m_ReadState )
	{
		//
		// Initialize read state.  This involves setting up to read a header
		// and then reentering the loop.
		//
		case READ_STATE_UNKNOWN:
		{
			m_pActiveRead->SetReadState( READ_STATE_READ_HEADER );
			m_pActiveRead->m_dwBytesToRead = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader );
			m_pActiveRead->m_dwReadOffset = 0;
			goto Reread;
		
			break;
		}

		//
		// issue a read for a header or user data
		//
		case READ_STATE_READ_HEADER:
		case READ_STATE_READ_DATA:
		{
			//
			// don't change m_dwReadOffset because it might have been set
			// elsewhere to recover a partially received message
			//
//			DNASSERT( m_pActiveReceiveBuffer != NULL );
//			m_dwBytesReceived = 0;
//			m_pActiveRead->m_dwBytesReceived = 0;
			break;
		}

		//
		// unknown state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

		
	//
	// lock the active read list for Win9x only to prevent reads from completing
	// early
	//
#ifdef WIN95
	m_pSPData->GetThreadPool()->LockReadData();
	DNASSERT( m_pActiveRead->Win9xOperationPending() == FALSE );
	m_pActiveRead->SetWin9xOperationPending( TRUE );
#endif // WIN95

	DNASSERT( m_pActiveRead->jkm_dwOverlappedBytesReceived == 0 );


	DPFX(DPFPREP, 8, "Submitting read 0x%p (socketport 0x%p, file 0x%p).",
		m_pActiveRead, this, m_hFile);


	//
	// perform read
	//
	fReadReturn = ReadFile( HANDLE_FROM_DNHANDLE(m_hFile),													// file handle
							&m_pActiveRead->m_ReceiveBuffer.ReceivedData[ m_pActiveRead->m_dwReadOffset ],	// pointer to destination
							m_pActiveRead->m_dwBytesToRead,													// number of bytes to read
							&m_pActiveRead->jkm_dwImmediateBytesReceived,									// pointer to number of bytes received
							m_pActiveRead->Overlap()														// pointer to overlap structure
							);
	if ( fReadReturn == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		switch ( dwError )
		{
			//
			// I/O is pending, wait for completion notification
			//
			case ERROR_IO_PENDING:
			{
				hr = DPNERR_PENDING;
				break;
			}

			//
			// comport was closed, nothing else to do
			//
			case ERROR_INVALID_HANDLE:
			{
				hr = DPNERR_NOCONNECTION;
				DPFX(DPFPREP, 3, "File closed.");
				goto Failure;

				break;
			}

			//
			// other
			//
			default:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP, 0, "Unknown error from ReadFile (%u)!", dwError);
				DisplayErrorCode( 0, dwError );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}
		}
	}
	else
	{
		//
		// read succeeded immediately, we'll handle it on the async notification
		//
		DPFX(DPFPREP, 7, "Read 0x%p completed immediately (%u bytes).",
			m_pActiveRead, m_pActiveRead->jkm_dwImmediateBytesReceived);
		DNASSERT( hr == DPN_OK );
	}

Exit:
#ifdef WIN95
		m_pSPData->GetThreadPool()->UnlockReadData();
#endif // WIN95
	return	hr;

Failure:

	if ( m_pActiveRead != NULL )
	{
#ifdef WIN95
		m_pActiveRead->SetWin9xOperationPending( FALSE );
#endif // WIN95
		m_pActiveRead->DecRef();
		m_pActiveRead = NULL;
	}

	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::SendData - send data
//
// Entry:		Pointer to write buffer
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::SendData"

void	CDataPort::SendData( CModemWriteIOData *const pWriteIOData )
{
//	CModemWriteIOData	*pActiveSend;
	UINT_PTR		uIndex;
	DWORD			dwByteCount;
	BOOL			fWriteFileReturn;


	DNASSERT( m_EndpointRefCount != 0 );
	DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START  );
	DNASSERT( ( pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken == SERIAL_DATA_USER_DATA ) ||
			  ( ( pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken & ~( ENUM_RTT_MASK ) ) == SERIAL_DATA_ENUM_QUERY ) ||
			  ( ( pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken & ~( ENUM_RTT_MASK ) )== SERIAL_DATA_ENUM_RESPONSE ) );

	//
	// check for command cancellation
	//
	if ( pWriteIOData->m_pCommand != NULL )
	{
		pWriteIOData->m_pCommand->Lock();
		switch ( pWriteIOData->m_pCommand->GetState() )
		{
			//
			// command pending, mark as uninterruptable and exit
			//
			case COMMAND_STATE_PENDING:
			{
				pWriteIOData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
				pWriteIOData->m_pCommand->Unlock();
				break;
			}

			//
			// command is being cancelled, indicate command failure
			//
			case COMMAND_STATE_CANCELLING:
			{
				DNASSERT( FALSE );
				break;
			}

			//
			// other
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	//
	// flatten the buffer so it will send faster (no thread transitions from
	// send complete to sending the next chunk).
	//
	dwByteCount = sizeof( pWriteIOData->m_DataBuffer.MessageHeader );
	for ( uIndex = 0; uIndex < pWriteIOData->m_uBufferCount; uIndex++ )
	{
		memcpy( &pWriteIOData->m_DataBuffer.Data[ dwByteCount ],
				pWriteIOData->m_pBuffers[ uIndex ].pBufferData,
				pWriteIOData->m_pBuffers[ uIndex ].dwBufferSize );
		dwByteCount += pWriteIOData->m_pBuffers[ uIndex ].dwBufferSize;
	}

	DNASSERT( dwByteCount <= MAX_MESSAGE_SIZE );

	DNASSERT( dwByteCount < 65536 );
	DBG_CASSERT( sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wMessageSize ) == sizeof( WORD ) );
	pWriteIOData->m_DataBuffer.MessageHeader.wMessageSize = static_cast<WORD>( dwByteCount - sizeof( pWriteIOData->m_DataBuffer.MessageHeader ) );

	DBG_CASSERT( sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wMessageCRC ) == sizeof( WORD ) );
	pWriteIOData->m_DataBuffer.MessageHeader.wMessageCRC = static_cast<WORD>( GenerateCRC( &pWriteIOData->m_DataBuffer.Data[ sizeof( pWriteIOData->m_DataBuffer.MessageHeader ) ], pWriteIOData->m_DataBuffer.MessageHeader.wMessageSize ) );

	DBG_CASSERT( sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wHeaderCRC ) == sizeof( WORD ) );
	DBG_CASSERT( sizeof( &pWriteIOData->m_DataBuffer.MessageHeader ) == sizeof( BYTE* ) );
	pWriteIOData->m_DataBuffer.MessageHeader.wHeaderCRC = static_cast<WORD>( GenerateCRC( reinterpret_cast<BYTE*>( &pWriteIOData->m_DataBuffer.MessageHeader ),
																						  ( sizeof( pWriteIOData->m_DataBuffer.MessageHeader) - sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wHeaderCRC ) ) ) );


	DPFX(DPFPREP, 7, "(0x%p) Writing %u bytes (WriteData 0x%p, command = 0x%p, buffer = 0x%p).",
		this, dwByteCount, pWriteIOData, pWriteIOData->m_pCommand, &(pWriteIOData->m_DataBuffer) );


	AddRef();

#ifdef WIN95
	m_pSPData->GetThreadPool()->LockWriteData();
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
	pWriteIOData->SetWin9xOperationPending( TRUE );
#endif // WIN95
	DNASSERT( pWriteIOData->jkm_dwOverlappedBytesSent == 0 );
	pWriteIOData->SetDataPort( this );

	fWriteFileReturn = WriteFile( HANDLE_FROM_DNHANDLE(m_hFile),			// file handle
								  &pWriteIOData->m_DataBuffer,				// buffer to send
								  dwByteCount,								// bytes to send
								  &pWriteIOData->jkm_dwImmediateBytesSent,	// pointer to bytes written
								  pWriteIOData->Overlap() );				// pointer to overlapped structure
	if ( fWriteFileReturn == FALSE )
	{
		DWORD	dwError;


		//
		// send didn't complete immediately, find out why
		//
		dwError = GetLastError();
		switch ( dwError )
		{
			//
			// Write is queued, no problem.  Wait for asynchronous notification.
			//
			case ERROR_IO_PENDING:
			{
				break;
			}

			//
			// Other problem, stop if not 'known' to see if there's a better
			// error return.
			//
			default:
			{
				DPFX(DPFPREP,  0, "Problem with WriteFile!" );
				DisplayErrorCode( 0, dwError );
				pWriteIOData->jkm_hSendResult = DPNERR_NOCONNECTION;
				
				switch ( dwError )
				{
					case ERROR_INVALID_HANDLE:
					{
						break;
					}

					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}

				//
				// fail the write
				//
				pWriteIOData->DataPort()->SendComplete( pWriteIOData, pWriteIOData->jkm_hSendResult );
					
				break;
			}
		}
	}
	else
	{
		//
		// Send completed immediately.  Wait for the asynchronous notification.
		//
	}

//Exit:
#ifdef WIN95
	m_pSPData->GetThreadPool()->UnlockWriteData();
#endif // WIN95
//	SendData( NULL );

	return;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CDataPort::SendComplete - send has completed
//
// Entry:		Pointer to write data
//				Send result
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::SendComplete"

void	CDataPort::SendComplete( CModemWriteIOData *const pWriteIOData, const HRESULT hSendResult )
{
	HRESULT		hr;

	
	DNASSERT( pWriteIOData != NULL );
#ifdef WIN95
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
#endif // WIN95

	switch ( pWriteIOData->m_SendCompleteAction )
	{
		case SEND_COMPLETE_ACTION_COMPLETE_COMMAND:
		{
			DPFX(DPFPREP, 8, "Data port 0x%p completing send command 0x%p, hr = 0x%lx, context = 0x%p to interface 0x%p.",
				this, pWriteIOData->m_pCommand, hSendResult,
				pWriteIOData->m_pCommand->GetUserContext(),
				m_pSPData->DP8SPCallbackInterface());
			
			hr = IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),			// pointer to callback interface
													pWriteIOData->m_pCommand,						// command handle
													hSendResult,									// error code
													pWriteIOData->m_pCommand->GetUserContext()		// user context
													);

			DPFX(DPFPREP, 8, "Data port 0x%p returning from command complete [0x%lx].", this, hr);
		
			break;
		}

		case SEND_COMPLETE_ACTION_NONE:
		{
			if (pWriteIOData->m_pCommand != NULL)
			{
				DPFX(DPFPREP, 8, "Data port 0x%p not completing send command 0x%p, hr = 0x%lx, context = 0x%p.",
					this, pWriteIOData->m_pCommand, hSendResult, pWriteIOData->m_pCommand->GetUserContext() );
			}
			else
			{
				DPFX(DPFPREP, 8, "Data port 0x%p not completing NULL send command, hr = 0x%lx",
					this, hSendResult );
			}
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	m_pSPData->GetThreadPool()->ReturnWriteIOData( pWriteIOData );
	DecRef();
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CDataPort::ProcessReceivedData - process received data
//
// Entry:		Count of bytes received
//				Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::ProcessReceivedData"

void	CDataPort::ProcessReceivedData( const DWORD dwBytesReceived, const DWORD dwError )
{
	DNASSERT( m_pActiveRead != NULL );
	DNASSERT( dwBytesReceived <= m_pActiveRead->m_dwBytesToRead );

	//
	// If this data port is not actively receiving, returnt the active read to
	// the pool.  This happens on shutdown and when the modem disconnects.
	//
	if ( GetState() != DATA_PORT_STATE_RECEIVING )
	{
		DPFX(DPFPREP, 7, "Data port 0x%p not receiving, ignoring %u bytes received and err %u.",
			this, dwBytesReceived, dwError );
		
		if ( m_pActiveRead != NULL )
		{
#ifdef WIN95
			m_pActiveRead->SetWin9xOperationPending( FALSE );
#endif // WIN95
			m_pActiveRead->DecRef();
			m_pActiveRead = NULL;
		}
		goto Exit;
	}

	switch ( dwError )
	{
		//
		// ERROR_OPERATION_ABORTED = something stopped operation, stop and look.
		//
		case ERROR_OPERATION_ABORTED:
		{
			DPFX(DPFPREP, 8, "Operation aborted, data port 0x%p, bytes received = %u.",
				this, dwBytesReceived );
			break;
		}
		
		//
		// ERROR_SUCCESS = data was received (may be 0 bytes from a timeout)
		//
		case ERROR_SUCCESS:
		{
			break;
		}

		//
		// other
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP,  0, "Failed read!" );
			DisplayErrorCode( 0, dwError );
			break;
		}
	}

	m_pActiveRead->m_dwBytesToRead -= dwBytesReceived;
	if ( m_pActiveRead->m_dwBytesToRead != 0 )
	{
		DPFX(DPFPREP, 7, "Data port 0x%p got %u bytes but there are %u bytes remaining to be read.",
			this, dwBytesReceived, m_pActiveRead->m_dwBytesToRead );
		
#ifdef WIN95
		m_pSPData->GetThreadPool()->ReinsertInReadList( m_pActiveRead );
#endif // WIN95
		Receive();
	}
	else
	{
		//
		// all data has been read, attempt to process it
		//
		switch ( m_pActiveRead->m_ReadState )
		{
			//
			// Header.  Check header integrity before proceeding.  If the header
			// is bad, attempt to find another header signature and reread.
			//
			case READ_STATE_READ_HEADER:
			{
				WORD	wCRC;
				DWORD	dwCRCSize;


				DPFX(DPFPREP, 9, "Reading header.");

				DBG_CASSERT( OFFSETOF( MESSAGE_HEADER, SerialSignature ) == 0 );
				dwCRCSize = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) - sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader.wHeaderCRC );
				wCRC = static_cast<WORD>( GenerateCRC( reinterpret_cast<BYTE*>( &m_pActiveRead->m_ReceiveBuffer.MessageHeader ), dwCRCSize ) );
				if ( ( m_pActiveRead->m_ReceiveBuffer.MessageHeader.SerialSignature != SERIAL_HEADER_START ) ||
					 ( wCRC != m_pActiveRead->m_ReceiveBuffer.MessageHeader.wHeaderCRC ) )
				{
					DWORD	dwIndex;


					DPFX(DPFPREP, 1, "Header failed signature or CRC check (%u != %u or %u != %u), searching for next header.",
						m_pActiveRead->m_ReceiveBuffer.MessageHeader.SerialSignature,
						SERIAL_HEADER_START, wCRC,
						m_pActiveRead->m_ReceiveBuffer.MessageHeader.wHeaderCRC);


					dwIndex = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader.SerialSignature );
					while ( ( dwIndex < sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) ) &&
							( m_pActiveRead->m_ReceiveBuffer.ReceivedData[ dwIndex ] != SERIAL_HEADER_START ) )
					{
						dwIndex++;
					}

					m_pActiveRead->m_dwBytesToRead = dwIndex;
					m_pActiveRead->m_dwReadOffset = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) - dwIndex;
					memcpy( &m_pActiveRead->m_ReceiveBuffer.ReceivedData,
							&m_pActiveRead->m_ReceiveBuffer.ReceivedData[ dwIndex ],
							sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) - dwIndex );
				}
				else
				{
					m_pActiveRead->SetReadState( READ_STATE_READ_DATA );
					m_pActiveRead->m_dwBytesToRead = m_pActiveRead->m_ReceiveBuffer.MessageHeader.wMessageSize;
					m_pActiveRead->m_dwReadOffset = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader );
				}
				
#ifdef WIN95
				m_pActiveRead->SetWin9xOperationPending( FALSE );
#endif // WIN95
				m_pActiveRead->jkm_dwOverlappedBytesReceived = 0;
#ifdef WIN95
				m_pSPData->GetThreadPool()->ReinsertInReadList( m_pActiveRead );
#endif // WIN95
				Receive();
				break;
			}

			//
			// Reading data.  Regardless of the validity of the data, start reading
			// another frame before processing the current data.  If the data is
			// valid, send it to a higher layer.
			//
			case READ_STATE_READ_DATA:
			{
				WORD		wCRC;
				CModemReadIOData	*pTempRead;


				pTempRead = m_pActiveRead;
				m_pActiveRead = NULL;
				Receive();


				DPFX(DPFPREP, 7, "Reading regular data.");

				DNASSERT( pTempRead->m_SPReceivedBuffer.BufferDesc.pBufferData == &pTempRead->m_ReceiveBuffer.ReceivedData[ sizeof( pTempRead->m_ReceiveBuffer.MessageHeader ) ] );
				wCRC = static_cast<WORD>( GenerateCRC( &pTempRead->m_ReceiveBuffer.ReceivedData[ sizeof( pTempRead->m_ReceiveBuffer.MessageHeader ) ],
													   pTempRead->m_ReceiveBuffer.MessageHeader.wMessageSize ) );
				if ( wCRC == pTempRead->m_ReceiveBuffer.MessageHeader.wMessageCRC )
				{
					pTempRead->m_SPReceivedBuffer.BufferDesc.dwBufferSize = pTempRead->m_ReceiveBuffer.MessageHeader.wMessageSize;
					
					Lock();
					switch ( pTempRead->m_ReceiveBuffer.MessageHeader.MessageTypeToken & ~( ENUM_RTT_MASK ) )
					{
						//
						// User data.  Send the data up the connection if there is
						// one, otherwise pass it up the listen.
						//
						case SERIAL_DATA_USER_DATA:
						{
							if ( m_hConnectEndpoint != 0 )
							{
								CModemEndpoint	*pEndpoint;


								pEndpoint = m_pSPData->EndpointFromHandle( m_hConnectEndpoint );
								Unlock();

								if ( pEndpoint != NULL )
								{
									pEndpoint->ProcessUserData( pTempRead );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								if ( m_hListenEndpoint != 0 )
								{
									CModemEndpoint	*pEndpoint;


									pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
									Unlock();

									if ( pEndpoint != NULL )
									{
										pEndpoint->ProcessUserDataOnListen( pTempRead );
										pEndpoint->DecCommandRef();
									}
								}
								else
								{
									//
									// no endpoint to handle data, drop it
									//
									Unlock();
								}
							}

							break;
						}

						//
						// Enum query.  Send it up the listen.
						//
						case SERIAL_DATA_ENUM_QUERY:
						{
							if ( m_hListenEndpoint != 0 )
							{
								CModemEndpoint	*pEndpoint;


								pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
								Unlock();

								if ( pEndpoint != NULL )
								{
									pEndpoint->ProcessEnumData( &pTempRead->m_SPReceivedBuffer,
																pTempRead->m_ReceiveBuffer.MessageHeader.MessageTypeToken & ENUM_RTT_MASK );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// no endpoint to handle data, drop it
								//
								Unlock();
							}

							break;
						}

						//
						// Enum response. Send it up the enum.
						//
						case SERIAL_DATA_ENUM_RESPONSE:
						{
							if ( m_hEnumEndpoint != 0 )
							{
								CModemEndpoint	*pEndpoint;


								pEndpoint = m_pSPData->EndpointFromHandle( m_hEnumEndpoint );
								Unlock();

								if ( pEndpoint != NULL )
								{
									pEndpoint->ProcessEnumResponseData( &pTempRead->m_SPReceivedBuffer,
																		pTempRead->m_ReceiveBuffer.MessageHeader.MessageTypeToken & ENUM_RTT_MASK );

									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// no endpoint to handle data, drop it
								//
								Unlock();
							}
							
							break;
						}

						//
						// way busted message!
						//
						default:
						{
							Unlock();
							DNASSERT( FALSE );
							break;
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "Data failed CRC check (%u != %u).",
						wCRC, pTempRead->m_ReceiveBuffer.MessageHeader.wMessageCRC);
				}

				pTempRead->DecRef();

				break;
			}

			//
			// other state
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

Exit:
	DecRef();
	return;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CDataPort::EnumAdapters - enumerate adapters
//
// Entry:		Pointer to enum adapters data
//				
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::EnumAdapters"

HRESULT	CDataPort::EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const
{
	if (m_fModem)
	{
		HRESULT			hr;
#ifndef UNICODE
		HRESULT			hTempResult;
#endif // ! UNICODE
		DWORD			dwRequiredSize;
		DWORD			dwDetectedTAPIDeviceCount;
		DWORD			dwModemNameDataSize;
		MODEM_NAME_DATA	*pModemNameData;
		UINT_PTR		uIndex;
		WCHAR			*pOutputName;
		DWORD			dwRemainingStringSize;
		DWORD			dwConvertedStringSize;


		DNASSERT( pEnumAdaptersData != NULL );
		DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) || ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );

		//
		// initialize
		//
		hr = DPN_OK;
		dwRequiredSize = 0;
		dwModemNameDataSize = 0;
		pModemNameData = NULL;
		pEnumAdaptersData->dwAdapterCount = 0;

		hr = GenerateAvailableModemList( GetSPData()->GetThreadPool()->GetTAPIInfo(),
										 &dwDetectedTAPIDeviceCount,
										 pModemNameData,
										 &dwModemNameDataSize );
		switch ( hr )
		{
			//
			// there are no modems!
			//
			case DPN_OK:
			{
				goto ExitMODEM;
				break;
			}

			//
			// buffer was too small (expected return), keep processing
			//
			case DPNERR_BUFFERTOOSMALL:
			{
				break;
			}

			//
			// other
			//
			default:
			{
				DPFX(DPFPREP,  0, "EnumAdapters: Failed to enumerate modems!" );
				DisplayDNError( 0, hr );
				goto FailureMODEM;

				break;
			}
		}

		pModemNameData = static_cast<MODEM_NAME_DATA*>( DNMalloc( dwModemNameDataSize ) );
		if ( pModemNameData == NULL )
		{
			DPFX(DPFPREP,  0, "Failed to allocate temp buffer to enumerate modems!" );
			DisplayDNError( 0, hr );
		}

		hr = GenerateAvailableModemList( GetSPData()->GetThreadPool()->GetTAPIInfo(),
										 &dwDetectedTAPIDeviceCount,
										 pModemNameData,
										 &dwModemNameDataSize );
		DNASSERT( hr == DPN_OK );

		//
		// compute required size, check for the need to add 'all adapters'
		//
		dwRequiredSize += sizeof( *pEnumAdaptersData->pAdapterData ) * dwDetectedTAPIDeviceCount;

		uIndex = dwDetectedTAPIDeviceCount;
		while ( uIndex != 0 )
		{
			uIndex--;

			//
			// account for unicode conversion
			//
			dwRequiredSize += pModemNameData[ uIndex ].dwModemNameSize * ( sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) / sizeof( *pModemNameData[ uIndex ].pModemName ) );
		}

		//
		// check required size
		//
		if ( pEnumAdaptersData->dwAdapterDataSize < dwRequiredSize )
		{
			pEnumAdaptersData->dwAdapterDataSize = dwRequiredSize;
			hr = DPNERR_BUFFERTOOSMALL;
			DPFX(DPFPREP,  0, "EnumAdapters: Insufficient buffer to enumerate adapters!" );
			goto FailureMODEM;
		}

		//
		// copy information into user buffer
		//
		DEBUG_ONLY( memset( pEnumAdaptersData->pAdapterData, 0xAA, dwRequiredSize ) );
		DBG_CASSERT( sizeof( pOutputName ) == sizeof( &pEnumAdaptersData->pAdapterData[ dwDetectedTAPIDeviceCount ] ) );
		pOutputName = reinterpret_cast<WCHAR*>( &pEnumAdaptersData->pAdapterData[ dwDetectedTAPIDeviceCount ] );

		//
		// compute number of WCHAR characters we have remaining in the buffer to output
		// devices names into
		//
		dwRemainingStringSize = dwRequiredSize;
		dwRemainingStringSize -= ( sizeof( *pEnumAdaptersData->pAdapterData ) * dwDetectedTAPIDeviceCount );
		dwRemainingStringSize /= sizeof( *pEnumAdaptersData->pAdapterData->pwszName );

		uIndex = dwDetectedTAPIDeviceCount;
		while ( uIndex > 0 )
		{
			uIndex--;

			pEnumAdaptersData->pAdapterData[ uIndex ].dwFlags = 0;
			pEnumAdaptersData->pAdapterData[ uIndex ].pwszName = pOutputName;
			pEnumAdaptersData->pAdapterData[ uIndex ].dwReserved = 0;
			pEnumAdaptersData->pAdapterData[ uIndex ].pvReserved = NULL;

			DeviceIDToGuid( &pEnumAdaptersData->pAdapterData[ uIndex ].guid,
							pModemNameData[ uIndex ].dwModemID,
							&g_ModemSPEncryptionGuid );

			dwConvertedStringSize = dwRemainingStringSize;
#ifdef UNICODE
			wcscpy(pOutputName, pModemNameData[ uIndex ].pModemName);
			dwConvertedStringSize = wcslen(pOutputName) + 1;
#else
			hTempResult = AnsiToWide( pModemNameData[ uIndex ].pModemName, -1, pOutputName, &dwConvertedStringSize );
			DNASSERT( hTempResult == DPN_OK );
			DNASSERT( dwConvertedStringSize <= dwRemainingStringSize );
#endif // UNICODE
			dwRemainingStringSize -= dwConvertedStringSize;
			pOutputName = &pOutputName[ dwConvertedStringSize ];
		}

		pEnumAdaptersData->dwAdapterCount = dwDetectedTAPIDeviceCount;
		pEnumAdaptersData->dwAdapterDataSize = dwRequiredSize;

	ExitMODEM:
		if ( pModemNameData != NULL )
		{
			DNFree( pModemNameData );
			pModemNameData = NULL;
		}
		return	hr;

	FailureMODEM:
		goto ExitMODEM;

	}
	else
	{
		HRESULT		hr;
#ifndef UNICODE
		HRESULT		hTempResult;
#endif // ! UNICODE
		BOOL		fPortAvailable[ MAX_DATA_PORTS ];
		DWORD		dwValidPortCount;
		WCHAR		*pWorkingString;
		INT_PTR		iIdx;
		INT_PTR		iOutputIdx;
		DWORD		dwRequiredDataSize = 0;
		DWORD		dwConvertedStringSize;
		DWORD		dwRemainingStringSize;


		DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
		DNASSERT( pEnumAdaptersData != NULL );
		DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) || ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );

		//
		// initialize
		//
		hr = DPN_OK;

		hr = GenerateAvailableComPortList( fPortAvailable, LENGTHOF( fPortAvailable ) - 1, &dwValidPortCount );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to generate list of available comports!" );
			DisplayDNError( 0, hr );
			goto FailureCOM;
		}

		dwRequiredDataSize = sizeof( *pEnumAdaptersData->pAdapterData ) * dwValidPortCount;

		iIdx = LENGTHOF( fPortAvailable );
		while ( iIdx > 0 )
		{
			iIdx--;

			//
			// compute exact size based on the com port number
			//
			if ( fPortAvailable[ iIdx ] != FALSE )
			{
				if ( iIdx > 100 )
				{
					dwRequiredDataSize += sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) * 7;
				}
				else
				{
					if ( iIdx > 10 )
					{
						dwRequiredDataSize += sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) * 6;
					}
					else
					{
						dwRequiredDataSize += sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) * 5;
					}
				}
			}
		}

		if ( pEnumAdaptersData->dwAdapterDataSize < dwRequiredDataSize )
		{
			hr = DPNERR_BUFFERTOOSMALL;
			pEnumAdaptersData->dwAdapterDataSize = dwRequiredDataSize;
			DPFX(DPFPREP,  8, "Buffer too small when enumerating comport adapters!" );
			goto ExitCOM;
		}

		//
		// if there are no adapters, bail
		//
		if ( dwValidPortCount == 0 )
		{
			// debug me!
			DNASSERT( FALSE );
			DNASSERT( dwRequiredDataSize == 0 );
			DNASSERT( pEnumAdaptersData->dwAdapterCount == 0 );
			goto ExitCOM;
		}

		DNASSERT( dwValidPortCount >= 1 );
		dwRemainingStringSize = ( dwRequiredDataSize - ( ( sizeof( *pEnumAdaptersData->pAdapterData ) ) * dwValidPortCount ) ) / sizeof( *pEnumAdaptersData->pAdapterData->pwszName );

		//
		// we've got enough space, start building structures
		//
		DEBUG_ONLY( memset( pEnumAdaptersData->pAdapterData, 0xAA, dwRequiredDataSize ) );
		pEnumAdaptersData->dwAdapterCount = dwValidPortCount;

		DBG_CASSERT( sizeof( &pEnumAdaptersData->pAdapterData[ dwValidPortCount ] ) == sizeof( WCHAR* ) );
		pWorkingString = reinterpret_cast<WCHAR*>( &pEnumAdaptersData->pAdapterData[ dwValidPortCount ] );

		iIdx = 1;
		iOutputIdx = 0;
		while ( iIdx < MAX_DATA_PORTS )
		{
			//
			// convert to guid if it's valid
			//
			if ( fPortAvailable[ iIdx ] != FALSE )
			{
				TCHAR	TempBuffer[ (COM_PORT_STRING_LENGTH + 1) ];


				//
				// convert device ID to a string and check for local buffer overrun
				//
				DEBUG_ONLY( TempBuffer[ LENGTHOF( TempBuffer ) - 1 ] = 0x5a );

				ComDeviceIDToString( TempBuffer, iIdx );
				DEBUG_ONLY( DNASSERT( TempBuffer[ LENGTHOF( TempBuffer ) - 1 ] == 0x5a ) );

#ifdef UNICODE
				dwConvertedStringSize = lstrlen(TempBuffer) + 1;
				lstrcpy(pWorkingString, TempBuffer);
#else
				dwConvertedStringSize = dwRemainingStringSize;
				hTempResult = AnsiToWide( TempBuffer, -1, pWorkingString, &dwConvertedStringSize );
				DNASSERT( hTempResult == DPN_OK );
#endif // UNICODE
				DNASSERT( dwRemainingStringSize >= dwConvertedStringSize );
				dwRemainingStringSize -= dwConvertedStringSize;

				pEnumAdaptersData->pAdapterData[ iOutputIdx ].dwFlags = 0;
				pEnumAdaptersData->pAdapterData[ iOutputIdx ].pvReserved = NULL;
				pEnumAdaptersData->pAdapterData[ iOutputIdx ].dwReserved = NULL;
				DeviceIDToGuid( &pEnumAdaptersData->pAdapterData[ iOutputIdx ].guid, iIdx, &g_SerialSPEncryptionGuid );
				pEnumAdaptersData->pAdapterData[ iOutputIdx ].pwszName = pWorkingString;

				pWorkingString = &pWorkingString[ dwConvertedStringSize ];
				iOutputIdx++;
				DEBUG_ONLY( dwValidPortCount-- );
			}

			iIdx++;
		}

		DEBUG_ONLY( DNASSERT( dwValidPortCount == 0 ) );
		DNASSERT( dwRemainingStringSize == 0 );

	ExitCOM:
		//
		// set size of output data
		//
		pEnumAdaptersData->dwAdapterDataSize = dwRequiredDataSize;

		return	hr;

	FailureCOM:
		goto ExitCOM;
	}

}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::GetLocalAdapterDP8Address - get the IDirectPlay8 address for this
//		adapter
//
// Entry:		Adapter type
//				
// Exit:		Pointer to address (may be null)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::GetLocalAdapterDP8Address"

IDirectPlay8Address	*CDataPort::GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const
{
	IDirectPlay8Address	*pAddress;
	HRESULT	hr;


	DNASSERT ( ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER ) ||
			   ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT ) );


	//
	// initialize
	//
	pAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IDirectPlay8Address,
							   reinterpret_cast<void**>( &pAddress ), FALSE );
	if ( hr != DPN_OK )
	{
		DNASSERT( pAddress == NULL );
		DPFX(DPFPREP,  0, "GetLocalAdapterDP8Address: Failed to create Address when converting data port to address!" );
		goto Failure;
	}

	//
	// set the SP guid
	//
	hr = IDirectPlay8Address_SetSP( pAddress, &CLSID_DP8SP_MODEM );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "GetLocalAdapterDP8Address: Failed to set service provider GUID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// If this machine is in host form, return nothing because there isn't a
	// local phone number associated with this modem.  Otherwise returnt the
	// device GUID.
	//
	if ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER )
	{
		GUID	DeviceGuid;


		DeviceIDToGuid( &DeviceGuid, GetDeviceID(), &g_ModemSPEncryptionGuid );
		hr = IDirectPlay8Address_SetDevice( pAddress, &DeviceGuid );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "GetLocalAdapterDP8Address: Failed to add device GUID!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

Exit:
	return	pAddress;

Failure:
	if ( pAddress != NULL )
	{
		IDirectPlay8Address_Release( pAddress );
		pAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::BindToNetwork - bind this data port to the network
//
// Entry:		Device ID
//				Pointer to device context
//				
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::BindToNetwork"

HRESULT	CDataPort::BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext )
{
	if (m_fModem)
	{
		HRESULT			hr;
		LONG			lTapiReturn;
		const TAPI_INFO	*pTapiInfo;
		LINEEXTENSIONID	LineExtensionID;


		DNASSERT( pDeviceContext == NULL );
		DNASSERT( GetModemState() == MODEM_STATE_UNKNOWN );

		//
		// initialize
		//
		hr = DPN_OK;
		hr = SetDeviceID( dwDeviceID );
		DNASSERT( hr == DPN_OK );
		pTapiInfo = GetSPData()->GetThreadPool()->GetTAPIInfo();
		DNASSERT( pTapiInfo != NULL );
		memset( &LineExtensionID, 0x00, sizeof( LineExtensionID ) );

		//
		// grab the modem
		//
		DNASSERT( GetNegotiatedAPIVersion() == 0 );
		DPFX(DPFPREP,  5, "lineNegotiateAPIVersion" );
		lTapiReturn = p_lineNegotiateAPIVersion( pTapiInfo->hApplicationInstance,		// TAPI application instance
												 TAPIIDFromModemID( GetDeviceID() ),	// TAPI ID for modem
												 0,
												 pTapiInfo->dwVersion,					// min API version
												 &m_dwNegotiatedAPIVersion,				// negotiated version
												 &LineExtensionID						// line extension ID
												 );
		if ( lTapiReturn != LINEERR_NONE )
		{
			DPFX(DPFPREP,  0, "Failed to negotiate modem version!" );
			DisplayTAPIError( 0, lTapiReturn );
			hr = DPNERR_NOCONNECTION;
			goto FailureMODEM;
		}
		DNASSERT( GetNegotiatedAPIVersion() != 0 );

		DNASSERT( GetLineHandle() == NULL );
		DBG_CASSERT( sizeof( HANDLE ) == sizeof( DWORD_PTR ) );
		DPFX(DPFPREP,  5, "lineOpen %d", TAPIIDFromModemID( GetDeviceID() ) );
		lTapiReturn = p_lineOpen( pTapiInfo->hApplicationInstance,				// TAPI application instance
								  TAPIIDFromModemID( GetDeviceID() ),			// TAPI ID for modem
								  &m_hLine,										// pointer to line handle
								  GetNegotiatedAPIVersion(),					// API version
								  0,											// extension version (none)
								  (DWORD_PTR)( GetHandle() ),					// callback context
								  LINECALLPRIVILEGE_OWNER,						// priveleges (full ownership)
								  LINEMEDIAMODE_DATAMODEM,						// media mode
								  NULL											// call parameters (none)
								  );
		if ( lTapiReturn != LINEERR_NONE )
		{
			DPFX(DPFPREP,  0, "Failed to open modem!" );
			DisplayTAPIError( 0, lTapiReturn );

			if ( lTapiReturn == LINEERR_RESOURCEUNAVAIL )
			{
				hr = DPNERR_OUTOFMEMORY;
			}
			else
			{
				hr = DPNERR_NOCONNECTION;
			}

			goto FailureMODEM;
		}

		DPFX(DPFPREP,  5, "\nTAPI line opened: 0x%x", GetLineHandle() );

		SetModemState( MODEM_STATE_INITIALIZED );

	ExitMODEM:
		return	hr;

	FailureMODEM:
		SetDeviceID( INVALID_DEVICE_ID );
		SetNegotiatedAPIVersion( 0 );
		DNASSERT( GetLineHandle() == NULL );

		goto ExitMODEM;
	}
	else
	{
		HRESULT	hr;
		const CComPortData	*pDataPortData;

		
		DNASSERT( pDeviceContext != NULL );

		//
		// initialize
		//
		hr = DPN_OK;
		pDataPortData = static_cast<const CComPortData*>( pDeviceContext );
		m_ComPortData.Copy( pDataPortData );

		//
		// open port
		//
		DNASSERT( m_hFile == DNINVALID_HANDLE_VALUE );
		m_hFile = DNCreateFile( m_ComPortData.ComPortName(),	// comm port
							  GENERIC_READ | GENERIC_WRITE,	// read/write access
							  0,							// don't share file with others
							  NULL,							// default sercurity descriptor
							  OPEN_EXISTING,				// comm port must exist to be opened
							  FILE_FLAG_OVERLAPPED,			// use overlapped I/O
							  NULL							// no handle for template file
							  );
		if ( m_hFile == DNINVALID_HANDLE_VALUE )
		{
			DWORD	dwError;


			hr = DPNERR_NOCONNECTION;
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "CreateFile() failed!" );
			DisplayErrorCode( 0, dwError );
			goto FailureCOM;
		}

		//
		// bind to completion port for NT
		//
#ifdef WINNT
		HANDLE	hCompletionPort;

		hCompletionPort = CreateIoCompletionPort( HANDLE_FROM_DNHANDLE(m_hFile),						// current file handle
												  GetSPData()->GetThreadPool()->GetIOCompletionPort(),	// handle of completion port
												  IO_COMPLETION_KEY_IO_COMPLETE,						// completion key
												  0														// number of concurrent threads (default to number of processors)
												  );
		if ( hCompletionPort == NULL )
		{
			DWORD	dwError;


			hr = DPNERR_OUTOFMEMORY;
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Cannot bind comport to completion port!" );
			DisplayErrorCode( 0, dwError );
			goto FailureCOM;
		}
		DNASSERT( hCompletionPort == GetSPData()->GetThreadPool()->GetIOCompletionPort() );
#endif // WINNT

		//
		// set bit rate, etc.
		//
		hr = SetPortState();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Problem with SetPortState" );
			DisplayDNError( 0, hr );
			goto FailureCOM;
		}

		//
		// set general comminications paramters (timeouts, etc.)
		//
		hr = SetPortCommunicationParameters();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to set communication paramters!" );
			DisplayDNError( 0, hr );
			goto FailureCOM;
		}

		//
		// start receiving
		//
		hr = StartReceiving();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to start receiving!" );
			DisplayDNError( 0, hr );
			goto FailureCOM;
		}

	ExitCOM:
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Problem with CDataPort::Open" );
			DisplayDNError( 0, hr );
		}

		return hr;

	FailureCOM:
		if ( m_hFile != DNINVALID_HANDLE_VALUE )
		{
			DNCloseHandle( m_hFile );
			m_hFile = DNINVALID_HANDLE_VALUE;
		}
	//	Close();
		goto ExitCOM;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::UnbindFromNetwork - unbind this data port from the network
//
// Entry:		Nothing
//				
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::UnbindFromNetwork"

void	CDataPort::UnbindFromNetwork( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this);

	if (m_fModem)
	{
		if ( GetHandle() != 0 )
		{
			GetSPData()->GetThreadPool()->CloseDataPortHandle( this );
			DNASSERT( GetHandle() == 0 );
		}

		if ( GetCallHandle() != NULL )
		{
			LONG	lTapiResult;


			DPFX(DPFPREP,  5, "lineDrop: 0x%x", GetCallHandle() );
			lTapiResult = p_lineDrop( GetCallHandle(), NULL, 0 );
			if ( lTapiResult < 0 )
			{
				DPFX(DPFPREP,  0, "Problem dropping line!" );
				DisplayTAPIError( 0, lTapiResult );
			}

			DPFX(DPFPREP,  5, "lineDeallocateCall (call handle=0x%x)", GetCallHandle() );
			lTapiResult = p_lineDeallocateCall( GetCallHandle() );
			if ( lTapiResult != LINEERR_NONE )
			{
				DPFX(DPFPREP,  0, "Problem deallocating call!" );
				DisplayTAPIError( 0, lTapiResult );
			}
		}

		if ( GetLineHandle() != NULL )
		{
			LONG	lTapiResult;


			DPFX(DPFPREP,  5, "lineClose: 0x%x", GetLineHandle() );
			lTapiResult = p_lineClose( GetLineHandle() );
			if ( lTapiResult != LINEERR_NONE )
			{
				DPFX(DPFPREP,  0, "Problem closing line!" );
				DisplayTAPIError( 0, lTapiResult );
			}
		}

		SetCallHandle( NULL );

		if ( GetFileHandle() != DNINVALID_HANDLE_VALUE )
		{
			DPFX(DPFPREP,  5, "Closing file handle when unbinding from network!" );
			if ( DNCloseHandle( m_hFile ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Failed to close file handle!" );
				DisplayErrorCode( 0, dwError );

			}

			m_hFile = DNINVALID_HANDLE_VALUE;
		}

		SetActiveLineCommand( INVALID_TAPI_COMMAND );
		SetDeviceID( INVALID_DEVICE_ID );
		SetNegotiatedAPIVersion( 0 );
		SetLineHandle( NULL );
		SetModemState( MODEM_STATE_UNKNOWN );
	}
	else
	{
#ifdef WIN95
		CModemReadIOData *	pReadData;
#endif // WIN95


		DNASSERT( GetState() == DATA_PORT_STATE_UNBOUND );

		if ( GetHandle() != 0 )
		{
			GetSPData()->GetThreadPool()->CloseDataPortHandle( this );
			DNASSERT( GetHandle() == 0 );
		}

		//
		// if there's a com file, purge all communications and close it
		//
		if ( m_hFile != DNINVALID_HANDLE_VALUE )
		{
			DPFX(DPFPREP, 6, "Flushing and closing COM port file handle 0x%p.", m_hFile);
		
			//
			// wait until all writes have completed
			//
			if ( FlushFileBuffers( HANDLE_FROM_DNHANDLE(m_hFile) ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem with FlushFileBuffers() when closing com port!" );
				DisplayErrorCode( 0, dwError );
			}


			//
			// force all communication to complete
			//
			if ( PurgeComm( HANDLE_FROM_DNHANDLE(m_hFile), ( PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ) ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem with PurgeComm() when closing com port!" );
				DisplayErrorCode( 0, dwError );
			}


#ifdef WIN95
			pReadData = this->GetActiveRead();
			
			//
			// if there is a pending read, wait until it completes
			//
			
			if ( pReadData != NULL )
			{
				//
				// pull it out of the list so the regular receive thread doesn't catch the completion
				//
				GetSPData()->GetThreadPool()->LockReadData();
				pReadData->m_OutstandingReadListLinkage.RemoveFromList();
				GetSPData()->GetThreadPool()->UnlockReadData();


				if ( pReadData->Win9xOperationPending() != FALSE )
				{
					DWORD	dwAttempt;


					dwAttempt = 0;
					
WaitAgain:
					DPFX(DPFPREP, 1, "Checking if read 0x%p has completed.", pReadData );
					
					if ( GetOverlappedResult( HANDLE_FROM_DNHANDLE(m_hFile),
											  pReadData->Overlap(),
											  &pReadData->jkm_dwOverlappedBytesReceived,
											  FALSE
											  ) != FALSE )
					{
						DBG_CASSERT( ERROR_SUCCESS == 0 );
						pReadData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
					}
					else
					{
						DWORD	dwError;


						//
						// other error, stop if not 'known'
						//
						dwError = GetLastError();
						switch( dwError )
						{
							//
							// ERROR_IO_INCOMPLETE = treat as I/O complete.  Event isn't
							//						 signalled, but that's expected because
							//						 it's cleared before checking for I/O
							//
							case ERROR_IO_INCOMPLETE:
							{
								pReadData->jkm_dwOverlappedBytesReceived = pReadData->m_dwBytesToRead;
								pReadData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
								break;
							}

							//
							// ERROR_IO_PENDING = io still pending
							//
							case ERROR_IO_PENDING:
							{
								dwAttempt++;
								if (dwAttempt <= 6)
								{
									DPFX(DPFPREP, 1, "Read data 0x%p has not completed yet, waiting for %u ms.",
										pReadData, (dwAttempt * 100));

									SleepEx(dwAttempt, TRUE);

									goto WaitAgain;
								}
								
								DPFX(DPFPREP, 0, "Read data 0x%p still not marked as completed, ignoring.",
									pReadData);
								break;
							}

							//
							// ERROR_OPERATION_ABORTED = operation was cancelled (COM port closed)
							// ERROR_INVALID_HANDLE = operation was cancelled (COM port closed)
							//
							case ERROR_OPERATION_ABORTED:
							case ERROR_INVALID_HANDLE:
							{
								break;
							}

							default:
							{
								DisplayErrorCode( 0, dwError );
								DNASSERT( FALSE );
								break;
							}
						}

						pReadData->m_dwWin9xReceiveErrorReturn = dwError;
					}


					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
					pReadData->SetWin9xOperationPending( FALSE );

					DNASSERT( pReadData->DataPort() == this );
					this->ProcessReceivedData( pReadData->jkm_dwOverlappedBytesReceived, pReadData->m_dwWin9xReceiveErrorReturn );
				}
			}
			else
			{
				//
				// it's not pending Win9x style, ignore it and hope a receive
				// thread picked up the completion
				//
				DPFX(DPFPREP, 8, "Read data 0x%p not pending Win9x style, assuming receive thread picked up completion." );
			}
#endif // WIN95

			if ( DNCloseHandle( m_hFile ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem with CloseHandle(): 0x%x", dwError );
			}

			m_hFile = DNINVALID_HANDLE_VALUE;
		}
		
		SetLinkDirection( LINK_DIRECTION_UNKNOWN );
	}


	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::BindEndpoint - bind endpoint to this data port
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::BindEndpoint"

HRESULT	CDataPort::BindEndpoint( CModemEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	HRESULT	hr;
	IDirectPlay8Address	*pDeviceAddress;
	IDirectPlay8Address	*pHostAddress;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p, %u)", this, pEndpoint, EndpointType);

	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pDeviceAddress = NULL;
	pHostAddress = NULL;

	Lock();

	if (m_fModem)
	{
		//
		// we're only allowed one endpoint of any given type so determine which
		// type and then bind the endpoint
		//
		switch ( EndpointType )
		{
			case ENDPOINT_TYPE_ENUM:
			case ENDPOINT_TYPE_CONNECT:
			case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
			{
				CModemEndpoint		*pModemEndpoint;
				LONG			lTapiReturn;
				LINECALLPARAMS	LineCallParams;


				pModemEndpoint = static_cast<CModemEndpoint*>( pEndpoint );

				switch ( EndpointType )
				{
					//
					// reject for duplicated endpoints
					//
					case ENDPOINT_TYPE_CONNECT:
					case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
					{
						if ( m_hConnectEndpoint != 0 )
						{
							hr = DPNERR_ALREADYINITIALIZED;
							DPFX(DPFPREP,  0, "Attempted to bind connect endpoint when one already exists.!" );
							goto Failure;
						}

						m_hConnectEndpoint = pEndpoint->GetHandle();

						if ( EndpointType == ENDPOINT_TYPE_CONNECT )
						{
							SPIE_CONNECTADDRESSINFO	ConnectAddressInfo;
							HRESULT	hTempResult;


							//
							// set addresses in addressing information
							//
							pDeviceAddress = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
							pHostAddress = pEndpoint->GetRemoteHostDP8Address();

							memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
							ConnectAddressInfo.pDeviceAddress = pDeviceAddress;
							ConnectAddressInfo.pHostAddress = pHostAddress;
							ConnectAddressInfo.hCommandStatus = DPN_OK;
							ConnectAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();	

							if ( ( ConnectAddressInfo.pDeviceAddress == NULL ) ||
								 ( ConnectAddressInfo.pHostAddress == NULL ) )
							{
								DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial connect addressing!" );
								hr = DPNERR_OUTOFMEMORY;
								goto Failure;
							}

							hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
																		SPEV_CONNECTADDRESSINFO,				// event type
																		&ConnectAddressInfo						// pointer to data
																		);
							DNASSERT( hTempResult == DPN_OK );
						}

						break;
					}

					case ENDPOINT_TYPE_ENUM:
					{
						SPIE_ENUMADDRESSINFO	EnumAddressInfo;
						HRESULT	hTempResult;


						if ( m_hEnumEndpoint != 0 )
						{
							hr = DPNERR_ALREADYINITIALIZED;
							DPFX(DPFPREP,  0, "Attempted to bind enum endpoint when one already exists!" );
							goto Failure;
						}

						m_hEnumEndpoint = pEndpoint->GetHandle();

						//
						// indicate addressing to a higher layer
						//
						pDeviceAddress = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
						pHostAddress = pEndpoint->GetRemoteHostDP8Address();

						memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );
						EnumAddressInfo.pDeviceAddress = pDeviceAddress;
						EnumAddressInfo.pHostAddress = pHostAddress;
						EnumAddressInfo.hCommandStatus = DPN_OK;
						EnumAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

						if ( ( EnumAddressInfo.pDeviceAddress == NULL ) ||
							 ( EnumAddressInfo.pHostAddress == NULL ) )
						{
							DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial enum addressing!" );
							hr = DPNERR_OUTOFMEMORY;
							goto Failure;
						}

						hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),
																	SPEV_ENUMADDRESSINFO,
																	&EnumAddressInfo
																	);
						DNASSERT( hTempResult == DPN_OK );

						break;
					}

					//
					// shouldn't be here
					//
					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}

				//
				// an outgoing endpoint was bound, attempt the outgoing
				// connection.  If it fails make sure that the above binding is
				// undone.
				//
				switch ( GetModemState() )
				{
					case MODEM_STATE_OUTGOING_CONNECTED:
					case MODEM_STATE_INCOMING_CONNECTED:
					{
						break;
					}

					case MODEM_STATE_INITIALIZED:
					{
						DNASSERT( GetCallHandle() == NULL );
						memset( &LineCallParams, 0x00, sizeof( LineCallParams ) );
						LineCallParams.dwTotalSize = sizeof( LineCallParams );
						LineCallParams.dwBearerMode = LINEBEARERMODE_VOICE;
						LineCallParams.dwMediaMode = LINEMEDIAMODE_DATAMODEM;

						DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );
						DPFX(DPFPREP,  5, "lineMakeCall" );
						lTapiReturn = p_lineMakeCall( GetLineHandle(),						// line handle
													  &m_hCall,								// pointer to call destination
													  pModemEndpoint->GetPhoneNumber(),		// destination address (phone number)
													  0,									// country code (default)
													  &LineCallParams						// pointer to call params
													  );
						if ( lTapiReturn > 0 )
						{
							DPFX(DPFPREP,  5, "TAPI making call (handle=0x%x), command ID: %d", GetCallHandle(), lTapiReturn );
							SetModemState( MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT );
							SetActiveLineCommand( lTapiReturn );
						}
						else
						{
							DPFX(DPFPREP,  0, "Problem with lineMakeCall" );
							DisplayTAPIError( 0, lTapiReturn );
							hr = DPNERR_NOCONNECTION;

							switch ( EndpointType )
							{
								case ENDPOINT_TYPE_CONNECT:
								case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
								{
									DNASSERT( m_hConnectEndpoint != 0 );
									m_hConnectEndpoint = 0;
									break;
								}

								case ENDPOINT_TYPE_ENUM:
								{
									DNASSERT( m_hEnumEndpoint != 0 );
									m_hEnumEndpoint = 0;
									break;
								}

								default:
								{
									DNASSERT( FALSE );
									break;
								}
							}

							goto Failure;
						}

						break;
					}

					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}

				break;
			}

			case ENDPOINT_TYPE_LISTEN:
			{
				SPIE_LISTENADDRESSINFO	ListenAddressInfo;
				HRESULT	hTempResult;


				if ( ( GetModemState() == MODEM_STATE_CLOSING_INCOMING_CONNECTION ) ||
					 ( m_hListenEndpoint != 0 ) )
				{
					hr = DPNERR_ALREADYINITIALIZED;
					DPFX(DPFPREP,  0, "Attempted to bind listen endpoint when one already exists!" );
					goto Failure;
				}

				m_hListenEndpoint = pEndpoint->GetHandle();
				//
				// set addressing information
				//
				pDeviceAddress = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
				DNASSERT( pHostAddress == NULL );

				memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
				ListenAddressInfo.pDeviceAddress = pDeviceAddress;
				ListenAddressInfo.hCommandStatus = DPN_OK;
				ListenAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

				if ( ListenAddressInfo.pDeviceAddress == NULL )
				{
					DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial listen addressing!" );
					hr = DPNERR_OUTOFMEMORY;
					goto Failure;
				}

				hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
															SPEV_LISTENADDRESSINFO,					// event type
															&ListenAddressInfo						// pointer to data
															);
				DNASSERT( hTempResult == DPN_OK );

				break;
			}

			//
			// invalid case, we should never be here
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}

		//
		// add these references before the lock is released to prevent them from
		// being immediately cleaned
		//
		pEndpoint->SetDataPort( this );
		pEndpoint->AddRef();

		if ( ( GetModemState() == MODEM_STATE_OUTGOING_CONNECTED ) &&
			 ( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
			   ( EndpointType == ENDPOINT_TYPE_ENUM ) ) )
		{
			pEndpoint->OutgoingConnectionEstablished( DPN_OK );
		}
	}
	else
	{
		//
		// we're only allowed one endpoint of any given type so determine which
		// type end then bind the endpoint
		//
		switch ( EndpointType )
		{
			case ENDPOINT_TYPE_CONNECT:
			case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
			{
				if ( m_hConnectEndpoint != 0 )
				{
					hr = DPNERR_ALREADYINITIALIZED;
					DPFX(DPFPREP,  0, "Attempted to bind connect endpoint when one already exists!" );
					goto Failure;
				}

				m_hConnectEndpoint = pEndpoint->GetHandle();
				
				if ( EndpointType == ENDPOINT_TYPE_CONNECT )
				{
					SPIE_CONNECTADDRESSINFO	ConnectAddressInfo;
					HRESULT	hTempResult;
					
					
					//
					// set addresses in addressing information
					//
					pDeviceAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_LOCAL_ADAPTER );
					pHostAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_REMOTE_HOST );

					memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
					ConnectAddressInfo.pDeviceAddress = pDeviceAddress;
					ConnectAddressInfo.pHostAddress = pHostAddress;
					ConnectAddressInfo.hCommandStatus = DPN_OK;
					ConnectAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();	

					if ( ( ConnectAddressInfo.pDeviceAddress == NULL ) ||
						 ( ConnectAddressInfo.pHostAddress == NULL ) )
					{
						DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial connect addressing!" );
						hr = DPNERR_OUTOFMEMORY;
						goto Failure;
					}

					hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
																SPEV_CONNECTADDRESSINFO,				// event type
																&ConnectAddressInfo						// pointer to data
																);
					DNASSERT( hTempResult == DPN_OK );
				}

				break;
			}

			case ENDPOINT_TYPE_LISTEN:
			{
				SPIE_LISTENADDRESSINFO	ListenAddressInfo;
				HRESULT	hTempResult;


				if ( m_hListenEndpoint != 0 )
				{
					hr = DPNERR_ALREADYINITIALIZED;
					DPFX(DPFPREP,  0, "Attempted to bind listen endpoint when one already exists!" );
					goto Failure;
				}
				m_hListenEndpoint = pEndpoint->GetHandle();
				
				//
				// set addressing information
				//
				pDeviceAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_LOCAL_ADAPTER );
				DNASSERT( pHostAddress == NULL );

				memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
				ListenAddressInfo.pDeviceAddress = pDeviceAddress;
				ListenAddressInfo.hCommandStatus = DPN_OK;
				ListenAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

				if ( ListenAddressInfo.pDeviceAddress == NULL )
				{
					DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial listen addressing!" );
					hr = DPNERR_OUTOFMEMORY;
					goto Failure;
				}

				hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
															SPEV_LISTENADDRESSINFO,					// event type
															&ListenAddressInfo						// pointer to data
															);
				DNASSERT( hTempResult == DPN_OK );

				break;
			}

			case ENDPOINT_TYPE_ENUM:
			{
				SPIE_ENUMADDRESSINFO	EnumAddressInfo;
				HRESULT	hTempResult;

				
				if ( m_hEnumEndpoint != 0 )
				{
					hr = DPNERR_ALREADYINITIALIZED;
					DPFX(DPFPREP,  0, "Attempted to bind enum endpoint when one already exists!" );
					goto Exit;
				}
				m_hEnumEndpoint = pEndpoint->GetHandle();
				
				//
				// indicate addressing to a higher layer
				//
				pDeviceAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_LOCAL_ADAPTER );
				pHostAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_REMOTE_HOST );
				
				memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );
				EnumAddressInfo.pDeviceAddress = pDeviceAddress;
				EnumAddressInfo.pHostAddress = pHostAddress;
				EnumAddressInfo.hCommandStatus = DPN_OK;
				EnumAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

				if ( ( EnumAddressInfo.pDeviceAddress == NULL ) ||
					 ( EnumAddressInfo.pHostAddress == NULL ) )
				{
					DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial enum addressing!" );
					hr = DPNERR_OUTOFMEMORY;
					goto Failure;
				}

				hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),
															SPEV_ENUMADDRESSINFO,
															&EnumAddressInfo
															);
				DNASSERT( hTempResult == DPN_OK );
				
				break;
			}

			//
			// invalid case, we should never be here
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}

		//
		// add these references before the lock is released to prevent them from
		// being immediately cleaned
		//
		pEndpoint->SetDataPort( this );
		pEndpoint->AddRef();
		
		//
		// if this was a connect or enum, indicate that the outgoing connection is
		// ready.
		//
		if ( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
			 ( EndpointType == ENDPOINT_TYPE_ENUM ) )
		{
			pEndpoint->OutgoingConnectionEstablished( DPN_OK );
		}

	}
	Unlock();


Exit:
	if ( pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( pHostAddress );
		pHostAddress = NULL;
	}

	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}


	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;

Failure:
	Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::UnbindEndpoint - unbind endpoint from this data port
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::UnbindEndpoint"

void	CDataPort::UnbindEndpoint( CModemEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	DNASSERT( pEndpoint != NULL );

	Lock();

	DNASSERT( pEndpoint->GetDataPort() == this );
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		case ENDPOINT_TYPE_CONNECT:
		{
			DNASSERT( m_hConnectEndpoint != 0 );
			m_hConnectEndpoint = 0;
			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( m_hListenEndpoint != 0 );
			m_hListenEndpoint = 0;
			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( m_hEnumEndpoint != 0 );
			m_hEnumEndpoint = 0;
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Unlock();

	pEndpoint->SetDataPort( NULL );
	pEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::BindComPort - bind com port to network
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::BindComPort"

HRESULT	CDataPort::BindComPort( void )
{
	HRESULT		hr;
	VARSTRING	*pTempInfo;
	LONG		lTapiError;
	DWORD		dwSizeNeeded;


	//
	// In the case of host migration, there is an outstanding read pending that
	// needs to be cleaned up.  Unfortunately, there is no mechanism in Win32
	// to cancel just this little I/O operation.  Release the read ref count on
	// this CDataPort and reissue the read.....
	//
	if ( GetActiveRead() != NULL )
	{
#ifdef WIN95
		GetActiveRead()->SetWin9xOperationPending( FALSE );
#endif // WIN95
		DecRef();
	}

	//
	// initialize
	//
	hr = DPN_OK;
	pTempInfo = NULL;

	//
	// get file handle for modem device
	//
	pTempInfo = static_cast<VARSTRING*>( DNMalloc( sizeof( *pTempInfo ) ) );
	if ( pTempInfo == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Out of memory allocating for lineGetID!" );
		goto Failure;
	}

	pTempInfo->dwTotalSize = sizeof( *pTempInfo );
	pTempInfo->dwNeededSize = pTempInfo->dwTotalSize;
	pTempInfo->dwStringFormat = STRINGFORMAT_BINARY;
	lTapiError = LINEERR_STRUCTURETOOSMALL;
	while ( lTapiError == LINEERR_STRUCTURETOOSMALL )
	{
		DNASSERT( pTempInfo != NULL );

		dwSizeNeeded = pTempInfo->dwNeededSize;

		DNFree( pTempInfo );
		pTempInfo = static_cast<VARSTRING*>( DNMalloc( dwSizeNeeded ) );
		if ( pTempInfo == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Out of memory reallocating for lineGetID!" );
			goto Failure;
		}
		pTempInfo->dwTotalSize = dwSizeNeeded;

		DPFX(DPFPREP,  5, "lineGetID (call handle=0x%x)", GetCallHandle() );
		lTapiError = p_lineGetID( NULL,						// line handle
								  0,						// address ID
								  m_hCall,					// call handle
								  LINECALLSELECT_CALL,		// use call handle
								  pTempInfo,				// pointer to variable information
								  TEXT("comm/datamodem")	// request comm/modem ID information
								  );

		if ( ( lTapiError == LINEERR_NONE ) &&
			 ( pTempInfo->dwTotalSize < pTempInfo->dwNeededSize ) )
		{
			lTapiError = LINEERR_STRUCTURETOOSMALL;
		}
	}

	if ( lTapiError != LINEERR_NONE )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem with lineGetID" );
		DisplayTAPIError( 0, lTapiError );
		goto Failure;
	}

	DNASSERT( pTempInfo->dwStringSize != 0 );
	DNASSERT( pTempInfo->dwStringFormat == STRINGFORMAT_BINARY );
	m_hFile = MAKE_DNHANDLE(*( (HANDLE*) ( ( (BYTE*) pTempInfo ) + pTempInfo->dwStringOffset ) ));
	if ( m_hFile == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "problem getting Com file handle!" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = SetPortCommunicationParameters();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to set communication parameters!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// bind to completion port for NT
	//
#ifdef WINNT
	HANDLE	hCompletionPort;


	hCompletionPort = CreateIoCompletionPort( HANDLE_FROM_DNHANDLE(m_hFile),						// current file handle
											  GetSPData()->GetThreadPool()->GetIOCompletionPort(),	// handle of completion port
											  IO_COMPLETION_KEY_IO_COMPLETE,						// completion key
											  0					    								// number of concurrent threads (default to number of processors)
											  );
	if ( hCompletionPort == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot bind comport to completion port!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}
#endif // WINNT

	hr = StartReceiving();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start receiving!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pTempInfo != NULL )
	{
		DNFree( pTempInfo );
		pTempInfo = NULL;
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::ProcessTAPIMessage - process a TAPI message
//
// Entry:		Pointer to message information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::ProcessTAPIMessage"

void	CDataPort::ProcessTAPIMessage( const LINEMESSAGE *const pLineMessage )
{
	DPFX(DPFPREP, 1, "(0x%p) Processing TAPI message %u:", this, pLineMessage->dwMessageID );
	DisplayTAPIMessage( 1, pLineMessage );

	Lock();

	switch ( pLineMessage->dwMessageID )
	{
		//
		// call information about the specified call has changed
		//
		case LINE_CALLINFO:
		{
			DPFX(DPFPREP, 3, "Call info type 0x%lx changed, ignoring.",
				pLineMessage->dwParam1);
			break;
		}
		
		//
		// command reply
		//
		case LINE_REPLY:
		{
			DNASSERT( pLineMessage->hDevice == 0 );
			SetActiveLineCommand( INVALID_TAPI_COMMAND );

			//
			// Can't ASSERT that there's a call handle because the command
			// may have failed and been cleaned up from the NT completion
			// port, just ASSERT our state.  Can't ASSERT modem state because
			// TAPI events may race off the completion port on NT.  Can't ASSERT
			// command because it may have already been cleaned.
			//

			break;
		}

		//
		// new call, make sure we're listening for a call and that there's an
		// active 'listen' before accepting.
		//	
		case LINE_APPNEWCALL:
		{
			DNASSERT( GetCallHandle() == NULL );

			DBG_CASSERT( sizeof( m_hLine ) == sizeof( pLineMessage->hDevice ) );
			DNASSERT( GetLineHandle() == pLineMessage->hDevice );
			DNASSERT( pLineMessage->dwParam3 == LINECALLPRIVILEGE_OWNER );

			if ( m_hListenEndpoint != 0 )
			{
				LONG	lTapiReturn;


				DPFX(DPFPREP,  5, "lineAnswer (call handle=0x%x)", pLineMessage->dwParam2 );
				lTapiReturn = p_lineAnswer( static_cast<HCALL>( pLineMessage->dwParam2 ),		// call to be answered
											NULL,						// user information to be sent to remote party (none)
											0							// size of user data to send
											);
				if ( lTapiReturn > 0 )
				{
					DPFX(DPFPREP,  8, "Accepted call, id: %d", lTapiReturn );
					SetCallHandle( static_cast<HCALL>( pLineMessage->dwParam2 ) );
					SetModemState( MODEM_STATE_WAITING_FOR_INCOMING_CONNECT );
					SetActiveLineCommand( lTapiReturn );
				}
				else
				{
					DPFX(DPFPREP,  0, "Failed to answer call!" );
					DisplayTAPIError( 0, lTapiReturn );
				}
			}

			break;
		}

		//
		// call state
		//
		case LINE_CALLSTATE:
		{
			//
			// if there's state information, make sure we own the call
			//
			DNASSERT( ( pLineMessage->dwParam3 == 0 ) ||
					  ( pLineMessage->dwParam3 == LINECALLPRIVILEGE_OWNER ) );

			//
			// validate input, but note that  it's possible that TAPI messages got processed
			// out of order so we might not have seen a call handle yet
			//
			DBG_CASSERT( sizeof( m_hCall ) == sizeof( pLineMessage->hDevice ) );
			DNASSERT( ( m_hCall == pLineMessage->hDevice ) || ( m_hCall == NULL ) );

			//
			// what's the sub-state?
			//
			switch ( pLineMessage->dwParam1 )
			{
				//
				// modem has connected
				//	
				case LINECALLSTATE_CONNECTED:
				{
					DNASSERT( ( pLineMessage->dwParam2 == 0 ) ||
							  ( pLineMessage->dwParam2 == LINECONNECTEDMODE_ACTIVE ) );

					DNASSERT( ( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) ||
							  ( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT ) );

					if ( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT )
					{
						HRESULT	hr;


						hr = BindComPort();
						if ( hr != DPN_OK )
						{
							DPFX(DPFPREP,  0, "Failed to bind modem communication port!" );
							DisplayDNError( 0, hr );
							DNASSERT( FALSE );
						}

						SetModemState( MODEM_STATE_OUTGOING_CONNECTED );

						if ( m_hConnectEndpoint != 0 )
						{
							CModemEndpoint	*pEndpoint;


							pEndpoint = GetSPData()->EndpointFromHandle( m_hConnectEndpoint );
							if ( pEndpoint != NULL )
							{
								pEndpoint->OutgoingConnectionEstablished( DPN_OK );
								pEndpoint->DecCommandRef();
							}
						}

						if ( m_hEnumEndpoint != 0 )
						{
							CModemEndpoint	*pEndpoint;


							pEndpoint = GetSPData()->EndpointFromHandle( m_hEnumEndpoint );
							if ( pEndpoint != NULL )
							{
								pEndpoint->OutgoingConnectionEstablished( DPN_OK );
								pEndpoint->DecCommandRef();
							}
						}
					}
					else
					{
						HRESULT	hr;


						hr = BindComPort();
						if ( hr != DPN_OK )
						{
							DPFX(DPFPREP,  0, "Failed to bind modem communication port!" );
							DisplayDNError( 0, hr );
							DNASSERT( FALSE );
						}

						SetModemState( MODEM_STATE_INCOMING_CONNECTED );
					}

					break;
				}

				//
				// modems disconnected
				//
				case LINECALLSTATE_DISCONNECTED:
				{
					LONG	lTapiReturn;


					switch( pLineMessage->dwParam2 )
					{
						case LINEDISCONNECTMODE_NORMAL:
						case LINEDISCONNECTMODE_BUSY:
						case LINEDISCONNECTMODE_NOANSWER:
						case LINEDISCONNECTMODE_NODIALTONE:
						case LINEDISCONNECTMODE_UNAVAIL:
						{
							break;
						}

						//
						// stop and look
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					CancelOutgoingConnections();

					//
					// reset modem port to initialized state and indicate that
					// it is no longer receiving data
					//
					SetModemState( MODEM_STATE_INITIALIZED );

					DPFX(DPFPREP,  5, "Closing file handle on DISCONNECT notification." );
					if ( DNCloseHandle( GetFileHandle() ) == FALSE )
					{
						DWORD	dwError;


						dwError = GetLastError();
						DPFX(DPFPREP,  0, "Problem closing file handle when restarting modem on host!" );
						DisplayErrorCode( 0, dwError );
					}
					m_hFile = DNINVALID_HANDLE_VALUE;
					SetActiveLineCommand( INVALID_TAPI_COMMAND );

					//
					// if there is an active listen, release this call so TAPI
					// can indicate future incoming calls.
					//
					if ( m_hListenEndpoint != 0 )
    				{
						SetState( DATA_PORT_STATE_INITIALIZED );

						DPFX(DPFPREP,  5, "lineDeallocateCall listen (call handle=0x%x)", GetCallHandle() );
						lTapiReturn = p_lineDeallocateCall( GetCallHandle() );
						if ( lTapiReturn != LINEERR_NONE )
						{
							DPFX(DPFPREP,  0, "Failed to release call (listen)!" );
							DisplayTAPIError( 0, lTapiReturn );
							DNASSERT( FALSE );
						}
						SetCallHandle( NULL );

						DNASSERT( GetFileHandle() == DNINVALID_HANDLE_VALUE );
					}
					else
					{
						//
						// Deallocate the call if there is one..
						//
						if (GetCallHandle() != NULL)
						{
							DNASSERT(( m_hEnumEndpoint != 0 ) || ( m_hConnectEndpoint != 0 ));
							
							DPFX(DPFPREP,  5, "lineDeallocateCall non-listen (call handle=0x%x)", GetCallHandle() );
							lTapiReturn = p_lineDeallocateCall( GetCallHandle() );
							if ( lTapiReturn != LINEERR_NONE )
							{
								DPFX(DPFPREP,  0, "Failed to release call (non-listen)!" );
								DisplayTAPIError( 0, lTapiReturn );
								DNASSERT( FALSE );
							}
							SetCallHandle( NULL );
						}
						else
						{
							DPFX(DPFPREP,  5, "No call handle." );
							DNASSERT( m_hEnumEndpoint == 0 );
							DNASSERT( m_hConnectEndpoint == 0 );
						}
						SetModemState( MODEM_STATE_UNKNOWN );
					}

					break;
				}

				//
				// call is officially ours.  Can't ASSERT any state here because
				// messages might have been reversed by the NT completion threads
				// so LINE_APPNEWCALL may not yet have been processed.  It's also
				// possible that we're in disconnect cleanup as someone is calling
				// and LINECALLSTATE_OFFERING is coming in before LINE_APPNEWCALL.
				//
				case LINECALLSTATE_OFFERING:
				{
					break;
				}

				//
				// call has been accepted, waiting for modems to connect
				//
				case LINECALLSTATE_ACCEPTED:
				{
					DNASSERT( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT );
					break;
				}

				//
				// we're dialing
				//
				case LINECALLSTATE_DIALING:
				case LINECALLSTATE_DIALTONE:
				{
					DNASSERT( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT );
					break;
				}

				//
				// we're done dialing, waiting for modems to connect
				//
				case LINECALLSTATE_PROCEEDING:
				{
					DNASSERT( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT );
					break;
				}

				//
				// line is idle, most likely from a modem hanging up during negotiation
				//
				case LINECALLSTATE_IDLE:
				{
					break;
				}

				//
				// other state, stop and look
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// TAPI line was closed
		//
		case LINE_CLOSE:
		{
			CancelOutgoingConnections();
			break;
		}

		//
		// unhandled message
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Unlock();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::CancelOutgoingConnections - cancel any outgoing connection attempts
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::CancelOutgoingConnections"

void	CDataPort::CancelOutgoingConnections( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this );

	
	//
	// if there is an outstanding enum, stop it
	//
	if ( m_hEnumEndpoint != 0 )
	{
		CModemEndpoint	*pEndpoint;


		pEndpoint = GetSPData()->EndpointFromHandle( m_hEnumEndpoint );
		if ( pEndpoint != NULL )
		{
			CModemCommandData	*pCommandData;


			pCommandData = pEndpoint->GetCommandData();
			pCommandData->Lock();
			if ( pCommandData->GetState() != COMMAND_STATE_INPROGRESS )
			{
				DNASSERT( pCommandData->GetState() == COMMAND_STATE_CANCELLING );
				pCommandData->Unlock();
			}
			else
			{
				pCommandData->SetState( COMMAND_STATE_CANCELLING );
				pCommandData->Unlock();

				pEndpoint->Lock();
				pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
				pEndpoint->Unlock();

				pEndpoint->StopEnumCommand( DPNERR_NOCONNECTION );
			}

			pEndpoint->DecCommandRef();
		}
	}

	//
	// if there is an outstanding connect, disconnect it
	//
	if ( m_hConnectEndpoint != 0 )
	{
		CModemEndpoint	*pEndpoint;
		DPNHANDLE	hOldHandleValue;


		hOldHandleValue = m_hConnectEndpoint;
		pEndpoint = GetSPData()->GetEndpointAndCloseHandle( hOldHandleValue );
		if ( pEndpoint != NULL )
		{
			HRESULT	hTempResult;


			hTempResult = pEndpoint->Disconnect( hOldHandleValue );
			pEndpoint->DecRef();
		}
	}

	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::PoolAllocFunction - called when new pool item is allocated
//
// Entry:		Pointer to context
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::PoolAllocFunction"

BOOL	CDataPort::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CDataPort* pDataPort = (CDataPort*)pvItem;
	DATA_PORT_POOL_CONTEXT* pDataPortContext = (DATA_PORT_POOL_CONTEXT*)pvContext;

	DNASSERT( pDataPortContext != NULL );
	pDataPort->m_fModem = (pDataPortContext->pSPData->GetType() == TYPE_MODEM);

	pDataPort->m_ModemState = MODEM_STATE_UNKNOWN;
	pDataPort->m_dwDeviceID = INVALID_DEVICE_ID;
	pDataPort->m_dwNegotiatedAPIVersion = 0;
	pDataPort->m_hLine = NULL;
	pDataPort->m_hCall = NULL;
	pDataPort->m_lActiveLineCommand = INVALID_TAPI_COMMAND;

	// Initialize Base Class members
	pDataPort->m_EndpointRefCount = 0;
	pDataPort->m_State = DATA_PORT_STATE_UNKNOWN;
	pDataPort->m_Handle = 0;
	pDataPort->m_pSPData = NULL;
	pDataPort->m_pActiveRead = NULL;
	pDataPort->m_LinkDirection = LINK_DIRECTION_UNKNOWN;
	pDataPort->m_hFile = DNINVALID_HANDLE_VALUE;
	pDataPort->m_hListenEndpoint = 0;
	pDataPort->m_hConnectEndpoint = 0;
	pDataPort->m_hEnumEndpoint = 0;
	pDataPort->m_iRefCount = 0;

	pDataPort->m_ActiveListLinkage.Initialize();
	
	DEBUG_ONLY( pDataPort->m_fInitialized = FALSE );

	//
	// Attempt to create critical section, recursion count needs to be non-zero
	// to handle endpoint cleanup when a modem operation fails.
	//
	if ( DNInitializeCriticalSection( &pDataPort->m_Lock ) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialized critical section on DataPort!" );
		return FALSE;
	}
	DebugSetCriticalSectionRecursionCount( &pDataPort->m_Lock, 1 );
	DebugSetCriticalSectionGroup( &pDataPort->m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes

	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::PoolInitFunction - called when new pool item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::PoolInitFunction"

void	CDataPort::PoolInitFunction( void* pvItem, void* pvContext )
{
	CDataPort* pDataPort = (CDataPort*)pvItem;
	DATA_PORT_POOL_CONTEXT* pDataPortContext = (DATA_PORT_POOL_CONTEXT*)pvContext;

#ifdef DBG
	DNASSERT( pDataPortContext != NULL );
	DNASSERT( pDataPort->GetActiveRead() == NULL );
	DNASSERT( pDataPort->GetHandle() == 0 );

	DNASSERT( pDataPortContext->pSPData != NULL );
	DNASSERT( pDataPort->m_fInitialized == FALSE );
	DNASSERT( pDataPort->m_pSPData == NULL );
#endif // DBG

	pDataPort->m_pSPData = pDataPortContext->pSPData;

	DNASSERT( pDataPort->m_ActiveListLinkage.IsEmpty() );
	
	DNASSERT( pDataPort->m_hListenEndpoint == 0 );
	DNASSERT( pDataPort->m_hConnectEndpoint == 0 );
	DNASSERT( pDataPort->m_hEnumEndpoint == 0 );

	pDataPort->SetState( DATA_PORT_STATE_INITIALIZED );
	DEBUG_ONLY( pDataPort->m_fInitialized = TRUE );

	DNASSERT(pDataPort->m_iRefCount == 0);
	pDataPort->m_iRefCount = 1;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::PoolReleaseFunction - called when new pool item is returned to  pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::PoolReleaseFunction"

void	CDataPort::PoolReleaseFunction( void* pvItem )
{
	CDataPort* pDataPort = (CDataPort*)pvItem;

	pDataPort->m_pSPData = NULL;

	DNASSERT( pDataPort->m_ActiveListLinkage.IsEmpty() );
	DNASSERT( pDataPort->m_hFile == DNINVALID_HANDLE_VALUE );

	DNASSERT( pDataPort->m_hListenEndpoint == 0 );
	DNASSERT( pDataPort->m_hConnectEndpoint == 0 );
	DNASSERT( pDataPort->m_hEnumEndpoint == 0 );

	pDataPort->SetState( DATA_PORT_STATE_UNKNOWN );
	DEBUG_ONLY( pDataPort->m_fInitialized = FALSE );


	pDataPort->m_ComPortData.Reset();

	DNASSERT( pDataPort->GetActiveRead() == NULL );
	DNASSERT( pDataPort->GetHandle() == 0 );
	DNASSERT( pDataPort->GetModemState() == MODEM_STATE_UNKNOWN );
	DNASSERT( pDataPort->GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( pDataPort->GetNegotiatedAPIVersion() == 0 );
	DNASSERT( pDataPort->GetLineHandle() == NULL );
	DNASSERT( pDataPort->GetCallHandle() == NULL );
	DNASSERT( pDataPort->GetActiveLineCommand() == INVALID_TAPI_COMMAND );


	DNASSERT( pDataPort->m_EndpointRefCount == 0 );
	DNASSERT( pDataPort->GetState() == DATA_PORT_STATE_UNKNOWN );
	DNASSERT( pDataPort->GetSPData() == NULL );

	DNASSERT( pDataPort->m_ActiveListLinkage.IsEmpty() != FALSE );

	DNASSERT( pDataPort->m_LinkDirection == LINK_DIRECTION_UNKNOWN );
	DNASSERT( pDataPort->m_hFile == DNINVALID_HANDLE_VALUE );

	DNASSERT( pDataPort->m_hListenEndpoint == 0 );
	DNASSERT( pDataPort->m_hConnectEndpoint == 0 );
	DNASSERT( pDataPort->m_hEnumEndpoint == 0 );

	DNASSERT( pDataPort->m_iRefCount == 0 );

}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::PoolDeallocFunction - called when new pool item is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::PoolDeallocFunction"

void	CDataPort::PoolDeallocFunction( void* pvItem )
{
	CDataPort* pDataPort = (CDataPort*)pvItem;

	DNDeleteCriticalSection( &pDataPort->m_Lock );

	DNASSERT( pDataPort->GetModemState() == MODEM_STATE_UNKNOWN );
	DNASSERT( pDataPort->GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( pDataPort->GetNegotiatedAPIVersion() == 0 );
	DNASSERT( pDataPort->GetLineHandle() == NULL );
	DNASSERT( pDataPort->GetCallHandle() == NULL );
	DNASSERT( pDataPort->GetActiveLineCommand() == INVALID_TAPI_COMMAND );

	// Deinit Base Class members
	DEBUG_ONLY( DNASSERT( pDataPort->m_fInitialized == FALSE ) );

	DNASSERT( pDataPort->m_EndpointRefCount == 0 );
	DNASSERT( pDataPort->GetState() == DATA_PORT_STATE_UNKNOWN );
	DNASSERT( pDataPort->GetHandle() == 0 );
	DNASSERT( pDataPort->GetSPData() == NULL );
	DNASSERT( pDataPort->m_pActiveRead == NULL );

	DNASSERT( pDataPort->m_ActiveListLinkage.IsEmpty() != FALSE );

	DNASSERT( pDataPort->m_LinkDirection == LINK_DIRECTION_UNKNOWN );
	DNASSERT( pDataPort->m_hFile == DNINVALID_HANDLE_VALUE );

	DNASSERT( pDataPort->m_hListenEndpoint == 0 );
	DNASSERT( pDataPort->m_hConnectEndpoint == 0 );
	DNASSERT( pDataPort->m_hEnumEndpoint == 0 );

	DNASSERT( pDataPort->m_iRefCount == 0 );

}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CDataPort::SetPortState - set communications port state
//		description
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CDataPort::SetPortState"

HRESULT	CDataPort::SetPortState( void )
{
	DCB	Dcb;
	HRESULT	hr;


	DNASSERT( m_hFile != DNINVALID_HANDLE_VALUE );

	//
	// initialize
	//
	hr = DPN_OK;
	memset( &Dcb, 0x00, sizeof( Dcb ) );
	Dcb.DCBlength = sizeof( Dcb );

	//
	// set parameters
	//
	Dcb.BaudRate = GetBaudRate();	// current baud rate
	Dcb.fBinary = TRUE;				// binary mode, no EOF check (MUST BE TRUE FOR WIN32!)

	//
	// parity
	//
	if ( GetParity() != NOPARITY )
	{
		Dcb.fParity = TRUE;
	}
	else
	{
		Dcb.fParity = FALSE;
	}

	//
	// are we using RTS?
	//
	if ( ( GetFlowControl() == FLOW_RTS ) ||
		 ( GetFlowControl() == FLOW_RTSDTR ) )
	{
		Dcb.fOutxCtsFlow = TRUE;					// allow RTS/CTS
		Dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;	// handshake with RTS/CTS
	}
	else
	{
		Dcb.fOutxCtsFlow = FALSE;					// disable RTS/CTS
		Dcb.fRtsControl = RTS_CONTROL_ENABLE;		// always be transmit ready
	}

	//
	// are we using DTR?
	//
	if ( ( GetFlowControl() == FLOW_DTR ) ||
		 ( GetFlowControl() == FLOW_RTSDTR ) )
	{
		Dcb.fOutxDsrFlow = TRUE;					// allow DTR/DSR
		Dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;	// handshake with DTR/DSR
	}
	else
	{
		Dcb.fOutxDsrFlow = FALSE;					// disable DTR/DSR
		Dcb.fDtrControl = DTR_CONTROL_ENABLE;		// always be ready
	}


	//
	// DSR sensitivity
	//
	Dcb.fDsrSensitivity = FALSE;	// TRUE = incoming data dropped if DTR is not set

	//
	// continue sending after Xoff
	//
	Dcb.fTXContinueOnXoff= FALSE;	// TRUE = continue to send data after XOFF has been received
									// and there's room in the buffer


	//
	// are we using Xon/Xoff?
	//
	if ( GetFlowControl() == FLOW_XONXOFF )
	{
		Dcb.fOutX = TRUE;
		Dcb.fInX = TRUE;
	}
	else
	{
		// disable Xon/Xoff
		Dcb.fOutX = FALSE;
		Dcb.fInX = FALSE;
	}

	//
	// replace erroneous bytes with 'Error Byte'
	//
	Dcb.fErrorChar = FALSE;			// TRUE = replace bytes with parity errors with
									// an error character

	//
	// drop NULL characters
	//
	Dcb.fNull = FALSE;				// TRUE = remove NULLs from input stream

	//
	// stop on error
	//
	Dcb.fAbortOnError = FALSE;		// TRUE = abort reads/writes on error

	//
	// reserved, set to zero!
	//
	Dcb.fDummy2 = NULL;				// reserved

	//
	// reserved
	//
	Dcb.wReserved = NULL;			// not currently used

	//
	// buffer size before sending Xon/Xoff
	//
	Dcb.XonLim = XON_LIMIT;			// transmit XON threshold
	Dcb.XoffLim = XOFF_LIMIT;		// transmit XOFF threshold

	//
	// size of a 'byte'
	//
	Dcb.ByteSize = BITS_PER_BYTE;	// number of bits/byte, 4-8

	//
	// set parity type
	//
	DNASSERT( GetParity() < 256 );
	Dcb.Parity = static_cast<BYTE>( GetParity() );

	//
	// stop bits
	//
	DNASSERT( GetStopBits() < 256 );
	Dcb.StopBits = static_cast<BYTE>( GetStopBits() );	// 0,1,2 = 1, 1.5, 2

	//
	// Xon/Xoff characters
	//
	Dcb.XonChar = ASCII_XON;		// Tx and Rx XON character
	Dcb.XoffChar = ASCII_XOFF;		// Tx and Rx XOFF character

	//
	// error replacement character
	//
	Dcb.ErrorChar = NULL_TOKEN;		// error replacement character

	//
	// EOF character
	//
	Dcb.EofChar = NULL_TOKEN;		// end of input character

	//
	// event signal character
	//
	Dcb.EvtChar = NULL_TOKEN;		// event character

	Dcb.wReserved1 = 0;				// reserved; do not use

	//
	// set the state of the communication port
	//
	if ( SetCommState( HANDLE_FROM_DNHANDLE(m_hFile), &Dcb ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "SetCommState failed!" );
		DisplayErrorCode( 0, dwError );
		goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dnmdmi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnmdmi.h
 *  Content:    DirectPlay Modem SP master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNMODEMI_H__
#define __DNMODEMI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "classbilink.h"
#include "fixedpool.h"
#include "dneterrors.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"
#include "createin.h"
#include "HandleTable.h"
#include "ClassFactory.h"

// 
// Modem private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

#include "SerialSP.h"

#include "dpnmodemlocals.h"

#include "CommandData.h"
#include "dpnmodemiodata.h"
#include "dpnmodemjobqueue.h"
#include "dpnmodempools.h"
#include "dpnmodemsendqueue.h"
#include "dpnmodemspdata.h"
#include "dpnmodemutils.h"

#include "ComPortData.h"
#include "ComPortUI.h"

#include "DataPort.h"
#include "dpnmodemendpoint.h"

#include "dpnmodemthreadpool.h"

#include "ParseClass.h"

#include "ModemUI.h"
#include "Crc.h"


#include "Resource.h"

#include "dpnmodemextern.h"


#endif // __DNMODEMI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dataport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DataPort.h
 *  Content:	Serial communications port management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 *	09/14/99	jtk		Derived from ComPort.h
 ***************************************************************************/

#ifndef __DATA_PORT_H__
#define __DATA_PORT_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of phone state
//
typedef enum
{
	MODEM_STATE_UNKNOWN = 0,

	MODEM_STATE_INITIALIZED,
	MODEM_STATE_INCOMING_CONNECTED,
	MODEM_STATE_OUTGOING_CONNECTED,

	MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT,
	MODEM_STATE_WAITING_FOR_INCOMING_CONNECT,
	MODEM_STATE_CLOSING_OUTGOING_CONNECTION,
	MODEM_STATE_CLOSING_INCOMING_CONNECTION

} MODEM_STATE;

//
// invalid TAPI command ID
//
#define	INVALID_TAPI_COMMAND	-1

//
// enumerated values for state of data port
//
typedef	enum	_DATA_PORT_STATE
{
	DATA_PORT_STATE_UNKNOWN,		// unknown state
	DATA_PORT_STATE_INITIALIZED,	// initialized
	DATA_PORT_STATE_RECEIVING,		// data port is receiving data
	DATA_PORT_STATE_UNBOUND			// data port is unboind (closing)
} DATA_PORT_STATE;


//typedef	enum	_SEND_COMPLETION_CODE
//{
//	SEND_UNKNOWN,			// send is unknown
//	SEND_FAILED,			// send failed
//	SEND_IN_PROGRESS		// send is in progress
//} SEND_COMPLETION_CODE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CModemEndpoint;
class	CDataPort;
class	CModemReadIOData;
class	CModemWriteIOData;
typedef	enum	_ENDPOINT_TYPE	ENDPOINT_TYPE;
typedef	struct	_DATA_PORT_DIALOG_THREAD_PARAM	DATA_PORT_DIALOG_THREAD_PARAM;


//
// structure used to get date from the data port pool
//
typedef	struct	_DATA_PORT_POOL_CONTEXT
{
	CModemSPData	*pSPData;
} DATA_PORT_POOL_CONTEXT;

////
//// dialog function to call
////
//typedef	HRESULT	(*PDIALOG_SERVICE_FUNCTION)( const DATA_PORT_DIALOG_THREAD_PARAM *const pDialogData, HWND *const phDialog );
//
////
//// structure used to pass data to/from the data port dialog thread
////
//typedef	struct	_DATA_PORT_DIALOG_THREAD_PARAM
//{
//	CDataPort					*pDataPort;
//	BOOL						*pfDialogRunning;
//	PDIALOG_SERVICE_FUNCTION	pDialogFunction;
//} DATA_PORT_DIALOG_THREAD_PARAM;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CDataPort
{
	public:
		void	EndpointAddRef( void );
		DWORD	EndpointDecRef( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::AddRef"
		void	AddRef( void ) 
		{ 
			DNASSERT( m_iRefCount != 0 );
			DNInterlockedIncrement( &m_iRefCount ); 
		}
		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		//
		// pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::Lock"
		void	Lock( void )
		{
		    DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
		    DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::Unlock"
		void	Unlock( void )
		{
		    DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
		    DNLeaveCriticalSection( &m_Lock );
		}

		DPNHANDLE	GetHandle( void ) const { return m_Handle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetHandle"
		void	SetHandle( const DPNHANDLE Handle )
		{
			DNASSERT( ( m_Handle == 0 ) || ( Handle == 0 ) );
			m_Handle = Handle;
		}
		
		DATA_PORT_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SetState"
		void	SetState( const DATA_PORT_STATE State )
		{
			//
			// Validate state transitions
			//
			DNASSERT( ( m_State == DATA_PORT_STATE_UNKNOWN ) ||
					  ( State == DATA_PORT_STATE_UNKNOWN ) ||
					  ( ( m_State == DATA_PORT_STATE_INITIALIZED ) && ( State == DATA_PORT_STATE_UNBOUND ) ) ||
					  ( ( m_State == DATA_PORT_STATE_INITIALIZED ) && ( State == DATA_PORT_STATE_RECEIVING ) ) ||
					  ( ( m_State == DATA_PORT_STATE_RECEIVING ) && ( State == DATA_PORT_STATE_UNBOUND ) ) ||
					  ( ( m_State == DATA_PORT_STATE_RECEIVING ) && ( State == DATA_PORT_STATE_INITIALIZED ) ) ||
					  ( ( m_State == DATA_PORT_STATE_INITIALIZED ) && ( State == DATA_PORT_STATE_INITIALIZED ) ) );		// modem failed to answer a call
			m_State = State;
		}

		//
		// port settings
		//

		const CComPortData	*ComPortData( void ) const { return &m_ComPortData; }
		const SP_BAUD_RATE	GetBaudRate( void ) const { return m_ComPortData.GetBaudRate(); }
		HRESULT	SetBaudRate( const SP_BAUD_RATE BaudRate ) { return m_ComPortData.SetBaudRate( BaudRate ); }

		const SP_STOP_BITS	GetStopBits( void ) const { return m_ComPortData.GetStopBits(); }
		HRESULT	SetStopBits( const SP_STOP_BITS StopBits ) { return m_ComPortData.SetStopBits( StopBits ); }

		const SP_PARITY_TYPE	GetParity( void ) const  { return m_ComPortData.GetParity(); }
		HRESULT	SetParity( const SP_PARITY_TYPE Parity ) { return m_ComPortData.SetParity( Parity ); }

		const SP_FLOW_CONTROL	GetFlowControl( void ) const { return m_ComPortData.GetFlowControl(); }
		HRESULT	SetFlowControl( const SP_FLOW_CONTROL FlowControl ) { return m_ComPortData.SetFlowControl( FlowControl ); }



		MODEM_STATE	GetModemState( void ) const { return m_ModemState; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SetModemState"
		void	SetModemState( const MODEM_STATE NewState )
		{
			DNASSERT( ( GetModemState() == MODEM_STATE_UNKNOWN ) ||
					  ( NewState == MODEM_STATE_UNKNOWN ) ||
					  ( ( GetModemState() == MODEM_STATE_INITIALIZED ) && ( NewState == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) ) ||
					  ( ( GetModemState() == MODEM_STATE_INITIALIZED ) && ( NewState == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT ) ) ||
					  ( ( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) && ( NewState == MODEM_STATE_INCOMING_CONNECTED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) && ( NewState == MODEM_STATE_INITIALIZED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT ) && ( NewState == MODEM_STATE_OUTGOING_CONNECTED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_INCOMING_CONNECTED ) && ( NewState == MODEM_STATE_INITIALIZED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_OUTGOING_CONNECTED ) && ( NewState == MODEM_STATE_INITIALIZED ) ) );
			m_ModemState = NewState;
		}

		IDirectPlay8Address	*GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const;

		HRESULT	BindComPort( void );

		void	ProcessTAPIMessage( const LINEMESSAGE *const pLineMessage );

		
		
		
		CModemSPData	*GetSPData( void ) const { return m_pSPData; }

		LINK_DIRECTION	GetLinkDirection( void ) const { return m_LinkDirection; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SetLinkDirection"
		void	SetLinkDirection( const LINK_DIRECTION LinkDirection )
		{
			DNASSERT( ( m_LinkDirection == LINK_DIRECTION_UNKNOWN ) || ( LinkDirection == LINK_DIRECTION_UNKNOWN ) );
			m_LinkDirection = LinkDirection;
		}

		HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const;

		HRESULT	BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext );
		void	UnbindFromNetwork( void );

		HRESULT	BindEndpoint( CModemEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );
		void	UnbindEndpoint( CModemEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );
		HRESULT	SetPortCommunicationParameters( void );

		DWORD	GetDeviceID( void ) const 
		{ 
			if (m_fModem)
			{
				return m_dwDeviceID;
			}
			else
			{
				return m_ComPortData.GetDeviceID(); 
			}
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SetDeviceID"
		HRESULT	SetDeviceID( const DWORD dwDeviceID )
		{
			DNASSERT( ( GetDeviceID() == INVALID_DEVICE_ID ) ||
					  ( dwDeviceID == INVALID_DEVICE_ID ) );

			if (m_fModem)
			{
				m_dwDeviceID = dwDeviceID;
				return DPN_OK;
			}
			else
			{
				return m_ComPortData.SetDeviceID( dwDeviceID );
			}
		}
		

		DNHANDLE	GetFileHandle( void ) const { return m_hFile; }

		//
		// send functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SendUserData"
		void	SendUserData( CModemWriteIOData *const pWriteIOData )
		{
			DNASSERT( pWriteIOData != NULL );
			DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
			pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken = SERIAL_DATA_USER_DATA;
			SendData( pWriteIOData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SendEnumQueryData"
		void	SendEnumQueryData( CModemWriteIOData *const pWriteIOData, const UINT_PTR uRTTIndex )
		{
			DNASSERT( pWriteIOData != NULL );
			DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
			pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken = SERIAL_DATA_ENUM_QUERY | static_cast<BYTE>( uRTTIndex );
			SendData( pWriteIOData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SendEnumResponseData"
		void	SendEnumResponseData( CModemWriteIOData *const pWriteIOData, const UINT_PTR uRTTIndex )
		{
			DNASSERT( pWriteIOData != NULL );
			DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
			pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken = SERIAL_DATA_ENUM_RESPONSE | static_cast<BYTE>( uRTTIndex );
			SendData( pWriteIOData );
		}

		void	ProcessReceivedData( const DWORD dwBytesReceived, const DWORD dwError );
		void	SendComplete( CModemWriteIOData *const pWriteIOData, const HRESULT hSendResult );

	private:
		CModemReadIOData	*GetActiveRead( void ) const { return m_pActiveRead; }

		BOOL			m_fModem;

		CBilink			m_ActiveListLinkage;	// link to active data port list

    	//
    	// file I/O management parameters
    	//
    	LINK_DIRECTION	m_LinkDirection;	// direction of link

    	DNHANDLE			m_hFile;			// file handle for reading/writing data

		//
		// bound endpoints
		//
		DPNHANDLE	m_hListenEndpoint;		// endpoint for active listen
		DPNHANDLE	m_hConnectEndpoint;		// endpoint for active connect
		DPNHANDLE	m_hEnumEndpoint;		// endpoint for active enum

		HRESULT	StartReceiving( void );
		HRESULT	Receive( void );

		//
		// private I/O functions
		//
		void	SendData( CModemWriteIOData *const pWriteIOData );

		//
		// debug only items
		//
		DEBUG_ONLY( BOOL	m_fInitialized );

		//
		// reference count and state
		//
		volatile LONG		m_EndpointRefCount;		// endpoint reference count
		volatile LONG		m_iRefCount;
		volatile DATA_PORT_STATE	m_State;		// state of data port
		volatile DPNHANDLE		m_Handle;				// handle

#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_Lock;					// critical section lock
#endif // !DPNBUILD_ONLYONETHREAD

		CModemSPData				*m_pSPData;				// pointer to SP data

		CModemReadIOData		*m_pActiveRead;				// pointer to current read

		CComPortData	m_ComPortData;
		
		HRESULT	SetPortState( void );

		volatile MODEM_STATE	m_ModemState;

		DWORD	m_dwDeviceID;
		DWORD	m_dwNegotiatedAPIVersion;
		HLINE	m_hLine;
		HCALL	m_hCall;
		LONG	m_lActiveLineCommand;

		DWORD	GetNegotiatedAPIVersion( void ) const { return m_dwNegotiatedAPIVersion; }
		void	SetNegotiatedAPIVersion( const DWORD dwVersion )
		{
			DNASSERT( ( GetNegotiatedAPIVersion() == 0 ) || ( dwVersion == 0 ) );
			m_dwNegotiatedAPIVersion = dwVersion;
		}

		HLINE	GetLineHandle( void ) const { return m_hLine; }
		void	SetLineHandle( const HLINE hLine )
		{
			DNASSERT( ( GetLineHandle() == NULL ) || ( hLine == NULL ) );
			m_hLine = hLine;
		}

		HCALL	GetCallHandle( void ) const { return m_hCall; }
		void	SetCallHandle( const HCALL hCall )
		{
			DNASSERT( ( GetCallHandle() == NULL ) ||
					  ( hCall == NULL ) );
			m_hCall = hCall;
		}

		LONG	GetActiveLineCommand( void ) const { return m_lActiveLineCommand; }
		void	SetActiveLineCommand( const LONG lLineCommand )
		{
			DNASSERT( ( GetActiveLineCommand() == INVALID_TAPI_COMMAND ) ||
					  ( lLineCommand == INVALID_TAPI_COMMAND ) );
			m_lActiveLineCommand = lLineCommand;
		}

		void	CancelOutgoingConnections( void );

		//
		// prevent unwarranted copies
		//
		CDataPort( const CDataPort & );
		CDataPort& operator=( const CDataPort & );
};

#undef DPF_MODNAME

#endif	// __DATA_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnmodemextern.h
 *  Content:    DirectPlay Modem Library external functions to be called
 *              by other DirectPlay components.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	 09/25/2001	masonb	Created
 *
 ***************************************************************************/

BOOL DNModemInit(HANDLE hModule);
void DNModemDeInit();
#ifndef DPNBUILD_NOCOMREGISTER
BOOL DNModemRegister(LPCWSTR wszDLLName);
BOOL DNModemUnRegister();
#endif // ! DPNBUILD_NOCOMREGISTER

HRESULT CreateModemInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
								const XDP8CREATE_PARAMS * const pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
								IDP8ServiceProvider **const ppiDP8SP
								);

HRESULT CreateSerialInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
								const XDP8CREATE_PARAMS * const pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
								IDP8ServiceProvider **const ppiDP8SP
								);


#ifndef DPNBUILD_LIBINTERFACE
DWORD DNModemGetRemainingObjectCount();

extern IClassFactoryVtbl ModemClassFactoryVtbl;
extern IClassFactoryVtbl SerialClassFactoryVtbl;
#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Classfac.cpp
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#include "dnmdmi.h"


#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif

HRESULT	ModemDoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

/*
 * DP8MDMCF_CreateInstance
 *
 * Creates an instance of a DNServiceProvider object
 */
STDMETHODIMP DP8MDMCF_CreateInstance(
                LPCLASSFACTORY This,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT						hr = S_OK;
    _IDirectPlayClassFactory*	pcf;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	pcf = (_IDirectPlayClassFactory*) This;
	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = ModemDoCreateInstance(This, pUnkOuter, pcf->clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* DP8WSCF_CreateInstance */


IClassFactoryVtbl ModemClassFactoryVtbl =
{
        DPCF_QueryInterface, // dnet\common\classfactory.cpp will implement the rest of these
        DPCF_AddRef,
        DPCF_Release,
        DP8MDMCF_CreateInstance, // MASONB: TODO: Finish making these CLSID specific
        DPCF_LockServer
};

IClassFactoryVtbl SerialClassFactoryVtbl =
{
        DPCF_QueryInterface, // dnet\common\classfactory.cpp will implement the rest of these
        DPCF_AddRef,
        DPCF_Release,
        DP8MDMCF_CreateInstance,
        DPCF_LockServer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemendpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Endpoint.cpp
 *  Content:	DNSerial communications endpoint base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_TAPI_DEV_CAPS_SIZE	1024

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemEndpoint::CopyConnectData - copy data for connect command
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CopyConnectData"

void	CModemEndpoint::CopyConnectData( const SPCONNECTDATA *const pConnectData )
{
	DNASSERT( GetType() == ENDPOINT_TYPE_CONNECT );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hCommand != NULL );
	DNASSERT( pConnectData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_pCommandHandle == NULL );

	DBG_CASSERT( sizeof( m_CurrentCommandParameters.ConnectData ) == sizeof( *pConnectData ) );
	memcpy( &m_CurrentCommandParameters.ConnectData, pConnectData, sizeof( m_CurrentCommandParameters.ConnectData ) );
	m_CurrentCommandParameters.ConnectData.pAddressHost = NULL;
	m_CurrentCommandParameters.ConnectData.pAddressDeviceInfo = NULL;

	m_Flags.fCommandPending = TRUE;
	m_pCommandHandle = static_cast<CModemCommandData*>( m_CurrentCommandParameters.ConnectData.hCommand );
	m_pCommandHandle->SetUserContext( pConnectData->pvContext );
	SetState( ENDPOINT_STATE_ATTEMPTING_CONNECT );
};
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ConnectJobCallback - asynchronous callback wrapper from work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ConnectJobCallback"

void	CModemEndpoint::ConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CModemEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CModemEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_Flags.fCommandPending != FALSE );
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ConnectData.hCommand == pThisEndpoint->m_pCommandHandle );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteConnect();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem completing connect in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!
	//

Exit:
	pThisEndpoint->DecRef();
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CancelConnectJobCallback - cancel for connect job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CancelConnectJobCallback"

void	CModemEndpoint::CancelConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CModemEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CModemEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	pThisEndpoint->m_pCommandHandle->Lock();
	DNASSERT( ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pCommandHandle->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pCommandHandle->Unlock();
	
	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->GetSPData()->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CompleteConnect - complete connection
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CModemEndpoint::CompleteConnect( void )
{
	HRESULT		hr;


	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_CONNECT );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	DNASSERT( m_CurrentCommandParameters.ConnectData.hCommand == m_pCommandHandle );
	DNASSERT( m_CurrentCommandParameters.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );

	
	//
	// check for user cancelling command
	//
	m_pCommandHandle->Lock();

	DNASSERT( m_pCommandHandle->GetType() == COMMAND_TYPE_CONNECT );
	switch ( m_pCommandHandle->GetState() )
	{
		//
		// Command is still pending, don't mark it as uninterruptable because
		// it might be cancelled before indicating the final connect.
		//
		case COMMAND_STATE_PENDING:
		{
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP,  0, "User cancelled connect!" );

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pCommandHandle->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// find a dataport to bind with
	//
	hr = m_pSPData->BindEndpoint( this, GetDeviceID(), GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind to data port in connect!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// The connect sequence will complete when the CDataPort indicates that the
	// outbound connection has been established.
	//

Exit:
	return	hr;

Failure:
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::Disconnect - disconnect this endpoint
//
// Entry:		Old handle value
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::Disconnect"

HRESULT	CModemEndpoint::Disconnect( const DPNHANDLE hOldEndpointHandle )
{
	HRESULT	hr;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p)", this, hOldEndpointHandle );

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();
	switch ( GetState() )
	{
		//
		// connected endpoint
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			DNASSERT( m_Flags.fCommandPending == FALSE );
			DNASSERT( m_pCommandHandle == NULL );

			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();

			//
			// Unlock this endpoint before calling to a higher level.  The endpoint
			// has already been labeled as DISCONNECTING so nothing will happen to it.
			//
			Unlock();
				
			//
			// Note the old endpoint handle so it can be used in the disconnect
			// indication that will be given just before this endpoint is returned
			// to the pool.  Need to release the reference that was added for the
			// connection at this point or the endpoint will never be returned to
			// the pool.
			//
			SetDisconnectIndicationHandle( hOldEndpointHandle );
			DecRef();

			Close( DPN_OK );
			
			//
			// close outstanding reference for this command
			//
			DecCommandRef();
			DecRef();

			break;
		}

		//
		// endpoint waiting for the modem to pick up on the other end
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();
			Unlock();
			
			Close( DPNERR_NOCONNECTION );
			
			//
			// close outstanding reference for this command
			//
			DecCommandRef();
			DecRef();
			
			break;
		}

		//
		// some other endpoint state
		//
		default:
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPFX(DPFPREP,  0, "Attempted to disconnect endpoint that's not connected!" );
			switch ( m_State )
			{
				case ENDPOINT_STATE_UNINITIALIZED:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_UNINITIALIZED" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_LISTEN:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_ATTEMPTING_LISTEN" );
					break;
				}

				case ENDPOINT_STATE_ENUM:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_ENUM" );
					break;
				}

				case ENDPOINT_STATE_DISCONNECTING:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_DISCONNECTING" );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
			
			Unlock();
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}

Exit:
	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr );
	
	return	hr;

Failure:
	// nothing to do
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::StopEnumCommand - stop an enum job
//
// Entry:		Error code for completing command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::StopEnumCommand"

void	CModemEndpoint::StopEnumCommand( const HRESULT hCommandResult )
{
	Lock();
	DNASSERT( GetState() == ENDPOINT_STATE_DISCONNECTING );
	if ( m_hActiveDialogHandle != NULL )
	{
		StopSettingsDialog( m_hActiveDialogHandle );
		Unlock();
	}
	else
	{
		BOOL	fStoppedJob;

		
		Unlock();
		fStoppedJob = m_pSPData->GetThreadPool()->StopTimerJob( m_pCommandHandle, hCommandResult );
		if ( ! fStoppedJob )
		{
			DPFX(DPFPREP, 1, "Unable to stop timer job (context 0x%p) manually setting result to 0x%lx.",
				m_pCommandHandle, hCommandResult);
			
			//
			// Set the command result so it can be returned when the endpoint
			// reference count is zero.
			//
			SetCommandResult( hCommandResult );
		}
	}
	
	m_pSPData->CloseEndpointHandle( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::SetState - set state of this endpoint
//
// Entry:		New state
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::SetState"

void	CModemEndpoint::SetState( const ENDPOINT_STATE EndpointState )
{
	DNASSERT( ( GetState() == ENDPOINT_STATE_UNINITIALIZED ) ||
			  ( EndpointState == ENDPOINT_STATE_UNINITIALIZED ) ||
			  ( ( m_State== ENDPOINT_STATE_ATTEMPTING_LISTEN ) && ( EndpointState == ENDPOINT_STATE_LISTENING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_LISTENING ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM ) && ( EndpointState == ENDPOINT_STATE_ENUM ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ENUM ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_CONNECT_CONNECTED ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) );
	m_State = EndpointState;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CopyListenData - copy data for listen command
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CopyListenData"

void	CModemEndpoint::CopyListenData( const SPLISTENDATA *const pListenData )
{
	DNASSERT( GetType() == ENDPOINT_TYPE_LISTEN );
	DNASSERT( pListenData != NULL );
	DNASSERT( pListenData->hCommand != NULL );
	DNASSERT( pListenData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_Flags.fListenStatusNeedsToBeIndicated == FALSE );

	DBG_CASSERT( sizeof( m_CurrentCommandParameters.ListenData ) == sizeof( *pListenData ) );
	memcpy( &m_CurrentCommandParameters.ListenData, pListenData, sizeof( m_CurrentCommandParameters.ListenData ) );
	DEBUG_ONLY( m_CurrentCommandParameters.ListenData.pAddressDeviceInfo = NULL );

	m_Flags.fCommandPending = TRUE;
	m_Flags.fListenStatusNeedsToBeIndicated = TRUE;
	m_pCommandHandle = static_cast<CModemCommandData*>( m_CurrentCommandParameters.ListenData.hCommand );
	m_pCommandHandle->SetUserContext( pListenData->pvContext );
	
	SetState( ENDPOINT_STATE_ATTEMPTING_LISTEN );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ListenJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ListenJobCallback"

void	CModemEndpoint::ListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CModemEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	// initialize
	pThisEndpoint = static_cast<CModemEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->GetState() == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( pThisEndpoint->m_Flags.fCommandPending != NULL );
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ListenData.hCommand == pThisEndpoint->m_pCommandHandle );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteListen();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem completing listen in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

Exit:
	pThisEndpoint->DecRef();

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!!
	//

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CancelListenJobCallback - cancel for listen job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CancelListenJobCallback"

void	CModemEndpoint::CancelListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CModemEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CModemEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	pThisEndpoint->m_pCommandHandle->Lock();
	DNASSERT( ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pCommandHandle->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pCommandHandle->Unlock();

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->GetSPData()->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CompleteListen - complete listen process
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CModemEndpoint::CompleteListen( void )
{
	HRESULT					hr;
	BOOL					fEndpointLocked;
	SPIE_LISTENSTATUS		ListenStatus;
	HRESULT					hTempResult;


	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_LISTEN );

	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;

	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	DNASSERT( m_pCommandHandle->GetEndpoint() == this );
	DNASSERT( m_CurrentCommandParameters.ListenData.hCommand == m_pCommandHandle );
	DNASSERT( m_CurrentCommandParameters.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );
	
	
	//
	// check for user cancelling command
	//
	Lock();
	fEndpointLocked = TRUE;
	m_pCommandHandle->Lock();

	DNASSERT( m_pCommandHandle->GetType() == COMMAND_TYPE_LISTEN );
	switch ( m_pCommandHandle->GetState() )
	{
		//
		// command is pending, mark as in-progress and cancellable
		//
		case COMMAND_STATE_PENDING:
		{
			m_pCommandHandle->SetState( COMMAND_STATE_INPROGRESS );
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP,  0, "User cancelled listen!" );

			Unlock();
			fEndpointLocked = FALSE;
			
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			Unlock();
			fEndpointLocked = FALSE;
			
			break;
		}
	}
	m_pCommandHandle->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// find a dataport to bind with
	//
	hr = m_pSPData->BindEndpoint( this, GetDeviceID(), GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind endpoint for serial listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// We're done and everyone's happy.  Listen commands never
	// complete until cancelled by the user.  Don't complete
	// the command at this point.
	//
	SetState( ENDPOINT_STATE_LISTENING );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );

Exit:
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}
	
	if ( m_Flags.fListenStatusNeedsToBeIndicated != FALSE )
	{
		m_Flags.fListenStatusNeedsToBeIndicated = FALSE;
		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hResult = hr;
		DNASSERT( m_pCommandHandle == m_CurrentCommandParameters.ListenData.hCommand );
		ListenStatus.hCommand = m_CurrentCommandParameters.ListenData.hCommand;
		ListenStatus.pUserContext = m_CurrentCommandParameters.ListenData.pvContext;
		ListenStatus.hEndpoint = (HANDLE)(DWORD_PTR)GetHandle();
		DeviceIDToGuid( &ListenStatus.ListenAdapter, GetDeviceID(), GetEncryptionGuid() );

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);
		DNASSERT( hTempResult == DPN_OK );
	}
	
	return	hr;

Failure:
	//
	// we've failed to complete the listen, clean up and return this
	// endpoint to the pool
	//
	Close( hr );
	
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CopyEnumQueryData - copy data for enum query command
//
// Entry:		Pointer to command data
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CopyEnumQueryData"

void	CModemEndpoint::CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData )
{
	DNASSERT( GetType() == ENDPOINT_TYPE_ENUM );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( pEnumQueryData->hCommand != NULL );
	DNASSERT( pEnumQueryData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_pCommandHandle == NULL );

	DBG_CASSERT( sizeof( m_CurrentCommandParameters.EnumQueryData ) == sizeof( *pEnumQueryData ) );
	memcpy( &m_CurrentCommandParameters.EnumQueryData, pEnumQueryData, sizeof( m_CurrentCommandParameters.EnumQueryData ) );
	m_CurrentCommandParameters.EnumQueryData.pAddressHost = NULL;
	m_CurrentCommandParameters.EnumQueryData.pAddressDeviceInfo = NULL;

	m_Flags.fCommandPending = TRUE;
	m_pCommandHandle = static_cast<CModemCommandData*>( m_CurrentCommandParameters.EnumQueryData.hCommand );
	m_pCommandHandle->SetUserContext( pEnumQueryData->pvContext );
	SetState( ENDPOINT_STATE_ATTEMPTING_ENUM );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::EnumQueryJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::EnumQueryJobCallback"

void	CModemEndpoint::EnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CModemEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CModemEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_Flags.fCommandPending != FALSE );
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.EnumQueryData.hCommand == pThisEndpoint->m_pCommandHandle );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteEnumQuery();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem completing enum query in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned to the pool!!!!
	//
Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CancelEnumQueryJobCallback - cancel for enum query job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CancelEnumQueryJobCallback"

void	CModemEndpoint::CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CModemEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CModemEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	pThisEndpoint->m_pCommandHandle->Lock();
	DNASSERT( ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_INPROGRESS ) ||
			  ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pCommandHandle->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pCommandHandle->Unlock();

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->GetSPData()->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CompleteEnumQuery - complete enum query process
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CModemEndpoint::CompleteEnumQuery( void )
{
	HRESULT		hr;
	BOOL		fEndpointLocked;
	BOOL		fEndpointBound;
	CDataPort	*pDataPort;


	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	fEndpointBound = FALSE;
	pDataPort = NULL;

	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_ENUM );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	DNASSERT( m_pCommandHandle->GetEndpoint() == this );
	DNASSERT( m_CurrentCommandParameters.EnumQueryData.hCommand == m_pCommandHandle );
	DNASSERT( m_CurrentCommandParameters.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// check for user cancelling command
	//
	Lock();
	fEndpointLocked = TRUE;
	m_pCommandHandle->Lock();

	DNASSERT( m_pCommandHandle->GetType() == COMMAND_TYPE_ENUM_QUERY );
	switch ( m_pCommandHandle->GetState() )
	{
		//
		// command is still in progress
		//
		case COMMAND_STATE_INPROGRESS:
		{
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP,  0, "User cancelled enum query!" );
			Unlock();
			fEndpointLocked = FALSE;
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			Unlock();
			fEndpointLocked = FALSE;
			break;
		}
	}
	m_pCommandHandle->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// find a dataport to bind with
	//
	hr = m_pSPData->BindEndpoint( this, GetDeviceID(), GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind to data port for EnumQuery!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fEndpointBound = TRUE;

	SetState( ENDPOINT_STATE_ENUM );

Exit:
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}
	
	if ( pDataPort != NULL )
	{
		pDataPort->EndpointDecRef();
		pDataPort = NULL;
	}

	return	hr;

Failure:
	if ( fEndpointBound != FALSE )
	{
		DNASSERT( GetDataPort() != NULL );
		m_pSPData->UnbindEndpoint( this, GetType() );
		fEndpointBound = FALSE;
	}

	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::OutgoingConnectionEstablished - an outgoing connection was established
//
// Entry:		Command result (DPN_OK == connection succeeded)
//
// Exit:		Nothing
// ------------------------------
void	CModemEndpoint::OutgoingConnectionEstablished( const HRESULT hCommandResult )
{
	HRESULT			hr;
	CModemCommandData	*pCommandData;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%lx)", this, hCommandResult);

	pCommandData = GetCommandData();
	DNASSERT( pCommandData != NULL );
	
	//
	// check for successful connection
	//
	if ( hCommandResult != DPN_OK )
	{
		DNASSERT( FALSE );
		hr = hCommandResult;
		goto Failure;
	}
		
	//
	// determine which type of outgoing connection this is and complete it
	//
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
		{
			BOOL	fProceed;
			
			
			fProceed = TRUE;
			pCommandData->Lock();
			switch ( pCommandData->GetState() )
			{
				case COMMAND_STATE_PENDING:
				{
					pCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
					DNASSERT( fProceed != FALSE );
					break;
				}

				case COMMAND_STATE_CANCELLING:
				{
					fProceed = FALSE;
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
			pCommandData->Unlock();

			if ( fProceed != FALSE )
			{
				SPIE_CONNECT	ConnectIndicationData;


				//
				// Inform user of connection.  Assume that the user will accept
				// and everything will succeed so we can set the user context
				// for the endpoint.  If the connection fails, clear the user
				// endpoint context.
				//
				memset( &ConnectIndicationData, 0x00, sizeof( ConnectIndicationData ) );
				DBG_CASSERT( sizeof( ConnectIndicationData.hEndpoint ) == sizeof( HANDLE ) );
				ConnectIndicationData.hEndpoint = (HANDLE)(DWORD_PTR)GetHandle();
				ConnectIndicationData.pCommandContext = m_CurrentCommandParameters.ConnectData.pvContext;
				SetUserEndpointContext( ConnectIndicationData.pEndpointContext );

				hr = SignalConnect( &ConnectIndicationData );
				if ( hr != DPN_OK )
				{
					DNASSERT( hr == DPNERR_ABORTED );
					DPFX(DPFPREP,  0, "User refused connect in CompleteConnect!" );
					DisplayDNError( 0, hr );
					SetUserEndpointContext( NULL );
					goto Failure;
				}

				//
				// we're done and everyone's happy, complete the command, this
				// will clear all of our internal command data
				//
				CompletePendingCommand( hr );
				DNASSERT( m_Flags.fCommandPending == FALSE );
				DNASSERT( m_pCommandHandle == NULL );
			}

			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			UINT_PTR	uRetryCount;
			BOOL		fRetryForever;
			DWORD		dwRetryInterval;
			BOOL		fWaitForever;
			DWORD		dwIdleTimeout;
			
			

			//
			// check retry to determine if we're enumerating forever
			//
			switch ( m_CurrentCommandParameters.EnumQueryData.dwRetryCount )
			{
				//
				// let SP determine retry count
				//
				case 0:
				{
					uRetryCount = DEFAULT_ENUM_RETRY_COUNT;
					fRetryForever = FALSE;
					break;
				}

				//
				// retry forever
				//
				case INFINITE:
				{
					uRetryCount = 1;
					fRetryForever = TRUE;
					break;
				}

				//
				// other
				//
				default:
				{
					uRetryCount = m_CurrentCommandParameters.EnumQueryData.dwRetryCount;
					fRetryForever = FALSE;
					break;
				}
			}

			//
			// check interval for default
			//
			if ( m_CurrentCommandParameters.EnumQueryData.dwRetryInterval == 0 )
			{
				dwRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
			}
			else
			{
				dwRetryInterval = m_CurrentCommandParameters.EnumQueryData.dwRetryInterval;
			}

			//
			// check timeout to see if we're waiting forever
			//
			switch ( m_CurrentCommandParameters.EnumQueryData.dwTimeout )
			{
				//
				// wait forever
				//
				case INFINITE:
				{
					fWaitForever = TRUE;
					dwIdleTimeout = -1;
					break;
				}

				//
				// possible default
				//
				case 0:
				{
					fWaitForever = FALSE;
					dwIdleTimeout = DEFAULT_ENUM_TIMEOUT;	
					break;
				}

				//
				// other
				//
				default:
				{
					fWaitForever = FALSE;
					dwIdleTimeout = m_CurrentCommandParameters.EnumQueryData.dwTimeout;
					break;
				}
			}

			m_dwEnumSendIndex = 0;
			memset( m_dwEnumSendTimes, 0, sizeof( m_dwEnumSendTimes ) );

			pCommandData->Lock();
			if ( pCommandData->GetState() == COMMAND_STATE_INPROGRESS )
			{
				//
				// add a reference for the timer job, must be cleaned on failure
				//
				AddRef();
				
				hr = m_pSPData->GetThreadPool()->SubmitTimerJob( uRetryCount,						// number of times to retry command
																 fRetryForever,						// retry forever
																 dwRetryInterval,					// retry interval
																 fWaitForever,						// wait forever after all enums sent
																 dwIdleTimeout,						// timeout to wait after command complete
																 CModemEndpoint::EnumTimerCallback,		// function called when timer event fires
																 CModemEndpoint::EnumCompleteWrapper,	// function called when timer event expires
																 m_pCommandHandle );				// context
				if ( hr != DPN_OK )
				{
					pCommandData->Unlock();
					DPFX(DPFPREP,  0, "Failed to spool enum job on work thread!" );
					DisplayDNError( 0, hr );
					DecRef();

					goto Failure;
				}

				//
				// if everything is a success, we should still have an active command
				//
				DNASSERT( m_Flags.fCommandPending != FALSE );
				DNASSERT( m_pCommandHandle != NULL );
			}
			
			pCommandData->Unlock();
			
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:

	DPFX(DPFPREP, 6, "(0x%p) Returning", this);
	
	return;

Failure:
	DNASSERT( FALSE );
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::EnumCompleteWrapper - this enum has expired
//
// Entry:		Error code
//				Context (command pointer)
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::EnumCompleteWrapper"

void	CModemEndpoint::EnumCompleteWrapper( const HRESULT hResult, void *const pContext )
{
	CModemCommandData	*pCommandData;


	DNASSERT( pContext != NULL );
	pCommandData = static_cast<CModemCommandData*>( pContext );
	pCommandData->GetEndpoint()->EnumComplete( hResult );
	pCommandData->GetEndpoint()->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::EnumTimerCallback - timed callback to send enum data
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::EnumTimerCallback"

void	CModemEndpoint::EnumTimerCallback( void *const pContext )
{
	CModemCommandData	*pCommandData;
	CModemEndpoint		*pThisObject;
	CModemWriteIOData	*pWriteData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pCommandData = static_cast<CModemCommandData*>( pContext );
	pThisObject = pCommandData->GetEndpoint();
	pWriteData = NULL;

	pThisObject->Lock();

	switch ( pThisObject->m_State )
	{
		//
		// we're enumerating (as expected)
		//
		case ENDPOINT_STATE_ENUM:
		{
			break;
		}

		//
		// this endpoint is disconnecting, bail!
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			pThisObject->Unlock();
			goto Exit;

			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	pThisObject->Unlock();

	//
	// attempt to get a new IO buffer for this endpoint
	//
	pWriteData = pThisObject->m_pSPData->GetThreadPool()->CreateWriteIOData();
	if ( pWriteData == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to get write data for an enum!" );
		goto Failure;
	}

	//
	// Set all data for the write.  Since this is an enum and we
	// don't care about the outgoing data so don't send an indication
	// when it completes.
	//
	DNASSERT( pThisObject->m_Flags.fCommandPending != FALSE );
	DNASSERT( pThisObject->m_pCommandHandle != NULL );
	DNASSERT( pThisObject->GetState() == ENDPOINT_STATE_ENUM );
	pWriteData->m_pBuffers = pThisObject->m_CurrentCommandParameters.EnumQueryData.pBuffers;
	pWriteData->m_uBufferCount = pThisObject->m_CurrentCommandParameters.EnumQueryData.dwBufferCount;
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_NONE;

	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->m_pCommand->GetUserContext() == NULL );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );

	DNASSERT( pThisObject->GetDataPort() != NULL );
	pThisObject->m_dwEnumSendIndex++;
	pThisObject->m_dwEnumSendTimes[ pThisObject->m_dwEnumSendIndex & ENUM_RTT_MASK ] = GETTIMESTAMP();
	pThisObject->m_pDataPort->SendEnumQueryData( pWriteData,
												 ( pThisObject->m_dwEnumSendIndex & ENUM_RTT_MASK ) );

Exit:
	return;

Failure:
	// nothing to clean up at this time

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::SignalConnect - note connection
//
// Entry:		Pointer to connect data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::SignalConnect"

HRESULT	CModemEndpoint::SignalConnect( SPIE_CONNECT *const pConnectData )
{
	HRESULT	hr;


	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hEndpoint == (HANDLE)(DWORD_PTR)GetHandle() );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	switch ( m_State )
	{
		//
		// disconnecting, nothing to do
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;
			break;
		}

		//
		// we're attempting to connect
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DNASSERT( m_Flags.fConnectIndicated == FALSE );
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
											   SPEV_CONNECT,							// event type
											   pConnectData								// pointer to data
											   );
			switch ( hr )
			{
				//
				// connection accepted
				//
				case DPN_OK:
				{
					//
					// note that we're connected
					//
					SetUserEndpointContext( pConnectData->pEndpointContext );
					m_Flags.fConnectIndicated = TRUE;
					m_State = ENDPOINT_STATE_CONNECT_CONNECTED;
					AddRef();

					break;
				}

				//
				// user aborted connection attempt, nothing to do, just pass
				// the result on
				//
				case DPNERR_ABORTED:
				{
					DNASSERT( GetUserEndpointContext() == NULL );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// states where we shouldn't be getting called
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::SignalDisconnect - note disconnection
//
// Entry:		Old endpoint handle
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::SignalDisconnect"

void	CModemEndpoint::SignalDisconnect( const DPNHANDLE hOldEndpointHandle )
{
	HRESULT	hr;
	SPIE_DISCONNECT	DisconnectData;


	// tell user that we're disconnecting
	DNASSERT( m_Flags.fConnectIndicated != FALSE );
	DBG_CASSERT( sizeof( DisconnectData.hEndpoint ) == sizeof( this ) );
	DisconnectData.hEndpoint = (HANDLE)(DWORD_PTR)hOldEndpointHandle;
	DisconnectData.pEndpointContext = GetUserEndpointContext();
	m_Flags.fConnectIndicated = FALSE;
	DNASSERT( m_pSPData != NULL );
	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// callback interface
									   SPEV_DISCONNECT,					    	// event type
									   &DisconnectData					    	// pointer to data
									   );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SignalDisconnect!" );
		DisplayDNError( 0, hr );
		DNASSERT( FALSE );
	}

	SetDisconnectIndicationHandle( 0 );

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CleanUpCommand - perform cleanup now that the command on this
//		endpoint is essentially complete.  There may be outstanding references,
//		but nobody will be asking the endpoint to do anything else.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CModemEndpoint::CleanUpCommand( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this );

	
	if ( GetDataPort() != NULL )
	{
		DNASSERT( m_pSPData != NULL );
		m_pSPData->UnbindEndpoint( this, GetType() );
	}

	//
	// If we're bailing here it's because the UI didn't complete.  There is no
	// adapter guid to return because one may have not been specified.  Return
	// a bogus endpoint handle so it can't be queried for addressing data.
	//
	if ( m_Flags.fListenStatusNeedsToBeIndicated != FALSE )
	{
		HRESULT				hTempResult;
		SPIE_LISTENSTATUS	ListenStatus;
		

		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hCommand = m_pCommandHandle;
		ListenStatus.hEndpoint = 0;
		ListenStatus.hResult = CommandResult();
		memset( &ListenStatus.ListenAdapter, 0x00, sizeof( ListenStatus.ListenAdapter ) );
		ListenStatus.pUserContext = m_pCommandHandle->GetUserContext();

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);
		DNASSERT( hTempResult == DPN_OK );

		m_Flags.fListenStatusNeedsToBeIndicated = FALSE;
	}

	SetHandle( 0 );
	SetState( ENDPOINT_STATE_UNINITIALIZED );

	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ProcessEnumData - process received enum data
//
// Entry:		Pointer to received data
//				Enum RTT index
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ProcessEnumData"

void	CModemEndpoint::ProcessEnumData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uEnumRTTIndex )
{
	DNASSERT( pReceivedBuffer != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// we're listening, this is the only way to detect enums
		//
		case ENDPOINT_STATE_LISTENING:
		{
			ENDPOINT_ENUM_QUERY_CONTEXT	QueryContext;
			HRESULT		hr;


			DNASSERT( m_pCommandHandle != NULL );
			DEBUG_ONLY( memset( &QueryContext, 0x00, sizeof( QueryContext ) ) );

			QueryContext.hEndpoint = (HANDLE)(DWORD_PTR)GetHandle();
			QueryContext.uEnumRTTIndex = uEnumRTTIndex;
			QueryContext.EnumQueryData.pReceivedData = pReceivedBuffer;
			QueryContext.EnumQueryData.pUserContext = m_pCommandHandle->GetUserContext();
	
			QueryContext.EnumQueryData.pAddressSender = GetRemoteHostDP8Address();
			QueryContext.EnumQueryData.pAddressDevice = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
			if ( ( QueryContext.EnumQueryData.pAddressSender != NULL ) &&
				 ( QueryContext.EnumQueryData.pAddressDevice != NULL ) )
			{
				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_ENUMQUERY,							// data type
												   &QueryContext.EnumQueryData				// pointer to data
												   );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP,  0, "User returned unexpected error from enum query indication!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}
			}

			if ( QueryContext.EnumQueryData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressSender );
				QueryContext.EnumQueryData.pAddressSender = NULL;
			}

			if ( QueryContext.EnumQueryData.pAddressDevice )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressDevice );
				QueryContext.EnumQueryData.pAddressDevice = NULL;
			}

			break;
		}

		//
		// we're disconnecting, ignore this message
		//
		case ENDPOINT_STATE_ATTEMPTING_LISTEN:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ProcessEnumResponseData - process received enum response data
//
// Entry:		Pointer to received data
//				Pointer to address of sender
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ProcessEnumResponseData"

void	CModemEndpoint::ProcessEnumResponseData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uRTTIndex )
{
	DNASSERT( pReceivedBuffer != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// endpoint is enuming, it can handle enum responses
		//
		case ENDPOINT_STATE_ENUM:
		{
			SPIE_QUERYRESPONSE	QueryResponseData;
			HRESULT	hr;


			DNASSERT( m_pCommandHandle != NULL );
			DEBUG_ONLY( memset( &QueryResponseData, 0x00, sizeof( QueryResponseData ) ) );
			QueryResponseData.pReceivedData = pReceivedBuffer;
			QueryResponseData.dwRoundTripTime = GETTIMESTAMP() - m_dwEnumSendTimes[ uRTTIndex ];
			QueryResponseData.pUserContext = m_pCommandHandle->GetUserContext();

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
			QueryResponseData.pAddressSender = GetRemoteHostDP8Address();
			QueryResponseData.pAddressDevice = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
			if ( ( QueryResponseData.pAddressSender != NULL ) &&
				 ( QueryResponseData.pAddressDevice != NULL ) )
			{
				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_QUERYRESPONSE,						// data type
												   &QueryResponseData						// pointer to data
												   );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP,  0, "User returned unknown error when indicating query response!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}

			}

			if ( QueryResponseData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
				QueryResponseData.pAddressSender = NULL;
			}
			
			if ( QueryResponseData.pAddressDevice != NULL )
			{
				IDirectPlay8Address_Release( QueryResponseData.pAddressDevice );
				QueryResponseData.pAddressDevice = NULL;
			}

			break;
		}

		//
		// endpoint is disconnecting, ignore data
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ProcessUserData - process received user data
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ProcessUserData"

void	CModemEndpoint::ProcessUserData( CModemReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );

	switch ( m_State )
	{
		//
		// endpoint is connected
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT		hr;
			SPIE_DATA	UserData;


			//
			// it's possible that the user wants to keep the data, add a
			// reference to keep it from going away
			//
			pReadData->AddRef();

			//
			// we're connected, report the user data
			//
			DEBUG_ONLY( memset( &UserData, 0x00, sizeof( UserData ) ) );
			DBG_CASSERT( sizeof( this ) == sizeof( HANDLE ) );
			UserData.hEndpoint = (HANDLE)(DWORD_PTR)GetHandle();
			UserData.pEndpointContext = GetUserEndpointContext();
			UserData.pReceivedData = &pReadData->m_SPReceivedBuffer;

			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DATA 0x%p to interface 0x%p.",
				this, &UserData, m_pSPData->DP8SPCallbackInterface());
			
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to interface
											   SPEV_DATA,								// user data was received
											   &UserData								// pointer to data
											   );
			
			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DATA [0x%lx].", this, hr);
			
			switch ( hr )
			{
				//
				// user didn't keep the data, remove the reference added above
				//
				case DPN_OK:
				{
					DNASSERT( pReadData != NULL );
					pReadData->DecRef();
					break;
				}

				//
				// The user kept the data buffer, they will return it later.
				// Leave the reference to prevent this buffer from being returned
				// to the pool.
				//
				case DPNERR_PENDING:
				{
					break;
				}


				//
				// Unknown return.  Remove the reference added above.
				//
				default:
				{
					DNASSERT( pReadData != NULL );
					pReadData->DecRef();

					DPFX(DPFPREP,  0, "User returned unknown error when indicating user data!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// Endpoint disconnecting, or we haven't finished acknowledging a connect,
		// ignore data.
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 3, "Endpoint 0x%p ignoring data, state = %u.", this, m_State );
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ProcessUserDataOnListen - process received user data on a listen
//		port that may result in a new connection
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ProcessUserDataOnListen"

void	CModemEndpoint::ProcessUserDataOnListen( CModemReadIOData *const pReadData )
{
	HRESULT			hr;
	CModemEndpoint		*pNewEndpoint;
	SPIE_CONNECT	ConnectData;
	BOOL			fEndpointBound;


	DNASSERT( pReadData != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	DPFX(DPFPREP,  8, "Reporting connect on a listen!" );

	//
	// initialize
	//
	pNewEndpoint = NULL;
	fEndpointBound = FALSE;

	switch ( m_State )
	{
		//
		// this endpoint is still listening
		//
		case ENDPOINT_STATE_LISTENING:
		{
			break;
		}

		//
		// we're unable to process this user data, exti
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// get a new endpoint from the pool
	//
	pNewEndpoint = m_pSPData->GetNewEndpoint();
	if ( pNewEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not create new endpoint for new connection on listen!" );
		goto Failure;
	}


	//
	// We are adding this endpoint to the hash table and indicating it up
	// to the user, so it's possible that it could be disconnected (and thus
 	// removed from the table) while we're still in here.  We need to
 	// hold an additional reference for the duration of this function to
  	// prevent it from disappearing while we're still indicating data.
	//
	pNewEndpoint->AddCommandRef();


	//
	// open this endpoint as a new connection, since the new endpoint
	// is related to 'this' endpoint, copy local information
	//
	hr = pNewEndpoint->OpenOnListen( this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem initializing new endpoint when indicating connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Attempt to bind this endpoint to the socket port.  This will reserve our
	// slot before we notify the user.  If another message is attempting this same
	// procedure we won't be able to add this endpoint and we'll bail on the message.
	//
	DNASSERT( hr == DPN_OK );
	hr = m_pSPData->BindEndpoint( pNewEndpoint, pNewEndpoint->GetDeviceID(), pNewEndpoint->GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind endpoint to dataport on new connect from listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fEndpointBound = TRUE;

	//
	// Indicate connect on this endpoint.
	//
	DEBUG_ONLY( memset( &ConnectData, 0x00, sizeof( ConnectData ) ) );
	DBG_CASSERT( sizeof( ConnectData.hEndpoint ) == sizeof( pNewEndpoint ) );
	ConnectData.hEndpoint = (HANDLE)(DWORD_PTR)pNewEndpoint->GetHandle();

	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	ConnectData.pCommandContext = m_CurrentCommandParameters.ListenData.pvContext;

	DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
	hr = pNewEndpoint->SignalConnect( &ConnectData );
	switch ( hr )
	{
		//
		// user accepted new connection
		//
		case DPN_OK:
		{
			//
			// fall through to code below
			//

			break;
		}

		//
		// user refused new connection
		//
		case DPNERR_ABORTED:
		{
			DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
			DPFX(DPFPREP,  8, "User refused new connection!" );
			goto Failure;

			break;
		}

		//
		// other
		//
		default:
		{
			DPFX(DPFPREP,  0, "Unknown return when indicating connect event on new connect from listen!" );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );

			break;
		}
	}

	//
	// note that a connection has been establised and send the data received
	// through this new endpoint
	//
	pNewEndpoint->ProcessUserData( pReadData );


	//
	// Remove the reference we added just after creating the endpoint.
	//
	pNewEndpoint->DecCommandRef();
	pNewEndpoint = NULL;

Exit:
	return;

Failure:
	if ( pNewEndpoint != NULL )
	{
		if ( fEndpointBound != FALSE )
		{
			m_pSPData->UnbindEndpoint( pNewEndpoint, ENDPOINT_TYPE_CONNECT );
			fEndpointBound = FALSE;
		}

		//
		// closing endpoint decrements reference count and may return it to the pool
		//
		pNewEndpoint->Close( hr );
		m_pSPData->CloseEndpointHandle( pNewEndpoint );
		pNewEndpoint->DecCommandRef();	// remove reference added just after creating endpoint
		pNewEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::SettingsDialogComplete - dialog has completed
//
// Entry:		Error code for dialog
//
// Exit:		Nothing
// ------------------------------
void	CModemEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
{
	HRESULT					hr;


	//
	// initialize
	//
	hr = hDialogResult;

	//
	// since the dialog is exiting, clear our handle to the dialog
	//
	m_hActiveDialogHandle = NULL;

	//
	// dialog failed, fail the user's command
	//
	if ( hr != DPN_OK )
	{
		if ( hr != DPNERR_USERCANCEL)
		{
			DPFX(DPFPREP,  0, "Failing dialog (err = 0x%lx)!", hr );
		}

		goto Failure;
	}

	AddRef();

	//
	// the remote machine address has been adjusted, finish the command
	//
	switch ( GetType() )
	{
	    case ENDPOINT_TYPE_ENUM:
	    {
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( EnumQueryJobCallback,
																   CancelEnumQueryJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP,  0, "Failed to set delayed enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

	    case ENDPOINT_TYPE_CONNECT:
	    {
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ConnectJobCallback,
																   CancelConnectJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP,  0, "Failed to set delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

		case ENDPOINT_TYPE_LISTEN:
		{
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ListenJobCallback,
																   CancelListenJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP,  0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

	    //
	    // unknown!
	    //
	    default:
	    {
	    	DNASSERT( FALSE );
	    	hr = DPNERR_GENERIC;
	    	goto Failure;

	    	break;
	    }
	}

Exit:
	DecRef();

	return;

Failure:
	//
	// close this endpoint
	//
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CompletePendingCommand - complete an internal commad
//
// Entry:		Error code returned for command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CompletePendingCommand"

void	CModemEndpoint::CompletePendingCommand( const HRESULT hr )
{
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );

	DNASSERT( m_pSPData != NULL );

	
	DPFX(DPFPREP, 5, "Endpoint 0x%p completing command handle 0x%p (result = 0x%lx, user context 0x%p) to interface 0x%p.",
		this, m_pCommandHandle, hr,
		m_pCommandHandle->GetUserContext(),
		m_pSPData->DP8SPCallbackInterface());

	IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),	// pointer to SP callbacks
									m_pCommandHandle,			    		// command handle
									hr,								    	// return
									m_pCommandHandle->GetUserContext()		// user cookie
									);

	DPFX(DPFPREP, 5, "Endpoint 0x%p returning from command complete [0x%lx].", this, hr);


	m_Flags.fCommandPending = FALSE;
	m_pCommandHandle->DecRef();
	m_pCommandHandle = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetLinkDirection - get link direction for this endpoint
//
// Entry:		Nothing
//
// Exit:		Link direction
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetLinkDirection"

LINK_DIRECTION	CModemEndpoint::GetLinkDirection( void ) const
{
	LINK_DIRECTION	LinkDirection;


	LinkDirection = LINK_DIRECTION_OUTGOING;
	
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_LISTEN:
		{
			LinkDirection = LINK_DIRECTION_INCOMING;			
			break;
		}

		//
		// connect and enum are outgoing
		//
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( LinkDirection == LINK_DIRECTION_OUTGOING );
			break;
		}

		//
		// shouldn't be here
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	LinkDirection;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemEndpoint::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ReturnSelfToPool"

void	CModemEndpoint::ReturnSelfToPool( void )
{
	if ( m_Flags.fCommandPending != FALSE )
	{
		CompletePendingCommand( PendingCommandResult() );
	}

	if ( m_Flags.fConnectIndicated != FALSE )
	{
		SignalDisconnect( GetDisconnectIndicationHandle() );
	}
	
	DNASSERT( m_Flags.fConnectIndicated == FALSE );

	memset( m_PhoneNumber, 0x00, sizeof( m_PhoneNumber ) );
	
	SetUserEndpointContext( NULL );
	
	if (m_fModem)
	{
		g_ModemEndpointPool.Release( this );
	}
	else
	{
		g_ComEndpointPool.Release( this );
	}
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to pool context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolAllocFunction"

BOOL	CModemEndpoint::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CModemEndpoint* pEndpoint = (CModemEndpoint*)pvItem;
	const ENDPOINT_POOL_CONTEXT* pEPContext = (ENDPOINT_POOL_CONTEXT*)pvContext;

	DNASSERT( pEPContext != NULL );

	pEndpoint->m_fModem = pEPContext->fModem;

	pEndpoint->m_Sig[0] = 'M';
	pEndpoint->m_Sig[1] = 'O';
	pEndpoint->m_Sig[2] = 'E';
	pEndpoint->m_Sig[3] = 'P';
	
	memset( &pEndpoint->m_PhoneNumber, 0x00, sizeof( pEndpoint->m_PhoneNumber ) );

	pEndpoint->m_dwDeviceID = INVALID_DEVICE_ID;

	//
	// initialize base object
	//

	pEndpoint->m_pSPData = NULL;
	pEndpoint->m_pCommandHandle = NULL;
	pEndpoint->m_Handle = 0;
	pEndpoint->m_State = ENDPOINT_STATE_UNINITIALIZED;
	pEndpoint->m_lCommandRefCount = 0;
	pEndpoint->m_EndpointType = ENDPOINT_TYPE_UNKNOWN;
	pEndpoint->m_pDataPort = NULL;
	pEndpoint->m_hPendingCommandResult = DPNERR_GENERIC;
	pEndpoint->m_hDisconnectIndicationHandle = 0;
	pEndpoint->m_pUserEndpointContext = NULL;
	pEndpoint->m_hActiveDialogHandle = NULL;
	pEndpoint->m_dwEnumSendIndex = 0;
	pEndpoint->m_iRefCount =  0;

	pEndpoint->m_Flags.fConnectIndicated = FALSE;
	pEndpoint->m_Flags.fCommandPending = FALSE;
	pEndpoint->m_Flags.fListenStatusNeedsToBeIndicated = FALSE;

	pEndpoint->m_ComPortData.Reset();

	memset( &pEndpoint->m_CurrentCommandParameters, 0x00, sizeof( pEndpoint->m_CurrentCommandParameters ) );
	memset( &pEndpoint->m_Flags, 0x00, sizeof( pEndpoint->m_Flags ) );

	if ( DNInitializeCriticalSection( &pEndpoint->m_Lock ) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize endpoint lock!" );
		return FALSE;
	}
	DebugSetCriticalSectionRecursionCount( &pEndpoint->m_Lock, 0 );
	DebugSetCriticalSectionGroup( &pEndpoint->m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes

	pEndpoint->m_Flags.fInitialized = TRUE;
	
	return	TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolInitFunction - function called when item is created in pool
//
// Entry:		Pointer to pool context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolInitFunction"

void	CModemEndpoint::PoolInitFunction( void* pvItem, void* pvContext )
{
	CModemEndpoint* pEndpoint = (CModemEndpoint*)pvItem;
	ENDPOINT_POOL_CONTEXT* pEPContext = (ENDPOINT_POOL_CONTEXT*)pvContext;

	DNASSERT( pEPContext != NULL );
	DNASSERT( pEndpoint->m_pSPData == NULL );
	DNASSERT( pEndpoint->GetState() == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( pEndpoint->GetType() == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( pEndpoint->GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( pEndpoint->GetDisconnectIndicationHandle() == 0 );
	
	pEndpoint->m_pSPData = pEPContext->pSPData;
	pEndpoint->m_pSPData->ObjectAddRef();

	//
	// set reasonable defaults
	//
	pEndpoint->m_ComPortData.SetBaudRate( CBR_57600 );
	pEndpoint->m_ComPortData.SetStopBits( ONESTOPBIT );
	pEndpoint->m_ComPortData.SetParity( NOPARITY );
	pEndpoint->m_ComPortData.SetFlowControl( FLOW_RTSDTR );

	DNASSERT(pEndpoint->m_iRefCount == 0);
	pEndpoint->m_iRefCount = 1;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolReleaseFunction - function called when returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolReleaseFunction"

void	CModemEndpoint::PoolReleaseFunction( void* pvItem )
{
	CModemSPData	*pSPData;

	CModemEndpoint* pEndpoint = (CModemEndpoint*)pvItem;

	DNASSERT(pEndpoint->m_iRefCount == 0);

	//
	// deinitialize base object
	//
	DNASSERT( pEndpoint->m_pSPData != NULL );
	pSPData = pEndpoint->m_pSPData;
	pEndpoint->m_pSPData = NULL;

	pEndpoint->m_ComPortData.Reset();
	pEndpoint->SetType( ENDPOINT_TYPE_UNKNOWN );
	pEndpoint->SetState( ENDPOINT_STATE_UNINITIALIZED );
	pEndpoint->SetDeviceID( INVALID_DEVICE_ID );
	DNASSERT( pEndpoint->GetDisconnectIndicationHandle() == 0 );

	DNASSERT( pEndpoint->m_Flags.fConnectIndicated == FALSE );
	DNASSERT( pEndpoint->m_Flags.fCommandPending == FALSE );
	DNASSERT( pEndpoint->m_Flags.fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( pEndpoint->m_pCommandHandle == NULL );
	DNASSERT( pEndpoint->m_hActiveDialogHandle == NULL );

	pSPData->ObjectDecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolDeallocFunction - function called when deleted from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolDeallocFunction"

void	CModemEndpoint::PoolDeallocFunction( void* pvItem )
{
	CModemEndpoint* pEndpoint = (CModemEndpoint*)pvItem;

	DNASSERT( pEndpoint->m_Flags.fInitialized != FALSE );
	DNDeleteCriticalSection( &pEndpoint->m_Lock );
	pEndpoint->m_pSPData = NULL;
	
	DNASSERT( pEndpoint->m_pCommandHandle == NULL );
	DNASSERT( pEndpoint->m_Flags.fCommandPending == FALSE );

	pEndpoint->SetState( ENDPOINT_STATE_UNINITIALIZED );
	pEndpoint->SetType( ENDPOINT_TYPE_UNKNOWN );
	
	DNASSERT( pEndpoint->GetDataPort() == NULL );
	pEndpoint->m_Flags.fInitialized = FALSE;

	DNASSERT( pEndpoint->GetDeviceID() == INVALID_DEVICE_ID );

	DNASSERT( pEndpoint->GetDisconnectIndicationHandle() == 0 );
	DNASSERT( pEndpoint->m_pSPData == NULL );
	DNASSERT( pEndpoint->m_Flags.fInitialized == FALSE );
	DNASSERT( pEndpoint->m_Flags.fConnectIndicated == FALSE );
	DNASSERT( pEndpoint->m_Flags.fCommandPending == FALSE );
	DNASSERT( pEndpoint->m_Flags.fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( pEndpoint->m_pCommandHandle == NULL );
	DNASSERT( pEndpoint->m_Handle == 0 );
	DNASSERT( pEndpoint->m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( pEndpoint->m_lCommandRefCount == 0 );
	DNASSERT( pEndpoint->m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( pEndpoint->m_pDataPort == NULL );
//	DNASSERT( pEndpoint->m_hPendingCommandResult == DPNERR_GENERIC );	MASONB:	NOTE: PreFAST caught a bug here because == was =, but it now asserts.  Check intent.
	DNASSERT( pEndpoint->m_pUserEndpointContext == NULL );
	DNASSERT( pEndpoint->m_hActiveDialogHandle == NULL );
	DNASSERT( pEndpoint->m_dwEnumSendIndex == 0 );

	DNASSERT( pEndpoint->m_iRefCount == 0 );
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemEndpoint::Open - open communications with endpoint
//
// Entry:		Pointer to host address
//				Pointer to adapter address
//				Link direction
//				Endpoint type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::Open"

HRESULT CModemEndpoint::Open( IDirectPlay8Address *const pHostAddress,
							  IDirectPlay8Address *const pAdapterAddress,
							  const LINK_DIRECTION LinkDirection,
							  const ENDPOINT_TYPE EndpointType )
{
	HRESULT		hr;
	HRESULT		hDeviceResult;
	GUID		ModemDeviceGuid;


	DNASSERT( pAdapterAddress != NULL );

	DNASSERT( ( LinkDirection == LINK_DIRECTION_INCOMING ) ||
			  ( LinkDirection == LINK_DIRECTION_OUTGOING ) );
	DNASSERT( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
			  ( EndpointType == ENDPOINT_TYPE_ENUM ) ||
			  ( EndpointType == ENDPOINT_TYPE_LISTEN ) ||
			  ( EndpointType == ENDPOINT_TYPE_CONNECT_ON_LISTEN ) );
	DNASSERT( ( ( pHostAddress != NULL ) && ( LinkDirection == LINK_DIRECTION_OUTGOING ) ) ||
			  ( ( pHostAddress == NULL ) && ( LinkDirection == LINK_DIRECTION_INCOMING ) ) );

	//
	// initialize
	//
	hr = DPN_OK;

	if (m_fModem)
	{
		DNASSERT( lstrlen( m_PhoneNumber ) == 0 );
		DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );

		hDeviceResult = IDirectPlay8Address_GetDevice( pAdapterAddress, &ModemDeviceGuid );
		switch ( hDeviceResult )
		{
			case DPN_OK:
			{
				SetDeviceID( GuidToDeviceID( &ModemDeviceGuid, &g_ModemSPEncryptionGuid ) );
				break;
			}

			case DPNERR_DOESNOTEXIST:
			{
				DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
				break;
			}

			default:
			{
				hr = hDeviceResult;
				DPFX(DPFPREP,  0, "Failed to get modem device!" );
				DisplayDNError( 0, hr);
				goto Failure;
			}
		}

		if ( LinkDirection == LINK_DIRECTION_OUTGOING )
		{
			HRESULT		hPhoneNumberResult;
			DWORD		dwWCHARPhoneNumberSize;
			DWORD		dwDataType;
			WCHAR		PhoneNumber[ LENGTHOF( m_PhoneNumber ) ];


			dwWCHARPhoneNumberSize = sizeof( PhoneNumber );
			hPhoneNumberResult = IDirectPlay8Address_GetComponentByName( pHostAddress,
																		 DPNA_KEY_PHONENUMBER,
																		 PhoneNumber,
																		 &dwWCHARPhoneNumberSize,
																		 &dwDataType );
			switch ( hPhoneNumberResult )
			{
				case DPN_OK:
				{
#ifdef UNICODE
					lstrcpy(m_PhoneNumber, PhoneNumber);
#else
					DWORD	dwASCIIPhoneNumberSize;

					//
					// can't use the STR_ functions to convert ANSI to WIDE phone
					// numbers because phone numbers with symbols: "9,", "*70" are
					// interpreted as already being WCHAR when they're not!
					//
					dwASCIIPhoneNumberSize = sizeof( m_PhoneNumber );
					DNASSERT( dwDataType == DPNA_DATATYPE_STRING );
					hr = PhoneNumberFromWCHAR( PhoneNumber, m_PhoneNumber, &dwASCIIPhoneNumberSize );
					DNASSERT( hr == DPN_OK );
#endif // UNICODE

					break;
				}

				case DPNERR_DOESNOTEXIST:
				{
					break;
				}

				default:
				{
					hr = hPhoneNumberResult;
					DPFX(DPFPREP,  0, "Failed to process phone number!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}
			}
		}

		if ( ( GetDeviceID() == INVALID_DEVICE_ID ) ||
			 ( ( LinkDirection == LINK_DIRECTION_OUTGOING ) && ( lstrlen( m_PhoneNumber ) == 0 ) ) )
		{
			hr = DPNERR_INCOMPLETEADDRESS;
			goto Failure;
		}
	}
	else // !m_fModem
	{
		hr = m_ComPortData.ComPortDataFromDP8Addresses( pHostAddress, pAdapterAddress );
	}

Exit:
	SetType( EndpointType );

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CModemEndpoint::Open" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::OpenOnListen - open this endpoint when data is received on a listen
//
// Entry:		Nothing
//
// Exit:		Noting
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::OpenOnListen"

HRESULT	CModemEndpoint::OpenOnListen( const CModemEndpoint *const pListenEndpoint )
{
	HRESULT	hr;


	DNASSERT( pListenEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	if (m_fModem)
	{
		SetDeviceID( pListenEndpoint->GetDeviceID() );
	}
	else
	{
		m_ComPortData.Copy( pListenEndpoint->GetComPortData() );
	}
	SetType( ENDPOINT_TYPE_CONNECT_ON_LISTEN );
	SetState( ENDPOINT_STATE_ATTEMPTING_CONNECT );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::Close - close this endpoint
//
// Entry:		Nothing
//
// Exit:		Noting
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::Close"

void	CModemEndpoint::Close( const HRESULT hActiveCommandResult )
{
	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%lx)", this, hActiveCommandResult);

	
	//
	// Set the command result so it can be returned when the endpoint reference
	// count is zero.
	//
	SetCommandResult( hActiveCommandResult );


	DPFX(DPFPREP, 6, "(0x%p) Leaving", this);
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemEndpoint::GetLinkSpeed - get speed of link
//
// Entry:		Nothing
//
// Exit:		Link speed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CModemEndpoint::GetLinkSpeed"

DWORD	CModemEndpoint::GetLinkSpeed( void ) const
{
	return	GetBaudRate();
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CModemEndpoint::EnumComplete - enumeration has completed
//
// Entry:		Command completion code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::EnumComplete"

void	CModemEndpoint::EnumComplete( const HRESULT hCommandResult )
{
	Close( hCommandResult );
	m_pSPData->CloseEndpointHandle( this );
	m_dwEnumSendIndex = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetDeviceContext - get device context to initialize data port
//
// Entry:		Nothing
//
// Exit:		Device context
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetDeviceContext"

const void	*CModemEndpoint::GetDeviceContext( void ) const
{
	if (m_fModem)
	{
		return	NULL;
	}
	else
	{
		return	&m_ComPortData;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetRemoteHostDP8Address - get address of remote host
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetRemoteHostDP8Address"

IDirectPlay8Address	*CModemEndpoint::GetRemoteHostDP8Address( void ) const
{
	IDirectPlay8Address	*pAddress;
	HRESULT	hr;

	if (!m_fModem)
	{
		return	GetLocalAdapterDP8Address( ADDRESS_TYPE_REMOTE_HOST );
	}

	//
	// initialize
	//
	pAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IDirectPlay8Address,
							   reinterpret_cast<void**>( &pAddress ), FALSE );
	if ( hr != DPN_OK )
	{
		DNASSERT( pAddress == NULL );
		DPFX(DPFPREP,  0, "GetRemoteHostDP8Address: Failed to create Address when converting data port to address!" );
		goto Failure;
	}

	//
	// set the SP guid
	//
	hr = IDirectPlay8Address_SetSP( pAddress, &CLSID_DP8SP_MODEM );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "GetRemoteHostDP8Address: Failed to set service provider GUID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Host names can only be returned for connect and enum endpoints.  Host
	// names are the phone numbers that were called and will be unknown on a
	// 'listen' endpoint.
	//
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_ENUM:
		case ENDPOINT_TYPE_CONNECT:
		{
			DWORD	dwPhoneNumberLength;


			dwPhoneNumberLength = lstrlen( m_PhoneNumber );
			if ( dwPhoneNumberLength != 0 )
			{
#ifdef UNICODE
				hr = IDirectPlay8Address_AddComponent( pAddress,
													   DPNA_KEY_PHONENUMBER,
													   m_PhoneNumber,
													   (dwPhoneNumberLength + 1) * sizeof( *m_PhoneNumber ),
													   DPNA_DATATYPE_STRING );
#else
				WCHAR	WCHARPhoneNumber[ sizeof( m_PhoneNumber ) ];
				DWORD	dwWCHARPhoneNumberLength;

				//
				// can't use the STR_ functions to convert ANSI to WIDE phone
				// numbers because phone numbers with symbols: "9,", "*70" are
				// interpreted as already being WCHAR when they're not!
				//
				dwWCHARPhoneNumberLength = LENGTHOF( WCHARPhoneNumber );
				hr = PhoneNumberToWCHAR( m_PhoneNumber, WCHARPhoneNumber, &dwWCHARPhoneNumberLength );
				DNASSERT( hr == DPN_OK );

				hr = IDirectPlay8Address_AddComponent( pAddress,
													   DPNA_KEY_PHONENUMBER,
													   WCHARPhoneNumber,
													   dwWCHARPhoneNumberLength * sizeof( *WCHARPhoneNumber ),
													   DPNA_DATATYPE_STRING );
#endif // UNICODE
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP,  0, "GetRemoteHostDP8Address: Failed to add phone number to hostname!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}
			}
			
			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}

	}

Exit:
	return	pAddress;

Failure:
	if ( pAddress != NULL )
	{
		IDirectPlay8Address_Release( pAddress );
		pAddress = NULL;
	}
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetLocalAdapterDP8Address - get address from local adapter
//
// Entry:		Adadpter address format
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetLocalAdapterDP8Address"

IDirectPlay8Address	*CModemEndpoint::GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const
{
	CDataPort	*pDataPort;

	DNASSERT( GetDataPort() != NULL );
	pDataPort = GetDataPort();

	if (m_fModem)
	{
		return	pDataPort->GetLocalAdapterDP8Address( AddressType );
	}
	else
	{
		return	pDataPort->ComPortData()->DP8AddressFromComPortData( AddressType );
	}
}
//**********************************************************************

#ifndef DPNBUILD_NOSPUI

//**********************************************************************
// ------------------------------
// CModemEndpoint::ShowIncomingSettingsDialog - show dialog for incoming modem settings
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ShowIncomingSettingsDialog"

HRESULT	CModemEndpoint::ShowIncomingSettingsDialog( CModemThreadPool *const pThreadPool )
{
	HRESULT	hr;
	DIALOG_FUNCTION* pFunction;

	if (m_fModem)
	{
		pFunction = DisplayIncomingModemSettingsDialog;
	}
	else
	{
		pFunction = DisplayComPortSettingsDialog;
	}

	DNASSERT( pThreadPool != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( pFunction, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start incoming modem dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ShowOutgoingSettingsDialog - show settings dialog for outgoing
//		modem connection
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ShowOutgoingSettingsDialog"

HRESULT	CModemEndpoint::ShowOutgoingSettingsDialog( CModemThreadPool *const pThreadPool )
{
	HRESULT	hr;
	DIALOG_FUNCTION* pFunction;


	DNASSERT( pThreadPool != NULL );

	if (m_fModem)
	{
		pFunction = DisplayOutgoingModemSettingsDialog;
	}
	else
	{
		pFunction = DisplayComPortSettingsDialog;
	}

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( pFunction, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start incoming modem dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::StopSettingsDialog - stop a settings dialog
//
// Entry:		Dialog handle
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::StopSettingsDialog"

void	CModemEndpoint::StopSettingsDialog( const HWND hDialog )
{
	if (m_fModem)
	{
		StopModemSettingsDialog( hDialog );
	}
	else
	{
		StopComPortSettingsDialog( hDialog );
	}
}
//**********************************************************************

#endif // !DPNBUILD_NOSPUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemendpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Endpoint.h
 *  Content:	DNSerial communications endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 ***************************************************************************/

#ifndef __ENDPOINT_H__
#define __ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	MAX_PHONE_NUMBER_SIZE	200

//
// enumeration of endpoint types
//
typedef	enum	_ENDPOINT_TYPE
{
	ENDPOINT_TYPE_UNKNOWN = 0,			// unknown endpoint type
	ENDPOINT_TYPE_LISTEN,				// 'Listen' endpoint
	ENDPOINT_TYPE_CONNECT,				// 'Conenct' endpoint
	ENDPOINT_TYPE_ENUM,					// 'Enum' endpoint
	ENDPOINT_TYPE_CONNECT_ON_LISTEN		// endpoint connected from a 'listen'
} ENDPOINT_TYPE;

//
// enumeration of the states an endpoint can be in
//
typedef	enum
{
	ENDPOINT_STATE_UNINITIALIZED = 0,		// uninitialized state
	ENDPOINT_STATE_ATTEMPTING_ENUM,			// attempting to enum
	ENDPOINT_STATE_ENUM,					// endpoint is supposed to enum connections
	ENDPOINT_STATE_ATTEMPTING_CONNECT,		// attempting to connect
	ENDPOINT_STATE_CONNECT_CONNECTED,		// endpoint is supposed to connect and is connected
	ENDPOINT_STATE_ATTEMPTING_LISTEN,		// attempting to listen
	ENDPOINT_STATE_LISTENING,				// endpoint is supposed to listen and is listening
	ENDPOINT_STATE_DISCONNECTING,			// endpoint is disconnecting

	ENDPOINT_STATE_MAX
} ENDPOINT_STATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
typedef	struct	_JOB_HEADER			JOB_HEADER;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
class	CModemCommandData;
class	CDataPort;
class	CModemReadIOData;
class	CModemThreadPool;
class	CModemWriteIOData;

//
// structure used to get data from the endpoint port pool
//
typedef	struct	_ENDPOINT_POOL_CONTEXT
{
	CModemSPData *pSPData;
	BOOL	fModem;
} ENDPOINT_POOL_CONTEXT;

//
// structure to bind extra information to an enum query to be used on enum reponse
//
typedef	struct	_ENDPOINT_ENUM_QUERY_CONTEXT
{
	SPIE_QUERY	EnumQueryData;
	HANDLE		hEndpoint;
	UINT_PTR	uEnumRTTIndex;
} ENDPOINT_ENUM_QUERY_CONTEXT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CModemEndpoint
{
	public:

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::Lock"
		void	Lock( void )
		{
			DNASSERT( m_Flags.fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_Flags.fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		void	ReturnSelfToPool( void );
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::AddRef"
		void	AddRef( void ) 
		{ 
			DNASSERT( m_iRefCount != 0 );
			DNInterlockedIncrement( &m_iRefCount ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		void	AddCommandRef( void )
		{
			DNInterlockedIncrement( &m_lCommandRefCount );
			AddRef();
		}

		void	DecCommandRef( void )
		{
			if ( DNInterlockedDecrement( &m_lCommandRefCount ) == 0 )
			{
				CleanUpCommand();
			}
			DecRef();
		}
		
		DPNHANDLE	GetHandle( void ) const { return m_Handle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetHandle"
		void	SetHandle( const DPNHANDLE Handle )
		{
			DNASSERT( ( m_Handle == 0 ) || ( Handle == 0 ) );
			m_Handle = Handle;
		}

		const CComPortData	*ComPortData( void ) const { return &m_ComPortData; }
		const SP_BAUD_RATE	GetBaudRate( void ) const { return m_ComPortData.GetBaudRate(); }
		HRESULT	SetBaudRate( const SP_BAUD_RATE BaudRate ) { return m_ComPortData.SetBaudRate( BaudRate ); }

		const SP_STOP_BITS	GetStopBits( void ) const { return m_ComPortData.GetStopBits(); }
		HRESULT	SetStopBits( const SP_STOP_BITS StopBits ) { return m_ComPortData.SetStopBits( StopBits ); }

		const SP_PARITY_TYPE	GetParity( void ) const  { return m_ComPortData.GetParity(); }
		HRESULT	SetParity( const SP_PARITY_TYPE Parity ) { return m_ComPortData.SetParity( Parity ); }

		const SP_FLOW_CONTROL	GetFlowControl( void ) const { return m_ComPortData.GetFlowControl(); }
		HRESULT	SetFlowControl( const SP_FLOW_CONTROL FlowControl ) { return m_ComPortData.SetFlowControl( FlowControl ); }

		const CComPortData	*GetComPortData( void ) const { return &m_ComPortData; }

		const GUID	*GetEncryptionGuid( void ) const 
		{ 
			if (m_fModem)
			{
				return &g_ModemSPEncryptionGuid;
			}
			else
			{
				return &g_SerialSPEncryptionGuid; 
			}
		}

		const TCHAR	*GetPhoneNumber( void ) const { return m_PhoneNumber; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetPhoneNumber"
		HRESULT	SetPhoneNumber( const TCHAR *const pPhoneNumber )
		{
			DNASSERT( pPhoneNumber != NULL );
			DNASSERT( lstrlen( pPhoneNumber ) < ( sizeof( m_PhoneNumber ) / sizeof( TCHAR ) ) );
			lstrcpyn( m_PhoneNumber, pPhoneNumber, MAX_PHONE_NUMBER_SIZE );
			return	DPN_OK;
		}

		void	*DeviceBindContext( void ) { return &m_dwDeviceID; }

		CDataPort	*GetDataPort( void ) const { return m_pDataPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetDataPort"
		void	SetDataPort( CDataPort *const pDataPort )
		{
			DNASSERT( ( m_pDataPort == NULL ) || ( pDataPort == NULL ) );
			m_pDataPort = pDataPort;
		}

		ENDPOINT_TYPE	GetType( void ) const { return m_EndpointType; }

		void	*GetUserEndpointContext( void ) const { return m_pUserEndpointContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetUserEndpointContext"
		void	SetUserEndpointContext( void *const pContext )
		{
			DNASSERT( ( m_pUserEndpointContext == NULL ) || ( pContext == NULL ) );
			m_pUserEndpointContext = pContext;
		}

		ENDPOINT_STATE	GetState( void ) const { return m_State; }
		void	SetState( const ENDPOINT_STATE EndpointState );
		CModemSPData	*GetSPData( void ) const { return m_pSPData; }

		CModemCommandData	*GetCommandData( void ) const { return m_pCommandHandle; }
		DPNHANDLE	GetDisconnectIndicationHandle( void ) const { return this->m_hDisconnectIndicationHandle; }
		void	SetDisconnectIndicationHandle( const DPNHANDLE hDisconnectIndicationHandle )
		{
			DNASSERT( ( GetDisconnectIndicationHandle() == 0 ) ||
					  ( hDisconnectIndicationHandle == 0 ) );
			m_hDisconnectIndicationHandle = hDisconnectIndicationHandle;
		}

		void	CopyConnectData( const SPCONNECTDATA *const pConnectData );
		static	void	ConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteConnect( void );

		void	CopyListenData( const SPLISTENDATA *const pListenData );
		static	void	ListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteListen( void );

		void	CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData );
		static	void	EnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteEnumQuery( void );
		void	OutgoingConnectionEstablished( const HRESULT hCommandResult );

		HRESULT	Open( IDirectPlay8Address *const pHostAddress,
					  IDirectPlay8Address *const pAdapterAddress,
					  const LINK_DIRECTION LinkDirection,
					  const ENDPOINT_TYPE EndpointType );
		HRESULT	OpenOnListen( const CModemEndpoint *const pEndpoint );
		void	Close( const HRESULT hActiveCommandResult );
		DWORD	GetLinkSpeed( void ) const;

		HRESULT	Disconnect( const DPNHANDLE hOldEndpointHandle );
		void	SignalDisconnect( const DPNHANDLE hOldEndpointHandle );

		//
		// send functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SendUserData"
		void	SendUserData( CModemWriteIOData *const pWriteBuffer )
		{
			DNASSERT( pWriteBuffer != NULL );
			DNASSERT( m_pDataPort != NULL );
			m_pDataPort->SendUserData( pWriteBuffer );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SendEnumResponseData"
		void	SendEnumResponseData( CModemWriteIOData *const pWriteBuffer, const UINT_PTR uRTTIndex )
		{
			DNASSERT( pWriteBuffer != NULL );
			DNASSERT( m_pDataPort != NULL );
			m_pDataPort->SendEnumResponseData( pWriteBuffer, uRTTIndex );
		}

		void	StopEnumCommand( const HRESULT hCommandResult );

		LINK_DIRECTION	GetLinkDirection( void ) const;

		//
		// dialog settings
		//
		IDirectPlay8Address	*GetRemoteHostDP8Address( void ) const;
		IDirectPlay8Address	*GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const;

		//
		// data processing functions
		//
		void	ProcessEnumData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uRTTIndex );
		void	ProcessEnumResponseData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uRTTIndex );
		void	ProcessUserData( CModemReadIOData *const pReadData );
		void	ProcessUserDataOnListen( CModemReadIOData *const pReadData );

#ifndef DPNBUILD_NOSPUI
		//
		// UI functions
		//
		HRESULT	ShowOutgoingSettingsDialog( CModemThreadPool *const pThreadPool );
		HRESULT	ShowIncomingSettingsDialog( CModemThreadPool *const pThreadPool );
		void	StopSettingsDialog( const HWND hDialog );

		void	SettingsDialogComplete( const HRESULT hDialogReturnCode );

		HWND	ActiveDialogHandle( void ) const { return m_hActiveDialogHandle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetActiveDialogHandle"
		void	SetActiveDialogHandle( const HWND hDialog )
		{
			DNASSERT( ( ActiveDialogHandle() == NULL ) || ( hDialog == NULL ) );
			m_hActiveDialogHandle = hDialog;
		}
#endif // !DPNBUILD_NOSPUI

		//
		// port settings
		//
		DWORD	GetDeviceID( void ) const 
		{ 
			if (m_fModem)
			{
				return m_dwDeviceID;
			}
			else
			{
				return m_ComPortData.GetDeviceID(); 
			}
		}
		HRESULT	SetDeviceID( const DWORD dwDeviceID ) 
		{ 
			if (m_fModem)
			{
				DNASSERT( ( m_dwDeviceID == INVALID_DEVICE_ID ) || ( dwDeviceID == INVALID_DEVICE_ID ) );
				m_dwDeviceID = dwDeviceID;
				return	DPN_OK;
			}
			else
			{
				return m_ComPortData.SetDeviceID( dwDeviceID ); 
			}
		}

		//
		// pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );


	protected:
		BYTE			m_Sig[4];	// debugging signature ('THPL')

		CModemSPData			*m_pSPData;					// pointer to SP data

		BOOL			m_fModem;

		CComPortData	m_ComPortData;

		DWORD	m_dwDeviceID;
		TCHAR	m_PhoneNumber[ MAX_PHONE_NUMBER_SIZE ];

		struct
		{
			BOOL	fInitialized : 1;
			BOOL	fConnectIndicated : 1;
			BOOL	fCommandPending : 1;
			BOOL	fListenStatusNeedsToBeIndicated : 1;
		} m_Flags;
		
		DWORD		m_dwEnumSendIndex;			// enum send index
		DWORD		m_dwEnumSendTimes[ 4 ];		// enum send times

		union									// Local copy of the pending command paramters.
		{										// This data contains the pointers to the active
			SPCONNECTDATA	ConnectData;		// command, and the user context.
			SPLISTENDATA	ListenData;			//
			SPENUMQUERYDATA	EnumQueryData;		//
		} m_CurrentCommandParameters;			//

		CModemCommandData	*m_pCommandHandle;		// pointer to active command (this is kept to
												// avoid a switch to go through the m_ActveCommandData
												// to find the command handle)

		HWND			m_hActiveDialogHandle;	// handle of active dialog

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetType"
		void	SetType( const ENDPOINT_TYPE EndpointType )
		{
			DNASSERT( ( m_EndpointType == ENDPOINT_TYPE_UNKNOWN ) || ( EndpointType == ENDPOINT_TYPE_UNKNOWN ) );
			m_EndpointType = EndpointType;
		}

		CModemCommandData	*CommandHandle( void ) const;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetCommandHandle"
		void	SetCommandHandle( CModemCommandData *const pCommandHandle )
		{
			DNASSERT( ( m_pCommandHandle == NULL ) || ( pCommandHandle == NULL ) );
			m_pCommandHandle = pCommandHandle;
		}

		HRESULT	CommandResult( void ) const { return m_hPendingCommandResult; }
		void	SetCommandResult( const HRESULT hCommandResult ) { m_hPendingCommandResult = hCommandResult; }

		void	CompletePendingCommand( const HRESULT hResult );
		HRESULT	PendingCommandResult( void ) const { return m_hPendingCommandResult; }

		static void		EnumCompleteWrapper( const HRESULT hCompletionCode, void *const pContext );	
		static void		EnumTimerCallback( void *const pContext );
		void	EnumComplete( const HRESULT hCompletionCode );
		
		HRESULT	SignalConnect( SPIE_CONNECT *const pConnectData );
		const void	*GetDeviceContext( void ) const;
		void	CleanUpCommand( void );

#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_Lock;	   					// critical section
#endif // !DPNBUILD_ONLYONETHREAD
		DPNHANDLE				m_Handle;					// active handle for this endpoint
		volatile ENDPOINT_STATE	m_State;				// endpoint state
		
		volatile LONG			m_lCommandRefCount;		// Command ref count.  When this
														// goes to zero, the endpoint unbinds
														// from the network
		volatile LONG		m_iRefCount;

		ENDPOINT_TYPE	m_EndpointType;					// type of endpoint
		CDataPort		*m_pDataPort;					// pointer to associated data port

		HRESULT			m_hPendingCommandResult;		// command result returned when endpoint RefCount == 0
		DPNHANDLE			m_hDisconnectIndicationHandle;	// handle to be indicated with disconnect notification.

		void			*m_pUserEndpointContext;		// user context associated with this endpoint

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CModemEndpoint( const CModemEndpoint & );
		CModemEndpoint& operator=( const CModemEndpoint & );
};

#undef DPF_MODNAME

#endif	// __ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemiodata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.h
 *  Content:	Structure definitions for IOData for the DNSerial service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 *	09/14/99	jtk		Dereived from Locals.h
 ***************************************************************************/

#ifndef __IODDATA_H__
#define __IODDATA_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated types for what action to take when a send completes
//
typedef	enum	_SEND_COMPLETE_ACTION
{
	SEND_COMPLETE_ACTION_UNKNOWN = 0,				// unknown value
	SEND_COMPLETE_ACTION_NONE,						// no action
	SEND_COMPLETE_ACTION_COMPLETE_COMMAND			// complete command
} SEND_COMPLETE_ACTION;

//
// enumerated values for state of reads
//
typedef	enum	_READ_STATE
{
	READ_STATE_UNKNOWN,			// unknown state
//	READ_STATE_INITIALIZE,		// initialize state machine
	READ_STATE_READ_HEADER,		// read header information
	READ_STATE_READ_DATA		// read message data
} READ_STATE;

typedef	enum	_NT_IO_OPERATION_TYPE
{
	NT_IO_OPERATION_UNKNOWN,
	NT_IO_OPERATION_RECEIVE,
	NT_IO_OPERATION_SEND
} NT_IO_OPERATION_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
//typedef	struct	_RECEIVE_BUFFER	RECEIVE_BUFFER;
class	CModemCommandData;
class	CDataPort;
class	CIOData;
class	CModemThreadPool;

//
// structure used to prefix a message on the wire for framing
//
#pragma pack( push, 1 )
typedef	struct _MESSAGE_HEADER
{
	BYTE	SerialSignature;	// serial signature
	BYTE	MessageTypeToken;	// token to indicate message type
	WORD	wMessageSize;		// message data size
	WORD	wMessageCRC;		// CRC of message data
	WORD	wHeaderCRC;			// CRC of header

} MESSAGE_HEADER;
#pragma pack( pop )


//
// class containing all data for I/O completion
//
class	CIOData
{
	public:
		CDataPort	*DataPort( void ) const { return m_pDataPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetDataPort"
		void	SetDataPort( CDataPort *const pDataPort )
		{
			DNASSERT( ( m_pDataPort == NULL ) || ( pDataPort == NULL ) );
			m_pDataPort = pDataPort;
		}

#ifdef WIN95
		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
#endif // WIN95

#ifdef WINNT
		NT_IO_OPERATION_TYPE	NTIOOperationType( void ) const { return m_NTIOOperationType; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetNTIOOperationType"
		void	SetNTIOOperationType( const NT_IO_OPERATION_TYPE OperationType )
		{
			DNASSERT( ( OperationType == NT_IO_OPERATION_UNKNOWN ) ||
					  ( m_NTIOOperationType == NT_IO_OPERATION_UNKNOWN ) );
			m_NTIOOperationType = OperationType;
		}
#endif // WINNT

		OVERLAPPED	*Overlap( void ) { return &m_Overlap; }
#ifdef WIN95
		HANDLE	OverlapEvent( void ) const { return m_Overlap.hEvent; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetOverlapEvent"
		void	SetOverlapEvent( const HANDLE hEvent )
		{
			DNASSERT( ( m_Overlap.hEvent == NULL ) || ( hEvent == NULL ) );
			m_Overlap.hEvent = hEvent;
		}
#endif // WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::IODataFromOverlap"
		static	CIOData	*IODataFromOverlap( OVERLAPPED *const pOverlap )
		{
			DNASSERT( pOverlap != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pOverlap ) );
			DBG_CASSERT( sizeof( CIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CIOData*>( &reinterpret_cast<BYTE*>( pOverlap )[ -OFFSETOF( CIOData, m_Overlap ) ] );
		}

	protected:

		OVERLAPPED	m_Overlap;		// overlapped I/O structure

#ifdef WINNT
		NT_IO_OPERATION_TYPE	m_NTIOOperationType;
#endif // WINNT

		CDataPort		*m_pDataPort;   						// pointer to data port associated with this IO request
#ifdef WIN95
		BOOL			m_fWin9xOperationPending;				// this structure has been initialized and the operation is pending on Win9x
#endif // WIN95


		//
		// prevent unwarranted copies
		//
		CIOData( const CIOData & );
		CIOData& operator=( const CIOData & );
};


//
// all data for a read operation
//
class	CModemReadIOData : public CIOData
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemReadIOData::AddRef"
		void	AddRef( void ) 
		{ 
			DNASSERT( m_lRefCount != 0 );
			DNInterlockedIncrement( &m_lRefCount ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemReadIOData::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_lRefCount != 0 );
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CBilink				m_OutstandingReadListLinkage;	// links to the unbound list

		//
		// I/O variables
		//
		DWORD	m_dwWin9xReceiveErrorReturn;		// Win9x error return
		DWORD	jkm_dwOverlappedBytesReceived;		// used in GetOverlappedResult()
		DWORD	jkm_dwImmediateBytesReceived;		// used as an immediate for ReadFile()

		//
		// read state
		//
		READ_STATE	m_ReadState;				// state of READ
		DWORD		m_dwBytesToRead;			// bytes to read
		DWORD		m_dwReadOffset;				// destination offset into read buffer

		//
		// read buffers
		//
		SPRECEIVEDBUFFER	m_SPReceivedBuffer;				// received buffer data that is handed to the application
		union
		{
			MESSAGE_HEADER	MessageHeader;							// template for message header
			BYTE			ReceivedData[ MAX_MESSAGE_SIZE ];		// full buffer for received data
		} m_ReceiveBuffer;


		READ_STATE	ReadState( void ) const { return m_ReadState; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemReadIOData::SetReadState"
		void	SetReadState( const READ_STATE ReadState )
		{
			DNASSERT( ( m_ReadState == READ_STATE_UNKNOWN ) ||
					  ( ReadState == READ_STATE_UNKNOWN ) ||
					  ( ( m_ReadState == READ_STATE_READ_HEADER ) && ( ReadState == READ_STATE_READ_DATA ) ) );		// valid header read, start reading data
			m_ReadState = ReadState;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemReadIOData::SetThreadPool"
		void	SetThreadPool( CModemThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemReadIOData::ReadDataFromBilink"
		static CModemReadIOData	*ReadDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CModemReadIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CModemReadIOData, m_OutstandingReadListLinkage ) ] );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemReadIOData::ReadDataFromSPReceivedBuffer"
		static CModemReadIOData	*ReadDataFromSPReceivedBuffer( SPRECEIVEDBUFFER *const pSPReceivedBuffer )
		{
			DNASSERT( pSPReceivedBuffer != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pSPReceivedBuffer ) );
			DBG_CASSERT( sizeof( CModemReadIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CModemReadIOData*>( &reinterpret_cast<BYTE*>( pSPReceivedBuffer )[ -OFFSETOF( CModemReadIOData, m_SPReceivedBuffer ) ] );
		}

		//
		// functions for managing read IO data pool
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

	private:
		void	ReturnSelfToPool( void );

		BYTE			m_Sig[4];	// debugging signature ('RIOD')
		
		volatile LONG	m_lRefCount;
		CModemThreadPool		*m_pThreadPool;
		
		//
		// prevent unwarranted copies
		//
		CModemReadIOData( const CModemReadIOData & );
		CModemReadIOData& operator=( const CModemReadIOData & );
};

//
// all data for a write operation
//
class	CModemWriteIOData : public CIOData
{
	public:
		CModemWriteIOData			*m_pNext;							// link to next write in the send queue (see CSendQueue)

		CBilink					m_OutstandingWriteListLinkage;		// links to the outstanding write list
		BUFFERDESC				*m_pBuffers;						// pointer to outgoing buffers
		UINT_PTR				m_uBufferCount;						// count of outgoing buffers
		CModemCommandData			*m_pCommand;						// associated command

		SEND_COMPLETE_ACTION	m_SendCompleteAction;				// enumerated value indicating the action to take
									    							// when a send completes

		//
		// I/O variables
		//
		HRESULT		jkm_hSendResult;
		DWORD		jkm_dwOverlappedBytesSent;		// used in GetOverlappedResult()
		DWORD		jkm_dwImmediateBytesSent;		// used as an immediate for WriteFile()

		//
		// Since the following is a packed structure, put it at the end
		// to preserve as much alignment as possible with the
		// above fields
		//
		union
		{
			MESSAGE_HEADER	MessageHeader;					// data prepended on a write
			BYTE			Data[ MAX_MESSAGE_SIZE ];		// data buffer to flatten outgoing data
		} m_DataBuffer;

		static CModemWriteIOData	*WriteDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CModemWriteIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CModemWriteIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CModemWriteIOData, m_OutstandingWriteListLinkage ) ] );
		}

		//
		// functions for managing write IO data pool
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

	private:
		BYTE			m_Sig[4];	// debugging signature ('WIOD')
		
		//
		// prevent unwarranted copies
		//
		CModemWriteIOData( const CModemWriteIOData & );
		CModemWriteIOData& operator=( const CModemWriteIOData & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __IODDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemiodata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.cpp
 *  Content:	Functions for IO structures
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 *	02/11/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemReadIOData::PoolAllocFunction - called when new CModemReadIOData is allocated
//
// Entry:		Context (handle of read complete event)
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemReadIOData::PoolAllocFunction"

BOOL	CModemReadIOData::PoolAllocFunction( void* pvItem, void* pvContext )
{
	BOOL	fReturn;
	
	CModemReadIOData* pReadIOData = (CModemReadIOData*)pvItem;
	HANDLE hContext = (HANDLE)pvContext;
	
	//
	// initialize
	//
	fReturn = TRUE;

	pReadIOData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
	pReadIOData->jkm_dwOverlappedBytesReceived = 0;
	pReadIOData->jkm_dwImmediateBytesReceived = 0;
	pReadIOData->m_ReadState = READ_STATE_UNKNOWN;
	pReadIOData->m_dwBytesToRead = 0;
	pReadIOData->m_dwReadOffset = 0;
	pReadIOData->m_lRefCount = 0;
	pReadIOData->m_pThreadPool = NULL;

	pReadIOData->m_Sig[0] = 'R';
	pReadIOData->m_Sig[1] = 'I';
	pReadIOData->m_Sig[2] = 'O';
	pReadIOData->m_Sig[3] = 'D';
	
	pReadIOData->m_OutstandingReadListLinkage.Initialize();
	memset( &pReadIOData->m_ReceiveBuffer, 0x00, sizeof( pReadIOData->m_ReceiveBuffer ) );
	
#ifdef WIN95
	DNASSERT( pReadIOData->Win9xOperationPending() == FALSE );
#endif // WIN95
	memset( &pReadIOData->m_SPReceivedBuffer, 0x00, sizeof( pReadIOData->m_SPReceivedBuffer ) );
	pReadIOData->m_SPReceivedBuffer.BufferDesc.pBufferData = &pReadIOData->m_ReceiveBuffer.ReceivedData[ sizeof( pReadIOData->m_ReceiveBuffer.MessageHeader ) ];

	// Initialize Base Class members
#ifdef WINNT
	pReadIOData->m_NTIOOperationType = NT_IO_OPERATION_UNKNOWN;
#endif // WINNT
#ifdef WIN95
	pReadIOData->m_fWin9xOperationPending = FALSE;
#endif // WIN95
	pReadIOData->m_pDataPort = NULL;

	memset( &pReadIOData->m_Overlap, 0x00, sizeof( pReadIOData->m_Overlap ) );

	//
	// set the appropriate callback
	//
#ifdef WINNT
	//
	// WinNT, always use IO completion ports
	//
	DNASSERT( hContext == NULL );
	DNASSERT( pReadIOData->NTIOOperationType() == NT_IO_OPERATION_UNKNOWN );
	pReadIOData->SetNTIOOperationType( NT_IO_OPERATION_RECEIVE );
#else // WIN95
	//
	// Win9x
	//
	DNASSERT( hContext != NULL );
	DNASSERT( pReadIOData->OverlapEvent() == NULL );
#endif // WINNT

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemReadIOData::PoolInitFunction - called when new item is grabbed from the pool
//
// Entry:		Context (read complete event)
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemReadIOData::PoolInitFunction"

void	CModemReadIOData::PoolInitFunction( void* pvItem, void* pvContext )
{
	CModemReadIOData* pReadIOData = (CModemReadIOData*)pvItem;
	HANDLE hContext = (HANDLE)pvContext;

	DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	DNASSERT( pReadIOData->m_dwBytesToRead == 0 );
	DNASSERT( pReadIOData->m_dwReadOffset == 0 );
	DNASSERT( pReadIOData->jkm_dwOverlappedBytesReceived == 0 );

	DNASSERT( pReadIOData->m_SPReceivedBuffer.BufferDesc.pBufferData == &pReadIOData->m_ReceiveBuffer.ReceivedData[ sizeof( pReadIOData->m_ReceiveBuffer.MessageHeader ) ] );

	DNASSERT( pReadIOData->DataPort() == NULL );
#ifdef WIN95
	DNASSERT( pReadIOData->Win9xOperationPending() == FALSE );
	pReadIOData->SetOverlapEvent( hContext );
#endif // WIN95

	//
	// Initialize internal SPRECEIVEDDATA.  When data is received, it's possible
	// that the pointers in the SPRECEIVEDDATA block were manipulated.  Reset
	// them to reflect that the entire buffer is available.
	//
	ZeroMemory( &pReadIOData->m_SPReceivedBuffer, sizeof( pReadIOData->m_SPReceivedBuffer ) );
	pReadIOData->m_SPReceivedBuffer.BufferDesc.pBufferData = &pReadIOData->m_ReceiveBuffer.ReceivedData[ sizeof( pReadIOData->m_ReceiveBuffer.MessageHeader ) ];

	DNASSERT(pReadIOData->m_lRefCount == 0);
	pReadIOData->m_lRefCount = 1;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemReadIOData::PoolReleaseFunction - called when CModemReadIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemReadIOData::PoolReleaseFunction"

void	CModemReadIOData::PoolReleaseFunction( void* pvItem )
{
	CModemReadIOData* pReadIOData = (CModemReadIOData*)pvItem;

	DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	pReadIOData->m_ReadState = READ_STATE_UNKNOWN;
	pReadIOData->m_dwBytesToRead = 0;
	pReadIOData->m_dwReadOffset = 0;
	pReadIOData->jkm_dwOverlappedBytesReceived = 0;
#ifdef WIN95
	DNASSERT( pReadIOData->Win9xOperationPending() == FALSE );
	pReadIOData->SetOverlapEvent( NULL );
#endif // WIN95

	pReadIOData->SetDataPort( NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemReadIOData::PoolDeallocFunction - called when CModemReadIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemReadIOData::PoolDeallocFunction"

void	CModemReadIOData::PoolDeallocFunction( void* pvItem )
{
	const CModemReadIOData* pReadIOData = (CModemReadIOData*)pvItem;

	DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( pReadIOData->m_dwBytesToRead == 0 );
	DNASSERT( pReadIOData->m_dwReadOffset == 0 );

	DNASSERT( pReadIOData->m_ReadState == READ_STATE_UNKNOWN );
	DNASSERT( pReadIOData->m_lRefCount == 0 );
	DNASSERT( pReadIOData->m_pThreadPool == NULL );
	
	DNASSERT( pReadIOData->DataPort() == NULL );

#ifdef WIN95
	DNASSERT( pReadIOData->OverlapEvent() == NULL );
	DNASSERT( pReadIOData->Win9xOperationPending() == FALSE );
#endif // WIN95
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CRedaIOData::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemReadIOData::ReturnSelfToPool"

void	CModemReadIOData::ReturnSelfToPool( void )
{
	CModemThreadPool	*pThreadPool;
	

	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool != NULL );
	pThreadPool = m_pThreadPool;
	SetThreadPool( NULL );
	pThreadPool->ReturnReadIOData( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemWriteIOData::PoolAllocFunction - called when new CModemWriteIOData is allocated
//
// Entry:		Context (handle of write completion event)
//
// Exit:		Boolean indicating success
//				TRUE = allocation succeeded
//				FALSE = allocation failed
//
// Note:	We always want a command structure associated with CModemWriteIOData
//			so we don't need to grab a new command from the command pool each
//			time a CModemWriteIOData entry is removed from its pool.  This is done
//			for speed.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemWriteIOData::PoolAllocFunction"

BOOL	CModemWriteIOData::PoolAllocFunction( void* pvItem, void* pvContext )
{
	BOOL	fReturn;
	CModemCommandData	*pCommand;

	CModemWriteIOData* pWriteIOData = (CModemWriteIOData*)pvItem;
	HANDLE hContext = (HANDLE)pvContext;

#ifdef WIN95
	DNASSERT( hContext != NULL );
#endif // WIN95

	pWriteIOData->m_pNext = NULL;
	pWriteIOData->m_pBuffers = NULL;
	pWriteIOData->m_uBufferCount = 0;
	pWriteIOData->m_pCommand = NULL;
	pWriteIOData->m_SendCompleteAction = SEND_COMPLETE_ACTION_UNKNOWN;
	pWriteIOData->jkm_hSendResult = DPN_OK;
	pWriteIOData->jkm_dwOverlappedBytesSent = 0;
	pWriteIOData->jkm_dwImmediateBytesSent = 0;

	pWriteIOData->m_Sig[0] = 'W';
	pWriteIOData->m_Sig[1] = 'I';
	pWriteIOData->m_Sig[2] = 'O';
	pWriteIOData->m_Sig[3] = 'D';
	
	pWriteIOData->m_OutstandingWriteListLinkage.Initialize();
	memset( &pWriteIOData->m_DataBuffer, 0x00, sizeof( pWriteIOData->m_DataBuffer ) );
	pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature = SERIAL_HEADER_START;

	// Initialize Base Class members
#ifdef WINNT
	pWriteIOData->m_NTIOOperationType = NT_IO_OPERATION_UNKNOWN;
#endif // WINNT
#ifdef WIN95
	pWriteIOData->m_fWin9xOperationPending = FALSE;
#endif // WIN95
	pWriteIOData->m_pDataPort = NULL;

	memset( &pWriteIOData->m_Overlap, 0x00, sizeof( pWriteIOData->m_Overlap ) );

	//
	// initialize
	//
	fReturn = TRUE;

	pCommand = (CModemCommandData*)g_ModemCommandDataPool.Get();
	if ( pCommand == NULL )
	{
		DPFX(DPFPREP,  0, "Could not get command when allocating new CModemWriteIOData!" );
		fReturn = FALSE;
		goto Exit;
	}

	//
	// associate this command with the WriteData, clear the command descriptor
	// because the command isn't really being used yet, and it'll
	// cause an ASSERT when it's removed from the WriteIOData pool.
	//
	pWriteIOData->m_pCommand = pCommand;

	//
	// set the appropriate IO function
	//
#ifdef WINNT
	//
	// WinNT, we'll always use completion ports
	//
	DNASSERT( pWriteIOData->NTIOOperationType() == NT_IO_OPERATION_UNKNOWN );
	pWriteIOData->SetNTIOOperationType( NT_IO_OPERATION_SEND );
#else // WIN95
	//
	// Win9x
	//
	DNASSERT( pWriteIOData->OverlapEvent() == NULL );
#endif // WINNT

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemWriteIOData::PoolInitFunction - called when new CModemWriteIOData is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemWriteIOData::PoolInitFunction"

void	CModemWriteIOData::PoolInitFunction( void* pvItem, void* pvContext )
{
	CModemWriteIOData* pWriteIOData = (CModemWriteIOData*)pvItem;
	HANDLE hContext = (HANDLE)pvContext;

	DNASSERT( pWriteIOData->m_pNext == NULL );
	DNASSERT( pWriteIOData->m_pBuffers == NULL );
	DNASSERT( pWriteIOData->m_uBufferCount == 0 );
	DNASSERT( pWriteIOData->jkm_dwOverlappedBytesSent == 0 );

	DNASSERT( pWriteIOData->m_pCommand != NULL );
	pWriteIOData->m_pCommand->SetDescriptor();

	DNASSERT( pWriteIOData->m_pCommand->GetDescriptor() != NULL_DESCRIPTOR );
	DNASSERT( pWriteIOData->m_pCommand->GetUserContext() == NULL );

	DNASSERT( pWriteIOData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( pWriteIOData->m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( pWriteIOData->DataPort() == NULL );
#ifdef WIN95
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
	pWriteIOData->SetOverlapEvent( hContext );
#endif // WIN95
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemWriteIOData::PoolReleaseFunction - called when CModemWriteIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemWriteIOData::PoolReleaseFunction"

void	CModemWriteIOData::PoolReleaseFunction( void* pvItem )
{
	CModemWriteIOData* pWriteIOData = (CModemWriteIOData*)pvItem;

	DNASSERT( pWriteIOData->m_pCommand != NULL );
	pWriteIOData->m_pCommand->Reset();

	DNASSERT( pWriteIOData->m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
#ifdef WIN95
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
	pWriteIOData->SetOverlapEvent( NULL );
#endif

	pWriteIOData->m_pBuffers = NULL;
	pWriteIOData->m_uBufferCount = 0;
	pWriteIOData->jkm_dwOverlappedBytesSent = 0;
	pWriteIOData->m_pNext = NULL;
	pWriteIOData->m_SendCompleteAction = SEND_COMPLETE_ACTION_UNKNOWN;
	pWriteIOData->SetDataPort( NULL );

	DEBUG_ONLY( memset( &pWriteIOData->m_DataBuffer.Data[ 1 ], 0x00, sizeof( pWriteIOData->m_DataBuffer.Data ) - 1 ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemWriteIOData::PoolDeallocFunction - called when new CModemWriteIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemWriteIOData::PoolDeallocFunction"

void	CModemWriteIOData::PoolDeallocFunction( void* pvItem )
{
	CModemWriteIOData* pWriteIOData = (CModemWriteIOData*)pvItem;

	DNASSERT( pWriteIOData->m_pBuffers == NULL );
	DNASSERT( pWriteIOData->m_uBufferCount == 0 );
	DNASSERT( pWriteIOData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( pWriteIOData->m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );

	
	DNASSERT( pWriteIOData->m_pCommand != NULL );
	pWriteIOData->m_pCommand->DecRef();
	pWriteIOData->m_pCommand = NULL;

	DNASSERT( pWriteIOData->DataPort() == NULL );

#ifdef WIN95
	DNASSERT( pWriteIOData->OverlapEvent() == NULL );
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
#endif // WIN95
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemlocals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.h
 *  Content:	Global information for the DNSerial service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __LOCALS_H__
#define __LOCALS_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// max 32-bit value
//
#define	UINT32_MAX	((DWORD) 0xFFFFFFFF)
#define	WORD_MAX	((WORD) 0xFFFF)

//
// invalid port ID
//
#define	INVALID_DEVICE_ID		-1

//
// string for name of a com port
//
#define	COM_PORT_STRING			"COM"
#define	COM_PORT_TEMPLATE		"COM%d"
#define	COM_PORT_STRING_LENGTH	7

//
// no error code from TAPI
//
#define	LINEERR_NONE	0

//
// event indicies for all threads
//
#define	SP_CLOSING_EVENT_INDEX	0
#define	USER_CANCEL_EVENT_INDEX	1

#define	MAX_ACTIVE_WIN9X_ENDPOINTS	25

#define	MAX_PHONE_NUMBER_LENGTH		200

//
// enumeration of flow control
//
typedef	enum
{
	FLOW_NONE,			// no flow control
	FLOW_XONXOFF,		// XON/XOFF flow control
	FLOW_RTS,			// RTS
	FLOW_DTR,			// DTR
	FLOW_RTSDTR			// RTS/DTR
} SP_FLOW_CONTROL;

// definitions of communication types
typedef	DWORD	SP_BAUD_RATE;
typedef	DWORD	SP_STOP_BITS;
typedef	DWORD	SP_PARITY_TYPE;   			// SP_PARITY is reserved in WINBASE.H

// buffer limits for XON/XOFF flow control
#define	XON_LIMIT	100
#define	XOFF_LIMIT	100

// XON/XOFF flow control characters
#define	ASCII_XON	0x11
#define	ASCII_XOFF	0x13

// timeout intervals (milliseconds)
#define	WRITE_TIMEOUT_MS	5000
#define	READ_TIMEOUT_MS		500

// maximum user data allowed in a message
#define	MAX_MESSAGE_SIZE	1500
#define	MAX_USER_PAYLOAD	( MAX_MESSAGE_SIZE - sizeof( _MESSAGE_HEADER ) )

//
// Message start tokens (make non-ascii to reduce chance of being user data)
// The tokens need to be arranged such that all messages start with the INITIAL_DATA_SUB_TOKEN
// Note that enums use the bottom 2 bits of the 'command' token for RTT.
// The high-bit of the 'command' token is reserved.
//
#define	SERIAL_HEADER_START			0xCC
#define	SERIAL_DATA_USER_DATA		0x40
#define	SERIAL_DATA_ENUM_QUERY		0x60
#define	SERIAL_DATA_ENUM_RESPONSE	0x20
#define	ENUM_RTT_MASK	0x03

//
// enumerated constants for IO completion returns
//
typedef	enum	_IO_COMPLETION_KEY
{
	IO_COMPLETION_KEY_UNKNONW = 0,		// invalid value
	IO_COMPLETION_KEY_SP_CLOSE,			// SP is closing, bail on completion threads
	IO_COMPLETION_KEY_TAPI_MESSAGE,		// TAPI sent a message
	IO_COMPLETION_KEY_IO_COMPLETE,		// IO operation complete
	IO_COMPLETION_KEY_NEW_JOB,			// new job notification
} IO_COMPLETION_KEY;

//
// enumerated values indicating how to open provider
//
typedef	enum	_LINK_DIRECTION
{
	LINK_DIRECTION_UNKNOWN = 0,		// unknown state
	LINK_DIRECTION_INCOMING,		// incoming state
	LINK_DIRECTION_OUTGOING			// outgoing state
} LINK_DIRECTION;

//
// initialization states of address components
//
typedef	enum	_SP_ADDRESS_COMPONENT_STATE
{
	SP_ADDRESS_COMPONENT_UNINITIALIZED = 0,
	SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED,
	SP_ADDRESS_COMPONENT_INITIALIZED
} SP_ADDRESS_COMPONENT_STATE;

typedef	enum	_ADDRESS_TYPE
{
	ADDRESS_TYPE_UNKNOWN = 0,
	ADDRESS_TYPE_REMOTE_HOST,
	ADDRESS_TYPE_LOCAL_ADAPTER,
	ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT
} ADDRESS_TYPE;

//
// default enum retries for serial SP and retry time (milliseconds)
//
#define	DEFAULT_ENUM_RETRY_COUNT		5
#define	DEFAULT_ENUM_RETRY_INTERVAL		1500
#define	DEFAULT_ENUM_TIMEOUT			1500

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// structure for all TAPI information
//
typedef	struct	_TAPI_INFO
{
	HLINEAPP	hApplicationInstance;		// from lineInitializeEx()
	DWORD		dwVersion;					// negotiated version
	DWORD		dwLinesAvailable;			// number of TAPI lines available
} TAPI_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

// DLL instance
extern HINSTANCE	g_hModemDLLInstance;

#ifndef DPNBUILD_LIBINTERFACE
//
// count of outstanding COM interfaces
//
extern volatile LONG	g_lModemOutstandingInterfaceCount;
#endif // ! DPNBUILD_LIBINTERFACE

extern const TCHAR	g_NullToken;

//
// thread count
//
extern	INT			g_iThreadCount;

//
// GUIDs for munging device IDs
//
extern	GUID	g_ModemSPEncryptionGuid;
extern	GUID	g_SerialSPEncryptionGuid;

#ifdef DBG
extern CBilink	g_blDPNModemCritSecsHeld;
#endif // DBG



//**********************************************************************
// TAPI Function prototypes
//**********************************************************************

//
// TAPI interface functions
//
#ifdef UNICODE
#define TAPI_APPEND_LETTER "W"
#else
#define TAPI_APPEND_LETTER "A"
#endif // UNICODE

// UNICODE and ANSI versions same
typedef	LONG WINAPI	TAPI_lineClose( HLINE hLine );

typedef	LONG WINAPI	TAPI_lineDeallocateCall( HCALL hCall );

typedef	LONG WINAPI	TAPI_lineGetMessage( HLINEAPP hLineApp,
										 LPLINEMESSAGE lpMessage,
										 DWORD dwTimeout );

typedef	LONG WINAPI TAPI_lineShutdown( HLINEAPP hLineApp );

typedef	LONG WINAPI	TAPI_lineAnswer( HCALL hCall,
									 LPCSTR lpsUserUserInfo,
									 DWORD dwSize );

typedef	LONG WINAPI	TAPI_lineDrop( HCALL hCall,
								   LPCSTR lpsUserUserInfo,
								   DWORD dwSize );

typedef LONG WINAPI TAPI_lineNegotiateAPIVersion( HLINEAPP hLineApp,
												  DWORD dwDeviceID,
												  DWORD dwAPILowVersion,
												  DWORD dwAPIHighVersion,
												  LPDWORD lpdwAPIVersion,
												  LPLINEEXTENSIONID lpExtensionID );


// Unicode vs. ANSI

typedef	LONG WINAPI	TAPI_lineConfigDialog( DWORD dwDeviceID,
										   HWND hwndOwner,
										   LPCTSTR lpszDeviceClass );

typedef LONG WINAPI TAPI_lineGetDevCaps( HLINEAPP hLineApp,
										 DWORD dwDeviceID,
										 DWORD dwAPIVersion,
										 DWORD dwExtVersion,
										 LPLINEDEVCAPS lpLineDevCaps );

typedef	LONG WINAPI	TAPI_lineGetID( HLINE hLine,
									DWORD dwAddressID,
									HCALL hCall,
									DWORD dwSelect,
									LPVARSTRING lpDeviceID,
									LPCTSTR lpszDeviceClass );

typedef LONG WINAPI TAPI_lineInitializeEx( LPHLINEAPP lphLineApp,
										   HINSTANCE hInstance,
										   LINECALLBACK lpfnCallback,
										   LPCTSTR lpszFriendlyAppName,
										   LPDWORD lpdwNumDevs,
										   LPDWORD lpdwAPIVersion,
										   LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams );

typedef	LONG WINAPI	TAPI_lineMakeCall( HLINEAPP hLineApp,
									   LPHCALL lphCall,
									   LPCTSTR lpszDestAddress,
									   DWORD dwCountryCode,
									   LPLINECALLPARAMS const lpCallParams );

typedef	LONG WINAPI	TAPI_lineOpen( HLINEAPP hLineApp,
								   DWORD dwDeviceID,
								   LPHLINE lphLine,
								   DWORD dwAPIVersion,
								   DWORD dwExtVersion,
								   DWORD_PTR dwCallbackInstance,
								   DWORD dwPrivileges,
								   DWORD dwMediaModes,
								   LPLINECALLPARAMS const lpCallParams );

extern	TAPI_lineAnswer*				p_lineAnswer;
extern	TAPI_lineClose*					p_lineClose;
extern	TAPI_lineConfigDialog*			p_lineConfigDialog;
extern	TAPI_lineDeallocateCall*		p_lineDeallocateCall;
extern	TAPI_lineDrop*					p_lineDrop;
extern	TAPI_lineGetDevCaps*			p_lineGetDevCaps;
extern	TAPI_lineGetID*					p_lineGetID;
extern	TAPI_lineGetMessage*			p_lineGetMessage;
extern	TAPI_lineInitializeEx*			p_lineInitializeEx;
extern	TAPI_lineMakeCall*				p_lineMakeCall;
extern	TAPI_lineNegotiateAPIVersion*	p_lineNegotiateAPIVersion;
extern	TAPI_lineOpen*					p_lineOpen;
extern	TAPI_lineShutdown*				p_lineShutdown;

//**********************************************************************
// Function definitions
//**********************************************************************

#endif	// __LOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemjobqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		JobQueue.cpp
 *  Content:	Job queue for use in the thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/21/2000	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CJobQueue::Initialize - initialize
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Initialize"

BOOL	CJobQueue::Initialize( void )
{
	BOOL	fReturn;

	m_pQueueHead = NULL;
	m_pQueueTail = NULL;
	m_hPendingJob = NULL;

	//
	// initialize
	//
	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section on job queue!" );
		goto Failure;
	}
	DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes

	m_hPendingJob = DNCreateEvent( NULL,		// pointer to security attributes (none)
								 TRUE,		// manual reset
								 FALSE,		// start unsignalled
								 NULL );	// pointer to name (none)
	if ( m_hPendingJob == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create event for pending job!" );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Deinitialize"

void	CJobQueue::Deinitialize( void )
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNDeleteCriticalSection( &m_Lock );

	if ( m_hPendingJob != NULL )
	{
		if ( DNCloseHandle( m_hPendingJob ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing job queue handle" );
			DisplayErrorCode( 0, dwError );
		}

		m_hPendingJob = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::SignalPendingJob - set flag to signal a pending job
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::SignalPendingJob"

BOOL	CJobQueue::SignalPendingJob( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( DNSetEvent( GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Cannot set event for pending job!" );
		DisplayErrorCode( 0, dwError );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::EnqueueJob - add a job to the job list
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::EnqueueJob"

void	CJobQueue::EnqueueJob( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	if ( m_pQueueTail != NULL )
	{
		DNASSERT( m_pQueueHead != NULL );
		DNASSERT( m_pQueueTail->pNext == NULL );
		m_pQueueTail->pNext = pJob;
	}
	else
	{
		m_pQueueHead = pJob;
	}

	m_pQueueTail = pJob;
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::DequeueJob - remove job from job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::DequeueJob"

THREAD_POOL_JOB	*CJobQueue::DequeueJob( void )
{
	THREAD_POOL_JOB	*pJob;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	
	pJob = NULL;
	
	if ( m_pQueueHead != NULL )
	{
		pJob = m_pQueueHead;
		m_pQueueHead = pJob->pNext;
		if ( m_pQueueHead == NULL )
		{
			DNASSERT( m_pQueueTail == pJob );
			m_pQueueTail = NULL;
		}

		DEBUG_ONLY( pJob->pNext = NULL );
	}

	return	pJob;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemjobqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       JobQueue.h
 *  Content:	Job queue for thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/24/2000	jtk		Created
 ***************************************************************************/

#ifndef __JOB_QUEUE_H__
#define __JOB_QUEUE_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CSocketPort;
typedef	enum	_JOB_TYPE	JOB_TYPE;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );

//
// structure for job to start monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;	// pointer to associated socket port

} DATA_ADD_SOCKET;

//
// structure for job to stop monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;		// pointer to associated socket port

} DATA_REMOVE_SOCKET;

//
// structure for job to connect
//
typedef struct
{
	JOB_FUNCTION	*pCommandFunction;	// pointer to function for the command
	void			*pContext;			// user context (i.e. CModemEndpoint pointer)
	UINT_PTR		uData;				// user data
} DATA_DELAYED_COMMAND;

//
// structure for job to refresh enums
//
typedef	struct
{
	UINT_PTR	uDummy;			// dummy variable to prevent compiler from whining
} DATA_REFRESH_TIMED_JOBS;

//
// structure encompassing information for a job for the workhorse thread
//
typedef struct	_THREAD_POOL_JOB
{
	THREAD_POOL_JOB		*pNext;					// pointer to next job
	JOB_TYPE			JobType;				// type of job
	JOB_FUNCTION		*pCancelFunction;		// function for cancelling job

//	DWORD		dwCommandID;			// unique ID used to identify this command
//	FUNCTION	*pProcessFunction;		// function for performing job

	union
	{
		DATA_DELAYED_COMMAND	JobDelayedCommand;
		DATA_REMOVE_SOCKET		JobRemoveSocket;
		DATA_ADD_SOCKET			JobAddSocket;
		DATA_REFRESH_TIMED_JOBS	JobRefreshTimedJobs;
	} JobData;

} THREAD_POOL_JOB;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************


//
// class to encapsultate a job queue
//
class	CJobQueue
{
	public:
		BOOL	Initialize( void );
		void	Deinitialize( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CJobQueue::GetPendingJobHandle"
		DNHANDLE	GetPendingJobHandle( void ) const
		{
			DNASSERT( m_hPendingJob != NULL );
			return	m_hPendingJob;
		}

		BOOL	SignalPendingJob( void );

		BOOL	IsEmpty( void ) const { return ( m_pQueueHead == NULL ); }

		void	EnqueueJob( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*DequeueJob( void );

	protected:

	private:
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_Lock;			// lock
#endif // !DPNBUILD_ONLYONETHREAD
		THREAD_POOL_JOB		*m_pQueueHead;	// head of job queue
		THREAD_POOL_JOB		*m_pQueueTail;	// tail of job queue
		DNHANDLE			m_hPendingJob;	// event indicating a pending job

		//
		// prevent unwarranted copies
		//
		CJobQueue( const CJobQueue & );
		CJobQueue& operator=( const CJobQueue & );
};

#undef DPF_MODNAME

#endif	// __JOB_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemlocals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.cpp
 *  Content:	Global variables for the DNSerial service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#define	DPF_MODNAME	"Locals"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

// DLL instance
HINSTANCE	g_hModemDLLInstance = NULL;

#ifndef DPNBUILD_LIBINTERFACE
//
// count of outstanding COM interfaces
//
volatile LONG	g_lModemOutstandingInterfaceCount = 0;
#endif // ! DPNBUILD_LIBINTERFACE

//
// Note: all of these constants MUST be in the same order as their numbering in
//		the dialog resource file!
//

//
// NULL characters token
//
const TCHAR	g_NullToken = TEXT('\0');

//
// thread count
//
INT			g_iThreadCount = 0;

//
// GUIDs for munging device IDs
//
// {735D5A43-8249-4628-BE0C-F4DC6836ACDD}
GUID	g_ModemSPEncryptionGuid = { 0x735d5a43, 0x8249, 0x4628, { 0xbe, 0xc, 0xf4, 0xdc, 0x68, 0x36, 0xac, 0xdd } };
// {66AFD073-206B-416c-A0B6-09B216FE007B}
GUID	g_SerialSPEncryptionGuid = { 0x66afd073, 0x206b, 0x416c, { 0xa0, 0xb6, 0x9, 0xb2, 0x16, 0xfe, 0x0, 0x7b } };

#ifdef DBG
CBilink		g_blDPNModemCritSecsHeld;
#endif // DBG


//**********************************************************************
// Function prototypes
//**********************************************************************

TAPI_lineAnswer					*p_lineAnswer = NULL;
TAPI_lineClose					*p_lineClose = NULL;
TAPI_lineConfigDialog			*p_lineConfigDialog = NULL;
TAPI_lineDeallocateCall			*p_lineDeallocateCall = NULL;
TAPI_lineDrop					*p_lineDrop = NULL;
TAPI_lineGetDevCaps				*p_lineGetDevCaps = NULL;
TAPI_lineGetID					*p_lineGetID = NULL;
TAPI_lineGetMessage				*p_lineGetMessage = NULL;
TAPI_lineInitializeEx			*p_lineInitializeEx = NULL;
TAPI_lineMakeCall				*p_lineMakeCall = NULL;
TAPI_lineNegotiateAPIVersion	*p_lineNegotiateAPIVersion = NULL;
TAPI_lineOpen					*p_lineOpen = NULL;
TAPI_lineShutdown				*p_lineShutdown = NULL;

//**********************************************************************
// Function definitions
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodempools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:	Pool functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from utils.h
 ***************************************************************************/

#ifndef __POOLS_H__
#define __POOLS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CModemCommandData;
class	CDataPort;
class	CModemEndpoint;
class	CModemThreadPool;
typedef	struct	_DATA_PORT_POOL_CONTEXT	DATA_PORT_POOL_CONTEXT;
typedef	struct	_ENDPOINT_POOL_CONTEXT	ENDPOINT_POOL_CONTEXT;

//**********************************************************************
// Variable definitions
//**********************************************************************

extern CFixedPool g_ComEndpointPool;
extern CFixedPool g_ModemCommandDataPool;
extern CFixedPool g_ComPortPool;
extern CFixedPool g_ModemEndpointPool;
extern CFixedPool g_ModemPortPool;
extern CFixedPool g_ModemThreadPoolPool;
extern CFixedPool g_ModemReadIODataPool;
extern CFixedPool g_ModemWriteIODataPool;
extern CFixedPool g_ModemThreadPoolJobPool;	
extern CFixedPool g_ModemTimerEntryPool;	

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	ModemInitializePools( void );
void	ModemDeinitializePools( void );

CDataPort		*CreateDataPort( DATA_PORT_POOL_CONTEXT *pContext );
CModemEndpoint		*CreateEndpoint( ENDPOINT_POOL_CONTEXT *pContext );

#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemsendqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SendQueue.cpp
 *  Content:	Queue to manage outgoing sends
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_MODNAME
#define	DPF_MODNAME	"SendQueue"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::CSendQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
CSendQueue::CSendQueue():
	m_pHead( NULL ),
	m_pTail( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::~CSendQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
CSendQueue::~CSendQueue()
{
	DNASSERT( m_pHead == NULL );
	DNASSERT( m_pTail == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::Initialize - initialize this send queue
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CSendQueue::Initialize( void )
{
	HRESULT	hr;


	hr = DPN_OK;
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not initialize critical section for SendQueue!" );
	}
	else
	{
		DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
		DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	}

	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemsendqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CSendQueue.h
 *  Content:	Queue to manage outgoing sends
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#ifndef __SEND_QUEUE_H__
#define __SEND_QUEUE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// forward structure references
//
class	CModemEndpoint;
class	CModemWriteIOData;

//
// main class definition
//
class	CSendQueue
{
	public:
		CSendQueue();
		~CSendQueue();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	Initialize( void );
		void	Deinitialize( void ) { DNDeleteCriticalSection( &m_Lock ); }

		//
		// add item to end of queue
		//
		void	Enqueue( CModemWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pTail == NULL )
			{
				m_pHead = pWriteData;
			}
			else
			{
				m_pTail->m_pNext = pWriteData;
			}

			m_pTail = pWriteData;
			pWriteData->m_pNext = NULL;
		}

		//
		// add item to front of queue
		//
		void	AddToFront( CModemWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead != NULL )
			{
				pWriteData->m_pNext = m_pHead;
			}
			else
			{
				m_pTail = pWriteData;
				pWriteData->m_pNext = NULL;
			}

			m_pHead = pWriteData;
		}

		//
		// remove item from queue
		//
		CModemWriteIOData	*Dequeue( void )
		{
			CModemWriteIOData	*pReturn;


			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			pReturn = m_pHead;
			if ( m_pHead != NULL )
			{
				m_pHead = m_pHead->m_pNext;
				if ( m_pHead == NULL )
				{
					m_pTail = NULL;
				}

				DEBUG_ONLY( pReturn->m_pNext = NULL );
			}

			return	pReturn;
		};

		//
		// determine if queue is empty
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSendQueue::IsEmpty"
		BOOL	IsEmpty( void )	const
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead == NULL )
			{
				DNASSERT( m_pTail == NULL );
				return	TRUE;
			}
			else
			{
				return	FALSE;
			}
		}
 
	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;		// critical section
		CModemWriteIOData		*m_pHead;	// pointer to queue head
		CModemWriteIOData		*m_pTail;	// pointer to queue tail
};

#endif	// __SEND_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodempools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Pool utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from Utils.h
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// pool for com endpoints
//
CFixedPool g_ComEndpointPool;
CFixedPool g_ModemCommandDataPool;
CFixedPool g_ComPortPool;
CFixedPool g_ModemEndpointPool;
CFixedPool g_ModemPortPool;
CFixedPool g_ModemThreadPoolPool;
CFixedPool g_ModemReadIODataPool;
CFixedPool g_ModemWriteIODataPool;
CFixedPool g_ModemThreadPoolJobPool;	
CFixedPool g_ModemTimerEntryPool;	


#define COMEP_POOL_INITED		0x00000001
#define CMDDATA_POOL_INITED		0x00000002
#define COMPORT_POOL_INITED		0x00000004
#define MODEMEP_POOL_INITED		0x00000008
#define MODEMPORT_POOL_INITED	0x00000010
#define THREADPOOL_POOL_INITED	0x00000020
#define READIODATA_POOL_INITED	0x00000040
#define WRITEIODATA_POOL_INITED	0x00000080
#define THREADJOB_POOL_INITED	0x00000100
#define TIMERENTRY_POOL_INITED	0x00000200

DWORD g_dwModemInitFlags = 0;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemInitializePools - initialize pools
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemInitializePools"

BOOL	ModemInitializePools( void )
{
	if (!g_ComEndpointPool.Initialize(sizeof(CModemEndpoint), CModemEndpoint::PoolAllocFunction, CModemEndpoint::PoolInitFunction, CModemEndpoint::PoolReleaseFunction, CModemEndpoint::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= COMEP_POOL_INITED;
	
	if (!g_ModemCommandDataPool.Initialize(sizeof(CModemCommandData), CModemCommandData::PoolAllocFunction, CModemCommandData::PoolInitFunction, CModemCommandData::PoolReleaseFunction, CModemCommandData::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= CMDDATA_POOL_INITED;

	if (!g_ComPortPool.Initialize(sizeof(CDataPort), CDataPort::PoolAllocFunction, CDataPort::PoolInitFunction, CDataPort::PoolReleaseFunction, CDataPort::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= COMPORT_POOL_INITED;

	if (!g_ModemEndpointPool.Initialize(sizeof(CModemEndpoint), CModemEndpoint::PoolAllocFunction, CModemEndpoint::PoolInitFunction, CModemEndpoint::PoolReleaseFunction, CModemEndpoint::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= MODEMEP_POOL_INITED;

	if (!g_ModemPortPool.Initialize(sizeof(CDataPort), CDataPort::PoolAllocFunction, CDataPort::PoolInitFunction, CDataPort::PoolReleaseFunction, CDataPort::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= MODEMPORT_POOL_INITED;

	if (!g_ModemThreadPoolPool.Initialize(sizeof(CModemThreadPool), CModemThreadPool::PoolAllocFunction, CModemThreadPool::PoolInitFunction, NULL, CModemThreadPool::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= THREADPOOL_POOL_INITED;

	if (!g_ModemReadIODataPool.Initialize(sizeof(CModemReadIOData), CModemReadIOData::PoolAllocFunction, CModemReadIOData::PoolInitFunction, CModemReadIOData::PoolReleaseFunction, CModemReadIOData::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= READIODATA_POOL_INITED;

	if (!g_ModemWriteIODataPool.Initialize(sizeof(CModemWriteIOData), CModemWriteIOData::PoolAllocFunction, CModemWriteIOData::PoolInitFunction, CModemWriteIOData::PoolReleaseFunction, CModemWriteIOData::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= WRITEIODATA_POOL_INITED;

	if (!g_ModemThreadPoolJobPool.Initialize(sizeof(THREAD_POOL_JOB), ThreadPoolJob_Alloc, ThreadPoolJob_Get, ThreadPoolJob_Release, NULL))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= THREADJOB_POOL_INITED;
	if (!g_ModemTimerEntryPool.Initialize(sizeof(TIMER_OPERATION_ENTRY), ModemTimerEntry_Alloc, ModemTimerEntry_Get, ModemTimerEntry_Release, ModemTimerEntry_Dealloc))
	{
		goto Failure;
	}
	g_dwModemInitFlags |= TIMERENTRY_POOL_INITED;

	
	return	TRUE;

Failure:
	ModemDeinitializePools();

	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemDeinitializePools - deinitialize the pools
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemDeinitializePools"

void	ModemDeinitializePools( void )
{
	if (g_dwModemInitFlags & COMEP_POOL_INITED)
	{
		g_ComEndpointPool.DeInitialize();
	}	
	// NOTE: WriteIOData's keep CommandData structures on them while they are in the pool
	// If we don't clean up the WriteIOData pool first, we will have outstanding items in the 
	// CommandData pool.
	if (g_dwModemInitFlags & WRITEIODATA_POOL_INITED)
	{
		g_ModemWriteIODataPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & CMDDATA_POOL_INITED)
	{
		g_ModemCommandDataPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & COMPORT_POOL_INITED)
	{
		g_ComPortPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & MODEMEP_POOL_INITED)
	{
		g_ModemEndpointPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & MODEMPORT_POOL_INITED)
	{
		g_ModemPortPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & THREADPOOL_POOL_INITED)
	{
		g_ModemThreadPoolPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & READIODATA_POOL_INITED)
	{
		g_ModemReadIODataPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & THREADJOB_POOL_INITED)
	{
		g_ModemThreadPoolJobPool.DeInitialize();
	}	
	if (g_dwModemInitFlags & TIMERENTRY_POOL_INITED)
	{
		g_ModemTimerEntryPool.DeInitialize();
	}	

	g_dwModemInitFlags = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateDataPort - create a data port
//
// Entry:		Nothing
//
// Exit:		Pointer to DataPort
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateDataPort"

CDataPort	*CreateDataPort( DATA_PORT_POOL_CONTEXT *pPoolContext )
{
	CDataPort	*pReturn;


	pReturn = NULL;
	switch ( pPoolContext->pSPData->GetType() )
	{
		case TYPE_SERIAL:
		{
			pReturn = (CDataPort*)g_ComPortPool.Get( pPoolContext );
			break;
		}

		case TYPE_MODEM:
		{
			pReturn = (CDataPort*)g_ModemPortPool.Get( pPoolContext );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateEndpoint - create an endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to Endpoint
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateEndpoint"

CModemEndpoint	*CreateEndpoint( ENDPOINT_POOL_CONTEXT *const pPoolContext )
{
	CModemEndpoint	*pReturn;


	pReturn = NULL;
	switch ( pPoolContext->pSPData->GetType() )
	{
		case TYPE_SERIAL:
		{
			pPoolContext->fModem = FALSE;
			pReturn = (CModemEndpoint*)g_ComEndpointPool.Get( pPoolContext );
			break;
		}

		case TYPE_MODEM:
		{
			pPoolContext->fModem = TRUE;
			pReturn = (CModemEndpoint*)g_ModemEndpointPool.Get( pPoolContext );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemspdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.cpp
 *  Content:	Global variables for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Dereived from Locals.cpp
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// default number of command descriptors to create
#define	DEFAULT_COMMAND_POOL_SIZE	20
#define	COMMAND_POOL_GROW_SIZE		5

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemSPData::CModemSPData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::CModemSPData"

CModemSPData::CModemSPData():
	m_lRefCount( 0 ),
	m_lObjectRefCount( 0 ),
	m_hShutdownEvent( NULL ),
	m_SPType( TYPE_UNKNOWN ),
	m_State( SPSTATE_UNINITIALIZED ),
	m_pThreadPool( NULL ),
	m_fLockInitialized( FALSE ),
	m_fHandleTableInitialized( FALSE ),
	m_fDataPortDataLockInitialized( FALSE ),
	m_fInterfaceGlobalsInitialized( FALSE )
{
	m_Sig[0] = 'S';
	m_Sig[1] = 'P';
	m_Sig[2] = 'D';
	m_Sig[3] = 'T';
	
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_DataPortList, 0x00, sizeof( m_DataPortList ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );
#ifndef DPNBUILD_LIBINTERFACE
	DNInterlockedIncrement( &g_lModemOutstandingInterfaceCount );
#endif // ! DPNBUILD_LIBINTERFACE
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::~CModemSPData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::~CModemSPData"

CModemSPData::~CModemSPData()
{
	UINT_PTR	uIndex;


	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( m_hShutdownEvent == NULL );
	DNASSERT( m_SPType == TYPE_UNKNOWN );
	DNASSERT( m_State == SPSTATE_UNINITIALIZED );
	DNASSERT( m_pThreadPool == NULL );

	uIndex = LENGTHOF( m_DataPortList );
	while ( uIndex > 0 )
	{
		uIndex--;
		DNASSERT( m_DataPortList[ uIndex ] == NULL );
	}

	DNASSERT( m_fLockInitialized == FALSE );
	DNASSERT( m_fHandleTableInitialized == FALSE );
	DNASSERT( m_fDataPortDataLockInitialized == FALSE );
	DNASSERT( m_fInterfaceGlobalsInitialized == FALSE );
#ifndef DPNBUILD_LIBINTERFACE
	DNInterlockedDecrement( &g_lModemOutstandingInterfaceCount );
#endif // ! DPNBUILD_LIBINTERFACE
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::Initialize - intialize
//
// Entry:		Pointer to DirectNet
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::Initialize"

HRESULT	CModemSPData::Initialize( const SP_TYPE SPType,
							 IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT		hr;


	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_lRefCount == 1 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( GetType() == TYPE_UNKNOWN );

	DNASSERT( GetType() == TYPE_UNKNOWN );
	m_SPType = SPType;

	DNASSERT( m_COMInterface.m_pCOMVtbl == NULL );
	m_COMInterface.m_pCOMVtbl = pVtbl;

	DNASSERT( m_fLockInitialized == FALSE );
	DNASSERT( m_fDataPortDataLockInitialized == FALSE );
	DNASSERT( m_fInterfaceGlobalsInitialized == FALSE );

	//
	// attempt to initialize shutdown event
	//
	DNASSERT( m_hShutdownEvent == NULL );
	m_hShutdownEvent = DNCreateEvent( NULL,		// pointer to security (none)
									TRUE,		// manual reset
									TRUE,		// start signalled (so close can be called without any endpoints being created)
									NULL		// pointer to name (none)
									);
	if ( m_hShutdownEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event for shutting down spdata!" );
		DisplayErrorCode( 0, dwError );
	}

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize SP lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	m_fLockInitialized = TRUE;


	hr = m_HandleTable.Initialize();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to initialize handle table!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fHandleTableInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_DataPortDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize data port data lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_DataPortDataLock, 0 );
	DebugSetCriticalSectionGroup( &m_DataPortDataLock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	m_fDataPortDataLockInitialized = TRUE;

	//
	// get a thread pool
	//
	DNASSERT( m_pThreadPool == NULL );
	hr = InitializeInterfaceGlobals( this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to create thread pool!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fInterfaceGlobalsInitialized = TRUE;

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CModemSPData::Initialize" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	Deinitialize();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::Shutdown - shut down this set of SP data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::Shutdown"

void	CModemSPData::Shutdown( void )
{
	BOOL	fLooping;


	//
	// Unbind this interface from the globals.  This will cause a closure of all
	// of the I/O which will release endpoints, socket ports and then this data.
	//
	if ( m_fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_fInterfaceGlobalsInitialized = FALSE;
	}

	SetState( SPSTATE_CLOSING );
	
	DNASSERT( m_hShutdownEvent != NULL );
	
	fLooping = TRUE;
	while ( fLooping != FALSE )
	{
		switch ( DNWaitForSingleObjectEx( m_hShutdownEvent, INFINITE, TRUE ) )
		{
			case WAIT_OBJECT_0:
			{
				fLooping = FALSE;
				break;
			}

			case WAIT_IO_COMPLETION:
			{
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	if ( DNCloseHandle( m_hShutdownEvent ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to close shutdown event!" );
		DisplayErrorCode( 0, dwError );
	}
	m_hShutdownEvent = NULL;

	if ( DP8SPCallbackInterface() != NULL)
	{
		IDP8SPCallback_Release( DP8SPCallbackInterface() );
		memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::Deinitialize"

void	CModemSPData::Deinitialize( void )
{
	DPFX(DPFPREP,  9, "Entering CModemSPData::Deinitialize" );

	//
	// deinitialize interface globals
	//
	if ( m_fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_fInterfaceGlobalsInitialized = FALSE;
	}

	if ( m_fDataPortDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_DataPortDataLock );
		m_fDataPortDataLockInitialized = FALSE;
	}
	
	if ( m_fHandleTableInitialized != FALSE )
	{
		m_HandleTable.Deinitialize();
		m_fHandleTableInitialized = FALSE;
	}

	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	m_COMInterface.m_pCOMVtbl = NULL;

	SetState( SPSTATE_UNINITIALIZED );
	m_SPType = TYPE_UNKNOWN;

	if ( GetThreadPool() != NULL )
	{
		GetThreadPool()->DecRef();
		SetThreadPool( NULL );
	}
	
	if ( m_hShutdownEvent != NULL )
	{
		if ( DNCloseHandle( m_hShutdownEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to close shutdown handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hShutdownEvent = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::SetCallbackData - set data for SP callbacks to application
//
// Entry:		Pointer to initialization data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::SetCallbackData"

void	CModemSPData::SetCallbackData( const SPINITIALIZEDATA *const pInitData )
{
	DNASSERT( pInitData != NULL );

	DNASSERT( 	pInitData->dwFlags == SP_SESSION_TYPE_PEER ||
				pInitData->dwFlags == SP_SESSION_TYPE_CLIENT ||
				pInitData->dwFlags == SP_SESSION_TYPE_SERVER ||
				pInitData->dwFlags == 0);
				
	m_InitData.dwFlags = pInitData->dwFlags;

	DNASSERT( pInitData->pIDP != NULL );
	m_InitData.pIDP = pInitData->pIDP;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::BindEndpoint - bind endpoint to a data port
//
// Entry:		Pointer to endpoint
//				DeviceID
//				Device context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::BindEndpoint"

HRESULT	CModemSPData::BindEndpoint( CModemEndpoint *const pEndpoint,
							   const DWORD dwDeviceID,
							   const void *const pDeviceContext )
{
	HRESULT	hr;
	CDataPort	*pDataPort;
	BOOL	fDataPortDataLocked;
	BOOL	fDataPortCreated;
	BOOL	fDataPortBoundToNetwork;

	
 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p, %u, 0x%p)",
 		this, pEndpoint, dwDeviceID, pDeviceContext);
 	
	//
	// intialize
	//
	hr = DPN_OK;
	pDataPort = NULL;
	fDataPortDataLocked = FALSE;
	fDataPortCreated = FALSE;
	fDataPortBoundToNetwork = FALSE;

	LockDataPortData();
	fDataPortDataLocked = TRUE;
	
	if ( m_DataPortList[ dwDeviceID ] != NULL )
	{
		pDataPort = m_DataPortList[ dwDeviceID ];
	}
	else
	{
		DATA_PORT_POOL_CONTEXT	DataPortPoolContext;


		memset( &DataPortPoolContext, 0x00, sizeof( DataPortPoolContext ) );
		DataPortPoolContext.pSPData = this;

		pDataPort = CreateDataPort( &DataPortPoolContext );
		if ( pDataPort == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed to create new data port!" );
			goto Failure;
		}
		fDataPortCreated = TRUE;

		hr = GetThreadPool()->CreateDataPortHandle( pDataPort );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to create handle for data port!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}

		hr = pDataPort->BindToNetwork( dwDeviceID, pDeviceContext );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to bind data port to network!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
		fDataPortBoundToNetwork = TRUE;

		//
		// update the list, keep the reference added by 'CreateDataPort' as it
		// will be cleaned when the data port is removed from the active list.
		//
		m_DataPortList[ dwDeviceID ] = pDataPort;
	}
	

	DNASSERT( pDataPort != NULL );
	pDataPort->EndpointAddRef();

	hr = pDataPort->BindEndpoint( pEndpoint, pEndpoint->GetType() );
	if ( hr != DPN_OK )
	{
		pDataPort->EndpointDecRef();
		DPFX(DPFPREP,  0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fDataPortDataLocked != FALSE )
	{
		UnlockDataPortData();
		fDataPortDataLocked = FALSE;
	}

	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:
	if ( pDataPort != NULL )
	{
		if ( fDataPortBoundToNetwork != FALSE )
		{
			pDataPort->UnbindFromNetwork();
			fDataPortBoundToNetwork = FALSE;
		}

		if ( fDataPortCreated != FALSE )
		{
			if ( pDataPort->GetHandle() != 0 )
			{
				GetThreadPool()->CloseDataPortHandle( pDataPort );
				DNASSERT( pDataPort->GetHandle() == 0 );
			}

			pDataPort->DecRef();
			fDataPortCreated = FALSE;
		}
		
		pDataPort = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::UnbindEndpoint - unbind an endpoint from a dataport
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::UnbindEndpoint"

void	CModemSPData::UnbindEndpoint( CModemEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	CDataPort	*pDataPort;
	DWORD		dwDeviceID;
	BOOL		fCleanUpDataPort;


 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p, %u)", this, pEndpoint, EndpointType);

 	
	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	pDataPort = NULL;
	fCleanUpDataPort = FALSE;

	pDataPort = pEndpoint->GetDataPort();
	dwDeviceID = pDataPort->GetDeviceID();
	
	LockDataPortData();

	pDataPort->UnbindEndpoint( pEndpoint, EndpointType );
	if ( pDataPort->EndpointDecRef() == 0 )
	{
		DNASSERT( m_DataPortList[ dwDeviceID ] == pDataPort );
		m_DataPortList[ dwDeviceID ] = NULL;
		fCleanUpDataPort = TRUE;
	}

	UnlockDataPortData();

	if ( fCleanUpDataPort != FALSE )
	{
		pDataPort->DecRef();
		fCleanUpDataPort = FALSE;
	}
	
	
	DPFX(DPFPREP, 9, "(0x%p) Leave", this);
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CModemSPData::GetNewEndpoint - get a new endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to new endpoint
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::GetNewEndpoint"

CModemEndpoint	*CModemSPData::GetNewEndpoint( void )
{
	HRESULT		hTempResult;
	CModemEndpoint	*pEndpoint;
	DPNHANDLE	hEndpoint;
	ENDPOINT_POOL_CONTEXT	PoolContext;

	
 	DPFX(DPFPREP, 9, "(0x%p) Enter", this);
 	
	//
	// initialize
	//
	pEndpoint = NULL;
	hEndpoint = 0;
	memset( &PoolContext, 0x00, sizeof( PoolContext ) );

	PoolContext.pSPData = this;
	pEndpoint = CreateEndpoint( &PoolContext );
	if ( pEndpoint == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create endpoint!" );
		goto Failure;
	}
	
	hTempResult = m_HandleTable.Create( pEndpoint, &hEndpoint );
	if ( hTempResult != DPN_OK )
	{
		DNASSERT( hEndpoint == 0 );
		DPFX(DPFPREP,  0, "Failed to create endpoint handle!" );
		DisplayErrorCode( 0, hTempResult );
		goto Failure;
	}

	pEndpoint->SetHandle( hEndpoint );
	pEndpoint->AddCommandRef();
	pEndpoint->DecRef();

Exit:
	
	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%p]", this, pEndpoint);
	
	return	pEndpoint;

Failure:
	if ( hEndpoint != 0 )
	{
		m_HandleTable.Destroy( hEndpoint, NULL );
		hEndpoint = 0;
	}

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::EndpointFromHandle - get endpoint from handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::EndpointFromHandle"

CModemEndpoint	*CModemSPData::EndpointFromHandle( const DPNHANDLE hEndpoint )
{
	CModemEndpoint	*pEndpoint;


 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p)", this, hEndpoint);
 	
	pEndpoint = NULL;

	m_HandleTable.Lock();
	if (SUCCEEDED(m_HandleTable.Find( hEndpoint, (PVOID*)&pEndpoint )))
	{
		pEndpoint->AddCommandRef();
	}
	m_HandleTable.Unlock();

	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%p]", this, pEndpoint);

	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::CloseEndpointHandle - close endpoint handle
//
// Entry:		Poiner to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::CloseEndpointHandle"

void	CModemSPData::CloseEndpointHandle( CModemEndpoint *const pEndpoint )
{
	DPNHANDLE	Handle;

	DNASSERT( pEndpoint != NULL );
	Handle = pEndpoint->GetHandle();


	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p {handle = 0x%p})",
		this, pEndpoint, Handle);
	
	if (SUCCEEDED(m_HandleTable.Destroy( Handle, NULL )))
	{
		pEndpoint->DecCommandRef();
	}

	DPFX(DPFPREP, 9, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::GetEndpointAndCloseHandle - get endpoint from handle and close the
//		handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint (it needs a call to 'DecCommandRef' when done)
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemSPData::GetEndpointAndCloseHandle"

CModemEndpoint	*CModemSPData::GetEndpointAndCloseHandle( const DPNHANDLE hEndpoint )
{
	CModemEndpoint	*pEndpoint;


 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p)", this, hEndpoint);


	//
	// initialize
	//
	pEndpoint = NULL;

	if (SUCCEEDED( m_HandleTable.Destroy( hEndpoint, (PVOID*)&pEndpoint )))
	{
		pEndpoint->AddRef();
	}

	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%p]", this, pEndpoint);
	
	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemSPData::DestroyThisObject - destroy this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CModemSPData::DestroyThisObject"
void	CModemSPData::DestroyThisObject( void )
{
	Deinitialize();
	delete	this;		// maybe a little too extreme......
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemspdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.h
 *  Content:	Global information for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Derived from Locals.h
 ***************************************************************************/

#ifndef __SPDATA_H__
#define __SPDATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of the states the SP can be in
//
typedef enum
{
	SPSTATE_UNINITIALIZED = 0,	// uninitialized state
	SPSTATE_INITIALIZED,		// service provider has been initialized
	SPSTATE_CLOSING				// service provider is closing
} SPSTATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CComPortData;
class	CDataPort;
class	CModemEndpoint;
class	CModemThreadPool;
typedef	enum	_ENDPOINT_TYPE	ENDPOINT_TYPE;

//
// class for information used by the provider
//
class	CModemSPData
{	
	public:
		CModemSPData();
		~CModemSPData();
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemSPData::AddRef"
		DWORD	AddRef( void ) 
		{ 
			return DNInterlockedIncrement( &m_lRefCount ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemSPData::DecRef"
		DWORD	DecRef( void )
		{
			DWORD	dwReturn;
			
			DNASSERT( m_lRefCount != 0);
			dwReturn = DNInterlockedDecrement( &m_lRefCount );
			if ( dwReturn == 0 )
			{
				//
				// WARNING, the following function deletes this object!!!
				//
				DestroyThisObject();
			}

			return	dwReturn;
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CModemSPData::ObjectAddRef"
		void	ObjectAddRef( void )
		{
			AddRef();
			
			Lock();
			if ( DNInterlockedIncrement( &m_lObjectRefCount ) == 1 )
			{
				DNASSERT( m_hShutdownEvent != NULL );
				if ( DNResetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Failed to reset shutdown event!" );
					DisplayErrorCode( 0, dwError );
				}
			}

			Unlock();
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CModemSPData::ObjectDecRef"
		void	ObjectDecRef( void )
		{
			Lock();

			if ( DNInterlockedDecrement( &m_lObjectRefCount ) == 0 )
			{
				if ( DNSetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Failed to set shutdown event!" );
					DisplayErrorCode( 0, dwError );
				}
			}
			
			Unlock();
			
			DecRef();
		}
		
		
		HRESULT	Initialize( const SP_TYPE SPType,
							IDP8ServiceProviderVtbl *const pVtbl );
		void	Shutdown( void );
		void	Deinitialize( void );

		void	SetCallbackData( const SPINITIALIZEDATA *const pInitData );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		SPSTATE	GetState( void ) const { return m_State; }
		void	SetState( const SPSTATE NewState ) { m_State = NewState; }

		CModemThreadPool	*GetThreadPool( void ) const { return m_pThreadPool; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemSPData::SetThreadPool"
		void	SetThreadPool( CModemThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}

		HRESULT BindEndpoint( CModemEndpoint *const pEndpoint,
							  const DWORD dwDeviceID,
							  const void *const pDeviceContext );
		
		void	UnbindEndpoint( CModemEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );

		void	LockDataPortData( void ) { DNEnterCriticalSection( &m_DataPortDataLock ); }
		void 	UnlockDataPortData( void ) { DNLeaveCriticalSection( &m_DataPortDataLock ); }

		//
		// endpoint and data port pool management
		//
		CModemEndpoint	*GetNewEndpoint( void );
		CModemEndpoint	*EndpointFromHandle( const DPNHANDLE hEndpoint );
		void		CloseEndpointHandle( CModemEndpoint *const pEndpoint );
		CModemEndpoint	*GetEndpointAndCloseHandle( const DPNHANDLE hEndpoint );

		//
		// COM functions
		//
		SP_TYPE	GetType( void ) const { return m_SPType; }
		IDP8SPCallback	*DP8SPCallbackInterface( void ) { return reinterpret_cast<IDP8SPCallback*>( m_InitData.pIDP ); }
		IDP8ServiceProvider	*COMInterface( void ) { return reinterpret_cast<IDP8ServiceProvider*>( &m_COMInterface ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemSPData::SPDataFromCOMInterface"
		static	CModemSPData	*SPDataFromCOMInterface( IDP8ServiceProvider *const pCOMInterface )
		{
			DNASSERT( pCOMInterface != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pCOMInterface ) );
			DBG_CASSERT( sizeof( CModemSPData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CModemSPData*>( &reinterpret_cast<BYTE*>( pCOMInterface )[ -OFFSETOF( CModemSPData, m_COMInterface ) ] );
		}

	private:
		BYTE				m_Sig[4];			// debugging signature ('SPDT')
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_Lock;				// lock
#endif // !DPNBUILD_ONLYONETHREAD
		volatile LONG		m_lRefCount;		// reference count
		volatile LONG		m_lObjectRefCount;	// reference count ofo objects (CDataPort, CModemEndpoint, etc.)
		DNHANDLE			m_hShutdownEvent;	// event signalled when all objects are gone
		SP_TYPE				m_SPType;			// SP type
		SPSTATE				m_State;			// status of the service provider
		SPINITIALIZEDATA	m_InitData;			// initialization data
		CModemThreadPool			*m_pThreadPool;		// thread pool for jobs

		CHandleTable		m_HandleTable;		// handle table

#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_DataPortDataLock;
#endif // !DPNBUILD_ONLYONETHREAD
		CDataPort		*m_DataPortList[ MAX_DATA_PORTS ];

		BOOL	m_fLockInitialized;
		BOOL	m_fHandleTableInitialized;
		BOOL	m_fDataPortDataLockInitialized;
		BOOL	m_fInterfaceGlobalsInitialized;

		struct
		{
			IDP8ServiceProviderVtbl	*m_pCOMVtbl;
		} m_COMInterface;

		void	DestroyThisObject( void );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent unwarranted copies
		//
		CModemSPData( const CModemSPData & );
		CModemSPData& operator=( const CModemSPData & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __SPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemthreadpool.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ThreadPool.cpp
 *  Content:	main job thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// events for threads
//
enum
{
	EVENT_INDEX_STOP_ALL_THREADS = 0,
	EVENT_INDEX_PENDING_JOB = 1,
	EVENT_INDEX_WAKE_NT_TIMER_THREAD = 1,
	EVENT_INDEX_SEND_COMPLETE = 2,
	EVENT_INDEX_RECEIVE_COMPLETE = 3,
	EVENT_INDEX_TAPI_MESSAGE = 4,

	EVENT_INDEX_MAX
};

//
// times to wait in milliseconds when polling for work thread shutdown
//
#define	WORK_THREAD_CLOSE_WAIT_TIME		3000
#define	WORK_THREAD_CLOSE_SLEEP_TIME	100

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// structure for common data in Win9x thread
//
typedef	struct	_WIN9X_CORE_DATA
{
	DWORD		dwNextTimerJobTime;					// time when the next timer job needs service
	DNHANDLE	hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
	DWORD		dwWaitHandleCount;					// count of handles to wait on
	DWORD		dwTimeToNextJob;					// time to next job
	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
	BOOL		fLooping;							// Boolean indicating that this thread is still active

} WIN9X_CORE_DATA;

//
// information passed to the Win9x workhorse thread
//
typedef struct	_WIN9X_THREAD_DATA
{
	CModemThreadPool		*pThisThreadPool;	// pointer to this object
} WIN9X_THREAD_DATA;

//
// information passed to the IOCompletion thread
//
typedef struct	_IOCOMPLETION_THREAD_DATA
{
	CModemThreadPool		*pThisThreadPool;	// pointer to this object
} IOCOMPLETION_THREAD_DATA;

//
// structure passed to dialog threads
//
typedef	struct	_DIALOG_THREAD_PARAM
{
	DIALOG_FUNCTION	*pDialogFunction;
	void			*pContext;
	CModemThreadPool		*pThisThreadPool;
} DIALOG_THREAD_PARAM;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::PoolAllocFunction
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::PoolAllocFunction"

BOOL CModemThreadPool::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CModemThreadPool* pThreadPool = (CModemThreadPool*)pvItem;

	pThreadPool->m_iTotalThreadCount = 0;
#ifdef WINNT
	pThreadPool->m_iNTCompletionThreadCount = 0;
	pThreadPool->m_fNTTimerThreadRunning = FALSE;
	pThreadPool->m_hIOCompletionPort = NULL;
#endif // WINNT
	pThreadPool->m_fAllowThreadCountReduction = FALSE;
	pThreadPool->m_iIntendedThreadCount = 0;
	pThreadPool->m_hStopAllThreads = NULL;
#ifdef WIN95
	pThreadPool->m_hSendComplete = NULL;
	pThreadPool->m_hReceiveComplete = NULL;
	pThreadPool->m_hTAPIEvent = NULL;
	pThreadPool->m_hFakeTAPIEvent = NULL;
#endif // WIN95
	pThreadPool->m_fTAPIAvailable = FALSE; 
	pThreadPool->m_iRefCount = 0;

	pThreadPool->m_Sig[0] = 'T';
	pThreadPool->m_Sig[1] = 'H';
	pThreadPool->m_Sig[2] = 'P';
	pThreadPool->m_Sig[3] = 'L';
	
	pThreadPool->m_OutstandingReadList.Initialize();
	pThreadPool->m_OutstandingWriteList.Initialize();
	memset( &pThreadPool->m_InitFlags, 0x00, sizeof( pThreadPool->m_InitFlags ) );
	memset( &pThreadPool->m_TAPIInfo, 0x00, sizeof( pThreadPool->m_TAPIInfo ) );
	pThreadPool->m_TimerJobList.Initialize();

	return TRUE;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CModemThreadPool::PoolInitFunction
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::PoolInitFunction"

void CModemThreadPool::PoolInitFunction( void* pvItem, void* pvContext )
{
	CModemThreadPool* pThreadPool = (CModemThreadPool*)pvItem;

	DNASSERT(pThreadPool->m_iRefCount == 0);
	pThreadPool->m_iRefCount = 1;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::PoolDeallocFunction
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::PoolDeallocFunction"

void CModemThreadPool::PoolDeallocFunction( void* pvItem )
{
	const CModemThreadPool* pThreadPool = (CModemThreadPool*)pvItem;

	DNASSERT( pThreadPool->m_iTotalThreadCount == 0 );
#ifdef WINNT
	DNASSERT( pThreadPool->m_iNTCompletionThreadCount == 0 );
	DNASSERT( pThreadPool->m_fNTTimerThreadRunning == FALSE );
	DNASSERT( pThreadPool->m_hIOCompletionPort == NULL );
#endif // WINNT
	DNASSERT( pThreadPool->m_fAllowThreadCountReduction == FALSE );
	DNASSERT( pThreadPool->m_iIntendedThreadCount == 0 );
	DNASSERT( pThreadPool->m_hStopAllThreads == NULL );
#ifdef WIN95
	DNASSERT( pThreadPool->m_hSendComplete == NULL );
	DNASSERT( pThreadPool->m_hReceiveComplete == NULL );
	DNASSERT( pThreadPool->m_hTAPIEvent == NULL );
	DNASSERT( pThreadPool->m_hFakeTAPIEvent == NULL );
#endif // WIN95
	DNASSERT( pThreadPool->m_fTAPIAvailable == FALSE );

	DNASSERT( pThreadPool->m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( pThreadPool->m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( pThreadPool->m_TimerJobList.IsEmpty() != FALSE );

	DNASSERT( pThreadPool->m_InitFlags.fTAPILoaded == FALSE );
	DNASSERT( pThreadPool->m_InitFlags.fLockInitialized == FALSE );
	DNASSERT( pThreadPool->m_InitFlags.fIODataLockInitialized == FALSE );
	DNASSERT( pThreadPool->m_InitFlags.fJobDataLockInitialized == FALSE );
	DNASSERT( pThreadPool->m_InitFlags.fTimerDataLockInitialized == FALSE );
	DNASSERT( pThreadPool->m_InitFlags.fJobQueueInitialized == FALSE );
	DNASSERT( pThreadPool->m_iRefCount == 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::Initialize - initialize work threads
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::Initialize"

BOOL	CModemThreadPool::Initialize( void )
{
	HRESULT	hTempResult;
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;
	DNASSERT( m_InitFlags.fTAPILoaded == FALSE );
	DNASSERT( m_InitFlags.fLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fDataPortHandleTableInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized == FALSE );

	//
	// try to load TAPI before anything else
	//
	hTempResult = LoadTAPILibrary();
	if ( hTempResult == DPN_OK )
	{
		m_InitFlags.fTAPILoaded = TRUE;
	}
	else
	{
		DPFX(DPFPREP,  0, "Failed to load TAPI!" );
		DisplayDNError( 0, hTempResult );
	}

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	m_InitFlags.fLockInitialized = TRUE;

	//
	// Win9x has poor APC support and as part of the workaround, the read and
	// write data locks need to be taken twice.  Adjust the recursion counts
	// accordingly.
	//
	if ( DNInitializeCriticalSection( &m_IODataLock ) == FALSE )
	{
	    goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_IODataLock, 1 );
	DebugSetCriticalSectionGroup( &m_IODataLock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	m_InitFlags.fIODataLockInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_JobDataLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_JobDataLock, 0 );
	DebugSetCriticalSectionGroup( &m_JobDataLock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	m_InitFlags.fJobDataLockInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_TimerDataLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_TimerDataLock, 0 );
	DebugSetCriticalSectionGroup( &m_TimerDataLock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes
	m_InitFlags.fTimerDataLockInitialized = TRUE;

	//
	// handle table
	//
	if ( m_DataPortHandleTable.Initialize() != DPN_OK )
	{
		goto Failure;
	}
	m_InitFlags.fDataPortHandleTableInitialized = TRUE;

	//
	// initialize job queue
	//
	if ( m_JobQueue.Initialize() == FALSE )
	{
		goto Failure;
	}
	m_InitFlags.fJobQueueInitialized = TRUE;

	//
	// Create event to stop all threads.  Win9x needs this to stop processing
	// and the NT enum thread uses this to stop processing
	//
	DNASSERT( m_hStopAllThreads == NULL );
	m_hStopAllThreads = DNCreateEvent( NULL,		// pointer to security (none)
			    					 TRUE,		// manual reset
			    					 FALSE,		// start unsignalled
			    					 NULL );	// pointer to name (none)
	if ( m_hStopAllThreads == NULL )
	{
		DWORD   dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event to stop all threads!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	DNASSERT( m_fAllowThreadCountReduction == FALSE );
	m_fAllowThreadCountReduction = TRUE;

	//
	// OS-specific initialization
	//
#ifdef WINNT
	//
	// WinNT
	//
	if (FAILED(WinNTInit()))
	{
		goto Failure;
	}
#else // WIN95
	//
	// Windows 9x
	//
	if (FAILED(Win9xInit()))
	{
		goto Failure;
	}
#endif // WINNT

	//
	// Verify all internal flags.  It's possible that TAPI didn't load
	// so don't check it (it's not a fatal condition).
	//
	DNASSERT( m_InitFlags.fLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized != FALSE );

Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	StopAllThreads();
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::Deinitialize - destroy work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::Deinitialize"

void	CModemThreadPool::Deinitialize( void )
{
//	DNASSERT( m_JobQueue.IsEmpty() != FALSE );

	//
	// request that all threads stop and then cycle our timeslice to
	// allow the threads a chance for cleanup
	//
	m_fAllowThreadCountReduction = FALSE;
	DPFX(DPFPREP, 9, "SetIntendedThreadCount 0");
	SetIntendedThreadCount( 0 );
	StopAllThreads();
	SleepEx( 0, TRUE );

#ifdef WINNT
	if ( m_hIOCompletionPort != NULL )
	{
		if ( CloseHandle( m_hIOCompletionPort ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing handle to I/O completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		m_hIOCompletionPort = NULL;
	}
#endif // WINNT

	//
	// close StopAllThreads handle
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( DNCloseHandle( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to close StopAllThreads handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hStopAllThreads = NULL;
	}

#ifdef WIN95
	//
	// close handles for I/O events
	//
	if ( m_hSendComplete != NULL )
	{
		if ( DNCloseHandle( m_hSendComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing SendComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hSendComplete = NULL;
	}

	if ( m_hReceiveComplete != NULL )
	{
		if ( DNCloseHandle( m_hReceiveComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing ReceiveComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hReceiveComplete = NULL;
	}
#endif // WIN95
	//
	// Now that all of the threads are stopped, clean up any outstanding I/O.
	// this can be done without taking any locks
	//
	if (m_InitFlags.fJobQueueInitialized)
	{
		CancelOutstandingIO();	
	}

	//
	// double-check empty IO lists
	//
	DNASSERT( m_OutstandingWriteList.IsEmpty() != FALSE );
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );

	//
	// deinitialize handle table
	//
	if ( m_InitFlags.fDataPortHandleTableInitialized != FALSE )
	{
		m_DataPortHandleTable.Deinitialize();
		m_InitFlags.fDataPortHandleTableInitialized = FALSE;
	}

	//
	// deinitialize job queue
	//
	if ( m_InitFlags.fJobQueueInitialized != FALSE )
	{
		m_JobQueue.Deinitialize();
		m_InitFlags.fJobQueueInitialized = FALSE;
	}

	if ( m_InitFlags.fTimerDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_TimerDataLock );
		m_InitFlags.fTimerDataLockInitialized = FALSE;
	}

	if ( m_InitFlags.fJobDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_JobDataLock );
		m_InitFlags.fJobDataLockInitialized = FALSE;
	}

	if ( m_InitFlags.fIODataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_IODataLock );
		m_InitFlags.fIODataLockInitialized = FALSE;
	}

	if ( m_InitFlags.fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_InitFlags.fLockInitialized = FALSE;
	}

	//
	// unload TAPI
	//
	if ( m_TAPIInfo.hApplicationInstance != NULL )
	{
		DNASSERT( p_lineShutdown != NULL );
		p_lineShutdown( m_TAPIInfo.hApplicationInstance );
		m_TAPIInfo.hApplicationInstance = NULL;
	}
	m_fTAPIAvailable = FALSE;
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );

#ifdef WIN95
	if (m_hTAPIEvent != NULL && m_hFakeTAPIEvent == NULL)
	{
		// In the case that we got the event from lineInitializeEx, lineShutdown will have closed the event handle,
		// so we can tell the handle tracking code that the handle is already cleaned up.
		REMOVE_DNHANDLE(m_hTAPIEvent);
	}
	m_hTAPIEvent = NULL;

	if ( m_hFakeTAPIEvent != NULL )
	{
		if ( DNCloseHandle( m_hFakeTAPIEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing fake TAPI event!" );
			DisplayErrorCode( 0, GetLastError() );
		}

		m_hFakeTAPIEvent = NULL;
	}
#endif // WIN95
	//
	// close TAPI
	//
	if ( m_InitFlags.fTAPILoaded != FALSE )
	{
		UnloadTAPILibrary();
		m_InitFlags.fTAPILoaded = FALSE;
	}

	DNASSERT( m_InitFlags.fTAPILoaded == FALSE );
	DNASSERT( m_InitFlags.fLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::CreateReadIOData - create read IO data
//
// Entry:		Nothing
//
// Exit:		Pointer to Read IO Data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::CreateReadIOData"

CModemReadIOData	*CModemThreadPool::CreateReadIOData( void )
{
	CModemReadIOData	*pReadData;


	LockReadData();
#ifdef WIN95
	pReadData = (CModemReadIOData*)g_ModemReadIODataPool.Get( GetReceiveCompleteEvent() );
#else
	pReadData = (CModemReadIOData*)g_ModemReadIODataPool.Get( NULL );
#endif // WIN95
	if ( pReadData != NULL )
	{
		pReadData->SetThreadPool( this );
		pReadData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );
	}

	UnlockReadData();
	return	pReadData;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::ReturnReadIOData - return read data to pool
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ReturnReadIOData"

void	CModemThreadPool::ReturnReadIOData( CModemReadIOData *const pReadIOData )
{
	DNASSERT( pReadIOData != NULL );

	LockReadData();

	pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
	DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	g_ModemReadIODataPool.Release( pReadIOData );

	UnlockReadData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::CreateWriteIOData - create Write IO data
//
// Entry:		Nothing
//
// Exit:		Pointer to Write IO Data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::CreateWriteIOData"

CModemWriteIOData	*CModemThreadPool::CreateWriteIOData( void )
{
	CModemWriteIOData	*pWriteData;


	LockWriteData();
#ifdef WIN95
	pWriteData = (CModemWriteIOData*)g_ModemWriteIODataPool.Get( GetSendCompleteEvent() );
#else // WINNT
	pWriteData = (CModemWriteIOData*)g_ModemWriteIODataPool.Get( NULL );
#endif // WIN95
	if ( pWriteData != NULL )
	{
		pWriteData->m_OutstandingWriteListLinkage.InsertBefore( &m_OutstandingWriteList );
	}

	UnlockWriteData();
	return	pWriteData;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::ReturnWriteIOData - return write data to pool
//
// Entry:		Pointer to Write data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ReturnWriteIOData"

void	CModemThreadPool::ReturnWriteIOData( CModemWriteIOData *const pWriteIOData )
{
	DNASSERT( pWriteIOData != NULL );

	LockWriteData();

	pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();

	g_ModemWriteIODataPool.Release( pWriteIOData );

	UnlockWriteData();
}
//**********************************************************************

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CModemThreadPool::WinNTInit - initialize WinNT components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::WinNTInit"

HRESULT	CModemThreadPool::WinNTInit( void )
{
	HRESULT					hr;
	LINEINITIALIZEEXPARAMS	LineInitializeExParams;
	LONG					lReturn;


	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_hIOCompletionPort == NULL );
	m_hIOCompletionPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,	    // don't associate a file handle yet
												  NULL,					    // handle of existing completion port (none)
												  NULL,					    // completion key for callback (none)
												  0						    // number of concurent threads (0 = use number of processors)
												  );
	if ( m_hIOCompletionPort == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not create NT IOCompletionPort!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// Initialize TAPI.  If TAPI doesn't start, it's not a problem, but note
	// the failure.
	//
	DNASSERT( m_fTAPIAvailable == FALSE );
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );
	memset( &LineInitializeExParams, 0x00, sizeof( LineInitializeExParams ) );
	m_TAPIInfo.dwVersion = TAPI_CURRENT_VERSION;
	LineInitializeExParams.dwTotalSize = sizeof( LineInitializeExParams );
	LineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT;
	LineInitializeExParams.dwCompletionKey = IO_COMPLETION_KEY_TAPI_MESSAGE;
	DNASSERT( GetIOCompletionPort() != NULL );
	LineInitializeExParams.Handles.hCompletionPort = GetIOCompletionPort();

	lReturn = LINEERR_UNINITIALIZED;

	if ( p_lineInitializeEx != NULL )
	{
		lReturn = p_lineInitializeEx( &m_TAPIInfo.hApplicationInstance,		// pointer to application TAPI instance handle
									  DNGetApplicationInstance(),			// instance handle of .DLL
									  NULL,									// callback function (not used)
									  NULL,									// friendly application name (none)
									  &m_TAPIInfo.dwLinesAvailable,			// pointer to number of devices available to TAPI
									  &m_TAPIInfo.dwVersion,				// pointer to input/output TAPI version
									  &LineInitializeExParams );			// pointer to extra params
	}

	if ( lReturn == LINEERR_NONE )
	{
		m_fTAPIAvailable = TRUE;
	}
	else
	{
		DPFX(DPFPREP,  0, "Failed to initialize TAPI for NT!" );
	}


	//
	// Prepare to spin up IOCompletionPort threads
	//
	DNASSERT( ThreadCount() == 0 );
	DNASSERT( NTCompletionThreadCount() == 0 );

	DPFX(DPFPREP, 9, "SetIntendedThreadCount %i", g_iThreadCount);
	SetIntendedThreadCount( g_iThreadCount );

Exit:
	return	hr;

Failure:
	DPFX(DPFPREP,  0, "Failed WinNT initialization!" );
	DisplayDNError( 0, hr );

	goto Exit;
}
//**********************************************************************
#endif // WINNT

#ifdef WIN95
//**********************************************************************
// ------------------------------
// CModemThreadPool::Win9xInit - initialize Win9x components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::Win9xInit"

HRESULT	CModemThreadPool::Win9xInit( void )
{
	HRESULT		hr;
	DNHANDLE	hPrimaryThread;
	DWORD		dwPrimaryThreadID;
	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
	LINEINITIALIZEEXPARAMS	LineInitializeExParams;
	LONG		lReturn;


	//
	// initialize
	//
	hr = DPN_OK;
	hPrimaryThread = NULL;
	pPrimaryThreadInput = NULL;

	//
	// Initialize TAPI.  If this succeeds, it will give us an event to use for
	// TAPI messages.  If not, create a fake event that will take the place of
	// the TAPI event for the Win9x threads.
	//
	DNASSERT( m_fTAPIAvailable == FALSE );
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );
	memset( &LineInitializeExParams, 0x00, sizeof( LineInitializeExParams ) );
	m_TAPIInfo.dwVersion = TAPI_CURRENT_VERSION;
	LineInitializeExParams.dwTotalSize = sizeof( LineInitializeExParams );
	LineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;

	lReturn = LINEERR_UNINITIALIZED;
	if ( p_lineInitializeEx != NULL )
	{
		lReturn = p_lineInitializeEx( &m_TAPIInfo.hApplicationInstance,		// pointer to application TAPI instance handle
									  DNGetApplicationInstance(),			// instance handle of .DLL
									  NULL,									// callback function (not used)
									  NULL,									// friendly application name (none)
									  &m_TAPIInfo.dwLinesAvailable,			// pointer to number of devices available to TAPI
									  &m_TAPIInfo.dwVersion,				// pointer to input/output TAPI version
									  &LineInitializeExParams );			// pointer to extra params
	}

	if ( lReturn == LINEERR_NONE )
	{
		m_hTAPIEvent = MAKE_DNHANDLE(LineInitializeExParams.Handles.hEvent);
		m_fTAPIAvailable = TRUE;
	}
	else
	{
		DPFX(DPFPREP,  0, "Failed to initialize TAPI for Win9x!" );
		DNASSERT( m_hTAPIEvent == NULL );
		DNASSERT( m_hFakeTAPIEvent == NULL );
		m_hFakeTAPIEvent = DNCreateEvent( NULL,		// pointer to security (none)
										TRUE,		// manual reset
										FALSE,		// start unsignalled
										NULL );		// pointer to name (none)
		if ( m_hFakeTAPIEvent == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to create fake TAPI event!" );
			DisplayErrorCode( 0, hr );
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		m_hTAPIEvent = m_hFakeTAPIEvent;
		DNASSERT( m_fTAPIAvailable == FALSE );
	}

	//
	// create send complete event
	//
	DNASSERT( m_hSendComplete == NULL );
	m_hSendComplete = DNCreateEvent( NULL,	// pointer to security (none)
								   TRUE,	// manual reset
								   FALSE,	// start unsignalled
								   NULL		// pointer to name (none)
								   );
	if ( m_hSendComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event for Send!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// create receive complete event
	//
	DNASSERT( m_hReceiveComplete == NULL );
	m_hReceiveComplete = DNCreateEvent( NULL,		// pointer to security (none)
									  TRUE,		// manual reset
									  FALSE,	// start unsignalled
									  NULL		// pointer to name (none)
									  );
	if ( m_hReceiveComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event for Receive!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// create parameters to worker threads
	//
	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
	if ( pPrimaryThreadInput == NULL )
	{
		DPFX(DPFPREP,  0, "Problem allocating memory for primary Win9x thread!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
	pPrimaryThreadInput->pThisThreadPool = this;

	//
	// Create one worker thread and boost its priority.  If the primary thread
	// can be created and boosted, create a secondary thread.  Do not create a
	// secondary thread if the primary could not be boosted because the system
	// is probably low on resources.
	//
	IncrementActiveThreadCount();
	hPrimaryThread = DNCreateThread( NULL,					// pointer to security attributes (none)
								   0,						// stack size (default)
								   PrimaryWin9xThread,		// pointer to thread function
								   pPrimaryThreadInput,		// pointer to input parameter
								   0,						// let it run
								   &dwPrimaryThreadID		// pointer to destination of thread ID
								   );
	if ( hPrimaryThread == NULL )
	{
		DWORD	dwError;


		//
		// Failed to create thread, decrement active thread count and report
		// error.
		//
		DecrementActiveThreadCount();

		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem creating Win9x thread!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;

		goto Failure;
	}
	pPrimaryThreadInput = NULL;


	DPFX(DPFPREP,  8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
	DNASSERT( hPrimaryThread != NULL );

#if ADJUST_THREAD_PRIORITY
	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
		DisplayErrorCode( 0, dwError );
	}
#endif // ADJUST_THREAD_PRIORITY

	//
	// Disallow thread reduction right off the bat.
	// We give them these two threads and that's what they're stuck with.
	//
	m_fAllowThreadCountReduction = FALSE;


Exit:
	if ( pPrimaryThreadInput != NULL )
	{
		DNFree( pPrimaryThreadInput );
		pPrimaryThreadInput = NULL;
	}

	if ( hPrimaryThread != NULL )
	{
		if ( DNCloseHandle( hPrimaryThread ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing Win9x thread hanle!" );
			DisplayErrorCode( 0, dwError );
		}

		hPrimaryThread = NULL;
	}

	return	hr;

Failure:
	DPFX(DPFPREP,  0, "Failed Win9x Initialization!" );
	DisplayDNError( 0, hr );
	goto Exit;
}
//**********************************************************************
#endif // WIN95

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CModemThreadPool::StartNTCompletionThread - start a WinNT completion thread
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::StartNTCompletionThread"

void	CModemThreadPool::StartNTCompletionThread( void )
{
	DNHANDLE	hThread;
	DWORD		dwThreadID;
	IOCOMPLETION_THREAD_DATA	*pIOCompletionThreadData;


	pIOCompletionThreadData = static_cast<IOCOMPLETION_THREAD_DATA*>( DNMalloc( sizeof( *pIOCompletionThreadData ) ) );
	if ( pIOCompletionThreadData != NULL )
	{
		pIOCompletionThreadData->pThisThreadPool = this;
		hThread = NULL;
		hThread = DNCreateThread( NULL,						// pointer to security attributes (none)
								0,							// stack size (default)
								WinNTIOCompletionThread,	// thread function
								pIOCompletionThreadData,	// thread parameter
								0,							// start thread immediately
								&dwThreadID					// pointer to thread ID destination
								);
		if ( hThread != NULL )
		{
			//
			// note that a thread was created, and close the handle
			// to the thread because it's no longer needed.
			//
			IncrementActiveNTCompletionThreadCount();

			DPFX(DPFPREP,  8, "Creating I/O completion thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, ThreadCount(), NTCompletionThreadCount() );
			if ( DNCloseHandle( hThread ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem creating thread for I/O completion port" );
				DisplayErrorCode( 0, dwError );
			}
		}
		else
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to create I/O completion thread!" );
			DisplayErrorCode( 0, dwError );

			DNFree( pIOCompletionThreadData );
		}
	}
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CModemThreadPool::StopAllThreads - stop all work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::StopAllThreads"

void	CModemThreadPool::StopAllThreads( void )
{
	//
	// stop all non-I/O completion threads
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( DNSetEvent( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to set event to stop all threads!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	//
	// If we're running on NT submit enough jobs to stop all threads.
	//
#ifdef WINNT
	UINT_PTR	uIndex;


	uIndex = NTCompletionThreadCount();
	while ( uIndex > 0 )
	{
		uIndex--;
		if ( PostQueuedCompletionStatus( m_hIOCompletionPort,		    // handle of completion port
										 0,							    // number of bytes transferred
										 IO_COMPLETION_KEY_SP_CLOSE,    // completion key
										 NULL						    // pointer to overlapped structure (none)
										 ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem submitting Stop job to IO completion port!" );
			DisplayErrorCode( 0, dwError );
		}
	}
#endif // WINNT
	//
	// check for outstanding threads (no need to lock thread pool count)
	//
	DPFX(DPFPREP,  8, "Number of outstanding threads: %d", ThreadCount() );
	while ( ThreadCount() != 0 )
	{
		DPFX(DPFPREP,  8, "Waiting for %d threads to quit.", ThreadCount() );
		SleepEx( WORK_THREAD_CLOSE_SLEEP_TIME, TRUE );
	}

	DNASSERT( ThreadCount() == 0 );
	m_iTotalThreadCount = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::CancelOutstandingIO - cancel outstanding IO
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::CancelOutstandingIO"

void	CModemThreadPool::CancelOutstandingIO( void )
{
	CBilink	*pTemp;


	DNASSERT( ThreadCount() == 0 );

	//
	// stop any receives with the notification that they were cancelled
	//
	pTemp = m_OutstandingReadList.GetNext();
	while ( pTemp != &m_OutstandingReadList )
	{
		CModemReadIOData	*pReadData;


		pReadData = CModemReadIOData::ReadDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pReadData->m_OutstandingReadListLinkage.RemoveFromList();

		DPFX(DPFPREP, 1, "Forcing read data 0x%p to be cancelled.", pReadData);

#ifdef WIN95
		DNASSERT( pReadData->Win9xOperationPending() != FALSE );
		pReadData->SetWin9xOperationPending( FALSE );
#endif // WIN95
		pReadData->DataPort()->ProcessReceivedData( 0, ERROR_OPERATION_ABORTED );
	}

	//
	// stop any pending writes with the notification that the user cancelled it.
	//
	pTemp = m_OutstandingWriteList.GetNext();
	while ( pTemp != &m_OutstandingWriteList )
	{
		CModemWriteIOData	*pWriteData;


		pWriteData = CModemWriteIOData::WriteDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();

		DPFX(DPFPREP, 1, "Forcing write data 0x%p to be cancelled.", pWriteData);

#ifdef WIN95
		DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
		pWriteData->SetWin9xOperationPending( FALSE );
#endif // WIN95
		pWriteData->DataPort()->SendComplete( pWriteData, DPNERR_USERCANCEL );
	}

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pJob;


		pJob = m_JobQueue.DequeueJob();
		DNASSERT( pJob != NULL );
		if (pJob->pCancelFunction != NULL)
		{
			pJob->pCancelFunction( pJob );
		}
		pJob->JobType = JOB_UNINITIALIZED;

		g_ModemThreadPoolJobPool.Release( pJob );
	};
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ReturnSelfToPool"

void	CModemThreadPool::ReturnSelfToPool( void )
{
	g_ModemThreadPoolPool.Release( this );
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CModemThreadPool::ProcessTimerJobs - process timed jobs
//
// Entry:		Pointer to job list
//				Pointer to destination for time of next job
//
// Exit:		Boolean indicating active jobs exist
//				TRUE = there are active jobs
//				FALSE = there are no active jobs
//
// Notes:	The input job queue is expected to be locked for the duration
//			of this function call!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ProcessTimerJobs"

BOOL	CModemThreadPool::ProcessTimerJobs( const CBilink *const pJobList, DWORD *const pdwNextJobTime )
{
	BOOL		fReturn;
	CBilink		*pWorkingEntry;
	INT_PTR		iActiveTimerJobCount;
	DWORD		dwCurrentTime;


	DNASSERT( pJobList != NULL );
	DNASSERT( pdwNextJobTime != NULL );

	//
	// Initialize.  Set the next job time to be infinitely far in the future
	// so this thread will wake up for any jobs that need to completed before
	// then.
	//
	fReturn = FALSE;
	DBG_CASSERT( OFFSETOF( TIMER_OPERATION_ENTRY, Linkage ) == 0 );
	pWorkingEntry = pJobList->GetNext();
	iActiveTimerJobCount = 0;
	dwCurrentTime = GETTIMESTAMP();
	(*pdwNextJobTime) = dwCurrentTime - 1;

	//
	// loop through all timer items
	//
	while ( pWorkingEntry != pJobList )
	{
		TIMER_OPERATION_ENTRY	*pTimerEntry;
		BOOL	fJobActive;


		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pWorkingEntry );
		pWorkingEntry = pWorkingEntry->GetNext();

		fJobActive = ProcessTimedOperation( pTimerEntry, dwCurrentTime, pdwNextJobTime );
		DNASSERT( ( fJobActive == FALSE ) || ( fJobActive == TRUE ) );

		fReturn |= fJobActive;

		if ( fJobActive == FALSE )
		{
			RemoveTimerOperationEntry( pTimerEntry, DPN_OK );
		}
	}

	DNASSERT( ( fReturn == FALSE ) || ( fReturn == TRUE ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::ProcessTimedOperation - process a timed operation
//
// Entry:		Pointer to job information
//				Current time
//				Pointer to time to be updated
//
// Exit:		Boolean indicating that the job is still active
//				TRUE = operation active
//				FALSE = operation not active
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ProcessTimedOperation"

BOOL	CModemThreadPool::ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pTimedJob,
											const DWORD dwCurrentTime,
											DWORD *const pdwNextJobTime )
{
	BOOL	fEnumActive;


	DNASSERT( pTimedJob != NULL );
	DNASSERT( pdwNextJobTime != NULL );


	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p, %u, 0x%p)",
		this, pTimedJob, dwCurrentTime, pdwNextJobTime);

	//
	// Assume that this enum will remain active.  If we retire this enum, this
	// value will be reset.
	//
	fEnumActive = TRUE;

	//
	// If this enum has completed sending enums and is waiting only
	// for responses, decrement the wait time (assuming it's not infinite)
	// and remove the enum if the we've exceeded its wait time.
	//
	if ( pTimedJob->uRetryCount == 0 )
	{
		if ( (int) ( pTimedJob->dwIdleTimeout - dwCurrentTime ) <= 0 )
		{
			fEnumActive = FALSE;
		}
		else
		{
			//
			// This enum isn't complete, check to see if it's the next enum
			// to need service.
			//
			if ( (int) ( pTimedJob->dwIdleTimeout - (*pdwNextJobTime) ) < 0 )
			{
				(*pdwNextJobTime) = pTimedJob->dwIdleTimeout;
			}
		}
	}
	else
	{
		//
		// This enum is still sending.  Determine if it's time to send a new enum
		// and adjust the wakeup time if appropriate.
		//
		if ( (int) ( pTimedJob->dwNextRetryTime - dwCurrentTime ) <= 0 )
		{
#ifdef DBG
			DWORD	dwDelay;


			dwDelay = dwCurrentTime - pTimedJob->dwNextRetryTime;

			DPFX(DPFPREP, 7, "Threadpool 0x%p performing timed job 0x%p approximately %u ms after intended time of %u.",
				this, pTimedJob, dwDelay, pTimedJob->dwNextRetryTime);
#endif // DBG

			//
			// Timeout, execute this timed item
			//
			pTimedJob->pTimerCallback( pTimedJob->pContext );

			//
			// If this job isn't running forever, decrement the retry count.
			// If there are no more retries, set up wait time.  If the job
			// is waiting forever, set max wait timeout.
			//
			if ( pTimedJob->fRetryForever == FALSE )
			{
				pTimedJob->uRetryCount--;
				if ( pTimedJob->uRetryCount == 0 )
				{
					if ( pTimedJob->fIdleWaitForever == FALSE )
					{
						//
						// Compute stopping time for this job's 'Timeout' phase and
						// see if this will be the next job to need service.
						//
						pTimedJob->dwIdleTimeout += dwCurrentTime;
						if ( (int) (pTimedJob->dwIdleTimeout - (*pdwNextJobTime) ) < 0 )
						{
							(*pdwNextJobTime) = pTimedJob->dwIdleTimeout;
						}
					}
					else
					{
						//
						// We're waiting forever for enum returns.  ASSERT that we
						// have the maximum timeout and don't bother checking to see
						// if this will be the next enum to need service (it'll never
						// need service).
						//
						DNASSERT( pTimedJob->dwIdleTimeout == -1 );
					}

					goto SkipNextRetryTimeComputation;
				}
			}

			pTimedJob->dwNextRetryTime = dwCurrentTime + pTimedJob->dwRetryInterval;
		}

		//
		// is this the next enum to fire?
		//
		if ( (int) ( (*pdwNextJobTime) - pTimedJob->dwNextRetryTime ) < 0 )
		{
			(*pdwNextJobTime) = pTimedJob->dwNextRetryTime;


			DPFX(DPFPREP, 8, "Job 0x%p is the next job to fire (at time %u).",
				pTimedJob, pTimedJob->dwNextRetryTime);
		}
		else
		{
			//
			// Not next job to fire.
			//
		}

SkipNextRetryTimeComputation:
		//
		// the following blank line is there to shut up the compiler
		//
		;
	}


	DPFX(DPFPREP, 9, "(0x%p) Returning [%i]",
		this, fEnumActive);

	return	fEnumActive;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::SubmitWorkItem - submit a work item for processing and inform
//		work thread that another job is available
//
// Entry:		Pointer to job information
//
// Exit:		Error code
//
// Note:	This function assumes that the job data is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::SubmitWorkItem"

HRESULT	CModemThreadPool::SubmitWorkItem( THREAD_POOL_JOB *const pJobInfo )
{
	HRESULT	hr;


	DNASSERT( pJobInfo != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// add job to queue and tell someone that there's a job available
	//
	m_JobQueue.Lock();
	m_JobQueue.EnqueueJob( pJobInfo );
	m_JobQueue.Unlock();

#ifdef WINNT
	//
	// WinNT, submit new I/O completion item
	//
	DNASSERT( m_hIOCompletionPort != NULL );
	if ( PostQueuedCompletionStatus( m_hIOCompletionPort,			// completion port
									 0,								// number of bytes written (unused)
									 IO_COMPLETION_KEY_NEW_JOB,		// completion key
									 NULL							// pointer to overlapped structure (unused)
									 ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem posting completion item for new job!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
#else // WIN95
	//
	// Win9x, set event that the work thread will listen for
	//
	DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to signal pending job!" );
		goto Failure;
	}
#endif // WINNT

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SubmitWorkItem!" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::GetWorkItem - get a work item from the job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job information (may be NULL)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::GetWorkItem"

THREAD_POOL_JOB	*CModemThreadPool::GetWorkItem( void )
{
	THREAD_POOL_JOB	*pReturn;


	//
	// initialize
	//
	pReturn = NULL;

	m_JobQueue.Lock();
	pReturn = m_JobQueue.DequeueJob();

	//
	// if we're under Win9x (we have a 'pending job' handle),
	// see if the handle needs to be reset
	//
	if ( m_JobQueue.IsEmpty() != FALSE )
	{
		DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
		if ( DNResetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem resetting event for pending Win9x jobs!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	m_JobQueue.Unlock();

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::SubmitTimerJob - add a timer job to the timer list
//
// Entry:		Retry count
//				Boolean indicating that we retry forever
//				Retry interval
//				Boolean indicating that we wait forever
//				Idle wait interval
//				Pointer to callback when event fires
//				Pointer to callback when event complete
//				User context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::SubmitTimerJob"

HRESULT	CModemThreadPool::SubmitTimerJob( const UINT_PTR uRetryCount,
									 const BOOL fRetryForever,
									 const DWORD dwRetryInterval,
									 const BOOL fIdleWaitForever,
									 const DWORD dwIdleTimeout,
									 TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
									 TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
									 void *const pContext )
{
	HRESULT					hr;
	TIMER_OPERATION_ENTRY	*pEntry;
	THREAD_POOL_JOB			*pJob;
	BOOL					fTimerJobListLocked;


	DNASSERT( uRetryCount != 0 );
	DNASSERT( pTimerCallbackFunction != NULL );
	DNASSERT( pTimerCompleteFunction != NULL );
	DNASSERT( pContext != NULL );				// must be non-NULL because it's the lookup key to remove job

	//
	// initialize
	//
	hr = DPN_OK;
	pEntry = NULL;
	pJob = NULL;
	fTimerJobListLocked = FALSE;

	LockJobData();

	//
	// If we're on NT, attempt to start the enum thread here so we can return
	// an error if it fails to start.  If it does start, it'll sit until it's
	// informed that an enum job has been added.
	//
#ifdef WINNT
	hr = StartNTTimerThread();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Cannot spin up NT timer thread!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
#endif // WINNT
	//
	// allocate new enum entry
	//
	pEntry = static_cast<TIMER_OPERATION_ENTRY*>( g_ModemTimerEntryPool.Get( ) );
	if ( pEntry == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate memory to add to timer list!" );
		goto Failure;
	}
	DNASSERT( pEntry->pContext == NULL );

	//
	// build timer entry block
	//
	pEntry->pContext = pContext;
	pEntry->uRetryCount = uRetryCount;
	pEntry->fRetryForever = fRetryForever;
	pEntry->dwRetryInterval = dwRetryInterval;
	pEntry->dwIdleTimeout = dwIdleTimeout;
	pEntry->fIdleWaitForever = fIdleWaitForever;
	pEntry->pTimerCallback = pTimerCallbackFunction;
	pEntry->pTimerComplete = pTimerCompleteFunction;

	//
	// set this enum to fire as soon as it gets a chance
	//
	pEntry->dwNextRetryTime = 0;

	pJob = static_cast<THREAD_POOL_JOB*>( g_ModemThreadPoolJobPool.Get( ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate memory for enum job!" );
		goto Failure;
	}

	//
	// Create job for work thread.
	//
	pJob->pCancelFunction = NULL;
	pJob->JobType = JOB_REFRESH_TIMER_JOBS;

	// set our dummy paramter to simulate passing data
	DEBUG_ONLY( pJob->JobData.JobRefreshTimedJobs.uDummy = 0 );

	LockTimerData();
	fTimerJobListLocked = TRUE;

	//
	// we can submit the 'ENUM_REFRESH' job before inserting the enum entry
	// into the active enum list because nobody will be able to pull the
	// 'ENUM_REFRESH' job from the queue since we have the queue locked
	//
	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem submitting enum work item" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// debug block to check for duplicate contexts
	//
	DEBUG_ONLY(
				{
					CBilink	*pTempLink;


					pTempLink = m_TimerJobList.GetNext();
					while ( pTempLink != &m_TimerJobList )
					{
						TIMER_OPERATION_ENTRY	*pTempTimerEntry;


						pTempTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempLink );
						DNASSERT( pTempTimerEntry->pContext != pContext );
						pTempLink = pTempLink->GetNext();
					}
				}
			);

	//
	// link to rest of list
	//
	pEntry->Linkage.InsertAfter( &m_TimerJobList );

Exit:
	if ( fTimerJobListLocked != FALSE )
	{
		UnlockTimerData();
		fTimerJobListLocked = FALSE;
	}

	UnlockJobData();

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SubmitEnumJob" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	if ( pEntry != NULL )
	{
		g_ModemTimerEntryPool.Release( pEntry );
		DEBUG_ONLY( pEntry = NULL );
	}

	if ( pJob != NULL )
	{
		g_ModemThreadPoolJobPool.Release( pJob );
		DEBUG_ONLY( pJob = NULL );
	}

	//
	// It's possible that the enum thread has been started for this enum.
	// Since there's no way to stop it without completing the enums or
	// closing the SP, leave it running.
	//

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::StopTimerJob - remove timer job from list
//
// Entry:		Pointer to job context (these MUST be uniquie for jobs)
//				Command result
//
// Exit:		Boolean indicating whether a job was stopped or not
//
// Note:	This function is for the forced removal of a job from the timed job
//			list.  It is assumed that the caller of this function will clean
//			up any messes.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::StopTimerJob"

BOOL	CModemThreadPool::StopTimerJob( void *const pContext, const HRESULT hCommandResult )
{
	BOOL						fComplete = FALSE;
	CBilink *					pTempEntry;
	TIMER_OPERATION_ENTRY *		pTimerEntry;


	DNASSERT( pContext != NULL );

	DPFX(DPFPREP, 9, "Parameters (0x%p, 0x%lx)", pContext, hCommandResult);
	
	//
	// initialize
	//
	LockTimerData();

	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			//
			// remove this link from the list
			//
			pTimerEntry->Linkage.RemoveFromList();

			fComplete = TRUE;

			//
			// terminate loop
			//
			break;
		}

		pTempEntry = pTempEntry->GetNext();
	}

	UnlockTimerData();

	//
 	// tell owner that the job is complete and return the job to the pool
 	// outside of the lock
 	//
	if (fComplete)
	{
		pTimerEntry->pTimerComplete( hCommandResult, pTimerEntry->pContext );
		g_ModemTimerEntryPool.Release( pTimerEntry );
	}


	DPFX(DPFPREP, 9, "Returning [%i]", fComplete);

	return fComplete;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::SpawnDialogThread - start a secondary thread to display service
//		provider UI.
//
// Entry:		Pointer to dialog function
//				Dialog context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::SpawnDialogThread"

HRESULT	CModemThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, void *const pDialogContext )
{
	HRESULT	hr;
	DNHANDLE	hDialogThread;
	DIALOG_THREAD_PARAM		*pThreadParam;
	DWORD	dwThreadID;


	DNASSERT( pDialogFunction != NULL );
	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??


	//
	// initialize
	//
	hr = DPN_OK;
	pThreadParam = NULL;

	//
	// create and initialize thread param
	//
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
	if ( pThreadParam == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to allocate memory for dialog thread!" );
		goto Failure;
	}

	pThreadParam->pDialogFunction = pDialogFunction;
	pThreadParam->pContext = pDialogContext;
	pThreadParam->pThisThreadPool = this;

	//
	// assume that a thread will be created
	//
	IncrementActiveThreadCount();

	//
	// create thread
	//
	hDialogThread = DNCreateThread( NULL,				// pointer to security (none)
								  0,					// stack size (default)
								  DialogThreadProc,		// thread procedure
								  pThreadParam,			// thread param
								  0,					// creation flags (none)
								  &dwThreadID );		// pointer to thread ID
	if ( hDialogThread == NULL )
	{
		DWORD	dwError;


		//
		// decrement active thread count and report error
		//
		DecrementActiveThreadCount();

		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start dialog thread!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	if ( DNCloseHandle( hDialogThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing handle from create dialog thread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:	
	return	hr;

Failure:
	if ( pThreadParam != NULL )
	{
		DNFree( pThreadParam );
		pThreadParam = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::GetIOThreadCount - get I/O thread count
//
// Entry:		Pointer to variable to fill
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CModemThreadPool::GetIOThreadCount"

HRESULT	CModemThreadPool::GetIOThreadCount( LONG *const piThreadCount )
{
	HRESULT	hr;


	DNASSERT( piThreadCount != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		*piThreadCount = GetIntendedThreadCount();
	}
	else
	{
#ifdef WIN95
		*piThreadCount = ThreadCount();
#else // WINNT
		DNASSERT( NTCompletionThreadCount() != 0 );
		*piThreadCount = NTCompletionThreadCount();
#endif // WIN95
	}

	
	Unlock();

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::SetIOThreadCount - set I/O thread count
//
// Entry:		New thread count
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CModemThreadPool::SetIOThreadCount"

HRESULT	CModemThreadPool::SetIOThreadCount( const LONG iThreadCount )
{
	HRESULT	hr;


	DNASSERT( iThreadCount > 0 );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		DPFX(DPFPREP, 4, "Thread pool not locked down, setting intended thread count to %i.", iThreadCount );
		SetIntendedThreadCount( iThreadCount );
	}
	else
	{
#ifdef WIN95
		//
		// Win9x can not adjust thread count.
		//
		DPFX(DPFPREP, 4, "Thread pool locked down and already has %i 9x threads, not adjusting to %i.",
			ThreadCount(), iThreadCount );
#else // WINNT
		//
		// WinNT can have many threads.  If the user wants more threads, attempt
		// to boost the thread pool to the requested amount (if we fail to
		// start a new thread, too bad).  If the user wants fewer threads, check
		// to see if the thread pool has been locked out of changes.  If not,
		// start killing off the threads.
		//
		if ( iThreadCount > NTCompletionThreadCount() )
		{
			INT_PTR	iDeltaThreads;


			iDeltaThreads = iThreadCount - NTCompletionThreadCount();

			DPFX(DPFPREP, 4, "Thread pool locked down, spawning %i new NT threads (for a total of %i).",
				iDeltaThreads, iThreadCount );
			
			while ( iDeltaThreads > 0 )
			{
				iDeltaThreads--;
				StartNTCompletionThread();
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "Thread pool locked down and already has %i NT threads, not adjusting to %i.",
				NTCompletionThreadCount(), iThreadCount );
		}
#endif // WIN95
	}

	Unlock();

	return	hr;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CModemThreadPool::PreventThreadPoolReduction - prevents the thread pool size from being reduced
//
// Entry:		None
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CModemThreadPool::PreventThreadPoolReduction"

HRESULT CModemThreadPool::PreventThreadPoolReduction( void )
{
	HRESULT				hr = DPN_OK;
	LONG				iDesiredThreads;
#ifdef DBG
	DWORD				dwStartTime;
#endif // DBG


	Lock();

	//
	// If we haven't already clamped down, do so, and spin up the threads.
	//
	if ( IsThreadCountReductionAllowed() )
	{
		m_fAllowThreadCountReduction = FALSE;

		DNASSERT( GetIntendedThreadCount() > 0 );
		DNASSERT( ThreadCount() == 0 );

		iDesiredThreads = GetIntendedThreadCount();
		SetIntendedThreadCount( 0 );
		

		DPFX(DPFPREP, 3, "Locking down thread count at %i.", iDesiredThreads );

#ifdef DBG
		dwStartTime = GETTIMESTAMP();
#endif // DBG
		

		//
		// OS-specific thread starting.
		//
#ifdef WINNT
		//
		// WinNT
		//
		DNASSERT( NTCompletionThreadCount() == 0 );
		
		while ( iDesiredThreads > 0 )
		{
			iDesiredThreads--;
			StartNTCompletionThread();
		}

		//
		// If at least one thread was created, the SP will perform in a
		// non-optimal fashion, but we will still function.  If no threads
		// were created, fail.
		//
		if ( ThreadCount() == 0 )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Unable to create any threads to service NT I/O completion port!" );
			goto Failure;
		}
#else // WIN95
		//
		// Windows 9x
		//
		//
		// We should never get here because there will always only
		// be 1 thread.
		//
		DNASSERT( FALSE );
#endif // WINNT
		
#ifdef DBG
		DPFX(DPFPREP, 8, "Spent %u ms starting %i threads.", (GETTIMESTAMP() - dwStartTime), ThreadCount());
#endif // DBG
	}
	else
	{
		DPFX(DPFPREP, 3, "Thread count already locked down (at %i).", ThreadCount() );
	}

#ifdef WINNT
Exit:
#endif // WINNT
	
	Unlock();

	return	hr;

#ifdef WINNT
Failure:

	goto Exit;
#endif // WINNT
}
//**********************************************************************





//**********************************************************************
// ------------------------------
// CModemThreadPool::CreateDataPortHandle - create a new handle and assign a CDataPort
//		to it
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CModemThreadPool::CreateDataPortHandle( CDataPort *const pDataPort )
{
	HRESULT	hr;
	DPNHANDLE	hDataPort;


	DNASSERT( pDataPort != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	hDataPort = 0;

	hr = m_DataPortHandleTable.Create( pDataPort, &hDataPort );
	if ( hr != DPN_OK )
	{
		DNASSERT( hDataPort == 0 );
		DPFX(DPFPREP,  0, "Failed to create handle!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	pDataPort->SetHandle( hDataPort );
	pDataPort->AddRef();

Exit:
	return	hr;

Failure:
	DNASSERT( hDataPort == 0 );
	DNASSERT( pDataPort->GetHandle() == 0 );
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::CloseDataPortHandle - invalidate a handle for a CDataPort
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CModemThreadPool::CloseDataPortHandle( CDataPort *const pDataPort )
{
	DPNHANDLE	hDataPort;


	DNASSERT( pDataPort != NULL );

	hDataPort = pDataPort->GetHandle();

	if (SUCCEEDED(m_DataPortHandleTable.Destroy( hDataPort, NULL )))
	{
		pDataPort->SetHandle( 0 );
		pDataPort->DecRef();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::DataPortFromHandle - convert a handle to a CDataPort
//
// Entry:		Handle
//
// Exit:		Pointer to CDataPort (may be NULL for invalid handle)
// ------------------------------
CDataPort	*CModemThreadPool::DataPortFromHandle( const DPNHANDLE hDataPort )
{
	CDataPort	*pDataPort;


	DNASSERT( hDataPort != 0 );

	pDataPort = NULL;

	m_DataPortHandleTable.Lock();
	if (SUCCEEDED(m_DataPortHandleTable.Find( hDataPort, (PVOID*)&pDataPort )))
	{
		pDataPort->AddRef();
	}
	m_DataPortHandleTable.Unlock();

	return	pDataPort;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::SubmitDelayedCommand - submit request to enum query to remote session
//
// Entry:		Pointer to callback function
//				Pointer to cancel function
//				Pointer to callback context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::SubmitDelayedCommand"

HRESULT	CModemThreadPool::SubmitDelayedCommand( JOB_FUNCTION *const pFunction, JOB_FUNCTION *const pCancelFunction, void *const pContext )
{
	HRESULT			hr;
	THREAD_POOL_JOB	*pJob;
	BOOL			fJobDataLocked;


	DNASSERT( pFunction != NULL );
	DNASSERT( pCancelFunction != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pJob = NULL;
	fJobDataLocked = FALSE;

	pJob = static_cast<THREAD_POOL_JOB*>( g_ModemThreadPoolJobPool.Get( ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate job for DelayedCommand!" );
		goto Failure;
	}

	pJob->JobType = JOB_DELAYED_COMMAND;
	pJob->pCancelFunction = pCancelFunction;
	pJob->JobData.JobDelayedCommand.pCommandFunction = pFunction;
	pJob->JobData.JobDelayedCommand.pContext = pContext;

	LockJobData();
	fJobDataLocked = TRUE;

	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem submitting DelayedCommand job!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fJobDataLocked != FALSE )
	{
		UnlockJobData();
		fJobDataLocked = FALSE;
	}

	return	hr;

Failure:
	if ( pJob != NULL )
	{
		g_ModemThreadPoolJobPool.Release( pJob );
	}

	goto Exit;
}
//**********************************************************************

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CModemThreadPool::StartNTTimerThread - start the timer thread for NT
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	This function assumes that the enum data is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::StartNTTimerThread"

HRESULT	CModemThreadPool::StartNTTimerThread( void )
{
	HRESULT	hr;
	DNHANDLE	hThread;
	DWORD	dwThreadID;


	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );

	if ( m_fNTTimerThreadRunning != FALSE )
	{
		//
		// the enum thread is already running, poke it to note new enums
		//
		if ( DNSetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			hr = DPNERR_OUTOFMEMORY;
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem setting event to wake NTTimerThread!" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		goto Exit;
	}

//	DNASSERT( m_hWakeNTEnumThread != NULL );
//	m_NTEnumThreadData.hEventList[ EVENT_INDEX_ENUM_WAKEUP ] = m_hWakeNTEnumThread;

	IncrementActiveThreadCount();
	hThread = DNCreateThread( NULL,				// pointer to security attributes (none)
							0,					// stack size (default)
							WinNTTimerThread,	// thread function
							this,				// thread parameter
							0,					// creation flags (none, start running now)
							&dwThreadID			// pointer to thread ID
							);
	if ( hThread == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create NT timer thread!" );
		DisplayErrorCode( 0, dwError );
		DecrementActiveThreadCount();

		goto Failure;
	}

	//
	// note that the thread is running and close the handle to the thread
	//
	m_fNTTimerThreadRunning = TRUE;
	DPFX(DPFPREP,  8, "Creating NT-Timer thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, ThreadCount(), NTCompletionThreadCount() );

	if ( DNCloseHandle( hThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing handle after starting NTTimerThread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemThreadPool::WakeNTTimerThread - wake the timer thread because a timed event
//		has been added
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::WakeNTTimerThread"

void	CModemThreadPool::WakeNTTimerThread( void )
{
	LockJobData();
	DNASSERT( m_JobQueue.GetPendingJobHandle() != FALSE );
	if ( DNSetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem setting event to wake up NT timer thread!" );
		DisplayErrorCode( 0, dwError );
	}
	UnlockJobData();
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CModemThreadPool::RemoveTimerOperationEntry - remove timer operation job	from list
//
// Entry:		Pointer to timer operation
//				Result code to return
//
// Exit:		Nothing
//
// Note:	This function assumes that the list is appropriately locked
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::RemoveTimerOperationEntry"

void	CModemThreadPool::RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerEntry, const HRESULT hJobResult )
{
	DNASSERT( pTimerEntry != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_TimerDataLock, TRUE );

	//
	// remove this link from the list, tell owner that the job is complete and
	// return the job to the pool
	//
	pTimerEntry->Linkage.RemoveFromList();
	pTimerEntry->pTimerComplete( hJobResult, pTimerEntry->pContext );
	g_ModemTimerEntryPool.Release( pTimerEntry );
}
//**********************************************************************


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CModemThreadPool::CompleteOutstandingSends - check for completed sends and
//		indicate send completion for them.
//
// Entry:		Send complete event
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::CompleteOutstandingSends"

void	CModemThreadPool::CompleteOutstandingSends( const DNHANDLE hSendCompleteEvent )
{
	CBilink		*pCurrentOutstandingWrite;
	CBilink		WritesToBeProcessed;


	DNASSERT( hSendCompleteEvent != NULL );
	WritesToBeProcessed.Initialize();

	//
	// Loop through the list out outstanding sends.  Any completed sends are
	// removed from the list and processed after we release the write data lock.
	//
	LockWriteData();
	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
	{
		CDataPort		*pDataPort;
		CModemWriteIOData	*pWriteIOData;
		DWORD			dwFlags;
		DWORD			dwBytesSent;


		//
		// note this send and advance pointer to the next pending send
		//
		pWriteIOData = CModemWriteIOData::WriteDataFromBilink( pCurrentOutstandingWrite );
		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();

		if ( pWriteIOData->Win9xOperationPending() != FALSE )
		{
			if ( GetOverlappedResult( HANDLE_FROM_DNHANDLE(pWriteIOData->DataPort()->GetFileHandle()),		// file handle
									  pWriteIOData->Overlap(),							// pointer to overlap structure
									  &dwBytesSent,										// pointer to bytes sent
									  FALSE												// wait for completion (don't wait)
									  ) != FALSE )
			{
				pWriteIOData->jkm_hSendResult = DPN_OK;
			}
			else
			{
				DWORD	dwError;


				dwError = GetLastError();
				switch( dwError )
				{
					//
					// ERROR_IO_PENDING = operation pending
					//
					case ERROR_IO_PENDING:
					{
						goto SkipSendCompletion;
						break;
					}

					//
					// ERROR_IO_INCOMPLETE = overlapped I/O is not in a signalled state
					// 						 this is expected since the event is always
					//						 cleared before checking I/O.  Assume complete.
					//
					case ERROR_IO_INCOMPLETE:
					{
						pWriteIOData->jkm_hSendResult = DPN_OK;
						break;
					}

					//
					// ERROR_OPERATION_ABORTED = operation complete because of cancel or
					//							 a thread quit.  (Com port was closed)
					//
					case ERROR_OPERATION_ABORTED:
					{
						pWriteIOData->jkm_hSendResult = DPNERR_USERCANCEL;
						break;
					}		

					//
					// ERROR_INVALID_HANDLE = the serial port is gone.  This is
					//						  possible when a modem hangs up.
					//
					case ERROR_INVALID_HANDLE:
					{
						pWriteIOData->jkm_hSendResult = DPNERR_NOCONNECTION;
						break;
					}

					//
					// other error, stop and take a look
					//
					default:
					{
						pWriteIOData->jkm_hSendResult = DPNERR_GENERIC;
						DisplayErrorCode( 0, dwError );

						DNASSERT( FALSE );
						break;
					}
				}
			}

			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
			pWriteIOData->SetWin9xOperationPending( FALSE );

			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( &WritesToBeProcessed );
		}

SkipSendCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	//
	// If there are no more outstanding reads, reset the write complete event.
	// It will be signalled when the next posted write completes.  No other read
	// can be posted at this time because the write data lock is held.
	//
	if ( m_OutstandingWriteList.IsEmpty() != FALSE )
	{
		if ( DNResetEvent( hSendCompleteEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to reset send event!" );
			DisplayErrorCode( 0, dwError );
		}
	}
	UnlockWriteData();

	//
	// process all writes that have been pulled to the side.
	//
	while ( WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
	{
		CModemWriteIOData	*pTempWrite;
		CDataPort		*pDataPort;


		pTempWrite = CModemWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
		pDataPort = pTempWrite->DataPort();
		DNASSERT( pDataPort != NULL );

		pDataPort->SendComplete( pTempWrite, pTempWrite->jkm_hSendResult );
//		pDataPort->SendFromWriteQueue();
//		pDataPort->DecRef();
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CModemThreadPool::CompleteOutstandingReceives - check for completed receives and
//		indicate completion for them.
//
// Entry:		Receive complete event
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::CompleteOutstandingReceives"

void	CModemThreadPool::CompleteOutstandingReceives( const DNHANDLE hReceiveCompleteEvent )
{
	CBilink		*pCurrentOutstandingRead;
	CBilink		ReadsToBeProcessed;


	DNASSERT( hReceiveCompleteEvent != NULL );
	ReadsToBeProcessed.Initialize();
	LockReadData();

	//
	// Loop through the list of outstanding reads and pull out the ones that need
	// to be serviced.  We don't want to service them while the read data lock
	// is taken.
	//
	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
	{
		CDataPort		*pDataPort;
		CModemReadIOData		*pReadIOData;
		DWORD			dwFlags;


		pReadIOData = CModemReadIOData::ReadDataFromBilink( pCurrentOutstandingRead );
		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();

		//
		// Make sure this operation is really pending before attempting to check
		// for completion.  It's possible that the read was added to the list, but
		// we haven't actually called Winsock yet.
		//
		if ( pReadIOData->Win9xOperationPending() != FALSE )
		{
			if ( GetOverlappedResult( HANDLE_FROM_DNHANDLE(pReadIOData->DataPort()->GetFileHandle()),
									  pReadIOData->Overlap(),
									  &pReadIOData->jkm_dwOverlappedBytesReceived,
									  FALSE
									  ) != FALSE )
			{
				DBG_CASSERT( ERROR_SUCCESS == 0 );
//				pReadIOData->jkm_hReceiveReturn = DPN_OK;
				pReadIOData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
			}
			else
			{
				DWORD	dwError;


				dwError = GetLastError();
				switch( dwError )
				{
					//
					// ERROR_IO_INCOMPLETE = treat as I/O complete.  Event isn't
					//						 signalled, but that's expected because
					//						 it's cleared before checking for I/O
					//
					case ERROR_IO_INCOMPLETE:
					{
						pReadIOData->jkm_dwOverlappedBytesReceived = pReadIOData->m_dwBytesToRead;
						pReadIOData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
					    break;
					}

					//
					// ERROR_IO_PENDING = io still pending
					//
					case ERROR_IO_PENDING:
					{
						DNASSERT( FALSE );
						goto SkipReceiveCompletion;
						break;
					}

					//
					// other error, stop if not 'known'
					//
					default:
					{
						switch ( dwError )
						{
							//
							// ERROR_OPERATION_ABORTED = operation was cancelled (COM port closed)
							// ERROR_INVALID_HANDLE = operation was cancelled (COM port closed)
							//
							case ERROR_OPERATION_ABORTED:
							case ERROR_INVALID_HANDLE:
							{
								break;
							}

							default:
							{
								DisplayErrorCode( 0, dwError );
								DNASSERT( FALSE );
								break;
							}
						}

						pReadIOData->m_dwWin9xReceiveErrorReturn = dwError;

						break;
					}
				}
			}

			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
			pReadIOData->SetWin9xOperationPending( FALSE );

			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( &ReadsToBeProcessed );
		}

SkipReceiveCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	//
	// If there are no more outstanding reads, reset the read complete event.
	// It will be signalled when the next posted read completes.  No other read
	// can be posted at this time because the read data lock is held.
	//
	if ( m_OutstandingReadList.IsEmpty() != FALSE )
	{
		if ( DNResetEvent( hReceiveCompleteEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to reset receive event!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	UnlockReadData();

	//
	// loop through the list of reads that have completed and dispatch them
	//
	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
	{
		CModemReadIOData		*pTempRead;
		CDataPort		*pDataPort;


		pTempRead = CModemReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();

		pDataPort = pTempRead->DataPort();
		DNASSERT( pDataPort != NULL );
		pDataPort->ProcessReceivedData( pTempRead->jkm_dwOverlappedBytesReceived, pTempRead->m_dwWin9xReceiveErrorReturn );
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CModemThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
//		supposed to do under Win9x.
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::PrimaryWin9xThread"

DWORD	WINAPI	CModemThreadPool::PrimaryWin9xThread( void *pParam )
{
	WIN9X_CORE_DATA		CoreData;
	DWORD	    		dwCurrentTime;
	DWORD	    		dwMaxWaitTime;
	BOOL				fComInitialized;


	CModemThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;


	DNASSERT( pParam != NULL );
	DNASSERT( pThisThreadPool != NULL );

	//
	// initialize
	//
	memset( &CoreData, 0x00, sizeof CoreData );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP,  0, "Primary Win9x thread failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}

	DNASSERT( CoreData.fTimerJobsActive == FALSE );

	//
	// set enums to happen infinitely in the future
	//
	CoreData.dwNextTimerJobTime = GETTIMESTAMP() - 1;

	//
	// set wait handles
	//
	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
	CoreData.hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ] = pThisThreadPool->GetSendCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ] = pThisThreadPool->GetReceiveCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_TAPI_MESSAGE ] = pThisThreadPool->GetTAPIMessageEvent();

	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_TAPI_MESSAGE ] );

	//
	// go until we're told to stop
	//
	CoreData.fLooping = TRUE;
	while ( CoreData.fLooping != FALSE )
	{
		DWORD   dwWaitReturn;


		//
		// Update the job time so we know how long to wait.  We can
		// only get here if a socket was just added to the socket list, or
		// we've been servicing sockets.
		//
		dwCurrentTime = GETTIMESTAMP();
		if ( (int) ( dwCurrentTime - CoreData.dwNextTimerJobTime ) >= 0 )
		{
			pThisThreadPool->LockTimerData();
			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
			    														   &CoreData.dwNextTimerJobTime );
			if ( CoreData.fTimerJobsActive != FALSE )
			{
			    DPFX(DPFPREP,  8, "There are active jobs left with Winsock1 sockets active!" );
			}
			pThisThreadPool->UnlockTimerData();
		}

		dwMaxWaitTime = CoreData.dwNextTimerJobTime - dwCurrentTime;

		//
		// Check for I/O
		//
		dwWaitReturn = DNWaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
			    								 CoreData.hWaitHandles,					// handles to wait on
			    								 FALSE,									// don't wait for all to be signalled
			    								 dwMaxWaitTime,							// wait timeout
			    								 TRUE									// we're alertable for APCs
			    								 );
		switch ( dwWaitReturn )
		{
			//
			// timeout, don't do anything, we'll probably process timer jobs on
			// the next loop
			//
			case WAIT_TIMEOUT:
			{
			    break;
			}

			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_SEND_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_RECEIVE_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_TAPI_MESSAGE ):
			{
				pThisThreadPool->ProcessWin9xEvents( &CoreData );
				break;
			}


			//
			// There are I/O completion routines scheduled on this thread.
			// This is not a good thing!
			//
			case WAIT_IO_COMPLETION:
			{
			    DPFX(DPFPREP,  1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
			    break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
			    DWORD	dwError;


			    dwError = GetLastError();
			    DPFX(DPFPREP,  0, "Primary Win9x thread wait failed!" );
			    DisplayDNError( 0, dwError );
			    break;
			}

			//
			// problem
			//
			default:
			{
			    DWORD	dwError;


			    dwError = GetLastError();
			    DPFX(DPFPREP,  0, "Primary Win9x thread unknown problem in wait!" );
			    DisplayDNError( 0, dwError );
			    DNASSERT( FALSE );
			    break;
			}
		}
	}

	pThisThreadPool->DecrementActiveThreadCount();

	DNFree( pParam );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // WIN95


#ifdef WINNT
//**********************************************************************
// ------------------------------
// CModemThreadPool::WinNTIOCompletionThread - thread to service I/O completion port
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::WinNTIOCompletionThread"

DWORD	WINAPI	CModemThreadPool::WinNTIOCompletionThread( void *pParam )
{
	IOCOMPLETION_THREAD_DATA	*pInput;
	BOOL	fLooping;
	HANDLE	hIOCompletionPort;
	BOOL	fComInitialized;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	pInput = static_cast<IOCOMPLETION_THREAD_DATA*>( pParam );
	DNASSERT( pInput->pThisThreadPool != NULL );
	fLooping = TRUE;
	hIOCompletionPort = pInput->pThisThreadPool->m_hIOCompletionPort;
	DNASSERT( hIOCompletionPort != NULL );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP,  0, "Failed to initialize COM!" );
			break;
		}
	}

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		BOOL		fStatusReturn;
		DWORD		dwBytesTransferred;
		ULONG_PTR	uCompletionKey;
		OVERLAPPED	*pOverlapped;


		DNASSERT( hIOCompletionPort != NULL );
		fStatusReturn = GetQueuedCompletionStatus( hIOCompletionPort,		// handle of completion port
												   &dwBytesTransferred,		// pointer to number of bytes read
												   &uCompletionKey,			// pointer to completion key
												   &pOverlapped,			// pointer to overlapped structure
												   INFINITE					// wait forever
												   );
		if ( ( fStatusReturn == FALSE ) && ( pOverlapped == FALSE ) )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem getting item from completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		else
		{
			switch ( uCompletionKey )
			{
				//
				// ReadFile or WriteFile completed.  Check error status and
				// complete the appropriate operation.
				//
				case IO_COMPLETION_KEY_IO_COMPLETE:
				{
					CIOData		*pIOData;
					DWORD		dwError;


					DNASSERT( pOverlapped != NULL );
					if ( fStatusReturn != FALSE )
					{
						dwError = ERROR_SUCCESS;
					}
					else
					{
						dwError = GetLastError();
					}

					pIOData = CIOData::IODataFromOverlap( pOverlapped );
					if ( pIOData->NTIOOperationType() == NT_IO_OPERATION_RECEIVE )
					{
						DNASSERT( ( dwError == ERROR_SUCCESS ) || ( dwBytesTransferred == 0 ) );
						pIOData->DataPort()->ProcessReceivedData( dwBytesTransferred, dwError );
					}
					else
					{
						HRESULT		hOperationResult;


						DNASSERT( pIOData->NTIOOperationType() == NT_IO_OPERATION_SEND );
						switch ( dwError )
						{
							//
							// no problem
							//
							case ERROR_SUCCESS:
							{
								hOperationResult = DPN_OK;
								break;
							}

							//
							// ERROR_OPERATION_ABORTED = operation was stopped, most likely
							//		because of a user cancel
							//
							case ERROR_OPERATION_ABORTED:
							{
								hOperationResult = DPNERR_USERCANCEL;
								break;
							}

							default:
							{
								DNASSERT( FALSE );
								DPFX(DPFPREP,  0, "Failed on I/O completion send!" );
								DisplayErrorCode( 0, dwError );
								hOperationResult = DPNERR_GENERIC;
								break;
							}
						}

						pIOData->DataPort()->SendComplete( static_cast<CModemWriteIOData*>( pIOData ), hOperationResult );
					}

					break;
				}

				//
				// SP is closing, stop all threads
				//
				case IO_COMPLETION_KEY_SP_CLOSE:
				{
					DNASSERT( DNWaitForSingleObjectEx( pInput->pThisThreadPool->m_hStopAllThreads, 0, TRUE ) == WAIT_OBJECT_0 );
					fLooping = FALSE;
					break;
				}

				//
				// a new job was submitted to the job queue, or the SP is closing from above
				//
				case IO_COMPLETION_KEY_NEW_JOB:
				{
					THREAD_POOL_JOB	*pJobInfo;


					//
					// SP is still running, process our job
					//
					pJobInfo = pInput->pThisThreadPool->GetWorkItem();
					if ( pJobInfo != NULL )
					{
						switch ( pJobInfo->JobType )
						{
							//
							// enum refresh
							//
							case JOB_REFRESH_TIMER_JOBS:
							{
								DPFX(DPFPREP,  8, "IOCompletion job REFRESH_TIMER_JOBS" );
								DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );

								pInput->pThisThreadPool->WakeNTTimerThread();

								break;
							}

							//
							// issue callback for this job
							//
							case JOB_DELAYED_COMMAND:
							{
								DPFX(DPFPREP,  8, "IOCompletion job DELAYED_COMMAND" );
								DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );

								pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
								break;
							}

							//
							// other job
							//
							default:
							{
								DPFX(DPFPREP,  0, "IOCompletion job unknown!" );
								DNASSERT( FALSE );
								break;
							}
						}

						pJobInfo->JobType = JOB_UNINITIALIZED;
						g_ModemThreadPoolJobPool.Release( pJobInfo );
					}

					break;
				}

				//
				// TAPI message, pointer to line message is in pOverlapped and
				// we are responsible for freeing it via LocalFree()
				//
				case IO_COMPLETION_KEY_TAPI_MESSAGE:
				{
					LINEMESSAGE	*pLineMessage;
					CDataPort	*pModemPort;
					DPNHANDLE	hModemPort;


					DNASSERT( pOverlapped != NULL );
					DBG_CASSERT( sizeof( pLineMessage ) == sizeof( pOverlapped ) );
					pLineMessage = reinterpret_cast<LINEMESSAGE*>( pOverlapped );

					DBG_CASSERT( sizeof( pModemPort ) == sizeof( pLineMessage->dwCallbackInstance ) );
					hModemPort = (DPNHANDLE)( pLineMessage->dwCallbackInstance );

					pModemPort = static_cast<CDataPort*>( pInput->pThisThreadPool->DataPortFromHandle( hModemPort ) );
					if ( pModemPort != NULL )
					{
						pModemPort->ProcessTAPIMessage( pLineMessage );

						if ( LocalFree( pOverlapped ) != NULL )
						{
							DWORD	dwError;


							dwError = GetLastError();
							DPFX(DPFPREP,  0, "Problem with LocalFree in NTProcessTAPIMessage" );
							DisplayErrorCode( 0, dwError );
						}

						pModemPort->DecRef();
					}
					else
					{
						DPFX(DPFPREP,  5, "Dropping TAPI message on closed modem port!" );
						DisplayTAPIMessage( 5, pLineMessage );
					}

					break;
				}

				//
				// unknown I/O completion message type
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
		}
	}

	pInput->pThisThreadPool->DecrementActiveNTCompletionThreadCount();
	DNFree( pInput );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // WINNT

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CModemThreadPool::WinNTTimerThread - timer thread for NT
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is a static memory chunk and cannot be freed.
//			Cleanup of this memory is the responsibility of this thread.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::WinNTTimerThread"

DWORD	WINAPI	CModemThreadPool::WinNTTimerThread( void *pParam )
{
	CModemThreadPool	*pThisThreadPool;
	BOOL			fLooping;
	DWORD			dwWaitReturn;
	DWORD			dwNextEnumTime;
	DNHANDLE		hEvents[ 2 ];
	BOOL			fComInitialized;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	DNASSERT( pParam != NULL );
	pThisThreadPool = static_cast<CModemThreadPool*>( pParam );
	DNASSERT( pThisThreadPool->m_JobQueue.GetPendingJobHandle() != NULL );

	dwNextEnumTime = GETTIMESTAMP() - 1;

	hEvents[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	hEvents[ EVENT_INDEX_WAKE_NT_TIMER_THREAD ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();

	fComInitialized = FALSE;


	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP, 0, "Failed to initialize COM!" );
			break;
		}
	}



	//
	// there were no active enums so we want to wait forever for something to
	// happen
	//
	fLooping = TRUE;

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		DWORD		dwCurrentTime;
		DWORD		dwMaxWaitTime;


		dwCurrentTime = GETTIMESTAMP();

		if ( (int) ( dwNextEnumTime - dwCurrentTime ) <= 0 )
		{

			//
			// acknowledge that we've handled this event and then process the
			// enums
			//
			pThisThreadPool->LockTimerData();

			if ( DNResetEvent( hEvents[ EVENT_INDEX_WAKE_NT_TIMER_THREAD ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem resetting event to wake NT timer thread!" );
				DisplayErrorCode( 0, dwError );
			}

			pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList, &dwNextEnumTime );
			pThisThreadPool->UnlockTimerData();
		}

		dwMaxWaitTime = dwNextEnumTime - dwCurrentTime;

		DPFX(DPFPREP, 9, "Waiting %u ms until next timed job.", dwMaxWaitTime);

		dwWaitReturn = DNWaitForMultipleObjectsEx( LENGTHOF( hEvents ),	// number of events
												 hEvents,				// event list
												 FALSE,					// wait for any one event to be signalled
												 dwMaxWaitTime,			// timeout
												 TRUE					// be nice and allow APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// SP closing
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			{
				DPFX(DPFPREP,  8, "NT timer thread thread detected SPClose!" );
				fLooping = FALSE;
				break;
			}

			//
			// Enum wakeup event, someone added an enum to the list.  Clear
			// our enum time and go back to the top of the loop where we
			// will process enums.
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WAKE_NT_TIMER_THREAD ):
			{
				dwNextEnumTime = GETTIMESTAMP();
				break;
			}

			//
			// Wait timeout.  We're probably going to process enums, go back
			// to the top of the loop.
			//
			case WAIT_TIMEOUT:
			{
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DPFX(DPFPREP,  0, "NT timer thread WaitForMultipleObjects failed: 0x%x", dwWaitReturn );
				DNASSERT( FALSE );
				break;
			}

			//
			// problem
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	DPFX(DPFPREP,  8, "NT timer thread is exiting!" );
	pThisThreadPool->LockTimerData();

	pThisThreadPool->m_fNTTimerThreadRunning = FALSE;
	pThisThreadPool->DecrementActiveThreadCount();

	pThisThreadPool->UnlockTimerData();


	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CModemThreadPool::DialogThreadProc - thread proc for spawning dialogs
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::DialogThreadProc"

DWORD WINAPI	CModemThreadPool::DialogThreadProc( void *pParam )
{
	const DIALOG_THREAD_PARAM	*pThreadParam;
	BOOL	fComInitialized;


	//
	// Initialize COM.  If this fails, we'll have problems later.
	//
	fComInitialized = FALSE;
	switch ( COM_CoInitialize( NULL ) )
	{
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP,  0, "Failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}

	DNASSERT( pParam != NULL );
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );

	pThreadParam->pDialogFunction( pThreadParam->pContext );

	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
	DNFree( pParam );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************

#ifdef WIN95
//**********************************************************************
// ------------------------------
// CModemThreadPool::ProcessWin9xEvents - process a Win9x events
//
// Entry:		Pointer core data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ProcessWin9xEvents"

void	CModemThreadPool::ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData )
{
	BOOL	fAllIOComplete;
	DNASSERT( pCoreData != NULL );


	//
	// this funciton checks each of the handles to see if they're signalled
	// to prevent I/O from starving the rest of the handles
	//
	fAllIOComplete = TRUE;

	//
	// New job.  Account for the time spent in the wait.  Don't
	// account for time after the job is complete because it's
	// possible that the job was an job submission which will want
	// to reset the wait time.
	//
	switch ( DNWaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_PENDING_JOB ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP,  8, "Primary Win9x thread has a pending job!" );
			ProcessWin9xJob( pCoreData );
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


	//
	// TAPI message
	//
	switch ( DNWaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_TAPI_MESSAGE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP,  8, "Processing TAPI event!" );
			ProcessTapiEvent();
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


	//
	// send complete
	//
	switch ( DNWaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
//		    DPFX(DPFPREP,  0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
			CompleteOutstandingSends( pCoreData->hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ] );
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// receive complete
	//
	switch ( DNWaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
//		    DPFX(DPFPREP,  0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
			CompleteOutstandingReceives( pCoreData->hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ] );
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// SP closing
	//
	switch ( DNWaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP,  8, "Primary Win9x thread exit because SP closing!" );
			pCoreData->fLooping = FALSE;
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}



	//
	// If there is I/O pending the Read/Write handles are probably still signalled.
	// Wait 5 milliseconds to process it before running through the handles again.
	//
	LockReadData();
	LockWriteData();

	if ( ( m_OutstandingReadList.IsEmpty() == FALSE ) ||
		 ( m_OutstandingWriteList.IsEmpty() == FALSE ) )
	{
		fAllIOComplete = FALSE;
	}

	UnlockReadData();
	UnlockWriteData();

	if ( fAllIOComplete == FALSE )
	{
		SleepEx( 5, TRUE );
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CModemThreadPool::ProcessWin9xJob - process a Win9x job
//
// Entry:		Pointer core data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemThreadPool::ProcessWin9xJob"

void	CModemThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
{
	THREAD_POOL_JOB	*pJobInfo;


	//
	// remove and process a single job from the list
	//
	pJobInfo = GetWorkItem();
	if ( pJobInfo != NULL )
	{
		switch ( pJobInfo->JobType )
		{
			//
			// enum refresh
			//
			case JOB_REFRESH_TIMER_JOBS:
			{
				DPFX(DPFPREP,  8, "WorkThread job REFRESH_ENUM" );
				DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
				LockTimerData();
				pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->dwNextTimerJobTime );
				UnlockTimerData();

				if ( pCoreData->fTimerJobsActive != FALSE )
				{
					DPFX(DPFPREP,  8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
				}

				break;
			}

			//
			// issue callback for this job
			//
			case JOB_DELAYED_COMMAND:
			{
				DPFX(DPFPREP,  8, "WorkThread job DELAYED_COMMAND" );
				DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
				pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
				break;
			}

			//
			// other job
			//
			default:
			{
				DPFX(DPFPREP,  0, "WorkThread Win9x job unknown!" );
				DNASSERT( FALSE );
				break;
			}
		}

		pJobInfo->JobType = JOB_UNINITIALIZED;
		g_ModemThreadPoolJobPool.Release( pJobInfo );
	}
}
//**********************************************************************
#endif // WIN95


//**********************************************************************
// ------------------------------
// CModemThreadPool::ProcessTapiEvent - process TAPI event
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CModemThreadPool::ProcessTapiEvent( void )
{
	LONG		lTapiReturn;
	LINEMESSAGE	LineMessage;


	lTapiReturn = p_lineGetMessage( GetTAPIInfo()->hApplicationInstance, &LineMessage, 0 );
	if ( lTapiReturn != LINEERR_NONE )
	{
		DPFX(DPFPREP,  0, "Failed to process Win9x TAPI message!" );
		DisplayTAPIError( 0, lTapiReturn );
	}
	else
	{
		CDataPort	*pModemPort;
		DPNHANDLE	hModemPort;


		DNASSERT( sizeof( hModemPort ) == sizeof( LineMessage.dwCallbackInstance ) );
		hModemPort = (DPNHANDLE)( LineMessage.dwCallbackInstance );

		pModemPort = static_cast<CDataPort*>( DataPortFromHandle( hModemPort ) );
		if ( pModemPort != NULL )
		{
			pModemPort->ProcessTAPIMessage( &LineMessage );
			pModemPort->DecRef();
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ThreadPoolJob_Alloc - allocate a new job
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ThreadPoolJob_Alloc"

BOOL ThreadPoolJob_Alloc( void *pvItem, void* pvContext )
{
	BOOL			fReturn;
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	fReturn = TRUE;
	pJob = static_cast<THREAD_POOL_JOB*>( pvItem );

	memset( pJob, 0x00, sizeof( *pJob ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ThreadPoolJob_Get - a job is being removed from the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ThreadPoolJob_Get"

void ThreadPoolJob_Get( void *pvItem, void* pvContext )
{
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	pJob = static_cast<THREAD_POOL_JOB*>( pvItem );
	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );
	DNASSERT( pJob->pNext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ThreadPoolJob_Release - a job is being returned to the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ThreadPoolJob_Release"

void ThreadPoolJob_Release( void *pvItem )
{
	THREAD_POOL_JOB	*pJob;


	DNASSERT( pvItem != NULL );
	pJob = static_cast<THREAD_POOL_JOB*>( pvItem );

	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemTimerEntry_Alloc - allocate a new timer job entry
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemTimerEntry_Alloc"

BOOL ModemTimerEntry_Alloc( void *pvItem, void* pvContext )
{
	BOOL					fReturn;
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pvItem != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pvItem );
	memset( pTimerEntry, 0x00, sizeof( *pTimerEntry ) );
	pTimerEntry->pContext = NULL;
	pTimerEntry->Linkage.Initialize();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemTimerEntry_Get - get new timer job entry from pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemTimerEntry_Get"

void ModemTimerEntry_Get( void *pvItem, void* pvContext )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pvItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pvItem );

	pTimerEntry->Linkage.Initialize();
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemTimerEntry_Release - return timer job entry to pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemTimerEntry_Release"

void ModemTimerEntry_Release( void *pvItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pvItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pvItem );
	pTimerEntry->pContext= NULL;

	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemTimerEntry_Dealloc - deallocate a timer job entry
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemTimerEntry_Dealloc"

void	ModemTimerEntry_Dealloc( void *pvItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pvItem != NULL );

	//
	// initialize
	//
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pvItem );

	//
	// return associated poiner to write data
	//
	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemunk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Unk.cpp
 *  Content:	IUnknown implementation
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Copied from winsock provider
 *	11/30/98	jtk		Initial checkin into SLM
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dnmdmi.h"


#define DPN_REG_LOCAL_MODEM_SERIAL_ROOT		L"\\DPNSPModemSerial"
#define DPN_REG_LOCAL_MODEM_MODEM_ROOT		L"\\DPNSPModemModem"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

HRESULT ModemLoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString );

#undef DPF_MODNAME
#define DPF_MODNAME "DNModemInit"
BOOL DNModemInit(HANDLE hModule)
{
	DNASSERT( g_hModemDLLInstance == NULL );
	g_hModemDLLInstance = (HINSTANCE) hModule;

	//
	// attempt to initialize process-global items
	//
	if ( ModemInitProcessGlobals() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to initialize globals!" );

		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNModemDeInit"
void DNModemDeInit()
{
	DPFX(DPFPREP, 5, "Deinitializing Serial SP");

	DNASSERT( g_hModemDLLInstance != NULL );
	g_hModemDLLInstance = NULL;

	ModemDeinitProcessGlobals();
}


#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DNModemRegister"
BOOL DNModemRegister(LPCWSTR wszDLLName)
{
	HRESULT hr = S_OK;
	BOOL fReturn = TRUE;

	if( !CRegistry::Register( L"DirectPlay8SPModem.Modem.1", L"DirectPlay8 Modem Provider Object",
							  wszDLLName, &CLSID_DP8SP_MODEM, L"DirectPlay8SPModem.Modem") )
	{
		DPFERR( "Could not register dp8 Modem object" );
		fReturn = FALSE;
	}

	if( !CRegistry::Register( L"DirectPlay8SPModem.Serial.1", L"DirectPlay8 Serial Provider Object",
							  wszDLLName, &CLSID_DP8SP_SERIAL, L"DirectPlay8SPModem.Serial") )
	{
		DPFERR( "Could not register dp8 Serial object" );
		fReturn = FALSE;
	}


	CRegistry creg;
	WCHAR *wszFriendlyName = NULL;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_MODEM_MODEM_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create Modem sub-area" );
		fReturn = FALSE;
	}
	else
	{

		hr = ModemLoadAndAllocString( IDS_FRIENDLYNAME_MODEM, &wszFriendlyName );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Could not load Modem name hr=0x%x", hr );
			fReturn = FALSE;
		}
		else
		{
			// Load from resource file
			creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
	
			delete [] wszFriendlyName;
	
			creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_MODEM );
		}
	
		creg.Close();
	}
	
	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_MODEM_SERIAL_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create Serial sub-aread" );
		fReturn = FALSE;
	}
	else
	{
	
		hr = ModemLoadAndAllocString( IDS_FRIENDLYNAME_SERIAL, &wszFriendlyName );
	
		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Could not load Serial name hr=0x%x", hr );
			fReturn = FALSE;
		}
		else
		{
			// Load from resource file
			creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
	
			delete [] wszFriendlyName;
	
			creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_SERIAL );
		}
	
		creg.Close();
	}
	
	return fReturn;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNModemUnRegister"
BOOL DNModemUnRegister()
{
	HRESULT hr = S_OK;
	BOOL fReturn = TRUE;

	if( !CRegistry::UnRegister(&CLSID_DP8SP_MODEM) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister Modem object" );
		fReturn = FALSE;
	}

	if( !CRegistry::UnRegister(&CLSID_DP8SP_SERIAL) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister Serial object" );
		fReturn = FALSE;
	}

	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove app, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_MODEM_MODEM_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove Modem sub-key, could have elements" );
		}

		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_MODEM_SERIAL_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove Serial sub-key, could have elements" );
		}

	}

	return fReturn;
}

#endif // ! DPNBUILD_NOCOMREGISTER


#ifndef DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "DNModemGetRemainingObjectCount"
DWORD DNModemGetRemainingObjectCount()
{
	return g_lModemOutstandingInterfaceCount;
}

#endif // ! DPNBUILD_LIBINTERFACE



//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	STDMETHODIMP DNMODEMSP_QueryInterface( IDP8ServiceProvider* lpDNSP, REFIID riid, LPVOID * ppvObj );

#define NOTSUPPORTED(parm)	(HRESULT (__stdcall *) (struct IDP8ServiceProvider *, parm)) DNMODEMSP_NotSupported


//**********************************************************************
// Function pointers
//**********************************************************************
// these are the vtables for serial and modem.  One or the other is used depending on
//	what is passed to DoCreateInstance
static	IDP8ServiceProviderVtbl	g_SerialInterface =
{
	DNMODEMSP_QueryInterface,
	DNMODEMSP_AddRef,
	DNMODEMSP_Release,
	DNMODEMSP_Initialize,
	DNMODEMSP_Close,
	DNMODEMSP_Connect,
	DNMODEMSP_Disconnect,
	DNMODEMSP_Listen,
	DNMODEMSP_SendData,
	DNMODEMSP_EnumQuery,
	DNMODEMSP_EnumRespond,
	DNMODEMSP_CancelCommand,
	NOTSUPPORTED(PSPENUMMULTICASTSCOPESDATA),		// EnumMulticastScopes
	NOTSUPPORTED(PSPSHAREENDPOINTINFODATA),			// ShareEndpointInfo
	NOTSUPPORTED(PSPGETENDPOINTBYADDRESSDATA),		// GetEndpointByAddress
	NOTSUPPORTED(PSPUPDATEDATA),					// Update
	DNMODEMSP_GetCaps,
	DNMODEMSP_SetCaps,
	DNMODEMSP_ReturnReceiveBuffers,
	DNMODEMSP_GetAddressInfo,
	DNMODEMSP_IsApplicationSupported,
	DNMODEMSP_EnumAdapters,
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA)		// ProxyEnumQuery
};

static	IDP8ServiceProviderVtbl	g_ModemInterface =
{
	DNMODEMSP_QueryInterface,
	DNMODEMSP_AddRef,
	DNMODEMSP_Release,
	DNMODEMSP_Initialize,
	DNMODEMSP_Close,
	DNMODEMSP_Connect,
	DNMODEMSP_Disconnect,
	DNMODEMSP_Listen,
	DNMODEMSP_SendData,
	DNMODEMSP_EnumQuery,
	DNMODEMSP_EnumRespond,
	DNMODEMSP_CancelCommand,
	NOTSUPPORTED(PSPENUMMULTICASTSCOPESDATA),		// EnumMulticastScopes
	NOTSUPPORTED(PSPSHAREENDPOINTINFODATA),			// ShareEndpointInfo
	NOTSUPPORTED(PSPGETENDPOINTBYADDRESSDATA),		// GetEndpointByAddress
	NOTSUPPORTED(PSPUPDATEDATA),					// Update
	DNMODEMSP_GetCaps,
	DNMODEMSP_SetCaps,
	DNMODEMSP_ReturnReceiveBuffers,
	DNMODEMSP_GetAddressInfo,
	DNMODEMSP_IsApplicationSupported,
	DNMODEMSP_EnumAdapters,
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA)		// ProxyEnumQuery
};


//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_QueryInterface - query for a particular interface
//
// Entry:		Pointer to current interface
//				Desired interface ID
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_QueryInterface"

static	STDMETHODIMP DNMODEMSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj )
{
    HRESULT hr = S_OK;


	// assume no interface
	*ppvObj=NULL;

	 // hmmm, switch would be cleaner...
    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDP8ServiceProvider) )
    {
		*ppvObj = lpDNSP;
		DNMODEMSP_AddRef( lpDNSP );
    }
	else
	{
		hr =  E_NOINTERFACE;		
	}

    return hr;
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CreateModemInterface - create a modem interface
//
// Entry:		Pointer to pointer to SP interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateModemInterface"

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateModemInterface( const XDP8CREATE_PARAMS * const pDP8CreateParams, IDP8ServiceProvider **const ppiDP8SP )
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateModemInterface( IDP8ServiceProvider **const ppiDP8SP )
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	HRESULT 		hr;
	CModemSPData	*pSPData;

	
	DNASSERT( ppiDP8SP != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDP8SP = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData,
						TYPE_MODEM,
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
						pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
						&g_ModemInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData == NULL );
		DPFX(DPFPREP, 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDP8SP = pSPData->COMInterface();

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSerialInterface - create a serial interface
//
// Entry:		Pointer to pointer to SP interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateSerialInterface"

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateSerialInterface( const XDP8CREATE_PARAMS * const pDP8CreateParams, IDP8ServiceProvider **const ppiDP8SP )
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateSerialInterface( IDP8ServiceProvider **const ppiDP8SP )
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	HRESULT 		hr;
	CModemSPData	*pSPData;

	
	DNASSERT( ppiDP8SP != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDP8SP = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData,
						TYPE_SERIAL,
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
						pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
						&g_SerialInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData == NULL );
		DPFX(DPFPREP, 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDP8SP = pSPData->COMInterface();

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************



#ifndef DPNBUILD_LIBINTERFACE

//**********************************************************************
// ------------------------------
// ModemDoCreateInstance - create an instance of an interface
//
// Entry:		Pointer to class factory
//				Pointer to unknown interface
//				Refernce of GUID of desired interface
//				Reference to another GUID?
//				Pointer to pointer to interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
HRESULT ModemDoCreateInstance( LPCLASSFACTORY This,
						  LPUNKNOWN pUnkOuter,
						  REFCLSID rclsid,
						  REFIID riid,
						  LPVOID *ppvObj )
{
	HRESULT		hr;


	DNASSERT( ppvObj != NULL );

	//
	// initialize
	//
	*ppvObj = NULL;

	//
	// we can either create an IPX instance or an IP instance
	//
	if (IsEqualCLSID(rclsid, CLSID_DP8SP_MODEM))
	{
		hr = CreateModemInterface( reinterpret_cast<IDP8ServiceProvider**>( ppvObj ) );
	}
	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_SERIAL))
	{
		hr = CreateSerialInterface( reinterpret_cast<IDP8ServiceProvider**>( ppvObj ) );
	}
	else
	{
		// this shouldn't happen if they called IClassFactory::CreateObject correctly
		DPFX(DPFPREP, 0, "Got unexpected CLSID!");
		hr = E_UNEXPECTED;
	}

	return hr;
}
//**********************************************************************

#endif // ! DPNBUILD_LIBINTERFACE


//**********************************************************************
// ------------------------------
// IsClassImplemented - tells asked if this DLL implements a given class.
//		DLLs may implement multiple classes and multiple interfaces on those classes
//
// Entry:		Class reference
//
// Exit:		Boolean indicating whether the class is implemented
//				TRUE = class implemented
//				FALSE = class not implemented
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"

BOOL IsClassImplemented( REFCLSID rclsid )
{
	return IsSerialGUID( &rclsid );
}
//**********************************************************************

#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH

#undef DPF_MODNAME
#define DPF_MODNAME "ModemLoadAndAllocString"

HRESULT ModemLoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
{
	int length;
	HRESULT hr;

	TCHAR szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		
	length = LoadString( g_hModemDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

	if( length == 0 )
	{
		hr = GetLastError();		
		
		DPFX(DPFPREP, 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
		*lpswzString = NULL;

		return DPNERR_GENERIC;
	}
	else
	{
		*lpswzString = new wchar_t[length+1];

		if( *lpswzString == NULL )
		{
			DPFX(DPFPREP, 0, "Alloc failure" );
			return DPNERR_OUTOFMEMORY;
		}

#ifdef UNICODE
		wcscpy( *lpswzString, szTmpBuffer );
#else // !UNICODE
		if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) != DPN_OK )
		{
			hr = GetLastError();
			
			delete[] *lpswzString;
			*lpswzString = NULL;

			DPFX(DPFPREP, 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
			return DPNERR_GENERIC;
		}
#endif // !UNICODE

		return DPN_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemthreadpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ThreadPool.h
 *  Content:	Functions to manage a thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/01/99	jtk		Derived from Utils.h
 ***************************************************************************/

#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// max handles that can be waited on for Win9x
//
#define	MAX_WIN9X_HANDLE_COUNT	64

//
// job definitions
//
typedef enum	_JOB_TYPE
{
	JOB_UNINITIALIZED,			// uninitialized value
	JOB_DELAYED_COMMAND,		// callback provided
	JOB_REFRESH_TIMER_JOBS,		// revisit timer jobs
} JOB_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );
typedef	void	TIMER_EVENT_CALLBACK( void *const pContext );
typedef	void	TIMER_EVENT_COMPLETE( const HRESULT hCompletionCode, void *const pContext );
typedef	void	DIALOG_FUNCTION( void *const pDialogContext );

//
// functions for managing the job pool
//
BOOL	ThreadPoolJob_Alloc( void *pvItem, void* pvContext );
void	ThreadPoolJob_Get( void *pvItem, void* pvContext );
void	ThreadPoolJob_Release( void *pvItem );

//
// functions for managing the timer data pool
//
BOOL	ModemTimerEntry_Alloc( void *pvItem, void* pvContext );
void	ModemTimerEntry_Get( void *pvItem, void* pvContext );
void	ModemTimerEntry_Release( void *pvItem );
void	ModemTimerEntry_Dealloc( void *pvItem );


//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CDataPort;
class	CModemThreadPool;
typedef struct	_THREAD_POOL_JOB		THREAD_POOL_JOB;
typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;

typedef struct	_TIMER_OPERATION_ENTRY
{
	CBilink		Linkage;			// list links
	void		*pContext;			// user context passed back in timer events

	//
	// timer information
	//
	UINT_PTR	uRetryCount;		// number of times to retry this event
	BOOL		fRetryForever;		// Boolean for retrying forever
	DWORD		dwRetryInterval;	// time between enums (milliseconds)
	DWORD		dwIdleTimeout;		// time at which the command sits idle after all retrys are complete
	BOOL		fIdleWaitForever;	// Boolean for waiting forever in idle state
	DWORD		dwNextRetryTime;	// time at which this event will fire next (milliseconds)

	TIMER_EVENT_CALLBACK	*pTimerCallback;	// callback for when this event fires
	TIMER_EVENT_COMPLETE	*pTimerComplete;	// callback for when this event is complete

	#undef DPF_MODNAME
	#define DPF_MODNAME "_TIMER_OPERATION_ENTRY::TimerOperationFromLinkage"
	static _TIMER_OPERATION_ENTRY	*TimerOperationFromLinkage( CBilink *const pLinkage )
	{
		DNASSERT( pLinkage != NULL );
		DBG_CASSERT( OFFSETOF( _TIMER_OPERATION_ENTRY, Linkage ) == 0 );
		return	reinterpret_cast<_TIMER_OPERATION_ENTRY*>( pLinkage );
	}

} TIMER_OPERATION_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

//
// class for thread pool
//
class	CModemThreadPool
{
	public:
		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }
		void	LockReadData( void ) { DNEnterCriticalSection( &m_IODataLock ); }
		void	UnlockReadData( void ) { DNLeaveCriticalSection( &m_IODataLock ); }
		void	LockWriteData( void ) { DNEnterCriticalSection( &m_IODataLock ); }
		void	UnlockWriteData( void ) { DNLeaveCriticalSection( &m_IODataLock ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::AddRef"
		void	AddRef( void ) 
		{ 
			DNASSERT( m_iRefCount != 0 );
			DNInterlockedIncrement( &m_iRefCount ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolDeallocFunction( void* pvItem );

		BOOL	Initialize( void );
		void	Deinitialize( void );

#ifdef WINNT
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::GetIOCompletionPort"
		HANDLE	GetIOCompletionPort( void ) const
		{
			DNASSERT( m_hIOCompletionPort != NULL );
			return	m_hIOCompletionPort;
		}
#endif // WINNT

		//
		// functions for handling I/O data
		//
		CModemReadIOData	*CreateReadIOData( void );
		void	ReturnReadIOData( CModemReadIOData *const pReadIOData );
		CModemWriteIOData	*CreateWriteIOData( void );
		void	ReturnWriteIOData( CModemWriteIOData *const pWriteData );

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::ReinsertInReadList"
		void	ReinsertInReadList( CModemReadIOData *const pReadIOData )
		{
			//
			// Win9x operations are removed from the active list when they
			// complete and need to be readded if they're going to be reattempted.
			// WinNT doesn't remove items from the list until they're processed.
			//
			DNASSERT( pReadIOData != NULL );
			DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );
			LockReadData();
			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );
			UnlockReadData();
		}
#endif // WIN95

		//
		// TAPI functions
		//
		const TAPI_INFO	*GetTAPIInfo( void ) const { return &m_TAPIInfo; }
		BOOL	TAPIAvailable( void ) const { return m_fTAPIAvailable; }

		HRESULT	SubmitDelayedCommand( JOB_FUNCTION *const pFunction,
									  JOB_FUNCTION *const pCancelFunction,
									  void *const pContext );

		HRESULT	SubmitTimerJob( const UINT_PTR uRetryCount,
								const BOOL fRetryForever,
								const DWORD dwRetryInterval,
								const BOOL fIdleWaitForever,
								const DWORD dwIdleTimeout,
								TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
								TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
								void *const pContext );
		
		BOOL	StopTimerJob( void *const pContext, const HRESULT hCommandResult );

		//
		// thread functions
		//
		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, void *const pDialogContext );
		
		LONG	GetIntendedThreadCount( void ) const { return m_iIntendedThreadCount; }
		void	SetIntendedThreadCount( const LONG iIntendedThreadCount ) { m_iIntendedThreadCount = iIntendedThreadCount; }
		LONG	ThreadCount( void ) const { return m_iTotalThreadCount; }
#ifdef WINNT
		LONG	NTCompletionThreadCount( void ) const { return m_iNTCompletionThreadCount; }
#endif // WINNT
		
		void	IncrementActiveThreadCount( void ) { DNInterlockedIncrement( const_cast<LONG*>( &m_iTotalThreadCount ) ); }
		void	DecrementActiveThreadCount( void ) { DNInterlockedDecrement( const_cast<LONG*>( &m_iTotalThreadCount ) ); }

#ifdef WINNT
		void	IncrementActiveNTCompletionThreadCount( void )
		{
			IncrementActiveThreadCount();
			DNInterlockedIncrement( const_cast<LONG*>( &m_iNTCompletionThreadCount ) );
		}

		void	DecrementActiveNTCompletionThreadCount( void )
		{
			DNInterlockedDecrement( const_cast<LONG*>( &m_iNTCompletionThreadCount ) );
			DecrementActiveThreadCount();
		}
#endif // WINNT
		
		HRESULT	GetIOThreadCount( LONG *const piThreadCount );
		HRESULT	SetIOThreadCount( const LONG iMaxThreadCount );
		BOOL IsThreadCountReductionAllowed( void ) const { return m_fAllowThreadCountReduction; }
		HRESULT PreventThreadPoolReduction( void );

		//
		// data port handle functions
		//
		HRESULT	CreateDataPortHandle( CDataPort *const pDataPort );
		void	CloseDataPortHandle( CDataPort *const pDataPort );
		CDataPort	*DataPortFromHandle( const DPNHANDLE hDataPort );

	protected:

	private:
		BYTE				m_Sig[4];	// debugging signature ('THPL')

		volatile LONG	m_iRefCount;
		
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_Lock;		// local lock
#endif // !DPNBUILD_ONLYONETHREAD

		volatile LONG	m_iTotalThreadCount;			// number of active threads
#ifdef WINNT
		volatile LONG	m_iNTCompletionThreadCount;		// count of NT I/O completion threads
		HANDLE	m_hIOCompletionPort;	// I/O completion port for NT
#endif // WINNT
		
		BOOL	m_fAllowThreadCountReduction;	// Boolean indicating that the thread count is locked from being reduced
		LONG	m_iIntendedThreadCount;			// how many threads will be started

		DNHANDLE	m_hStopAllThreads;		// handle used to stop all non-I/O completion threads
#ifdef WIN95
		DNHANDLE	m_hSendComplete;		// send complete on a data port
		DNHANDLE	m_hReceiveComplete;		// receive complete on a data port
		DNHANDLE	m_hTAPIEvent;			// handle to be used for TAPI messages, this handle is not closed on exit
		DNHANDLE	m_hFakeTAPIEvent;		// Fake TAPI event so the Win9x threads can always wait on a fixed
											// number of events.  If TAPI cannot be initialzed, this event needs to be
											// created and copied to m_hTAPIEvent (though it will never be signalled)
#endif // WIN95
		//
		// Handle table to prevent TAPI messages from going to CModemPorts when
		// they're no longer in use.
		//
		CHandleTable	m_DataPortHandleTable;

		//
		// list of pending network operations, it doesn't really matter if they're
		// reads or writes, they're just pending.  Since serial isn't under extreme
		// loads, share one lock for all of the data
		//
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_IODataLock;								// lock for all read data
#endif // !DPNBUILD_ONLYONETHREAD
		CBilink		m_OutstandingReadList;								// list of outstanding reads

		CBilink		m_OutstandingWriteList;							// list of outstanding writes

		//
		// The Job data lock covers all items through and including m_fNTTimerThreadRunning
		//
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_JobDataLock;		// lock for job queue/pool
#endif // !DPNBUILD_ONLYONETHREAD

		CJobQueue	m_JobQueue;					// job queue

		//
		// Data used by the the timer thread.  This data is protected by m_TimerDataLock.
		// This data is cleaned by the timer thread.  Since only one timer thread
		// is allowed to run at any given time, the status of the NT timer thread
		// can be determined by m_fNTEnumThreadRunning.  Win9x doesn't have a timer
		// thread, the main thread loop is timed.
		//
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_TimerDataLock;
#endif // !DPNBUILD_ONLYONETHREAD
		CBilink				m_TimerJobList;
#ifdef WINNT
		BOOL				m_fNTTimerThreadRunning;
#endif // WINNT

		//
		// TAPI information.  This is required to be in the thread pool because
		// it's needed for thread initialzation.
		//
		BOOL		m_fTAPIAvailable;
		TAPI_INFO	m_TAPIInfo;

		struct
		{
			BOOL	fTAPILoaded : 1;
			BOOL	fLockInitialized : 1;
			BOOL	fIODataLockInitialized : 1;
			BOOL	fJobDataLockInitialized : 1;
			BOOL	fTimerDataLockInitialized : 1;
			BOOL	fDataPortHandleTableInitialized :1 ;
			BOOL	fJobQueueInitialized : 1;
		} m_InitFlags;

		void	LockJobData( void ) { DNEnterCriticalSection( &m_JobDataLock ); }
		void	UnlockJobData( void ) { DNLeaveCriticalSection( &m_JobDataLock ); }

		void	LockTimerData( void ) { DNEnterCriticalSection( &m_TimerDataLock ); }
		void	UnlockTimerData( void ) { DNLeaveCriticalSection( &m_TimerDataLock ); }

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::GetSendCompleteEvent"
		DNHANDLE	GetSendCompleteEvent( void ) const
		{
			DNASSERT( m_hSendComplete != NULL );
			return m_hSendComplete;
		}
#endif // WIN95

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::GetReceiveCompleteEvent"
		DNHANDLE	GetReceiveCompleteEvent( void ) const
		{
			DNASSERT( m_hReceiveComplete != NULL );
			return m_hReceiveComplete;
		}
#endif // WIN95

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemThreadPool::GetTAPIMessageEvent"
		DNHANDLE	GetTAPIMessageEvent( void ) const
		{
			DNASSERT( m_hTAPIEvent != NULL );
			return	m_hTAPIEvent;
		}
#endif // WIN95

#ifdef WINNT
		HRESULT	WinNTInit( void );
#else // WIN95
		HRESULT	Win9xInit( void );
#endif // WINNT

		BOOL	ProcessTimerJobs( const CBilink *const pJobList, DWORD *const pdwNextJobTime);

		BOOL	ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pJob,
									   const DWORD dwCurrentTime,
									   DWORD *const pdwNextJobTime );

#ifdef WINNT
		HRESULT	StartNTTimerThread( void );
		void	WakeNTTimerThread( void );
#endif // WINNT
		void	RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerOperationData, const HRESULT hReturnCode );

#ifdef WIN95
		void	CompleteOutstandingSends( const DNHANDLE hSendCompleteEvent );
		void	CompleteOutstandingReceives( const DNHANDLE hReceiveCompleteEvent );

		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
#endif // WIN95

#ifdef WINNT
		static	DWORD WINAPI	WinNTIOCompletionThread( void *pParam );
		static	DWORD WINAPI	WinNTTimerThread( void *pParam );
#endif // WINNT
		static	DWORD WINAPI	DialogThreadProc( void *pParam );

		HRESULT	SubmitWorkItem( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*GetWorkItem( void );

#ifdef WIN95
		void	ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData );
		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
#endif // WIN95
		void	ProcessTapiEvent( void );

#ifdef WINNT
		void	StartNTCompletionThread( void );
#endif // WINNT
		void	StopAllThreads( void );
//		void	CancelOutstandingJobs( void );
		void	CancelOutstandingIO( void );
		void	ReturnSelfToPool( void );


		//
		// prevent unwarranted copies
		//
		CModemThreadPool( const CModemThreadPool & );
		CModemThreadPool& operator=( const CModemThreadPool & );
};

#undef DPF_MODNAME

#endif	// __THREAD_POOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   Utils.cpp
 *  Content:	Serial service provider utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_WIN9X_THREADS	1

static const WCHAR	g_RegistryBase[] = L"SOFTWARE\\Microsoft\\DirectPlay8";
static const WCHAR	g_RegistryKeyThreadCount[] = L"ThreadCount";

//
// default buffer size for getting TAPI device caps
//
static const DWORD	g_dwDefaultTAPIDevCapsSize = 512;

//
// TAPI module name
//
static const TCHAR	g_TAPIModuleName[] = TEXT("TAPI32.DLL");

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// global variables that are unique for the process
//
#ifndef DPNBUILD_ONLYONETHREAD
static	DNCRITICAL_SECTION	g_InterfaceGlobalsLock;
#endif // !DPNBUILD_ONLYONETHREAD

static volatile	LONG	g_iThreadPoolRefCount = 0;
static	CModemThreadPool		*g_pThreadPool = NULL;

static volatile LONG	g_iTAPIRefCount = 0;
static	HMODULE			g_hTAPIModule = NULL;

//**********************************************************************
// Function prototypes
//**********************************************************************
static	void	ReadSettingsFromRegistry( void );
static	BYTE	GetAddressEncryptionKey( void );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemInitProcessGlobals - initialize the global items needed for the SP to operate
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemInitProcessGlobals"

BOOL	ModemInitProcessGlobals( void )
{
	BOOL	fReturn;
	BOOL	fCriticalSectionInitialized;
	DWORD	iIndex;


	//
	// initialize
	//
	fReturn = TRUE;
	fCriticalSectionInitialized = FALSE;


#ifdef DBG
	g_blDPNModemCritSecsHeld.Initialize();
#endif // DBG


	ReadSettingsFromRegistry();

	if ( DNInitializeCriticalSection( &g_InterfaceGlobalsLock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	DebugSetCriticalSectionGroup( &g_InterfaceGlobalsLock, &g_blDPNModemCritSecsHeld );	 // separate dpnmodem CSes from the rest of DPlay's CSes

	fCriticalSectionInitialized = TRUE;


	if ( ModemInitializePools() == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

	// Load localized string from resources //////////////////////////////////////////////////////////////
	for (iIndex = 0; iIndex < g_dwBaudRateCount; iIndex++)
	{
		if (!LoadString(g_hModemDLLInstance, IDS_BAUD_9600 + iIndex, g_BaudRate[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	for (iIndex = 0; iIndex < g_dwStopBitsCount; iIndex++)
	{
		if (!LoadString(g_hModemDLLInstance, IDS_STOPBITS_ONE + iIndex, g_StopBits[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	for (iIndex = 0; iIndex < g_dwParityCount; iIndex++)
	{
		if (!LoadString(g_hModemDLLInstance, IDS_PARITY_EVEN + iIndex, g_Parity[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	for (iIndex = 0; iIndex < g_dwFlowControlCount; iIndex++)
	{
		if (!LoadString(g_hModemDLLInstance, IDS_FLOW_NONE + iIndex, g_FlowControl[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	DNASSERT( g_pThreadPool == NULL );

Exit:
	return	fReturn;

Failure:
	ModemDeinitializePools();

	if ( fCriticalSectionInitialized != FALSE )
	{
		DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
		fCriticalSectionInitialized = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemDeinitProcessGlobals - deinitialize the global items
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemDeinitProcessGlobals"

void	ModemDeinitProcessGlobals( void )
{
	DNASSERT( g_pThreadPool == NULL );
	DNASSERT( g_iThreadPoolRefCount == 0 );

	ModemDeinitializePools();
	DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializeInterfaceGlobals - perform global initialization for an interface.
//		This entails starting the thread pool and RSIP (if applicable).
//
// Entry:		Pointer to SPData
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "InitializeInterfaceGlobals"

HRESULT	InitializeInterfaceGlobals( CModemSPData *const pSPData )
{
	HRESULT		hr;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_pThreadPool == NULL )
	{
		DNASSERT( g_iThreadPoolRefCount == 0 );
		g_pThreadPool = (CModemThreadPool*)g_ModemThreadPoolPool.Get();
		if ( g_pThreadPool == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		else
		{
			if (!g_pThreadPool->Initialize())
			{
				hr = DPNERR_OUTOFMEMORY;
				g_ModemThreadPoolPool.Release(g_pThreadPool);
				g_pThreadPool = NULL;
				goto Failure;
			}

			g_iThreadPoolRefCount++;
		}
	}
	else
	{
		DNASSERT( g_iThreadPoolRefCount != 0 );
		g_iThreadPoolRefCount++;
		g_pThreadPool->AddRef();
	}

Exit:
	pSPData->SetThreadPool( g_pThreadPool );
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializeInterfaceGlobals - deinitialize thread pool and Rsip
//
// Entry:		Pointer to service provider
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DeinitializeInterfaceGlobals"

void	DeinitializeInterfaceGlobals( CModemSPData *const pSPData )
{
	CModemThreadPool		*pThreadPool;
	BOOL			fCleanUp;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	pThreadPool = NULL;
	fCleanUp = FALSE;

	//
	// Process as little as possible inside the lock.  If any of the items
	// need to be released, pointers to them will be set.
	//
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_pThreadPool != NULL );
	DNASSERT( g_iThreadPoolRefCount != 0 );
	DNASSERT( g_pThreadPool == pSPData->GetThreadPool() );

	pThreadPool = pSPData->GetThreadPool();

	//
	// remove thread pool reference
	//
	g_iThreadPoolRefCount--;
	if ( g_iThreadPoolRefCount == 0 )
	{
		g_pThreadPool = NULL;
		fCleanUp = TRUE;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	//
	// now that we're outside of the lock, clean up the thread pool if this
	// was the last reference to it
	//
	DNASSERT( pThreadPool != NULL );
	if ( fCleanUp != FALSE )
	{
		pThreadPool->Deinitialize();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LoadTAPILibrary - load TAPI library
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LoadTAPILibrary"

HRESULT	LoadTAPILibrary( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );
	if ( g_iTAPIRefCount != 0 )
	{
		DNASSERT( p_lineAnswer != NULL );
		DNASSERT( p_lineClose != NULL );
		DNASSERT( p_lineConfigDialog != NULL );
		DNASSERT( p_lineDeallocateCall != NULL );
		DNASSERT( p_lineDrop != NULL );
		DNASSERT( p_lineGetDevCaps != NULL );
		DNASSERT( p_lineGetID != NULL );
		DNASSERT( p_lineGetMessage != NULL );
		DNASSERT( p_lineInitializeEx != NULL );
		DNASSERT( p_lineMakeCall != NULL );
		DNASSERT( p_lineNegotiateAPIVersion != NULL );
		DNASSERT( p_lineOpen != NULL );
		DNASSERT( p_lineShutdown != NULL );
	}
	else
	{
		DNASSERT( g_hTAPIModule == NULL );
		DNASSERT( p_lineAnswer == NULL );
		DNASSERT( p_lineClose == NULL );
		DNASSERT( p_lineConfigDialog == NULL );
		DNASSERT( p_lineDeallocateCall == NULL );
		DNASSERT( p_lineDrop == NULL );
		DNASSERT( p_lineGetDevCaps == NULL );
		DNASSERT( p_lineGetID == NULL );
		DNASSERT( p_lineGetMessage == NULL );
		DNASSERT( p_lineInitializeEx == NULL );
		DNASSERT( p_lineMakeCall == NULL );
		DNASSERT( p_lineNegotiateAPIVersion == NULL );
		DNASSERT( p_lineOpen == NULL );
		DNASSERT( p_lineShutdown == NULL );

		g_hTAPIModule = LoadLibrary( g_TAPIModuleName );
		if ( g_hTAPIModule == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to load TAPI!" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineAnswer = reinterpret_cast<TAPI_lineAnswer*>( GetProcAddress( g_hTAPIModule, "lineAnswer" ) );
		if ( p_lineAnswer == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineAnswer" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineClose = reinterpret_cast<TAPI_lineClose*>( GetProcAddress( g_hTAPIModule, "lineClose"  ) );
		if ( p_lineClose == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineClose" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineConfigDialog = reinterpret_cast<TAPI_lineConfigDialog*>( GetProcAddress( g_hTAPIModule, "lineConfigDialog" TAPI_APPEND_LETTER ) );
		if ( p_lineConfigDialog == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineConfigDialog" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineDeallocateCall = reinterpret_cast<TAPI_lineDeallocateCall*>( GetProcAddress( g_hTAPIModule, "lineDeallocateCall" ) );
		if ( p_lineDeallocateCall == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineDeallocateCall" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineDrop = reinterpret_cast<TAPI_lineDrop*>( GetProcAddress( g_hTAPIModule, "lineDrop" ) );
		if ( p_lineDrop == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineDrop" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineGetDevCaps = reinterpret_cast<TAPI_lineGetDevCaps*>( GetProcAddress( g_hTAPIModule, "lineGetDevCaps" TAPI_APPEND_LETTER ) );
		if ( p_lineGetDevCaps == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineGetDevCaps" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineGetID = reinterpret_cast<TAPI_lineGetID*>( GetProcAddress( g_hTAPIModule, "lineGetID" TAPI_APPEND_LETTER ) );
		if ( p_lineGetID == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineGetID" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineGetMessage = reinterpret_cast<TAPI_lineGetMessage*>( GetProcAddress( g_hTAPIModule, "lineGetMessage" ) );
		if ( p_lineGetMessage == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineGetMessage" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineInitializeEx = reinterpret_cast<TAPI_lineInitializeEx*>( GetProcAddress( g_hTAPIModule, "lineInitializeEx" TAPI_APPEND_LETTER ) );
		if ( p_lineInitializeEx == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineInitializeEx" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineMakeCall = reinterpret_cast<TAPI_lineMakeCall*>( GetProcAddress( g_hTAPIModule, "lineMakeCall" TAPI_APPEND_LETTER ) );
		if ( p_lineMakeCall == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineMakeCall" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineNegotiateAPIVersion = reinterpret_cast<TAPI_lineNegotiateAPIVersion*>( GetProcAddress( g_hTAPIModule, "lineNegotiateAPIVersion" ) );
		if ( p_lineNegotiateAPIVersion == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineNegotiateAPIVersion" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineOpen = reinterpret_cast<TAPI_lineOpen*>( GetProcAddress( g_hTAPIModule, "lineOpen" TAPI_APPEND_LETTER ) );
		if ( p_lineOpen == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineOpen" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineShutdown = reinterpret_cast<TAPI_lineShutdown*>( GetProcAddress( g_hTAPIModule, "lineShutdown" ) );
		if ( p_lineShutdown == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineShutdown" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
	}
	
	DNASSERT( g_iTAPIRefCount != -1 );
	g_iTAPIRefCount++;

Exit:	
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
	return	hr;

Failure:
	hr = DPNERR_OUTOFMEMORY;

	p_lineAnswer = NULL;
	p_lineClose = NULL;
	p_lineConfigDialog = NULL;
	p_lineDeallocateCall = NULL;
	p_lineDrop = NULL;
	p_lineGetDevCaps = NULL;
	p_lineGetID = NULL;
	p_lineGetMessage = NULL;
	p_lineInitializeEx = NULL;
	p_lineMakeCall = NULL;
	p_lineNegotiateAPIVersion = NULL;
	p_lineOpen = NULL;
	p_lineShutdown = NULL;
	
	if ( g_hTAPIModule != NULL )
	{
		if ( FreeLibrary( g_hTAPIModule ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem unloading TAPI module on failed load!" );
			DisplayErrorCode( 0, dwError );
		}
	
		g_hTAPIModule = NULL;
	}
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// UnloadTAPILibrary - unload TAPI library
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "UnloadTAPILibrary"

void	UnloadTAPILibrary( void )
{
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_iTAPIRefCount != 0 );
	g_iTAPIRefCount--;
	if ( g_iTAPIRefCount == 0 )
	{
		DNASSERT( g_hTAPIModule != NULL );
		DNASSERT( p_lineAnswer != NULL );
		DNASSERT( p_lineClose != NULL );
		DNASSERT( p_lineConfigDialog != NULL );
		DNASSERT( p_lineDeallocateCall != NULL );
		DNASSERT( p_lineDrop != NULL );
		DNASSERT( p_lineGetDevCaps != NULL );
		DNASSERT( p_lineGetID != NULL );
		DNASSERT( p_lineGetMessage != NULL );
		DNASSERT( p_lineInitializeEx != NULL );
		DNASSERT( p_lineMakeCall != NULL );
		DNASSERT( p_lineNegotiateAPIVersion != NULL );
		DNASSERT( p_lineOpen != NULL );
		DNASSERT( p_lineShutdown != NULL );

		if ( FreeLibrary( g_hTAPIModule ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem unloading TAPI module on failed load!" );
			DisplayErrorCode( 0, dwError );
		}
	
		g_hTAPIModule = NULL;
		p_lineAnswer = NULL;
		p_lineClose = NULL;
		p_lineConfigDialog = NULL;
		p_lineDeallocateCall = NULL;
		p_lineDrop = NULL;
		p_lineGetDevCaps = NULL;
		p_lineGetID = NULL;
		p_lineGetMessage = NULL;
		p_lineInitializeEx = NULL;
		p_lineMakeCall = NULL;
		p_lineNegotiateAPIVersion = NULL;
		p_lineOpen = NULL;
		p_lineShutdown = NULL;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IsSerialGUID - is a GUID a serial GUID?
//
// Entry:		Pointer to GUID
//
// Exit:		Boolean inficating whether the GUID is a serial GUID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IsSerialGUID"

BOOL	IsSerialGUID( const GUID *const pGuid )
{
	BOOL	fReturn;


	DNASSERT( pGuid != NULL );

	//
	// assume guid is serial
	//
	fReturn = TRUE;

	//
	// is this modem or serial?
	//
	if ( IsEqualCLSID( *pGuid, CLSID_DP8SP_MODEM ) == FALSE )
	{
		if ( IsEqualCLSID( *pGuid, CLSID_DP8SP_SERIAL ) == FALSE )
		{
			// not a known GUID
			fReturn = FALSE;
		}
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// StringToValue - convert a string to an enumerated value
//
// Entry:		Pointer to string
//				Length of string
//				Pointer to destination enum
//				Pointer to string/enum pairs
//				Count of string/enum pairs
//
// Exit:		Boolean indicating success
//				TRUE = value found
//				FALSE = value not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StringToValue"

BOOL	StringToValue( const WCHAR *const pString,
					   const DWORD dwStringLength,
					   VALUE_ENUM_TYPE *const pEnum,
					   const STRING_BLOCK *const pStringBlock,
					   const DWORD dwPairCount )
{
	BOOL	fFound;
	DWORD	dwCount;


	// initialize
	fFound = FALSE;
	dwCount = dwPairCount;

	// loop through list
	while ( ( dwCount > 0 ) && ( fFound == FALSE ) )
	{
		// make array index
		dwCount--;

		// are the strings the same length?
		if ( pStringBlock[ dwCount ].dwWCHARKeyLength == dwStringLength )
		{
			// is this what we were looking for?
			if ( memcmp( pString, pStringBlock[ dwCount ].pWCHARKey, dwStringLength ) == 0 )
			{
				// found it
				fFound = TRUE;
				*pEnum = pStringBlock[ dwCount ].dwEnumValue;
			}
		}
	}

	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ValueToString - split extra info into components
//
// Entry:		Pointer to pointer to string
//				Length of string
//				Enumerated value
//				Pointer to string-enum pairs
//				Count of string-enum pairs
//
// Exit:		Boolean indicating success
//				TRUE = value was converted
//				FALSE = value was not converted
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ValueToString"

BOOL	ValueToString( const WCHAR **const ppString,
					   DWORD *const pdwStringLength,
					   const DWORD Enum,
					   const STRING_BLOCK *const pStringBlock,
					   const DWORD dwPairCount )
{
	BOOL	fFound;
	DWORD	dwCount;


	// initialize
	fFound = FALSE;
	dwCount = dwPairCount;

	// loop through strings
	while ( ( dwCount > 0 ) && ( fFound == FALSE ))
	{
		// make array index
		dwCount--;

		// is this the enum?
		if ( pStringBlock[ dwCount ].dwEnumValue == Enum )
		{
			// note that we found the value
			*ppString = pStringBlock[ dwCount ].pWCHARKey;
			*pdwStringLength = pStringBlock[ dwCount ].dwWCHARKeyLength;
			fFound = TRUE;
		}
	}

	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReadSettingsFromRegistry - read custom registry keys
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReadSettingsFromRegistry"

static void	ReadSettingsFromRegistry( void )
{
	CRegistry	RegObject;


	if ( RegObject.Open( HKEY_LOCAL_MACHINE, g_RegistryBase ) != FALSE )
	{
		DWORD	dwRegValue;

		//
		// read default threads
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyThreadCount, &dwRegValue ) != FALSE )
		{
			g_iThreadCount = dwRegValue;	
		}
	
		//
		// if thread count is zero, use the 'default' for the system
		//
		if ( g_iThreadCount == 0 )
		{
#ifdef WIN95
			g_iThreadCount = DEFAULT_WIN9X_THREADS;
#else // WINNT
			SYSTEM_INFO		SystemInfo;

			//
			// as suggested by 'Multithreading Applications in Win32' book:
			// dwNTThreadCount = ( ( processors * 2 ) + 2 )
			//
			memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
			GetSystemInfo( &SystemInfo );
			
			g_iThreadCount = ( ( 2 * SystemInfo.dwNumberOfProcessors ) + 2 );
#endif // WIN95
		}
		
		RegObject.Close();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetAddressEncryptionKey - get a key used to encrypt device GUIDs
//
// Entry:		Nothing
//
// Exit:		Byte key
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetAddressEncryptionKey"

static	BYTE	GetAddressEncryptionKey( void )
{
	BYTE		bReturn;
	UINT_PTR	ProcessID;

	bReturn = 0;
	ProcessID = GetCurrentProcessId();
	while ( ProcessID > 0 )
	{
		bReturn ^= ProcessID;
		ProcessID >>= ( sizeof( bReturn ) * 8 );
	}

	return	bReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeviceIDToGuid - convert a device ID to an adapter GUID
//
// Entry:		Reference of Guid to fill
//				Device ID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DeviceIDToGuid"

void	DeviceIDToGuid( GUID *const pGuid, const UINT_PTR DeviceID, const GUID *const pEncryptionGuid )
{
	DNASSERT( DeviceID < MAX_DATA_PORTS );

	DNASSERT( sizeof( *pGuid ) == sizeof( *pEncryptionGuid ) );
	memset( pGuid, 0x00, sizeof( *pGuid ) );
	reinterpret_cast<BYTE*>( pGuid )[ 0 ] = static_cast<BYTE>( DeviceID );

	ModemEncryptGuid( pGuid, pGuid, pEncryptionGuid );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GuidToDeviceID - convert an adapter GUID to a device ID
//
// Entry:		Reference of Guid
//				
//
// Exit:		Device ID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GuidToDeviceID"

DWORD	GuidToDeviceID( const GUID *const pGuid, const GUID *const pEncryptionGuid )
{
	GUID	DecryptedGuid;


	DNASSERT( pGuid != NULL );
	DNASSERT( pEncryptionGuid != NULL );

	ModemDecryptGuid( pGuid, &DecryptedGuid, pEncryptionGuid );
	return	reinterpret_cast<const BYTE*>( &DecryptedGuid )[ 0 ];
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ComDeviceIDToString - convert a COM device ID to a string
//
// Entry:		Pointer to destination string (assumed to be large enough)
//				Device ID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ComDeviceIDToString"

void	ComDeviceIDToString( TCHAR *const pString, const UINT_PTR uDeviceID )
{
	UINT_PTR	uTemp;


	DNASSERT( uDeviceID < MAX_DATA_PORTS );

	uTemp = uDeviceID;
	memcpy( pString, TEXT("COM000"), COM_PORT_STRING_LENGTH * sizeof(TCHAR) );
	pString[ 5 ] = ( static_cast<char>( uTemp % 10 ) ) + TEXT('0');
	uTemp /= 10;
	pString[ 4 ] = ( static_cast<char>( uTemp % 10 ) ) + TEXT('0');
	uTemp /= 10;
	pString[ 3 ] = ( static_cast<char>( uTemp % 10 ) ) + TEXT('0');
	DNASSERT( uTemp < 10 );

	if ( uDeviceID < 100 )
	{
		if ( uDeviceID < 10 )
		{
			DNASSERT( pString[ 3 ] == TEXT('0') );
			DNASSERT( pString[ 4 ] == TEXT('0') );
			pString[ 3 ] = pString[ 5 ];
			pString[ 4 ] = TEXT('\0');
			pString[ 5 ] = TEXT('\0');
		}
		else
		{
			DNASSERT( pString[ 3 ] == TEXT('0') );
			pString[ 3 ] = pString[ 4 ];
			pString[ 4 ] = pString[ 5 ];
			pString[ 5 ] = TEXT('\0');
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// WideToANSI - convert a wide string to an ANSI string
//
// Entry:		Pointer to source wide string
//				Size of source string (in WCHAR units, -1 implies NULL-terminated)
//				Pointer to ANSI string destination
//				Pointer to size of ANSI destination
//
// Exit:		Error code:
//				DPNERR_GENERIC = operation failed
//				DPN_OK = operation succeded
//				DPNERR_BUFFERTOOSMALL = destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "WideToAnsi"

HRESULT	WideToAnsi( const WCHAR *const pWCHARString, const DWORD dwWCHARStringLength, char *const pString, DWORD *const pdwStringLength )
{
	HRESULT	hr;
	int		iReturn;
	BOOL	fDefault;


	DNASSERT( pWCHARString != NULL );
	DNASSERT( pdwStringLength != NULL );
	DNASSERT( ( pString != NULL ) || ( &pdwStringLength == 0 ) );

	hr = DPN_OK;

	fDefault = FALSE;
	iReturn = WideCharToMultiByte( CP_ACP,				// code page (default ANSI)
								   0,					// flags (none)
								   pWCHARString,		// pointer to WCHAR string
								   dwWCHARStringLength,	// size of WCHAR string
								   pString,				// pointer to destination ANSI string
								   *pdwStringLength,	// size of destination string
								   NULL,				// pointer to default for unmappable characters (none)
								   &fDefault			// pointer to flag indicating that default was used
								   );
	if ( iReturn == 0 )
	{
		hr = DPNERR_GENERIC;
	}
	else
	{
		if ( *pdwStringLength == 0 )
		{
			hr = DPNERR_BUFFERTOOSMALL;
		}
		else
		{
			DNASSERT( hr == DPN_OK );
		}

		*pdwStringLength = iReturn;
	}

	//
	// if you hit this ASSERT it's because you've probably got ASCII text as your
	// input WCHAR string.  Double-check your input!!
	//
	DNASSERT( fDefault == FALSE );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ANSIToWide - convert an ANSI string to a wide string
//
// Entry:		Pointer to source multi-byte (ANSI) string
//				Size of source string (-1 imples NULL-terminated)
//				Pointer to multi-byte string destination
//				Pointer to size of multi-byte destination (in WCHAR units)
//
// Exit:		Error code:
//				ERR_FAIL - operation failed
//				ERR_NONE - operation succeded
//				ERR_BUFFER_TOO_SMALL - destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "AnsiToWide"

HRESULT	AnsiToWide( const char *const pString, const DWORD dwStringLength, WCHAR *const pWCHARString, DWORD *const pdwWCHARStringLength )
{
	HRESULT	hr;
	int		iReturn;


	DNASSERT( pdwWCHARStringLength != 0 );
	DNASSERT( ( pWCHARString != NULL ) || ( pdwWCHARStringLength == 0 ) );
	DNASSERT( pString != NULL );

	hr = DPN_OK;
	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pString,					// pointer to multi-byte string			
								   dwStringLength,			// size of string (assume null-terminated)
								   pWCHARString,			// pointer to destination wide-char string
								   *pdwWCHARStringLength	// size of destination in WCHARs
								   );
	if ( iReturn == 0 )
	{
		hr = DPNERR_GENERIC;
	}
	else
	{
		if ( *pdwWCHARStringLength == 0 )
		{
			hr = DPNERR_BUFFERTOOSMALL;
		}
		else
		{
			DNASSERT( hr == DPN_OK );
		}

		*pdwWCHARStringLength = iReturn;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSPData - create instance data for SP
//
// Entry:		Pointer to pointer to SPData
//				Pionter to class GUID
//				Interface type
//				Pointer to COM interface vtable
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateSPData"

HRESULT	CreateSPData( CModemSPData **const ppSPData,
					  const SP_TYPE SPType,
					  IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT	hr;
	CModemSPData	*pSPData;


	DNASSERT( ppSPData != NULL );
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	*ppSPData = NULL;
	pSPData = NULL;

	//
	// create data
	//
	pSPData = new CModemSPData;
	if ( pSPData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot create data for interface!" );
		goto Failure;
	}
	pSPData->AddRef();

	hr = pSPData->Initialize( SPType, pVtbl );
	if ( hr != DPN_OK  )
	{
		DPFX(DPFPREP,  0, "Failed to intialize SP data!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CreateSPData!" );
		DisplayDNError( 0, hr );
	}

	*ppSPData = pSPData;
	
	return	hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateAvailableComPortList - generate a list of available com ports
//
// Entry:		Pointer to list of Booleans to indicate availablility
//				Maximum index of comport to enumerate
//				Pointer to number of com ports found
//
// Exit:		Error code
//
// Note:	This function will fill in indicies 1 through uMaxDeviceIndex.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GenerateAvailableComPortList"

HRESULT	GenerateAvailableComPortList( BOOL *const pfPortAvailable,
									  const UINT_PTR uMaxDeviceIndex,
									  DWORD *const pdwPortCount )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	UINT_PTR	uPortCount;


	DNASSERT( pfPortAvailable != NULL );
	DNASSERT( uMaxDeviceIndex != 0 );
	DNASSERT( pdwPortCount != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	uPortCount = 0;
	memset( pfPortAvailable, 0x00, ( sizeof( *pfPortAvailable ) * ( uMaxDeviceIndex + 1 ) ) );
	*pdwPortCount = 0;

	//
	// attempt to open all COM ports in the specified range
	//
	uIndex = uMaxDeviceIndex;
	while ( uIndex != 0 )
	{
		DNHANDLE	hComFile;
		TCHAR	ComTemplate[ (COM_PORT_STRING_LENGTH+1) ];
		DWORD	dwError;


		ComDeviceIDToString( ComTemplate, uIndex );
		hComFile = DNCreateFile( ComTemplate,						// comm port name
							   GENERIC_READ | GENERIC_WRITE,	// read/write access
							   0,								// don't share file with others
							   NULL,							// default sercurity descriptor
							   OPEN_EXISTING,					// comm port must exist to be opened
							   FILE_FLAG_OVERLAPPED,			// use overlapped I/O
							   NULL								// no handle for template file
							   );
		if ( hComFile == DNINVALID_HANDLE_VALUE )
		{
			dwError = GetLastError();
			if ( dwError != ERROR_ACCESS_DENIED )
			{
				//
				// Don't bother displaying ERROR_FILE_NOT_FOUND, that's the usual
				// error when you try to open a bogus COM port.
				//
				if ( dwError != ERROR_FILE_NOT_FOUND )
				{
					DPFX(DPFPREP, 9, "Couldn't open COM%u while enumerating com port adapters, err = %u.", uIndex, dwError );
					DisplayErrorCode( 9, dwError );
				}
				
				goto SkipComPort;
			}

			DPFX(DPFPREP, 1, "Couldn't open COM%u, it is probably already in use.", uIndex );

			//
			// Consider the port as possibly available, continue.
			//
		}

		//
		// We found a valid COM port (it may be in use), note which COM port
		// this is and then close our handle
		//
		pfPortAvailable[ uIndex ] = TRUE;
		uPortCount++;

		if ( hComFile != DNINVALID_HANDLE_VALUE )
		{
			if ( DNCloseHandle( hComFile ) == FALSE )
			{
				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem closing COM%u while enumerating com port adapters, err = %u!",
					uIndex, dwError );
				DisplayErrorCode( 0, dwError );
			}
		}

SkipComPort:
		uIndex--;
	}

	DNASSERT( uPortCount <= UINT32_MAX );
	DBG_CASSERT( sizeof( *pdwPortCount ) == sizeof( DWORD ) );
	*pdwPortCount = static_cast<DWORD>( uPortCount );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateAvailableModemList - generate list of available modems
//
// Entry:		Pointer to TAPI data
//				Pointer to modem count
//				Pointer to data block
//				Pointer to size of data block
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GenerateAvailableModemList"

HRESULT	GenerateAvailableModemList( const TAPI_INFO *const pTAPIInfo,
									DWORD *const pdwModemCount,
									MODEM_NAME_DATA *const pModemNameData,
									DWORD *const pdwModemNameDataSize )
{
	HRESULT				hr;
	LONG				lLineReturn;
	DWORD				dwDeviceID;
	DWORD				dwDevCapsSize;
	DWORD				dwAPIVersion;
	LINEDEVCAPS			*pDevCaps;
	LINEEXTENSIONID		LineExtensionID;
	DWORD				dwRequiredBufferSize;
	TCHAR				*pOutputModemName;


	DNASSERT( pdwModemCount != NULL );
	DNASSERT( pdwModemNameDataSize != NULL );
	DNASSERT( ( pModemNameData != NULL ) || ( *pdwModemNameDataSize == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;
	dwRequiredBufferSize = 0;
	*pdwModemCount = 0;
	pDevCaps = NULL;

	if ( pModemNameData != NULL )
	{
		pOutputModemName = &(reinterpret_cast<TCHAR*>( pModemNameData )[ *pdwModemNameDataSize / sizeof(TCHAR) ]);
		memset( pModemNameData, 0x00, *pdwModemNameDataSize );
	}
	else
	{
		pOutputModemName = NULL;
	}

	dwDevCapsSize = g_dwDefaultTAPIDevCapsSize;
	pDevCaps = static_cast<LINEDEVCAPS*>( DNMalloc( dwDevCapsSize ) );
	if ( pDevCaps == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	dwDeviceID = pTAPIInfo->dwLinesAvailable;
	if ( dwDeviceID > ( MAX_DATA_PORTS - 2 ) )
	{
		dwDeviceID = MAX_DATA_PORTS - 2;
		DPFX(DPFPREP,  0, "Truncating to %d devices!", dwDeviceID );
	}

Reloop:
	while ( dwDeviceID != 0 )
	{
		dwDeviceID--;

		memset( &LineExtensionID, 0x00, sizeof( LineExtensionID ) );
		DNASSERT( p_lineNegotiateAPIVersion != NULL );
		lLineReturn = p_lineNegotiateAPIVersion( pTAPIInfo->hApplicationInstance,	// handle to TAPI instance
												 dwDeviceID,						// device ID
												 0,
												 pTAPIInfo->dwVersion,				// maximum TAPI version
												 &dwAPIVersion,						// pointer to negotiated line version
												 &LineExtensionID					// pointer to line extension infromation (none)
												 );
		if ( lLineReturn != LINEERR_NONE )
		{
			//
			// let this slide, just return no name string
			//
			switch ( lLineReturn )
			{
				//
				// this TAPI device isn't up to our standards, ignore it
				//
				case LINEERR_INCOMPATIBLEAPIVERSION:
				{
					DPFX(DPFPREP, 0, "Rejecting TAPI device 0x%x because of API version!", dwDeviceID );
					goto Reloop;

					break;
				}

				//
				// Device is not present.  I don't know what causes
				// this, but I saw it on one of my dev machines after
				// I switched the modem from COM2 to COM1.
				//
				case LINEERR_NODEVICE:
				{
					DPFX(DPFPREP, 0, "Rejecting TAPI device 0x%x because it's not there!", dwDeviceID );
					goto Reloop;
					break;
				}

				//
				// This was seen in PnP stress.
				//
				case LINEERR_UNINITIALIZED:
				{
					DPFX(DPFPREP, 0, "Rejecting TAPI device 0x%x because it is not initialized!", dwDeviceID );
					goto Reloop;
					break;
				}

				//
				// other, stop and see what happened
				//
				default:
				{
					DPFX(DPFPREP, 0, "Problem getting line API version for device: %d", dwDeviceID );
					DisplayTAPIError( 0, lLineReturn );
					goto Reloop;

					break;
				}
			}
		}

		//
		// ask for device caps
		//
		pDevCaps->dwTotalSize = dwDevCapsSize;
		pDevCaps->dwNeededSize = dwDevCapsSize;
		lLineReturn = LINEERR_STRUCTURETOOSMALL;

		while ( lLineReturn == LINEERR_STRUCTURETOOSMALL )
		{
			DNASSERT( pDevCaps != NULL );

			dwDevCapsSize = pDevCaps->dwNeededSize;

			DNFree( pDevCaps );
			pDevCaps = (LINEDEVCAPS*) DNMalloc( dwDevCapsSize );
			if ( pDevCaps == NULL )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "GetAvailableModemList: Failed to realloc memory on device %d!", dwDeviceID );
				goto Failure;
			}

			pDevCaps->dwTotalSize = dwDevCapsSize;
			pDevCaps->dwNeededSize = 0;

			DNASSERT( p_lineGetDevCaps != NULL );
			lLineReturn = p_lineGetDevCaps( pTAPIInfo->hApplicationInstance,	// TAPI instance handle
											dwDeviceID,							// TAPI device ID
											dwAPIVersion,						// negotiated API version
											0,									// extended data version (none)
											pDevCaps							// pointer to device caps data
											);
			//
			// TAPI lies about structures being too small!
			// Double check the structure size ourselves.
			//
			if ( pDevCaps->dwNeededSize > dwDevCapsSize )
			{
				lLineReturn = LINEERR_STRUCTURETOOSMALL;
			}
		}

		//
		// If caps have been gotten, process them.  Otherwise skip this device.
		//
		if ( lLineReturn == LINEERR_NONE )
		{
			//
			// is this really a modem?
			//
			if ( ( pDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM ) != 0 )
			{
				//
				// is this the modem name information accerptable?
				//
				if ( ( pDevCaps->dwLineNameSize != 0 ) &&
					 ( pDevCaps->dwLineNameOffset != 0 ) )
				{
					//
					// get the name of the device
					//
					DBG_CASSERT( sizeof( pDevCaps ) == sizeof( char* ) );
					DWORD dwSize;
					switch (pDevCaps->dwStringFormat)
					{
						case STRINGFORMAT_ASCII:
						{
							char* pLineName;
							pLineName = &( reinterpret_cast<char*>( pDevCaps )[ pDevCaps->dwLineNameOffset ] );
							//
							// Note the required storage size and only copy it to the output
							// if there's enough room.  TAPI drivers are inconsistent.  Some
							// drivers return NULL terminated strings and others return strings
							// with no NULL termination.  Be paranoid and reserve space for an
							// extra NULL for termination so we can always guarantee termination.
							// This may waste a byte or two, but the user will never notice.
							//
							dwRequiredBufferSize += sizeof( *pModemNameData ) + (pDevCaps->dwLineNameSize * sizeof(TCHAR)) + sizeof( g_NullToken );
							if ( dwRequiredBufferSize <= *pdwModemNameDataSize )
							{
								pModemNameData[ *pdwModemCount ].dwModemID = ModemIDFromTAPIID( dwDeviceID );
								pModemNameData[ *pdwModemCount ].dwModemNameSize = pDevCaps->dwLineNameSize * sizeof(TCHAR);

								pOutputModemName = &pOutputModemName[ - (static_cast<INT_PTR>( ((pDevCaps->dwLineNameSize * sizeof(TCHAR)) + sizeof( g_NullToken ) ) / sizeof(TCHAR))) ];
#ifndef UNICODE
								memcpy( pOutputModemName, pLineName, pDevCaps->dwLineNameSize );
#else
								dwSize = pDevCaps->dwLineNameSize * sizeof(TCHAR);
								AnsiToWide(pLineName, pDevCaps->dwLineNameSize, pOutputModemName, &dwSize);
#endif // UNICODE
								pModemNameData[ *pdwModemCount ].pModemName = pOutputModemName;

								//
								// Be paranoid about NULL termination.  We've accounted for enough
								// space to add a terminating NULL to the TAPI device name if one
								// wasn't provided.
								//
								if ( pOutputModemName[ ((pDevCaps->dwLineNameSize * sizeof(TCHAR)) - sizeof( g_NullToken )) / sizeof(TCHAR) ] != g_NullToken )
								{
									pOutputModemName[ pDevCaps->dwLineNameSize ] = g_NullToken;
									pModemNameData[ *pdwModemCount ].dwModemNameSize += sizeof( g_NullToken );
								}
							}
							else
							{
								//
								// Note that the output buffer is too small, but still keep
								// processing modem names.
								//
								hr = DPNERR_BUFFERTOOSMALL;
							}

							(*pdwModemCount)++;
							DPFX(DPFPREP,  2, "Accepting modem device: 0x%x (ASCII)", dwDeviceID );
						}
						break;
						
						case STRINGFORMAT_UNICODE:
						{
							WCHAR* pLineName;
							pLineName = &( reinterpret_cast<WCHAR*>( pDevCaps )[ pDevCaps->dwLineNameOffset / sizeof(WCHAR)] );
							//
							// Note the required storage size and only copy it to the output
							// if there's enough room.  TAPI drivers are inconsistent.  Some
							// drivers return NULL terminated strings and others return strings
							// with no NULL termination.  Be paranoid and reserve space for an
							// extra NULL for termination so we can always guarantee termination.
							// This may waste a byte or two, but the user will never notice.
							//
							dwRequiredBufferSize += sizeof( *pModemNameData ) + ((pDevCaps->dwLineNameSize * sizeof(TCHAR)) / sizeof(WCHAR)) + sizeof( g_NullToken );
							if ( dwRequiredBufferSize <= *pdwModemNameDataSize )
							{
								pModemNameData[ *pdwModemCount ].dwModemID = ModemIDFromTAPIID( dwDeviceID );
								pModemNameData[ *pdwModemCount ].dwModemNameSize = pDevCaps->dwLineNameSize * (sizeof(TCHAR) / sizeof(WCHAR));

								pOutputModemName = &pOutputModemName[ - (static_cast<INT_PTR>( (((pDevCaps->dwLineNameSize * sizeof(TCHAR)) / sizeof(WCHAR)) + sizeof( g_NullToken ) ) / sizeof(TCHAR))) ];
#ifdef UNICODE
								memcpy( pOutputModemName, pLineName, pDevCaps->dwLineNameSize );
#else
								dwSize = pDevCaps->dwLineNameSize / sizeof(TCHAR);
								WideToAnsi(pLineName, pDevCaps->dwLineNameSize / sizeof(WCHAR), pOutputModemName, &dwSize);
#endif // UNICODE
								pModemNameData[ *pdwModemCount ].pModemName = pOutputModemName;

								//
								// Be paranoid about NULL termination.  We've accounted for enough
								// space to add a terminating NULL to the TAPI device name if one
								// wasn't provided.
								//
								if ( pOutputModemName[ (((pDevCaps->dwLineNameSize*sizeof(TCHAR))/sizeof(WCHAR)) - sizeof( g_NullToken )) / sizeof(TCHAR) ] != g_NullToken )
								{
									pOutputModemName[ pDevCaps->dwLineNameSize / sizeof(WCHAR) ] = g_NullToken;
									pModemNameData[ *pdwModemCount ].dwModemNameSize += sizeof( g_NullToken );
								}
							}
							else
							{
								//
								// Note that the output buffer is too small, but still keep
								// processing modem names.
								//
								hr = DPNERR_BUFFERTOOSMALL;
							}

							(*pdwModemCount)++;
							DPFX(DPFPREP,  2, "Accepting modem device: 0x%x (Unicode)", dwDeviceID );
						}
						break;

						default:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem with modem name for device: 0x%x!", dwDeviceID );
							DNASSERT( FALSE );
						}
					}
				}
				else
				{
					hr = DPNERR_GENERIC;
					DPFX(DPFPREP,  0, "Problem with modem name for device: 0x%x!", dwDeviceID );
					DNASSERT( FALSE );
				}
			}
			else
			{
				DPFX(DPFPREP,  1, "Ignoring non-datamodem device: 0x%x", dwDeviceID );
			}
		}
		else
		{
			DPFX(DPFPREP,  0, "Failed to get device caps.  Ignoring device: 0x%x", dwDeviceID );
		}
	}

	*pdwModemNameDataSize = dwRequiredBufferSize;

Exit:
	if ( pDevCaps != NULL )
	{
		DNFree( pDevCaps );
		pDevCaps = NULL;
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// PhoneNumberToWCHAR - convert a phone number to WCHAR
//
// Entry:		Pointer to phone number
//				Pointer to WCHAR destination
//				Pointer to size of WCHAR destintion
//
// Exit:		Error code
// ------------------------------
#ifndef UNICODE
HRESULT	PhoneNumberToWCHAR( const char *const pPhoneNumber,
							WCHAR *const pWCHARPhoneNumber,
							DWORD *const pdwWCHARPhoneNumberSize )
{
	HRESULT		hr;
	char		*pOutput;
	DWORD		dwInputIndex;	
	DWORD		dwOutputIndex;

	
	DNASSERT( pPhoneNumber != NULL );
	DNASSERT( pWCHARPhoneNumber != NULL );
	DNASSERT( pdwWCHARPhoneNumberSize != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pOutput = reinterpret_cast<char*>( pWCHARPhoneNumber );
	dwInputIndex = 0;
	dwOutputIndex = 0;
	memset( pWCHARPhoneNumber, 0, ( (*pdwWCHARPhoneNumberSize) * sizeof( *pWCHARPhoneNumber ) ) );

	while ( pPhoneNumber[ dwInputIndex ] != '\0' )
	{
		if ( dwInputIndex < ( *pdwWCHARPhoneNumberSize ) )
		{
			pOutput[ dwOutputIndex ] = pPhoneNumber[ dwInputIndex ];
		}
	
		dwOutputIndex += sizeof( *pWCHARPhoneNumber );
		dwInputIndex += sizeof( *pPhoneNumber );
	}
	
	*pdwWCHARPhoneNumberSize = dwInputIndex + 1;

	return	hr;
}
#endif // !UNICODE
//**********************************************************************


//**********************************************************************
// ------------------------------
// PhoneNumberFromWCHAR - convert a phone number from WCHAR
//
// Entry:		Pointer to WCHAR phone number
//				Pointer to phone number destination
//				Pointer to phone destination size
//
// Exit:		Error code
// ------------------------------
#ifndef UNICODE
HRESULT	PhoneNumberFromWCHAR( const WCHAR *const pWCHARPhoneNumber,
							  char *const pPhoneNumber,
							  DWORD *const pdwPhoneNumberSize )
{
	HRESULT	hr;
	const char	*pInput;
	DWORD		dwInputIndex;
	DWORD		dwOutputIndex;

	
	DNASSERT( pWCHARPhoneNumber != NULL );
	DNASSERT( pPhoneNumber != NULL );
	DNASSERT( pdwPhoneNumberSize != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pInput = reinterpret_cast<const char*>( pWCHARPhoneNumber );
	dwInputIndex = 0;
	dwOutputIndex = 0;
	memset( pPhoneNumber, 0x00, *pdwPhoneNumberSize );

	while ( pInput[ dwInputIndex ] != '\0' )
	{
		if ( dwOutputIndex < *pdwPhoneNumberSize )
		{
			pPhoneNumber[ dwOutputIndex ] = pInput[ dwInputIndex ];
		}
		
		dwInputIndex += sizeof( *pWCHARPhoneNumber );
		dwOutputIndex += sizeof( *pPhoneNumber );
	}

	*pdwPhoneNumberSize = dwOutputIndex + 1;
	
	return	hr;
}
#endif // !UNICODE
//**********************************************************************


//**********************************************************************
// ------------------------------
// ModemEncryptGuid - encrypt a guid
//
// Entry:		Pointer to source guid
//				Pointer to destination guid
//				Pointer to encryption key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ModemEncryptGuid"

void	ModemEncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncryptionKey )
{
	const char	*pSourceBytes;
	char		*pDestinationBytes;
	const char	*pEncryptionBytes;
	DWORD_PTR	dwIndex;


	DNASSERT( pSourceGuid != NULL );
	DNASSERT( pDestinationGuid != NULL );
	DNASSERT( pEncryptionKey != NULL );

	DBG_CASSERT( sizeof( pSourceBytes ) == sizeof( pSourceGuid ) );
	pSourceBytes = reinterpret_cast<const char*>( pSourceGuid );
	
	DBG_CASSERT( sizeof( pDestinationBytes ) == sizeof( pDestinationGuid ) );
	pDestinationBytes = reinterpret_cast<char*>( pDestinationGuid );
	
	DBG_CASSERT( sizeof( pEncryptionBytes ) == sizeof( pEncryptionKey ) );
	pEncryptionBytes = reinterpret_cast<const char*>( pEncryptionKey );
	
	DBG_CASSERT( ( sizeof( *pSourceGuid ) == sizeof( *pEncryptionKey ) ) &&
				 ( sizeof( *pDestinationGuid ) == sizeof( *pEncryptionKey ) ) );
	dwIndex = sizeof( *pSourceGuid );
	while ( dwIndex != 0 )
	{
		dwIndex--;
		pDestinationBytes[ dwIndex ] = pSourceBytes[ dwIndex ] ^ pEncryptionBytes[ dwIndex ];
	}
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\modemui.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemUI.cpp
 *  Content:	Modem service provider UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/24/99	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// default size of temp strings used to add stuff to dialog
#define	DEFAULT_DIALOG_STRING_SIZE	100

#define	DEFAULT_DEVICE_SELECTION_INDEX			0

#define	MAX_MODEM_NAME_LENGTH	255

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

static const INT_PTR	g_iExpectedIncomingModemSettingsReturn = 0x23456789;
static const INT_PTR	g_iExpectedOutgoingModemSettingsReturn = 0x3456789A;

//**********************************************************************
// Function prototypes
//**********************************************************************
static	INT_PTR CALLBACK	IncomingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam );
static	HRESULT	SetAddressParametersFromIncomingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint );

static	INT_PTR CALLBACK	OutgoingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam );
static	HRESULT	SetOutgoingPhoneNumber( const HWND hDialog, const CModemEndpoint *const pModemEndpoint );
static	HRESULT	SetAddressParametersFromOutgoingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint );

static	HRESULT	DisplayModemConfigDialog( const HWND hDialog, const HWND hDeviceComboBox, const CModemEndpoint *const pModemEndpoint );

static	HRESULT	SetModemDataInDialog( const HWND hComboBox, const CModemEndpoint *const pModemEndpoint );
static	HRESULT	GetModemSelectionFromDialog( const HWND hComboBox, CModemEndpoint *const pModemEndpoint );
static	INT_PTR CALLBACK	ModemStatusDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayIncomingModemSettingsDialog - dialog for incoming modem connection
//
// Entry:		Pointer to startup param
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayIncomingModemSettingsDialog"

void	DisplayIncomingModemSettingsDialog( void *const pContext )
{
	INT_PTR			iDlgReturn;
	CModemEndpoint	*pModemEndpoint;


	DNASSERT( pContext != NULL );

	//	
	// intialize
	//
	pModemEndpoint = static_cast<CModemEndpoint*>( pContext );

	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LPARAM ) );
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hModemDLLInstance,									// handle of module for resources
								 MAKEINTRESOURCE( IDD_INCOMING_MODEM_SETTINGS ),	// resource for dialog
								 NULL,												// no parent
								 IncomingSettingsDialogProc,						// dialog message proc
								 reinterpret_cast<LPARAM>( pModemEndpoint )			// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedIncomingModemSettingsReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start incoming modem settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pModemEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayOutgoingModemSettingsDialog - dialog for Outgoing modem connection
//
// Entry:		Pointer to startup param
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayOutgoingModemSettingsDialog"

void	DisplayOutgoingModemSettingsDialog( void *const pContext )
{
	INT_PTR			iDlgReturn;
	CModemEndpoint	*pModemEndpoint;


	DNASSERT( pContext != NULL );

	//	
	// intialize
	//
	pModemEndpoint = static_cast<CModemEndpoint*>( pContext );

	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LPARAM ) );
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hModemDLLInstance,									// handle of module for resources
								 MAKEINTRESOURCE( IDD_OUTGOING_MODEM_SETTINGS ),	// resource for dialog
								 NULL,												//
								 OutgoingSettingsDialogProc,						// dialog message proc
								 reinterpret_cast<LPARAM>( pModemEndpoint )			// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedOutgoingModemSettingsReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start outgoing modem settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pModemEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// StopModemSettingsDialog - stop dialog dialog for modem settings
//
// Entry:		Handle of dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StopModemSettingsDialog"

void	StopModemSettingsDialog( const HWND hDlg )
{
	DNASSERT( hDlg != NULL );
	if ( PostMessage( hDlg, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to stop dialog!" );
		DisplayErrorCode( 0, dwError );
		DNASSERT( FALSE );
	}
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// DisplayModemStatusDialog - dialog for modem status
////
//// Entry:		Pointer to destination for dialog handle
////				Pointer to startup param
////
//// Exit:		Error code
//// ------------------------------
//HRESULT	DisplayModemStatusDialog( HWND *const phDialog, CModemEndpoint *const pEndpoint )
//{
//	HRESULT	hr;
//	HWND	hDialog;
//
//
//	// intialize
//	hr = DPN_OK;
//
//	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( LPARAM ) );
//	hDialog = CreateDialogParam( g_hModemDLLInstance,							// handle of module for resources
//							  MAKEINTRESOURCE( IDD_MODEM_STATUS ),		// resource for dialog
//							  GetForegroundWindow(),					// parent window (whatever is on top)
//							  ModemStatusDialogProc,					// dialog message proc
//							  reinterpret_cast<LPARAM>( pEndpoint )		// startup parameter
//							  );
//	if ( hDialog == NULL )
//	{
//		DPFX(DPFPREP,  0, "Could not create modem status dialog!" );
//		DisplayErrorCode( 0, GetLastError() );
//		goto Failure;
//	}
//
//	*phDialog = hDialog;
//	ShowWindow( hDialog, SW_SHOW );
//	UpdateWindow( hDialog );
//
//Exit:
//	return	hr;
//
//Failure:
//	goto Exit;
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// StopModemStatusDialog - stop dialog for modem connection status
////
//// Entry:		Handle of dialog
////
//// Exit:		Nothing
//// ------------------------------
//void	StopModemStatusDialog( const HWND hDialog )
//{
//	DNASSERT( hDialog != NULL );
//
//	if ( SendMessage( hDialog, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) != 0 )
//	{
//		// we didn't handle the message
//		DNASSERT( FALSE );
//	}
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// OutgoingSettingsDialogProc - dialog proc for outgoing modem connection
//
// Entry:		Window handle
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "OutgoingSettingsDialogProc"

static	INT_PTR CALLBACK OutgoingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CModemEndpoint	*pModemEndpoint;
	HRESULT	hr;

	
	//
	// initialize
	//
	hr = DPN_OK;

	// note the active endpoint pointer
	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LONG_PTR ) );
	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDialog, GWLP_USERDATA ) );

	switch ( uMsg )
	{
	    // initialize dialog
	    case WM_INITDIALOG:
	    {
	    	// since this is the first dialog message, the default code to set
	    	// pModemEndpoint isn't getting valid data
	    	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( lParam ) );
			pModemEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
			pModemEndpoint->SetActiveDialogHandle( hDialog );

	    	//
	    	// SetWindowLongPtr() returns NULL in case of error.  It's possible
			// that the old value from SetWindowLongPtr() was really NULL in
			// which case it's not an error.  To be safe, clear any residual
			// error code before calling SetWindowLongPtr().
	    	//
	    	SetLastError( 0 );
	    	if ( SetWindowLongPtr( hDialog, GWLP_USERDATA, lParam ) == NULL )
	    	{
	    		DWORD	dwError;

	    		dwError = GetLastError();
	    		if ( dwError != ERROR_SUCCESS )
	    		{
	    			DPFX(DPFPREP,  0, "Problem setting user data for window!" );
	    			DisplayErrorCode( 0, dwError );
	    			goto Failure;
	    		}
	    	}

	    	//
			// set dialog information
	    	//
			hr = SetModemDataInDialog( GetDlgItem( hDialog, IDC_COMBO_OUTGOING_MODEM_DEVICE ), pModemEndpoint );
			if ( hr != DPN_OK )
	    	{
	    		DPFX(DPFPREP,  0, "Problem setting modem device!" );
	    		DisplayDNError( 0, hr );
	    		goto Failure;
	    	}

	    	hr = SetOutgoingPhoneNumber( hDialog, pModemEndpoint );
			if ( hr != DPN_OK )
	    	{
	    		DPFX(DPFPREP,  0, "Problem setting phone number!" );
	    		DisplayDNError( 0, hr );
	    		goto Failure;
	    	}

	    	return	TRUE;

	    	break;
	    }

	    // a control did something
	    case WM_COMMAND:
	    {
	    	// what was the control?
	    	switch ( LOWORD( wParam ) )
	    	{
	    		case IDOK:
	    		{
	    			hr = SetAddressParametersFromOutgoingDialogData( hDialog, pModemEndpoint );
					if ( hr != DPN_OK )
	    			{
	    				DPFX(DPFPREP,  0, "Problem getting dialog data!" );
	    				DisplayDNError( 0, hr );
	    				goto Failure;
	    			}

	    			// pass any error code on to 'DialogComplete'
	    			pModemEndpoint->SettingsDialogComplete( hr );
	    			EndDialog( hDialog, g_iExpectedOutgoingModemSettingsReturn );

	    			break;
	    		}

	    		case IDCANCEL:
	    		{
	    			pModemEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
	    			EndDialog( hDialog, g_iExpectedOutgoingModemSettingsReturn );

	    			break;
	    		}

	    		case IDC_BUTTON_MODEM_CONFIGURE:
	    		{
	    			hr = DisplayModemConfigDialog( hDialog, GetDlgItem( hDialog, IDC_COMBO_OUTGOING_MODEM_DEVICE ), pModemEndpoint );
					if ( hr != DPN_OK )
	    			{
	    				DPFX(DPFPREP,  0, "Problem with DisplayModemConfigDialog in outgoing dialog!" );
	    				DisplayDNError( 0, hr );
	    			}

	    			break;
	    		}
	    	}

	    	break;
	    }

	    // window is closing
	    case WM_CLOSE:
	    {
	    	break;
	    }
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pModemEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pModemEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDialog, g_iExpectedOutgoingModemSettingsReturn );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IncomingSettingsDialogProc - dialog proc for incoming modem connection
//
// Entry:		Window handle
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IncomingSettingsDialogProc"

static	INT_PTR CALLBACK IncomingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CModemEndpoint	*pModemEndpoint;
	HRESULT			hr;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// note the modem port pointer
	//
	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LONG_PTR ) );
	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDialog, GWLP_USERDATA ) );

	switch ( uMsg )
	{
		//
		// initialize dialog
		//
		case WM_INITDIALOG:
		{
			//
			// since this is the first dialog message, the default code to set
			// pModemEndpoint isn't getting valid data
			//
			DBG_CASSERT( sizeof( pModemEndpoint) == sizeof( lParam ) );
			pModemEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
			pModemEndpoint->SetActiveDialogHandle( hDialog );

			//
			// SetWindowLongPtr() returns NULL in case of error.  It's possible
			// that the old value from SetWindowLongPtr() was really NULL in
			// which case it's not an error.  To be safe, clear any residual
			// error code before calling SetWindowLongPtr().
			//
			SetLastError( 0 );
			if ( SetWindowLongPtr( hDialog, GWLP_USERDATA, lParam ) == NULL )
			{
				DWORD	dwError;


				dwError = GetLastError();
				if ( dwError != ERROR_SUCCESS )
				{
					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
					DisplayErrorCode( 0, dwError );
					goto Failure;
				}
			}

			//
			// set dialog information
			//
			hr = SetModemDataInDialog( GetDlgItem( hDialog, IDC_COMBO_INCOMING_MODEM_DEVICE ), pModemEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "Problem setting modem device!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			return	TRUE;

			break;
		}

		//
		// a control did something
		//
		case WM_COMMAND:
		{
			// what was the control?
			switch ( LOWORD( wParam ) )
			{
				case IDOK:
				{
					hr = SetAddressParametersFromIncomingDialogData( hDialog, pModemEndpoint );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem getting dialog data!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					//
					// pass any error code on to 'DialogComplete'
					//
					pModemEndpoint->SettingsDialogComplete( hr );
					EndDialog( hDialog, g_iExpectedIncomingModemSettingsReturn );

					break;
				}

				case IDCANCEL:
				{
					pModemEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
					EndDialog( hDialog, g_iExpectedIncomingModemSettingsReturn );

					break;
				}

				case IDC_BUTTON_MODEM_CONFIGURE:
				{
					hr = DisplayModemConfigDialog( hDialog,
												   GetDlgItem( hDialog, IDC_COMBO_INCOMING_MODEM_DEVICE ),
												   pModemEndpoint );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem with DisplayModemConfigDialog in incoming dialog!" );
						DisplayDNError( 0, hr );
					}

					break;
				}
			}

			break;
		}

		//
		// window is closing
		//
		case WM_CLOSE:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pModemEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pModemEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDialog, g_iExpectedIncomingModemSettingsReturn );

	goto Exit;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// ModemStatusDialogProc - dialog proc for modem status
////
//// Entry:		Window handle
////				Message LPARAM
////				Message WPARAM
////
//// Exit:		Error code
//// ------------------------------
//static	INT_PTR CALLBACK ModemStatusDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam )
//{
//	CModemEndpoint	*pModemEndpoint;
//	HRESULT	hr;
//
//	// initialize
//	hr = DPN_OK;
//
//	// note the active endpoint pointer
//	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LONG_PTR ) );
//	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDialog, GWLP_USERDATA ) );
//
//	switch ( uMsg )
//	{
//		// initialize dialog
//		case WM_INITDIALOG:
//		{
//			// since this is the first dialog message, the default code to set
//			// pModemEndpoint isn't getting valid data
//			DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( lParam ) );
//			pModemEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
//
//			//
//			// SetWindowLongPtr() returns NULL in case of error.  It's possible
//			// that the old value from SetWindowLongPtr() was really NULL in
//			// which case it's not an error.  To be safe, clear any residual
//			// error code before calling SetWindowLongPtr().
//			//
//			SetLastError( 0 );
//			if ( SetWindowLongPtr( hDialog, GWLP_USERDATA, lParam ) == NULL )
//			{
//				DWORD	dwError;
//
//				dwError = GetLastError();
//				if ( dwError != ERROR_SUCCESS )
//				{
//					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
//					DisplayErrorCode( 0, dwError );
//					goto Failure;
//				}
//			}
//
//			// set dialog information
//
//			return	TRUE;
//
//			break;
//		}
//
//		// a control did something
//		case WM_COMMAND:
//		{
//			// what was the control?
//			switch ( LOWORD( wParam ) )
//			{
//				case IDOK:
//				{
////					HRESULT	hr;
//
//
////					if ( ( hr = GetDialogData( hDialog, pModemEndpoint ) ) != DPN_OK )
////					{
////					    DPFX(DPFPREP,  0, "Problem getting dialog data!" );
////					    DisplayDNError( 0, hr );
////					    goto Failure;
////					}
//
////					// pass any error code on to 'DialogComplete'
////					pModemEndpoint->DialogComplete( hr );
//					DestroyWindow( hDialog );
//
//					break;
//				}
//
////				case IDCANCEL:
////				{
////				    pModemEndpoint->DialogComplete( DPNERR_USERCANCEL );
////				    DestroyWindow( hDialog );
////
////				    break;
////				}
//			}
//
//			break;
//		}
//
//		// window is closing
//		case WM_CLOSE:
//		{
//			break;
//		}
//	}
//
//Exit:
//	return	FALSE;
//
//Failure:
//	DNASSERT( pModemEndpoint != NULL );
//	DNASSERT( hr != DPN_OK );
////	pModemEndpoint->StatusDialogComplete( hr );
//	DestroyWindow( hDialog );
//
//	goto Exit;
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// SetModemDataInDialog - set device for modem dialog
//
// Entry:		Window handle of modem combo box
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetModemDataInDialog"

HRESULT	SetModemDataInDialog( const HWND hComboBox, const CModemEndpoint *const pModemEndpoint )
{
	HRESULT			hr;
	LRESULT			lResult;
	DWORD			dwModemCount;
	MODEM_NAME_DATA	*pModemNameData;
	DWORD			dwModemNameDataSize;
	BOOL			fSelectionSet;
	UINT_PTR		uIndex;


	DNASSERT( hComboBox != NULL );
	DNASSERT( pModemEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pModemNameData = NULL;
	dwModemNameDataSize = 0;
	fSelectionSet = FALSE;

	lResult = SendMessage( hComboBox, CB_RESETCONTENT, 0, 0 );
//	DNASSERT( lResult == CB_OKAY );		// <-- Win2K is busted!!!!

	hr = GenerateAvailableModemList( pModemEndpoint->GetSPData()->GetThreadPool()->GetTAPIInfo(),
									 &dwModemCount,
									 pModemNameData,
									 &dwModemNameDataSize );
	switch ( hr )
	{
		//
		// no modems to list, no more processing to be done
		//
		case DPN_OK:
		{
			goto Exit;
		}

		//
		// expected return
		//
		case DPNERR_BUFFERTOOSMALL:
		{
			break;
		}

		//
		// error
		//
		default:
		{
			DPFX(DPFPREP,  0, "SetModemDataInDialog: Failed to get size of modem list!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

	pModemNameData = static_cast<MODEM_NAME_DATA*>( DNMalloc( dwModemNameDataSize ) );
	if ( pModemNameData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "SetModemDataInDialog: Failed to allocate memory to fill modem dialog list!" );
		goto Failure;
	}

	hr = GenerateAvailableModemList( pModemEndpoint->GetSPData()->GetThreadPool()->GetTAPIInfo(),
									 &dwModemCount,
									 pModemNameData,
									 &dwModemNameDataSize );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "SetModemDataInDialog: Failed to get size of modem list!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	for ( uIndex = 0; uIndex < dwModemCount; uIndex++ )
	{
		LRESULT	AddResult;


		DBG_CASSERT( sizeof( pModemNameData[ uIndex ].pModemName ) == sizeof( LPARAM ) );
		AddResult = SendMessage( hComboBox, CB_INSERTSTRING, 0, reinterpret_cast<const LPARAM>( pModemNameData[ uIndex ].pModemName ) );
		switch ( AddResult )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding serial device to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory when ading serial device to combo box!" );
				goto Failure;


				break;
			}

			//
			// we added the string OK, set the associated device id and check
			// to see if this is the current value to set selection
			//
			default:
			{	
				LRESULT	SetResult;


				SetResult = SendMessage ( hComboBox, CB_SETITEMDATA, AddResult, pModemNameData[ uIndex ].dwModemID );
				if ( SetResult == CB_ERR )
				{
					DWORD	dwError;


					hr = DPNERR_OUTOFMEMORY;
					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Problem setting modem device info!" );
					DisplayErrorCode( 0, dwError );
					goto Failure;
				}

				if ( pModemEndpoint->GetDeviceID() == uIndex )
				{
					LRESULT	SetSelectionResult;


					SetSelectionResult = SendMessage( hComboBox, CB_SETCURSEL, AddResult, 0 );
					if ( SetSelectionResult == CB_ERR )
					{
						DWORD	dwError;


						hr = DPNERR_GENERIC;
						dwError = GetLastError();
						DPFX(DPFPREP,  0, "Problem setting default modem device selection!" );
						DisplayErrorCode( 0, dwError );
						DNASSERT( FALSE );
						goto Failure;
					}

					fSelectionSet = TRUE;
				}

				break;
			}

		}
	}

	if ( fSelectionSet == FALSE )
	{
		LRESULT	SetSelectionResult;


		SetSelectionResult = SendMessage( hComboBox, CB_SETCURSEL, 0, 0 );
		if ( SetSelectionResult == CB_ERR )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem setting default modem selection!" );
			DisplayErrorCode( 0, dwError );
		}
	}

Exit:
	if ( pModemNameData != NULL )
	{
		DNFree( pModemNameData );
		pModemNameData = NULL;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetModemSelectionFromDialog - get modem selection from dialog
//
// Entry:		Window handle of modem combo box
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetModemSelectionFromDialog"

static HRESULT	GetModemSelectionFromDialog( const HWND hComboBox, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	LRESULT	Selection;
	LRESULT	DeviceID;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( hComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Invalid control handle passed to GetModemSelectionFromDialog!" );
		goto Failure;
	}

	//
	// get modem selection
	//
	Selection = SendMessage( hComboBox, CB_GETCURSEL, 0, 0 );
	if ( Selection == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Could not get current modem selection!" );
		DNASSERT( FALSE );
		goto Failure;
	}

	//
	// get device ID
	//
	DeviceID = SendMessage( hComboBox, CB_GETITEMDATA, Selection, 0 );
	if ( DeviceID == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Could not get selection item data!" );
		DNASSERT( FALSE );
		goto Failure;
	}

	//
	// Now that we finally have the device ID, set it.  Make sure
	// we clear any existing ID first, or the ID setting code will
	// complain.  I like paranoid code, so work around the ASSERT.
	//
	DNASSERT( DeviceID <= UINT32_MAX );
	hr = pModemEndpoint->SetDeviceID( INVALID_DEVICE_ID );
	DNASSERT( hr == DPN_OK );

	hr = pModemEndpoint->SetDeviceID( static_cast<DWORD>( DeviceID ) );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem setting modem device ID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetOutgoingPhoneNumber - set phone number for modem dialog
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetOutgoingPhoneNumber"

HRESULT	SetOutgoingPhoneNumber( const HWND hDialog, const CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( SetWindowText( GetDlgItem( hDialog, IDC_EDIT_MODEM_PHONE_NUMBER ), pModemEndpoint->GetPhoneNumber() ) == FALSE )
	{
	    DPFX(DPFPREP,  0, "Problem setting default phone number!" );
	    DisplayErrorCode( 0, GetLastError() );
	    goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetAddressParamtersFromIncomingDialogData - set address data from incoming modem settings dialog
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetAddressParametersFromIncomingDialogData"

static	HRESULT	SetAddressParametersFromIncomingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	HWND	hControl;


	//
	// initialize
	//
	hr = DPN_OK;
	hControl = GetDlgItem( hDialog, IDC_COMBO_INCOMING_MODEM_DEVICE );
	if ( hControl == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	hr = GetModemSelectionFromDialog( hControl, pModemEndpoint );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem getting modem device!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Failure:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetAddressParamtersFromOutgoingDialogData - set endpoint data from outgoing modem settings dialog
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetAddressParametersFromOutgoingDialogData"

static	HRESULT	SetAddressParametersFromOutgoingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	HWND	hControl;
	DWORD	dwPhoneNumberLength;
	TCHAR	TempBuffer[ MAX_PHONE_NUMBER_LENGTH + 1 ];


	DNASSERT( hDialog != NULL );
	DNASSERT( pModemEndpoint != NULL );

	// initialize
	hr = DPN_OK;
	hControl = GetDlgItem( hDialog, IDC_COMBO_OUTGOING_MODEM_DEVICE );
	if ( hControl == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	hr = GetModemSelectionFromDialog( hControl, pModemEndpoint );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem getting modem device!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	// get phone number from dialog
	hControl = GetDlgItem( hDialog, IDC_EDIT_MODEM_PHONE_NUMBER );
	if ( hControl == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of phone number edit field!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	dwPhoneNumberLength = GetWindowText( hControl, TempBuffer, (sizeof(TempBuffer)/sizeof(TCHAR)) - 1 );
	if ( dwPhoneNumberLength == 0 )
	{
#ifdef DBG
		DWORD	dwErrorReturn;


		dwErrorReturn = GetLastError();
		DPFX(DPFPREP,  0, "User entered an invalid phone number in dialog (err = %u)!", dwErrorReturn );
#endif // DBG
		hr = DPNERR_ADDRESSING;
		goto Failure;
	}
	else
	{
		hr = pModemEndpoint->SetPhoneNumber( TempBuffer );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Problem setting new phone number!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

Failure:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayModemConfigDialog - display dialog to configure modem
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayModemConfigDialog"

static	HRESULT	DisplayModemConfigDialog( const HWND hDialog, const HWND hDeviceComboBox, const CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	LRESULT	lSelection;
	LRESULT	lDeviceID;
	LONG	lTAPIReturn;


	DNASSERT( hDialog != NULL );
	DNASSERT( pModemEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	if ( hDeviceComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Invalid device combo box handle!" );
		goto Exit;
	}

	//
	// ask for current selection in combo box
	//
	lSelection = SendMessage( hDeviceComboBox, CB_GETCURSEL, 0, 0 );
	if ( lSelection == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Failed to get current modem selection when configuring modem!" );
		DNASSERT( FALSE );
		goto Exit;
	}

	//
	// ask for the device ID for this selection, note that the device IDs are
	//
	lDeviceID = SendMessage( hDeviceComboBox, CB_GETITEMDATA, lSelection, 0 );
	if ( lDeviceID == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting device ID from selected modem when calling for config dialog!" );
		goto Exit;
	}

	// display dialog
	DNASSERT( lDeviceID <= UINT32_MAX );
	lTAPIReturn = p_lineConfigDialog( TAPIIDFromModemID( static_cast<DWORD>( lDeviceID ) ),
									  hDialog,
									  TEXT("comm/datamodem") );
	if ( lTAPIReturn != LINEERR_NONE )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem with modem config dialog!" );
		DisplayTAPIError( 0, lTAPIReturn );
		goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\dpnmodemutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.h
 *  Content:	serial service provider utilitiy functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __UTILS_H__
#define __UTILS_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// type definition for values in StringToValue and ValueToString
//
#define	VALUE_ENUM_TYPE	DWORD

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward strucutre references
//
class	CModemSPData;
typedef	struct	_BUFFERDESC			BUFFERDESC;
typedef	struct	_MESSAGE_HEADER		MESSAGE_HEADER;

//
// structure for relating a string to an enum value
//
typedef	struct	_STRING_BLOCK
{
	DWORD		dwEnumValue;
	const WCHAR	*pWCHARKey;
	DWORD		dwWCHARKeyLength;
	const char	*pASCIIKey;
	DWORD		dwASCIIKeyLength;
	TCHAR		szLocalizedKey[256];		
} STRING_BLOCK;

//
// structure to generate list of modems
//
typedef	struct	_MODEM_NAME_DATA
{
	DWORD		dwModemID;			// modem ID
	DWORD		dwModemNameSize;	// size of name (including NULL)
	const TCHAR	*pModemName;		// modem name
} MODEM_NAME_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	ModemInitProcessGlobals( void );
void	ModemDeinitProcessGlobals( void );

HRESULT	InitializeInterfaceGlobals( CModemSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CModemSPData *const pSPData );

HRESULT	LoadTAPILibrary( void );
void	UnloadTAPILibrary( void );

BOOL	IsSerialGUID( const GUID *const pGuid );

BOOL	StringToValue( const WCHAR *const pString,
					   const DWORD dwStringLength,
					   VALUE_ENUM_TYPE *const pEnum,
					   const STRING_BLOCK *const pPairs,
					   const DWORD dwPairCount );

BOOL	ValueToString( const WCHAR **const ppString,
					   DWORD *const pdwStringLength,
					   const DWORD Enum,
					   const STRING_BLOCK *const pPairs,
					   const DWORD dwPairCount );

void	DeviceIDToGuid( GUID *const pGuid, const UINT_PTR DeviceID, const GUID *const pEncryptionGuid );
DWORD	GuidToDeviceID( const GUID *const pGuid, const GUID *const pEncryptionGuid );

void	ComDeviceIDToString( TCHAR *const pString, const UINT_PTR DeviceID );

HRESULT	WideToAnsi( const WCHAR *const pWCHARString,
					const DWORD dwWCHARStringLength,
					char *const pString,
					DWORD *const pdwStringLength );

HRESULT	AnsiToWide( const char *const pString,
					const DWORD dwStringLength,
					WCHAR *const pWCHARString,
					DWORD *const pdwWCHARStringLength );

HRESULT	CreateSPData( CModemSPData **const ppSPData,
					  const SP_TYPE SPType,
					  IDP8ServiceProviderVtbl *const pVtbl );

HRESULT	InitializeInterfaceGlobals( CModemSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CModemSPData *const pSPData );

HRESULT	GenerateAvailableComPortList( BOOL *const pfPortAvailable,
									  const UINT_PTR uMaxDeviceIndex,
									  DWORD *const pdwPortCount );

HRESULT	GenerateAvailableModemList( const TAPI_INFO *const pTAPIInfo,
									DWORD *const pdwModemCount,
									MODEM_NAME_DATA *const pModemNameData,
									DWORD *const pdwModemNameDataSize );

_inline DWORD	ModemIDFromTAPIID( const DWORD dwTAPIID ) { return	( dwTAPIID + 1 ); }

#undef DPF_MODNAME
#define DPF_MODNAME "TAPIIDFromModemID"
_inline DWORD	TAPIIDFromModemID( const DWORD dwModemID )
{
	DNASSERT( dwModemID != 0 );
	return	( dwModemID - 1 );
}

#undef DPF_MODNAME


#ifndef UNICODE
HRESULT	PhoneNumberToWCHAR( const char *const pPhoneNumber,
							WCHAR *const pWCHARPhoneNumber,
							DWORD *const pdwWCHARPhoneNumberSize );

HRESULT	PhoneNumberFromWCHAR( const WCHAR *const pWCHARPhoneNumber,
							  char *const pPhoneNumber,
							  DWORD *const pdwPhoneNumberSize );
#endif
//
// GUID encryption/decription code.  Note that it's presently an XOR function
// so map the decryption code to the encryption function.
//
void	ModemEncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncrpytionKey );

inline void	ModemDecryptGuid( const GUID *const pSourceGuid,
						 GUID *const pDestinationGuid,
						 const GUID *const pEncryptionKey ) { ModemEncryptGuid( pSourceGuid, pDestinationGuid, pEncryptionKey ); }


#endif	// __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\parseclass.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ParseClass.cpp
 *  Content:	Parsing class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	121/02/99	jtk		Derived from IPXAddress.cpp
 *  01/10/20000	rmt		Updated to build with Millenium build process
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************
//
// default buffer size to use when parsing address components
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CParseClass::ParseDP8Address - parse a DirectPlay8 address
//
// Entry:		Pointer to DP8Address
//				Pointer to expected SP guid
//				Pointer to parse keys
//				Count of parse keys
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CParseClass::ParseDP8Address"

HRESULT	CParseClass::ParseDP8Address( IDirectPlay8Address *const pDP8Address,
									  const GUID *const pSPGuid,
									  const PARSE_KEY *const pParseKeys,
									  const UINT_PTR uParseKeyCount )
{
	HRESULT		hr;
	BOOL		fParsing;
#ifndef DPNBUILD_ONLYONESP
	GUID		Guid;
#endif // ! DPNBUILD_ONLYONESP
	void		*pAddressComponent;
	DWORD		dwComponentSize;
	DWORD		dwAllocatedComponentSize;
	UINT_PTR	uIndex;


	DNASSERT( pDP8Address != NULL );
	DNASSERT( pSPGuid != NULL );
	DNASSERT( pParseKeys != NULL );
	DNASSERT( uParseKeyCount != 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	fParsing = TRUE;
	dwAllocatedComponentSize = DEFAULT_COMPONENT_BUFFER_SIZE;
	uIndex = uParseKeyCount;

	pAddressComponent = DNMalloc( dwAllocatedComponentSize );
	if ( pAddressComponent == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "ParseClass: failed to allocate temp buffer for parsing" );
		goto Exit;
	}

#ifndef DPNBUILD_ONLYONESP
	//
	// verify SPType
	//
	hr = IDirectPlay8Address_GetSP( pDP8Address, &Guid );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "ParseClass: failed to verify service provider type!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	if ( IsEqualCLSID( *pSPGuid, Guid ) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		DPFX(DPFPREP,  0, "Service provider guid mismatch during parse!" );
		goto Exit;
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	// parse
	//
	while ( uIndex != 0 )
	{
		HRESULT		hTempResult;
		DWORD		dwDataType;


		uIndex--;
		DNASSERT( pAddressComponent != NULL );
		dwComponentSize = dwAllocatedComponentSize;

Reparse:
		hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address,					// pointer to address
															  pParseKeys[ uIndex ].pKey,	// pointer to key to search for
															  pAddressComponent,			// pointer to value destination
															  &dwComponentSize,				// pointer to value destination size
															  &dwDataType );				// pointer to data type
		switch ( hTempResult )
		{
			//
			// component parsed successfully, figure out what it is by checking
			// key length and then comparing key strings
			//
			case DPN_OK:
			{
				hr = pParseKeys[ uIndex ].pParseFunc( pAddressComponent,
													  dwComponentSize,
													  dwDataType,
													  pParseKeys[ uIndex ].pContext
													  );
				if ( hr != DPN_OK )
				{
					goto Exit;
				}

				break;
			}

			//
			// buffer too small, reallocate and try again
			//
			case DPNERR_BUFFERTOOSMALL:
			{
				DNASSERT( dwComponentSize > dwAllocatedComponentSize );
				DNASSERT( pAddressComponent != NULL );

				DNFree( pAddressComponent );
				pAddressComponent = DNMalloc( dwComponentSize );
				if ( pAddressComponent == NULL )
				{
					hr = DPNERR_OUTOFMEMORY;
					goto Exit;
				}
					
				dwAllocatedComponentSize = dwComponentSize;

				goto Reparse;

				break;
			}

			//
			// Missing component.  Skip this component and
			// look for other parsing errors.
			//
			case DPNERR_DOESNOTEXIST:
			{
				break;
			}

			//
			// error
			//
			default:
			{
				hr = hTempResult;
				DPFX(DPFPREP,  0, "ParseClass: Problem parsing address!" );
				DisplayDNError( 0, hr );
				DNASSERT( FALSE );
				goto Exit;

				break;
			}
		}
	}

Exit:
	if ( pAddressComponent != NULL )
	{
		DNFree( pAddressComponent );
		pAddressComponent = NULL;
	}

	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\parseclass.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ParseClass.h
 *  Content:	Class to perform parsing
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/02/99	jtk		Derived from IPXEndpt.h
 ***************************************************************************/

#ifndef __PARSE_CLASS_H__
#define __PARSE_CLASS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// function prototype for parse callback
//
typedef	HRESULT	(*PPARSE_CALLBACK)( const void *const pAddressComponent,
									const DWORD dwComponentLength,
									const DWORD dwComponentType,
									void *const pContext );

//
// structure for parse key
//
typedef	struct	_PARSE_KEY
{
	const WCHAR	*pKey;			// key name
	UINT_PTR	uKeyLength;		// length of key (without NULL!)
	void 		*pContext;		// pointer to callback context
	PPARSE_CALLBACK	pParseFunc;	// callback when this key is encountered
} PARSE_KEY, *PPARSE_KEY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
class	CParseClass
{
	public:
		CParseClass(){}
		~CParseClass(){}

		static HRESULT	ParseDP8Address( IDirectPlay8Address *const pDNAddress,
								 const GUID *const pSPGuid,
								 const PARSE_KEY *const pParseKeys,
								 const UINT_PTR uParseKeyCount );
	protected:

	private:
		//
		// prevent unwarranted copies
		//
		CParseClass( const CParseClass & );
		CParseClass& operator=( const CParseClass & );
};


#endif	// __PARSE_CLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\modemui.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemUI.h
 *  Content:	Modem service provider UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/25/99	jtk		Created
 ***************************************************************************/

#ifndef __MODEM_UI_H__
#define __MODEM_UI_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
void	DisplayIncomingModemSettingsDialog( void *const pContext );
void	DisplayOutgoingModemSettingsDialog( void *const pContext );
void	StopModemSettingsDialog( const HWND hDialog );

HRESULT	DisplayModemStatusDialog( void *const pContext );
void	StopModemStatusDialog( const HWND hDialog );

#endif	// __MODEM_UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\serialsp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SerialSP.h
 *  Content:	Service provider interface functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/09/98	jtk		Derived from SerialUtil.h
 *	09/23/99	jtk		Derived from SerialCore.h
 ***************************************************************************/

#ifndef __SERIAL_SP_H__
#define __SERIAL_SP_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//
// including a header file in another header isn't that good, but it's the easiest thing
// to do right now since #defines need to be set first.
//
#define		MAX_TAPI_VERSION	0x00020000
#define		TAPI_CURRENT_VERSION	MAX_TAPI_VERSION
#include	<tapi.h>

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum number of data ports
//
#define	MAX_DATA_PORTS	128

//
// enumeration of types of SP
//
typedef enum
{
	TYPE_UNKNOWN,		// unknown type
	TYPE_MODEM,			// modem type
	TYPE_SERIAL			// serial type

} SP_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CModemSPData;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

STDAPI DNMODEMSP_Initialize(IDP8ServiceProvider*, PSPINITIALIZEDATA);
STDMETHODIMP_(ULONG) DNMODEMSP_AddRef( IDP8ServiceProvider* lpDNSP );
STDMETHODIMP_(ULONG) DNMODEMSP_Release(IDP8ServiceProvider* lpDNSP);
STDMETHODIMP DNMODEMSP_Connect(IDP8ServiceProvider*, PSPCONNECTDATA);
STDMETHODIMP DNMODEMSP_Disconnect(IDP8ServiceProvider*, PSPDISCONNECTDATA);
STDMETHODIMP DNMODEMSP_Listen(IDP8ServiceProvider*, PSPLISTENDATA);
STDMETHODIMP DNMODEMSP_EnumQuery(IDP8ServiceProvider*, PSPENUMQUERYDATA);
STDMETHODIMP DNMODEMSP_EnumRespond(IDP8ServiceProvider*, PSPENUMRESPONDDATA);
STDMETHODIMP DNMODEMSP_SendData(IDP8ServiceProvider*, PSPSENDDATA);
STDMETHODIMP DNMODEMSP_CancelCommand(IDP8ServiceProvider*, HANDLE, DWORD);
STDMETHODIMP DNMODEMSP_Close(IDP8ServiceProvider*);
STDMETHODIMP DNMODEMSP_GetCaps(IDP8ServiceProvider*, PSPGETCAPSDATA);
STDMETHODIMP DNMODEMSP_SetCaps(IDP8ServiceProvider*, PSPSETCAPSDATA);
STDMETHODIMP DNMODEMSP_ReturnReceiveBuffers(IDP8ServiceProvider*, SPRECEIVEDBUFFER* );
STDMETHODIMP DNMODEMSP_GetAddressInfo(IDP8ServiceProvider*, SPGETADDRESSINFODATA* );
STDMETHODIMP DNMODEMSP_IsApplicationSupported(IDP8ServiceProvider*, SPISAPPLICATIONSUPPORTEDDATA* );
STDMETHODIMP DNMODEMSP_EnumAdapters(IDP8ServiceProvider*, SPENUMADAPTERSDATA* );

STDMETHODIMP DNMODEMSP_NotSupported( IDP8ServiceProvider*, PVOID );

#endif	// __SERIAL_SP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\sources.inc ===
TARGETNAME=dpnmodem
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnmdmi.h
PRECOMPILED_PCH=dnmdmi.pch
PRECOMPILED_OBJ=dnmdmi.obj

INCLUDES=..\;..\..\..\inc;..\..\..\common;..\..\..\core;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=dpnmodemclassfac.cpp \
	CommandData.cpp \
	ComPortData.cpp \
	ComportUI.cpp \
	CRC.cpp \
	DataPort.cpp \
	dpnmodemendpoint.cpp \
	dpnmodemiodata.cpp \
	dpnmodemjobqueue.cpp \
	dpnmodemlocals.cpp \
	ModemUI.cpp \
	ParseClass.cpp \
	dpnmodempools.cpp \
	dpnmodemsendqueue.cpp \
	SerialSP.cpp \
	dpnmodemspdata.cpp \
	dpnmodemthreadpool.cpp \
	dpnmodemunk.cpp \
	dpnmodemutils.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\adapterentry.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AdapterEntry.cpp
 *  Content:	Structure used in the list of active sockets
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/07/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "dnwsocki.h"


#ifndef DPNBUILD_ONLYONEADAPTER


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolAllocFunction
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolAllocFunction"
BOOL	CAdapterEntry::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CAdapterEntry* pAdapterEntry = (CAdapterEntry*)pvItem;

	pAdapterEntry->m_lRefCount = 0;
	pAdapterEntry->m_AdapterListLinkage.Initialize();
	pAdapterEntry->m_ActiveSocketPorts.Initialize();
	memset( &pAdapterEntry->m_BaseSocketAddress, 0x00, sizeof( pAdapterEntry->m_BaseSocketAddress ) );

	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolInitFunction - called when item is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolInitFunction"

void	CAdapterEntry::PoolInitFunction( void* pvItem, void* pvContext )
{
	CAdapterEntry* pAdapterEntry = (CAdapterEntry*)pvItem;

	DNASSERT( pAdapterEntry->m_AdapterListLinkage.IsEmpty() );
	DNASSERT( pAdapterEntry->m_ActiveSocketPorts.IsEmpty() );
	DNASSERT( pAdapterEntry->m_lRefCount == 0 );

	pAdapterEntry->m_lRefCount = 1;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolReleaseFunction - called when item is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolReleaseFunction"

void	CAdapterEntry::PoolReleaseFunction( void* pvItem )
{
	CAdapterEntry* pAdapterEntry = (CAdapterEntry*)pvItem;

	//
	// No more references, time to remove self from list.
	// This assumes the SPData socketportdata lock is held.
	//
	pAdapterEntry->m_AdapterListLinkage.RemoveFromList();

	DNASSERT( pAdapterEntry->m_AdapterListLinkage.IsEmpty() );
	DNASSERT( pAdapterEntry->m_ActiveSocketPorts.IsEmpty() );
	DNASSERT( pAdapterEntry->m_lRefCount == 0 );
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolDeallocFunction
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolDeallocFunction"
void	CAdapterEntry::PoolDeallocFunction( void* pvItem )
{
	const CAdapterEntry* pAdapterEntry = (CAdapterEntry*)pvItem;

	DNASSERT( pAdapterEntry->m_AdapterListLinkage.IsEmpty() );
	DNASSERT( pAdapterEntry->m_ActiveSocketPorts.IsEmpty() );
	DNASSERT( pAdapterEntry->m_lRefCount == 0 );
}
//**********************************************************************



#ifdef DBG

//**********************************************************************
// ------------------------------
// CAdapterEntry::DebugPrintOutstandingSocketPorts - print out all the outstanding socket ports for this adapter
//
// Entry:		None
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CAdapterEntry::DebugPrintOutstandingSocketPorts"

void	CAdapterEntry::DebugPrintOutstandingSocketPorts( void )
{
	CBilink *		pBilink;
	CSocketPort *	pSocketPort;


	DPFX(DPFPREP, 4, "Adapter entry 0x%p outstanding socket ports:", this);

	//
	// Find the base adapter entry for this network address.  If none is found,
	// create a new one.  If a new one cannot be created, fail.
	//
	pBilink = this->m_ActiveSocketPorts.GetNext();
	while (pBilink != &m_ActiveSocketPorts)
	{
		pSocketPort = CSocketPort::SocketPortFromBilink(pBilink);
		DPFX(DPFPREP, 4, "     Socketport 0x%p", pSocketPort);
		pBilink = pBilink->GetNext();
	}
}
//**********************************************************************


#endif // ! DPNBUILD_ONLYONEADAPTER

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\serial\serialsp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SerialSP.cpp
 *  Content:	Service provider serial interface functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/03/98	jtk		Created
 *	09/23/99	jtk		Derived from ComCore.cpp
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_AddRef - increment interface reference cound
//
// Entry:		Pointer to interface
//
// Exit:		Current interface reference count
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_AddRef"

STDMETHODIMP_(ULONG) DNMODEMSP_AddRef( IDP8ServiceProvider *pThis )
{
	CModemSPData *	pSPData;
	ULONG		ulResult;


	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->AddRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);
	
	return ulResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_Release - release an interface
//
// Entry:		Pointer to current interface
//				Desired interface ID
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_Release"

STDMETHODIMP_(ULONG) DNMODEMSP_Release( IDP8ServiceProvider *pThis )
{
	CModemSPData *	pSPData;
	ULONG		ulResult;

	
	DNASSERT( pThis != NULL );
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->DecRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);
	
	return ulResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_Initialize - initialize SP interface
//
// Entry:	Pointer to interface
//			Pointer to initialization data
//
// Exit:	Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_Initialize"

STDMETHODIMP	DNMODEMSP_Initialize( IDP8ServiceProvider *pThis, SPINITIALIZEDATA *pData )
{
	HRESULT				hr;
	CModemSPData				*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pData);

	DNASSERT( pThis != NULL );
	DNASSERT( pData != NULL );

	
	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );

	//
	// prevent anyone else from messing with this interface and bump up the reference
	// count
	//
	pSPData->Lock();

	//
	// check interface state
	//
	switch ( pSPData->GetState() )
	{
		//
		// uninitialized interface, we can initialize it
		//
		case SPSTATE_UNINITIALIZED:
		{
			break;
		}

		//
		// other state
		//
		case SPSTATE_INITIALIZED:
		case SPSTATE_CLOSING:
		default:
		{
			hr = DPNERR_ALREADYINITIALIZED;
			DPFX(DPFPREP,  0, "Attempted to reinitialize interface!" );
			DNASSERT( FALSE );

			goto Exit;
		}
	}

	//
	// before we get too far, check for the availablility of serial ports or
	// modems
	//
	switch ( pSPData->GetType() )
	{
		case TYPE_SERIAL:
		{
			BOOL	fPortAvailable[ MAX_DATA_PORTS ];
			DWORD	dwPortCount;


			hr = GenerateAvailableComPortList( fPortAvailable, ( LENGTHOF( fPortAvailable ) - 1 ), &dwPortCount );
			if ( ( hr != DPN_OK ) || ( dwPortCount == 0 ) )
			{
				hr = DPNERR_UNSUPPORTED;
				goto Failure;
			}

			break;
		}

		case TYPE_MODEM:
		{
			if ( pSPData->GetThreadPool()->TAPIAvailable() != FALSE )
			{
				DWORD	dwModemCount;
				DWORD	dwModemNameDataSize;
				HRESULT	hTempResult;


				//
				// Get count of available modems.  If this call succeeds but there
				// are no modems returned, fail.
				//
				dwModemCount = 0;
				dwModemNameDataSize = 0;
				hTempResult = GenerateAvailableModemList( pSPData->GetThreadPool()->GetTAPIInfo(),
														  &dwModemCount,
														  NULL,
														  &dwModemNameDataSize );
				if ( ( hTempResult != DPNERR_BUFFERTOOSMALL ) && ( hTempResult != DPN_OK ) )
				{
					hr = hTempResult;
					DPFX(DPFPREP,  0, "Failed to detect available modems!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}

				if ( dwModemCount == 0 )
				{
					DPFX(DPFPREP,  1, "No modems detected!" );
					hr = DPNERR_UNSUPPORTED;
					goto Failure;
				}

				DNASSERT( hr == DPN_OK );
			}
			else
			{
				DPFX(DPFPREP,  0, "TAPI not available!" );
				hr = DPNERR_UNSUPPORTED;
				goto Failure;
			}

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// remember the init data
	//
	pSPData->SetCallbackData( pData );
		
	//
	// Success from here on in
	//
	IDP8SPCallback_AddRef( pSPData->DP8SPCallbackInterface() );
	pSPData->SetState( SPSTATE_INITIALIZED );
	pSPData->Unlock();
	
	IDP8ServiceProvider_AddRef( pThis );

Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	pSPData->Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_Close - close this instance of the service provier
//
// Entry:		Pointer to the service provider to close
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_Close"

STDMETHODIMP	DNMODEMSP_Close( IDP8ServiceProvider *pThis )
{
	HRESULT		hr;
	CModemSPData		*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	
	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );

	switch ( pSPData->GetType() )
	{
		case TYPE_SERIAL:
		case TYPE_MODEM:
		{
			//
			// release our ref to the DPlay callbacks
			//
			pSPData->Shutdown();
			IDP8ServiceProvider_Release( pThis );
			
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_Connect - start process to establish comport connection to a remote host
//
// Entry:		Pointer to the service provider interface
//				Pointer to connection data
//
// Exit:		Error Code
//
// Note:	Any command handle allocated by this function is closed by the
//			endpoint.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_Connect"

STDMETHODIMP	DNMODEMSP_Connect( IDP8ServiceProvider *pThis, SPCONNECTDATA *pConnectData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CModemSPData			*pSPData;
	CModemEndpoint   	*pEndpoint;
	CModemCommandData	*pCommand;
	BOOL			fEndpointOpen;
	GUID			DeviceGUID;
	GUID			guidnull;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pConnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->pAddressHost != NULL );
	DNASSERT( pConnectData->pAddressDeviceInfo != NULL );
	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOQUERY ) ) == 0 );
	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOQUERY ) ) == 0 );


	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pConnectData->hCommand = NULL;
	pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	memset(&guidnull, 0, sizeof(guidnull));


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}

	
	//
	// validate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "DNMODEMSP_Connect called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "DNMODEMSP_Connect called while SP closing!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}

	//
	// check for invalid device ID
	//
	hTempResult = IDirectPlay8Address_GetDevice( pConnectData->pAddressDeviceInfo, &DeviceGUID );
	switch ( hTempResult )
	{
	    //
	    // there was a device ID, check against GUID_NULL
	    //
	    case DPN_OK:
	    {
	    	if ( IsEqualCLSID( DeviceGUID, guidnull ) != FALSE )
	    	{
	    		hr = DPNERR_ADDRESSING;
	    		DPFX(DPFPREP,  0, "GUID_NULL was specified as a serial/modem device!" );
	    		goto Failure;
	    	}
	    	break;
	    }

	    //
	    // no device address specified, not a problem
	    //
	    case DPNERR_DOESNOTEXIST:
	    {
	    	break;
	    }

	    //
	    // other, stop and figure out why we're here
	    //
	    default:
	    {
			DNASSERT( FALSE );
	    	hr = hTempResult;
	    	DPFX(DPFPREP,  0, "Failed to validate device address!" );
	    	DisplayDNError( 0, hTempResult );
	    	break;
	    }
	}

	//
	// get endpoint for this connection
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNMODEMSP_Connect: Cannot create new endpoint!" );
		goto Failure;
	}

	//
	// get new command
	//
	pCommand = (CModemCommandData*)g_ModemCommandDataPool.Get();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNMODEMSP_Connect: Cannot get command handle!" );
		goto Failure;
	}

	//
	// initialize command
	//
	pConnectData->hCommand = pCommand;
	pConnectData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_CONNECT );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open this endpoint
	//
	hTempResult = pEndpoint->Open( pConnectData->pAddressHost,
								   pConnectData->pAddressDeviceInfo,
								   LINK_DIRECTION_OUTGOING,
								   ENDPOINT_TYPE_CONNECT );
	switch ( hTempResult )
	{
		//
		// endpoint opened, no problem
		//
		case DPN_OK:
		{
			//
			// copy connect data and the submit background job
			//
			fEndpointOpen = TRUE;
			pEndpoint->CopyConnectData( pConnectData );
			pEndpoint->AddRef();

			hTempResult = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ConnectJobCallback,
																		  pEndpoint->CancelConnectJobCallback,
																		  pEndpoint );
			if ( hTempResult != DPN_OK )
			{
				pEndpoint->DecRef();
				hr = hTempResult;
				DPFX(DPFPREP,  0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// not all of the addressing information was specifed, need to query user
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
#ifndef DPNBUILD_NOSPUI
			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// copy connect data for future reference and then start the dialog
				//
				fEndpointOpen = TRUE;
				pEndpoint->CopyConnectData( pConnectData );

				hTempResult = pEndpoint->ShowOutgoingSettingsDialog( pSPData->GetThreadPool() );
				if ( hTempResult != DPN_OK )
				 {
					hr = hTempResult;
					DPFX(DPFPREP,  0, "DNMODEMSP_Connect: Problem showing settings dialog!" );
					DisplayDNError( 0, hTempResult );

					goto Failure;
				 }

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				DNASSERT( hr == DPNERR_PENDING );

				goto Exit;
			}
			else
#endif // !DPNBUILD_NOSPUI
			{
				hr = hTempResult;
				goto Failure;
			}

			break;
		}

		default:
		{
			hr = hTempResult;
			DPFX(DPFPREP,  0, "DNMODEMSP_Connect: Problem opening endpoint with host address!" );
			DisplayDNError( 0, hTempResult );
			goto Failure;

			break;
		}
	}
Exit:
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP,  0, "Problem with DNMODEMSP_Connect()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	//
	// return any outstanding endpoint
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			DNASSERT( ( hr != DPN_OK ) && ( hr != DPNERR_PENDING ) );
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// return any outstanding command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;
		pConnectData->hCommand = NULL;
		pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_Disconnect - disconnect from a remote host
//
// Entry:		Pointer to the service provider interface
//				Pointer to connection data
//
// Exit:		Error Code
//
// Note:	This command is considered final, there's no chance to cancel a
//			disconnect.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_Disconnect"

STDMETHODIMP	DNMODEMSP_Disconnect( IDP8ServiceProvider *pThis, SPDISCONNECTDATA *pDisconnectData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CModemEndpoint   	*pEndpoint;
	CModemSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pDisconnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pDisconnectData != NULL );
	DNASSERT( pDisconnectData->hEndpoint != INVALID_HANDLE_VALUE && pDisconnectData->hEndpoint != 0 );
	DNASSERT( pDisconnectData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;
	pDisconnectData->hCommand = NULL;
	pDisconnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );

	//
	// check service provider state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "Disconnect called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "Disconnect called on closing SP!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// look up the endpoint and if it's found, close its handle
	//
	pEndpoint = pSPData->GetEndpointAndCloseHandle( (DPNHANDLE)(DWORD_PTR)pDisconnectData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		goto Failure;
	}
	
	hTempResult = pEndpoint->Disconnect( (DPNHANDLE)(DWORD_PTR)pDisconnectData->hEndpoint );
	switch ( hTempResult )
	{
		//
		// endpoint disconnected immediately
		//
		case DPN_OK:
		{
			break;
		}

		//
		// Other return.  Since the disconnect didn't complete, we need
		// to unlock the endpoint.
		//
		default:
		{
			DPFX(DPFPREP,  0, "Error reported when attempting to disconnect endpoint in DNMODEMSP_Disconnect!" );
			DisplayDNError( 0, hTempResult );

			break;
		}
	}

Exit:
	//
	// remove oustanding reference from GetEndpointHandleAndClose()
	//
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with DNMODEMSP_Disconnect()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_Listen - start process to listen for comport connections
//
// Entry:		Pointer to the service provider interface
//				Pointer to listen data
//
// Exit:		Error Code
//
// Note:	Any command handle allocated by this function is closed by the
//			endpoint.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_Listen"

STDMETHODIMP	DNMODEMSP_Listen( IDP8ServiceProvider *pThis, SPLISTENDATA *pListenData )
{
	HRESULT				hr;
	HRESULT				hTempResult;
	CModemSPData		*pSPData;
	CModemEndpoint   	*pEndpoint;
	CModemCommandData	*pCommand;
	BOOL				fEndpointOpen;
	BOOL				fInterfaceReferenceAdded;
	GUID				DeviceGUID;
	GUID				guidnull;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pListenData);

	DNASSERT( pThis != NULL );
	DNASSERT( pListenData != NULL );
	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOQUERY | DPNSPF_BINDLISTENTOGATEWAY | DPNSPF_LISTEN_DISALLOWENUMS ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pListenData->hCommand = NULL;
	pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	fInterfaceReferenceAdded = FALSE;
	memset(&guidnull, 0, sizeof(guidnull));


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	//
	// validate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPNERR_PENDING );
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;

			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "DNMODEMSP_Listen called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "DNMODEMSP_Listen called while SP closing!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}

	//
	// check for invalid device ID
	//
	hTempResult = IDirectPlay8Address_GetDevice( pListenData->pAddressDeviceInfo, &DeviceGUID );
	switch ( hTempResult )
	{
		//
		// there was a device ID, check against GUID_NULL
		//
		case DPN_OK:
		{
			if ( IsEqualCLSID( DeviceGUID, guidnull ) != FALSE )
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "GUID_NULL was specified as a serial/modem device!" );
				goto Failure;
			}
			break;
		}

		//
		// no device address specified, not a problem
		//
		case DPNERR_DOESNOTEXIST:
		{
			break;
		}

		//
		// other, stop and figure out why we're here
		//
		default:
		{
			DNASSERT( FALSE );
			hr = hTempResult;
			DPFX(DPFPREP,  0, "Failed to validate device address!" );
			DisplayDNError( 0, hTempResult );
			break;
		}
	}

	//
	// get endpoint for this connection
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNMODEMSP_Listen: Cannot create new endpoint!" );
		goto Failure;
	}

	//
	// get new command
	//
	pCommand = (CModemCommandData*)g_ModemCommandDataPool.Get();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNMODEMSP_Listen: Cannot get command handle!" );
		goto Failure;
	}

	//
	// initialize command
	//
	pListenData->hCommand = pCommand;
	pListenData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_LISTEN );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open this endpoint
	//
	hTempResult = pEndpoint->Open( NULL,
								   pListenData->pAddressDeviceInfo,
								   LINK_DIRECTION_INCOMING,
								   ENDPOINT_TYPE_LISTEN );
	switch ( hTempResult )
	{
		//
		// address conversion was fine, complete this command in the background
		//
		case DPN_OK:
		{
			//
			// copy connect data and the submit background job
			//
			fEndpointOpen = TRUE;
			pEndpoint->CopyListenData( pListenData );
			pEndpoint->AddRef();

			hTempResult = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ListenJobCallback,
																		  pEndpoint->CancelListenJobCallback,
																		  pEndpoint );
			if ( hTempResult != DPN_OK )
			{
				pEndpoint->DecRef();
				hr = hTempResult;
				DPFX(DPFPREP,  0, "DNMODEMSP_Listen: Failed to submit delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// address was incomplete, display a dialog if we can, otherwise fail the command
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// copy connect data for future reference and then start the dialog
				//
				fEndpointOpen = TRUE;
				pEndpoint->CopyListenData( pListenData );

				hTempResult = pEndpoint->ShowIncomingSettingsDialog( pSPData->GetThreadPool() );
				if ( hTempResult != DPN_OK )
				{
					hr = hTempResult;
					DPFX(DPFPREP,  0, "Problem showing settings dialog in DNMODEMSP_Listen!" );
					DisplayDNError( 0, hTempResult );

					goto Failure;
				 }

				//
				// This endpoint has been handed off, clear the pointer to it.
				// There is no reference to remove because the command is
				// still pending.
				//
				pEndpoint = NULL;
				DNASSERT( hr == DPNERR_PENDING );

				goto Exit;
			}
			else
			{
				hr = hTempResult;
				goto Failure;
			}

			break;
		}

		default:
		{
			hr = hTempResult;
			DPFX(DPFPREP,  0, "Problem initializing endpoint in DNMODEMSP_Listen!" );
			DisplayDNError( 0, hTempResult );
			goto Failure;

			break;
		}
	}

Exit:
	DNASSERT( pEndpoint == NULL );	
	
	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP,  0, "Problem with DNMODEMSP_Listen()" );
		DisplayDNError( 0, hr );
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// return any outstanding endpoint
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			DNASSERT( ( hr != DPN_OK ) && ( hr != DPNERR_PENDING ) );
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// return any outstanding command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pListenData->hCommand = NULL;
		pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_EnumQuery - start process to enum comport connections
//
// Entry:		Pointer to the service provider interface
//				Pointer to enum data
//
// Exit:		Error Code
//
// Note:	Any command handle allocated by this function is closed by the
//			endpoint.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_EnumQuery"

STDMETHODIMP	DNMODEMSP_EnumQuery( IDP8ServiceProvider *pThis, SPENUMQUERYDATA *pEnumQueryData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CModemSPData			*pSPData;
	CModemEndpoint   	*pEndpoint;
	CModemCommandData	*pCommand;
	BOOL			fEndpointOpen;
	GUID			DeviceGUID;
	GUID			guidnull;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOQUERY ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pEnumQueryData->hCommand = NULL;
	pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;
	memset(&guidnull, 0, sizeof(guidnull));


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	//
	// validate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery called while SP closing!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}

	//
	// check for invalid device ID
	//
	hTempResult = IDirectPlay8Address_GetDevice( pEnumQueryData->pAddressDeviceInfo, &DeviceGUID );
	switch ( hTempResult )
	{
		//
		// there was a device ID, check against GUID_NULL
		//
		case DPN_OK:
		{
			if ( IsEqualCLSID( DeviceGUID, guidnull ) != FALSE )
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "GUID_NULL was specified as a serial/modem device!" );
				goto Failure;
			}
			break;
		}

		//
		// no device address specified, not a problem
		//
		case DPNERR_DOESNOTEXIST:
		{
			break;
		}

		//
		// other, stop and figure out why we're here
		//
		default:
		{
			DNASSERT( FALSE );
			hr = hTempResult;
			DPFX(DPFPREP,  0, "Failed to validate device address!" );
			DisplayDNError( 0, hTempResult );
			break;
		}
	}

	//
	// get endpoint for this connection
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery: Cannot create new endpoint!" );
		goto Failure;
	}

	//
	// get new command
	//
	pCommand = (CModemCommandData*)g_ModemCommandDataPool.Get();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery: Cannot get command handle!" );
		goto Failure;
	}

	//
	// initialize command
	//
	pEnumQueryData->hCommand = pCommand;
	pEnumQueryData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_ENUM_QUERY );
	pCommand->SetState( COMMAND_STATE_INPROGRESS );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open this endpoint
	//
	hTempResult = pEndpoint->Open( pEnumQueryData->pAddressHost,
								   pEnumQueryData->pAddressDeviceInfo,
								   LINK_DIRECTION_OUTGOING,
								   ENDPOINT_TYPE_ENUM );
	switch ( hTempResult )
	{
		//
		// address was incomplete, display a dialog if we can, otherwise fail the command
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
#ifndef DPNBUILD_NOSPUI
			if ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// copy connect data for future reference and then start the dialog
				//
				fEndpointOpen = TRUE;
				pEndpoint->CopyEnumQueryData( pEnumQueryData );
	
				hTempResult = pEndpoint->ShowOutgoingSettingsDialog( pSPData->GetThreadPool() );
				if ( hTempResult != DPN_OK )
				 {
					hr = hTempResult;
					DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery: Problem showing settings dialog!" );
					DisplayDNError( 0, hTempResult );
	
					goto Failure;
				 }
	
				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				DNASSERT( hr == DPNERR_PENDING );
	
				goto Exit;
			}
			else
#endif // !DPNBUILD_NOSPUI
			{
				hr = hTempResult;
				goto Failure;
			}
	
			break;
		}
	
		//
		// address conversion was fine, complete this command in the background
		//
		case DPN_OK:
		{
			//
			// copy connect data and the submit background job
			//
			fEndpointOpen = TRUE;
			pEndpoint->CopyEnumQueryData( pEnumQueryData );
			pEndpoint->AddRef();

			hTempResult = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->EnumQueryJobCallback,
																		  pEndpoint->CancelEnumQueryJobCallback,
																		  pEndpoint );
			if ( hTempResult != DPN_OK )
			{
				pEndpoint->DecRef();
				hr = hTempResult;
				DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery: Failed to submit delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		default:
		{
			hr = hTempResult;
			DPFX(DPFPREP,  0, "DNMODEMSP_EnumQuery: Problem initializing endpoint!" );
			DisplayDNError( 0, hTempResult );
			goto Failure;

			break;
		}
	}

Exit:
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		DPFX(DPFPREP,  0, "Problem with DNMODEMSP_EnumQuery" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			DNASSERT( ( hr != DPN_OK ) && ( hr != DPNERR_PENDING ) );
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		DNASSERT( FALSE );
		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// return any outstanding command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pEnumQueryData->hCommand = NULL;
		pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNMODEMSP_SendData sends data to the specified "player"
 *
 *	This call MUST BE HIGHLY OPTIMIZED
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_SendData"

STDMETHODIMP DNMODEMSP_SendData( IDP8ServiceProvider *pThis, SPSENDDATA *pSendData )
{
	HRESULT			hr;
	CModemEndpoint		*pEndpoint;
	CModemWriteIOData	*pWriteData;
	CModemSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pSendData);

	DNASSERT( pThis != NULL );
	DNASSERT( pSendData != NULL );
	DNASSERT( pSendData->pBuffers != NULL );
	DNASSERT( pSendData->dwBufferCount != 0 );
	DNASSERT( pSendData->hEndpoint != INVALID_HANDLE_VALUE && pSendData->hEndpoint != 0 );
	DNASSERT( pSendData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pSendData->hCommand = NULL;
	pSendData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pWriteData = NULL;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );

	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// No need to lock down the thread counts here because the user already has
	// a connect or something running or they wouldn't be calling this function.
	// That outstanding connect would have locked down the thread pool.
	//

	//
	// Attempt to grab the endpoint from the handle.  If this succeeds, the
	// endpoint can send.
	//
	pEndpoint = pSPData->EndpointFromHandle( (DPNHANDLE)(DWORD_PTR)pSendData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDHANDLE;
		DPFX(DPFPREP,  0, "Invalid endpoint handle on send!" );
		goto Failure;
	}
	
	//
	// send data from pool
	//
	pWriteData = pSPData->GetThreadPool()->CreateWriteIOData();
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot get new write data from pool in SendData!" );
		goto Failure;
	}
	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->DataPort() == NULL );

	//
	// set the command state and fill in the message information
	//
	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pSendData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	DNASSERT( pSendData->dwBufferCount != 0 );
	pWriteData->m_uBufferCount = pSendData->dwBufferCount;
	pWriteData->m_pBuffers = pSendData->pBuffers;

	pSendData->hCommand = pWriteData->m_pCommand;
	pSendData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data through the endpoint
	//
	pEndpoint->SendUserData( pWriteData );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );
		DEBUG_ONLY( pWriteData = NULL );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_CancelCommand - cancels a command in progress
//
// Entry:		Pointer to the service provider interface
//				Handle of command
//				Command descriptor
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_CancelCommand"

STDMETHODIMP DNMODEMSP_CancelCommand( IDP8ServiceProvider *pThis, HANDLE hCommand, DWORD dwCommandDescriptor )
{
	HRESULT			hr;
	CModemSPData			*pSPData;
	CModemCommandData	*pCommandData;
	BOOL			fReferenceAdded;
	BOOL			fCommandLocked;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p, %ld)", pThis, hCommand, dwCommandDescriptor);

	DNASSERT( pThis != NULL );
	DNASSERT( hCommand != NULL );
	DNASSERT( dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	pCommandData = NULL;
	fReferenceAdded = FALSE;
	fCommandLocked = FALSE;
	
	//
	// vlidate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPN_OK );
			IDP8ServiceProvider_AddRef( pThis );
			fReferenceAdded = TRUE;
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "Disconnect called on uninitialized SP!" );
			DNASSERT( FALSE );
			goto Exit;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "Disconnect called on closing SP!" );
			DNASSERT( FALSE );
			goto Exit;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Exit;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Exit;
	}

	pCommandData = static_cast<CModemCommandData*>( hCommand );
	pCommandData->Lock();
	fCommandLocked = TRUE;

	//
	// this should never happen
	//
	if ( pCommandData->GetDescriptor() != dwCommandDescriptor )
	{
		hr = DPNERR_INVALIDCOMMAND;
		DPFX(DPFPREP,  0, "Attempt to cancel command with mismatched command descriptor!" );
		goto Exit;
	}

	switch ( pCommandData->GetState() )
	{
		//
		// unknown command state
		//
		case COMMAND_STATE_UNKNOWN:
		{
			hr = DPNERR_INVALIDCOMMAND;
			DNASSERT( FALSE );
			break;
		}

		//
		// command is waiting to be processed, set command state to be cancelling
		// and wait for someone to pick it up
		//
		case COMMAND_STATE_PENDING:
		{
			pCommandData->SetState( COMMAND_STATE_CANCELLING );
			break;
		}

		//
		// command in progress, and can't be cancelled
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			hr = DPNERR_CANNOTCANCEL;
			break;
		}

		//
		// Command is already being cancelled.  This is not a problem, but shouldn't
		// be happening.
		//
		case COMMAND_STATE_CANCELLING:
		{
			DNASSERT( hr == DPN_OK );
			DNASSERT( FALSE );
			break;
		}

		//
		// command is in progress, find out what type of command it is
		//
		case COMMAND_STATE_INPROGRESS:
		{
			switch ( pCommandData->GetType() )
			{
				case COMMAND_TYPE_UNKNOWN:
				{
					// we should never be in this state!
					DNASSERT( FALSE );
					break;
				}

				case COMMAND_TYPE_CONNECT:
				{
					// we should never be in this state!
					DNASSERT( FALSE );
					break;
				}

				case COMMAND_TYPE_LISTEN:
				{
					CModemEndpoint	*pEndpoint;


					//
					// set this command to the cancel state before we shut down
					// this endpoint
					//
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					fCommandLocked = FALSE;

					pEndpoint = pCommandData->GetEndpoint();
					pEndpoint->Lock();
					switch ( pEndpoint->GetState() )
					{
						//
						// endpoint is already disconnecting, no action needs to be taken
						//
						case ENDPOINT_STATE_DISCONNECTING:
						{
							pEndpoint->Unlock();
							goto Exit;
							break;
						}

						//
						// Endpoint is listening.  Flag it as Disconnecting and
						// add a reference so it doesn't disappear on us
						//
						case ENDPOINT_STATE_LISTENING:
						{
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							pEndpoint->AddRef();
							break;
						}

						//
						// other state
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					pEndpoint->Unlock();
					
					pEndpoint->Close( DPNERR_USERCANCEL );
					pSPData->CloseEndpointHandle( pEndpoint );
					
					pEndpoint->DecRef();

					break;
				}

				//
				// Note: this code is duplicated in CModemEndpoint::ProcessTAPIMessage
				//
				case COMMAND_TYPE_ENUM_QUERY:
				{
					CModemEndpoint	 *pEndpoint;


					pEndpoint = pCommandData->GetEndpoint();
					DNASSERT( pEndpoint != NULL );

					pEndpoint->AddRef();
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					
					fCommandLocked = FALSE;

					pEndpoint->Lock();
					pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
					pEndpoint->Unlock();

					pEndpoint->StopEnumCommand( DPNERR_USERCANCEL );
					pEndpoint->DecRef();
					
					break;
				}

				case COMMAND_TYPE_SEND:
				{
					// we should never be here
					DNASSERT( FALSE );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// other command state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	if ( fCommandLocked != FALSE )
	{
		DNASSERT( pCommandData != NULL );
		pCommandData->Unlock();
		fCommandLocked = FALSE;
	}

	if ( fReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fReferenceAdded = FALSE;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with DNMODEMSP_CancelCommand!" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_EnumRespond - send response to enumeration data
//
// Entry:		Pointer to the service provider interface
//				Pointer to enum response data
//
// Exit:		Error Code
//
// Note:	This command is supposed to be fast.  All initial error checking
//			will be ASSERTs so they go away in the retail build.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_EnumRespond"

STDMETHODIMP DNMODEMSP_EnumRespond( IDP8ServiceProvider *pThis, SPENUMRESPONDDATA *pEnumRespondData )
{
	HRESULT			hr;
	CModemEndpoint		*pEndpoint;
	CModemWriteIOData	*pWriteData;
	CModemSPData			*pSPData;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEnumQueryContext;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumRespondData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumRespondData != NULL );
	DNASSERT( pEnumRespondData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pWriteData = NULL;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );	
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEnumQueryContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pEnumRespondData->pQuery );

	pEnumRespondData->hCommand = NULL;
	pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );
	IDP8ServiceProvider_AddRef( pThis );

	//
	// check for valid endpoint
	//
	pEndpoint = pSPData->EndpointFromHandle( (DPNHANDLE)(DWORD_PTR)pEnumQueryContext->hEndpoint );
	if ( pEndpoint == NULL )
	{
		DNASSERT( FALSE );
		hr = DPNERR_INVALIDENDPOINT;
		DPFX(DPFPREP,  8, "Invalid endpoint handle in DNMODEMSP_EnumRespond" );
		goto Failure;
	}
	
	//
	// no need to poke at the thread pool here to lock down threads because we
	// can only really be here if there's an enum and that enum locked down the
	// thread pool.
	//
	pWriteData = pSPData->GetThreadPool()->CreateWriteIOData();
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot get new WRITE_IO_DATA for enum response!" );
		goto Failure;
	}

	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pEnumRespondData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	pWriteData->m_uBufferCount = pEnumRespondData->dwBufferCount;
	pWriteData->m_pBuffers = pEnumRespondData->pBuffers;

	pEnumRespondData->hCommand = pWriteData->m_pCommand;
	pEnumRespondData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data
	//
	pEndpoint->SendEnumResponseData( pWriteData, pEnumQueryContext->uEnumRTTIndex );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	
	IDP8ServiceProvider_Release( pThis );
	
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		DNASSERT( pSPData != NULL );
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );

		pEnumRespondData->hCommand = NULL;
		pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;

		pWriteData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_IsApplicationSupported - determine if this application is supported by this
//		SP.
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_IsApplicationSupported"

STDMETHODIMP	DNMODEMSP_IsApplicationSupported( IDP8ServiceProvider *pThis, SPISAPPLICATIONSUPPORTEDDATA *pIsApplicationSupportedData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CModemSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pIsApplicationSupportedData);

	DNASSERT( pThis != NULL );
	DNASSERT( pIsApplicationSupportedData != NULL );
	DNASSERT( pIsApplicationSupportedData->pApplicationGuid != NULL );
	DNASSERT( pIsApplicationSupportedData->dwFlags == 0 );

	//
	// initialize, we support all applications with this SP
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "IsApplicationSupported called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "IsApplicationSupported called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_GetCaps - get SP or endpoint capabilities
//
// Entry:		Pointer to DirectPlay
//				Pointer to caps data to fill
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_GetCaps"

STDMETHODIMP	DNMODEMSP_GetCaps( IDP8ServiceProvider *pThis, SPGETCAPSDATA *pCapsData )
{
	HRESULT		hr;
	LONG		iIOThreadCount;
	CModemSPData		*pSPData = NULL;

	
	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );
	DNASSERT( pCapsData->hEndpoint == INVALID_HANDLE_VALUE );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );

	//
	// there are no flags for this SP
	//
	pCapsData->dwFlags = 0;
	
	//
	// set frame sizes
	//
	pCapsData->dwUserFrameSize = MAX_USER_PAYLOAD;
	pCapsData->dwEnumFrameSize = 1000;

	//
	// get link speed
	//
	if ( pCapsData->hEndpoint != INVALID_HANDLE_VALUE )
	{
		// TODO: MASONB: I see no path where this is ever used
		CModemEndpoint	*pEndpoint;


		pEndpoint = pSPData->EndpointFromHandle( (DPNHANDLE)(DWORD_PTR)pCapsData->hEndpoint );
		if ( pEndpoint != NULL )
		{
			pCapsData->dwLocalLinkSpeed = pEndpoint->GetLinkSpeed();
			pEndpoint->DecCommandRef();
		}
		else
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPFX(DPFPREP,  0, "Invalid endpoint specified to GetCaps()" );
			goto Failure;
		}
	}
	else
	{
		pCapsData->dwLocalLinkSpeed = CBR_256000;
	}

	//
	// get IO thread count
	//
	hr = pSPData->GetThreadPool()->GetIOThreadCount( &iIOThreadCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "DNMODEMSP_GetCaps: Failed to get thread pool count!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	pCapsData->dwIOThreadCount = iIOThreadCount;

	//
	// set enumeration defaults
	//
	pCapsData->dwDefaultEnumRetryCount = DEFAULT_ENUM_RETRY_COUNT;
	pCapsData->dwDefaultEnumRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
	pCapsData->dwDefaultEnumTimeout = DEFAULT_ENUM_TIMEOUT;

	pCapsData->dwBuffersPerThread = 1;
	pCapsData->dwSystemBufferSize = 0;

Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_SetCaps - set SP capabilities
//
// Entry:		Pointer to DirectPlay
//				Pointer to caps data to use
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_SetCaps"

STDMETHODIMP	DNMODEMSP_SetCaps( IDP8ServiceProvider *pThis, SPSETCAPSDATA *pCapsData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CModemSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );


	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	
	//
	// validate caps
	//
	if ( pCapsData->dwBuffersPerThread == 0 )
	{
		DPFX(DPFPREP,  0, "Failing SetCaps because dwBuffersPerThread == 0" );
		hr = DPNERR_INVALIDPARAM;
		goto Failure;
	}
	

	//
	// change thread count, if requested
	//
	if (pCapsData->dwIOThreadCount != 0)
	{
		hr = pSPData->GetThreadPool()->SetIOThreadCount( pCapsData->dwIOThreadCount );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "DNMODEMSP_SetCaps: Failed to set thread pool count!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}


Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_ReturnReceiveBuffers - return receive buffers to pool
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_ReturnReceiveBuffers"

STDMETHODIMP	DNMODEMSP_ReturnReceiveBuffers( IDP8ServiceProvider *pThis, SPRECEIVEDBUFFER *pReceivedBuffers )
{
	SPRECEIVEDBUFFER	*pBuffers;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pReceivedBuffers);

	//
	// no need to tell thread pool to lock the thread count for this function.
	//
	DNASSERT( pThis != NULL );
	DNASSERT( pReceivedBuffers != NULL );

	pBuffers = pReceivedBuffers;
	while ( pBuffers != NULL )
	{
		SPRECEIVEDBUFFER	*pTemp;
		CModemReadIOData			*pReadData;


		pTemp = pBuffers;
		pBuffers = pBuffers->pNext;
		pReadData = CModemReadIOData::ReadDataFromSPReceivedBuffer( pTemp );
		pReadData->DecRef();
	}

	DPFX(DPFPREP, 2, "Returning: [DPN_OK]");

	return	DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_GetAddressInfo - get address information
//
// Entry:		Pointer to service provider interface
//				Pointer to get address data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_GetAddressInfo"

STDMETHODIMP	DNMODEMSP_GetAddressInfo( IDP8ServiceProvider *pThis, SPGETADDRESSINFODATA *pGetAddressInfoData )
{
	HRESULT	hr;
	CModemSPData		*pSPData;
	CModemEndpoint	*pEndpoint;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pGetAddressInfoData);

	DNASSERT( pThis != NULL );
	DNASSERT( pGetAddressInfoData != NULL );
	DNASSERT( pGetAddressInfoData->hEndpoint != INVALID_HANDLE_VALUE && pGetAddressInfoData->hEndpoint != 0 );
	DNASSERT( ( pGetAddressInfoData->Flags & ~( SP_GET_ADDRESS_INFO_LOCAL_ADAPTER |
												SP_GET_ADDRESS_INFO_REMOTE_HOST |
												SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES |
												SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS ) ) == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	pGetAddressInfoData->pAddress = NULL;
	
	pEndpoint = pSPData->EndpointFromHandle( (DPNHANDLE)(DWORD_PTR)pGetAddressInfoData->hEndpoint );
	if ( pEndpoint != NULL )
	{
		switch ( pGetAddressInfoData->Flags )
		{
			case SP_GET_ADDRESS_INFO_REMOTE_HOST:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetRemoteHostDP8Address();
				break;
			}

			//
			// there is no concept of a 'public' address for this service provider so
			// all local addresses are the same
			//
			case SP_GET_ADDRESS_INFO_LOCAL_ADAPTER:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS:
			case SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT );
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
		
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	else
	{
		hr = DPNERR_INVALIDENDPOINT;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem getting DP8Address from endpoint!" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMODEMSP_EnumAdapters - enumerate adapters for this SP
//
// Entry:		Pointer to service provider interface
//				Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMODEMSP_EnumAdapters"

STDMETHODIMP	DNMODEMSP_EnumAdapters( IDP8ServiceProvider *pThis, SPENUMADAPTERSDATA *pEnumAdaptersData )
{
	HRESULT					hr;
	CDataPort				*pDataPort;
	DATA_PORT_POOL_CONTEXT	DataPortPoolContext;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumAdaptersData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumAdaptersData->dwFlags == 0 );
	DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) ||
			  ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );

	//
	// intialize
	//
	hr = DPN_OK;
	pDataPort = NULL;
	pEnumAdaptersData->dwAdapterCount = 0;

	DataPortPoolContext.pSPData = CModemSPData::SPDataFromCOMInterface( pThis );
	pDataPort = CreateDataPort( &DataPortPoolContext );
	if ( pDataPort == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Problem getting new dataport!" );
		goto Failure;
	}

	hr = pDataPort->EnumAdapters( pEnumAdaptersData );
	if ( hr != DPN_OK )
	{
		if (hr != DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP,  0, "Problem enumerating adapters!" );
			DisplayDNError( 0, hr );
		}
		else
		{
			DPFX(DPFPREP,  1, "Buffer too small to enumerate adapters." );
		}
		goto Failure;
	}

Exit:
	if ( pDataPort != NULL )
	{
		pDataPort->DecRef();
		pDataPort = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNMODEMSP_NotSupported is used for methods required to implement the
 *  interface but that are not supported by this SP.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNMODEMSP_NotSupported"

STDMETHODIMP DNMODEMSP_NotSupported( IDP8ServiceProvider *pThis, PVOID pvParam )
{
	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pvParam);
	DPFX(DPFPREP, 2, "Returning: [DPNERR_UNSUPPORTED]");
	return DPNERR_UNSUPPORTED;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\cmddata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CmdData.cpp
 *  Content:	Class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/1999	jtk		Derived from SPData.h
 *	01/19/2000	jtk		Derived from CommandData.h
 *	10/10/2001	vanceo	Add multicast receive endpoint
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CCommandData::Reset - reset this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::Reset"

void	CCommandData::Reset( void )
{
	SetState( COMMAND_STATE_UNKNOWN );
	m_dwDescriptor = NULL_DESCRIPTOR;
	SetType( COMMAND_TYPE_UNKNOWN );
	SetEndpoint( NULL );
	SetUserContext( NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolAllocFunction - called when a pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolAllocFunction"

BOOL	CCommandData::PoolAllocFunction( void* pvItem, void* pvContext )
{
	BOOL	fReturn;

	CCommandData* pCmdData = (CCommandData*)pvItem;

	//
	// initialize
	//
	fReturn = TRUE;

	pCmdData->m_State = COMMAND_STATE_UNKNOWN;
	pCmdData->m_dwDescriptor = NULL_DESCRIPTOR;
	pCmdData->m_dwNextDescriptor = NULL_DESCRIPTOR + 1;
	pCmdData->m_Type = COMMAND_TYPE_UNKNOWN;
	pCmdData->m_pEndpoint = NULL;
	pCmdData->m_pUserContext = NULL;
	pCmdData->m_lRefCount = 0;

	//
	// initialize critical section and set recursin depth to 0
	//
	if ( DNInitializeCriticalSection( &pCmdData->m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &pCmdData->m_Lock, 0 );
	DebugSetCriticalSectionGroup( &pCmdData->m_Lock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes

Exit:
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolInitFunction - called when a pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolInitFunction"

void	CCommandData::PoolInitFunction( void* pvItem, void* pvContext )
{
	CCommandData* pCmdData = (CCommandData*)pvItem;

	DNASSERT( pCmdData->m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( pCmdData->m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( pCmdData->m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( pCmdData->m_pEndpoint == NULL );
	DNASSERT( pCmdData->m_pUserContext == NULL );

	DNASSERT( pCmdData->m_lRefCount == 0 );
	
	pCmdData->SetDescriptor();

	pCmdData->m_lRefCount = 1;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolReleaseFunction - called when item is returned to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolReleaseFunction"

void	CCommandData::PoolReleaseFunction( void* pvItem )
{
	CCommandData* pCmdData = (CCommandData*)pvItem;

	DNASSERT( pCmdData->m_lRefCount == 0 );

	pCmdData->m_State = COMMAND_STATE_UNKNOWN;
	pCmdData->m_dwDescriptor = NULL_DESCRIPTOR;
	pCmdData->m_Type = COMMAND_TYPE_UNKNOWN;
	pCmdData->m_pEndpoint = NULL;
	pCmdData->m_pUserContext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::Denitialize - deinitialization function for command data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolDeallocFunction"

void	CCommandData::PoolDeallocFunction( void* pvItem )
{
	CCommandData* pCmdData = (CCommandData*)pvItem;

	DNASSERT( pCmdData->m_lRefCount == 0 );

	DNDeleteCriticalSection( &pCmdData->m_Lock );
	pCmdData->m_State = COMMAND_STATE_UNKNOWN;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\debugutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DebugUtils.cpp
 *  Content:	Winsock service provider debug utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"

#ifdef DBG


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// HexDump - perform a hex dump of information
//
// Entry:		Pointer to data
//				Data size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "HexDump"

void HexDump( PVOID pData, UINT32 uDataSize )
{
	DWORD	uIdx = 0;


	// go through all data
	while ( uIdx < uDataSize )
	{
		// output character
		DPFX(DPFPREP,  0, "0x%2x ", ( (LPBYTE) pData )[ uIdx ] );

		// increment index
		uIdx++;

		// are we off the end of a line?
		if ( ( uIdx % 12 ) == 0 )
		{
			DPFX(DPFPREP,  0, "\n" );
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DumpSocketAddress - dump a socket address
//
// Entry:		Debug level
//				Pointer to socket address
//				Socket family
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DumpSocketAddress"

void DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily )
{
	switch ( dwFamily )
	{
		case AF_INET:
		{
			const SOCKADDR_IN	*const pInetAddress = reinterpret_cast<const SOCKADDR_IN*>( pSocketAddress );

			DPFX(DPFPREP, dwDebugLevel, "IPv4 socket: Address: %d.%d.%d.%d   Port: %d",
					pInetAddress->sin_addr.S_un.S_un_b.s_b1,
					pInetAddress->sin_addr.S_un.S_un_b.s_b2,
					pInetAddress->sin_addr.S_un.S_un_b.s_b3,
					pInetAddress->sin_addr.S_un.S_un_b.s_b4,
					NTOHS( pInetAddress->sin_port )
					);
			break;
		}

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );

			DPFX(DPFPREP, dwDebugLevel, "IPX socket: Net (hex) %x-%x-%x-%x   Node (hex): %x-%x-%x-%x-%x-%x   Socket: %d",
					(BYTE)pIPXAddress->sa_netnum[ 0 ],
					(BYTE)pIPXAddress->sa_netnum[ 1 ],
					(BYTE)pIPXAddress->sa_netnum[ 2 ],
					(BYTE)pIPXAddress->sa_netnum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
					NTOHS( pIPXAddress->sa_socket )
					);
			break;
		}
#endif // ! DPNBUILD_NOIPX

#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			WCHAR	wszString[INET6_ADDRSTRLEN];

			
			const SOCKADDR_IN6 *const pInet6Address = reinterpret_cast<const SOCKADDR_IN6*>( pSocketAddress );

			DNIpv6AddressToStringW(&pInet6Address->sin6_addr, wszString);
			DPFX(DPFPREP, dwDebugLevel, "IPv6 socket: Address: %ls   Port: %d   Scope: %d",
					wszString,
					NTOHS( pInet6Address->sin6_port ),
					pInet6Address->sin6_scope_id
					);
			break;
		}
#endif // ! DPNBUILD_NOIPV6

		default:
		{
			DPFX(DPFPREP,  0, "Unknown socket type!" );
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DumpAddress - convert an address to a URL and output via debugger
//
// Entry:		Debug level
//				Pointer to base message string
//				Pointer to address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DumpAddress"

void DumpAddress( const DWORD dwDebugLevel, const TCHAR *const pBaseString, IDirectPlay8Address *const pAddress )
{
	HRESULT	hr;
	TCHAR	tszURL[512];
	DWORD	dwURLSize;


	DNASSERT( pBaseString != NULL );
	DNASSERT( pAddress != NULL );
	
	dwURLSize = sizeof(tszURL) / sizeof(TCHAR);

	hr = IDirectPlay8Address_GetURL( pAddress, tszURL, &dwURLSize );
	if ( hr == DPN_OK )
	{
		DPFX(DPFPREP,  dwDebugLevel, "%s 0x%p - \"%s\"", pBaseString, pAddress, tszURL );
	}
	else
	{
		DPFX(DPFPREP,  dwDebugLevel, "Failing DumpAddress (err = 0x%x):", hr );
		DisplayDNError( dwDebugLevel, hr );
	}
	
	return;
}

#endif	// DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\classfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.cpp
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#include "dnwsocki.h"

#ifndef DPNBUILD_LIBINTERFACE

#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif // __MWERKS__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************



/*
 * DP8WSCF_CreateInstance
 *
 * Creates an instance of a DNServiceProvider object
 */
STDMETHODIMP DP8WSCF_CreateInstance(
                LPCLASSFACTORY This,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT						hr = S_OK;
    _IDirectPlayClassFactory*	pcf;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	pcf = (_IDirectPlayClassFactory*) This;
	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(This, pUnkOuter, pcf->clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* DP8WSCF_CreateInstance */


IClassFactoryVtbl TCPIPClassFactoryVtbl =
{
        DPCF_QueryInterface, // common\classfactory.cpp will implement the rest of these
        DPCF_AddRef,
        DPCF_Release,
        DP8WSCF_CreateInstance, // MASONB: TODO: Finish making these CLSID specific
        DPCF_LockServer
};

#ifndef DPNBUILD_NOIPX
IClassFactoryVtbl IPXClassFactoryVtbl =
{
        DPCF_QueryInterface, // common\classfactory.cpp will implement the rest of these
        DPCF_AddRef,
        DPCF_Release,
        DP8WSCF_CreateInstance,
        DPCF_LockServer
};
#endif // ! DPNBUILD_NOIPX


#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\cmddata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cmddata.h
 *  Content:	Declaration of class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/1999	jtk		Derived from SPData.h
 *	10/10/2001	vanceo	Add multicast receive endpoint
 ***************************************************************************/

#ifndef __COMMAND_DATA_H__
#define __COMMAND_DATA_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

typedef	enum
{
	COMMAND_STATE_UNKNOWN,					// unknown state
	COMMAND_STATE_PENDING,					// command waiting to be processed
	COMMAND_STATE_INPROGRESS,				// command is executing
	COMMAND_STATE_INPROGRESS_CANNOT_CANCEL,	// command is executing, can't be cancelled
	COMMAND_STATE_CANCELLING,				// command is already being cancelled
#ifndef DPNBUILD_ONLYONETHREAD
	COMMAND_STATE_FAILING,					// a blocking call executed by this command failed
#endif // ! DPNBUILD_ONLYONETHREAD
} COMMAND_STATE;

typedef	enum
{	
	COMMAND_TYPE_UNKNOWN,		// unknown command
	COMMAND_TYPE_CONNECT,		// connect command
	COMMAND_TYPE_LISTEN,		// listen command
	COMMAND_TYPE_ENUM_QUERY,	// enum command
#ifdef DPNBUILD_ASYNCSPSENDS
	COMMAND_TYPE_SEND,			// asynchronous data send command
#endif // DPNBUILD_ASYNCSPSENDS
#ifndef DPNBUILD_NOMULTICAST
	COMMAND_TYPE_MULTICAST_LISTEN,		// multicast listen command
	COMMAND_TYPE_MULTICAST_SEND,		// multicast send command
	COMMAND_TYPE_MULTICAST_RECEIVE,		// multicast receive command
#endif // ! DPNBUILD_NOMULTICAST
} COMMAND_TYPE;

#define	NULL_DESCRIPTOR		0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CEndpoint;
class	CCommandData;
class	CSPData;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
class	CCommandData
{
	public:
		void	Lock( void ) 
		{ 
			DNEnterCriticalSection( &m_Lock ); 
		}
		void	Unlock( void ) 
		{ 
			DNLeaveCriticalSection( &m_Lock ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_lRefCount != 0 );
			DNInterlockedIncrement( &m_lRefCount );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_lRefCount != 0 );
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				g_CommandDataPool.Release( this );
			}
		}

		DWORD	GetDescriptor( void ) const 
		{ 
			return m_dwDescriptor; 
		}
		void	SetDescriptor( void )
		{
			m_dwDescriptor = m_dwNextDescriptor;
			m_dwNextDescriptor++;
			if ( m_dwNextDescriptor == NULL_DESCRIPTOR )
			{
				m_dwNextDescriptor++;
			}
			
			SetState( COMMAND_STATE_UNKNOWN );
		}

		COMMAND_STATE	GetState( void ) const 
		{ 
			return m_State; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetState"
		void			SetState( const COMMAND_STATE State )	
		{ 
			m_State = State; 
		}

		COMMAND_TYPE	GetType( void ) const 
		{ 
			return m_Type; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetType"
		void			SetType( const COMMAND_TYPE Type )
		{
			DNASSERT( ( m_Type == COMMAND_TYPE_UNKNOWN ) || ( Type == COMMAND_TYPE_UNKNOWN ) );
			m_Type = Type;
		}

		CEndpoint	*GetEndpoint( void ) const { return m_pEndpoint; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetEndpoint"
		void		SetEndpoint( CEndpoint *const pEndpoint )
		{
			DNASSERT( ( m_pEndpoint == NULL ) || ( pEndpoint == NULL ) );
			m_pEndpoint = pEndpoint;
		}

		void	*GetUserContext( void ) const 
		{ 
			return m_pUserContext; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetUserContext"
		void	SetUserContext( void *const pUserContext )
		{
			DNASSERT( ( m_pUserContext == NULL ) || ( pUserContext == NULL ) );
			m_pUserContext = pUserContext;
		}

		void	Reset ( void );
		

		//
		// pool fnctions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

	protected:

	private:
		DWORD				m_dwDescriptor;
		DWORD				m_dwNextDescriptor;
		COMMAND_STATE		m_State;
		COMMAND_TYPE		m_Type;
		CEndpoint			*m_pEndpoint;
		void				*m_pUserContext;
		LONG 				m_lRefCount;
		
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_Lock;
#endif // !DPNBUILD_ONLYONETHREAD

		//
		// prevent unwarranted copies
		//
		CCommandData( const CCommandData & );
		CCommandData& operator=( const CCommandData & );
};

#undef DPF_MODNAME

#endif	// __COMMAND_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\debugutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DebugUtils.h
 *  Content:	Winsock service provider debug utilitiy functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/01/98	jtk		Created
 *  01/10/20000	rmt		Updated to build with Millenium build process
 ***************************************************************************/

#ifndef __DEBUG_UTILS_H__
#define __DEBUG_UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct sockaddr SOCKADDR;
typedef struct IDirectPlay8Address	IDirectPlay8Address;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifdef DBG

void	HexDump( PVOID pData, UINT32 uDataSize );
void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily );
void	DumpAddress( const DWORD dwDebugLevel, const TCHAR *const pBaseString, IDirectPlay8Address *const pAddress );

#else // DBG

#define HexDump( x, y )
#define DumpSocketAddress( x, y, z )
#define	DumpAddress( x, y, z )

#endif // DBG

#endif // __DEBUG_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\adapterentry.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AdapterEntry.h
 *  Content:	Strucutre definitions for IO data blocks
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/07/2000	jtk		Dereived from IOData.cpp
 ***************************************************************************/

#ifndef __ADAPTER_ENTRY_H__
#define __ADAPTER_ENTRY_H__


#ifndef DPNBUILD_ONLYONEADAPTER

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CThreadPool;


//
// class containing all data for an adapter list
//
class	CAdapterEntry
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_lRefCount != 0 );
			DNInterlockedIncrement( &m_lRefCount );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_lRefCount != 0 );
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				g_AdapterEntryPool.Release( this );
			}
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AddToAdapterList"
		void	AddToAdapterList( CBilink *const pAdapterList )
		{
			DNASSERT( pAdapterList != NULL );

			//
			// This assumes the SPData socketportdata lock is held.
			//
			
			m_AdapterListLinkage.InsertBefore( pAdapterList );
		}

		CBilink	*SocketPortList( void ) { return &m_ActiveSocketPorts; }
		const SOCKADDR	*BaseAddress( void ) const { return (SOCKADDR*) (&m_BaseSocketAddress); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::SetBaseAddress"
		void	SetBaseAddress( const SOCKADDR *const pSocketAddress, const int iSocketAddressSize )
		{
			DNASSERT(iSocketAddressSize <= sizeof(m_BaseSocketAddress));
			memcpy( &m_BaseSocketAddress, pSocketAddress, iSocketAddressSize );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AdapterEntryFromAdapterLinkage"
		static	CAdapterEntry	*AdapterEntryFromAdapterLinkage( CBilink *const pLinkage )
		{
			DNASSERT( pLinkage != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pLinkage ) );
			DBG_CASSERT( sizeof( CAdapterEntry* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CAdapterEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CAdapterEntry, m_AdapterListLinkage ) ] );
		}

#ifdef DBG
		void	DebugPrintOutstandingSocketPorts( void );
#endif // DBG

		//
		// Pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

	protected:

	private:
		CBilink				m_AdapterListLinkage;			// linkage to other adapters
		CBilink				m_ActiveSocketPorts;			// linkage to active socket ports
#ifdef DPNBUILD_NOIPV6
		SOCKADDR			m_BaseSocketAddress;			// socket address for this port class
#else // ! DPNBUILD_NOIPV6
		SOCKADDR_STORAGE	m_BaseSocketAddress;			// socket address for this port class
#endif // ! DPNBUILD_NOIPV6

		LONG				m_lRefCount;
		
		// prevent unwarranted copies
		CAdapterEntry( const CAdapterEntry & );
		CAdapterEntry& operator=( const CAdapterEntry & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME


#endif // ! DPNBUILD_ONLYONEADAPTER

#endif	// __ADAPTER_ENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\dnwsocki.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnwsocki.h
 *  Content:    DirectPlay Winsock SP master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNWSOCKI_H__
#define __DNWSOCKI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#include <winsockx.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#define INCL_WINSOCK_API_TYPEDEFS 1
#ifndef DPNBUILD_NOWINSOCK2
#include <Winsock2.h>
#include <IPHlpApi.h>
#include <WS2TCPIP.h>
#include <mstcpip.h>
#else
#include <winsock.h>
#endif // DPNBUILD_NOWINSOCK2
#include <windows.h>
#ifndef DPNBUILD_NOIPX
#include <WSIPX.h>
#endif // DPNBUILD_NOIPX
#include <mmsystem.h>
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
#include <ntsecapi.h> // for UNICODE_STRING
#include <madcapcl.h>
#endif // WINNT and ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_NOIPV6
#include <wspiapi.h>	// avoids hard linking to IPv6 functions, for Win2K support
#endif // ! DPNBUILD_NOIPV6
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "classbilink.h"
#include "fixedpool.h"
#include "dneterrors.h"
#include "PackBuff.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"
#include "createin.h"
#include "HandleTable.h"
#include "ClassFactory.h"
#include "HashTable.h"
#include "ReadWriteLock.h"

#ifndef DPNBUILD_NONATHELP
#include "dpnathlp.h"
#endif // ! DPNBUILD_NONATHELP

#ifdef DPNBUILD_LIBINTERFACE
#include "threadpoolclassfac.h"
#include "dpnaddrextern.h"
#endif // DPNBUILD_LIBINTERFACE


// 
// Wsock private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

#include "dpnwsockextern.h"

#include "Pools.h"
#include "Locals.h"
#include "MessageStructures.h"
#include "AdapterEntry.h"
#include "CMDData.h"
#include "DebugUtils.h"
#include "dwinsock.h"
#include "SPAddress.h"
#include "SPData.h"
#include "Utils.h"
#include "WSockSP.h"
#include "ThreadPool.h"
#include "SocketData.h"
#include "IOData.h"
#include "SocketPort.h"
#include "Endpoint.h"

#ifndef DPNBUILD_NOWINSOCK2
// provides us winsock2 support
#define DWINSOCK_EXTERN
#include "dwnsock2.inc"
#undef DWINSOCK_EXTERN
#endif // ! DPNBUILD_NOWINSOCK2

#ifndef DPNBUILD_NOSPUI
#include "IPUI.h"
#endif // !DPNBUILD_NOSPUI

#ifndef DPNBUILD_LIBINTERFACE
#include "Resource.h"
#endif // ! DPNBUILD_LIBINTERFACE

#ifndef HasOverlappedIoCompleted
#define HasOverlappedIoCompleted(lpOverlapped) ((lpOverlapped)->Internal != STATUS_PENDING)
#endif // HasOverlappedIoCompleted

#endif // __DNWSOCKI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\dpnwsockextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnwsockextern.h
 *  Content:    DirectPlay Wsock Library external functions to be called
 *              by other DirectPlay components.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	 07/20/2001	masonb	Created
 *
 ***************************************************************************/



// Pack this to keep it small since it will be sent over the wire
#pragma pack(push, 1)

#define SPSESSIONDATAINFO_XNET	0x00000001	// XNet security session information

typedef struct _SPSESSIONDATA_XNET
{
	DWORD		dwInfo;		// version control for future-proofing the session data, should be SPSESSIONDATAINFO_XNET
	GUID		guidKey;	// session key
	ULONGLONG	ullKeyID;	// session key ID
} SPSESSIONDATA_XNET;




#ifdef XBOX_ON_DESKTOP

//
// Emulated Xbox networking library structures
//

typedef struct {

    BYTE        cfgSizeOfStruct;

        // Must be set to sizeof(XNetStartupParams).  There is no default.

    BYTE        cfgFlags;

        // One or more of the following flags OR'd together:

        #define XNET_STARTUP_BYPASS_SECURITY            0x01
            // This devkit-only flag tells the XNet stack to allow insecure
            // communication to untrusted hosts (such as a PC).  This flag
            // is silently ignored by the secure versions of the library.

        #define XNET_STARTUP_BYPASS_DHCP                0x02
            // This devkit-only flag tells the XNet stack to skip searching for
            // for a DHCP server and use auto-ip only to acquire an IP address.
            // This will save several seconds when starting up if you know
            // that there is no DHCP server configured.  This flag is silently
            // ignored by the secure versions of the library.

        // The default is 0 (no flags specified).

    BYTE        cfgPrivatePoolSizeInPages;

        // Specifies the size of the pre-allocated private memory pool used by
        // XNet for the following situations:
        //
        //      - Responding to ARP/DHCP/ICMP messages
        //      - Responding to certain TCP control messages
        //      - Allocating incoming TCP connection request sockets
        //      - Buffering outgoing data until it is transmitted (UDP) or
        //        until it is acknowledged (TCP)
        //      - Buffering incoming data on a socket that does not have a
        //        sufficiently large overlapped read pending
        //
        // The reason for using a private pool instead of the normal system
        // pool is because we want to have completely deterministic memory 
        // behavior.  That is, all memory allocation occurs only when an API
        // is called.  No system memory allocation happens asynchronously in
        // response to an incoming packet.
        //
        // Note that this parameter is in units of pages (4096 bytes per page). 
        //
        // The default is 12 pages (48K).

    BYTE        cfgEnetReceiveQueueLength;
        
        // The length of the Ethernet receive queue in number of packets.  Each 
        // packet takes 2KB of physically contiguous memory.
        //
        // The default is 8 packets (16K).

    BYTE        cfgIpFragMaxSimultaneous;

        // The maximum number of IP datagrams that can be in the process of reassembly
        // at the same time.
        //
        // The default is 4 packets.

    BYTE        cfgIpFragMaxPacketDiv256;

        // The maximum size of an IP datagram (including header) that can be reassembled.
        // Be careful when setting this parameter to a large value as it opens up 
        // a potential denial-of-service attack by consuming large amounts of memory
        // in the fixed-size private pool.
        //
        // Note that this parameter is in units of 256-bytes each.
        //
        // The default is 8 units (2048 bytes).

    BYTE        cfgSockMaxSockets;

        // The maximum number of sockets that can be opened at once, including those 
        // sockets created as a result of incoming connection requests.  Remember
        // that a TCP socket may not be closed immediately after closesocket is
        // called depending on the linger options in place (by default a TCP socket
        // will linger).
        //
        // The default is 64 sockets.
        
    BYTE        cfgSockDefaultRecvBufsizeInK;

        // The default receive buffer size for a socket, in units of K (1024 bytes).
        //
        // The default is 16 units (16K).

    BYTE        cfgSockDefaultSendBufsizeInK;

        // The default send buffer size for a socket, in units of K (1024 bytes).
        //
        // The default is 16 units (16K).

    BYTE        cfgKeyRegMax;

        // The maximum number of XNKID / XNKEY pairs that can be registered at the 
        // same time by calling XNetRegisterKey.
        //
        // The default is 4 key pair registrations.

    BYTE        cfgSecRegMax;

        // The maximum number of security associations that can be registered at the
        // same time.  Security associations are created for each unique XNADDR / XNKID
        // pair passed to XNetXnAddrToInAddr.  Security associations are also implicitly
        // created for each secure host that establishes an incoming connection
        // with this host on a given registered XNKID.  Note that there will only be
        // one security association between a pair of hosts on a given XNKID no matter
        // how many sockets are actively communicating on that secure connection.
        //
        // The default is 32 security associations.

     BYTE       cfgQosDataLimitDiv4;

        // The maximum amount of Qos data, in units of DWORD (4 bytes), that can be supplied
        // to a call to XNetQosListen or returned in the result set of a call to XNetQosLookup.
        //
        // The default is 64 (256 bytes).

} XNetStartupParams;

typedef struct _XNADDR
{
	IN_ADDR		ina;			// IP address (zero if not static/DHCP)
	IN_ADDR		inaOnline;		// Online IP address (zero if not online)
	WORD		wPortOnline;	// Online port
	BYTE		abEnet[6];		// Ethernet MAC address
	BYTE		abOnline[20];	// Online identification
} XNADDR;

typedef struct _XNKID
{
	BYTE		ab[8];				// xbox to xbox key identifier
} XNKID;

#define XNET_XNKID_MASK				0xF0	// Mask of flag bits in first byte of XNKID
#define XNET_XNKID_SYSTEM_LINK		0x00	// Peer to peer system link session
#define XNET_XNKID_ONLINE_PEER		0x80	// Peer to peer online session
#define XNET_XNKID_ONLINE_SERVER	0xC0	// Client to server online session

#define XNetXnKidIsSystemLink(pxnkid)		(((pxnkid)->ab[0] & 0xC0) == XNET_XNKID_SYSTEM_LINK)
#define XNetXnKidIsOnlinePeer(pxnkid)		(((pxnkid)->ab[0] & 0xC0) == XNET_XNKID_ONLINE_PEER)
#define XNetXnKidIsOnlineServer(pxnkid)		(((pxnkid)->ab[0] & 0xC0) == XNET_XNKID_ONLINE_SERVER)

typedef struct _XNKEY
{
	BYTE		ab[16];				// xbox to xbox key exchange key
} XNKEY;

typedef struct
{
	INT			iStatus;	// WSAEINPROGRESS if pending; 0 if success; error if failed
	UINT		cina;		// Count of IP addresses for the given host
	IN_ADDR		aina[8];	// Vector of IP addresses for the given host
} XNDNS;



#endif // XBOX_ON_DESKTOP

#pragma pack(pop)



BOOL DNWsockInit(HANDLE hModule);
void DNWsockDeInit();
#ifndef DPNBUILD_NOCOMREGISTER
BOOL DNWsockRegister(LPCWSTR wszDLLName);
BOOL DNWsockUnRegister();
#endif // ! DPNBUILD_NOCOMREGISTER

#ifndef DPNBUILD_NOIPX
HRESULT CreateIPXInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							const XDP8CREATE_PARAMS * const pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
							IDP8ServiceProvider **const ppiDP8SP
							);
#endif // ! DPNBUILD_NOIPX
HRESULT CreateIPInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							const XDP8CREATE_PARAMS * const pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
							IDP8ServiceProvider **const ppiDP8SP
							);

#ifndef DPNBUILD_LIBINTERFACE
DWORD DNWsockGetRemainingObjectCount();

extern IClassFactoryVtbl TCPIPClassFactoryVtbl;
#ifndef DPNBUILD_NOIPX
extern IClassFactoryVtbl IPXClassFactoryVtbl;
#endif // ! DPNBUILD_NOIPX
#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\dwnsock2.inc ===
//
// DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
//

#if ((! defined(DPNBUILD_ONLYWINSOCK2)) && (! defined(DPNBUILD_NOWINSOCK2)))

#ifdef DWINSOCK_GLOBAL
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
#endif // DWINSOCK_GLOBAL

#ifdef DWINSOCK_EXTERN
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
#endif // DWINSOCK_EXTERN

#ifdef DWINSOCK_GETPROCADDRESS
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr)							\
				p_##name = (ptr)GetProcAddress(g_hWinSock2, #name);	\
				if (p_##name == NULL) fOK = FALSE
#endif // DWINSOCK_GETPROCADDRESS

	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
#ifdef UNICODE
	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
#else // ! UNICODE
	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
#endif // ! UNICODE

#else // DPNBUILD_ONLYWINSOCK2 or DPNBUILD_NOWINSOCK2
#ifdef DPNBUILD_ONLYWINSOCK2

	#define p_WSAGetOverlappedResult	WSAGetOverlappedResult
	#define p_WSAIoctl					WSAIoctl
	#define p_WSARecvFrom				WSARecvFrom
	#define p_WSASendTo					WSASendTo
#ifdef UNICODE
	#define p_WSAEnumProtocolsW			WSAEnumProtocolsW
#else // ! UNICODE
	#define p_WSAEnumProtocolsA			WSAEnumProtocolsA
#endif // ! UNICODE

#endif // DPNBUILD_ONLYWINSOCK2
#endif // DPNBUILD_ONLYWINSOCK2 or DPNBUILD_NOWINSOCK2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\dwinsock.cpp ===
//
// DWINSOCK.C	Dynamic WinSock
//
//				Functions for dynamically linking to
//				best available WinSock.
//
//				Dynamically links to WS2_32.DLL or
//				if WinSock 2 isn't available, it
//				dynamically links to WSOCK32.DLL.
//
//

#include "dnwsocki.h"


#if ((! defined(DPNBUILD_ONLYWINSOCK2)) && (! defined(DPNBUILD_NOWINSOCK2)))
//
// Globals
//
HINSTANCE	g_hWinSock2 = NULL;

//
// Declare global function pointers
//
#define DWINSOCK_GLOBAL
#include "dwnsock2.inc"

#endif // ! DPNBUILD_ONLYWINSOCK2 and ! DPNBUILD_NOWINSOCK2


//
// Internal Functions and data
//
#ifndef DPNBUILD_NOWINSOCK2
static BOOL MapWinsock2FunctionPointers(void);
#endif // ! DPNBUILD_NOWINSOCK2

#ifndef DPNBUILD_NOIPX

static char NibbleToHex(BYTE b);

static void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr);

static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
					   DWORD dwAddrLen,
					   LPTSTR lpAddrStr,
					   LPDWORD pdwStrLen);

#endif // ! DPNBUILD_NOIPX

////////////////////////////////////////////////////////////

#undef DPF_MODNAME
#define	DPF_MODNAME "DWSInitWinSock"

int DWSInitWinSock( void )
{
	WORD		 wVersionRequested;
	WSADATA		wsaData;
	int			iReturn;


#ifdef DPNBUILD_ONLYWINSOCK2
	//
	// Use Winsock 2.
	//
	wVersionRequested = MAKEWORD(2, 2);
#else // ! DPNBUILD_ONLYWINSOCK2
	//
	// Assume we will use Winsock 1.
	//
	wVersionRequested = MAKEWORD(1, 1);

#ifndef DPNBUILD_NOWINSOCK2
	//
	// Try to load Winsock 2 if allowed.
	//
#ifndef DPNBUILD_NOREGISTRY
	if (g_dwWinsockVersion != 1)
#endif // ! DPNBUILD_NOREGISTRY
	{
#ifdef WIN95
		OSVERSIONINFO	osvi;

		memset(&osvi, 0, sizeof(osvi));
		osvi.dwOSVersionInfoSize = sizeof(osvi);
		if ((g_dwWinsockVersion == 2) ||							// if we explicitly are supposed to use WS2, or
			(! GetVersionEx(&osvi)) ||								// if we can't get the OS information, or
			(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) ||	// if it's not Win9x, or
			(HIBYTE(HIWORD(osvi.dwBuildNumber)) != 4) ||			// it's not the Win98 major version number, or
			(LOBYTE(HIWORD(osvi.dwBuildNumber)) != 10))			// it's not Win98's minor version number (Gold = build 1998, SE = build 2222)
#endif // WIN95
		{
			g_hWinSock2 = LoadLibrary(TEXT("WS2_32.DLL"));
			if (g_hWinSock2 != NULL)
			{
				//
				// Use GetProcAddress to initialize
				// the function pointers
				//
				if (!MapWinsock2FunctionPointers())
				{
					iReturn = -1;
					goto Failure;
				}
				
				wVersionRequested = MAKEWORD(2, 2);
			}
		}
	}
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2

	//
	// Call WSAStartup()
	//
	iReturn = WSAStartup(wVersionRequested, &wsaData);
	if (iReturn != 0)
	{
		goto Failure;
	}

	DPFX(DPFPREP, 3, "Using WinSock version %i.%i",
		LOBYTE( wsaData.wVersion ), HIBYTE( wsaData.wVersion ) );

	if (wVersionRequested != wsaData.wVersion)
	{
		DPFX(DPFPREP, 0, "WinSock version %i.%i in use doesn't match version requested %i.%i!",
			LOBYTE( wsaData.wVersion ), HIBYTE( wsaData.wVersion ),
			LOBYTE( wVersionRequested ), HIBYTE( wVersionRequested ) );
		iReturn = -1;
		goto Failure;
	}

	DNASSERT(iReturn == 0);

Exit:

	return iReturn;

Failure:
	
#if ((! defined(DPNBUILD_ONLYWINSOCK2)) && (! defined(DPNBUILD_NOWINSOCK2)))
	if (g_hWinSock2 != NULL)
	{
		FreeLibrary(g_hWinSock2);
		g_hWinSock2 = NULL;
	}
#endif // ! DPNBUILD_ONLYWINSOCK2 and ! DPNBUILD_NOWINSOCK2

	DNASSERT(iReturn != 0);

	goto Exit;
}

#undef DPF_MODNAME

////////////////////////////////////////////////////////////

void DWSFreeWinSock(void)
{
	WSACleanup();

#if ((! defined(DPNBUILD_ONLYWINSOCK2)) && (! defined(DPNBUILD_NOWINSOCK2)))
	if (g_hWinSock2 != NULL)
	{
		FreeLibrary(g_hWinSock2);
		g_hWinSock2 = NULL;
	}
#endif // ! DPNBUILD_ONLYWINSOCK2 and ! DPNBUILD_NOWINSOCK2
}

#if ((! defined(DPNBUILD_ONLYWINSOCK2)) && (! defined(DPNBUILD_NOWINSOCK2)))
//**********************************************************************
// ------------------------------
// GetWinsockVersion - get the version of Winsock
//
// Entry:		Nothing
//
// Exit:		Winsock version
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "GetWinsockVersion"

int	GetWinsockVersion( void )
{
	return ((g_hWinSock2 != NULL) ? 2 : 1);
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYWINSOCK2 and ! DPNBUILD_NOWINSOCK2


#ifndef DPNBUILD_NOIPX

//
// Workaround for WSAAddressToString()/IPX bug
//
int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
					   DWORD dwAddrLen,
					   LPSTR lpAddrStr,
					   LPDWORD pdwStrLen)
{
	char szAddr[32];
	char szTmp[20];
	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
	//
	// Check destination length
	//
	if (*pdwStrLen < 27)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}

	//
	// Convert network number
	//
    BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
	strcpy(szAddr, szTmp);
    strcat(szAddr, ",");

	// Node Number
    BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
    strcat(szAddr, szTmp);

	strcpy(lpAddrStr, szAddr);
	*pdwStrLen = strlen(szAddr);

	return 0;
}


////////////////////////////////////////////////////////////

char NibbleToHex(BYTE b)
{
    if (b < 10)
		return (b + '0');

    return (b - 10 + 'A');
}

void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
{
	BYTE b;
    while(nNbrBytes--)
    {
		// High order nibble first
		b = (*pBytes >> 4);
		*lpStr = NibbleToHex(b);
		lpStr++;
		// Then low order nibble
		b = (*pBytes & 0x0F);
		*lpStr = NibbleToHex(b);
		lpStr++;
		pBytes++;
    }
    *lpStr = '\0';
}

////////////////////////////////////////////////////////////


//
// Workaround for WSAAddressToString()/IPX bug
//
int IPXAddressToString(LPSOCKADDR_IPX pAddr,
					   DWORD dwAddrLen,
					   LPTSTR lpAddrStr,
					   LPDWORD pdwStrLen)
{
	char szAddr[32];
	char szTmp[20];
	//
	// Check destination length
	//
	if (*pdwStrLen < 27)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}

	//
	// Convert network number
	//
    BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
	strcpy(szAddr, szTmp);
    strcat(szAddr, ",");

	// Node Number
    BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
    strcat(szAddr, szTmp);
    strcat(szAddr, ":");

	// IPX Address Socket number
    BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
    strcat(szAddr, szTmp);

#ifdef UNICODE
	//
	// Convert inet_ntoa string to wide char
	//
	int nRet = MultiByteToWideChar(CP_ACP,
								0,
								szAddr,
								-1,
								lpAddrStr,
								*pdwStrLen);
	if (nRet == 0)
	{
		if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
		{
			WSASetLastError(WSAEFAULT);
		}
		else
		{
			WSASetLastError(WSAEINVAL);
		}
		return SOCKET_ERROR;
	}
#else
	//
	// ANSI -- Check the string length
	//
	if (strlen(szAddr) > *pdwStrLen)
	{
		WSASetLastError(WSAEFAULT);
		*pdwStrLen = strlen(szAddr);
		return SOCKET_ERROR;
	}
	strcpy(lpAddrStr, szAddr);
	*pdwStrLen = strlen(szAddr);
#endif // UNICODE

	return 0;
}

#endif DPNBUILD_NOIPX

////////////////////////////////////////////////////////////

#ifndef DPNBUILD_NOWINSOCK2
BOOL MapWinsock2FunctionPointers(void)
{
	//
	// This variable must be declared
	// with this name in order to use
	// #define DWINSOCK_GETPROCADDRESS
	//
	BOOL fOK = TRUE;

	#define DWINSOCK_GETPROCADDRESS
	#include "dwnsock2.inc"

	return fOK;
}
#endif // DPNBUILD_NOWINSOCK2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\dwinsock.h ===
//
// DWINSOCK.H	Dynamic WinSock
//
//				Functions for dynamically linking to
//				best available WinSock.
//
//				Dynamically links to WS2_32.DLL or
//				if WinSock 2 isn't available, it
//				dynamically links to WSOCK32.DLL.
//
//

#ifndef DWINSOCK_H
#define DWINSOCK_H


int  DWSInitWinSock(void);
void DWSFreeWinSock(void);

#if ((! defined(DPNBUILD_ONLYWINSOCK2)) && (! defined(DPNBUILD_NOWINSOCK2)))
int	GetWinsockVersion(void);
#endif // ! DPNBUILD_ONLYWINSOCK2 and ! DPNBUILD_NOWINSOCK2


#ifndef DPNBUILD_NOIPX
int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
					   DWORD dwAddrLen,
					   LPSTR lpAddrStr,
					   LPDWORD pdwStrLen);
#endif // ! DPNBUILD_NOIPX



#endif // DWINSOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\endpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Endpoint.h
 *  Content:	Winsock endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/11/1999	jtk		Split out to make a base class
 *	01/10/2000	rmt		Updated to build with Millenium build process
 *	03/22/2000	jtk		Updated with changes to interface names
 *	03/12/2001	mjn		Added ENDPOINT_STATE_WAITING_TO_COMPLETE, m_dwThreadCount
 *	10/10/2001	vanceo	Added multicast code
 ***************************************************************************/

#ifndef __ENDPOINT_H__
#define __ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	TEMP_HOSTNAME_LENGTH	100

//
// enumeration of types of endpoints
//
typedef	enum	_ENDPOINT_TYPE
{
	ENDPOINT_TYPE_UNKNOWN = 0,				// unknown
	ENDPOINT_TYPE_CONNECT,					// endpoint is for connect
	ENDPOINT_TYPE_LISTEN,					// endpoint is for enum
	ENDPOINT_TYPE_ENUM,						// endpoint is for listen
	ENDPOINT_TYPE_CONNECT_ON_LISTEN,		// endpoint is for new connect coming from a listen
#ifndef DPNBUILD_NOMULTICAST
	ENDPOINT_TYPE_MULTICAST_SEND,			// endpoint is for sending multicasts
	ENDPOINT_TYPE_MULTICAST_LISTEN,			// endpoint is for receiving multicasts
	ENDPOINT_TYPE_MULTICAST_RECEIVE,		// endpoint is for receiving multicasts from a specific sender
#endif // ! DPNBUILD_NOMULTICAST
} ENDPOINT_TYPE;

//
// enumeration of the states an endpoint can be in
//
typedef	enum
{
	ENDPOINT_STATE_UNINITIALIZED = 0,		// uninitialized state
	ENDPOINT_STATE_ATTEMPTING_ENUM,			// attempting to enum
	ENDPOINT_STATE_ENUM,					// endpoint is supposed to enum connections
	ENDPOINT_STATE_ATTEMPTING_CONNECT,		// attempting to connect
	ENDPOINT_STATE_CONNECT_CONNECTED,		// endpoint is supposed to connect and is connected
	ENDPOINT_STATE_ATTEMPTING_LISTEN,		// attempting to listen
	ENDPOINT_STATE_LISTEN,					// endpoint is supposed to listen for connections
	ENDPOINT_STATE_DISCONNECTING,			// endpoint is disconnecting
	ENDPOINT_STATE_WAITING_TO_COMPLETE,		// endpoint is waiting to complete

	ENDPOINT_STATE_MAX
} ENDPOINT_STATE;

//
// enumeration of the states an endpoint uses to determine whether to accept an enum or not
//
typedef enum _ENUMSALLOWEDSTATE
{
	ENUMSNOTREADY,			// enums shouldn't be accepted yet
	ENUMSALLOWED,			// enums can be accepted
	ENUMSDISALLOWED			// enums must not be accepted
} ENUMSALLOWEDSTATE;


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSocketPort;
class	CSocketAddress;

//
// structure to bind extra information to an enum query to be used on enum reponse
//
typedef	struct	_ENDPOINT_ENUM_QUERY_CONTEXT
{
	SPIE_QUERY		EnumQueryData;
	HANDLE			hEndpoint;
	DWORD			dwEnumKey;
	CSocketAddress	*pReturnAddress;
} ENDPOINT_ENUM_QUERY_CONTEXT;

//
// structure to hold command parameters for endpoints
//
typedef	struct	_ENDPOINT_COMMAND_PARAMETERS
{
	union										// Local copy of the pending command data.
	{											// This data contains the pointers to the
		SPCONNECTDATA		ConnectData;		// active command, and the user context.
		SPLISTENDATA		ListenData;			//
		SPENUMQUERYDATA		EnumQueryData;		//
	} PendingCommandData;						//

	GATEWAY_BIND_TYPE	GatewayBindType;		// type of NAT binding that should be made for the endpoint
	DWORD				dwEnumSendIndex;		// index of time stamp on enumeration to be sent
	DWORD				dwEnumSendTimes[ ENUM_RTT_ARRAY_SIZE ];	// times of last enumeration sends

	static void PoolInitFunction( void* pvItem, void* pvContext)
	{
		memset(pvItem, 0, sizeof(_ENDPOINT_COMMAND_PARAMETERS));
	}

} ENDPOINT_COMMAND_PARAMETERS;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// class to act as a key for the enum lists in socket ports
//
class	CEndpointEnumKey
{
	public:
		CEndpointEnumKey() { };
		~CEndpointEnumKey() { };

		const WORD	GetKey( void ) const { return ( m_wKey & ~( ENUM_RTT_MASK ) ); }
		void	SetKey( const WORD wNewKey ) { m_wKey = wNewKey; };

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpointEnumKey::CompareFunction"
		static BOOL CompareFunction( PVOID pvKey1, PVOID pvKey2 )
		{
			const CEndpointEnumKey* pEPEnumKey1 = (CEndpointEnumKey*)pvKey1;
			const CEndpointEnumKey* pEPEnumKey2 = (CEndpointEnumKey*)pvKey2;

			return (pEPEnumKey1->GetKey() == pEPEnumKey2->GetKey());
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpointEnumKey::HashFunction"
		static DWORD HashFunction( PVOID pvKey, BYTE bBitDepth )
		{
			DWORD		dwReturn;
			UINT_PTR	Temp;
			const CEndpointEnumKey* pEPEnumKey = (CEndpointEnumKey*)pvKey;

			DNASSERT(pvKey != NULL);

			//
			// initialize
			//
			dwReturn = 0;

			//
			// hash enum key
			//
			Temp = pEPEnumKey->GetKey();
			do
			{
				dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
				Temp >>= bBitDepth;
			} while ( Temp != 0 );

			return dwReturn;
		}

	private:
		WORD	m_wKey;
};


#ifndef DPNBUILD_ONLYONETHREAD
#pragma pack(push, 4)
typedef struct _SEQUENCEDREFCOUNT
{
	WORD	wRefCount;
	WORD	wSequence;
} SEQUENCEDREFCOUNT;
#pragma pack(pop)
#endif // ! DPNBUILD_ONLYONETHREAD


//
// class for an endpoint
//
class	CEndpoint
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Lock"
		void	Lock( void )
		{
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Unlock"
		void	Unlock( void )
		{
			DNLeaveCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::AddCommandRef"
		BOOL	AddCommandRef( void )
		{
#ifdef DPNBUILD_ONLYONETHREAD
			LONG	lResult;


			DNASSERT(m_lCommandRefCount >= 0);

			//
			// Check if the command ref count is 0 at this moment.  If it is, then
			// the endpoint must be unbinding and this new reference should fail.
			//
			if (m_lCommandRefCount == 0)
			{
				DPFX(DPFPREP, 3, "Endpoint 0x%p command refcount is 0, not allowing new command ref.", this);
				return FALSE;
			}

			lResult = DNInterlockedIncrement( const_cast<LONG*>(&m_lCommandRefCount) );
				
			DPFX(DPFPREP, 9, "Endpoint 0x%p command refcount = %i", this, lResult);
#else // ! DPNBUILD_ONLYONETHREAD
			SEQUENCEDREFCOUNT	OldCommandRefCount;
			SEQUENCEDREFCOUNT	NewCommandRefCount;
			LONG				lResult;


			//
			// Check if the command ref count is 0 at this moment.  If it is, then
			// the endpoint must be unbinding and this new reference should fail.
			// We go through a few hoops to make sure that the ref count doesn't
			// go to 0 while we're trying to add a reference.
			//
			do
			{
				DBG_CASSERT(sizeof(m_CommandRefCount) == sizeof(LONG));
				*((LONG*) (&OldCommandRefCount)) = *((volatile LONG *) (&m_CommandRefCount));
				if (OldCommandRefCount.wRefCount == 0)
				{
					DPFX(DPFPREP, 3, "Endpoint 0x%p command refcount is 0, not allowing new command ref.", this);
					return FALSE;
				}

				DNASSERT(OldCommandRefCount.wRefCount < 0xFFFF);
				NewCommandRefCount.wRefCount = OldCommandRefCount.wRefCount + 1;
				NewCommandRefCount.wSequence = OldCommandRefCount.wSequence + 1;
				lResult = DNInterlockedCompareExchange((LONG*) (&m_CommandRefCount),
														(*(LONG*) (&NewCommandRefCount)),
														(*(LONG*) (&OldCommandRefCount)));
			}
			while (lResult != (*(LONG*) (&OldCommandRefCount)));

			DPFX(DPFPREP, 9, "Endpoint 0x%p command refcount = %i", this, NewCommandRefCount.wRefCount);
#endif // ! DPNBUILD_ONLYONETHREAD
				
			AddRef();
			
			return TRUE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::DecCommandRef"
		void	DecCommandRef( void )
		{
#ifdef DPNBUILD_ONLYONETHREAD
			LONG	lResult;


			DNASSERT(m_lCommandRefCount > 0);
			lResult = DNInterlockedDecrement( const_cast<LONG*>(&m_lCommandRefCount) );
			if ( lResult == 0 )
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p command refcount = 0, cleaning up command.", this);
				CleanUpCommand();
			}
			else
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p command refcount = %i", this, lResult);
			}
#else // ! DPNBUILD_ONLYONETHREAD
			SEQUENCEDREFCOUNT	OldCommandRefCount;
			SEQUENCEDREFCOUNT	NewCommandRefCount;
			LONG				lResult;


			do
			{
				DBG_CASSERT(sizeof(m_CommandRefCount) == sizeof(LONG));
				*((LONG*) (&OldCommandRefCount)) = *((volatile LONG *) (&m_CommandRefCount));
				DNASSERT(OldCommandRefCount.wRefCount > 0);
				NewCommandRefCount.wRefCount = OldCommandRefCount.wRefCount - 1;
				NewCommandRefCount.wSequence = OldCommandRefCount.wSequence + 1;
				lResult = DNInterlockedCompareExchange((LONG*) (&m_CommandRefCount),
														(*(LONG*) (&NewCommandRefCount)),
														(*(LONG*) (&OldCommandRefCount)));
			}
			while (lResult != (*(LONG*) (&OldCommandRefCount)));

			if ( NewCommandRefCount.wRefCount == 0 )
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p command refcount = 0, cleaning up command.", this);
				CleanUpCommand();
			}
			else
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p command refcount = %i", this, NewCommandRefCount.wRefCount);
			}
#endif // ! DPNBUILD_ONLYONETHREAD

			DecRef();
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::AddRef"
		void	AddRef( void )
		{
			LONG	lResult;

			
			DNASSERT( m_lRefCount != 0 );
			lResult = DNInterlockedIncrement( const_cast<LONG*>(&m_lRefCount) );
			DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = %i", this, lResult);
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::DecRef"
		void	DecRef( void )
		{
			LONG	lResult;

			
			DNASSERT( m_lRefCount != 0 );
			lResult = DNInterlockedDecrement( const_cast<LONG*>(&m_lRefCount) );
			if ( lResult == 0 )
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = 0, releasing.", this, lResult);
				g_EndpointPool.Release( this );
			}
			else
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = %i", this, lResult);
			}
		}

#ifndef DPNBUILD_NOSPUI
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetTempHostName"
		void		SetTempHostName( const TCHAR *const pHostName, const UINT_PTR uHostNameLength )
		{
			DNASSERT( pHostName[ uHostNameLength ] == TEXT('\0') );
			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1) * sizeof(TCHAR) );
		}
#endif // ! DPNBUILD_NOSPUI

		HRESULT	Open( const ENDPOINT_TYPE EndpointType,
					  IDirectPlay8Address *const pDP8Address,
					  PVOID pvSessionData,
					  DWORD dwSessionDataSize,
					  const CSocketAddress *const pSocketAddress );
		void	Close( const HRESULT hActiveCommandResult );
		void	ReinitializeWithBroadcast( void ) 
		{ 
			m_pRemoteMachineAddress->InitializeWithBroadcastAddress(); 
		}

		void	*GetUserEndpointContext( void ) const 
		{ 
			return m_pUserEndpointContext; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetUserEndpointContext"
		void	SetUserEndpointContext( void *const pUserEndpointContext )
		{
			DNASSERT( ( m_pUserEndpointContext == NULL ) ||
					  ( pUserEndpointContext == NULL ) );
			m_pUserEndpointContext = pUserEndpointContext;
		}

		const ENDPOINT_TYPE		GetType( void ) const 
		{ 
			return m_EndpointType; 
		}
		
		const ENDPOINT_STATE	GetState( void ) const 
		{ 
			return m_State; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetState"
		void	SetState( const ENDPOINT_STATE EndpointState )
		{
			DNASSERT( (EndpointState == ENDPOINT_STATE_DISCONNECTING ) || (EndpointState == ENDPOINT_STATE_WAITING_TO_COMPLETE));
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			m_State = EndpointState;
		}
		
		const GATEWAY_BIND_TYPE		GetGatewayBindType( void ) const 
		{ 
			return m_GatewayBindType; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetGatewayBindType"
		void	SetGatewayBindType( const GATEWAY_BIND_TYPE GatewayBindType )
		{
			DNASSERT( (m_GatewayBindType != GATEWAY_BIND_TYPE_UNKNOWN) || (GatewayBindType != GATEWAY_BIND_TYPE_UNKNOWN));
			m_GatewayBindType = GatewayBindType;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetWritableRemoteAddressPointer"
		CSocketAddress	*GetWritableRemoteAddressPointer( void ) const
		{
		    DNASSERT( m_pRemoteMachineAddress != NULL );
		    return m_pRemoteMachineAddress;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetRemoteAddressPointer"
		const CSocketAddress	*GetRemoteAddressPointer( void ) const
		{
		    DNASSERT( m_pRemoteMachineAddress != NULL );
		    return m_pRemoteMachineAddress;
		}
		
		void	ChangeLoopbackAlias( const CSocketAddress *const pSocketAddress ) const;

		const CEndpointEnumKey	*GetEnumKey( void ) const 
		{ 
			return &m_EnumKey; 
		}
		
		void	SetEnumKey( const WORD wKey ) 
		{ 
			m_EnumKey.SetKey( wKey ); 
		}

		void	SetEnumsAllowedOnListen( const BOOL fAllowed, const BOOL fOverwritePrevious );

		const BOOL IsEnumAllowedOnListen( void ) const
		{
			return (m_EnumsAllowedState == ENUMSALLOWED) ? TRUE : FALSE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetLocalAdapterDP8Address"
		IDirectPlay8Address *GetLocalAdapterDP8Address( const SP_ADDRESS_TYPE AddressType )
		{
			DNASSERT( GetSocketPort() != NULL );
#ifdef DPNBUILD_XNETSECURITY
			return	GetSocketPort()->GetDP8BoundNetworkAddress( AddressType,
																((IsUsingXNetSecurity()) ? &m_ullKeyID : NULL),
																GetGatewayBindType() );
#else // ! DPNBUILD_XNETSECURITY
			return	GetSocketPort()->GetDP8BoundNetworkAddress( AddressType, GetGatewayBindType() );
#endif // ! DPNBUILD_XNETSECURITY
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetRemoteHostDP8Address"
		IDirectPlay8Address *GetRemoteHostDP8Address( void )
		{
			DNASSERT( m_pRemoteMachineAddress != NULL );
#ifdef DPNBUILD_XNETSECURITY
			return	m_pRemoteMachineAddress->DP8AddressFromSocketAddress( ((IsUsingXNetSecurity()) ? &m_ullKeyID : NULL),
																			NULL,
																			SP_ADDRESS_TYPE_HOST );
#else // ! DPNBUILD_XNETSECURITY
			return	m_pRemoteMachineAddress->DP8AddressFromSocketAddress( SP_ADDRESS_TYPE_HOST );
#endif // ! DPNBUILD_XNETSECURITY
		}

		CSocketPort	*GetSocketPort( void ) const 
		{ 
			return m_pSocketPort; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetSocketPort"
		void		SetSocketPort( CSocketPort *const pSocketPort )
		{
			DNASSERT( ( m_pSocketPort == NULL ) || ( pSocketPort == NULL ) );
			m_pSocketPort = pSocketPort;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetCommandParametersGatewayBindType"
		void	SetCommandParametersGatewayBindType( GATEWAY_BIND_TYPE GatewayBindType )
		{
			DNASSERT( GetCommandParameters() != NULL );
			GetCommandParameters()->GatewayBindType = GatewayBindType;
		}

#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))
		void	MungeProxiedAddress( const CSocketPort * const pSocketPort,
									IDirectPlay8Address *const pHostAddress,
									const BOOL fEnum );
#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY

		HRESULT	CopyConnectData( const SPCONNECTDATA *const pConnectData );
		static	void	WINAPI ConnectJobCallback( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique );
		HRESULT	CompleteConnect( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::CleanupConnect"
		void	CleanupConnect( void )
		{
			DNASSERT( GetCommandParameters() != NULL );

			DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost );

			DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo );
		}

		BOOL	ConnectHasBeenSignalled( void ) const { return m_fConnectSignalled; }
		void	SignalDisconnect( void );
		HRESULT	Disconnect( void );
		void	StopEnumCommand( const HRESULT hCommandResult );

		HRESULT	CopyListenData( const SPLISTENDATA *const pListenData, IDirectPlay8Address *const pDeviceAddress );
		static	void	WINAPI ListenJobCallback( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique );
		HRESULT	CompleteListen( void );

		HRESULT	CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData );
		static	void	WINAPI EnumQueryJobCallback( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique );
		HRESULT	CompleteEnumQuery( void );

#ifndef DPNBUILD_ONLYONETHREAD
		static void	ConnectBlockingJobWrapper( void * const pvContext );
		void	ConnectBlockingJob( void );
		static void	ListenBlockingJobWrapper( void * const pvContext );
		void	ListenBlockingJob( void );
		static void	EnumQueryBlockingJobWrapper( void * const pvContext );
		void	EnumQueryBlockingJob( void );
#endif // ! DPNBUILD_ONLYONETHREAD

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::CleanupEnumQuery"
		void	CleanupEnumQuery( void )
		{
			DNASSERT( GetCommandParameters() != NULL );

			DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost );

			DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo );
		}

		void	ProcessEnumData( SPRECEIVEDBUFFER *const pBuffer, const DWORD dwEnumKey, const CSocketAddress *const pReturnSocketAddress );
		void	ProcessEnumResponseData( SPRECEIVEDBUFFER *const pBuffer,
										 const CSocketAddress *const pReturnSocketAddress,
#ifdef DPNBUILD_XNETSECURITY
										 const XNADDR *const pxnaddrReturn,
#endif // DPNBUILD_XNETSECURITY
										 const UINT_PTR uRTTIndex );
		void	ProcessUserData( CReadIOData *const pReadData );
		void	ProcessUserDataOnListen( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress );
#ifndef DPNBUILD_NOMULTICAST
		void	ProcessMcastDataFromUnknownSender( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress );
#endif // ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_ONLYONEADAPTER
		void	RemoveFromMultiplexList(void)				
		{ 
			// requires SPData's socket data lock
			m_blMultiplex.RemoveFromList(); 
		}
#endif // ! DPNBUILD_ONLYONEADAPTER

		void	AddToSocketPortList( CBilink * pBilink)		
		{ 
			// requires SPData's socket data lock
			m_blSocketPortList.InsertBefore( pBilink ); 
		}
		void	RemoveFromSocketPortList(void)				
		{ 
			// requires SPData's socket data lock
			m_blSocketPortList.RemoveFromList(); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::EndpointFromSocketPortListBilink"
		static	CEndpoint	*EndpointFromSocketPortListBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			return	reinterpret_cast<CEndpoint*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CEndpoint, m_blSocketPortList ) ] );
		}

		//
		//	Thread count references
		//
		DWORD	AddRefThreadCount( void )
		{
			return( ++m_dwThreadCount );
		}

		DWORD	DecRefThreadCount( void )
		{
			return( --m_dwThreadCount );
		}


		ENDPOINT_COMMAND_PARAMETERS	*GetCommandParameters( void ) const 
		{ 
			return m_pCommandParameters; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::IncNumReceives"
		void	IncNumReceives( void )
		{
			//
			// Assume the lock is held.
			//
			m_dwNumReceives++;

			//
			// Make sure it hasn't wrapped back to 0.
			//
			if ( m_dwNumReceives == 0 )
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p number of receives wrapped, will be off by one from now on.",
					this);

				m_dwNumReceives++;
			}
		}

		DWORD	GetNumReceives( void ) const
		{ 
			return m_dwNumReceives; 
		}


#ifndef DPNBUILD_NOSPUI
		//
		// UI functions
		//
		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
		void		SettingsDialogComplete( const HRESULT hr );
		static void		StopSettingsDialog( const HWND hDlg );
		HWND		GetActiveDialogHandle( void ) const 
		{ 
			return m_hActiveSettingsDialog; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetActiveDialogHandle"
		void	SetActiveDialogHandle( const HWND hDialog )
		{
			DNASSERT( ( GetActiveDialogHandle() == NULL ) ||
					  ( hDialog == NULL ) );
			m_hActiveSettingsDialog = hDialog;
		}
#endif // ! DPNBUILD_NOSPUI

#ifdef DPNBUILD_ASYNCSPSENDS
		static	void	WINAPI CompleteAsyncSend( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique );
#endif // DPNBUILD_ASYNCSPSENDS

#ifndef DPNBUILD_NOMULTICAST
		HRESULT	EnableMulticastReceive( CSocketPort * const pSocketPort );
		HRESULT	DisableMulticastReceive( void );

#ifdef WINNT
		static void MADCAPTimerComplete( const HRESULT hResult, void * const pContext );
		static void MADCAPTimerFunction( void * const pContext );
#endif // WINNT

		void GetScopeGuid( GUID * const pGuid )		{ memcpy( pGuid, &m_guidMulticastScope, sizeof( m_guidMulticastScope ) ); };
#endif // ! DPNBUILD_NOMULTICAST

#ifdef DPNBUILD_XNETSECURITY
		BOOL IsUsingXNetSecurity( void )				{ return m_fXNetSecurity; };
#endif // DPNBUILD_XNETSECURITY

#ifndef DPNBUILD_NONATHELP
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetUserTraversalMode"
		void SetUserTraversalMode( DWORD dwMode )
		{
			DNASSERT((dwMode == DPNA_TRAVERSALMODE_NONE) || (dwMode == DPNA_TRAVERSALMODE_PORTREQUIRED) || (dwMode == DPNA_TRAVERSALMODE_PORTRECOMMENDED));
			m_dwUserTraversalMode = dwMode;
		}
		DWORD GetUserTraversalMode( void ) const			{ return m_dwUserTraversalMode; }
#endif // ! DPNBUILD_NONATHELP

#ifdef DBG
		inline BOOL IsValid( void ) const
		{
			if (( m_Sig[0] != 'I' ) ||
				( m_Sig[1] != 'P' ) ||
				( m_Sig[2] != 'E' ) ||
				( m_Sig[3] != 'P' ))
			{
				return FALSE;
			}

			return TRUE;
		}
#endif // DBG


		//
		// pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
		static void	PoolReleaseFunction( void* pvItem );
		static void	PoolDeallocFunction( void* pvItem );

	protected:
		BYTE				m_Sig[4];	// debugging signature ('IPEP')

#ifndef DPNBUILD_NOSPUI
		TCHAR				m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
#endif // ! DPNBUILD_NOSPUI

		volatile	ENDPOINT_STATE		m_State;				// endpoint state
		volatile	BOOL				m_fConnectSignalled;	// Boolean indicating whether we've indicated a connection on this endpoint

		ENDPOINT_TYPE		m_EndpointType;						// type of endpoint
		CSocketAddress		*m_pRemoteMachineAddress;			// pointer to address of remote machine

		CSPData				*m_pSPData;							// pointer to SPData
		CSocketPort			*m_pSocketPort;						// pointer to associated socket port
		GATEWAY_BIND_TYPE	m_GatewayBindType;					// type of binding made (whether there should be a port mapping on the gateway or not)

		CEndpointEnumKey	m_EnumKey;							// key used for enums
		void				*m_pUserEndpointContext;			// context passed back with endpoint handles

		BOOL				m_fListenStatusNeedsToBeIndicated;
		ENUMSALLOWEDSTATE	m_EnumsAllowedState;					// whether incoming enums can be processed by this LISTEN endpoint or not
		
#ifndef DPNBUILD_ONLYONEADAPTER
		CBilink				m_blMultiplex;						// bilink in multiplexed command list,  protected by SPData's socket data lock
#endif // ! DPNBUILD_ONLYONEADAPTER
		CBilink				m_blSocketPortList;					// bilink in socketport list (not hash),  protected by SPData's socket data lock

		DWORD				m_dwNumReceives;					// how many packets have been received by this CONNECT/CONNECT_ON_LISTEN endpoint, or 0 if none



		BOOL	CommandPending( void ) const { return ( GetCommandParameters() != NULL ); }
		void	SetPendingCommandResult( const HRESULT hr ) { m_hrPendingCommandResult = hr; }
		HRESULT	PendingCommandResult( void ) const { return m_hrPendingCommandResult; }
		void	CompletePendingCommand( const HRESULT hrCommandResult );

		HRESULT	SignalConnect( SPIE_CONNECT *const pConnectData );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetCommandParameters"
		void	SetCommandParameters( ENDPOINT_COMMAND_PARAMETERS *const pCommandParameters )
		{
			DNASSERT( ( GetCommandParameters() == NULL ) ||
					  ( pCommandParameters == NULL ) );
			m_pCommandParameters = pCommandParameters;
		}

#ifndef DPNBUILD_ONLYONEADAPTER
		void SetEndpointID( const DWORD dwEndpointID )	{ m_dwEndpointID = dwEndpointID; }
		DWORD GetEndpointID( void ) const		{ return m_dwEndpointID; }
#endif // ! DPNBUILD_ONLYONEADAPTER


		DEBUG_ONLY( BOOL	m_fEndpointOpen );


#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION		m_Lock;						// critical section
#endif // !DPNBUILD_ONLYONETHREAD
		LONG					m_lRefCount;
#ifdef DPNBUILD_ONLYONETHREAD
		volatile LONG			m_lCommandRefCount;			// Command ref count.  When this goes to zero, the endpoint is unbound from the CSocketPort
#else // ! DPNBUILD_ONLYONETHREAD
		SEQUENCEDREFCOUNT		m_CommandRefCount;			// Command ref count.  When this goes to zero, the endpoint is unbound from the CSocketPort
#endif // ! DPNBUILD_ONLYONETHREAD
		DWORD volatile			m_dwThreadCount;			// Number of (ENUM) threads using endpoint
#ifndef DPNBUILD_ONLYONEADAPTER
		DWORD					m_dwEndpointID;				// unique identifier for this endpoint
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOMULTICAST
		GUID					m_guidMulticastScope;		// multicast scope being used
#ifdef WINNT
		BOOL					m_fMADCAPTimerJobSubmitted;	// whether the MADCAP timer job has been submitted or not
		MCAST_LEASE_RESPONSE	m_McastLeaseResponse;		// information describing the MADCAP lease response
#endif // WINNT
#endif // ! DPNBUILD_NOMULTICAST


#ifndef DPNBUILD_NOSPUI
		HWND						m_hActiveSettingsDialog;		// handle of active settings dialog
#endif // !DPNBUILD_NOSPUI

		ENDPOINT_COMMAND_PARAMETERS	*m_pCommandParameters;			// pointer to command parameters
		HRESULT						m_hrPendingCommandResult;		// result for pending command

		CCommandData				*m_pActiveCommandData;	// pointer to command data that's embedded in the command parameters
															// We don't know where in the union the command data really is, and
															// finding it programmatically each time would bloat the code.

#ifdef DPNBUILD_XNETSECURITY
		BOOL						m_fXNetSecurity;		// whether this endpoint is using XNet security or not
		GUID						m_guidKey;				// secure transport key GUID
		ULONGLONG					m_ullKeyID;				// secure transport key ID
#endif // DPNBUILD_XNETSECURITY

#ifndef DPNBUILD_NONATHELP
		DWORD						m_dwUserTraversalMode;	// the traversal mode specified by the user for this endpoint
#endif // ! DPNBUILD_NONATHELP

		static void		EnumCompleteWrapper( const HRESULT hCompletionCode, void *const pContext );	
		static void		EnumTimerCallback( void *const pContext );
		void	EnumComplete( const HRESULT hCompletionCode );	
		void	CleanUpCommand( void );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CEndpoint( const CEndpoint & );
		CEndpoint& operator=( const CEndpoint & );
};

#undef DPF_MODNAME

#endif	// __ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\iodata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.cpp
 *  Content:	Functions for IO structures
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/1998	jtk		Created
 *	02/11/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Alloc - called when new CReadIOData is allocated
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Alloc"

BOOL	CReadIOData::ReadIOData_Alloc( void* pvItem, void* pvContext )
{
	BOOL			fReturn;
	CSocketAddress	*pSocketAddress;

	CReadIOData* pReadIOData = (CReadIOData*)pvItem;
	READ_IO_DATA_POOL_CONTEXT* pReadIOContext = (READ_IO_DATA_POOL_CONTEXT*)pvContext;

	DNASSERT( pvContext != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pSocketAddress = NULL;


	pReadIOData->m_Sig[0] = 'R';
	pReadIOData->m_Sig[1] = 'I';
	pReadIOData->m_Sig[2] = 'O';
	pReadIOData->m_Sig[3] = 'D';

#ifndef DPNBUILD_NOWINSOCK2
	pReadIOData->m_pOverlapped = NULL;
    pReadIOData->m_dwOverlappedBytesReceived = 0;
#endif // ! DPNBUILD_NOWINSOCK2

	pReadIOData->m_pSocketPort = NULL;

	pReadIOData->m_dwBytesRead = 0;

	pReadIOData->m_ReceiveWSAReturn = ERROR_SUCCESS;

	DEBUG_ONLY( pReadIOData->m_fRetainedByHigherLayer = FALSE );

	pReadIOData->m_lRefCount = 0;
	pReadIOData->m_pThreadPool = NULL;

	DEBUG_ONLY( memset( &pReadIOData->m_ReceivedData, 0x00, sizeof( pReadIOData->m_ReceivedData ) ) );

	//
	// attempt to get a socket address for this item
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pReadIOContext->sSPType));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ( pSocketAddress == NULL )
	{
		DPFX(DPFPREP,  0, "Problem allocating a new socket address when creating ReadIOData pool item" );
		fReturn = FALSE;
		goto Exit;
	}

	pReadIOData->m_pSourceSocketAddress = pSocketAddress;
	pReadIOData->m_iSocketAddressSize = pSocketAddress->GetAddressSize();

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Get - called when new CReadIOData is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Get"

void	CReadIOData::ReadIOData_Get( void* pvItem, void* pvContext )
{
	DNASSERT( pvContext != NULL );

	CReadIOData* pReadIOData = (CReadIOData*)pvItem;
	READ_IO_DATA_POOL_CONTEXT* pReadIOContext = (READ_IO_DATA_POOL_CONTEXT*)pvContext;

	DNASSERT( pReadIOData->m_pSourceSocketAddress != NULL );
	DNASSERT( pReadIOData->m_iSocketAddressSize == pReadIOData->m_pSourceSocketAddress->GetAddressSize() );
	DNASSERT( pReadIOData->SocketPort() == NULL );

	DNASSERT( pReadIOContext->pThreadPool != NULL );
	DEBUG_ONLY( DNASSERT( pReadIOData->m_fRetainedByHigherLayer == FALSE ) );

	pReadIOData->m_pThreadPool = pReadIOContext->pThreadPool;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DNASSERT(pReadIOContext->dwCPU != -1);
	pReadIOData->m_dwCPU = pReadIOContext->dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR


#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	//
	// Make sure this address is for the right SP type, since this pooled read data
	// is possibly shared between them.
	//
	pReadIOData->m_pSourceSocketAddress->SetFamilyProtocolAndSize(pReadIOContext->sSPType);
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX

	DNASSERT( pReadIOData->m_lRefCount == 0 );
	
	//
	// Initialize internal SPRECEIVEDDATA.  When data is received, it's possible
	// that the pointers in the SPRECEIVEDDATA block were manipulated.  Reset
	// them to reflect that the entire buffer is available.
	//
	ZeroMemory( &pReadIOData->m_SPReceivedBuffer, sizeof( pReadIOData->m_SPReceivedBuffer ) );
	pReadIOData->m_SPReceivedBuffer.BufferDesc.pBufferData = pReadIOData->m_ReceivedData;
	pReadIOData->m_SPReceivedBuffer.BufferDesc.dwBufferSize = sizeof( pReadIOData->m_ReceivedData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Release - called when CReadIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Release"

void	CReadIOData::ReadIOData_Release( void* pvItem )
{
	CReadIOData* pReadIOData = (CReadIOData*)pvItem;
#ifndef DPNBUILD_NOWINSOCK2
	OVERLAPPED* pOverlapped;
	HRESULT		hr;
#endif // ! DPNBUILD_NOWINSOCK2


	DNASSERT( pReadIOData->m_lRefCount == 0 );
	DNASSERT( pReadIOData->m_pSourceSocketAddress != NULL );
	DEBUG_ONLY( DNASSERT( pReadIOData->m_fRetainedByHigherLayer == FALSE ) );

#ifndef DPNBUILD_NOWINSOCK2
	pOverlapped = pReadIOData->GetOverlapped();
	if (pOverlapped != NULL)
	{
		pReadIOData->SetOverlapped( NULL );
		DNASSERT( pReadIOData->m_pThreadPool != NULL );
		DNASSERT( pReadIOData->m_pThreadPool->GetDPThreadPoolWork() != NULL );

		hr = IDirectPlay8ThreadPoolWork_ReleaseOverlapped(pReadIOData->m_pThreadPool->GetDPThreadPoolWork(),
														pOverlapped,
														0);
		DNASSERT(hr == DPN_OK);
	}

	DNASSERT( pReadIOData->m_dwOverlappedBytesReceived == 0 );
#endif // ! DPNBUILD_NOWINSOCK2

	pReadIOData->m_pThreadPool = NULL;
	pReadIOData->SetSocketPort( NULL );

	DEBUG_ONLY( memset( &pReadIOData->m_ReceivedData, 0x00, sizeof( pReadIOData->m_ReceivedData ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Dealloc - called when CReadIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Dealloc"

void	CReadIOData::ReadIOData_Dealloc( void* pvItem )
{
	CReadIOData* pReadIOData = (CReadIOData*)pvItem;

	DNASSERT( pReadIOData->m_lRefCount == 0 );
	DNASSERT( pReadIOData->m_pSourceSocketAddress != NULL );
	DEBUG_ONLY( DNASSERT( pReadIOData->m_fRetainedByHigherLayer ==  FALSE ) );

	DNASSERT( pReadIOData->m_pThreadPool == NULL );

	// Base Class
	DNASSERT( pReadIOData->SocketPort() == NULL );

	g_SocketAddressPool.Release(pReadIOData->m_pSourceSocketAddress);
	
	pReadIOData->m_pSourceSocketAddress = NULL;
	pReadIOData->m_iSocketAddressSize = 0;

	DNASSERT( pReadIOData->m_pSourceSocketAddress == NULL );
	

}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\iodata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.h
 *  Content:	Strucutre definitions for IO data blocks
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/1998	jtk		Created
 ***************************************************************************/

#ifndef __IODATA_H__
#define __IODATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure and class references
//
class	CCommandData;
class	CEndpoint;
class	CSocketPort;
class	CSocketAddress;
class	CThreadPool;

//
// structures used to get I/O data from the pools
//
typedef	struct	_READ_IO_DATA_POOL_CONTEXT
{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	short					sSPType;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	CThreadPool				*pThreadPool;
}READ_IO_DATA_POOL_CONTEXT;


//
// all data for a read operation
//
class	CReadIOData
{
	public:

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::AddRef"
		void	AddRef( void ) 
		{ 
			DNInterlockedIncrement( &m_lRefCount ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_lRefCount != 0 );
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				CThreadPool	*pThreadPool;

				DNASSERT( m_pThreadPool != NULL );

				pThreadPool = m_pThreadPool;
				pThreadPool->ReturnReadIOData( this );
			}
		}

		SPRECEIVEDBUFFER	*ReceivedBuffer( void ) { DNASSERT( m_pThreadPool != NULL ); return &m_SPReceivedBuffer; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromSPReceivedBuffer"
    	static CReadIOData	*ReadDataFromSPReceivedBuffer( SPRECEIVEDBUFFER *const pSPReceivedBuffer )
    	{
    		DNASSERT( pSPReceivedBuffer != NULL );
    		DBG_CASSERT( sizeof( BYTE* ) == sizeof( pSPReceivedBuffer ) );
    		DBG_CASSERT( sizeof( CReadIOData* ) == sizeof( BYTE* ) );
    		return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pSPReceivedBuffer )[ -OFFSETOF( CReadIOData, m_SPReceivedBuffer ) ] );
    	}

		//
		// functions for managing read IO data pool
		//
		static BOOL	ReadIOData_Alloc( void* pvItem, void* pvContext );
		static void	ReadIOData_Get( void* pvItem, void* pvContext );
		static void	ReadIOData_Release( void* pvItem );
		static void	ReadIOData_Dealloc( void* pvItem );

		CSocketPort	*SocketPort( void ) const { return m_pSocketPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::SetSocketPort"
		void	SetSocketPort( CSocketPort *const pSocketPort )
		{
			DNASSERT( ( m_pSocketPort == NULL ) || ( pSocketPort == NULL ) );
			m_pSocketPort = pSocketPort;
		}

#ifndef DPNBUILD_NOWINSOCK2
		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::SetOverlapped"
		void	SetOverlapped( OVERLAPPED *const pOverlapped )
		{
			DNASSERT( ( m_pOverlapped == NULL ) || ( pOverlapped == NULL ) );
			m_pOverlapped = pOverlapped;
		}

		OVERLAPPED *GetOverlapped( void )	{ return m_pOverlapped; }
#endif // ! DPNBUILD_NOWINSOCK2

#ifndef DPNBUILD_ONLYONEPROCESSOR
		DWORD	GetCPU( void ) const		{ return m_dwCPU; }
#endif // ! DPNBUILD_ONLYONEPROCESSOR


		BYTE			m_Sig[4];						// debugging signature ('RIOD')
		
#ifndef DPNBUILD_NOWINSOCK2
		OVERLAPPED		*m_pOverlapped;					// pointer to overlapped I/O structure
		DWORD			m_dwOverlappedBytesReceived;
#endif // ! DPNBUILD_NOWINSOCK2

		CSocketPort		*m_pSocketPort;					// pointer to socket port associated with this IO request

		INT				m_iSocketAddressSize;			// size of received socket address (from Winsock)
		CSocketAddress	*m_pSourceSocketAddress;		// pointer to socket address class that's bound to the
														// local 'SocketAddress' element and is used to get the
														// address of the machine that originated the datagram

		INT				m_ReceiveWSAReturn;		

		DWORD			m_dwBytesRead;
		
		DEBUG_ONLY( BOOL	m_fRetainedByHigherLayer );
#ifndef DPNBUILD_ONLYONEPROCESSOR
		DWORD			m_dwCPU;					// owning CPU
#endif // ! DPNBUILD_ONLYONEPROCESSOR


	private:
		LONG				m_lRefCount;
		CThreadPool			*m_pThreadPool;
	
		SPRECEIVEDBUFFER	m_SPReceivedBuffer;
		BYTE				m_ReceivedData[ MAX_RECEIVE_FRAME_SIZE ];
		

		// prevent unwarranted copies
		CReadIOData( const CReadIOData & );
		CReadIOData& operator=( const CReadIOData & );
};



//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


#undef DPF_MODNAME

#endif	// __IODATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\ipui.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPUI.cpp
 *  Content:	Winsock service provider IP UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/15/1999	jtk		Dervied from ComPortUI.cpp
 ***************************************************************************/

#include "dnwsocki.h"

#ifndef DPNBUILD_NOSPUI

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// expected return from IP dialog
//
static const INT_PTR	g_iExpectedIPDialogReturn = 0x12345678;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
static	HRESULT	SetIPHostName( const HWND hDlg, const CEndpoint *const pEndpoint );
static	HRESULT	GetDialogData( const HWND hDlg, CEndpoint *const pEndpoint );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayIPHostNameDialog - dialog for comport settings
//
// Entry:		Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayIPHostNameSettingsDialog"

void	DisplayIPHostNameSettingsDialog( void *const pContext )
{
	CEndpoint	*pEndpoint;
	INT_PTR		iDlgReturn;

	
	DNASSERT( pContext != NULL );

	//
	// intialize
	//
	pEndpoint = static_cast<CEndpoint*>( pContext );
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( LPARAM ) );

	DPFX(DPFPREP,  5, "Starting IP settings dialog for endpoint 0x%p.", pEndpoint );
	
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hDLLInstance,						// handle of module for resources
								 MAKEINTRESOURCE( IDD_IP_SETTINGS ),	// resource for dialog
								 NULL,									// parent window (none)
								 SettingsDialogProc,					// dialog message proc
								 reinterpret_cast<LPARAM>( pEndpoint )	// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedIPDialogReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start IP settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetopIPHostNameSettingsDialog - stop dialog dialog for serial settings
//
// Entry:		Handle of dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StopIPHostNameSettingsDialog"

void	StopIPHostNameSettingsDialog( const HWND hDlg )
{
	DNASSERT( hDlg != NULL );
	if ( PostMessage( hDlg, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to stop dialog!" );
		DisplayErrorCode( 0, dwError );
		DNASSERT( FALSE );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SettingsDialogProc - dialog proc serial settings
//
// Entry:		Window handle
//				Message
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SettingsDialogProc"

static	INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CEndpoint	*pEndpoint;
	HRESULT		hr;


	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;

	//
	// Get the dialog context.  Note that the dialog context will be NULL
	// until the WM_INITDIALOG message is processed so the endpoint may note be
	// availble yet.
	//
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( LPARAM ) );
	pEndpoint = reinterpret_cast<CEndpoint*>( GetWindowLongPtr( hDlg, GWLP_USERDATA ) );

	switch ( uMsg )
	{
		//
		// initialize dialog
		//
		case WM_INITDIALOG:
		{
			//
			// since this is the first dialog message, the default code to set
			// pEndpoint isn't getting valid data
			//
			DBG_CASSERT( sizeof( pEndpoint ) == sizeof( lParam ) );
			pEndpoint = reinterpret_cast<CEndpoint*>( lParam );
			pEndpoint->Lock();
			if (pEndpoint->GetState() == ENDPOINT_STATE_DISCONNECTING)
			{
				hr = DPNERR_USERCANCEL;
				goto Failure;
			}
			else
			{
				pEndpoint->SetActiveDialogHandle( hDlg );
			}
			pEndpoint->Unlock();

			//
			// SetWindowLongPtr() returns NULL in case of error.  It's possible that
			// the old value from SetWindowLongPtr() was really NULL in which case it's not
			// an error.  To be safe, clear any residual error code before calling
			// SetWindowLongPtr().
			//
			SetLastError( 0 );
			if ( SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam ) == NULL )
			{
				DWORD	dwError;


				dwError = GetLastError();
				if ( dwError != ERROR_SUCCESS )
				{
					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
					DisplayErrorCode( 0, dwError );
					hr = DPNERR_GENERIC;
					goto Failure;
				}
			}

			//
			// set dialog parameters
			//
			if ( ( hr = SetIPHostName( hDlg, pEndpoint ) ) != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting device in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			return	TRUE;

			break;
		}

		//
		// a control did something
		//
		case WM_COMMAND:
		{
			//
			// what was the control?
			//
			switch ( LOWORD( wParam ) )
			{
				case IDOK:
				{
					if ( ( hr = GetDialogData( hDlg, pEndpoint ) ) != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem getting UI data!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					//
					// pass any error code on to 'DialogComplete'
					//
					EndDialog( hDlg, g_iExpectedIPDialogReturn );
					pEndpoint->SettingsDialogComplete( hr );

					break;
				}

				case IDCANCEL:
				{
					EndDialog( hDlg, g_iExpectedIPDialogReturn );
					pEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );

					break;
				}

				default:
				{
					break;
				}
			}

			break;
		}

		// window is closing
		case WM_CLOSE:
		{
			break;
		}
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDlg, g_iExpectedIPDialogReturn );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetIPHostName - set hostname field
//
// Entry:		Window handle
//				Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetIPHostName"

static	HRESULT	SetIPHostName( const HWND hDlg, const CEndpoint *const pEndpoint )
{
	HRESULT	hr;
	HWND	hEditControl;


	//
	// initialize
	//
	hr = DPN_OK;
	hEditControl = GetDlgItem( hDlg, IDC_EDIT_IP_HOSTNAME );
	if ( hEditControl == NULL )
	{
		DWORD	dwErrorCode;


		hr = DPNERR_GENERIC;
		dwErrorCode = GetLastError();
		DPFX(DPFPREP,  0, "Problem getting handle of hostname edit control!" );
		DisplayErrorCode( 0, dwErrorCode );
		goto Failure;
	}

	//
	// set edit field limit (this message does not have a return result)
	//
	SendMessage( hEditControl, EM_LIMITTEXT, TEMP_HOSTNAME_LENGTH, 0 );

	//
	// add string to dialog
	//
	if ( SetWindowText( hEditControl, TEXT("") ) == FALSE )
	{
		DWORD	dwErrorCode;


		hr = DPNERR_OUTOFMEMORY;
		dwErrorCode = GetLastError();
		DPFX(DPFPREP,  0, "Problem setting IP hostname in dialog!" );
		DisplayErrorCode( 0, dwErrorCode );
		goto Failure;
	}

Failure:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDialogData - set endpoint data from serial dialog
//
// Entry:		Window handle
//				Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDialogData"

static	HRESULT	GetDialogData( HWND hDlg, CEndpoint *pEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uHostNameLength;
	TCHAR		HostName[ TEMP_HOSTNAME_LENGTH ];
	HWND		hEditControl;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// get control ID and then the host name
	//
	hEditControl = GetDlgItem( hDlg, IDC_EDIT_IP_HOSTNAME );
	if ( hEditControl == NULL )
	{
		DWORD	dwErrorCode;


		DNASSERT( FALSE );
		hr = DPNERR_OUTOFMEMORY;
		dwErrorCode = GetLastError();
		DPFX(DPFPREP,  0, "Failed to get control handle when attempting to read IP hostname!" );
		DisplayDNError( 0, dwErrorCode );
		goto Failure;
	}

	//
	// Clear the error since Japanese Windows 9x does not seem to set it properly.
	//
	SetLastError(0);
	
	uHostNameLength = GetWindowText( hEditControl, HostName, LENGTHOF( HostName ) );
	if ( uHostNameLength == 0 )
	{
		DWORD	dwErrorCode;


		//
		// zero, possible empty name or error
		//
		dwErrorCode = GetLastError();
		if ( dwErrorCode != ERROR_SUCCESS )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed to read hostname from dialog!" );
			DisplayErrorCode( 0, dwErrorCode );
			goto Failure;
		}
	}

	pEndpoint->SetTempHostName( HostName, uHostNameLength );

Failure:
	return	hr;
}
//**********************************************************************

#endif // !DPNBUILD_NOSPUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\endpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Endpoint.cpp
 *  Content:	Winsock endpoint base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/12/1999	jtk		Derived from modem endpoint class
 *  01/10/2000	rmt		Updated to build with Millenium build process
 *  03/22/2000	jtk		Updated with changes to interface names
 *	03/12/2001	mjn		Prevent enum responses from being indicated up after completion
 *	10/08/2001	vanceo	Add multicast endpoint code
 ***************************************************************************/

#include "dnwsocki.h"



//**********************************************************************
// Constant definitions
//**********************************************************************

#ifndef DPNBUILD_NOMULTICAST
//#define MADCAP_LEASE_TIME				300 // ask for 5 minutes, in seconds
#define MADCAP_LEASE_TIME				3600 // ask for 1 hour, in seconds
#endif // ! DPNBUILD_NOMULTICAST




//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#ifndef DPNBUILD_ONLYONEADAPTER
typedef struct _MULTIPLEXEDADAPTERASSOCIATION
{
	CSPData *	pSPData;		// pointer to current SP interface for verification
	CBilink *	pBilink;		// pointer to list of endpoints for commands multiplexed over more than one adapter
	DWORD		dwEndpointID;	// identifier of endpoint referred to in bilink
} MULTIPLEXEDADAPTERASSOCIATION, * PMULTIPLEXEDADAPTERASSOCIATION;
#endif // ! DPNBUILD_ONLYONEADAPTER

//
// It's possible (although not advised) that this structure would get
// passed to a different platform, so we need to ensure that it always
// looks the same.
//
#pragma	pack(push, 1)

typedef struct _PROXIEDRESPONSEORIGINALADDRESS
{
	DWORD	dwSocketPortID;				// unique identifier for socketport originally sending packet
	DWORD	dwOriginalTargetAddressV4;	// the IPv4 address to which the packet was originally sent, in network byte order
	WORD	wOriginalTargetPort;		// the port to which the packet was originally sent, in network byte order
} PROXIEDRESPONSEORIGINALADDRESS, * PPROXIEDRESPONSEORIGINALADDRESS;

#pragma	pack(pop)


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CEndpoint::Open - open endpoint for use
//
// Entry:		Type of endpoint
//				Pointer to address to of remote machine
//				Pointer to socket address of remote machine
//
// Exit:		Error code
//
// Note:	Any call to Open() will require an associated call to Close().
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Open"

HRESULT	CEndpoint::Open( const ENDPOINT_TYPE EndpointType,
						 IDirectPlay8Address *const pDP8Address,
						 PVOID pvSessionData,
						 DWORD dwSessionDataSize,
						 const CSocketAddress *const pSocketAddress
						 )
{
	HRESULT					hr;
#ifdef DPNBUILD_XNETSECURITY
	SPSESSIONDATA_XNET *	pSessionDataXNet;
	ULONGLONG *				pullKeyID;
	int						iError;
#endif // DPNBUILD_XNETSECURITY


	DPFX(DPFPREP, 6, "(0x%p) Parameters (%u, 0x%p, 0x%p, %u, 0x%p)",
		this, EndpointType, pDP8Address, pvSessionData, dwSessionDataSize, pSocketAddress);

#ifdef DBG
	DNASSERT( m_fEndpointOpen == FALSE );
#endif // DBG

	//
	// initialize
	//
	hr = DPN_OK;
	DEBUG_ONLY( m_fEndpointOpen = TRUE );

	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	m_EndpointType = EndpointType;

	if (pvSessionData != NULL)
	{
		DNASSERT(dwSessionDataSize > sizeof(DWORD));
		
#ifdef DPNBUILD_XNETSECURITY
		//
		// Connect on listen endpoints are given the key ID already, it's
		// cast as the session data.
		//
		if (EndpointType == ENDPOINT_TYPE_CONNECT_ON_LISTEN)
		{
			DNASSERT(dwSessionDataSize == sizeof(m_ullKeyID));
			memcpy(&m_ullKeyID, pvSessionData, sizeof(m_ullKeyID));

#ifdef XBOX_ON_DESKTOP
			//
			// A security association is implicitly created by the secure transport.
			// Normally that would be taken care of by the time we got the data
			// that triggered this connection.  But when we're emulating the secure
			// transport, we need to do it manually.
			//
			iError = XNetPrivCreateAssociation((XNKID*) (&m_ullKeyID), pSocketAddress);
			if (iError != 0)
			{
				DPFX(DPFPREP, 0, "Unable to create implicit security association (err = %i)!",
					iError);
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
			else
			{
				DPFX(DPFPREP, 2, "Successfully created implicit security association.");
			}
#endif // XBOX_ON_DESKTOP

			m_fXNetSecurity = TRUE;
			pullKeyID = &m_ullKeyID;
		}
		else
		{
			pSessionDataXNet = (SPSESSIONDATA_XNET*) pvSessionData;
			if ((pSessionDataXNet->dwInfo == SPSESSIONDATAINFO_XNET) &&
				(dwSessionDataSize == sizeof(SPSESSIONDATA_XNET)))
			{
				//
				// Save the key and key ID.
				//
				memcpy(&m_guidKey, &pSessionDataXNet->guidKey, sizeof(m_guidKey));
				memcpy(&m_ullKeyID, &pSessionDataXNet->ullKeyID, sizeof(m_ullKeyID));

				//
				// Register the key.  It may have already been registered by another endpoint
				// so we use a refcount wrapper function to handle that case.
				//
				DBG_CASSERT(sizeof(ULONGLONG) == sizeof(XNKID));
				DBG_CASSERT(sizeof(GUID) == sizeof(XNKEY));
				iError = RegisterRefcountXnKey((XNKID*) (&m_ullKeyID), (XNKEY*) (&m_guidKey));
				if (iError != 0)
				{
					DPFX(DPFPREP, 0, "Unable to register secure transport key (err = %i)!",
						iError);
					hr = DPNERR_OUTOFMEMORY;
					goto Failure;
				}
				else
				{
					DPFX(DPFPREP, 2, "Successfully registered secure transport key.");
				}
				
				m_fXNetSecurity = TRUE;
				pullKeyID = &m_ullKeyID;
			}
			else
			{
				DPFX(DPFPREP, 0, "Unrecognized secure transport information (size %u, type 0x%08x), ignoring.",
					dwSessionDataSize, pSessionDataXNet->dwInfo);
				DNASSERT(! m_fXNetSecurity);
				pullKeyID = NULL;
			}
		}
#endif // DPNBUILD_XNETSECURITY
	}
	else
	{
		DNASSERT(dwSessionDataSize == 0);
#ifdef DPNBUILD_XNETSECURITY
		DNASSERT(! m_fXNetSecurity);
		pullKeyID = NULL;
#endif // DPNBUILD_XNETSECURITY
	}

	//
	// determine the endpoint type so we know how to handle the input parameters
	//
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address != NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			
			//
			//	Preset thread count
			//
			m_dwThreadCount = 0;
			
			hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
																		pullKeyID,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
																		FALSE,
#endif // DPNBUILD_ONLYONETHREAD
																		SP_ADDRESS_TYPE_HOST );
			if ( hr != DPN_OK )
			{
				if (hr == DPNERR_INCOMPLETEADDRESS)
				{
					DPFX(DPFPREP, 1, "Enum endpoint DP8Address is incomplete." );
				}
#ifndef DPNBUILD_ONLYONETHREAD
				else if (hr == DPNERR_TIMEDOUT)
				{
					DPFX(DPFPREP, 1, "Enum endpoint DP8Address requires name resolution." );

					//
					// It's not really a failure, we'll keep what we've done so
					// far and just return the special value.
					//
					goto Exit;
				}
#endif // ! DPNBUILD_ONLYONETHREAD
				else
				{
					DPFX(DPFPREP, 0, "Problem converting DP8Address to IP address in Open (enum)!" );
					DisplayDNError( 0, hr );
				}
				goto Failure;
			}
			
			//
			// Make sure its valid and not banned.
			//
			if (! m_pRemoteMachineAddress->IsValidUnicastAddress(TRUE))
			{
				DPFX(DPFPREP, 0, "Host address is invalid!");
				hr = DPNERR_INVALIDHOSTADDRESS;
				goto Failure;
			}

#ifndef DPNBUILD_NOREGISTRY
			if (m_pRemoteMachineAddress->IsBannedAddress())
			{
				DPFX(DPFPREP, 0, "Host address is banned!");
				hr = DPNERR_NOTALLOWED;
				goto Failure;
			}
#endif // ! DPNBUILD_NOREGISTRY

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_ONLYONETHREAD)))
			//
			// If NAT traversal is allowed, we may need to load and start
			// NAT Help, which can block.  Alert our caller so he/she knows
			// to submit a blocking job.
			//
			if ( GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE )
			{
				hr = DPNERR_TIMEDOUT;
			}
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_ONLYONETHREAD

			break;
		}

		//
		// standard endpoint creation, attempt to parse the input address
		//
		case ENDPOINT_TYPE_CONNECT:
#ifndef DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_MULTICAST_SEND:
		case ENDPOINT_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address != NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			
#ifndef DPNBUILD_NOMULTICAST
			if (EndpointType == ENDPOINT_TYPE_MULTICAST_SEND)
			{
				hr = m_pRemoteMachineAddress->SocketAddressFromMulticastDP8Address( pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
																					pullKeyID,
#endif // DPNBUILD_XNETSECURITY
																					&m_guidMulticastScope );
			}
			else
#endif // ! DPNBUILD_NOMULTICAST
			{
				hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
																			pullKeyID,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
																			FALSE,
#endif // DPNBUILD_ONLYONETHREAD
																			SP_ADDRESS_TYPE_HOST );
			}
			if ( hr != DPN_OK )
			{
				if ( hr == DPNERR_INCOMPLETEADDRESS )
				{
					DPFX(DPFPREP, 1, "Connect endpoint DP8Address is incomplete." );
				}
#ifndef DPNBUILD_ONLYONETHREAD
				else if (hr == DPNERR_TIMEDOUT)
				{
					DPFX(DPFPREP, 1, "Connect endpoint DP8Address requires name resolution." );
					DNASSERT(EndpointType == ENDPOINT_TYPE_CONNECT);

					//
					// It's not really a failure, we'll keep what we've done so
					// far and just return the special value.
					//
					goto Exit;
				}
#endif // ! DPNBUILD_ONLYONETHREAD
				else
				{
					DPFX(DPFPREP, 0, "Problem converting DP8Address to IP address in Open (connect)!" );
					DisplayDNError( 0, hr );
				}
				goto Failure;
			}
			
			//
			// Make sure its valid and not banned.
			//
			if (! m_pRemoteMachineAddress->IsValidUnicastAddress(FALSE))
			{
				DPFX(DPFPREP, 0, "Host address is invalid!");
				hr = DPNERR_INVALIDHOSTADDRESS;
				goto Failure;
			}

#ifndef DPNBUILD_NOREGISTRY
			if (m_pRemoteMachineAddress->IsBannedAddress())
			{
				DPFX(DPFPREP, 0, "Host address is banned!");
				hr = DPNERR_NOTALLOWED;
				goto Failure;
			}
#endif // ! DPNBUILD_NOREGISTRY


			//
			// Make sure the user isn't trying to connect to the DPNSVR port.
			//
			if ( m_pRemoteMachineAddress->GetPort() == HTONS(DPNA_DPNSVR_PORT) )
			{
				DPFX(DPFPREP, 0, "Attempting to connect to DPNSVR reserved port!" );
				hr = DPNERR_INVALIDHOSTADDRESS;
				goto Failure;
			}

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_ONLYONETHREAD)))
#ifndef DPNBUILD_NOMULTICAST
			if (EndpointType == ENDPOINT_TYPE_CONNECT)
#endif // ! DPNBUILD_NOMULTICAST
			{
				//
				// If NAT traversal is allowed, we may need to load and start
				// NAT Help, which can block.  Alert our caller so he/she knows
				// to submit a blocking job.
				//
				if ( GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE )
				{
					hr = DPNERR_TIMEDOUT;
				}
			}
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_ONLYONETHREAD

			break;
		}

		//
		// listen, there should be no input DNAddress
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_ONLYONETHREAD)))
			//
			// If NAT traversal is allowed, we may need to load and start
			// NAT Help, which can block.  Alert our caller so he/she knows
			// to submit a blocking job.
			//
			if ( GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE )
			{
				hr = DPNERR_TIMEDOUT;
			}
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_ONLYONETHREAD

			break;
		}

		//
		// new endpoint spawned from a listen, copy the input address and
		// note that this endpoint is really just a connection
		//
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			DNASSERT( pSocketAddress != NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			m_pRemoteMachineAddress->CopyAddressSettings( pSocketAddress );
			m_State = ENDPOINT_STATE_ATTEMPTING_CONNECT;

			break;
		}

#ifndef DPNBUILD_NOMULTICAST
		//
		// multicast listen, there should be a remote multicast address
		//
		case ENDPOINT_TYPE_MULTICAST_LISTEN:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address != NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );

			hr = m_pRemoteMachineAddress->SocketAddressFromMulticastDP8Address( pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
																				pullKeyID,
#endif // DPNBUILD_XNETSECURITY
																				&m_guidMulticastScope );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Problem converting DP8Address to IP address in Open (multicast listen)!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}
#endif // ! DPNBUILD_NOMULTICAST

		//
		// unknown type
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			break;

		}
	}

Exit:

	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Close - close an endpoint
//
// Entry:		Error code for active command
//
// Exit:		Error code
//
// Note:	This code does not disconnect an endpoint from its associated
//			socket port.  That is the responsibility of the code that is
//			calling this function.  This function assumes that this endpoint
//			is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Close"

void	CEndpoint::Close( const HRESULT hActiveCommandResult )
{
	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%lx)", this, hActiveCommandResult);

	
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

#ifndef DPNBUILD_ONLYONEADAPTER
	SetEndpointID( 0 );
#endif // ! DPNBUILD_ONLYONEADAPTER

	//
	// This can fire in legitimate cases.  For example, if a listen is cancelled
	// at the exact moment it is completing with a failure.
	//
	//DNASSERT( m_fEndpointOpen != FALSE );

	//
	// is there an active command?
	//
	if ( CommandPending() != FALSE )
	{
		//
		// cancel any active dialogs
		// if there are no dialogs, cancel the active command
		//
#ifndef DPNBUILD_NOSPUI
		if ( GetActiveDialogHandle() != NULL )
		{
			StopSettingsDialog( GetActiveDialogHandle() );
		}
#endif // !DPNBUILD_NOSPUI

		SetPendingCommandResult( hActiveCommandResult );
	}
	else
	{
		//
		// there should be no active dialog if there isn't an active command
		//
#ifndef DPNBUILD_NOSPUI
		DNASSERT( GetActiveDialogHandle() == NULL );
#endif // !DPNBUILD_NOSPUI
	}

#ifdef DPNBUILD_XNETSECURITY
	if (m_fXNetSecurity)
	{
		int	iResult;

		
		iResult = UnregisterRefcountXnKey((XNKID*) (&m_ullKeyID));
		DNASSERT(iResult == 0);
		m_fXNetSecurity = FALSE;
	}
#endif // DPNBUILD_XNETSECURITY

	DEBUG_ONLY( m_fEndpointOpen = FALSE );


	DPFX(DPFPREP, 6, "(0x%p) Leaving", this);

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ChangeLoopbackAlias - change the loopback alias to a real address
//
// Entry:		Pointer to real address to use
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ChangeLoopbackAlias"

void	CEndpoint::ChangeLoopbackAlias( const CSocketAddress *const pSocketAddress ) const
{
	DNASSERT( m_pRemoteMachineAddress != NULL );
	m_pRemoteMachineAddress->ChangeLoopBackToLocalAddress( pSocketAddress );
}
//**********************************************************************


#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))

//**********************************************************************
// ------------------------------
// CEndpoint::MungeProxiedAddress - modify this endpoint's remote address with proxied response information, if any
//
// Entry:		Pointer to socketport about to be bound
//				Pointer to remote host address
//				Whether its an enum or not
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::MungeProxiedAddress"

void	CEndpoint::MungeProxiedAddress( const CSocketPort * const pSocketPort,
										IDirectPlay8Address *const pHostAddress,
										const BOOL fEnum )
{
	HRESULT							hrTemp;
	PROXIEDRESPONSEORIGINALADDRESS	proa;
	DWORD							dwComponentSize;
	DWORD							dwComponentType;
	BYTE *							pbZeroExpandedStruct;
	DWORD							dwZeroExpands;
	BYTE *							pbStructAsBytes;
	BYTE *							pbValue;


	DNASSERT((GetType() == ENDPOINT_TYPE_CONNECT) || (GetType() == ENDPOINT_TYPE_ENUM));

	DNASSERT(m_pRemoteMachineAddress != NULL);

	DNASSERT(pSocketPort != NULL);
	DNASSERT(pSocketPort->GetNetworkAddress() != NULL);

	DNASSERT(pHostAddress != NULL);
	

	//
	// Proxying can only occur for IP, so bail if it's IPX.
	//
	if (pSocketPort->GetNetworkAddress()->GetFamily() != AF_INET)
	{
		//
		// Not IP socketport.  Bail.
		//
		return;
	}

#pragma TODO(vanceo, "Investigate for IPv6")

	//
	// See if the proxied response address component exists.
	//

	dwComponentSize = 0;
	dwComponentType = 0;
	hrTemp = IDirectPlay8Address_GetComponentByName( pHostAddress,										// interface
													DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS,	// tag
													NULL,												// component buffer
													&dwComponentSize,									// component size
													&dwComponentType									// component type
													);
	if (hrTemp != DPNERR_BUFFERTOOSMALL)
	{
		//
		// The component doesn't exist (or something else really weird
		// happened).  Bail.
		//
		return;
	}


	memset(&proa, 0, sizeof(proa));


	//
	// If the component type indicates the data is "binary", this is the original
	// address and we're good to go.  Same with ANSI strings; but the
	// addressing library currently will never return that I don't believe.
	// If it's a "Unicode string", the data probably got washed through the
	// GetURL/BuildFromURL functions (via Duplicate most likely).
	// The funky part is, every time through the wringer, each byte gets expanded
	// into a word (i.e. char -> WCHAR).  So when we retrieve it, it's actually not
	// a valid Unicode string, but a goofy expanded byte blob.  See below.
	// In all cases, the size of the buffer should be a multiple of the size of the
	// PROXIEDRESPONSEORIGINALADDRESS structure.
	//
	if ((dwComponentSize < sizeof(proa)) || ((dwComponentSize % sizeof(proa)) != 0))
	{
		//
		// The component isn't the right size.  Bail.
		//
		DPFX(DPFPREP, 0, "Private proxied response original address value is not a valid size (%u is not a multiple of %u)!  Ignoring.",
			dwComponentSize, sizeof(proa));
		return;
	}


	pbZeroExpandedStruct = (BYTE*) DNMalloc(dwComponentSize);
	if (pbZeroExpandedStruct == NULL)
	{
		//
		// Out of memory.  We have to bail.
		//
		return;
	}


	//
	// Retrieve the actual data.
	//
	hrTemp = IDirectPlay8Address_GetComponentByName( pHostAddress,										// interface
													DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS,	// tag
													pbZeroExpandedStruct,									// component buffer
													&dwComponentSize,									// component size
													&dwComponentType									// component type
													);
	if (hrTemp != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed retrieving private proxied response original address value (err = 0x%lx)!",
			hrTemp);

		DNFree(pbZeroExpandedStruct);
		pbZeroExpandedStruct = NULL;

		return;
	}


	//
	// Loop through the returned buffer and pop out the relevant bytes.
	//
	// 0xBB 0xAA			became 0xBB 0x00 0xAA, 0x00,
	// 0xBB 0x00 0xAA, 0x00	became 0xBB 0x00 0x00 0x00 0xAA 0x00 0x00 0x00,
	// etc.
	//

	dwZeroExpands = dwComponentSize / sizeof(proa);
	DNASSERT(dwZeroExpands > 0);


	DPFX(DPFPREP, 3, "Got %u byte expanded private proxied response original address key value (%u to 1 correspondence).",
		dwComponentSize, dwZeroExpands);


	pbStructAsBytes = (BYTE*) (&proa);
	pbValue = pbZeroExpandedStruct;

	while (dwComponentSize > 0)
	{
		(*pbStructAsBytes) = (*pbValue);
		pbStructAsBytes++;
		pbValue += dwZeroExpands;
		dwComponentSize -= dwZeroExpands;
	}
	

	DNFree(pbZeroExpandedStruct);
	pbZeroExpandedStruct = NULL;


	//
	// Once here, we've successfully read the proxied response original
	// address structure.
	//
	// We could have regkey to always set the target socketaddress back
	// to the original but the logic that picks the port could give the
	// wrong one and it's not necessary for the scenario we're
	// specifically trying to enable (ISA Server proxy).  See
	// CSocketPort::ProcessReceivedData.
	if (proa.dwSocketPortID != pSocketPort->GetSocketPortID())
	{
		SOCKADDR_IN *	psaddrinTemp;


		//
		// Since we're not using the exact same socket as what sent the
		// enum that generated the redirected response, the proxy may
		// have since removed the mapping.  Sending to the redirect
		// address will probably not work, so let's try going back to
		// the original address we were enumerating (and having the
		// proxy generate a new mapping).
		//


		//
		// Update the target.
		//
		psaddrinTemp = (SOCKADDR_IN*) m_pRemoteMachineAddress->GetWritableAddress();
		psaddrinTemp->sin_addr.S_un.S_addr	= proa.dwOriginalTargetAddressV4;
		psaddrinTemp->sin_port				= proa.wOriginalTargetPort;


		DPFX(DPFPREP, 2, "Socketport 0x%p is different from the one that received redirected response, using original target address %u.%u.%u.%u:%u",
			pSocketPort,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(psaddrinTemp->sin_port));


		DNASSERT(psaddrinTemp->sin_addr.S_un.S_addr != INADDR_ANY);
		DNASSERT(psaddrinTemp->sin_addr.S_un.S_addr != INADDR_BROADCAST);
		

		//
		//
		// There's a wrinkle involved here.  If the enum was originally
		// for the DPNSVR port, but we're now trying to connect, trying
		// to connect to the DPNSVR port won't work.  So we have to...
		// uh... guess the port.  So my logic will be: assume the remote
		// port is the same as the local one.  I figure, if the app is
		// using a custom port here, it probably was set on the other
		// side.  If it was an arbitrary port, we used a deterministic
		// algorithm to pick it, and it probably was done on the other
		// side, too.  The three cases where this won't work:
		//	1) when the server binds to a specific port but clients let
		//		DPlay pick. But if that side knew the server port ahead
		//		of time, this side probably doesn't need to enumerate
		//		the DPNSVR port, it should just enum the game port.
		//	2) when the other side let DPlay pick the port, but it was
		//		behind a NAT and thus the external port is something
		//		other than our default range.  Since it's behind a NAT,
		//		the remote user almost certainly communicated the public
		//		IP to this user, it should also be mentioning the port,
		//		and again, we can avoid the DPNSVR port.
		//	3) when DPlay was allowed to choose a port, but this machine
		//		and the remote one had differing ports already in use
		//		(i.e. this machine has no DPlay apps running and picked
		//		2302, but the remote machine has another DPlay app
		//		occupying port 2302 so we're actually want to get to
		//		2303.  Obviously, only workaround here is to keep that
		//		enum running so that we skip here and drop into the
		//		'else' case instead.
		//
		if ((proa.wOriginalTargetPort == HTONS(DPNA_DPNSVR_PORT)) && (! fEnum))
		{
			psaddrinTemp->sin_port			= pSocketPort->GetNetworkAddress()->GetPort();

			DPFX(DPFPREP, 1, "Original enum target was for DPNSVR port, attempting to connect to port %u instead.",
				NTOHS(psaddrinTemp->sin_port));
		}
	}
	else
	{
		//
		// Keep the redirected response address as the target, it's the
		// one the proxy probably intends us to use, see above comment).
		//
		// One additional problem - although we have the original target
		// we tried, it's conceivable that the proxy timed out the
		// mapping for the receive address and it would be no longer
		// valid.  The only way that would be possible with the current
		// DirectPlay core API is if the user got one of the redirected
		// enum responses, then the enum hit its retry limit and went to
		// the "wait for response" idle state and stayed that way such
		// that the the user started this enum/connect after the proxy
		// timeout but before the idle time expired.  Alternatively, if
		// he/she cancelled the enum before trying this enum/connect,
		// the above socketport ID check would fail unless a
		// simultaneous operation had kept the socketport open during
		// that time.  These scenarios don't seem that common, and I
		// don't expect a proxy timeout to be much shorter than 30-60
		// seconds anyway, so I think these are tolerable shortcomings.
		//
		DPFX(DPFPREP, 2, "Socketport 0x%p is the same, keeping redirected response address.",
			pSocketPort);
	}
}
//**********************************************************************

#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY



//**********************************************************************
// ------------------------------
// CEndpoint::CopyConnectData - copy data for connect command
//
// Entry:		Pointer to job information
//
// Exit:		Error code
//
// Note:	Device address needs to be preserved for later use.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyConnectData"

HRESULT	CEndpoint::CopyConnectData( const SPCONNECTDATA *const pConnectData )
{
	HRESULT	hr;
	ENDPOINT_COMMAND_PARAMETERS	*pCommandParameters;


	DNASSERT( pConnectData != NULL );
	
	DNASSERT( pConnectData->hCommand != NULL );
	DNASSERT( pConnectData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_pActiveCommandData == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;
	pCommandParameters = NULL;

	pCommandParameters = (ENDPOINT_COMMAND_PARAMETERS*)g_EndpointCommandParametersPool.Get();
	if ( pCommandParameters != NULL )
	{
		SetCommandParameters( pCommandParameters );

		DBG_CASSERT( sizeof( pCommandParameters->PendingCommandData.ConnectData ) == sizeof( *pConnectData ) );
		memcpy( &pCommandParameters->PendingCommandData, pConnectData, sizeof( pCommandParameters->PendingCommandData.ConnectData ) );

		pCommandParameters->PendingCommandData.ConnectData.pAddressHost = pConnectData->pAddressHost;
		IDirectPlay8Address_AddRef( pConnectData->pAddressHost );

		pCommandParameters->PendingCommandData.ConnectData.pAddressDeviceInfo = pConnectData->pAddressDeviceInfo;
		IDirectPlay8Address_AddRef( pConnectData->pAddressDeviceInfo );

		m_pActiveCommandData = static_cast<CCommandData*>( pCommandParameters->PendingCommandData.ConnectData.hCommand );
		m_pActiveCommandData->SetUserContext( pCommandParameters->PendingCommandData.ConnectData.pvContext );
		m_State = ENDPOINT_STATE_ATTEMPTING_CONNECT;
	
		DNASSERT( hr == DPN_OK );
	}
	else
	{
		hr = DPNERR_OUTOFMEMORY;
	}

	return	hr;
};
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ConnectJobCallback - asynchronous callback wrapper from work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ConnectJobCallback"

void	CEndpoint::ConnectJobCallback( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	// initialize
	DNASSERT( pvContext != NULL );
	pThisEndpoint = static_cast<CEndpoint*>( pvContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteConnect();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem completing connect in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!
	//

Exit:
	pThisEndpoint->DecRef();
	return;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CEndpoint::CompleteConnect - complete connection
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteConnect"

HRESULT	CEndpoint::CompleteConnect( void )
{
	HRESULT							hr;
	HRESULT							hTempResult;
	SPIE_CONNECT					ConnectIndicationData;
	BOOL							fEndpointBound;
	SPIE_CONNECTADDRESSINFO			ConnectAddressInfo;
	IDirectPlay8Address *			pHostAddress;
	IDirectPlay8Address *			pDeviceAddress;
	GATEWAY_BIND_TYPE				GatewayBindType;
	DWORD							dwConnectFlags;
	CEndpoint *						pTempEndpoint;
	CSocketData *					pSocketData;
	BOOL							fLockedSocketData;
#ifndef DPNBUILD_ONLYONEADAPTER
	MULTIPLEXEDADAPTERASSOCIATION	maa;
	DWORD							dwComponentSize;
	DWORD							dwComponentType;
	CBilink *						pBilinkAll;
	CBilink							blIndicate;
	CBilink							blFail;
#ifndef DPNBUILD_NOICSADAPTERSELECTIONLOGIC
	CSocketPort *					pSocketPort;
	CSocketAddress *				pSocketAddress;
	SOCKADDR_IN *					psaddrinTemp;
#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
	CEndpoint *						pPublicEndpoint;
	CSocketPort *					pPublicSocketPort;
	SOCKADDR						saddrPublic;
	DWORD							dwPublicAddressesSize;
	CBilink *						pBilinkPublic;
	DWORD							dwAddressTypeFlags;
	DWORD							dwTemp;
#endif // ! DPNBUILD_NONATHELP amd ! DPNBUILD_NOLOCALNAT
#endif // ! DPNBUILD_NOICSADAPTERSELECTIONLOGIC
#endif // ! DPNBUILD_ONLYONEADAPTER

	DNASSERT( GetCommandParameters() != NULL );
	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );
	DNASSERT( m_pActiveCommandData != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Enter", this);
	
	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointBound = FALSE;
	memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
#ifndef DPNBUILD_ONLYONEADAPTER
	blIndicate.Initialize();
	blFail.Initialize();
#endif // ! DPNBUILD_ONLYONEADAPTER
	pSocketData = NULL;
	fLockedSocketData = FALSE;

	DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.hCommand == m_pActiveCommandData );
	DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );

	DNASSERT( GetCommandParameters()->GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN) ;


	//
	// Transfer address references to our local pointers.  These will be released
	// at the end of this function, but we'll keep the pointers in the pending command
	// data so CSPData::BindEndpoint can still access them.
	//
	
	pHostAddress = GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost;
	DNASSERT( pHostAddress != NULL );

	pDeviceAddress = GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );


	//
	// Retrieve other parts of the command parameters for convenience.
	//
	GatewayBindType = GetCommandParameters()->GatewayBindType;
	dwConnectFlags = GetCommandParameters()->PendingCommandData.ConnectData.dwFlags;


	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

#ifdef DPNBUILD_NOMULTICAST
	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_CONNECT );
#else // ! DPNBUILD_NOMULTICAST
	DNASSERT( (m_pActiveCommandData->GetType() == COMMAND_TYPE_CONNECT) || (m_pActiveCommandData->GetType() == COMMAND_TYPE_MULTICAST_SEND) || (m_pActiveCommandData->GetType() == COMMAND_TYPE_MULTICAST_RECEIVE) );
#endif // ! DPNBUILD_NOMULTICAST
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command was pending, that's fine
		//
		case COMMAND_STATE_PENDING:
		{
			DNASSERT( hr == DPN_OK );

			break;
		}
		
		//
		// command was previously uninterruptable (probably because the connect UI
		// was displayed), mark it as pending
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_PENDING );
			DNASSERT( hr == DPN_OK );

			break;
		}
		
		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP, 0, "User cancelled connect!" );

			break;
		}
		
#ifndef DPNBUILD_ONLYONETHREAD
		//
		// blocking operation failed
		//
		case COMMAND_STATE_FAILING:
		{
			hr = m_hrPendingCommandResult;
			DNASSERT(hr != DPN_OK);
			DPFX(DPFPREP, 0, "Connect blocking operation failed!" );

			break;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	m_pActiveCommandData->Unlock();
	
	if ( hr != DPN_OK )
	{
		goto Failure;
	}



	//
	// Bind the endpoint.  Note that the GATEWAY_BIND_TYPE actually used
	// (GetGatewayBindType()) may differ from GatewayBindType.
	//
	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GatewayBindType );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind endpoint (err = 0x%lx)!", hr );
		DisplayDNError( 0, hr );

		//
		// We failed, but we'll continue through to indicate the address info and
		// add it to the multiplex list.
		//

		ConnectAddressInfo.pHostAddress = GetRemoteHostDP8Address();
		if ( ConnectAddressInfo.pHostAddress == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		//
		// Just regurgitate the device address we were given initially.
		//
		IDirectPlay8Address_AddRef(pDeviceAddress);
		ConnectAddressInfo.pDeviceAddress = pDeviceAddress;
		ConnectAddressInfo.hCommandStatus = hr;
		ConnectAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();
		
		SetPendingCommandResult( hr );
		hr = DPN_OK;

		//
		// Note that the endpoint is not bound!
		//
		DNASSERT(GetSocketPort() == NULL);
	}
	else
	{
		fEndpointBound = TRUE;
		
		//
		// attempt to indicate addressing to a higher layer
		//
#ifdef DPNBUILD_XNETSECURITY
		ConnectAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, NULL, GetGatewayBindType() );
#else // ! DPNBUILD_XNETSECURITY
		ConnectAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, GetGatewayBindType() );
#endif // ! DPNBUILD_XNETSECURITY
		ConnectAddressInfo.pHostAddress = GetRemoteHostDP8Address();
		ConnectAddressInfo.hCommandStatus = DPN_OK;
		ConnectAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

		if ( ( ConnectAddressInfo.pHostAddress == NULL ) ||
			 ( ConnectAddressInfo.pDeviceAddress == NULL ) )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	}


	//
	// Retrieve the socket data.  Bind endpoint should have created the object or
	// returned a failure, so we won't handle the error case here.
	//
	pSocketData = m_pSPData->GetSocketDataRef();
	DNASSERT(pSocketData != NULL);


#ifndef DPNBUILD_ONLYONEADAPTER
	//
	// We can run into problems with "multiplexed" device attempts when you are on
	// a NAT machine.  The core will try connecting on multiple adapters, but since
	// we are on the network boundary, each adapter can see and get responses from
	// both networks.  This causes problems with peer-to-peer sessions when the
	// "wrong" adapter gets selected (because it receives a response first).  To
	// prevent that, we are going to internally remember the association between
	// the multiplexed Connects so we can decide on the fly whether to indicate a
	// response or not.  Obviously this workaround/decision logic relies on having
	// internal knowledge of what the upper layer would be doing...
	//
	// So either build or add to the linked list of multiplexed Connects.
	// Technically this is only necessary for IP, since IPX can't have NATs, but
	// what's the harm in having a little extra info?
	//
		
	dwComponentSize = sizeof(maa);
	dwComponentType = 0;
	hTempResult = IDirectPlay8Address_GetComponentByName( pDeviceAddress,									// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component buffer
														&dwComponentSize,									// component size
														&dwComponentType									// component type
														);
	if (( hTempResult == DPN_OK ) && ( dwComponentSize == sizeof(MULTIPLEXEDADAPTERASSOCIATION) ) && ( dwComponentType == DPNA_DATATYPE_BINARY ))
	{
		//
		// We found the right component type.  See if it matches the right
		// CSPData object.
		//
		if ( maa.pSPData == m_pSPData )
		{
			pSocketData->Lock();
			//fLockedSocketData = TRUE;

			pTempEndpoint = CONTAINING_OBJECT(maa.pBilink, CEndpoint, m_blMultiplex);

			//
			// Make sure the endpoint is still around/valid.
			//
			// THIS MAY CRASH IF OBJECT POOLING IS DISABLED!
			//
			if ( pTempEndpoint->GetEndpointID() == maa.dwEndpointID )
			{
				DPFX(DPFPREP, 3, "Found correctly formed private multiplexed adapter association key, linking endpoint 0x%p with earlier connects (prev endpoint = 0x%p).",
					this, pTempEndpoint);

				DNASSERT( pTempEndpoint->GetType() == ENDPOINT_TYPE_CONNECT );
				DNASSERT( pTempEndpoint->GetState() != ENDPOINT_STATE_UNINITIALIZED );

				//
				// Actually link to the other endpoints.
				//
				m_blMultiplex.InsertAfter(maa.pBilink);
			}
			else
			{
				DPFX(DPFPREP, 1, "Found private multiplexed adapter association key, but prev endpoint 0x%p ID doesn't match (%u != %u), cannot link endpoint 0x%p and hoping this connect gets cancelled, too.",
					pTempEndpoint, pTempEndpoint->GetEndpointID(), maa.dwEndpointID, this);
			}
			

			pSocketData->Unlock();
			//fLockedSocketData = FALSE;
		}
		else
		{
			//
			// We are the only ones who should know about this key, so if it
			// got there either someone is trying to imitate our address format,
			// or someone is passing around device addresses returned by
			// xxxADDRESSINFO to a different interface or over the network.
			// None of those situations make a whole lot of sense, but we'll
			// just ignore it.
			//
			DPFX(DPFPREP, 0, "Multiplexed adapter association key exists, but 0x%p doesn't match expected 0x%p, is someone trying to get cute with device address 0x%p?!",
				maa.pSPData, m_pSPData, pDeviceAddress );
		}
	}
	else
	{
		//
		// Either the key is not there, it's the wrong size (too big for our
		// buffer and returned BUFFERTOOSMALL somehow), it's not a binary
 		// component, or something else bad happened.  Assume that this is the
		// first device.
		//
		DPFX(DPFPREP, 8, "Could not get appropriate private multiplexed adapter association key, error = 0x%lx, component size = %u, type = %u, continuing.",
			hTempResult, dwComponentSize, dwComponentType);
	}
	

	//
	// Add the multiplex information to the device address for future use if
	// necessary.
	// Ignore failure, we can still survive without it, we just might have the
	// race conditions for responses on NAT machines.
	//
	// NOTE: There is an inherent design problem here!  We're adding a pointer to
	// an endpoint (well, a field within the endpoint structure) inside the address.
	// If this endpoint goes away but the upper layer reuses the address at a later
	// time, this memory will be bogus!  We will assume that the endpoint will not
	// go away while this modified device address object is in existence.
	//
	if ( dwConnectFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
	{
		maa.pSPData = m_pSPData;
		maa.pBilink = &m_blMultiplex;
		maa.dwEndpointID = GetEndpointID();

		DPFX(DPFPREP, 7, "Additional multiplex adapters on the way, adding SPData 0x%p and bilink 0x%p to address.",
			maa.pSPData, maa.pBilink);
		
		hTempResult = IDirectPlay8Address_AddComponent( ConnectAddressInfo.pDeviceAddress,						// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component data
														sizeof(maa),										// component data size
														DPNA_DATATYPE_BINARY								// component data type
														);
		if ( hTempResult != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Couldn't add private multiplexed adapter association component (err = 0x%lx)!  Ignoring.", hTempResult);
		}

		//
		// Mark the command as "in-progress" so that the cancel thread knows it needs
		// to do the completion itself.
		// If the command has already been marked for cancellation, then we have to
		// do that now.
		//
		m_pActiveCommandData->Lock();
		if ( m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
		{
			m_pActiveCommandData->Unlock();


			DPFX(DPFPREP, 1, "Connect 0x%p (endpoint 0x%p) has already been cancelled, bailing.",
				m_pActiveCommandData, this);
			
			//
			// Complete the connect with USERCANCEL.
			//
			hr = DPNERR_USERCANCEL;
			goto Failure;
		}

		m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
		m_pActiveCommandData->Unlock();
	}
#endif // ! DPNBUILD_ONLYONEADAPTER


	//
	// Now tell the user about the address info that we ended up using, if we
	// successfully bound the endpoint, or give them a heads up for a failure
	// (see BindEndpoint failure case above).
	//
	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_CONNECTADDRESSINFO 0x%p to interface 0x%p.",
		this, &ConnectAddressInfo, m_pSPData->DP8SPCallbackInterface());
	DumpAddress( 8, _T("\t Host:"), ConnectAddressInfo.pHostAddress );
	DumpAddress( 8, _T("\t Device:"), ConnectAddressInfo.pDeviceAddress );
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

	hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
												SPEV_CONNECTADDRESSINFO,				// event type
												&ConnectAddressInfo						// pointer to data
												);

	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_CONNECTADDRESSINFO [0x%lx].",
		this, hTempResult);
	
	DNASSERT( hTempResult == DPN_OK );


	//
	// If there aren't more multiplex adapter commands on the way, then signal
	// the connection and complete the command for all connections, including
	// this one.
	//
#ifndef DPNBUILD_ONLYONEADAPTER
	if ( dwConnectFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
	{
		//
		// Not last multiplexed adapter.  All the work needed to be done for these
		// endpoints at this time has already been done.
		//
		DPFX(DPFPREP, 6, "Endpoint 0x%p is not the last multiplexed adapter, not completing connect yet.",
			this);
	}
	else
#endif // ! DPNBUILD_ONLYONEADAPTER
	{
		DPFX(DPFPREP, 7, "Completing all connects (including multiplexed).");


		pSocketData->Lock();
		fLockedSocketData = TRUE;


#ifndef DPNBUILD_ONLYONEADAPTER
		//
		// Attach a root node to the list of adapters.
		//
		blIndicate.InsertAfter(&(m_blMultiplex));


		//
		// Move this adapter to the failed list if it did fail to bind.
		//
		if (! fEndpointBound)
		{
			m_blMultiplex.RemoveFromList();
			m_blMultiplex.InsertBefore(&blFail);
		}


#ifndef DPNBUILD_NOICSADAPTERSELECTIONLOGIC
		//
		// Loop through all the remaining adapters in the list.
		//
		pBilinkAll = blIndicate.GetNext();
		while (pBilinkAll != &blIndicate)
		{
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);
			DNASSERT(pBilinkAll->GetNext() != pBilinkAll);


			//
			// THIS MUST BE CLEANED UP PROPERLY WITH AN INTERFACE CHANGE!
			//
			// The endpoint may have been returned to the pool and its associated
			// socketport pointer may have become NULL, or now be pointing to
			// something that's no longer valid.  So we try to handle NULL
			// pointers.  Obviously this is indicative of poor design, but it's
			// not possible to change this the correct way at this time.
			//

			
			//
			// If this is a NAT machine, then some adapters may be better than others
			// for reaching the desired address.  Particularly, it's better to use a
			// private adapter, which can directly reach the private network & be
			// mapped on the public network, than to use the public adapter.  It's not
			// fun to join a private game from an ICS machine while dialed up, have
			// your Internet connection go down, and lose the connection to the
			// private game which didn't (shouldn't) involve the Internet at all.  So
			// if we detect a public adapter when we have a perfectly good private
			// adapter, we'll fail connect attempts on the public one.
			//


			//
			// Cast to get rid of the const.  Don't worry, we won't actually change it.
			//
			pSocketAddress = (CSocketAddress*) pTempEndpoint->GetRemoteAddressPointer();
			psaddrinTemp = (SOCKADDR_IN*) pSocketAddress->GetAddress();
			pSocketPort = pTempEndpoint->GetSocketPort();


			//
			// If this item doesn't have a socketport, then it must have failed to bind.
			// We need to clean it up ourselves.
			//
			if (pSocketPort == NULL)
			{
				DPFX(DPFPREP, 3, "Endpoint 0x%p failed earlier, now completing.",
					pTempEndpoint);
				
				//
				// Get the next associated endpoint before we pull the current entry
				// from the list.
				//
				pBilinkAll = pBilinkAll->GetNext();

				//
				// Pull it out of the multiplex association list and move
				// it to the "early completion" list.
				//
				pTempEndpoint->RemoveFromMultiplexList();
				pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);

				//
				// Move to next iteration of loop.
				//
				continue;
			}

#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
			//
			// Detect if we've been given conflicting address families for our target
			// and our bound socket (see CSocketPort::BindEndpoint).
			//
			DNASSERT(pSocketPort->GetNetworkAddress() != NULL);
			if ( pSocketAddress->GetFamily() != pSocketPort->GetNetworkAddress()->GetFamily() )
			{
				DPFX(DPFPREP, 3, "Endpoint 0x%p (family %u) is targeting a different address family (%u), completing.",
					pTempEndpoint, pSocketPort->GetNetworkAddress()->GetFamily(), pSocketAddress->GetFamily());
				
				//
				// Get the next associated endpoint before we pull the current entry
				// from the list.
				//
				pBilinkAll = pBilinkAll->GetNext();

				//
				// Give the endpoint a meaningful error.
				//
				pTempEndpoint->SetPendingCommandResult(DPNERR_INVALIDDEVICEADDRESS);

				//
				// Pull it out of the multiplex association list and move
				// it to the "early completion" list.
				//
				pTempEndpoint->RemoveFromMultiplexList();
				pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);

				//
				// Move to next iteration of loop.
				//
				continue;
			}
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPV6
			//
			// Now handle some special IPv6 logic.
			//
			if (pSocketAddress->GetFamily() == AF_INET6)
			{
				SOCKADDR_IN6 *		psaddrinDevice;
				SOCKADDR_IN6 *		psaddrinRemote;


				psaddrinDevice = (SOCKADDR_IN6*) pSocketPort->GetNetworkAddress()->GetAddress();
				psaddrinRemote = (SOCKADDR_IN6*) pSocketAddress->GetAddress();
				
				if (! IN6_IS_ADDR_MULTICAST(&psaddrinRemote->sin6_addr))
				{
					BOOL	fDifferentScope;
					
						
					//
					// If this endpoint is targeting something which has a different address,
					// prefix scope, fail it.
					//
					
					fDifferentScope = FALSE;
					if (IN6_IS_ADDR_LINKLOCAL(&psaddrinDevice->sin6_addr))
					{
						if (! IN6_IS_ADDR_LINKLOCAL(&psaddrinRemote->sin6_addr))
						{
							fDifferentScope = TRUE;
						}
					}
					else if (IN6_IS_ADDR_SITELOCAL(&psaddrinDevice->sin6_addr))
					{
						if (! IN6_IS_ADDR_SITELOCAL(&psaddrinRemote->sin6_addr))
						{
							fDifferentScope = TRUE;
						}
					}
					else
					{
						if ((IN6_IS_ADDR_LINKLOCAL(&psaddrinRemote->sin6_addr)) ||
							(IN6_IS_ADDR_SITELOCAL(&psaddrinRemote->sin6_addr)))
						{
							fDifferentScope = TRUE;
						}
					}

					if (fDifferentScope)
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p is targeting address with different link-local/site-local/global scope, completing.",
							pTempEndpoint);
						
						//
						// Get the next associated endpoint before we pull the current entry
						// from the list.
						//
						pBilinkAll = pBilinkAll->GetNext();

						//
						// Give the endpoint a meaningful error.
						//
						pTempEndpoint->SetPendingCommandResult(DPNERR_INVALIDHOSTADDRESS);

						//
						// Pull it out of the multiplex association list and move
						// it to the "early completion" list.
						//
						pTempEndpoint->RemoveFromMultiplexList();
						pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);

						//
						// Move to next iteration of loop.
						//
						continue;
					}
				}
				else
				{
#ifndef DPNBUILD_NOMULTICAST
					//
					// Connects to multicast addresses should not be allowed!
					//
					DNASSERT(FALSE);
#endif // ! DPNBUILD_NOMULTICAST
				}
			}
#endif // ! DPNBUILD_NOIPV6

			//
			// See if this is an IP connect.
			//
			if (( pSocketAddress != NULL) &&
				( pSocketAddress->GetFamily() == AF_INET ))
			{
#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
				for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
				{
					if (pSocketPort->GetNATHelpPort(dwTemp) != NULL)
					{
						DNASSERT( g_papNATHelpObjects[dwTemp] != NULL );
						dwPublicAddressesSize = sizeof(saddrPublic);
						dwAddressTypeFlags = 0;
						hTempResult = IDirectPlayNATHelp_GetRegisteredAddresses(g_papNATHelpObjects[dwTemp],
																				pSocketPort->GetNATHelpPort(dwTemp),
																				&saddrPublic,
																				&dwPublicAddressesSize,
																				&dwAddressTypeFlags,
																				NULL,
																				0);
						if ((hTempResult != DPNH_OK) || (! (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)))
						{
							DPFX(DPFPREP, 7, "Socketport 0x%p is not locally mapped on gateway with NAT Help index %u (err = 0x%lx, flags = 0x%lx).",
								pSocketPort, dwTemp, hTempResult, dwAddressTypeFlags);
						}
						else
						{
							//
							// There is a local NAT.
							//
							DPFX(DPFPREP, 7, "Socketport 0x%p is locally mapped on gateway with NAT Help index %u (flags = 0x%lx), public address:",
								pSocketPort, dwTemp, dwAddressTypeFlags);
							DumpSocketAddress(7, &saddrPublic, AF_INET);
							

							//
							// Find the multiplexed connect on the public adapter that
							// we need to fail, as described above.
							//
							pBilinkPublic = blIndicate.GetNext();
							while (pBilinkPublic != &blIndicate)
							{
								pPublicEndpoint = CONTAINING_OBJECT(pBilinkPublic, CEndpoint, m_blMultiplex);
								DNASSERT(pBilinkPublic->GetNext() != pBilinkPublic);

								//
								// Don't bother checking the endpoint whose public
								// address we're seeking.
								//
								if (pPublicEndpoint != pTempEndpoint)
								{
									pPublicSocketPort = pPublicEndpoint->GetSocketPort();
									if ( pPublicSocketPort != NULL )
									{
										//
										// Cast to get rid of the const.  Don't worry, we won't
										// actually change it.
										//
										pSocketAddress = (CSocketAddress*) pPublicSocketPort->GetNetworkAddress();
										if ( pSocketAddress != NULL )
										{
											if ( pSocketAddress->CompareToBaseAddress( &saddrPublic ) == 0)
											{
												DPFX(DPFPREP, 3, "Endpoint 0x%p is multiplexed onto public adapter for endpoint 0x%p (current endpoint = 0x%p), failing public connect.",
													pTempEndpoint, pPublicEndpoint, this);

												//
												// Pull it out of the multiplex association list and move
												// it to the "fail" list.
												//
												pPublicEndpoint->RemoveFromMultiplexList();
												pPublicEndpoint->m_blMultiplex.InsertBefore(&blFail);

												break;
											}
											

											//
											// Otherwise, continue searching.
											//

											DPFX(DPFPREP, 8, "Endpoint 0x%p is multiplexed onto different adapter:",
												pPublicEndpoint);
											DumpSocketAddress(8, pSocketAddress->GetWritableAddress(), pSocketAddress->GetFamily());
										}
										else
										{
											DPFX(DPFPREP, 1, "Public endpoint 0x%p's socket port 0x%p is going away, skipping.",
												pPublicEndpoint, pPublicSocketPort);
										}
									}
									else
									{
										DPFX(DPFPREP, 1, "Public endpoint 0x%p is going away, skipping.",
											pPublicEndpoint);
									}
								}
								else
								{
									//
									// The same endpoint as the one whose
									// public address we're seeking.
									//
								}

								pBilinkPublic = pBilinkPublic->GetNext();
							}


							//
							// No need to search for any more NAT Help registrations.
							//
							break;
						} // end else (is mapped locally on Internet gateway)
					}
					else
					{
						//
						// No DirectPlay NAT Helper registration in this slot.
						//
					}
				} // end for (each DirectPlay NAT Helper)
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT

				//
				// NOTE: We should fail connects for non-optimal adapters even
				// when it's multiadapter but not a PAST/UPnP enabled NAT (see
				// ProcessEnumResponseData for WSAIoctl usage related to this).
				// We do not currently do this.  There can still be race conditions
				// for connects where the response for the "wrong" device arrives
				// first.
				//
			}
			else
			{
				//
				// Not IP address, or possibly the endpoint is shutting down.
				//
				DPFX(DPFPREP, 1, "Found non-IPv4 endpoint (possibly closing) (endpoint = 0x%p, socket address = 0x%p, socketport = 0x%p), not checking for local NAT mapping.",
					pTempEndpoint, pSocketAddress, pSocketPort);
			}


			//
			// Go to the next associated endpoint.  Although it's possible for
			// entries to have been removed from the list, the current entry
			// could not have been, so we're safe.
			//
			pBilinkAll = pBilinkAll->GetNext();
		}
#endif // ! DPNBUILD_NOICSADAPTERSELECTIONLOGIC
#endif // ! DPNBUILD_ONLYONEADAPTER


		//
		// Now loop through the remaining endpoints and indicate their
		// connections.
		//
#ifdef DPNBUILD_ONLYONEADAPTER
		if (fEndpointBound)
		{
			pTempEndpoint = this;
#else // ! DPNBUILD_ONLYONEADAPTER
		while (! blIndicate.IsEmpty())
		{
			pBilinkAll = blIndicate.GetNext();
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);
			DNASSERT(pBilinkAll->GetNext() != pBilinkAll);
#endif // ! DPNBUILD_ONLYONEADAPTER


			//
			// See notes above about NULL handling.
			//
			if (pTempEndpoint->m_pActiveCommandData != NULL)
			{
#ifndef DPNBUILD_ONLYONEADAPTER
				//
				// Pull it from the "indicate" list.
				//
				pTempEndpoint->RemoveFromMultiplexList();
#endif // ! DPNBUILD_ONLYONEADAPTER


				pTempEndpoint->m_pActiveCommandData->Lock();

				if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
				{
					pTempEndpoint->m_pActiveCommandData->Unlock();
					
					DPFX(DPFPREP, 3, "Connect 0x%p is cancelled, not indicating endpoint 0x%p.",
						pTempEndpoint->m_pActiveCommandData, pTempEndpoint);
					
#ifdef DPNBUILD_ONLYONEADAPTER
#else // ! DPNBUILD_ONLYONEADAPTER
					//
					// Put it on the list of connects to fail.
					//
					pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);
#endif // ! DPNBUILD_ONLYONEADAPTER
				}
				else
				{
					//
					// Mark the connect as uncancellable, since we're about to indicate
					// the connection.
					//
					pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						
					pTempEndpoint->m_pActiveCommandData->Unlock();


					//
					// Get a reference to keep the endpoint and command around while we
					// drop the socketport list lock.
					// Reuse fLockedSocketData to assert that we can add a command ref.
					//
					fLockedSocketData = pTempEndpoint->AddCommandRef();
					DNASSERT(fLockedSocketData);

					
					//
					// Drop the socket data lock.  It's safe since we pulled everything we
					// need off of the list that needs protection.
					//
					pSocketData->Unlock();
					fLockedSocketData = FALSE;

				
					//
					// Inform user of connection.  Assume that the user will accept and
					// everything will succeed so we can set the user context for the
					// endpoint.  If the connection fails, clear the user endpoint
					// context.
					//
					memset( &ConnectIndicationData, 0x00, sizeof( ConnectIndicationData ) );
					DBG_CASSERT( sizeof( ConnectIndicationData.hEndpoint ) == sizeof( this ) );
					ConnectIndicationData.hEndpoint = (HANDLE) pTempEndpoint;
					DNASSERT( pTempEndpoint->GetCommandParameters() != NULL );
					ConnectIndicationData.pCommandContext = pTempEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pvContext;
					pTempEndpoint->SetUserEndpointContext( NULL );
					hTempResult = pTempEndpoint->SignalConnect( &ConnectIndicationData );
					if ( hTempResult != DPN_OK )
					{
						DNASSERT( hTempResult == DPNERR_ABORTED );
						DPFX(DPFPREP, 1, "User refused connect in CompleteConnect (err = 0x%lx), completing connect with USERCANCEL.",
							hTempResult );
						DisplayDNError( 1, hTempResult );
						pTempEndpoint->SetUserEndpointContext( NULL );


						//
						// Retake the socket data lock so we can modify list linkage.
						//
						pSocketData->Lock();
						fLockedSocketData = TRUE;

						
#ifdef DPNBUILD_ONLYONEADAPTER
						//
						// Remember that we're failing.
						//
						fEndpointBound = FALSE;
#else // ! DPNBUILD_ONLYONEADAPTER
						//
						// Put it on the list of connects to fail.
						//
						pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);
#endif // ! DPNBUILD_ONLYONEADAPTER


						//
						// Mark the connect as cancelled so that we complete with
						// the right error code.
						//
						pTempEndpoint->m_pActiveCommandData->Lock();
						DNASSERT( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
						pTempEndpoint->m_pActiveCommandData->Unlock();


						//
						// Drop the reference.
						// Note: SocketPort lock is still held, but since the command was
						// marked as uncancellable, this should not cause the endpoint to
						// get unbound yet, and thus we shouldn't reenter the
						// socketportdata lock.
						//
						pTempEndpoint->DecCommandRef();
					}
					else
					{
						//
						// We're done and everyone's happy, complete the command.
						// This will clear all of our internal command data.
						//
						pTempEndpoint->CompletePendingCommand( hTempResult );
						DNASSERT( pTempEndpoint->GetCommandParameters() == NULL );
						DNASSERT( pTempEndpoint->m_pActiveCommandData == NULL );


						//
						// Drop the reference (may result in endpoint unbinding).
						//
						pTempEndpoint->DecCommandRef();


						//
						// Retake the socket data lock in preparation for the next item.
						//
						pSocketData->Lock();
						fLockedSocketData = TRUE;
					}
				}
			}
			else
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
					pTempEndpoint);
			}

			
			//
			// Go to the next associated endpoint.
			//
		}



		//
		// Finally loop through all the connects that need to fail and do
		// just that.
		//
#ifdef DPNBUILD_ONLYONEADAPTER
		if (! fEndpointBound)
		{
			pTempEndpoint = this;
#else // ! DPNBUILD_ONLYONEADAPTER
		while (! blFail.IsEmpty())
		{
			pBilinkAll = blFail.GetNext();
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);
			DNASSERT(pBilinkAll->GetNext() != pBilinkAll);


			//
			// Pull it from the "fail" list.
			//
			pTempEndpoint->RemoveFromMultiplexList();
#endif // ! DPNBUILD_ONLYONEADAPTER

			//
			// Get a reference to keep the endpoint around while we drop the
			// socketport list lock.
			//
			pTempEndpoint->AddRef();

			//
			// Drop the socket data lock.  It's safe since we pulled everything we
			// need off of the list that needs protection.
			//
			pSocketData->Unlock();
			fLockedSocketData = FALSE;


			//
			// See notes above about NULL handling.
			//
			if (pTempEndpoint->m_pActiveCommandData != NULL)
			{
				//
				// Complete it (by closing this endpoint).  Be considerate about the error
				// code expected by our caller.
				//

				pTempEndpoint->m_pActiveCommandData->Lock();

				if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
				{
					pTempEndpoint->m_pActiveCommandData->Unlock();
					
					DPFX(DPFPREP, 3, "Connect 0x%p command (endpoint 0x%p) is already cancelled.",
						pTempEndpoint->m_pActiveCommandData, pTempEndpoint);

					hTempResult = DPNERR_USERCANCEL;
				}
				else
				{
					//
					// Mark the connect as uncancellable, since we're about to complete
					// it with a failure.
					//
					if ( pTempEndpoint->m_pActiveCommandData->GetState() != COMMAND_STATE_INPROGRESS_CANNOT_CANCEL )
					{
						pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
					}


					//
					// Retrieve the current command result.
					//
					hTempResult = pTempEndpoint->PendingCommandResult();
					
					pTempEndpoint->m_pActiveCommandData->Unlock();


					//
					// If the command didn't have a descriptive error, assume it was
					// not previously set (i.e. wasn't overridden by BindEndpoint above),
					// and use NOCONNECTION instead.
					//
					if ( hTempResult == DPNERR_GENERIC )
					{
						hTempResult = DPNERR_NOCONNECTION;
					}
				
					DPFX(DPFPREP, 6, "Completing endpoint 0x%p connect (command 0x%p) with error 0x%lx.",
						pTempEndpoint, pTempEndpoint->m_pActiveCommandData, hTempResult);
				}

				pTempEndpoint->Lock();
				switch ( pTempEndpoint->GetState() )
				{
					case ENDPOINT_STATE_UNINITIALIZED:
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p is already completely closed.",
							pTempEndpoint);
						pTempEndpoint->Unlock();
						break;
					}
					
					case ENDPOINT_STATE_ATTEMPTING_CONNECT:
					case ENDPOINT_STATE_CONNECT_CONNECTED:
					{
						pTempEndpoint->SetState(ENDPOINT_STATE_DISCONNECTING);
						pTempEndpoint->Unlock();
						pTempEndpoint->Close( hTempResult );
						pTempEndpoint->m_pSPData->CloseEndpointHandle( pTempEndpoint );
						break;
					}

					case ENDPOINT_STATE_DISCONNECTING:
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p already disconnecting, not closing.",
							pTempEndpoint);
						pTempEndpoint->Unlock();
						break;
					}

					default:
					{
						DPFX(DPFPREP, 0, "Endpoint 0x%p is invalid state %u!",
							pTempEndpoint, pTempEndpoint->GetState());
						DNASSERT(FALSE);
						pTempEndpoint->Unlock();
						break;
					}
				}
			}
			else
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
					pTempEndpoint);
			}

			//
			// Drop the reference we used with the socketport list lock dropped.
			//
			pTempEndpoint->DecRef();


			//
			// Retake the socket data lock and go to next item.
			//
			pSocketData->Lock();
			fLockedSocketData = TRUE;
		}


		pSocketData->Unlock();
		fLockedSocketData = FALSE;
	}


Exit:

	if ( pSocketData != NULL )
	{
		pSocketData->Release();
		pSocketData = NULL;
	}
	
	if ( ConnectAddressInfo.pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( ConnectAddressInfo.pHostAddress );
		ConnectAddressInfo.pHostAddress = NULL;
	}

	if ( ConnectAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( ConnectAddressInfo.pDeviceAddress );
		ConnectAddressInfo.pDeviceAddress = NULL;
	}

	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );

	DNASSERT( pHostAddress != NULL );
	IDirectPlay8Address_Release( pHostAddress );


	DNASSERT( !fLockedSocketData );

#ifndef DPNBUILD_ONLYONEADAPTER
	DNASSERT(blIndicate.IsEmpty());
	DNASSERT(blFail.IsEmpty());
#endif // ! DPNBUILD_ONLYONEADAPTER

	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:

	//
	// If we still have the socket data lock, drop it.
	//
	if ( fLockedSocketData )
	{
		pSocketData->Unlock();
		fLockedSocketData = FALSE;
	}
	
	//
	// we've failed to complete the connect, clean up and return this endpoint
	// to the pool
	//
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// CEndpoint::ConnectBlockingJobWrapper - asynchronous callback wrapper for blocking job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ConnectBlockingJobWrapper"

void	CEndpoint::ConnectBlockingJobWrapper( void * const pvContext )
{
	CEndpoint	*pThisEndpoint;


	// initialize
	DNASSERT( pvContext != NULL );
	pThisEndpoint = static_cast<CEndpoint*>( pvContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );

	pThisEndpoint->ConnectBlockingJob();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ConnectBlockingJob - complete connect blocking job
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ConnectBlockingJob"

void	CEndpoint::ConnectBlockingJob( void )
{
	HRESULT			hr;


	//
	// Try to resolve the host name.  It's possible we already did this
	// when we first opened the endpoint, and we only need to resolve
	// the hostname, but it's simpler to just do it all again anyway.
	//
	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost,
#ifdef DPNBUILD_XNETSECURITY
																((m_fSecureTransport) ? &m_ullKeyID : NULL),
#endif // DPNBUILD_XNETSECURITY
																TRUE,
																SP_ADDRESS_TYPE_HOST );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Couldn't get valid address!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	
	//
	// Make sure its valid and not banned.
	//
	if (! m_pRemoteMachineAddress->IsValidUnicastAddress(FALSE))
	{
		DPFX(DPFPREP, 0, "Host address is invalid!");
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto Failure;
	}

#ifndef DPNBUILD_NOREGISTRY
	if (m_pRemoteMachineAddress->IsBannedAddress())
	{
		DPFX(DPFPREP, 0, "Host address is banned!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}
#endif // ! DPNBUILD_NOREGISTRY

	//
	// Make sure the user isn't trying to connect to the DPNSVR port.
	//
	if ( m_pRemoteMachineAddress->GetPort() == HTONS(DPNA_DPNSVR_PORT) )
	{
		DPFX(DPFPREP, 0, "Attempting to connect to DPNSVR reserved port!" );
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto Failure;
	}

#ifndef DPNBUILD_NONATHELP
	//
	// Try to get NAT help loaded, if it isn't already and we're allowed.
	//
	if (GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE)
	{
		DPFX(DPFPREP, 7, "Ensuring that NAT help is loaded.");
		m_pSPData->GetThreadPool()->EnsureNATHelpLoaded();
	}
#endif // ! DPNBUILD_NONATHELP

Exit:

	//
	// Submit the job for completion (for real).  We want it to occur on
	// a thread pool thread so that the user has gotten notified about the
	// thread prior to getting a callback on it.  We do it in even the failure
	// case.
	//
	// NOTE: If this fails, we will rely on the caller that triggered the original
	// operation to cancel the command at some point, probably when he
	// decides the operation is taking too long.
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::ConnectJobCallback,
														this );
#else // ! DPNBUILD_ONLYONEPROCESSOR
	hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( -1,								// we don't know the CPU yet, so pick any
														CEndpoint::ConnectJobCallback,
														this );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to queue delayed connect completion!  Operation must be cancelled." );
		DisplayDNError( 0, hr );

		//
		// Leave endpoint reference, see notes above.
		//
	}

	return;

Failure:

	//
	// Attempt to attach the failure code to the command.  If the user was
	// already cancelling this command, we will just leave the command alone.
	//
	m_pActiveCommandData->Lock();
	if (m_pActiveCommandData->GetState() != COMMAND_STATE_CANCELLING)
	{
		DNASSERT(m_pActiveCommandData->GetState() == COMMAND_STATE_PENDING);
		m_pActiveCommandData->SetState(COMMAND_STATE_FAILING);
		m_hrPendingCommandResult = hr;
	}
	else
	{
		DPFX(DPFPREP, 0, "User cancelled command, ignoring failure result 0x%lx.",
			hr);
	}
	m_pActiveCommandData->Unlock();

	goto Exit;
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYONETHREAD


//**********************************************************************
// ------------------------------
// CEndpoint::Disconnect - disconnect an endpoint
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Notes:	This function assumes that the endpoint is locked.  If this
//			function completes successfully (returns DPN_OK), the endpoint
//			is no longer locked (it was returned to the pool).
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Disconnect"

HRESULT	CEndpoint::Disconnect( void )
{
	HRESULT	hr;


	DPFX(DPFPREP, 6, "(0x%p) Enter", this);

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPNERR_PENDING;

	Lock();
	switch ( GetState() )
	{
		//
		// connected endpoint
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			DNASSERT( GetCommandParameters() == NULL );
			DNASSERT( m_pActiveCommandData == NULL );

			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();

			//
			// Unlock this endpoint before calling to a higher level.  The endpoint
			// has already been labeled as DISCONNECTING so nothing will happen to it.
			//
			Unlock();

			//
			// Need to release the reference that was added for the connection at this
			// point or the endpoint will never be returned to the pool.
			//
			DecRef();

			//
			// release reference from just after setting state
			//
			Close( DPN_OK );
			DecCommandRef();
			DecRef();

			break;
		}

		//
		// some other endpoint state
		//
		default:
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPFX(DPFPREP, 0, "Attempted to disconnect endpoint that's not connected!" );
			switch ( m_State )
			{
				case ENDPOINT_STATE_UNINITIALIZED:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_UNINITIALIZED" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_CONNECT:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_ATTEMPTING_CONNECT" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_LISTEN:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_ATTEMPTING_LISTEN" );
					break;
				}

				case ENDPOINT_STATE_ENUM:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_ENUM" );
					break;
				}

				case ENDPOINT_STATE_DISCONNECTING:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_DISCONNECTING" );
					break;
				}

				case ENDPOINT_STATE_WAITING_TO_COMPLETE:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_WAITING_TO_COMPLETE" );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			Unlock();
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}

Exit:
	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:
	// nothing to do
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::StopEnumCommand - stop a running enum command
//
// Entry:		Command result
//
// Exit:		Nothing
//
// Notes:	This function assumes that the endpoint is locked.  If this
//			function completes successfully (returns DPN_OK), the endpoint
//			is no longer locked (it was returned to the pool).
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::StopEnumCommand"

void	CEndpoint::StopEnumCommand( const HRESULT hCommandResult )
{
	Lock();

#ifndef DPNBUILD_NOSPUI
	if ( GetActiveDialogHandle() != NULL )
	{
		StopSettingsDialog( GetActiveDialogHandle() );
		Unlock();
	}
	else
#endif // !DPNBUILD_NOSPUI
	{
		BOOL	fStoppedJob;

		
		//
		// Don't hold the lock when cancelling a timer job because the
		// job might be in progress and attempting to use this endpoint!
		//
		Unlock();
		fStoppedJob = m_pSPData->GetThreadPool()->StopTimerJob( m_pActiveCommandData, hCommandResult );
		if ( ! fStoppedJob )
		{
			//
			// Either the endpoint just completed or it had never been started.
			// Check the state to determine which of those scenarios happened.
			//
			Lock();	
			if ( GetState() == ENDPOINT_STATE_ATTEMPTING_ENUM )
			{
				//
				// This is a multiplexed enum that is getting cancelled.  We
				// need to complete it.
				//
				Unlock();

				DPFX(DPFPREP, 1, "Endpoint 0x%p completing unstarted multiplexed enum (context/command 0x%p) with result 0x%lx.",
					this, m_pActiveCommandData, hCommandResult);

				EnumComplete( hCommandResult );
			}
			else
			{
				Unlock();

				//
				// The enum is in progress, it should detect that it needs to
				// be cancelled.  We don't need to do any work here.
				//
				DPFX(DPFPREP, 1, "Endpoint 0x%p unable to stop timer job (context/command 0x%p, state = %u, result would have been 0x%lx).",
					this, m_pActiveCommandData, GetState(), hCommandResult);
			}
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyListenData - copy data for listen command
//
// Entry:		Pointer to job information
//				Pointer to device address
//
// Exit:		Error code
//
// Note:	Device address needs to be preserved for later use.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyListenData"

HRESULT	CEndpoint::CopyListenData( const SPLISTENDATA *const pListenData, IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT	hr;
	ENDPOINT_COMMAND_PARAMETERS	*pCommandParameters;

	
	DNASSERT( pListenData != NULL );
	DNASSERT( pDeviceAddress != NULL );
	
	DNASSERT( pListenData->hCommand != NULL );
	DNASSERT( pListenData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_pActiveCommandData == NULL );
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;
	pCommandParameters = NULL;

	pCommandParameters = (ENDPOINT_COMMAND_PARAMETERS*)g_EndpointCommandParametersPool.Get();
	if ( pCommandParameters != NULL )
	{
		SetCommandParameters( pCommandParameters );

		DBG_CASSERT( sizeof( pCommandParameters->PendingCommandData.ListenData ) == sizeof( *pListenData ) );
		memcpy( &pCommandParameters->PendingCommandData.ListenData, pListenData, sizeof( pCommandParameters->PendingCommandData.ListenData ) );
		pCommandParameters->PendingCommandData.ListenData.pAddressDeviceInfo = pDeviceAddress;
		IDirectPlay8Address_AddRef( pDeviceAddress );

		m_fListenStatusNeedsToBeIndicated = TRUE;
		m_pActiveCommandData = static_cast<CCommandData*>( pCommandParameters->PendingCommandData.ListenData.hCommand );
		m_State = ENDPOINT_STATE_ATTEMPTING_LISTEN;
		
		DNASSERT( hr == DPN_OK );
	}
	else
	{
		hr = DPNERR_OUTOFMEMORY;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ListenJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ListenJobCallback"

void	CEndpoint::ListenJobCallback( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	// initialize
	DNASSERT( pvContext != NULL );
	pThisEndpoint = static_cast<CEndpoint*>( pvContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteListen();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem completing listen in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteListen - complete listen process
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteListen"

HRESULT	CEndpoint::CompleteListen( void )
{
	HRESULT							hr;
	HRESULT							hTempResult;
	SPIE_LISTENSTATUS				ListenStatus;
	BOOL							fEndpointLocked;
	SPIE_LISTENADDRESSINFO			ListenAddressInfo;
	IDirectPlay8Address *			pDeviceAddress;
	ENDPOINT_COMMAND_PARAMETERS *	pCommandParameters;


	DPFX(DPFPREP, 6, "(0x%p) Enter", this);
	
	DNASSERT( GetCommandParameters() != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
	memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
	pCommandParameters = GetCommandParameters();

	//
	// Transfer address reference to the local pointer.  This will be released at the
	// end of this function, but we'll keep the pointer in the pending command data so
	// CSPData::BindEndpoint can still access it.
	//

	pDeviceAddress = pCommandParameters->PendingCommandData.ListenData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );


	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( pCommandParameters->PendingCommandData.ListenData.hCommand == m_pActiveCommandData );
	DNASSERT( pCommandParameters->PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );

#ifdef DBG
	if (pCommandParameters->PendingCommandData.ListenData.dwFlags & DPNSPF_BINDLISTENTOGATEWAY)
	{
		DNASSERT( pCommandParameters->GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC_SHARED );
	}
	else
	{
		DNASSERT( pCommandParameters->GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN );
	}
#endif // DBG


	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

#ifdef DPNBUILD_NOMULTICAST
	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_LISTEN );
#else // ! DPNBUILD_NOMULTICAST
	DNASSERT( (m_pActiveCommandData->GetType() == COMMAND_TYPE_LISTEN) || (m_pActiveCommandData->GetType() == COMMAND_TYPE_MULTICAST_LISTEN) );
#endif // ! DPNBUILD_NOMULTICAST
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is pending, mark as in-progress
		//
		case COMMAND_STATE_PENDING:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
			
			Lock();
			fEndpointLocked = TRUE;
			
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP, 0, "User cancelled listen!" );

			break;
		}
		
#ifndef DPNBUILD_ONLYONETHREAD
		//
		// blocking operation failed
		//
		case COMMAND_STATE_FAILING:
		{
			hr = m_hrPendingCommandResult;
			DNASSERT(hr != DPN_OK);
			DPFX(DPFPREP, 0, "Listen blocking operation failed!" );

			break;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		//
		// other state
		//
		default:
		{
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// note that this endpoint is officially listening before adding it to the
	// socket port because it may get used immediately.
	// Also note that the GATEWAY_BIND_TYPE actually used
	// (GetGatewayBindType()) may differ from
	// pCommandParameters->GatewayBindType.
	//
	m_State = ENDPOINT_STATE_LISTEN;

	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, pCommandParameters->GatewayBindType );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}


	//
	// attempt to indicate addressing to a higher layer
	//
#ifdef DPNBUILD_XNETSECURITY
	ListenAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, NULL, GetGatewayBindType() );
#else // ! DPNBUILD_XNETSECURITY
	ListenAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, GetGatewayBindType() );
#endif // ! DPNBUILD_XNETSECURITY
	if ( ListenAddressInfo.pDeviceAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

#ifndef DPNBUILD_NOMULTICAST
	//
	// For multicast listens, we also need to include the multicast address
	// being used.
	//
	if ( GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN )
	{
		const SOCKADDR_IN *		psaddrinTemp;
		TCHAR					tszMulticastAddress[16]; // nnn.nnn.nnn.nnn + NULL termination


		DNASSERT( GetRemoteAddressPointer()->GetFamily() == AF_INET );
		psaddrinTemp = (const SOCKADDR_IN *) GetRemoteAddressPointer()->GetAddress();
		wsprintf(tszMulticastAddress, _T("%u.%u.%u.%u"),
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b4);

		//
		// Add the host name component to the device address.
		//
#ifdef UNICODE
		hr = IDirectPlay8Address_AddComponent( ListenAddressInfo.pDeviceAddress,
											DPNA_KEY_HOSTNAME,
											tszMulticastAddress,
											((_tcslen(tszMulticastAddress) + 1) * sizeof(TCHAR)),
											DPNA_DATATYPE_STRING );
#else // ! UNICODE
		hr = IDirectPlay8Address_AddComponent( ListenAddressInfo.pDeviceAddress,
											DPNA_KEY_HOSTNAME,
											tszMulticastAddress,
											((_tcslen(tszMulticastAddress) + 1) * sizeof(TCHAR)),
											DPNA_DATATYPE_STRING_ANSI );
#endif // ! UNICODE
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed to add hostname component to device address!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
#endif // ! DPNBUILD_NOMULTICAST


	//
	// Listens are not affected by the same multiplexed adapter problems (see
	// CompleteConnect and CompleteEnumQuery), so we don't need that workaround
	// code.
	//

	Unlock();
	fEndpointLocked = FALSE;


Exit:
	//
	// report the listen address info and status
	//
	if ( m_fListenStatusNeedsToBeIndicated != FALSE )
	{
		m_fListenStatusNeedsToBeIndicated = FALSE;
		
		//
		// If we don't currently have a device address object, just use the one passed
		// in to the Listen call.
		//
		if (ListenAddressInfo.pDeviceAddress == NULL)
		{
			IDirectPlay8Address_AddRef( pCommandParameters->PendingCommandData.ListenData.pAddressDeviceInfo );
			ListenAddressInfo.pDeviceAddress = pCommandParameters->PendingCommandData.ListenData.pAddressDeviceInfo;
		}
		ListenAddressInfo.hCommandStatus = hr;
		ListenAddressInfo.pCommandContext = pCommandParameters->PendingCommandData.ListenData.pvContext;


		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENADDRESSINFO 0x%p to interface 0x%p.",
			this, &ListenAddressInfo, m_pSPData->DP8SPCallbackInterface());
		DumpAddress( 8, _T("\t Device:"), ListenAddressInfo.pDeviceAddress );
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
													SPEV_LISTENADDRESSINFO,					// event type
													&ListenAddressInfo						// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENADDRESSINFO [0x%lx].",
			this, hTempResult);

		DNASSERT( hTempResult == DPN_OK );
	

		ListenStatus.hResult = hr;
		DNASSERT( m_pActiveCommandData == pCommandParameters->PendingCommandData.ListenData.hCommand );
		ListenStatus.hCommand = pCommandParameters->PendingCommandData.ListenData.hCommand;
		ListenStatus.pUserContext = pCommandParameters->PendingCommandData.ListenData.pvContext;
		ListenStatus.hEndpoint = (HANDLE) this;

		//
		// if the listen binding failed, there's no socket port to dereference so
		// return GUID_NULL as set by the memset.
		//
		if ( GetSocketPort() != NULL )
		{
			GetSocketPort()->GetNetworkAddress()->GuidFromInternalAddressWithoutPort( &ListenStatus.ListenAdapter );
		}

		//
		// it's possible that this endpoint was cleaned up so its internal pointers to the
		// COM and data interfaces may have been wiped, use the cached pointer
		//

		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENSTATUS 0x%p to interface 0x%p.",
			this, &ListenStatus, m_pSPData->DP8SPCallbackInterface());
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);
		
		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callback interface
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENSTATUS [0x%lx].",
			this, hTempResult);
		
		DNASSERT( hTempResult == DPN_OK );

		//
		// if we succeeded, start allowing enumerations to be handled
		//
		if ( GetSocketPort() != NULL )
		{
			SetEnumsAllowedOnListen( TRUE, FALSE );
		}
	}

	if ( ListenAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( ListenAddressInfo.pDeviceAddress );
		ListenAddressInfo.pDeviceAddress = NULL;
	}
	
	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );

	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:
	//
	// we've failed to complete the listen, clean up and return this
	// endpoint to the pool
	//
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// CEndpoint::ListenBlockingJobWrapper - asynchronous callback wrapper for blocking job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ListenBlockingJobWrapper"

void	CEndpoint::ListenBlockingJobWrapper( void * const pvContext )
{
	CEndpoint	*pThisEndpoint;


	// initialize
	DNASSERT( pvContext != NULL );
	pThisEndpoint = static_cast<CEndpoint*>( pvContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo != NULL );

	pThisEndpoint->ListenBlockingJob();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ListenBlockingJob - complete listen blocking job
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ListenBlockingJob"

void	CEndpoint::ListenBlockingJob( void )
{
	HRESULT		hr;


#ifndef DPNBUILD_NONATHELP
	//
	// Try to get NAT help loaded, if it isn't already and we're allowed.
	//
	if (GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE)
	{
		DPFX(DPFPREP, 7, "Ensuring that NAT help is loaded.");
		m_pSPData->GetThreadPool()->EnsureNATHelpLoaded();
	}
#endif // ! DPNBUILD_NONATHELP

	//
	// Submit the job for completion (for real).  We want it to occur on
	// a thread pool thread so that the user has gotten notified about the
	// thread prior to getting a callback on it.
	//
	// NOTE: If this fails, we will rely on the caller that triggered the original
	// operation to cancel the command at some point, probably when he
	// decides the operation is taking too long.  We leave the endpoint
	// reference.
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::ListenJobCallback,
														this );
#else // ! DPNBUILD_ONLYONEPROCESSOR
	hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( -1,								// we don't know the CPU yet, so pick any
														CEndpoint::ListenJobCallback,
														this );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to queue delayed listen completion!  Operation must be cancelled." );
		DisplayDNError( 0, hr );

		//
		// Leave endpoint reference, see notes above.
		//
	}
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYONETHREAD


//**********************************************************************
// ------------------------------
// CEndpoint::CopyEnumQueryData - copy data for enum query command
//
// Entry:		Pointer to command data
//
// Exit:		Error code
//
// Note:	Device address needs to be preserved for later use.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyEnumQueryData"

HRESULT	CEndpoint::CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData )
{
	HRESULT	hr;
	ENDPOINT_COMMAND_PARAMETERS	*pCommandParameters;


	DNASSERT( pEnumQueryData != NULL );

	DNASSERT( pEnumQueryData->hCommand != NULL );
	DNASSERT( pEnumQueryData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_pActiveCommandData == NULL );
	
	//
	// initialize
	//
	hr = DPN_OK;
	pCommandParameters = NULL;

	pCommandParameters = (ENDPOINT_COMMAND_PARAMETERS*)g_EndpointCommandParametersPool.Get();
	if ( pCommandParameters != NULL )
	{
		SetCommandParameters( pCommandParameters );

		DBG_CASSERT( sizeof( pCommandParameters->PendingCommandData.EnumQueryData ) == sizeof( *pEnumQueryData ) );
		memcpy( &pCommandParameters->PendingCommandData.EnumQueryData, pEnumQueryData, sizeof( pCommandParameters->PendingCommandData.EnumQueryData ) );

		pCommandParameters->PendingCommandData.EnumQueryData.pAddressHost = pEnumQueryData->pAddressHost;
		IDirectPlay8Address_AddRef( pEnumQueryData->pAddressHost );

		pCommandParameters->PendingCommandData.EnumQueryData.pAddressDeviceInfo = pEnumQueryData->pAddressDeviceInfo;
		IDirectPlay8Address_AddRef( pEnumQueryData->pAddressDeviceInfo );

		m_pActiveCommandData = static_cast<CCommandData*>( pCommandParameters->PendingCommandData.EnumQueryData.hCommand );
		m_pActiveCommandData->SetUserContext( pEnumQueryData->pvContext );
		m_State = ENDPOINT_STATE_ATTEMPTING_ENUM;
	
		DNASSERT( hr == DPN_OK );
	}
	else
	{
		hr = DPNERR_OUTOFMEMORY;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumQueryJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryJobCallback"

void	CEndpoint::EnumQueryJobCallback( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	// initialize
	DNASSERT( pvContext != NULL );
	pThisEndpoint = static_cast<CEndpoint*>( pvContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteEnumQuery();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem completing enum query in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned to the pool!!!!
	//
Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CEndpoint::CompleteEnumQuery - complete enum query process
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteEnumQuery"

HRESULT	CEndpoint::CompleteEnumQuery( void )
{
	HRESULT							hr;
	HRESULT							hTempResult;
	BOOL							fEndpointLocked;
	BOOL							fEndpointBound;
	UINT_PTR						uRetryCount;
	BOOL							fRetryForever;
	DWORD							dwRetryInterval;
	BOOL							fWaitForever;
	DWORD							dwIdleTimeout;
	SPIE_ENUMADDRESSINFO			EnumAddressInfo;
	IDirectPlay8Address *			pHostAddress;
	IDirectPlay8Address *			pDeviceAddress;
	GATEWAY_BIND_TYPE				GatewayBindType;
	DWORD							dwEnumQueryFlags;
	CEndpoint *						pTempEndpoint;
	CSocketData *					pSocketData;
	BOOL							fLockedSocketData;
#ifndef DPNBUILD_ONLYONEADAPTER
	MULTIPLEXEDADAPTERASSOCIATION	maa;
	DWORD							dwComponentSize;
	DWORD							dwComponentType;
	CBilink *						pBilinkEnd;
	CBilink *						pBilinkAll;
	CBilink *						pBilinkNext;
	CBilink							blInitiate;
	CBilink							blCompleteEarly;
#ifndef DPNBUILD_NOICSADAPTERSELECTIONLOGIC
	CSocketPort *					pSocketPort;
	CSocketAddress *				pSocketAddress;
	SOCKADDR_IN *					psaddrinTemp;
#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
	SOCKADDR						saddrPublic;
	CBilink *						pBilinkPublic;
	CEndpoint *						pPublicEndpoint;
	CSocketPort *					pPublicSocketPort;
	DWORD							dwTemp;
	DWORD							dwPublicAddressesSize;
	DWORD							dwAddressTypeFlags;
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT
#endif // ! DPNBUILD_NOICSADAPTERSELECTIONLOGIC
#endif // ! DPNBUILD_ONLYONEADAPTER


	DNASSERT( GetCommandParameters() != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Enter", this);
	
	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	fEndpointBound = FALSE;
	dwIdleTimeout = 0;
	memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );

	DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );

	//
	// Transfer address references to our local pointers.  These will be released
	// at the end of this function, but we'll keep the pointers in the pending command
	// data so CSPData::BindEndpoint can still access them.
	//

	pHostAddress = GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost;
	DNASSERT( pHostAddress != NULL );

	pDeviceAddress = GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );


	//
	// Retrieve other parts of the command parameters for convenience.
	//
	GatewayBindType = GetCommandParameters()->GatewayBindType;
	dwEnumQueryFlags = GetCommandParameters()->PendingCommandData.EnumQueryData.dwFlags;


#ifndef DPNBUILD_ONLYONEADAPTER
	blInitiate.Initialize();
	blCompleteEarly.Initialize();
#endif // ! DPNBUILD_ONLYONEADAPTER
	pSocketData = NULL;
	fLockedSocketData = FALSE;


	DNASSERT( m_pSPData != NULL );

	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.hCommand == m_pActiveCommandData );
	DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	DNASSERT( GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN );


	//
	// Since this endpoint will be passed off to the timer thread, add a reference
	// for the thread.  If the handoff fails, DecRef()
	//
	AddRef();


	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_ENUM_QUERY );
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is still pending, that's good
		//
		case COMMAND_STATE_PENDING:
		{
			Lock();
			fEndpointLocked = TRUE;
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP, 0, "User cancelled enum query!" );

			break;
		}
		
#ifndef DPNBUILD_ONLYONETHREAD
		//
		// blocking operation failed
		//
		case COMMAND_STATE_FAILING:
		{
			hr = m_hrPendingCommandResult;
			DNASSERT(hr != DPN_OK);
			DPFX(DPFPREP, 0, "Enum query blocking operation failed!" );

			break;
		}
#endif // ! DPNBUILD_ONLYONETHREAD
	
		//
		// command is in progress (probably came here from a dialog), mark it
		// as pending
		//
		case COMMAND_STATE_INPROGRESS:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_PENDING );
			
			Lock();
			fEndpointLocked = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// Note that the GATEWAY_BIND_TYPE actually used (GetGatewayBindType())
	// may differ from GatewayBindType.
	//
	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GatewayBindType );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind endpoint (err = 0x%lx)!", hr );
		DisplayDNError( 0, hr );

		//
		// We failed, but we'll continue through to indicate the address info and
		// add it to the multiplex list.
		//

		EnumAddressInfo.pHostAddress = GetRemoteHostDP8Address();
		if ( EnumAddressInfo.pHostAddress == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		//
		// Just regurgitate the device address we were given initially.
		//
		IDirectPlay8Address_AddRef(pDeviceAddress);
		EnumAddressInfo.pDeviceAddress = pDeviceAddress;
		EnumAddressInfo.hCommandStatus = hr;
		EnumAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();
		
		SetPendingCommandResult( hr );
		hr = DPN_OK;

		//
		// Note that the endpoint is not bound!
		//
		DNASSERT(GetSocketPort() == NULL);
	}
	else
	{
		fEndpointBound = TRUE;


#ifdef DPNBUILD_XNETSECURITY
		EnumAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, NULL, GetGatewayBindType() );
#else // ! DPNBUILD_XNETSECURITY
		EnumAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, GetGatewayBindType() );
#endif // ! DPNBUILD_XNETSECURITY
		EnumAddressInfo.pHostAddress = GetRemoteHostDP8Address();
		EnumAddressInfo.hCommandStatus = DPN_OK;
		EnumAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

		if ( ( EnumAddressInfo.pHostAddress == NULL ) ||
			 ( EnumAddressInfo.pDeviceAddress == NULL ) )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	}


	//
	// Retrieve the socket data.  Bind endpoint should have created the object or
	// returned a failure, so we won't handle the error case here.
	//
	pSocketData = m_pSPData->GetSocketDataRef();
	DNASSERT(pSocketData != NULL);


#ifndef DPNBUILD_ONLYONEADAPTER
	//
	// We can run into problems with "multiplexed" device attempts when you are on
	// a NAT machine.  The core will try enuming on multiple adapters, but since
	// we are on the network boundary, each adapter can see and get responses from
	// both networks.  This causes problems with peer-to-peer sessions when the
	// "wrong" adapter gets selected (because it receives a response first).  To
	// prevent that, we are going to internally remember the association between
	// the multiplexed Enums so we can decide on the fly whether to indicate a
	// response or not.  Obviously this workaround/decision logic relies on having
	// internal knowledge of what the upper layer would be doing...
	//
	// So either build or add to the linked list of multiplexed Enums.
	// Technically this is only necessary for IP, since IPX can't have NATs, but
	// what's the harm in having a little extra info?
	//
	dwComponentSize = sizeof(maa);
	dwComponentType = 0;
	hTempResult = IDirectPlay8Address_GetComponentByName( pDeviceAddress,									// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component buffer
														&dwComponentSize,									// component size
														&dwComponentType									// component type
														);
	if (( hTempResult == DPN_OK ) && ( dwComponentSize == sizeof(MULTIPLEXEDADAPTERASSOCIATION) ) && ( dwComponentType == DPNA_DATATYPE_BINARY ))
	{
		//
		// We found the right component type.  See if it matches the right
		// CSPData object.
		//
		if ( maa.pSPData == m_pSPData )
		{
			pSocketData->Lock();
			//fLockedSocketData = TRUE;

			pTempEndpoint = CONTAINING_OBJECT(maa.pBilink, CEndpoint, m_blMultiplex);

			
			//
			// Make sure the endpoint is still around/valid.
			//
			// THIS MAY CRASH IF OBJECT POOLING IS DISABLED!
			//
			if ( pTempEndpoint->GetEndpointID() == maa.dwEndpointID )
			{
				DPFX(DPFPREP, 3, "Found correctly formed private multiplexed adapter association key, linking endpoint 0x%p with earlier enums (prev endpoint = 0x%p).",
					this, pTempEndpoint);

				DNASSERT( pTempEndpoint->GetType() == ENDPOINT_TYPE_ENUM );
				DNASSERT( pTempEndpoint->GetState() != ENDPOINT_STATE_UNINITIALIZED );

				//
				// Actually link to the other endpoints.
				//
				m_blMultiplex.InsertAfter(maa.pBilink);
			}
			else
			{
				DPFX(DPFPREP, 1, "Found private multiplexed adapter association key, but prev endpoint 0x%p ID doesn't match (%u != %u), cannot link endpoint 0x%p and hoping this enum gets cancelled, too.",
					pTempEndpoint, pTempEndpoint->GetEndpointID(), maa.dwEndpointID, this);
			}


			pSocketData->Unlock();
			//fLockedSocketData = FALSE;
		}
		else
		{
			//
			// We are the only ones who should know about this key, so if it
			// got there either someone is trying to imitate our address format,
			// or someone is passing around device addresses returned by
			// xxxADDRESSINFO to a different interface or over the network.
			// None of those situations make a whole lot of sense, but we'll
			// just ignore it.
			//
			DPFX(DPFPREP, 0, "Multiplexed adapter association key exists, but 0x%p doesn't match expected 0x%p, is someone trying to get cute with device address 0x%p?!",
				maa.pSPData, m_pSPData, pDeviceAddress );
		}
	}
	else
	{
		//
		// Either the key is not there, it's the wrong size (too big for our
		// buffer and returned BUFFERTOOSMALL somehow), it's not a binary
 		// component, or something else bad happened.  Assume that this is the
		// first device.
		//
		DPFX(DPFPREP, 8, "Could not get appropriate private multiplexed adapter association key, error = 0x%lx, component size = %u, type = %u, continuing.",
			hTempResult, dwComponentSize, dwComponentType);
	}
	

	//
	// Add the multiplex information to the device address for future use if
	// necessary.
	// Ignore failure, we can still survive without it, we just might have the
	// race conditions for responses on NAT machines.
	//
	// NOTE: There is an inherent design problem here!  We're adding a pointer to
	// an endpoint (well, a field within the endpoint structure) inside the address.
	// If this endpoint goes away but the upper layer reuses the address at a later
	// time, this memory will be bogus!  We will assume that the endpoint will not
	// go away while this modified device address object is in existence.
	//
	if ( dwEnumQueryFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
	{
		maa.pSPData = m_pSPData;
		maa.pBilink = &m_blMultiplex;
		maa.dwEndpointID = GetEndpointID();

		DPFX(DPFPREP, 7, "Additional multiplex adapters on the way, adding SPData 0x%p and bilink 0x%p to address.",
			maa.pSPData, maa.pBilink);
		
		hTempResult = IDirectPlay8Address_AddComponent( EnumAddressInfo.pDeviceAddress,						// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component data
														sizeof(maa),										// component data size
														DPNA_DATATYPE_BINARY								// component data type
														);
		if ( hTempResult != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Couldn't add private multiplexed adapter association component (err = 0x%lx)!  Ignoring.", hTempResult);
		}

		//
		// Mark the command as "in-progress" so that the cancel thread knows it needs
		// to do the completion itself.
		// If the command has already been marked for cancellation, then we have to
		// do that now.
		//
		m_pActiveCommandData->Lock();
		if ( m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
		{
			m_pActiveCommandData->Unlock();


			DPFX(DPFPREP, 1, "Enum query 0x%p (endpoint 0x%p) has already been cancelled, bailing.",
				m_pActiveCommandData, this);
			
			//
			// Complete the enum with USERCANCEL.
			//
			hr = DPNERR_USERCANCEL;
			goto Failure;
		}

		m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
		m_pActiveCommandData->Unlock();
	}
#endif // ! DPNBUILD_ONLYONEADAPTER


	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}


	//
	// Now tell the user about the address info that we ended up using, if we
	// successfully bound the endpoint, or give them a heads up for a failure
	// (see BindEndpoint failure case above).
	//
	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_ENUMADDRESSINFO 0x%p to interface 0x%p.",
		this, &EnumAddressInfo, m_pSPData->DP8SPCallbackInterface());
	DumpAddress( 8, _T("\t Host:"), EnumAddressInfo.pHostAddress );
	DumpAddress( 8, _T("\t Device:"), EnumAddressInfo.pDeviceAddress );
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);
	
	hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
												SPEV_ENUMADDRESSINFO,					// event type
												&EnumAddressInfo						// pointer to data
												);
	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_ENUMADDRESSINFO [0x%lx].",
		this, hTempResult);

	DNASSERT( hTempResult == DPN_OK );


	//
	// If there aren't more multiplex adapter commands on the way, then submit the timer
	// jobs for all of the multiplex commands, including this one.
	//
#ifndef DPNBUILD_ONLYONEADAPTER
	if ( dwEnumQueryFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
	{
		//
		// Not last multiplexed adapter.  All the work needed to be done for these
		// endpoints at this time has already been done.
		//
		DPFX(DPFPREP, 6, "Endpoint 0x%p is not the last multiplexed adapter, not submitting enum timer job yet.",
			this);
	}
	else
#endif // ! DPNBUILD_ONLYONEADAPTER
	{
		DPFX(DPFPREP, 7, "Completing/starting all enum queries (including multiplexed).");

		pSocketData->Lock();
		fLockedSocketData = TRUE;


#ifndef DPNBUILD_ONLYONEADAPTER
		//
		// Attach a root node to the list of adapters.
		//
		blInitiate.InsertAfter(&(m_blMultiplex));


		//
		// Move this adapter to the failed list if it did fail to bind.
		//
		if (! fEndpointBound)
		{
			m_blMultiplex.RemoveFromList();
			m_blMultiplex.InsertBefore(&blCompleteEarly);
		}


#ifndef DPNBUILD_NOICSADAPTERSELECTIONLOGIC
		//
		// Loop through all the remaining adapters in the list.
		//
		pBilinkAll = blInitiate.GetNext();
		while (pBilinkAll != &blInitiate)
		{
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);
			DNASSERT(pBilinkAll->GetNext() != pBilinkAll);

			pBilinkNext = pBilinkAll->GetNext();

			
			//
			// THIS MUST BE CLEANED UP PROPERLY WITH AN INTERFACE CHANGE!
			//
			// The endpoint may have been returned to the pool and its associated
			// socketport pointer may have become NULL, or now be pointing to
			// something that's no longer valid.  So we try to handle NULL
			// pointers.  Obviously this is indicative of poor design, but it's
			// not possible to change this the correct way at this time.
			//


			//
			// If the enum is directed (not the broadcast address), and this is a NAT
			// machine, then some adapters may be better than others for reaching the
			// desired address.  Particularly, it's better to use a private adapter,
			// which can directly reach the private network & be mapped on the public
			// network, than to use the public adapter.  It's not fun to join a private
			// game from an ICS machine while dialed up, have your Internet connection
			// go down, and lose the connection to the private game which didn't
			// (shouldn't) involve the Internet at all.  So if we detect a public
			// adapter when we have a perfectly good private adapter, we'll prematurely
			// complete enumerations on the public one.
			//


			//
			// Cast to get rid of the const.  Don't worry, we won't actually change it.
			//
			pSocketAddress = (CSocketAddress*) pTempEndpoint->GetRemoteAddressPointer();
			psaddrinTemp = (SOCKADDR_IN*) pSocketAddress->GetAddress();
			pSocketPort = pTempEndpoint->GetSocketPort();

			//
			// If this item doesn't have a socketport, then it must have failed to bind.
			// We need to clean it up ourselves.
			//
			if (pSocketPort == NULL)
			{
				DPFX(DPFPREP, 3, "Endpoint 0x%p failed earlier, now completing.",
					pTempEndpoint);
				
				//
				// Get the next associated endpoint before we pull the current entry
				// from the list.
				//
				pBilinkAll = pBilinkAll->GetNext();

				//
				// Pull it out of the multiplex association list and move
				// it to the "early completion" list.
				//
				pTempEndpoint->RemoveFromMultiplexList();
				pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);

				//
				// Move to next iteration of loop.
				//
				continue;
			}

#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
			//
			// Detect if we've been given conflicting address families for our target
			// and our bound socket (see CSocketPort::BindEndpoint).
			//
			DNASSERT(pSocketPort->GetNetworkAddress() != NULL);
			if ( pSocketAddress->GetFamily() != pSocketPort->GetNetworkAddress()->GetFamily() )
			{
				DPFX(DPFPREP, 3, "Endpoint 0x%p (family %u) is targeting a different address family (%u), completing.",
					pTempEndpoint, pSocketPort->GetNetworkAddress()->GetFamily(), pSocketAddress->GetFamily());
				
				//
				// Get the next associated endpoint before we pull the current entry
				// from the list.
				//
				pBilinkAll = pBilinkAll->GetNext();

				//
				// Give the endpoint a meaningful error.
				//
				pTempEndpoint->SetPendingCommandResult(DPNERR_INVALIDDEVICEADDRESS);

				//
				// Pull it out of the multiplex association list and move
				// it to the "early completion" list.
				//
				pTempEndpoint->RemoveFromMultiplexList();
				pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);

				//
				// Move to next iteration of loop.
				//
				continue;
			}
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPV6
			//
			// Now handle some special IPv6 logic.
			//
			if (pSocketAddress->GetFamily() == AF_INET6)
			{
				SOCKADDR_IN6 *		psaddrinDevice;
				SOCKADDR_IN6 *		psaddrinRemote;


				psaddrinDevice = (SOCKADDR_IN6*) pSocketPort->GetNetworkAddress()->GetAddress();
				psaddrinRemote = (SOCKADDR_IN6*) pSocketAddress->GetAddress();
				
				//
				// If any non-link local IPv6 endpoints are targeting the IPv6 multicast enum
				// address, just fail them.
				//
				if (IN6_IS_ADDR_MULTICAST(&psaddrinRemote->sin6_addr))
				{
					//
					// Right now, only the specific enum multicast address is allowed.
					//
					DNASSERT(IN6_ADDR_EQUAL(&psaddrinRemote->sin6_addr, &c_in6addrEnumMulticast));
					
					if (! IN6_IS_ADDR_LINKLOCAL(&psaddrinDevice->sin6_addr))
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p is targeting multicast enum address but is not link-local IPv6 device, completing.",
							pTempEndpoint);
						
						//
						// Get the next associated endpoint before we pull the current entry
						// from the list.
						//
						pBilinkAll = pBilinkAll->GetNext();

						//
						// Give the endpoint a meaningful error.
						//
						pTempEndpoint->SetPendingCommandResult(DPNERR_INVALIDHOSTADDRESS);

						//
						// Pull it out of the multiplex association list and move
						// it to the "early completion" list.
						//
						pTempEndpoint->RemoveFromMultiplexList();
						pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);

						//
						// Move to next iteration of loop.
						//
						continue;
					}
				}
				else
				{
					BOOL	fDifferentScope;
					
						
					//
					// If this endpoint is targeting something which has a different address,
					// prefix scope, fail it.
					//
					
					fDifferentScope = FALSE;
					if (IN6_IS_ADDR_LINKLOCAL(&psaddrinDevice->sin6_addr))
					{
						if (! IN6_IS_ADDR_LINKLOCAL(&psaddrinRemote->sin6_addr))
						{
							fDifferentScope = TRUE;
						}
					}
					else if (IN6_IS_ADDR_SITELOCAL(&psaddrinDevice->sin6_addr))
					{
						if (! IN6_IS_ADDR_SITELOCAL(&psaddrinRemote->sin6_addr))
						{
							fDifferentScope = TRUE;
						}
					}
					else
					{
						if ((IN6_IS_ADDR_LINKLOCAL(&psaddrinRemote->sin6_addr)) ||
							(IN6_IS_ADDR_SITELOCAL(&psaddrinRemote->sin6_addr)))
						{
							fDifferentScope = TRUE;
						}
					}

					if (fDifferentScope)
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p is targeting address with different link-local/site-local/global scope, completing.",
							pTempEndpoint);
						
						//
						// Get the next associated endpoint before we pull the current entry
						// from the list.
						//
						pBilinkAll = pBilinkAll->GetNext();

						//
						// Give the endpoint a meaningful error.
						//
						pTempEndpoint->SetPendingCommandResult(DPNERR_INVALIDHOSTADDRESS);

						//
						// Pull it out of the multiplex association list and move
						// it to the "early completion" list.
						//
						pTempEndpoint->RemoveFromMultiplexList();
						pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);

						//
						// Move to next iteration of loop.
						//
						continue;
					}
				}
			}
#endif // ! DPNBUILD_NOIPV6


			//
			// See if this is a directed IP enum.
			//
			if ( ( pSocketAddress != NULL ) &&
				( pSocketAddress->GetFamily() == AF_INET ) &&
				( psaddrinTemp->sin_addr.S_un.S_addr != INADDR_BROADCAST ) )
			{
#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
				for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
				{
					if (pSocketPort->GetNATHelpPort(dwTemp) != NULL)
					{
						DNASSERT( g_papNATHelpObjects[dwTemp] != NULL );
						dwPublicAddressesSize = sizeof(saddrPublic);
						dwAddressTypeFlags = 0;
						hTempResult = IDirectPlayNATHelp_GetRegisteredAddresses(g_papNATHelpObjects[dwTemp],
																				pSocketPort->GetNATHelpPort(dwTemp),
																				&saddrPublic,
																				&dwPublicAddressesSize,
																				&dwAddressTypeFlags,
																				NULL,
																				0);
						if ((hTempResult != DPNH_OK) || (! (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)))
						{
							DPFX(DPFPREP, 7, "Socketport 0x%p is not locally mapped on gateway with NAT Help index %u (err = 0x%lx, flags = 0x%lx).",
								pSocketPort, dwTemp, hTempResult, dwAddressTypeFlags);
						}
						else
						{
							//
							// There is a local NAT.
							//
							DPFX(DPFPREP, 7, "Socketport 0x%p is locally mapped on gateway with NAT Help index %u (flags = 0x%lx), public address:",
								pSocketPort, dwTemp, dwAddressTypeFlags);
							DumpSocketAddress(7, &saddrPublic, AF_INET);
							

							//
							// Find the multiplexed enum on the public adapter that
							// we need to complete early, as described above.
							//
							pBilinkPublic = blInitiate.GetNext();
							while (pBilinkPublic != &blInitiate)
							{
								pPublicEndpoint = CONTAINING_OBJECT(pBilinkPublic, CEndpoint, m_blMultiplex);
								DNASSERT(pBilinkPublic->GetNext() != pBilinkPublic);

								//
								// Don't bother checking the endpoint whose public
								// address we're seeking.
								//
								if (pPublicEndpoint != pTempEndpoint)
								{
									pPublicSocketPort = pPublicEndpoint->GetSocketPort();
									if ( pPublicSocketPort != NULL )
									{
										//
										// Cast to get rid of the const.  Don't worry, we won't
										// actually change it.
										//
										pSocketAddress = (CSocketAddress*) pPublicSocketPort->GetNetworkAddress();
										if ( pSocketAddress != NULL )
										{
											if ( pSocketAddress->CompareToBaseAddress( &saddrPublic ) == 0)
											{
												DPFX(DPFPREP, 3, "Endpoint 0x%p is multiplexed onto public adapter for endpoint 0x%p (current endpoint = 0x%p), completing public enum.",
													pTempEndpoint, pPublicEndpoint, this);

												//
												// Pull it out of the multiplex association list and move
												// it to the "early completion" list.
												//
												pPublicEndpoint->RemoveFromMultiplexList();
												pPublicEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);

												break;
											}
											

											//
											// Otherwise, continue searching.
											//

											DPFX(DPFPREP, 8, "Endpoint 0x%p is multiplexed onto different adapter:",
												pPublicEndpoint);
											DumpSocketAddress(8, pSocketAddress->GetWritableAddress(), pSocketAddress->GetFamily());
										}
										else
										{
											DPFX(DPFPREP, 1, "Public endpoint 0x%p's socket port 0x%p is going away, skipping.",
												pPublicEndpoint, pPublicSocketPort);
										}
									}
									else
									{
										DPFX(DPFPREP, 1, "Public endpoint 0x%p is going away, skipping.",
											pPublicEndpoint);
									}
								}
								else
								{
									//
									// The same endpoint as the one whose
									// public address we're seeking.
									//
								}

								pBilinkPublic = pBilinkPublic->GetNext();
							}


							//
							// No need to search for any more NAT Help registrations.
							//
							break;
						} // end else (is mapped locally on Internet gateway)
					}
					else
					{
						//
						// No DirectPlay NAT Helper registration in this slot.
						//
					}
				} // end for (each DirectPlay NAT Helper)
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT

				//
				// NOTE: We should complete enums for non-optimal adapters even
				// when it's multiadapter but not a PAST/UPnP enabled NAT (see
				// ProcessEnumResponseData for WSAIoctl usage related to this).
				// We do not currently do this.  There can still be race conditions
				// for directed enums where the response for the "wrong" device
				// arrives first.
				//
			}
			else
			{
				//
				// Not IP address, or enum being sent to the broadcast address,
				// or possibly the endpoint is shutting down.
				//
				DPFX(DPFPREP, 1, "Found non-IPv4 endpoint (possibly closing) or enum IP endpoint bound to broadcast address (endpoint = 0x%p, socket address = 0x%p, socketport = 0x%p), not checking for local NAT mapping.",
					pTempEndpoint, pSocketAddress, pSocketPort);
			}


			//
			// Go to the next associated endpoint.  Although it's possible for
			// entries to have been removed from the list, the current entry
			// could not have been, so we're safe.
			//
			pBilinkAll = pBilinkAll->GetNext();
		}
#endif // ! DPNBUILD_NOICSADAPTERSELECTIONLOGIC
#endif // ! DPNBUILD_ONLYONEADAPTER


#ifdef DPNBUILD_ONLYONEADAPTER
		if (fEndpointBound)
		{
				//
				// Indentation used for consistency even though there's no
				// brace that warrants it.
				//
				pTempEndpoint = this;

#else // ! DPNBUILD_ONLYONEADAPTER
		//
		// Because we walk the list of associated multiplex enums when we receive
		// responses, and that list walker does not expect to see a root node, we
		// need to make sure that's gone before we drop the lock.  Get a pointer
		// to the first and last items remaining in the list before we do that (if
		// there are entries).
		//
		if (! blInitiate.IsEmpty())
		{
			pBilinkAll = blInitiate.GetNext();
			pBilinkEnd = blInitiate.GetPrev();
			blInitiate.RemoveFromList();


			//
			// Now loop through the remaining endpoints and kick off their enum jobs.
	 		//
			// Unlike Connects, we will not remove the Enums from the list since we
			// need to filter out broadcasts received on the "wrong" adapter (see
			// ProcessEnumResponseData).
			//
			do
			{
				pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);
	
				pBilinkNext = pBilinkAll->GetNext();
#endif // ! DPNBUILD_ONLYONEADAPTER


				//
				// See notes above about NULL handling.
				//
				if ( pTempEndpoint->m_pActiveCommandData != NULL )
				{
					//
					// The endpoint's command may be cancelled already.  So we take the
					// command lock now, and abort the enum if it's no longer necessary.  
					//
					
					pTempEndpoint->m_pActiveCommandData->Lock();
				
					if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
					{
						//
						// If the command has been cancelled, pull this endpoint out of the multiplex
						// association list and move it to the "early completion" list.
						//
						
						pTempEndpoint->m_pActiveCommandData->Unlock();
						
						DPFX(DPFPREP, 1, "Endpoint 0x%p's enum command (0x%p) has been cancelled, moving to early completion list.",
							pTempEndpoint, pTempEndpoint->m_pActiveCommandData);


#ifdef DPNBUILD_ONLYONEADAPTER
						//
						// Remember that we're not starting the enum.
						//
						fEndpointBound = FALSE;
#else // ! DPNBUILD_ONLYONEADAPTER
						pTempEndpoint->RemoveFromMultiplexList();
						pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);
#endif // ! DPNBUILD_ONLYONEADAPTER
					}
					else
					{
						//
						// The command has not been cancelled.
						//
						// This is very hairy, but we drop the socketport data lock and
						// keep the command data lock.  Dropping the socketport data
						// lock should prevent deadlocks with the enum completing inside
						// the timer lock, and keeping the command data lock should
						// prevent people from cancelling the endpoint's command.
						//
						// However, once we drop the command lock, we do want the
						// command to be cancellable, so set the state appropriately now.
						//
						
						pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );

						//
						// We also need to notify potential cancellers that the command is
						// in a different COMMAND_STATE_INPROGRESS now.  Now they
						// must try to stop the timer as well.
						//
						pTempEndpoint->Lock();
						DNASSERT( pTempEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );
						pTempEndpoint->m_State = ENDPOINT_STATE_ENUM;
						pTempEndpoint->Unlock();

						pSocketData->Unlock();
						fLockedSocketData = FALSE;



						//
						// check retry count to determine if we're enumerating forever
						//
						switch ( pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryCount )
						{
							//
							// let SP determine retry count
							//
							case 0:
							{
								uRetryCount = DEFAULT_ENUM_RETRY_COUNT;
								fRetryForever = FALSE;
								break;
							}

							//
							// retry forever
							//
							case INFINITE:
							{
								uRetryCount = 1;
								fRetryForever = TRUE;
								break;
							}

							//
							// other
							//
							default:
							{
								uRetryCount = pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryCount;
								fRetryForever = FALSE;
								break;
							}
						}
						
						//
						// check interval for default
						//
						if ( pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryInterval == 0 )
						{
							dwRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
						}
						else
						{
							dwRetryInterval = pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryInterval;
						}

						//
						// check timeout to see if we're enumerating forever
						//
						switch ( pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwTimeout )
						{
							//
							// wait forever
							//
							case INFINITE:
							{
								fWaitForever = TRUE;
								dwIdleTimeout = -1;
								break;
							}

							//
							// possible default
							//
							case 0:
							{
								fWaitForever = FALSE;
								dwIdleTimeout = DEFAULT_ENUM_TIMEOUT;	
								break;
							}

							//
							// other
							//
							default:
							{
								fWaitForever = FALSE;
								dwIdleTimeout = pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwTimeout;
								break;
							}
						}

						//
						// initialize array to compute round-trip times
						//
						memset( pTempEndpoint->GetCommandParameters()->dwEnumSendTimes, 0x00, sizeof( pTempEndpoint->GetCommandParameters()->dwEnumSendTimes ) );
						pTempEndpoint->GetCommandParameters()->dwEnumSendIndex = 0;

						
						DPFX(DPFPREP, 6, "Submitting enum timer job for endpoint 0x%p, retry count = %u, retry forever = %i, retry interval = %u, wait forever = %i, idle timeout = %u, context = 0x%p.",
							pTempEndpoint,
							uRetryCount,
							fRetryForever,
							dwRetryInterval,
							fWaitForever,
							dwIdleTimeout,
							pTempEndpoint->m_pActiveCommandData);

						if ( pTempEndpoint->m_pSPData != NULL )
						{
#ifdef DPNBUILD_ONLYONEPROCESSOR
							hTempResult = pTempEndpoint->m_pSPData->GetThreadPool()->SubmitTimerJob( TRUE,								// perform immediately
																								uRetryCount,							// number of times to retry command
																								fRetryForever,							// retry forever
																								dwRetryInterval,							// retry interval
																								fWaitForever,							// wait forever after all enums sent
																								dwIdleTimeout,							// timeout to wait after command complete
																								CEndpoint::EnumTimerCallback,			// function called when timer event fires
																								CEndpoint::EnumCompleteWrapper,			// function called when timer event expires
																								pTempEndpoint->m_pActiveCommandData );	// context
#else // ! DPNBUILD_ONLYONEPROCESSOR
							DNASSERT(pTempEndpoint->m_pSocketPort != NULL);
							hTempResult = pTempEndpoint->m_pSPData->GetThreadPool()->SubmitTimerJob( pTempEndpoint->m_pSocketPort->GetCPU(),		// CPU
																								TRUE,									// perform immediately
																								uRetryCount,								// number of times to retry command
																								fRetryForever,								// retry forever
																								dwRetryInterval,								// retry interval
																								fWaitForever,								// wait forever after all enums sent
																								dwIdleTimeout,								// timeout to wait after command complete
																								CEndpoint::EnumTimerCallback,				// function called when timer event fires
																								CEndpoint::EnumCompleteWrapper,				// function called when timer event expires
																								pTempEndpoint->m_pActiveCommandData );		// context
#endif // ! DPNBUILD_ONLYONEPROCESSOR
						}
						else
						{
							DPFX(DPFPREP, 1, "Endpoint 0x%p's SP data is NULL, not submitting timer job.",
								pTempEndpoint);
						}


						//
						// Drop active command data lock now that we've finished submission.
						//
						pTempEndpoint->m_pActiveCommandData->Unlock();

						
						//
						// Retake the socketport data lock so we can continue to work with the
						// list.
						//
						pSocketData->Lock();
						fLockedSocketData = TRUE;


						if ( hTempResult != DPN_OK )
						{
							DPFX(DPFPREP, 0, "Failed to spool enum job for endpoint 0x%p onto work thread (err = 0x%lx)!  Moving to early completion list.",
								pTempEndpoint, hTempResult);
							DisplayDNError( 0, hTempResult );
							
#ifdef DPNBUILD_ONLYONEADAPTER
							//
							// Remember that we didn't start the enum.
							//
							fEndpointBound = FALSE;
#else // ! DPNBUILD_ONLYONEADAPTER
							//
							// Move it to the "early completion" list.
							//
							pTempEndpoint->RemoveFromMultiplexList();
							pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);
#endif // ! DPNBUILD_ONLYONEADAPTER
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
						pTempEndpoint);
				}


#ifndef DPNBUILD_ONLYONEADAPTER
				//
				// If we've looped back around to the beginning, we're done.
				//
				if (pBilinkAll == pBilinkEnd)
				{
					break;
				}


				//
				// Go to the next associated endpoint.
				//
				pBilinkAll = pBilinkNext;
			}
			while (TRUE);
#endif // ! DPNBUILD_ONLYONEADAPTER
		}
		else
		{
			DPFX(DPFPREP, 1, "No remaining enums to initiate.");
		}


		//
		// Finally loop through all the enums that need to complete early and
		// do just that.
		//
#ifdef DPNBUILD_ONLYONEADAPTER
		if (! fEndpointBound)
		{
			pTempEndpoint = this;
#else // ! DPNBUILD_ONLYONEADAPTER
		while (! blCompleteEarly.IsEmpty())
		{
			pBilinkAll = blCompleteEarly.GetNext();
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);
			DNASSERT(pBilinkAll->GetNext() != pBilinkAll);


			//
			// Pull it from the "complete early" list.
			//
			pTempEndpoint->RemoveFromMultiplexList();
#endif // ! DPNBUILD_ONLYONEADAPTER


			//
			// Drop the socket data lock.  It's safe since we pulled everything we
			// we need off of the list that needs protection.
			//
			pSocketData->Unlock();
			fLockedSocketData = FALSE;


			//
			// See notes above about NULL handling.
			//
			if ( pTempEndpoint->m_pActiveCommandData != NULL )
			{
				//
				// Complete it with the appropriate error code.
				//
				
				pTempEndpoint->m_pActiveCommandData->Lock();

				if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
				{
					DPFX(DPFPREP, 6, "Completing endpoint 0x%p enum with USERCANCEL.", pTempEndpoint);
					hTempResult = DPNERR_USERCANCEL;
				}
				else
				{
					//
					// Retrieve the current command result.
					// If the command didn't have a descriptive error, assume it was
					// not previously set (i.e. wasn't overridden by BindEndpoint above),
					// and use NOCONNECTION instead.
					//
					hTempResult = pTempEndpoint->PendingCommandResult();
					if ( hTempResult == DPNERR_GENERIC )
					{
						hTempResult = DPNERR_NOCONNECTION;
					}
				
					DPFX(DPFPREP, 6, "Completing endpoint 0x%p enum query (command 0x%p) with error 0x%lx.",
						pTempEndpoint, pTempEndpoint->m_pActiveCommandData, hTempResult);
				}
				
				pTempEndpoint->m_pActiveCommandData->Unlock();

				pTempEndpoint->EnumComplete( hTempResult );
			}
			else
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
					pTempEndpoint);
			}


			//
			// Retake the socket data lock and go to next item.
			//
			pSocketData->Lock();
			fLockedSocketData = TRUE;
		}


		pSocketData->Unlock();
		fLockedSocketData = FALSE;
	}


Exit:

	if ( pSocketData != NULL )
	{
		pSocketData->Release();
		pSocketData = NULL;
	}

	if ( EnumAddressInfo.pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( EnumAddressInfo.pHostAddress );
		EnumAddressInfo.pHostAddress = NULL;
	}

	if ( EnumAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( EnumAddressInfo.pDeviceAddress );
		EnumAddressInfo.pDeviceAddress = NULL;
	}
	
	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );

	DNASSERT( pHostAddress != NULL );
	IDirectPlay8Address_Release( pHostAddress );

	DNASSERT( !fLockedSocketData );

#ifndef DPNBUILD_ONLYONEADAPTER
	DNASSERT(blCompleteEarly.IsEmpty());
	DNASSERT(blInitiate.IsEmpty());
#endif // ! DPNBUILD_ONLYONEADAPTER


	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;

Failure:

	//
	// If we still have the socket data lock, drop it.
	//
	if ( fLockedSocketData )
	{
		pSocketData->Unlock();
		fLockedSocketData = FALSE;
	}
	
	//
	// we've failed to complete the enum query, clean up and return this
	// endpoint to the pool
	//
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	//
	// remove timer thread reference
	//
	DecRef();

	goto Exit;
}
//**********************************************************************


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// CEndpoint::EnumQueryBlockingJobWrapper - asynchronous callback wrapper for blocking job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryBlockingJobWrapper"

void	CEndpoint::EnumQueryBlockingJobWrapper( void * const pvContext )
{
	CEndpoint	*pThisEndpoint;


	// initialize
	DNASSERT( pvContext != NULL );
	pThisEndpoint = static_cast<CEndpoint*>( pvContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );

	pThisEndpoint->EnumQueryBlockingJob();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumQueryBlockingJob - complete enum query blocking job
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryBlockingJob"

void	CEndpoint::EnumQueryBlockingJob( void )
{
	HRESULT			hr;


	//
	// Try to resolve the host name.  It's possible we already did this
	// when we first opened the endpoint, and we only need to resolve
	// the hostname, but it's simpler to just do it all again anyway.
	//
	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost,
#ifdef DPNBUILD_XNETSECURITY
																((m_fSecureTransport) ? &m_ullKeyID : NULL),
#endif // DPNBUILD_XNETSECURITY
																TRUE,
																SP_ADDRESS_TYPE_HOST );
	if ( hr != DPN_OK )
	{
		if ( hr != DPNERR_INCOMPLETEADDRESS )
		{
			DPFX(DPFPREP, 0, "Couldn't get valid address!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}

		//
		// we're OK, reset the destination address to broadcast
		//
		DNASSERT(! (GetCommandParameters()->PendingCommandData.EnumQueryData.dwFlags & DPNSPF_NOBROADCASTFALLBACK));
		ReinitializeWithBroadcast();
	}
	
	//
	// Make sure its valid and not banned.
	//
	if (! m_pRemoteMachineAddress->IsValidUnicastAddress(TRUE))
	{
		DPFX(DPFPREP, 0, "Host address is invalid!");
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto Failure;
	}

#ifndef DPNBUILD_NOREGISTRY
	if (m_pRemoteMachineAddress->IsBannedAddress())
	{
		DPFX(DPFPREP, 0, "Host address is banned!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}
#endif // ! DPNBUILD_NOREGISTRY


#ifndef DPNBUILD_NONATHELP
	//
	// Try to get NAT help loaded, if it isn't already and we're allowed.
	//
	if (GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE)
	{
		DPFX(DPFPREP, 7, "Ensuring that NAT help is loaded.");
		m_pSPData->GetThreadPool()->EnsureNATHelpLoaded();
	}
#endif // ! DPNBUILD_NONATHELP

Exit:

	//
	// Submit the job for completion (for real).  We want it to occur on
	// a thread pool thread so that the user has gotten notified about the
	// thread prior to getting a callback on it.  We do it in even the failure
	// case.
	//
	// NOTE: If this fails, we will rely on the caller that triggered the original
	// operation to cancel the command at some point, probably when he
	// decides the operation is taking too long.
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::EnumQueryJobCallback,
														this );
#else // ! DPNBUILD_ONLYONEPROCESSOR
	hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( -1,								// we don't know the CPU yet, so pick any
														CEndpoint::EnumQueryJobCallback,
														this );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to queue delayed enum query completion!  Operation must be cancelled." );
		DisplayDNError( 0, hr );

		//
		// Leave endpoint reference, see notes above.
		//
	}

	return;

Failure:

	//
	// Attempt to attach the failure code to the command.  If the user was
	// already cancelling this command, we will just leave the command alone.
	//
	m_pActiveCommandData->Lock();
	if (m_pActiveCommandData->GetState() != COMMAND_STATE_CANCELLING)
	{
		DNASSERT(m_pActiveCommandData->GetState() == COMMAND_STATE_PENDING);
		m_pActiveCommandData->SetState(COMMAND_STATE_FAILING);
		m_hrPendingCommandResult = hr;
	}
	else
	{
		DPFX(DPFPREP, 0, "User cancelled command, ignoring failure result 0x%lx.",
			hr);
	}
	m_pActiveCommandData->Unlock();

	goto Exit;
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYONETHREAD


//**********************************************************************
// ------------------------------
// CEndpoint::EnumCompleteWrapper - wrapper when enum has completed
//
// Entry:		Error code from enum command
//				Pointer to context	
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumCompleteWrapper"

void	CEndpoint::EnumCompleteWrapper( const HRESULT hResult, void *const pContext )
{
	CCommandData	*pCommandData;


	DNASSERT( pContext != NULL );
	pCommandData = static_cast<CCommandData*>( pContext );
	pCommandData->GetEndpoint()->EnumComplete( hResult );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumComplete - enum has completed
//
// Entry:		Error code from enum command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumComplete"

void	CEndpoint::EnumComplete( const HRESULT hResult )
{
	BOOL	fProcessCompletion;
	BOOL	fReleaseEndpoint;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%lx)", this, hResult);

	fProcessCompletion = FALSE;
	fReleaseEndpoint = FALSE;

	Lock();
	switch ( m_State )
	{
		//
		// starting up
		//
		case ENDPOINT_STATE_ATTEMPTING_ENUM:
		{
			DPFX(DPFPREP, 5, "Endpoint 0x%p has not started actual enum yet.", this);
			DNASSERT( m_dwThreadCount == 0 );

			SetState( ENDPOINT_STATE_DISCONNECTING );
			fReleaseEndpoint = TRUE;
			fProcessCompletion = TRUE;
			break;
		}

		//
		// enumerating, note that this endpoint is disconnecting
		//
		case ENDPOINT_STATE_ENUM:
		{
			//
			//	If there are threads using this endpoint,
			//	queue the completion
			//
			if (m_dwThreadCount)
			{
				DPFX(DPFPREP, 5, "Endpoint 0x%p waiting on %u threads before completing.",
					this, m_dwThreadCount);
				SetState( ENDPOINT_STATE_WAITING_TO_COMPLETE );
			}
			else
			{
				DPFX(DPFPREP, 5, "Endpoint 0x%p disconnecting.", this);
				SetState( ENDPOINT_STATE_DISCONNECTING );
				fReleaseEndpoint = TRUE;
			}

			//
			//	Prevent more responses from finding this endpoint
			//
			fProcessCompletion = TRUE;

			break;
		}

		//
		//	endpoint needs to have a completion indicated
		//
		case ENDPOINT_STATE_WAITING_TO_COMPLETE:
		{
			if (m_dwThreadCount == 0)
			{
				DPFX(DPFPREP, 5, "Endpoint 0x%p now able to disconnect.", this);
				SetState( ENDPOINT_STATE_DISCONNECTING );
				fReleaseEndpoint = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 5, "Endpoint 0x%p still waiting on %u threads before completing.",
					this, m_dwThreadCount);
			}
			break;
		}

		//
		// disconnecting (command was probably cancelled)
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 4, "Endpoint 0x%p already disconnecting.", this);
			DNASSERT( m_dwThreadCount == 0 );
			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	Unlock();

	if (fProcessCompletion)
	{
		GetCommandParameters()->dwEnumSendIndex = 0;
		Close( hResult );
		m_pSPData->CloseEndpointHandle( this );
	}
	if (fReleaseEndpoint)
	{
		DecRef();
	}


	DPFX(DPFPREP, 6, "(0x%p) Leave", this);

	return;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CEndpoint::CleanUpCommand - clean up this endpoint and unbind from CSocketPort
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SetEnumsAllowedOnListen"

void	CEndpoint::SetEnumsAllowedOnListen( const BOOL fAllowed, const BOOL fOverwritePrevious ) 
{
	ENUMSALLOWEDSTATE		NewEnumsAllowedState;
#ifndef DPNBUILD_NOIPV6
	const CSocketAddress *		pSocketAddress;
	IPV6_MREQ				mreq;
	int						iError;
#endif // ! DPNBUILD_NOIPV6


	NewEnumsAllowedState = (fAllowed) ? ENUMSALLOWED : ENUMSDISALLOWED;
	
	Lock();
	
	if ( m_EnumsAllowedState == NewEnumsAllowedState )
	{
		DPFX(DPFPREP, 6, "(0x%p) Enums already %slowed.", this, ((fAllowed) ? _T("al") : _T("disal")));
	}
	else if ((fOverwritePrevious) ||
			(m_EnumsAllowedState == ENUMSNOTREADY))
	{
		DPFX(DPFPREP, 7, "(0x%p) %slowing enums.", this, ((fAllowed) ? _T("Al") : _T("Disal")));

#ifndef DPNBUILD_NOIPV6
		//
		// If this is a link-local IPv6 socket, join or leave the multicast group used to
		// receive enums.
		//
		if (m_pSocketPort != NULL)
		{
			pSocketAddress = m_pSocketPort->GetNetworkAddress();
			DNASSERT(pSocketAddress != NULL);
			if ((pSocketAddress->GetFamily() == AF_INET6) &&
				(IN6_IS_ADDR_LINKLOCAL(&(((SOCKADDR_IN6*) pSocketAddress->GetAddress())->sin6_addr))))
			{
				DNASSERT(((SOCKADDR_IN6*) pSocketAddress->GetAddress())->sin6_scope_id != 0);
				mreq.ipv6mr_interface = ((SOCKADDR_IN6*) pSocketAddress->GetAddress())->sin6_scope_id;
				memcpy(&mreq.ipv6mr_multiaddr, &c_in6addrEnumMulticast, sizeof(mreq.ipv6mr_multiaddr));

				iError = setsockopt(m_pSocketPort->GetSocket(),
								IPPROTO_IPV6,
								((fAllowed) ? IPV6_JOIN_GROUP : IPV6_LEAVE_GROUP),
				              		(char*) (&mreq),
				              		sizeof(mreq));
#ifdef DBG
				if (iError != 0)
				{
					iError = WSAGetLastError();
					DPFX(DPFPREP, 0, "Couldn't %s link local multicast group (err = %i)!",
						((fAllowed) ? _T("join") : _T("leave")), iError);
				}
#endif // DBG
			}
		}
#endif // ! DPNBUILD_NOIPV6

		m_EnumsAllowedState = NewEnumsAllowedState;
	}
	else
	{
		DPFX(DPFPREP, 7, "(0x%p) Enums-allowed state unchanged, still %slowing enums.", this, ((fAllowed) ? _T("al") : _T("disal")));
	}

	Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CleanUpCommand - clean up this endpoint and unbind from CSocketPort
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CleanupCommand"

void	CEndpoint::CleanUpCommand( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this);

	//
	// If we're closing a listen normally, make sure no enums come
	// in from here on out.
	//
	if ( ( GetType() == ENDPOINT_TYPE_LISTEN ) &&
		( ! m_fListenStatusNeedsToBeIndicated ) )
	{
		SetEnumsAllowedOnListen( FALSE, TRUE );
	}
	
	//
	// There is an 'EndpointRef' that the endpoint holds against the
	// socket port since it was created and always must be released.
	// If the endpoint was bound it needs to be unbound.
	//
	if ( GetSocketPort() != NULL )
	{
		DNASSERT( m_pSPData != NULL );
		m_pSPData->UnbindEndpoint( this );
	}
#ifndef DPNBUILD_ONLYONEADAPTER
	else
	{
		//
		// Ensure that this endpoint is no longer in the multiplex list
		// (could happen if canceling a failed Connect/EnumQuery).
		//
		if (( m_pSPData != NULL ) && ( m_pSPData->GetSocketData() != NULL ))
		{
			m_pSPData->GetSocketData()->Lock();
			RemoveFromMultiplexList();
			m_pSPData->GetSocketData()->Unlock();
		}
	}
#endif // ! DPNBUILD_ONLYONEADAPTER
	
	//
	// If we're bailing here it's because the UI didn't complete.  There is no
	// adapter guid to return because one may have not been specified.  Return
	// a bogus endpoint handle so it can't be queried for addressing data.
	//
	if ( m_fListenStatusNeedsToBeIndicated != FALSE )
	{
		HRESULT					hTempResult;
		SPIE_LISTENADDRESSINFO	ListenAddressInfo;
		SPIE_LISTENSTATUS		ListenStatus;
		

		m_fListenStatusNeedsToBeIndicated = FALSE;

		memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );

		//
		// We don't have a bound socket at this point, so just return the original
		// device address specified.
		//
		DNASSERT(GetCommandParameters() != NULL);
		DNASSERT(GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo != NULL);
		ListenAddressInfo.pDeviceAddress = GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo;
		ListenAddressInfo.hCommandStatus = PendingCommandResult();
		ListenAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();


		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENADDRESSINFO 0x%p to interface 0x%p.",
			this, &ListenAddressInfo, m_pSPData->DP8SPCallbackInterface());
		DumpAddress( 8, _T("\t Device:"), ListenAddressInfo.pDeviceAddress );
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
													SPEV_LISTENADDRESSINFO,					// event type
													&ListenAddressInfo						// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENADDRESSINFO [0x%lx].",
			this, hTempResult);

		DNASSERT( hTempResult == DPN_OK );

		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hCommand = m_pActiveCommandData;
		ListenStatus.hEndpoint = INVALID_HANDLE_VALUE;
		ListenStatus.hResult = PendingCommandResult();
		memset( &ListenStatus.ListenAdapter, 0x00, sizeof( ListenStatus.ListenAdapter ) );
		ListenStatus.pUserContext = m_pActiveCommandData->GetUserContext();


		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENSTATUS 0x%p to interface 0x%p.",
			this, &ListenStatus, m_pSPData->DP8SPCallbackInterface());
		AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);
		
		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENSTATUS [0x%lx].",
			this, hTempResult);

		DNASSERT( hTempResult == DPN_OK );
	}
	
	m_State = ENDPOINT_STATE_UNINITIALIZED;

	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumData - process received enum data
//
// Entry:		Pointer to received buffer
//				Associated enum key
//				Pointer to return address
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumData"

void	CEndpoint::ProcessEnumData( SPRECEIVEDBUFFER *const pBuffer, const DWORD dwEnumKey, const CSocketAddress *const pReturnSocketAddress )
{
	DNASSERT( pBuffer != NULL );
	DNASSERT( pBuffer->pNext == NULL);
	DNASSERT( pBuffer->BufferDesc.dwBufferSize > 0);
	DNASSERT( pReturnSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// we're listening, this is the only way to detect enums
		//
		case ENDPOINT_STATE_LISTEN:
		{
			ENDPOINT_ENUM_QUERY_CONTEXT	QueryContext;
			HRESULT		hr;


			//
			// initialize
			//
			DNASSERT( m_pActiveCommandData != NULL );
			DEBUG_ONLY( memset( &QueryContext, 0x00, sizeof( QueryContext ) ) );

			//
			// set callback data
			//
			QueryContext.hEndpoint = (HANDLE) this;
			QueryContext.dwEnumKey = dwEnumKey;
			QueryContext.pReturnAddress = (CSocketAddress*) pReturnSocketAddress;
			
			QueryContext.EnumQueryData.pReceivedData = pBuffer;
			QueryContext.EnumQueryData.pUserContext = m_pActiveCommandData->GetUserContext();

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
#ifdef DPNBUILD_XNETSECURITY
			QueryContext.EnumQueryData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress( NULL, NULL, SP_ADDRESS_TYPE_READ_HOST );
			QueryContext.EnumQueryData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, NULL, GetGatewayBindType() );
#else // ! DPNBUILD_XNETSECURITY
			QueryContext.EnumQueryData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress( SP_ADDRESS_TYPE_READ_HOST );
			QueryContext.EnumQueryData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, GetGatewayBindType() );
#endif // ! DPNBUILD_XNETSECURITY

			if ( ( QueryContext.EnumQueryData.pAddressSender != NULL ) &&
				 ( QueryContext.EnumQueryData.pAddressDevice != NULL ) )
			{
				DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_ENUMQUERY 0x%p to interface 0x%p.",
					this, &QueryContext.EnumQueryData, m_pSPData->DP8SPCallbackInterface());
				DumpAddress( 8, _T("\t Sender:"), QueryContext.EnumQueryData.pAddressSender );
				DumpAddress( 8, _T("\t Device:"), QueryContext.EnumQueryData.pAddressDevice );
				AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_ENUMQUERY,							// data type
												   &QueryContext.EnumQueryData				// pointer to data
												   );

				DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_ENUMQUERY [0x%lx].", this, hr);

				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "User returned unexpected error from enum query indication!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}
			}

			if ( QueryContext.EnumQueryData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressSender );
				QueryContext.EnumQueryData.pAddressSender = NULL;
 			}
			
			if ( QueryContext.EnumQueryData.pAddressDevice != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressDevice );
				QueryContext.EnumQueryData.pAddressDevice = NULL;
 			}

			break;
		}

		//
		// we're disconnecting, ignore this message
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumResponseData - process received enum response data
//
// Entry:		Pointer to received data
//				Pointer to address of sender
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumResponseData"

void	CEndpoint::ProcessEnumResponseData( SPRECEIVEDBUFFER *const pBuffer,
											const CSocketAddress *const pReturnSocketAddress,
#ifdef DPNBUILD_XNETSECURITY
											const XNADDR *const pxnaddrReturn,
#endif // DPNBUILD_XNETSECURITY
											const UINT_PTR uRTTIndex )
{
	HRESULT				hrTemp;
	BOOL				fAddedThreadCount = FALSE;
	SPIE_QUERYRESPONSE	QueryResponseData;

	DNASSERT( pBuffer != NULL );
	DNASSERT( pReturnSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );
	

	//
	// Initialize.
	//
	memset( &QueryResponseData, 0x00, sizeof( QueryResponseData ) );


	DPFX(DPFPREP, 8, "Socketport 0x%p, endpoint 0x%p receiving enum RTT index 0x%x/%u.",
		GetSocketPort(), this, uRTTIndex, uRTTIndex); 


#ifdef DPNBUILD_XNETSECURITY
	//
	// Ignore insecure replies if enumerating securely.
	//
	if ((IsUsingXNetSecurity()) && (pxnaddrReturn == NULL))
	{
		DPFX(DPFPREP, 3, "Secure transport endpoint 0x%p ignoring insecure enum response.",
			this);
	}
	else
#endif // DPNBUILD_XNETSECURITY
	{
		Lock();
		switch( m_State )
		{
			case ENDPOINT_STATE_ENUM:
			{
				//
				// Valid endpoint - increment the thread count to prevent premature completion
				//
				AddRefThreadCount();
				
				fAddedThreadCount = TRUE;


				//
				// Attempt to build a sender DPlay8Addresses for the user.
				// If this fails, we'll ignore the enum.
				//
#ifdef DPNBUILD_XNETSECURITY
				QueryResponseData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress( NULL,
																									pxnaddrReturn,
																									SP_ADDRESS_TYPE_READ_HOST );
#else // ! DPNBUILD_XNETSECURITY
				QueryResponseData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress( SP_ADDRESS_TYPE_READ_HOST );
#endif // ! DPNBUILD_XNETSECURITY
				break;
			}

			case ENDPOINT_STATE_ATTEMPTING_ENUM:
			case ENDPOINT_STATE_WAITING_TO_COMPLETE:
			case ENDPOINT_STATE_DISCONNECTING:
			{
				//
				// Endpoint is waiting to complete or is disconnecting - ignore data
				//
				DPFX(DPFPREP, 2, "Endpoint 0x%p in state %u, ignoring enum response.",
					this, m_State);
				break;
			}

			default:
			{
				//
				// What's going on ?
				//
				DNASSERT( !"Invalid endpoint state" );
				break;
			}
		}
		Unlock();
	}


	//
	// If this is a multiplexed IP broadcast enum, we may want to drop the response
	// because there may be a more appropriate adapter (NAT private side adapter)
	// that should also be getting responses.
	// Also, if this is a directed IP enum, we should note whether this response
	// got proxied or not.
	//
#ifdef DPNBUILD_XNETSECURITY
	if ( ( QueryResponseData.pAddressSender != NULL ) &&
		( pxnaddrReturn == NULL ) )
#else // ! DPNBUILD_XNETSECURITY
	if ( QueryResponseData.pAddressSender != NULL )
#endif // ! DPNBUILD_XNETSECURITY
	{
		CSocketData *			pSocketData;
		CSocketAddress *		pSocketAddress;
		const SOCKADDR_IN *		psaddrinOriginalTarget;
		const SOCKADDR_IN *		psaddrinResponseSource;
		CSocketPort *			pSocketPort;
#ifndef DPNBUILD_ONLYONEADAPTER
		BOOL					fFoundMatchingEndpoint;

#ifndef DPNBUILD_NOWINSOCK2
		DWORD					dwBytesReturned;
#endif // DPNBUILD_NOWINSOCK2

#if ((! defined(DPNBUILD_NOWINSOCK2)) || ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT))))
		SOCKADDR				saddrTemp;
#endif // ! DPNBUILD_NOWINSOCK2 or (! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT)

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
		CSocketPort *			pTempSocketPort;
		CBilink *				pBilink;
		DWORD					dwTemp;
		CEndpoint *				pTempEndpoint;
		DWORD					dwPublicAddressesSize;
		DWORD					dwAddressTypeFlags;
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT
#endif // ! DPNBUILD_ONLYONEADAPTER


		//
		// In order for there to be a bound and usable endpoint, we must have created
		// the socket data.  Therefore we won't handle the error case.  We also don't
		// take a reference because the socket data should not go away until the socket
		// port and SP data objects are released.
		//
		pSocketData = m_pSPData->GetSocketData();
		DNASSERT( pSocketData != NULL );


		//
		// Find out where and how this enum was originally sent.
		//
		pSocketAddress = (CSocketAddress*) GetRemoteAddressPointer();
		DNASSERT( pSocketAddress != NULL );

	
		//
		// See if this is a response to and IP enum, either broadcast on multiple
		// adapters or directed, so we can have special NAT/proxy behavior.
		//
#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
		if ( pSocketAddress->GetFamily() != AF_INET )
		{
			//
			// Not IP address.
			//
			DPFX(DPFPREP, 8, "Non-IPv4 endpoint (0x%p), not checking for local NAT mapping or proxy.",
				this);
		}
		else
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
		{
			psaddrinOriginalTarget = (const SOCKADDR_IN *) pSocketAddress->GetAddress();

			pSocketPort = GetSocketPort();
			DNASSERT( pSocketPort != NULL );

			if ( psaddrinOriginalTarget->sin_addr.S_un.S_addr == INADDR_BROADCAST )
			{
#ifndef DPNBUILD_ONLYONEADAPTER
				//
				// Lock the list while we look at the entries.
				//
				pSocketData->Lock();
				
				if (! m_blMultiplex.IsEmpty())
				{
					//
					// It's a broadcast IP enum on multiple adapters.
					//

					//
					// Cast to get rid of the const.  Don't worry, we won't actually
					// change it.
					//
					pSocketAddress = (CSocketAddress*) pSocketPort->GetNetworkAddress();
					DNASSERT( pSocketAddress != NULL );


					fFoundMatchingEndpoint = FALSE;

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
					//
					// Loop through all other associated multiplexed endpoints to see
					// if one is more appropriate to receive responses from this
					// endpoint.  See CompleteEnumQuery.
					//
					pBilink = m_blMultiplex.GetNext();
					do
					{
						pTempEndpoint = CONTAINING_OBJECT(pBilink, CEndpoint, m_blMultiplex);

						DNASSERT( pTempEndpoint != this );
						DNASSERT( pTempEndpoint->GetType() == ENDPOINT_TYPE_ENUM );
						DNASSERT( pTempEndpoint->GetState() != ENDPOINT_STATE_UNINITIALIZED );
						DNASSERT( pTempEndpoint->GetCommandParameters() != NULL );
						DNASSERT( pTempEndpoint->m_pActiveCommandData != NULL );


						//
						// Although the endpoint may be in the list (and because we have the
						// socket data lock, it won't get pulled out while we're looking at it),
						// the endpoint may already be disconnecting.  If its m_pSocketPort is
						// NULL we should just ignore this temporary endpoint since its going
						// away (plus we sorta need its socket port pointer).
						//
						pTempSocketPort = pTempEndpoint->GetSocketPort();
						if (pTempSocketPort != NULL)
						{
							for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
							{
								if (pTempSocketPort->GetNATHelpPort(dwTemp) != NULL)
								{
									DNASSERT( g_papNATHelpObjects[dwTemp] != NULL );
									dwPublicAddressesSize = sizeof(saddrTemp);
									dwAddressTypeFlags = 0;
									hrTemp = IDirectPlayNATHelp_GetRegisteredAddresses(g_papNATHelpObjects[dwTemp],
																						pTempSocketPort->GetNATHelpPort(dwTemp),
																						&saddrTemp,
																						&dwPublicAddressesSize,
																						&dwAddressTypeFlags,
																						NULL,
																						0);
									if ((hrTemp != DPNH_OK) || (! (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)))
									{
										DPFX(DPFPREP, 7, "Socketport 0x%p is not locally mapped on gateway with NAT Help index %u (err = 0x%lx, flags = 0x%lx).",
											pTempSocketPort, dwTemp, hrTemp, dwAddressTypeFlags);
									}
									else
									{
										//
										// There is a local NAT.
										//
										DPFX(DPFPREP, 7, "Socketport 0x%p is locally mapped on gateway with NAT Help index %u (flags = 0x%lx), public address:",
											pTempSocketPort, dwTemp, dwAddressTypeFlags);
										DumpSocketAddress(7, &saddrTemp, AF_INET);
										

										//
										// Are we receiving via an endpoint on the public
										// adapter for that locally NATted endpoint?
										//
										if ( pSocketAddress->CompareToBaseAddress( &saddrTemp ) == 0)
										{
											//
											// If this response came from a private address,
											// then it would be better if the private adapter
											// handled it instead.
											//
											hrTemp = IDirectPlayNATHelp_QueryAddress(g_papNATHelpObjects[dwTemp],
																						pTempSocketPort->GetNetworkAddress()->GetAddress(),
																						pReturnSocketAddress->GetAddress(),
																						&saddrTemp,
																						sizeof(saddrTemp),
																						(DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND | DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED));
											if ((hrTemp == DPNH_OK) || (hrTemp == DPNHERR_NOMAPPINGBUTPRIVATE))
											{
												//
												// The address is private.  Drop this response,
												// and assume the private adapter will get one
												//
												DPFX(DPFPREP, 3, "Got enum response via public endpoint 0x%p that should be handled by associated private endpoint 0x%p instead, dropping.",
													this, pTempEndpoint);

												//
												// Clear the sender address so that we don't
												// indicate this enum.
												//
												IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
												QueryResponseData.pAddressSender = NULL;
											}
											else
											{
												//
												// The address does not appear to be private.  Let the
												// response through.
												//
												DPFX(DPFPREP, 3, "Receiving enum response via public endpoint 0x%p but associated private endpoint 0x%p does not see sender as local (err = 0x%lx).",
													this, pTempEndpoint, hrTemp);
											}

											//
											// No need to search for any more private-side
											// endpoints.
											//
											fFoundMatchingEndpoint = TRUE;
										}
										else
										{
											DPFX(DPFPREP, 8, "Receiving enum response via endpoint 0x%p, which is not on the public adapter for associated multiplex endpoint 0x%p.",
												this, pTempEndpoint);
										}


										//
										// No need to search for any more NAT Help
										// registrations.
										//
										break;
									} // end else (is mapped locally on Internet gateway)
								}
								else
								{
									//
									// No DirectPlay NAT Helper registration in this slot.
									//
								}
							} // end for (each DirectPlay NAT Helper)

							//
							// If we found a matching private adapter, we can stop
							// searching.
							//
							if (fFoundMatchingEndpoint)
							{
								break;
							}
						}
						else
						{
							DNASSERT(pTempEndpoint->GetState() == ENDPOINT_STATE_DISCONNECTING);
						}


						//
						// Otherwise, go to the next endpoint.
						//
						pBilink = pBilink->GetNext();
					}
					while (pBilink != &m_blMultiplex);
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT

					//
					// Drop the lock now that we're done with the list.
					//
					pSocketData->Unlock();

					//
					// If we didn't already find a matching endpoint, see if
					// WinSock reports this as the best route for the response.
					//
					if (! fFoundMatchingEndpoint)
					{
						DNASSERT(pSocketPort == GetSocketPort());
						
#ifndef DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_ONLYWINSOCK2
						if (GetWinsockVersion() == 2)
#endif // ! DPNBUILD_ONLYWINSOCK2
						{
							if (p_WSAIoctl(pSocketPort->GetSocket(),
										SIO_ROUTING_INTERFACE_QUERY,
										(PVOID) pReturnSocketAddress->GetAddress(),
										pReturnSocketAddress->GetAddressSize(),
										&saddrTemp,
										sizeof(saddrTemp),
										&dwBytesReturned,
										NULL,
										NULL) == 0)
							{
								if (( ((SOCKADDR_IN*) (&saddrTemp))->sin_addr.S_un.S_addr != IP_LOOPBACK_ADDRESS ) &&
									( pSocketPort->GetNetworkAddress()->CompareToBaseAddress( &saddrTemp ) != 0))
								{
									//
									// The response would be better off arriving
									// on a different interface.
									//
									DPFX(DPFPREP, 3, "Got enum response via endpoint 0x%p (socketport 0x%p) that should be handled by the socketport for %hs instead, dropping.",
										this, pSocketPort, inet_ntoa(((SOCKADDR_IN*) (&saddrTemp))->sin_addr));

									//
									// Clear the sender address so that we don't
									// indicate this enum.
									//
									IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
									QueryResponseData.pAddressSender = NULL;
								}
								else
								{
									//
									// The response arrived on the interface with
									// the best route.
									//
									DPFX(DPFPREP, 3, "Receiving enum response via endpoint 0x%p (socketport 0x%p) that appears to be the best route (%hs).",
										this, pSocketPort, inet_ntoa(((SOCKADDR_IN*) (&saddrTemp))->sin_addr));
								}
							}
#ifdef DBG
							else
							{
								DWORD					dwError;
								const SOCKADDR_IN *		psaddrinTemp;



								dwError = WSAGetLastError();
								psaddrinTemp = (const SOCKADDR_IN *) pReturnSocketAddress->GetAddress();
								DPFX(DPFPREP, 0, "Couldn't query routing interface for %hs (err = %u)!  Assuming endpoint 0x%p (socketport 0x%p) is best route.",
									inet_ntoa(psaddrinTemp->sin_addr),
									dwError, this, pSocketPort);
							}
#endif // DBG
						}
#endif // DPNBUILD_NOWINSOCK2
					} // end if (didn't find matching endpoint)
				}
				else
				{
					//
					// IP broadcast enum, but no multiplexed adapters.
					//

					//
					// Drop the lock we only needed it to look for multiplexed
					// adapters.
					//
					pSocketData->Unlock();
					
					DPFX(DPFPREP, 8, "IP broadcast enum endpoint (0x%p) is not multiplexed, not checking for local NAT mapping.",
						this);
				}
#endif // ! DPNBUILD_ONLYONEADAPTER
			}
			else
			{
				psaddrinResponseSource = (const SOCKADDR_IN *) pReturnSocketAddress->GetAddress();

				//
				// It's an IP enum that wasn't sent to the broadcast address.
				// If the enum was sent to a specific port (not the DPNSVR
				// port) but we're getting a response from a different IP
				// address or port, then someone along the way is proxying/
				// NATting the data.  Store the original target in the
				// address, since it might come in handy depending on what
				// the user tries to do with that address.
				//
				if ((psaddrinResponseSource->sin_addr.S_un.S_addr != psaddrinOriginalTarget->sin_addr.S_un.S_addr) ||
					((psaddrinResponseSource->sin_port != psaddrinOriginalTarget->sin_port) &&
					 (psaddrinOriginalTarget->sin_port != HTONS(DPNA_DPNSVR_PORT))))
				{

#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))
					if (
#ifndef DPNBUILD_NOWINSOCK2
						(pSocketPort->IsUsingProxyWinSockLSP())
#endif // ! DPNBUILD_NOWINSOCK2
#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_NOREGISTRY)))
						||
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_NOREGISTRY
#ifndef DPNBUILD_NOREGISTRY
						(g_fTreatAllResponsesAsProxied)
#endif // ! DPNBUILD_NOREGISTRY
						)
					{
						PROXIEDRESPONSEORIGINALADDRESS	proa;

						
						DPFX(DPFPREP, 3, "Endpoint 0x%p (proxied socketport 0x%p) receiving enum response from different IP address and/or port.",
							this, pSocketPort);

						memset(&proa, 0, sizeof(proa));
						proa.dwSocketPortID				= pSocketPort->GetSocketPortID();
						proa.dwOriginalTargetAddressV4	= psaddrinOriginalTarget->sin_addr.S_un.S_addr;
						proa.wOriginalTargetPort		= psaddrinOriginalTarget->sin_port;
						
						//
						// Add the component, but ignore failure, we might be able
						// to survive without it.
						//
						hrTemp = IDirectPlay8Address_AddComponent( QueryResponseData.pAddressSender,					// interface
																	DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS,	// tag
																	&proa,												// component data
																	sizeof(proa),										// component data size
																	DPNA_DATATYPE_BINARY								// component data type
																	);
						if ( hrTemp != DPN_OK )
						{
							DPFX(DPFPREP, 0, "Couldn't add private proxied response original address component (err = 0x%lx)!  Ignoring.",
								hrTemp);
						}
					}
					else
#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p receiving enum response from different IP address and/or port, but socketport 0x%p not considered proxied, indicating as is.",
							this, pSocketPort);
					}
				}
				else
				{
					//
					// The IP address and port to which enum was originally
					// sent is the same as where this response came from, or
					// the port differs but the enum was originally sent to
					// the DPNSVR port, so it _should_ differ.
					//
				}
			}
		}
	}


	if ( QueryResponseData.pAddressSender != NULL )
	{
		DNASSERT( m_pActiveCommandData != NULL );

		//
		// set message data
		//
		DNASSERT( GetCommandParameters() != NULL );
		QueryResponseData.pReceivedData = pBuffer;
		QueryResponseData.dwRoundTripTime = GETTIMESTAMP() - GetCommandParameters()->dwEnumSendTimes[ uRTTIndex ];
		QueryResponseData.pUserContext = m_pActiveCommandData->GetUserContext();


		//
		// If we can't allocate the device address object, ignore this
		// enum.
		//
#ifdef DPNBUILD_XNETSECURITY
		QueryResponseData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, NULL, GetGatewayBindType() );
#else // ! DPNBUILD_XNETSECURITY
		QueryResponseData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT, GetGatewayBindType() );
#endif // ! DPNBUILD_XNETSECURITY
		if ( QueryResponseData.pAddressDevice != NULL )
		{
			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_QUERYRESPONSE 0x%p to interface 0x%p.",
				this, &QueryResponseData, m_pSPData->DP8SPCallbackInterface());
			DumpAddress( 8, _T("\t Sender:"), QueryResponseData.pAddressSender );
			DumpAddress( 8, _T("\t Device:"), QueryResponseData.pAddressDevice );
			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

			hrTemp = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_QUERYRESPONSE,						// data type
												   &QueryResponseData						// pointer to data
												   );

			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_QUERYRESPONSE [0x%lx].", this, hrTemp);

			if ( hrTemp != DPN_OK )
			{
				DPFX(DPFPREP, 0, "User returned unknown error when indicating query response!" );
				DisplayDNError( 0, hrTemp );
				DNASSERT( FALSE );
			}


			IDirectPlay8Address_Release( QueryResponseData.pAddressDevice );
			QueryResponseData.pAddressDevice = NULL;
		}

		IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
		QueryResponseData.pAddressSender = NULL;
	}

	if (fAddedThreadCount)
	{
		DWORD	dwThreadCount;
		BOOL	fNeedToComplete;


		//
		//	Decrement thread count and complete if required
		//
		fNeedToComplete = FALSE;
		Lock();
		dwThreadCount = DecRefThreadCount();
		if ((m_State == ENDPOINT_STATE_WAITING_TO_COMPLETE) && (dwThreadCount == 0))
		{
			fNeedToComplete = TRUE;
		}
		Unlock();

		if (fNeedToComplete)
		{
			EnumComplete( DPN_OK );
		}
	}

	DNASSERT( QueryResponseData.pAddressSender == NULL );
	DNASSERT( QueryResponseData.pAddressDevice == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserData - process received user data
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserData"

void	CEndpoint::ProcessUserData( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );

	Lock();

	switch ( m_State )
	{
		//
		// endpoint is connected
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT		hr;
			SPIE_DATA	UserData;


			//
			// Although the endpoint is marked as connected, it's possible that
			// we haven't stored the user context yet.  Make sure we've done
			// that.
			//
			if ( ! m_fConnectSignalled )
			{
				DPFX(DPFPREP, 1, "(0x%p) Thread indicating connect has not stored user context yet, dropping read data 0x%p.",
					this, pReadData);
				Unlock();
				break;
			}

			//
			// we're connected report the user data
			//
			DEBUG_ONLY( memset( &UserData, 0x00, sizeof( UserData ) ) );
			UserData.pEndpointContext = GetUserEndpointContext();

			Unlock();
			
			UserData.hEndpoint = (HANDLE) this;
			UserData.pReceivedData = pReadData->ReceivedBuffer();

			
			//
			// it's possible that the user will want to keep the data, add a
			// reference to keep it from going away
			//
			pReadData->AddRef();
			DEBUG_ONLY( DNASSERT( pReadData->m_fRetainedByHigherLayer == FALSE ) );
			DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = TRUE );


			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DATA 0x%p to interface 0x%p.",
				this, &UserData, m_pSPData->DP8SPCallbackInterface());
			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);
		
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to interface
											   SPEV_DATA,								// user data was received
											   &UserData								// pointer to data
											   );

			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DATA [0x%lx].", this, hr);

			switch ( hr )
			{
				//
				// user didn't keep the data, remove the reference added above
				//
				case DPN_OK:
				{
					DNASSERT( pReadData != NULL );
					DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
					pReadData->DecRef();
					break;
				}

				//
				// The user kept the data buffer, they will return it later.
				// Leave the reference to prevent this buffer from being returned
				// to the pool.
				//
				case DPNERR_PENDING:
				{
					break;
				}

				//
				// Unknown return.  Remove the reference added above.
				//
				default:
				{
					DNASSERT( pReadData != NULL );
					DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
					pReadData->DecRef();

					DPFX(DPFPREP, 0, "User returned unknown error when indicating user data (err = 0x%lx)!", hr );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// Endpoint hasn't finished connecting yet, ignore data.
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DPFX(DPFPREP, 3, "Endpoint 0x%p still connecting, dropping read data 0x%p.",
				this, pReadData);
			Unlock();
			break;
		}
		
		//
		// Endpoint disconnecting, ignore data.
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 3, "Endpoint 0x%p disconnecting, dropping read data 0x%p.",
				this, pReadData);
			Unlock();
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			Unlock();
			break;
		}
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserDataOnListen - process received user data on a listen
//		port that may result in a new connection
//
// Entry:		Pointer to received data
//				Pointer to socket address that data was received from
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserDataOnListen"

void	CEndpoint::ProcessUserDataOnListen( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress )
{
	HRESULT					hr;
	CEndpoint *				pNewEndpoint;
	SPIE_DATA_UNCONNECTED	DataUnconnected;
	BYTE					abUnconnectedReplyBuffer[MAX_SEND_FRAME_SIZE];
	SPIE_CONNECT			ConnectData;
	BOOL					fGotCommandRef;


	DNASSERT( pReadData != NULL );
	DNASSERT( pSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	pNewEndpoint = NULL;

	switch ( m_State )
	{
		//
		// this endpoint is still listening
		//
		case ENDPOINT_STATE_LISTEN:
		{
			break;
		}

		//
		// we're unable to process this user data, exti
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 7, "Endpoint 0x%p disconnecting, ignoring data.", this );
			goto Exit;

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

#ifndef DPNBUILD_NOMULTICAST
	//
	// Multicast listens don't auto-create new endpoints for unrecognized
	// senders.  If the user requested that he/she wanted to hear data
	// from unknown senders, then indicate the data, otherwise drop it.
	//
	if ( GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN )
	{
		DNASSERT( m_pActiveCommandData != NULL );
		DNASSERT( GetCommandParameters() != NULL );
		if ( GetCommandParameters()->PendingCommandData.ListenData.dwFlags & DPNSPF_LISTEN_ALLOWUNKNOWNSENDERS )
		{
			DPFX(DPFPREP, 7, "Endpoint 0x%p receiving data from unknown multicast sender.", this );
			ProcessMcastDataFromUnknownSender( pReadData, pSocketAddress );
		}
		else
		{
			DPFX(DPFPREP, 7, "Endpoint 0x%p ignoring data from unknown multicast sender.", this );
		}
		goto Exit;
	}
#endif // ! DPNBUILD_NOMULTICAST

	//
	// Give the user a chance to process and reply to this data without
	// allocating any endpoints.
	//
	DEBUG_ONLY( memset( &DataUnconnected, 0x00, sizeof( DataUnconnected ) ) );
	DataUnconnected.pvListenCommandContext = m_pActiveCommandData->GetUserContext();
	DataUnconnected.pReceivedData = pReadData->ReceivedBuffer();
	DataUnconnected.dwSenderAddressHash = CSocketAddress::HashFunction( (PVOID) pSocketAddress, 31 ); // hash the address to a full DWORD
	DataUnconnected.pvReplyBuffer = abUnconnectedReplyBuffer;
	DataUnconnected.dwReplyBufferSize = sizeof(abUnconnectedReplyBuffer);


	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DATA_UNCONNECTED 0x%p to interface 0x%p.",
		this, &DataUnconnected, m_pSPData->DP8SPCallbackInterface());
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to interface
									   SPEV_DATA_UNCONNECTED,				// unconnected user data was received
									   &DataUnconnected						// pointer to data
									   );

	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DATA_UNCONNECTED [0x%lx].", this, hr);

	if ( hr != DPN_OK )
	{
#pragma TODO(vanceo, "A more explicit return, like DPNSUCCESS_REPLY?")
		if ( hr == DPNSUCCESS_PENDING )
		{
			BUFFERDESC		ReplyBufferDesc;

			
			//
			// The user wants to reply to the sender without committing a connection for it.
			//
			
			DNASSERT( DataUnconnected.pvReplyBuffer == abUnconnectedReplyBuffer );
			DNASSERT( DataUnconnected.dwReplyBufferSize != 0 );
			DNASSERT( DataUnconnected.dwReplyBufferSize <= sizeof(abUnconnectedReplyBuffer) );
			
			ReplyBufferDesc.dwBufferSize = DataUnconnected.dwReplyBufferSize;
			ReplyBufferDesc.pBufferData = abUnconnectedReplyBuffer;
			
			DPFX(DPFPREP, 7, "Replying to unconnected data.");

#ifdef DPNBUILD_ASYNCSPSENDS
			m_pSocketPort->SendData( &ReplyBufferDesc, 1, pSocketAddress, NULL );
#else // ! DPNBUILD_ASYNCSPSENDS
			m_pSocketPort->SendData( &ReplyBufferDesc, 1, pSocketAddress );
#endif // ! DPNBUILD_ASYNCSPSENDS
		}
		else
		{
			//
			// The user does not care about this data.
			//
			DPFX(DPFPREP, 7, "Ignoring unconnected data (user returned 0x%lx).", hr );
			DNASSERT( ( hr == DPNERR_ABORTED ) || ( hr == DPNERR_OUTOFMEMORY ) );
		}
		
		goto Exit;
	}


	DPFX(DPFPREP, 7, "Endpoint 0x%p reporting connect on a listen.", this );

	//
	// get a new endpoint from the pool
	//
	pNewEndpoint = m_pSPData->GetNewEndpoint();
	if ( pNewEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Could not create new endpoint for new connection on listen!" );
		goto Failure;
	}
	
#ifndef DPNBUILD_NONATHELP
	pNewEndpoint->SetUserTraversalMode( GetUserTraversalMode() );
#endif // ! DPNBUILD_NONATHELP


	//
	// We are adding this endpoint to the hash table and indicating it up
	// to the user, so it's possible that it could be disconnected (and thus
 	// removed from the table) while we're still in here.  We need to
 	// hold an additional reference for the duration of this function to
  	// prevent it from disappearing while we're still indicating data.
	//
	fGotCommandRef = pNewEndpoint->AddCommandRef();
	DNASSERT( fGotCommandRef );


	//
	// open this endpoint as a new connection, since the new endpoint
	// is related to 'this' endpoint, copy local information
	//
	hr = pNewEndpoint->Open( ENDPOINT_TYPE_CONNECT_ON_LISTEN,
							 NULL,
#ifdef DPNBUILD_XNETSECURITY
							 ((IsUsingXNetSecurity()) ? (&m_ullKeyID) : NULL),		// Open has a special session data case for CONNECT_ON_LISTEN endpoints
							 ((IsUsingXNetSecurity()) ? (sizeof(m_ullKeyID)) : 0),
#else // ! DPNBUILD_XNETSECURITY
							 NULL,
							 0,
#endif // ! DPNBUILD_XNETSECURITY
							 pSocketAddress
							 );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem initializing new endpoint when indicating connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}


	hr = m_pSPData->BindEndpoint( pNewEndpoint, NULL, GetSocketPort()->GetNetworkAddress(), GATEWAY_BIND_TYPE_NONE );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind new endpoint for connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	

	//
	// Indicate connect on this endpoint.
	//
	DEBUG_ONLY( memset( &ConnectData, 0x00, sizeof( ConnectData ) ) );
	DBG_CASSERT( sizeof( ConnectData.hEndpoint ) == sizeof( pNewEndpoint ) );
	ConnectData.hEndpoint = (HANDLE) pNewEndpoint;

	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( GetCommandParameters() != NULL );
	ConnectData.pCommandContext = GetCommandParameters()->PendingCommandData.ListenData.pvContext;

	DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
	hr = pNewEndpoint->SignalConnect( &ConnectData );
	switch ( hr )
	{
		//
		// user accepted new connection
		//
		case DPN_OK:
		{
			//
			// fall through to code below
			//

			break;
		}

		//
		// user refused new connection
		//
		case DPNERR_ABORTED:
		{
			DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
			DPFX(DPFPREP, 8, "User refused new connection!" );
			goto Failure;

			break;
		}

		//
		// other
		//
		default:
		{
			DPFX(DPFPREP, 0, "Unknown return when indicating connect event on new connect from listen!" );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );

			break;
		}
	}

	//
	// note that a connection has been established and send the data received
	// through this new endpoint
	//
	pNewEndpoint->ProcessUserData( pReadData );


	//
	// Remove the reference we added just after creating the endpoint.
	//
	pNewEndpoint->DecCommandRef();
	//pNewEndpoint = NULL;

Exit:
	return;

Failure:
	if ( pNewEndpoint != NULL )
	{
		//
		// closing endpoint decrements reference count and may return it to the pool
		//
		pNewEndpoint->Close( hr );
		m_pSPData->CloseEndpointHandle( pNewEndpoint );
		pNewEndpoint->DecCommandRef();	// remove reference added just after creating endpoint
		//pNewEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


#ifndef DPNBUILD_NOMULTICAST
//**********************************************************************
// ------------------------------
// CEndpoint::ProcessMcastDataFromUnknownSender - process received user data from an unknown multicast sender
//
// Entry:		Pointer to received data
//				Pointer to socket address that data was received from
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessMcastDataFromUnknownSender"

void	CEndpoint::ProcessMcastDataFromUnknownSender( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress )
{
	HRESULT						hr;
	IDirectPlay8Address *		pSenderAddress;
	SPIE_DATA_UNKNOWNSENDER		UserData;

	
	DNASSERT( pReadData != NULL );
	DNASSERT( pSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	pSenderAddress = pSocketAddress->DP8AddressFromSocketAddress( SP_ADDRESS_TYPE_READ_HOST );
	if (pSenderAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't convert socket address to DP8Address, ignoring data.");
		return;
	}

	//
	// it's possible that the user wants to keep the data, add a
	// reference to keep it from going away
	//
	pReadData->AddRef();
	DEBUG_ONLY( DNASSERT( pReadData->m_fRetainedByHigherLayer == FALSE ) );
	DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = TRUE );

	//
	// we're connected report the user data
	//
	DEBUG_ONLY( memset( &UserData, 0x00, sizeof( UserData ) ) );
	UserData.pSenderAddress = pSenderAddress;
	UserData.pvListenCommandContext = m_pActiveCommandData->GetUserContext();
	UserData.pReceivedData = pReadData->ReceivedBuffer();


	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DATA_UNKNOWNSENDER 0x%p to interface 0x%p.",
		this, &UserData, m_pSPData->DP8SPCallbackInterface());
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to interface
									   SPEV_DATA_UNKNOWNSENDER,					// user data was received
									   &UserData								// pointer to data
									   );

	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DATA_UNKNOWNSENDER [0x%lx].", this, hr);

	switch ( hr )
	{
		//
		// user didn't keep the data, remove the reference added above
		//
		case DPN_OK:
		{
			DNASSERT( pReadData != NULL );
			DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
			pReadData->DecRef();
			break;
		}

		//
		// The user kept the data buffer, they will return it later.
		// Leave the reference to prevent this buffer from being returned
		// to the pool.
		//
		case DPNERR_PENDING:
		{
			break;
		}


		//
		// Unknown return.  Remove the reference added above.
		//
		default:
		{
			DNASSERT( pReadData != NULL );
			DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
			pReadData->DecRef();

			DPFX(DPFPREP, 0, "User returned unknown error when indicating user data (err = 0x%lx)!", hr );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );

			break;
		}
	}

	IDirectPlay8Address_Release(pSenderAddress);
	pSenderAddress = NULL;

	return;
}
//**********************************************************************
#endif // ! DPNBUILD_NOMULTICAST


//**********************************************************************
// ------------------------------
// CEndpoint::EnumTimerCallback - timed callback to send enum data
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumTimerCallback"

void	CEndpoint::EnumTimerCallback( void *const pContext )
{
	CCommandData	*pCommandData;
	CEndpoint		*pThisObject;
	BUFFERDESC		*pBuffers;
	BUFFERDESC		aBuffers[3];
	UINT_PTR		uiBufferCount;
	WORD			wEnumKey;
	PREPEND_BUFFER	PrependBuffer;

	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pCommandData = static_cast<CCommandData*>( pContext );
	pThisObject = pCommandData->GetEndpoint();

	pThisObject->Lock();

	switch ( pThisObject->m_State )
	{
		//
		// we're enumerating (as expected)
		//
		case ENDPOINT_STATE_ENUM:
		{
			break;
		}

		//
		// this endpoint is disconnecting, bail!
		//
		case ENDPOINT_STATE_WAITING_TO_COMPLETE:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			pThisObject->Unlock();
			goto Exit;

			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	pThisObject->Unlock();

	pThisObject->GetCommandParameters()->dwEnumSendIndex++;
	pThisObject->GetCommandParameters()->dwEnumSendTimes[ ( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK ) ] = GETTIMESTAMP();

	DPFX(DPFPREP, 8, "Socketport 0x%p, endpoint 0x%p sending enum RTT index 0x%x/%u.",
		pThisObject->GetSocketPort(),
		pThisObject,
		( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK ),
		( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK )); 

	pBuffers = pThisObject->GetCommandParameters()->PendingCommandData.EnumQueryData.pBuffers;
	uiBufferCount = pThisObject->GetCommandParameters()->PendingCommandData.EnumQueryData.dwBufferCount;
	wEnumKey = pThisObject->GetEnumKey()->GetKey();
	wEnumKey |= (WORD) ( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK );

	PrependBuffer.EnumDataHeader.bSPLeadByte = SP_HEADER_LEAD_BYTE;
	PrependBuffer.EnumDataHeader.bSPCommandByte = ENUM_DATA_KIND;
	PrependBuffer.EnumDataHeader.wEnumPayload = wEnumKey;

	aBuffers[0].pBufferData = reinterpret_cast<BYTE*>( &PrependBuffer.EnumDataHeader );
	aBuffers[0].dwBufferSize = sizeof( PrependBuffer.EnumDataHeader );
	DNASSERT(uiBufferCount <= 2);
	memcpy(&aBuffers[1], pBuffers, (uiBufferCount * sizeof(BUFFERDESC)));
	uiBufferCount++;

#ifdef DPNBUILD_ASYNCSPSENDS
	pThisObject->GetSocketPort()->SendData( aBuffers, uiBufferCount, pThisObject->GetRemoteAddressPointer(), NULL );
#else // ! DPNBUILD_ASYNCSPSENDS
	pThisObject->GetSocketPort()->SendData( aBuffers, uiBufferCount, pThisObject->GetRemoteAddressPointer() );
#endif // ! DPNBUILD_ASYNCSPSENDS

Exit:
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalConnect - note connection
//
// Entry:		Pointer to connect data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalConnect"

HRESULT	CEndpoint::SignalConnect( SPIE_CONNECT *const pConnectData )
{
	HRESULT	hr;


	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hEndpoint == (HANDLE) this );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );


	//
	// Lock while we check state.
	//
	Lock();

	//
	// initialize
	//
	hr = DPN_OK;

	switch ( m_State )
	{
		//
		// disconnecting, nothing to do
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 1, "Endpoint 0x%p disconnecting, not indicating event.",
				this);
			
			//
			// Drop the lock.
			//
			Unlock();

			hr = DPNERR_USERCANCEL;
			
			break;
		}

		//
		// we're attempting to connect
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DNASSERT( m_fConnectSignalled == FALSE );

			//
			// Set the state as connected.
			//
			m_State = ENDPOINT_STATE_CONNECT_CONNECTED;

			//
			// Add a reference for the user.
			//
			AddRef();

			//
			// Drop the lock.
			//
			Unlock();

		
			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_CONNECT 0x%p to interface 0x%p.",
				this, pConnectData, m_pSPData->DP8SPCallbackInterface());
			AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
											   SPEV_CONNECT,							// event type
											   pConnectData								// pointer to data
											   );

			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_CONNECT [0x%lx].", this, hr);

			switch ( hr )
			{
				//
				// connection accepted
				//
				case DPN_OK:
				{
					//
					// note that we're connected, unless we're already trying to
					// disconnect.
					//
					
					Lock();
					
					SetUserEndpointContext( pConnectData->pEndpointContext );
					m_fConnectSignalled = TRUE;

					if (m_State == ENDPOINT_STATE_DISCONNECTING)
					{
						//
						// Although the endpoint is disconnecting, whatever caused the
						// disconnect will release the reference added before we indicated
						// the connect.
						//

						DPFX(DPFPREP, 1, "Endpoint 0x%p already disconnecting.", this);
					}
					else
					{
						DNASSERT(m_State == ENDPOINT_STATE_CONNECT_CONNECTED);

						//
						// The reference added before we indicated the connect will be
						// removed when the endpoint is disconnected.
						//
					}

					Unlock();
					
					break;
				}

				//
				// user aborted connection attempt, nothing to do, just pass
				// the result on
				//
				case DPNERR_ABORTED:
				{
					DNASSERT( GetUserEndpointContext() == NULL );
					
					//
					// Remove the user reference.
					//
					DecRef();
					
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					
					//
					// Remove the user reference.
					//
					DecRef();
					
					break;
				}
			}

			break;
		}

		//
		// states where we shouldn't be getting called
		//
		default:
		{
			DNASSERT( FALSE );
			
			//
			// Drop the lock.
			//
			Unlock();
			
			break;
		}
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalDisconnect - note disconnection
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint's data is locked!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalDisconnect"

void	CEndpoint::SignalDisconnect( void )
{
	HRESULT				hr;
	SPIE_DISCONNECT		DisconnectData;


	// tell user that we're disconnecting
	DNASSERT( m_fConnectSignalled != FALSE );
	DBG_CASSERT( sizeof( DisconnectData.hEndpoint ) == sizeof( this ) );
	DisconnectData.hEndpoint = (HANDLE) this;
	DisconnectData.pEndpointContext = GetUserEndpointContext();
	m_fConnectSignalled = FALSE;
	
	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DISCONNECT 0x%p to interface 0x%p.",
		this, &DisconnectData, m_pSPData->DP8SPCallbackInterface());
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);
		
	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
									   SPEV_DISCONNECT,							// event type
									   &DisconnectData							// pointer to data
									   );

	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DISCONNECT [0x%lx].", this, hr);

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with SignalDisconnect!" );
		DisplayDNError( 0, hr );
		DNASSERT( FALSE );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompletePendingCommand - complete a pending command
//
// Entry:		Error code returned for command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompletePendingCommand"

void	CEndpoint::CompletePendingCommand( const HRESULT hCommandResult )
{
	HRESULT								hr;
	ENDPOINT_COMMAND_PARAMETERS *		pCommandParameters;
	CCommandData *						pActiveCommandData;


	DNASSERT( GetCommandParameters() != NULL );
	DNASSERT( m_pActiveCommandData != NULL );

	pCommandParameters = GetCommandParameters();
	SetCommandParameters( NULL );

	pActiveCommandData = m_pActiveCommandData;
	m_pActiveCommandData = NULL;


	DPFX(DPFPREP, 5, "Endpoint 0x%p completing command 0x%p (result = 0x%lx, user context = 0x%p) to interface 0x%p.",
		this, pActiveCommandData, hCommandResult,
		pActiveCommandData->GetUserContext(),
		m_pSPData->DP8SPCallbackInterface());
	// NOTE: Enum commands may have timer data lock held

	hr = IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),	// pointer to callbacks
										pActiveCommandData,						// command handle
										hCommandResult,							// return
										pActiveCommandData->GetUserContext()	// user cookie
										);

	DPFX(DPFPREP, 5, "Endpoint 0x%p returning from command complete [0x%lx].", this, hr);


	memset( pCommandParameters, 0x00, sizeof( *pCommandParameters ) );
	g_EndpointCommandParametersPool.Release( pCommandParameters );
	
	
	pActiveCommandData->DecRef();
	pActiveCommandData = NULL;

}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::PoolAllocFunction"

BOOL	CEndpoint::PoolAllocFunction( void* pvItem, void* pvContext )
{
	DNASSERT( pvContext != NULL );
	
	CEndpoint* pEndpoint = (CEndpoint*) pvItem;
	const CSPData * pSPData = (CSPData*) pvContext;

	pEndpoint->m_Sig[0] = 'I';
	pEndpoint->m_Sig[1] = 'P';
	pEndpoint->m_Sig[2] = 'E';
	pEndpoint->m_Sig[3] = 'P';
	
	pEndpoint->m_State = ENDPOINT_STATE_UNINITIALIZED;
	pEndpoint->m_fConnectSignalled = FALSE;
	pEndpoint->m_EndpointType = ENDPOINT_TYPE_UNKNOWN;
	pEndpoint->m_pSPData = NULL;
	pEndpoint->m_pSocketPort = NULL;
	pEndpoint->m_GatewayBindType = GATEWAY_BIND_TYPE_UNKNOWN;
	pEndpoint->m_pUserEndpointContext = NULL;
	pEndpoint->m_fListenStatusNeedsToBeIndicated = FALSE;
	pEndpoint->m_EnumsAllowedState = ENUMSNOTREADY;
	pEndpoint->m_lRefCount = 0;
#ifdef DPNBUILD_ONLYONETHREAD
	pEndpoint->m_lCommandRefCount = 0;
#else // ! DPNBUILD_ONLYONETHREAD
	memset(&pEndpoint->m_CommandRefCount, 0, sizeof(pEndpoint->m_CommandRefCount));
#endif // ! DPNBUILD_ONLYONETHREAD
	pEndpoint->m_pCommandParameters = NULL;
	pEndpoint->m_pActiveCommandData = NULL;
	pEndpoint->m_dwThreadCount = 0;
#ifndef DPNBUILD_ONLYONEADAPTER
	pEndpoint->m_dwEndpointID = 0;
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOMULTICAST
#ifdef WINNT
	pEndpoint->m_fMADCAPTimerJobSubmitted = FALSE;
#endif // WINNT
#endif // ! DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_NOSPUI
	pEndpoint->m_hActiveSettingsDialog = NULL;
	memset( pEndpoint->m_TempHostName, 0x00, sizeof( pEndpoint->m_TempHostName ) );
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_ONLYONEADAPTER
	pEndpoint->m_blMultiplex.Initialize();
#endif // ! DPNBUILD_ONLYONEADAPTER
	pEndpoint->m_blSocketPortList.Initialize();

	DEBUG_ONLY( pEndpoint->m_fEndpointOpen = FALSE );

#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pEndpoint->m_pRemoteMachineAddress = (CSocketAddress*)g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pEndpoint->m_pRemoteMachineAddress = (CSocketAddress*)g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pSPData->GetType()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if (pEndpoint->m_pRemoteMachineAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Failed to allocate Address for new endpoint!" );
		goto Failure;
	}

	//
	// attempt to initialize the internal critical section
	//
	if ( DNInitializeCriticalSection( &pEndpoint->m_Lock ) == FALSE )
	{
		DPFX(DPFPREP, 0, "Problem initializing critical section for this endpoint!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &pEndpoint->m_Lock, 0 );
	DebugSetCriticalSectionGroup( &pEndpoint->m_Lock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes

	return TRUE;

Failure:
	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::PoolInitFunction - function called when item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::PoolInitFunction"

void CEndpoint::PoolInitFunction( void* pvItem, void* pvContext )
{
	CEndpoint* pEndpoint = (CEndpoint*) pvItem;
	CSPData * pSPData = (CSPData*) pvContext;

	DPFX(DPFPREP, 8, "This = 0x%p, context = 0x%p", pvItem, pvContext);
	
	DNASSERT( pSPData != NULL );
	DNASSERT( pEndpoint->m_pSPData == NULL );

	pEndpoint->m_pSPData = pSPData;
	pEndpoint->m_pSPData->ObjectAddRef();

	pEndpoint->m_dwNumReceives = 0;
	pEndpoint->m_hrPendingCommandResult = DPNERR_GENERIC;
#ifndef DPNBUILD_ONLYONEADAPTER
	//
	// NOTE: This doesn't work properly on Windows 95.  From MSDN:
	// "the return value is positive, but it is not necessarily equal to the result."
	// All endpoints will probably get an ID of 1 on that platform.
	//
	pEndpoint->m_dwEndpointID = (DWORD) DNInterlockedIncrement((LONG*) (&g_dwCurrentEndpointID));
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifdef DPNBUILD_XNETSECURITY
	pEndpoint->m_fXNetSecurity = FALSE;
#endif // DPNBUILD_XNETSECURITY

	DNASSERT( pEndpoint->m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( pEndpoint->m_EnumsAllowedState == ENUMSNOTREADY );
#ifndef DPNBUILD_ONLYONEADAPTER
	DNASSERT( pEndpoint->m_blMultiplex.IsEmpty() );
#endif // ! DPNBUILD_ONLYONEADAPTER
	DNASSERT( pEndpoint->m_blSocketPortList.IsEmpty() );
	DNASSERT( pEndpoint->m_pCommandParameters == NULL );
	DNASSERT( pEndpoint->m_pRemoteMachineAddress != NULL );
	
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	pEndpoint->m_pRemoteMachineAddress->SetFamilyProtocolAndSize(pSPData->GetType());
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX

	DNASSERT( pEndpoint->m_lRefCount == 0 );
	pEndpoint->m_lRefCount = 1;
#ifdef DPNBUILD_ONLYONETHREAD
	DNASSERT( pEndpoint->m_lCommandRefCount == 0 );
	pEndpoint->m_lCommandRefCount = 1;
#else // ! DPNBUILD_ONLYONETHREAD
	DNASSERT( pEndpoint->m_CommandRefCount.wRefCount == 0 );
	pEndpoint->m_CommandRefCount.wRefCount = 1;
#endif // ! DPNBUILD_ONLYONETHREAD
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::PoolReleaseFunction - function called when item is returning
//		to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::PoolReleaseFunction"

void	CEndpoint::PoolReleaseFunction( void* pvItem )
{
	DPFX(DPFPREP, 8, "This = 0x%p", pvItem);
	
	CEndpoint* pEndpoint = (CEndpoint*)pvItem;

	DNASSERT( pEndpoint->m_lRefCount == 0 );

#ifndef DPNBUILD_NOMULTICAST
#ifdef WINNT
	if (pEndpoint->m_fMADCAPTimerJobSubmitted)
	{
		pEndpoint->m_pSPData->GetThreadPool()->StopTimerJob( pEndpoint, DPNERR_USERCANCEL );
		pEndpoint->m_fMADCAPTimerJobSubmitted = FALSE;
	}
#endif // WINNT
#endif // ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_ONLYONEADAPTER
	pEndpoint->SetEndpointID( 0 );
#endif // ! DPNBUILD_ONLYONEADAPTER
	
	if ( pEndpoint->CommandPending() != FALSE )
	{
		pEndpoint->CompletePendingCommand( pEndpoint->PendingCommandResult() );
	}

	if ( pEndpoint->ConnectHasBeenSignalled() != FALSE )
	{
		pEndpoint->SignalDisconnect();
	}

	DNASSERT( pEndpoint->ConnectHasBeenSignalled() == FALSE );
	
	pEndpoint->SetUserEndpointContext( NULL );

#ifdef DBG
	DNASSERT( pEndpoint->m_fEndpointOpen == FALSE );
#endif // DBG

	pEndpoint->m_EndpointType = ENDPOINT_TYPE_UNKNOWN;

	DNASSERT( pEndpoint->m_fConnectSignalled == FALSE );
	DNASSERT( pEndpoint->m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( pEndpoint->m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( pEndpoint->m_pRemoteMachineAddress != NULL );

	DNASSERT( pEndpoint->m_pSPData != NULL );
	pEndpoint->m_pSPData->ObjectDecRef();
	pEndpoint->m_pSPData = NULL;

	DNASSERT( pEndpoint->GetSocketPort() == NULL );
	DNASSERT( pEndpoint->m_pUserEndpointContext == NULL );
#ifndef DPNBUILD_NOSPUI
	DNASSERT( pEndpoint->m_hActiveSettingsDialog == NULL );
#endif // ! DPNBUILD_NOSPUI
	DNASSERT( pEndpoint->GetCommandParameters() == NULL );

	DNASSERT( pEndpoint->m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( ! pEndpoint->IsEnumAllowedOnListen() );
	pEndpoint->m_EnumsAllowedState = ENUMSNOTREADY;
#ifndef DPNBUILD_ONLYONEADAPTER
	DNASSERT( pEndpoint->m_blMultiplex.IsEmpty() );
#endif // ! DPNBUILD_ONLYONEADAPTER
	DNASSERT( pEndpoint->m_blSocketPortList.IsEmpty() );
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CEndpoint::PoolDeallocFunction - function called when item is deallocated
//		from the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::PoolDeallocFunction"

void	CEndpoint::PoolDeallocFunction( void* pvItem )
{
	CEndpoint* pEndpoint = (CEndpoint*)pvItem;

	// This class
#ifndef DPNBUILD_NOSPUI
	DNASSERT( pEndpoint->m_hActiveSettingsDialog == NULL );
#endif // !DPNBUILD_NOSPUI

#ifndef DPNBUILD_NOMULTICAST
#ifdef WINNT
	DNASSERT(! pEndpoint->m_fMADCAPTimerJobSubmitted);
#endif // WINNT
#endif // ! DPNBUILD_NOMULTICAST

	DNASSERT(pEndpoint->m_pRemoteMachineAddress != NULL);
	g_SocketAddressPool.Release(pEndpoint->m_pRemoteMachineAddress);
	pEndpoint->m_pRemoteMachineAddress = NULL;

	DNDeleteCriticalSection( &pEndpoint->m_Lock );
	DNASSERT( pEndpoint->m_pSPData == NULL );

	// Base class
	DNASSERT( pEndpoint->m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( pEndpoint->m_fConnectSignalled == FALSE );
	DNASSERT( pEndpoint->m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( pEndpoint->m_pRemoteMachineAddress == NULL );
	DNASSERT( pEndpoint->m_pSPData == NULL );
	DNASSERT( pEndpoint->m_pSocketPort == NULL );
	DNASSERT( pEndpoint->m_GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN );
	DNASSERT( pEndpoint->m_pUserEndpointContext == NULL );
#ifndef DPNBUILD_NOSPUI
	DNASSERT( pEndpoint->GetActiveDialogHandle() == NULL );
#endif // !DPNBUILD_NOSPUI
	DNASSERT( pEndpoint->m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( pEndpoint->m_EnumsAllowedState == ENUMSNOTREADY );
#ifndef DPNBUILD_ONLYONEADAPTER
	DNASSERT( pEndpoint->m_blMultiplex.IsEmpty() );
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_ONLYONETHREAD
	DNASSERT( pEndpoint->m_lCommandRefCount == 0 );
#else // ! DPNBUILD_ONLYONETHREAD
	DNASSERT( pEndpoint->m_CommandRefCount.wRefCount == 0 );
#endif // ! DPNBUILD_ONLYONETHREAD
	DNASSERT( pEndpoint->m_pCommandParameters == NULL );
	DNASSERT( pEndpoint->m_pActiveCommandData == NULL );

#ifdef DBG
	DNASSERT( pEndpoint->m_fEndpointOpen == FALSE );
#endif // DBG

	DNASSERT( pEndpoint->m_lRefCount == 0 );
}
//**********************************************************************

#ifndef DPNBUILD_NOSPUI
//**********************************************************************
// ------------------------------
// CEndpoint::ShowSettingsDialog - show dialog for settings
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::ShowSettingsDialog"

HRESULT	CEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
{
	HRESULT	hr;


	DNASSERT( pThreadPool != NULL );
	DNASSERT( GetActiveDialogHandle() == NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to start IP hostname dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SettingsDialogComplete - dialog has completed
//
// Entry:		Error code for dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::SettingsDialogComplete"

void	CEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
{
	HRESULT					hr;
	IDirectPlay8Address		*pBaseAddress;
	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
	DWORD					dwWCharHostNameSize;
	TCHAR					*pPortString;
	TCHAR					*pLastPortChar;
	DWORD					dwPort;
	DWORD					dwNumPortSeparatorsFound;
#ifndef DPNBUILD_NOIPV6
	BOOL					fNonIPv6AddrCharFound;
#endif // ! DPNBUILD_NOIPV6


	//
	// initialize
	//
	hr = hDialogResult;
	pBaseAddress = NULL;
	pPortString = NULL;
	dwPort = 0;
	dwNumPortSeparatorsFound = 0;
#ifndef DPNBUILD_NOIPV6
	fNonIPv6AddrCharFound = FALSE;
#endif // ! DPNBUILD_NOIPV6


	//
	// dialog failed, fail the user's command
	//
	if ( hr != DPN_OK )
	{
		if ( hr != DPNERR_USERCANCEL)
		{
			DPFX(DPFPREP, 0, "Failing endpoint hostname dialog for endpoint 0x%p!", this );
			DisplayErrorCode( 0, hr );

		}
		else
		{
			DPFX(DPFPREP, 1, "Cancelling endpoint hostname dialog for endpoint 0x%p.", this );
		}

		goto Failure;
	}

	//
	// The dialog completed OK, rebuild remote address and complete command
	//

	DPFX(DPFPREP, 1, "Dialog completed successfully, got host name \"%s\" for endpoint 0x%p.",
		m_TempHostName, this);

	//
	// get the base DNADDRESS
	//
	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress( SP_ADDRESS_TYPE_HOST );
	if ( pBaseAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
		goto Failure;
	}

	//
	// If there is a port separator in the string, replace it with a NULL
	// to terminate the hostname and advance the port start index past the
	// separator.  Only indicate the presence of a port if the character
	// following the port separator is numeric, except in the IPv6 case.
	// IPv6 address can contain colons, too, so we will only remember the
	// last colon we saw, and whether we found any characters that aren't
	// allowed to be in an IPv6 address.
	//
	pPortString = m_TempHostName;
	while ( *pPortString != 0 )
	{
		if (*pPortString == TEXT(':'))
		{
			pLastPortChar = pPortString;
			dwNumPortSeparatorsFound++;
#ifdef DPNBUILD_NOIPV6
			break;
#endif // DPNBUILD_NOIPV6
		}
#ifndef DPNBUILD_NOIPV6
		else
		{
			if ((*pPortString >= TEXT('0') && (*pPortString <= TEXT('9'))) ||
				(*pPortString >= TEXT('a') && (*pPortString <= TEXT('f'))) ||
				(*pPortString >= TEXT('A') && (*pPortString <= TEXT('F'))) ||
				(*pPortString == TEXT('.'))) // the ':' character is covered above
			{
				//
				// It's a valid IPv6 character.
				//
			}
			else
			{
				fNonIPv6AddrCharFound = TRUE;
			}
		}
#endif // ! DPNBUILD_NOIPV6

		pPortString = CharNext( pPortString );
	}

	//
	// If a port was found, attempt to convert it from text.  If the resulting
	// port is zero, treat as if the port wasn't found.
	//
	if ( dwNumPortSeparatorsFound > 0 )
	{
		//
		// IPv6 addresses must have at least 2 colons, and can only contain
		// a specific set of characters.  But if we met that criteria, we can't
		// tell whether a port was specified or not.  We will have to assume
		// it was not.
		//
#ifndef DPNBUILD_NOIPV6
		if ((dwNumPortSeparatorsFound > 1) && (! fNonIPv6AddrCharFound))
		{
			DPFX(DPFPREP, 1, "Found %u port-separator and 0 invalid characters, assuming IPv6 address without a port.",
				dwNumPortSeparatorsFound );
			dwNumPortSeparatorsFound = 0;
		}
		else
#endif // ! DPNBUILD_NOIPV6
		{
			*pLastPortChar = 0;	// terminate hostname string at separator character
			pPortString = pLastPortChar + 1;
			
			while ( *pPortString != 0 )
			{
				if ( ( *pPortString < TEXT('0') ) ||
					 ( *pPortString > TEXT('9') ) )
				{
					hr = DPNERR_ADDRESSING;
					DPFX(DPFPREP, 0, "Invalid characters when parsing port from UI!" );
					goto Failure;
				}

				dwPort *= 10;
				dwPort += *pPortString - TEXT('0');

				if ( dwPort > WORD_MAX )
				{
					hr = DPNERR_ADDRESSING;
					DPFX(DPFPREP, 0, "Invalid value when parsing port from UI!" );
					goto Failure;
				}

				pPortString = CharNext( pPortString );
			}

			DNASSERT( dwPort < WORD_MAX );

			if ( dwPort == 0 )
			{
				dwNumPortSeparatorsFound = 0;
			}
		}
	}

	//
	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
	// and this is an enum, copy the broadcast hostname.  If the hostname is blank
	// on a connect, fail!
	//
	if ( m_TempHostName[ 0 ] == 0 )
	{
		if ( GetType() == ENDPOINT_TYPE_ENUM )
		{
			//
			// PREfast doesn't like unvalidated sizes for memcpys, so just double
			// check that it's reasonable.
			//
#ifndef DPNBUILD_NOIPV6
			if (g_iIPAddressFamily == PF_INET6)
			{
				DBG_CASSERT((sizeof(WCharHostName) / sizeof(WCHAR)) >= INET6_ADDRSTRLEN);
				DNIpv6AddressToStringW(&c_in6addrEnumMulticast, WCharHostName);
				dwWCharHostNameSize = (wcslen(WCharHostName) + 1) * sizeof(WCHAR);
			}
			else
#endif // ! DPNBUILD_NOIPV6
			{
				if ( g_dwIPBroadcastAddressSize < sizeof( WCharHostName ) )
				{
					memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
					dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
				}
				else
				{
					DNASSERT( FALSE );
					hr = DPNERR_GENERIC;
					goto Failure;
				}
			}
		}
		else
		{
			hr = DPNERR_ADDRESSING;
			DNASSERT( GetType() == ENDPOINT_TYPE_CONNECT );
			DPFX(DPFPREP, 0, "No hostname in dialog!" );
			goto Failure;
		}
	}
	else
	{
#ifdef UNICODE
		dwWCharHostNameSize = (wcslen(m_TempHostName) + 1) * sizeof(WCHAR);
		memcpy( WCharHostName, m_TempHostName, dwWCharHostNameSize );
#else
		dwWCharHostNameSize = LENGTHOF( WCharHostName );
		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
		DNASSERT( hr == DPN_OK );
		dwWCharHostNameSize *= sizeof( WCHAR );
#endif // UNICODE
	}

	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "SettingsDialogComplete: Failed to add hostname to address!" );
		goto Failure;
	}

	//
	// if there was a specified port, add it to the address
	//
	if ( dwNumPortSeparatorsFound > 0 )
	{
		hr = IDirectPlay8Address_AddComponent( pBaseAddress,
											   DPNA_KEY_PORT,
											   &dwPort,
											   sizeof( dwPort ),
											   DPNA_DATATYPE_DWORD
											   );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to add user specified port from the UI!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
	else
	{
		//
		// There was no port specified.  If this is a connect, then we don't
		// have enough information (we can't try connecting to the DPNSVR
		// port).
		//
		if ( GetType() == ENDPOINT_TYPE_CONNECT )
		{
			hr = DPNERR_ADDRESSING;
			DPFX(DPFPREP, 0, "No port specified in dialog!" );
			goto Failure;
		}
		else
		{
			DNASSERT( GetType() == ENDPOINT_TYPE_ENUM );
		}
	}


	//
	// set the address
	//
	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress,
#ifdef DPNBUILD_XNETSECURITY
															NULL,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
															TRUE,
#endif // DPNBUILD_ONLYONETHREAD
															SP_ADDRESS_TYPE_HOST );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to rebuild address when completing IP hostname dialog!" );
		goto Failure;
	}
			
	//
	// Make sure its valid and not banned.
	//
	if (! m_pRemoteMachineAddress->IsValidUnicastAddress((GetType() == ENDPOINT_TYPE_ENUM) ? TRUE : FALSE))
	{
		DPFX(DPFPREP, 0, "Host address is invalid!");
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto Failure;
	}

#ifndef DPNBUILD_NOREGISTRY
	if (m_pRemoteMachineAddress->IsBannedAddress())
	{
		DPFX(DPFPREP, 0, "Host address is banned!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}
#endif // ! DPNBUILD_NOREGISTRY


#ifndef DPNBUILD_NONATHELP
	//
	// Try to get NAT help loaded, if it isn't already and we're allowed.
	//
	if (GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE)
	{
		DPFX(DPFPREP, 7, "Ensuring that NAT help is loaded.");
		m_pSPData->GetThreadPool()->EnsureNATHelpLoaded();
	}
#endif // ! DPNBUILD_NONATHELP


	AddRef();

	//
	// Since any asynchronous I/O posted on a thread is quit when the thread
	// exits, it's necessary for the completion of this operation to happen
	// on one of the thread pool threads.
	//
	switch ( GetType() )
	{
	    case ENDPOINT_TYPE_ENUM:
	    {
#ifdef DPNBUILD_ONLYONEPROCESSOR
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::EnumQueryJobCallback,
																	this );
#else // ! DPNBUILD_ONLYONEPROCESSOR
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( -1,									// we don't know the CPU yet, so pick any
																	CEndpoint::EnumQueryJobCallback,
																	this );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP, 0, "Failed to set enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

	    case ENDPOINT_TYPE_CONNECT:
	    {
#ifdef DPNBUILD_ONLYONEPROCESSOR
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::ConnectJobCallback,
																	this );
#else // ! DPNBUILD_ONLYONEPROCESSOR
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( -1,									// we don't know the CPU yet, so pick any
																	CEndpoint::ConnectJobCallback,
																	this );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP, 0, "Failed to set enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

	    //
	    // unknown!
	    //
	    default:
	    {
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
	    	goto Failure;

	    	break;
	    }
	}

Exit:
	//
	// clear the handle to the dialog, it's the canceler's responsibility to clean up
	// now (or we already have).
	//
	Lock();
	SetActiveDialogHandle( NULL );
	Unlock();
	
	if ( pBaseAddress != NULL )
	{
		IDirectPlay8Address_Release( pBaseAddress );
		pBaseAddress = NULL;
	}

	if ( pBaseAddress != NULL )
	{
		DNFree( pBaseAddress );
		pBaseAddress = NULL;
	}

	DecRef();

	return;

Failure:
	//
	// cleanup and close this endpoint
	//
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
		{
			CleanupConnect();
			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			CleanupEnumQuery();
			break;
		}

		//
		// other state (note that LISTEN doesn't have a dialog)
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// note that Close will attempt to close the window again
	//
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::StopSettingsDialog - stop an active settings dialog
//
// Entry:		Handle of dialog to close
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::StopSettingsDialog"

void	CEndpoint::StopSettingsDialog( const HWND hDlg)
{
	StopIPHostNameSettingsDialog( hDlg );
}
//**********************************************************************
#endif // !DPNBUILD_NOSPUI




#ifdef DPNBUILD_ASYNCSPSENDS

//**********************************************************************
// ------------------------------
// CEndpoint::CompleteAsyncSend - async send completion callback
//
// Entry:		Pointer to callback context
//				Pointer to timer data
//				Pointer to timer uniqueness value
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CEndpoint::CompleteAsyncSend"

void CEndpoint::CompleteAsyncSend( void * const pvContext,
									void * const pvTimerData,
									const UINT uiTimerUnique )
{
	HRESULT				hr;
	CCommandData *		pCommand;
	CEndpoint *			pThisEndpoint;

	
	//
	// The context is the pointer to the command data.
	//
	pCommand = (CCommandData*) pvContext;
	pThisEndpoint = pCommand->GetEndpoint();
	DNASSERT(pThisEndpoint->IsValid());


#pragma TODO(vanceo, "Would be nice to print out result returned by Winsock")


	DPFX(DPFPREP, 8, "Endpoint 0x%p completing command 0x%p (result = DPN_OK, user context = 0x%p) to interface 0x%p.",
		pThisEndpoint, pCommand,
		pCommand->GetUserContext(),
		pThisEndpoint->m_pSPData->DP8SPCallbackInterface());
	AssertNoCriticalSectionsFromGroupTakenByThisThread(&g_blDPNWSockCritSecsHeld);

	hr = IDP8SPCallback_CommandComplete( pThisEndpoint->m_pSPData->DP8SPCallbackInterface(),	// pointer to callbacks
										pCommand,											// command handle
										DPN_OK,												// return
										pCommand->GetUserContext()							// user cookie
										);

	DPFX(DPFPREP, 8, "Endpoint 0x%p returning from command complete [0x%lx].", pThisEndpoint, hr);

	pThisEndpoint->DecCommandRef();
	
	pCommand->DecRef();
	pCommand = NULL;
}
//**********************************************************************
#endif // DPNBUILD_ASYNCSPSENDS



#ifndef DPNBUILD_NOMULTICAST

//**********************************************************************
// ------------------------------
// CEndpoint::EnableMulticastReceive - Enables this endpoint for receiving multicast traffic
//
// Entry:		Pointer to socketport
//
// Exit:		HRESULT indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnableMulticastReceive"

HRESULT CEndpoint::EnableMulticastReceive( CSocketPort * const pSocketPort )
{
	HRESULT					hr;
#ifdef DBG
	DWORD					dwError;
#endif // DBG
	const CSocketAddress *	pSocketAddressDevice;
	CSocketAddress *		pSocketAddressRemote;
	const SOCKADDR_IN *		psaddrinDevice;
	SOCKADDR_IN *			psaddrinRemote;
	int						iSocketOption;
	ip_mreq					MulticastRequest;
#ifdef WINNT
	PMCAST_SCOPE_ENTRY		paScopes = NULL;
#endif // WINNT


	DPFX(DPFPREP, 7, "(0x%p) Parameters: (0x%p)", this, pSocketPort);


	DNASSERT(GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN);

	//
	// Get the socket port and socket addresses to be used.
	//
	DNASSERT(pSocketPort != NULL);
	DNASSERT(pSocketPort->GetSocket() != INVALID_SOCKET);

	pSocketAddressDevice = pSocketPort->GetNetworkAddress();
	DNASSERT(pSocketAddressDevice != NULL);
	DNASSERT(pSocketAddressDevice->GetFamily() == AF_INET);
	psaddrinDevice = (const SOCKADDR_IN *) pSocketAddressDevice->GetAddress();
	DNASSERT(psaddrinDevice->sin_addr.S_un.S_addr != INADDR_ANY);
	DNASSERT(psaddrinDevice->sin_port != ANY_PORT);

	pSocketAddressRemote = GetWritableRemoteAddressPointer();
	DNASSERT(pSocketAddressRemote != NULL);
	DNASSERT(pSocketAddressRemote->GetFamily() == AF_INET);
	psaddrinRemote = (SOCKADDR_IN*) pSocketAddressRemote->GetWritableAddress();

	//
	// If we don't have a multicast IP address yet, select one.
	//
	if (psaddrinRemote->sin_addr.S_un.S_addr == INADDR_ANY)
	{
#pragma TODO(vanceo, "Reinvestigate address selection randomness")

#define GLOBALSCOPE_MULTICAST_PREFIX		238
		//
		// Given the scope identifier the caller gave us (or the default local
		// scope), use info for that built-in scope, or look for a MADCAP match
		// and generate an appropriate address (if possible).
		//
		if (memcmp(&m_guidMulticastScope, &GUID_DP8MULTICASTSCOPE_GLOBAL, sizeof(m_guidMulticastScope)) == 0)
		{
			//
			// We need to use a global scope address.  We will use our
			// arbitrary prefix that does not seem to collide with any IANA
			// registered global addresses.
			//
			// We'll get a pseudo-random number to use for the remainder of the
			// address by selecting part of the current time.
			//
			psaddrinRemote->sin_addr.S_un.S_addr		= GETTIMESTAMP();
			psaddrinRemote->sin_addr.S_un.S_un_b.s_b1	= GLOBALSCOPE_MULTICAST_PREFIX;
		}
#ifdef WINNT
		else if ((memcmp(&m_guidMulticastScope, &GUID_DP8MULTICASTSCOPE_PRIVATE, sizeof(m_guidMulticastScope)) == 0) ||
				(memcmp(&m_guidMulticastScope, &GUID_DP8MULTICASTSCOPE_LOCAL, sizeof(m_guidMulticastScope)) == 0) ||
				(! m_pSPData->GetThreadPool()->IsMadcapLoaded()))
#else // ! WINNT
		else
#endif // ! WINNT
		{
			//
			// We want to use a local scope address.   The MADCAP spec
			// recommends 239.255.0.0/16.
			//
			// We'll get a pseudo-random number to use for the remainder of the
			// address by selecting part of the current time.
			//
			psaddrinRemote->sin_addr.S_un.S_un_w.s_w1	= 0xFFEF;	// = FF EF = EF FF byte reversed = 239.255
			psaddrinRemote->sin_addr.S_un.S_un_w.s_w2	= (WORD) GETTIMESTAMP();
		}
#ifdef WINNT
		else
		{
#ifndef DBG
			DWORD					dwError;
#endif // ! DBG
			DWORD					dwScopesSize = 0;
			DWORD					dwNumScopeEntries;
			DWORD					dwTemp;
			GUID					guidComparison;
			MCAST_LEASE_REQUEST		McastLeaseRequest;
			DWORD					dwMADCAPRetryTime;


			//
			// Determine how much room we need to hold the list of scopes.
			//
			dwError = McastEnumerateScopes(pSocketAddressRemote->GetFamily(),
											TRUE,
											NULL,
											&dwScopesSize,
											&dwNumScopeEntries);
			if ((dwError != ERROR_SUCCESS) && (dwError != ERROR_MORE_DATA))
			{
				DPFX(DPFPREP, 0, "Enumerating scopes for size required didn't return expected error (err = %u)!",
					dwError);
				hr = DPNERR_GENERIC;
				goto Failure;
			}

			if (dwScopesSize < sizeof(MCAST_SCOPE_ENTRY))
			{
				DPFX(DPFPREP, 0, "Size required for scope buffer is invalid (%u < %u)!",
					dwScopesSize, sizeof(MCAST_SCOPE_ENTRY));
				hr = DPNERR_GENERIC;
				goto Failure;
			}

			paScopes = (PMCAST_SCOPE_ENTRY) DNMalloc(dwScopesSize);
			if (paScopes == NULL)
			{
				DPFX(DPFPREP, 0, "Couldn't allocate memory for scope list!");
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}


			//
			// Retrieve the list of scopes.
			//
			dwError = McastEnumerateScopes(pSocketAddressRemote->GetFamily(),
											FALSE,
											paScopes,
											&dwScopesSize,
											&dwNumScopeEntries);
			if (dwError != ERROR_SUCCESS)
			{
				DPFX(DPFPREP, 0, "Failed enumerating scopes (err = %u)!",
					dwError);
				hr = DPNERR_GENERIC;
				goto Failure;
			}


			//
			// Look for the scope we were given.
			//
			for(dwTemp = 0; dwTemp < dwNumScopeEntries; dwTemp++)
			{
				//
				// Encrypt this scope context and TTL as a GUID for comparison.
				//
#ifdef DPNBUILD_NOIPV6
				CSocketAddress::CreateScopeGuid(&(paScopes[dwTemp].ScopeCtx),
#else // ! DPNBUILD_NOIPV6
				CSocketAddress::CreateScopeGuid(pSocketAddressRemote->GetFamily(),
												&(paScopes[dwTemp].ScopeCtx),
#endif // ! DPNBUILD_NOIPV6
												(BYTE) (paScopes[dwTemp].TTL),
												&guidComparison);

				if (memcmp(&guidComparison, &m_guidMulticastScope, sizeof(m_guidMulticastScope)) == 0)
				{
					DPFX(DPFPREP, 3, "Found scope \"%ls - TTL %u\".",
						paScopes[dwTemp].ScopeDesc.Buffer, paScopes[dwTemp].TTL);
					break;
				}

				DPFX(DPFPREP, 7, "Didn't match scope \"%ls - TTL %u\".",
					paScopes[dwTemp].ScopeDesc.Buffer, paScopes[dwTemp].TTL);
			}

			//
			// If we didn't find the scope, then we will fail because we're
			// not sure what the user wanted.
			//
			if (dwTemp >= dwNumScopeEntries)
			{
				DPFX(DPFPREP, 0, "Unrecognized scope GUID {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}!",
					m_guidMulticastScope.Data1,
					m_guidMulticastScope.Data2,
					m_guidMulticastScope.Data3,
					m_guidMulticastScope.Data4[0],
					m_guidMulticastScope.Data4[1],
					m_guidMulticastScope.Data4[2],
					m_guidMulticastScope.Data4[3],
					m_guidMulticastScope.Data4[4],
					m_guidMulticastScope.Data4[5],
					m_guidMulticastScope.Data4[6],
					m_guidMulticastScope.Data4[7]);
				hr = DPNERR_INVALIDHOSTADDRESS;
				goto Failure;
			}


			//
			// If we're here, then we found a MADCAP scope context to use.
			// Request an address.
			//

			memset(&McastLeaseRequest, 0, sizeof(McastLeaseRequest));
			//McastLeaseRequest.LeaseStartTime		= 0;									// have the lease start now
			//McastLeaseRequest.MaxLeaseStartTime	= McastLeaseRequest.LeaseStartTime;
			McastLeaseRequest.LeaseDuration			= MADCAP_LEASE_TIME;
			McastLeaseRequest.MinLeaseDuration		= McastLeaseRequest.LeaseDuration;
			//McastLeaseRequest.ServerAddress		= 0;									// unknown at this time, leave set to 0
			McastLeaseRequest.MinAddrCount			= 1;
			McastLeaseRequest.AddrCount				= 1;
			//McastLeaseRequest.pAddrBuf			= NULL;									// not requesting a specific address

			memset(&m_McastLeaseResponse, 0, sizeof(m_McastLeaseResponse));
			m_McastLeaseResponse.AddrCount			= 1;
			m_McastLeaseResponse.pAddrBuf			= (PBYTE) (&psaddrinRemote->sin_addr.S_un.S_addr);

			dwError = McastRequestAddress(pSocketAddressRemote->GetFamily(),
										&g_mcClientUid,
										&(paScopes[dwTemp].ScopeCtx),
										&McastLeaseRequest,
										&m_McastLeaseResponse);
			if (dwError != ERROR_SUCCESS)
			{
				if (dwError == ERROR_ACCESS_DENIED)
				{
					DPFX(DPFPREP, 0, "Couldn't request multicast address, access was denied!");
					hr = DPNERR_NOTALLOWED;
				}
				else
				{
					DPFX(DPFPREP, 0, "Failed requesting multicast addresses (err = %u)!",
						dwError);
					hr = DPNERR_GENERIC;
				}
				goto Failure;
			}
			
			if ((m_McastLeaseResponse.AddrCount != 1) || (psaddrinRemote->sin_addr.S_un.S_addr == INADDR_ANY))
			{
				DPFX(DPFPREP, 0, "McastRequestAddress didn't return valid response (addrcount = %u, address = %hs)!",
					m_McastLeaseResponse.AddrCount, inet_ntoa(psaddrinRemote->sin_addr));
				hr = DPNERR_GENERIC;
				goto Failure;
			}

			//
			// If we're here, we successfully leased a multicast address.
			//

			DNFree(paScopes);
			paScopes = NULL;


			//
			// Kick off a timer to renew the lease when appropriate.
			//

			// Assume that LeaseStartTime is now, so we can easily calculate the lease duration.
			DNASSERT(m_McastLeaseResponse.LeaseStartTime != 0);
			DNASSERT(m_McastLeaseResponse.LeaseEndTime != 0);
			DNASSERT((m_McastLeaseResponse.LeaseEndTime - m_McastLeaseResponse.LeaseStartTime) > 0);
			dwMADCAPRetryTime = (m_McastLeaseResponse.LeaseEndTime - m_McastLeaseResponse.LeaseStartTime) * 1000;

			DPFX(DPFPREP, 7, "Submitting MADCAP refresh timer (for every %u ms) for thread pool 0x%p.",
				dwMADCAPRetryTime, m_pSPData->GetThreadPool());

			DNASSERT(! m_fMADCAPTimerJobSubmitted);
			m_fMADCAPTimerJobSubmitted = TRUE;

#ifdef DPNBUILD_ONLYONEPROCESSOR
			hr = m_pSPData->GetThreadPool()->SubmitTimerJob(FALSE,								// don't perform immediately
															1,									// retry count
															TRUE,								// retry forever
															dwMADCAPRetryTime,					// retry timeout
															TRUE,								// wait forever
															0,									// idle timeout
															CEndpoint::MADCAPTimerFunction,		// periodic callback function
															CEndpoint::MADCAPTimerComplete,		// completion function
															this);								// context
#else // ! DPNBUILD_ONLYONEPROCESSOR
			DNASSERT(m_pSocketPort != NULL);
			hr = m_pSPData->GetThreadPool()->SubmitTimerJob(m_pSocketPort->GetCPU(),				// CPU
															FALSE,								// don't perform immediately
															1,									// retry count
															TRUE,								// retry forever
															dwMADCAPRetryTime,					// retry timeout
															TRUE,								// wait forever
															0,									// idle timeout
															CEndpoint::MADCAPTimerFunction,		// periodic callback function
															CEndpoint::MADCAPTimerComplete,		// completion function
															this);								// context
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			if (hr != DPN_OK)
			{
				m_fMADCAPTimerJobSubmitted = FALSE;
				DPFX(DPFPREP, 0, "Failed to submit timer job to watch over MADCAP lease!" );
				
				//
				// MADCAP will probably not work correctly, but that won't
				// prevent us from still using that multicast address.
				// Consider it non-fatal.
				//
			}
		}
#endif // WINNT
	}


	//
	// Nobody should have touched the port yet.  It should just be a copy of
	// the port bound on the network.
	//
	DNASSERT(psaddrinRemote->sin_port == ANY_PORT);
	psaddrinRemote->sin_port = psaddrinDevice->sin_port;


	//
	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
	// make sure we use the proper constant.
	//
#ifdef DPNBUILD_ONLYWINSOCK2
	iSocketOption = 12;
#else // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NOWINSOCK2
	switch (GetWinsockVersion())
	{
		//
		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1.
		// See WINSOCK.H
		//
		case 1:
		{
#endif // ! DPNBUILD_NOWINSOCK2
			iSocketOption = 5;
#ifndef DPNBUILD_NOWINSOCK2
			break;
		}

		//
		// Winsock2, or greater, use the IP_ADD_MEMBERSHIP value for Winsock2.
		// See WS2TCPIP.H
		//
		case 2:
		default:
		{
			DNASSERT(GetWinsockVersion() == 2);
			iSocketOption = 12;
			break;
		}
	}
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2


	DPFX(DPFPREP, 3, "(0x%p) Socketport 0x%p joining IP multicast group:", this, pSocketPort);
	DumpSocketAddress(3, pSocketAddressRemote->GetAddress(), pSocketAddressRemote->GetFamily());


	//
	// Copy the multicast address and interface address into the structure.
	//
	
	memcpy(&MulticastRequest.imr_interface,
			&(psaddrinDevice->sin_addr),
			sizeof(MulticastRequest.imr_interface));

	memcpy(&MulticastRequest.imr_multiaddr,
			&(psaddrinRemote->sin_addr),
			sizeof(MulticastRequest.imr_multiaddr));


	if (setsockopt(pSocketPort->GetSocket(),		// socket
				  IPPROTO_IP,						// option level (TCP/IP)
				  iSocketOption,					// option (join multicast group)
				  (char*) (&MulticastRequest),		// option data
				  sizeof(MulticastRequest)) != 0)	// size of option data
	{
#ifdef DBG
		dwError = WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to join IP multicast group (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}


	hr = DPN_OK;


Exit:

	DPFX(DPFPREP, 7, "(0x%p) Return: [0x%lx]", this, hr);

	return hr;


Failure:

#ifdef WINNT
	if (paScopes != NULL)
	{
		DNFree(paScopes);
		paScopes = NULL;
	}
#endif // WINNT


	goto Exit;
} // CEndpoint::EnableMulticastReceive
//**********************************************************************

//**********************************************************************
// ------------------------------
// CEndpoint::DisableMulticastReceive - Disables receiving multicast traffic for this endpoint
//
// Entry:		Pointer to socketport
//
// Exit:		HRESULT indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::DisableMulticastReceive"

HRESULT CEndpoint::DisableMulticastReceive( void )
{
	HRESULT					hr;
#ifdef DBG
	DWORD					dwError;
#endif // DBG
	CSocketPort *			pSocketPort;
	const CSocketAddress *	pSocketAddressRemote;
	const CSocketAddress *	pSocketAddressDevice;
	const SOCKADDR_IN *		psaddrinRemote;
	const SOCKADDR_IN *		psaddrinDevice;
	int						iSocketOption;
	ip_mreq					MulticastRequest;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this);


	DNASSERT(GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN);

	//
	// Get the socket port and socket addresses to be used.
	//
	pSocketPort = GetSocketPort();
	DNASSERT(pSocketPort != NULL);
	DNASSERT(pSocketPort->GetSocket() != INVALID_SOCKET);

	pSocketAddressDevice = pSocketPort->GetNetworkAddress();
	DNASSERT(pSocketAddressDevice != NULL);
	DNASSERT(pSocketAddressDevice->GetFamily() == AF_INET);
	psaddrinDevice = (const SOCKADDR_IN *) pSocketAddressDevice->GetAddress();
	DNASSERT(psaddrinDevice->sin_addr.S_un.S_addr != INADDR_ANY);
	DNASSERT(psaddrinDevice->sin_port != ANY_PORT);

	pSocketAddressRemote = GetRemoteAddressPointer();
	DNASSERT(pSocketAddressRemote != NULL);
	DNASSERT(pSocketAddressRemote->GetFamily() == AF_INET);
	psaddrinRemote = (const SOCKADDR_IN *) pSocketAddressRemote->GetAddress();
	DNASSERT(psaddrinRemote->sin_addr.S_un.S_addr != INADDR_ANY);
	DNASSERT(psaddrinRemote->sin_port != ANY_PORT);


	//
	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
	// make sure we use the proper constant.
	//
#ifdef DPNBUILD_ONLYWINSOCK2
	iSocketOption = 13;
#else // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NOWINSOCK2
	switch (GetWinsockVersion())
	{
		//
		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1.
		// See WINSOCK.H
		//
		case 1:
		{
#endif // ! DPNBUILD_NOWINSOCK2
			iSocketOption = 6;
#ifndef DPNBUILD_NOWINSOCK2
			break;
		}

		//
		// Winsock2, or greater, use the IP_DROP_MEMBERSHIP value for Winsock2.
		// See WS2TCPIP.H
		//
		case 2:
		default:
		{
			DNASSERT(GetWinsockVersion() == 2);
			iSocketOption = 13;
			break;
		}
	}
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2


	DPFX(DPFPREP, 3, "(0x%p) Socketport 0x%p leaving IP multicast group:", this, pSocketPort);
	DumpSocketAddress(3, pSocketAddressRemote->GetAddress(), pSocketAddressRemote->GetFamily());


	//
	// Copy the multicast address and interface address into the structure.
	//
	memcpy(&MulticastRequest.imr_interface,
			&(psaddrinDevice->sin_addr),
			sizeof(MulticastRequest.imr_interface));

	memcpy(&MulticastRequest.imr_multiaddr,
			&(psaddrinRemote->sin_addr),
			sizeof(MulticastRequest.imr_multiaddr));

	if (setsockopt(pSocketPort->GetSocket(),		// socket
				  IPPROTO_IP,						// option level (TCP/IP)
				  iSocketOption,					// option (leave multicast group)
				  (char*) (&MulticastRequest),		// option data
				  sizeof(MulticastRequest)) != 0)	// size of option data
	{
#ifdef DBG
		dwError = WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to leave IP multicast group (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	hr = DPN_OK;


Exit:

	DPFX(DPFPREP, 7, "(0x%p) Return: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CEndpoint::DisableMulticastReceive
//**********************************************************************



#ifdef WINNT

//**********************************************************************
// ------------------------------
// CEndpoint::MADCAPTimerComplete - MADCAP timer job has completed
//
// Entry:		Timer result code
//				Context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::MADCAPTimerComplete"

void	CEndpoint::MADCAPTimerComplete( const HRESULT hResult, void * const pContext )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::MADCAPTimerFunction - MADCAP timer job needs service
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::MADCAPTimerFunction"

void	CEndpoint::MADCAPTimerFunction( void * const pContext )
{
	CEndpoint *				pThisEndpoint;
	MCAST_LEASE_REQUEST		McastLeaseRequest;
	DWORD					dwError;
	DWORD					dwNewRetryInterval;


	DNASSERT( pContext != NULL );
	pThisEndpoint = (CEndpoint*) pContext;


#pragma BUGBUG(vanceo, "Thread protection and delayed job a la NAT Help?")

	memset(&McastLeaseRequest, 0, sizeof(McastLeaseRequest));
	//McastLeaseRequest.LeaseStartTime		= 0;									// have the lease refresh right now
	//McastLeaseRequest.MaxLeaseStartTime	= McastLeaseRequest.LeaseStartTime;
	McastLeaseRequest.LeaseDuration			= MADCAP_LEASE_TIME;
	McastLeaseRequest.MinLeaseDuration		= McastLeaseRequest.LeaseDuration;
	memcpy(&McastLeaseRequest.ServerAddress, &pThisEndpoint->m_McastLeaseResponse.ServerAddress, sizeof(McastLeaseRequest.ServerAddress));
	McastLeaseRequest.MinAddrCount			= 1;
	McastLeaseRequest.AddrCount				= 1;
	McastLeaseRequest.pAddrBuf				= pThisEndpoint->m_McastLeaseResponse.pAddrBuf;

	dwError = McastRenewAddress(AF_INET,
								&g_mcClientUid,
								&McastLeaseRequest,
								&pThisEndpoint->m_McastLeaseResponse);
	if (dwError == ERROR_SUCCESS)
	{
#pragma BUGBUG(vanceo, "Verify that start time is now instead of when we originally leased it")
		//
		// Tweak the timer interval to reflect a possible change in the
		// lease duration.
		//
		// As before, assume that LeaseStartTime is now, so we can
		// easily calculate the lease duration.
		//
		DNASSERT(pThisEndpoint->m_McastLeaseResponse.LeaseStartTime != 0);
		DNASSERT(pThisEndpoint->m_McastLeaseResponse.LeaseEndTime != 0);
		DNASSERT((pThisEndpoint->m_McastLeaseResponse.LeaseEndTime - pThisEndpoint->m_McastLeaseResponse.LeaseStartTime) > 0);
		dwNewRetryInterval = (pThisEndpoint->m_McastLeaseResponse.LeaseEndTime - pThisEndpoint->m_McastLeaseResponse.LeaseStartTime) * 1000;

		DPFX(DPFPREP, 7, "Updating MADCAP refresh timer (for every %u ms) for endpoint 0x%p.",
			dwNewRetryInterval, pThisEndpoint);

#pragma BUGBUG(vanceo, "Update MADCAP refresh timer")
	}
	else
	{
		DPFX(DPFPREP, 0, "Failed renewing multicast addresses (err = %u)!  Ignoring.",
			dwError);

		//
		// Since we can't fail directly, just ignore the error.  We'll
		// try refreshing again after the next interval (although that
		// will probably fail, too).  In the meantime, we can continue
		// using the address just fine, we simply won't "own" it.
		//
	}
}
//**********************************************************************

#endif // WINNT


#endif // ! DPNBUILD_NOMULTICAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\ipui.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPUI.h
 *  Content:	Winsock provider IP UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/15/1999	jtk		Derived from ComPortUI.h
 ***************************************************************************/

#ifndef __IP_UI_H__
#define __IP_UI_H__

#ifndef DPNBUILD_NOSPUI

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
void	DisplayIPHostNameSettingsDialog( void *const pContext );
void	StopIPHostNameSettingsDialog( const HWND hDlg );

#endif // !DPNBUILD_NOSPUI

#endif	// __IP_UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\locals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.cpp
 *  Content:	Global variables for the DNWsock service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

#if ((! defined(WINCE)) && (! defined(_XBOX)))
//
// DLL instance
//
HINSTANCE						g_hDLLInstance = NULL;
#endif // ! WINCE and ! _XBOX
#ifdef _XBOX
BOOL							g_fStartedXNet = FALSE;
#endif // _XBOX

#ifndef DPNBUILD_LIBINTERFACE
//
// count of outstanding COM interfaces
//
volatile LONG					g_lOutstandingInterfaceCount = 0;
#endif // ! DPNBUILD_LIBINTERFACE


#ifndef DPNBUILD_ONLYONETHREAD
//
// thread count
//
LONG							g_iThreadCount = 0;
#endif // ! DPNBUILD_ONLYONETHREAD

#ifndef DPNBUILD_NOREGISTRY
#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
DWORD							g_dwWinsockVersion = 0;
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_ONLYWINSOCK2
#endif // ! DPNBUILD_NOREGISTRY

//
// Winsock receive buffer size
//
BOOL							g_fWinsockReceiveBufferSizeOverridden = FALSE;
INT								g_iWinsockReceiveBufferSize = 0;


#ifndef DPNBUILD_NONATHELP
//
// global NAT/firewall traversal information
//
#ifndef DPNBUILD_NOREGISTRY
BOOL							g_fDisableDPNHGatewaySupport = FALSE;
BOOL							g_fDisableDPNHFirewallSupport = FALSE;
DWORD							g_dwDefaultTraversalMode = DPNA_TRAVERSALMODE_PORTREQUIRED;
#endif // ! DPNBUILD_NOREGISTRY

IDirectPlayNATHelp **			g_papNATHelpObjects = NULL;
#ifndef DPNBUILD_NOLOCALNAT
BOOL							g_fLocalNATDetectedAtStartup = FALSE;
#endif // ! DPNBUILD_NOLOCALNAT
#endif // ! DPNBUILD_NONATHELP

#ifndef DPNBUILD_NOREGISTRY

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
BOOL							g_fDisableMadcapSupport = FALSE;
MCAST_CLIENT_UID				g_mcClientUid;
#endif // WINNT and not DPNBUILD_NOMULTICAST

//
// ignore enums performance option
//
BOOL							g_fIgnoreEnums = FALSE;

//
// disconnect upon reception of ICMP port not reachable option
//
BOOL							g_fDisconnectOnICMP = FALSE;

#ifndef DPNBUILD_NOIPV6
//
// IPv4 only/IPv6 only/hybrid setting
//
int						g_iIPAddressFamily = PF_INET;
#endif // ! DPNBUILD_NOIPV6

//
// IP banning globals
//
CHashTable *					g_pHashBannedIPv4Addresses = NULL;
DWORD							g_dwBannedIPv4Masks = 0;

//
// proxy support options
//
#ifndef DPNBUILD_NOWINSOCK2
BOOL							g_fDontAutoDetectProxyLSP = FALSE;
#endif // ! DPNBUILD_NOWINSOCK2
BOOL							g_fTreatAllResponsesAsProxied = FALSE;

//
// settings for overriding MTU
//
DWORD					g_dwMaxUserDataSize = DEFAULT_MAX_USER_DATA_SIZE;
DWORD					g_dwMaxEnumDataSize = DEFAULT_MAX_ENUM_DATA_SIZE;

//
// default port range
//
WORD					g_wBaseDPlayPort = BASE_DPLAY8_PORT;
WORD					g_wMaxDPlayPort = MAX_DPLAY8_PORT;

#endif // ! DPNBUILD_NOREGISTRY


//
// ID of most recent endpoint generated
//
DWORD							g_dwCurrentEndpointID = 0;


#ifdef DBG
//
// Bilink for tracking DPNWSock critical sections
//
CBilink							g_blDPNWSockCritSecsHeld;
#endif // DBG


#ifdef DPNBUILD_WINSOCKSTATISTICS
//
// Winsock debugging/tuning stats
//
DWORD							g_dwWinsockStatNumSends = 0;
DWORD							g_dwWinsockStatSendCallTime = 0;
#endif // DPNBUILD_WINSOCKSTATISTICS



#ifndef DPNBUILD_NOREGISTRY
//
// registry strings
//
const WCHAR	g_RegistryBase[] = L"SOFTWARE\\Microsoft\\DirectPlay8";

const WCHAR	g_RegistryKeyReceiveBufferSize[] = L"WinsockReceiveBufferSize";
#ifndef DPNBUILD_ONLYONETHREAD
const WCHAR	g_RegistryKeyThreadCount[] = L"ThreadCount";
#endif // ! DPNBUILD_ONLYONETHREAD

#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
const WCHAR	g_RegistryKeyWinsockVersion[] = L"WinsockVersion";
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NONATHELP
const WCHAR	g_RegistryKeyDisableDPNHGatewaySupport[] = L"DisableDPNHGatewaySupport";
const WCHAR	g_RegistryKeyDisableDPNHFirewallSupport[] = L"DisableDPNHFirewallSupport";
const WCHAR g_RegistryKeyTraversalModeSettings[] = L"TraversalModeSettings";
const WCHAR g_RegistryKeyDefaultTraversalMode[] = L"DefaultTraversalMode";
#endif // !DPNBUILD_NONATHELP

const WCHAR	g_RegistryKeyAppsToIgnoreEnums[] = L"AppsToIgnoreEnums";
const WCHAR	g_RegistryKeyAppsToDisconnectOnICMP[] = L"AppsToDisconnectOnICMP";

#ifndef DPNBUILD_NOIPV6
const WCHAR	g_RegistryKeyIPAddressFamilySettings[] = L"IPAddressFamilySettings";
const WCHAR	g_RegistryKeyDefaultIPAddressFamily[]= L"DefaultIPAddressFamily";
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOWINSOCK2
const WCHAR	g_RegistryKeyDontAutoDetectProxyLSP[] = L"DontAutoDetectProxyLSP";
#endif // ! DPNBUILD_NOWINSOCK2
const WCHAR	g_RegistryKeyTreatAllResponsesAsProxied[] = L"TreatAllResponsesAsProxied";

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
const WCHAR	g_RegistryKeyDisableMadcapSupport[] = L"DisableMadcapSupport";
#endif // WINNT and not DPNBUILD_NOMULTICAST

const WCHAR	g_RegistryKeyBannedIPv4Addresses[] = L"BannedIPv4Addresses";

const WCHAR	g_RegistryKeyMaxUserDataSize[] = L"MaxUserDataSize";
const WCHAR	g_RegistryKeyMaxEnumDataSize[] = L"MaxEnumDataSize";

const WCHAR	g_RegistryKeyBaseDPlayPort[] = L"BaseDPlayPort";
const WCHAR	g_RegistryKeyMaxDPlayPort[] = L"MaxDPlayPort";

#endif // ! DPNBUILD_NOREGISTRY

//
// GUIDs for munging device and scope IDs
//
// {4CE725F4-7B00-4397-BA6F-11F965BC4299}
GUID	g_IPSPEncryptionGuid = { 0x4ce725f4, 0x7b00, 0x4397, { 0xba, 0x6f, 0x11, 0xf9, 0x65, 0xbc, 0x42, 0x99 } };

#ifndef DPNBUILD_NOIPX
// {CA734945-3FC1-42ea-BF49-84AFCD4764AA}
GUID	g_IPXSPEncryptionGuid = { 0xca734945, 0x3fc1, 0x42ea, { 0xbf, 0x49, 0x84, 0xaf, 0xcd, 0x47, 0x64, 0xaa } };
#endif // ! DPNBUILD_NOIPX


#ifndef DPNBUILD_NOIPV6
//
// IPv6 link-local multicast address for enumerating DirectPlay sessions
//
#pragma TODO(vanceo, "\"Standardize\" enum multicast address?")
const IN6_ADDR		c_in6addrEnumMulticast = {0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0x01,0x30};
#endif // ! DPNBUILD_NOIPV6




//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\pools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Pool utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from Utils.h
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************


#ifndef DPNBUILD_ONLYONETHREAD
static	DNCRITICAL_SECTION	g_AddressLock;
#endif // !DPNBUILD_ONLYONETHREAD

// Pools
#ifndef DPNBUILD_ONLYONEADAPTER
CFixedPool g_AdapterEntryPool;
#endif // ! DPNBUILD_ONLYONEADAPTER
CFixedPool g_CommandDataPool;
CFixedPool g_SocketAddressPool;
CFixedPool g_EndpointPool;
CFixedPool g_EndpointCommandParametersPool;
CFixedPool g_SocketPortPool;
CFixedPool g_ThreadPoolPool;
CFixedPool g_ReadIODataPool;	
CFixedPool g_TimerEntryPool;	
CFixedPool g_SocketDataPool;
#ifndef DPNBUILD_ONLYONETHREAD
CFixedPool g_BlockingJobPool;
#endif // ! DPNBUILD_ONLYONETHREAD


#ifndef DPNBUILD_ONLYONEADAPTER
#define ADAPTERENTRY_POOL_INITED		0x00000001
#endif // ! DPNBUILD_ONLYONEADAPTER
#define COMMANDDATA_POOL_INITED			0x00000002
#define ADDRESS_LOCK_INITED				0x00000004
#define SOCKETADDRESS_POOL_INITED		0x00000008
#define ENDPOINT_POOL_INITED			0x00000010
#define EPCMDPARAM_POOL_INITED			0x00000020
#define SOCKETPORT_POOL_INITED			0x00000040
#define THREADPOOL_POOL_INITED			0x00000080
#define READ_POOL_INITED				0x00000100
#define TIMERENTRY_POOL_INITED			0x00000200
#define SOCKETDATA_POOL_INITED			0x00000400
#ifndef DPNBUILD_ONLYONETHREAD
#define BLOCKINGJOB_POOL_INITED			0x00000800
#endif // ! DPNBUILD_ONLYONETHREAD

DWORD g_dwWsockInitFlags = 0;


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializePools - initialize pools
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitializePools"

BOOL	InitializePools( void )
{
#ifndef DPNBUILD_ONLYONEADAPTER
	//
	// AdapterEntry object pool
	//
	if (!g_AdapterEntryPool.Initialize(sizeof(CAdapterEntry), 
										CAdapterEntry::PoolAllocFunction,
										CAdapterEntry::PoolInitFunction,
										CAdapterEntry::PoolReleaseFunction,
										CAdapterEntry::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= ADAPTERENTRY_POOL_INITED;
#endif // ! DPNBUILD_ONLYONEADAPTER

	//
	// command data pool
	//
	if (!g_CommandDataPool.Initialize(sizeof(CCommandData), 
										CCommandData::PoolAllocFunction,
										CCommandData::PoolInitFunction,
										CCommandData::PoolReleaseFunction,
										CCommandData::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= COMMANDDATA_POOL_INITED;

	//
	// initialize lock for address and endpoint pools
	//
	if ( DNInitializeCriticalSection( &g_AddressLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &g_AddressLock, 0 );
	DebugSetCriticalSectionGroup( &g_AddressLock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes
	g_dwWsockInitFlags |= ADDRESS_LOCK_INITED;

	//
	// address pools
	//
	if (!g_SocketAddressPool.Initialize(sizeof(CSocketAddress), 
										CSocketAddress::PoolAllocFunction,
										CSocketAddress::PoolGetFunction,
										CSocketAddress::PoolReturnFunction,
										NULL))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= SOCKETADDRESS_POOL_INITED;

	//
	// endpoint pools
	//
	if (!g_EndpointPool.Initialize(sizeof(CEndpoint), 
										CEndpoint::PoolAllocFunction,
										CEndpoint::PoolInitFunction,
										CEndpoint::PoolReleaseFunction,
										CEndpoint::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= ENDPOINT_POOL_INITED;

	//
	// endpoint command parameter pools
	//
	if (!g_EndpointCommandParametersPool.Initialize(sizeof(ENDPOINT_COMMAND_PARAMETERS), 
										NULL,
										ENDPOINT_COMMAND_PARAMETERS::PoolInitFunction,
										NULL,
										NULL))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= EPCMDPARAM_POOL_INITED;

	//
	// socket port pool
	//
	if (!g_SocketPortPool.Initialize(sizeof(CSocketPort), 
										CSocketPort::PoolAllocFunction,
										CSocketPort::PoolInitFunction,
#ifdef DBG
										CSocketPort::PoolDeinitFunction,
#else // ! DBG
										NULL,
#endif // ! DBG
										CSocketPort::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= SOCKETPORT_POOL_INITED;

	//
	// thread pool pool
	//
	if (!g_ThreadPoolPool.Initialize(sizeof(CThreadPool), 
										CThreadPool::PoolAllocFunction,
										NULL,
										NULL,
										CThreadPool::PoolDeallocFunction))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= THREADPOOL_POOL_INITED;

	// pool of read requests
	if (!g_ReadIODataPool.Initialize( sizeof(CReadIOData),
									   CReadIOData::ReadIOData_Alloc,
									   CReadIOData::ReadIOData_Get,
									   CReadIOData::ReadIOData_Release,
									   CReadIOData::ReadIOData_Dealloc))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= READ_POOL_INITED;

	// timer entry pool
	if (!g_TimerEntryPool.Initialize( sizeof(TIMER_OPERATION_ENTRY),
						 TimerEntry_Alloc,					// function called on pool entry initial allocation
						 TimerEntry_Get,					// function called on entry extraction from pool
						 TimerEntry_Release,				// function called on entry return to pool
						 TimerEntry_Dealloc					// function called on entry free
						))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= TIMERENTRY_POOL_INITED;

	// socket data pool
	if (!g_SocketDataPool.Initialize( sizeof(CSocketData),
						CSocketData::PoolAllocFunction,
						CSocketData::PoolInitFunction,
						CSocketData::PoolReleaseFunction,
						CSocketData::PoolDeallocFunction
						))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= SOCKETDATA_POOL_INITED;

#ifndef DPNBUILD_ONLYONETHREAD
	// blocking job pool
	if (!g_BlockingJobPool.Initialize( sizeof(BLOCKING_JOB),
									NULL,
									NULL,
									NULL,
									NULL))
	{
		goto Failure;
	}
	g_dwWsockInitFlags |= BLOCKINGJOB_POOL_INITED;
#endif // ! DPNBUILD_ONLYONETHREAD

	return	TRUE;

Failure:
	DeinitializePools();
	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializePools - deinitialize the pools
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitializePools"

void	DeinitializePools( void )
{
	if (g_dwWsockInitFlags & READ_POOL_INITED)
	{
		g_ReadIODataPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~READ_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & TIMERENTRY_POOL_INITED)
	{
		g_TimerEntryPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~TIMERENTRY_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & THREADPOOL_POOL_INITED)
	{
		g_ThreadPoolPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~THREADPOOL_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & SOCKETPORT_POOL_INITED)
	{
		g_SocketPortPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~SOCKETPORT_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & EPCMDPARAM_POOL_INITED)
	{
		g_EndpointCommandParametersPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~EPCMDPARAM_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & ENDPOINT_POOL_INITED)
	{
		g_EndpointPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~ENDPOINT_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & SOCKETADDRESS_POOL_INITED)
	{
		g_SocketAddressPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~SOCKETADDRESS_POOL_INITED;
#endif // DBG
	}

	if (g_dwWsockInitFlags & ADDRESS_LOCK_INITED)
	{
		DNDeleteCriticalSection( &g_AddressLock );
#ifdef DBG
		g_dwWsockInitFlags &= ~ADDRESS_LOCK_INITED;
#endif // DBG
	}
	
	if (g_dwWsockInitFlags & COMMANDDATA_POOL_INITED)
	{
		g_CommandDataPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~COMMANDDATA_POOL_INITED;
#endif // DBG
	}

#ifndef DPNBUILD_ONLYONEADAPTER
	if (g_dwWsockInitFlags & ADAPTERENTRY_POOL_INITED)
	{
		g_AdapterEntryPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~ADAPTERENTRY_POOL_INITED;
#endif // DBG
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	if (g_dwWsockInitFlags & SOCKETDATA_POOL_INITED)
	{
		g_SocketDataPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~SOCKETDATA_POOL_INITED;
#endif // DBG
	}

#ifndef DPNBUILD_ONLYONETHREAD
	if (g_dwWsockInitFlags & BLOCKINGJOB_POOL_INITED)
	{
		g_BlockingJobPool.DeInitialize();
#ifdef DBG
		g_dwWsockInitFlags &= ~BLOCKINGJOB_POOL_INITED;
#endif // DBG
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	DNASSERT(g_dwWsockInitFlags == 0);
	g_dwWsockInitFlags = 0;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\pools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:	Pool functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from utils.h
 ***************************************************************************/

#ifndef __POOLS_H__
#define __POOLS_H__


// Pools
#ifndef DPNBUILD_ONLYONEADAPTER
extern CFixedPool g_AdapterEntryPool;
#endif // ! DPNBUILD_ONLYONEADAPTER
extern CFixedPool g_CommandDataPool;
extern CFixedPool g_SocketAddressPool;
extern CFixedPool g_EndpointPool;
extern CFixedPool g_EndpointCommandParametersPool;
extern CFixedPool g_SocketPortPool;
extern CFixedPool g_ThreadPoolPool;
extern CFixedPool g_ReadIODataPool;	
extern CFixedPool g_TimerEntryPool;	
extern CFixedPool g_SocketDataPool;
#ifndef DPNBUILD_ONLYONETHREAD
extern CFixedPool g_BlockingJobPool;
#endif // ! DPNBUILD_ONLYONETHREAD


//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
#ifndef DPNBUILD_ONLYONEADAPTER
class	CAdapterEntry;
#endif // ! DPNBUILD_ONLYONEADAPTER
class	CCommandData;
class	CSocketAddress;
class	CEndpoint;
class	CSocketPort;
class	CSocketData;
class	CSPData;
class	CThreadPool;
class	CReadIOData;

typedef	struct	_ENDPOINT_COMMAND_PARAMETERS	ENDPOINT_COMMAND_PARAMETERS;
typedef	struct	_READ_IO_DATA_POOL_CONTEXT		READ_IO_DATA_POOL_CONTEXT;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitializePools( void );
void	DeinitializePools( void );

#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\messagestructures.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MessageStructures.h
 *  Content:	Message strucutre definitions for messages on the wire
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/20/2000	jtk		Derived from IOData.h
 ***************************************************************************/

#ifndef __MESSAGE_STRUCTURES_H__
#define __MESSAGE_STRUCTURES_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define SP_HEADER_LEAD_BYTE			0x00
//#define ESCAPED_USER_DATA_PAD_VALUE	0x0000

//
// Data types used by service provider messages.  Note, the high-order bit
// is reserved for future use and should not be set!
//
//#define ESCAPED_USER_DATA_KIND		0x01 // UNUSED: Protocol guarantees that the first byte will never be zero
#define ENUM_DATA_KIND				0x02
#define ENUM_RESPONSE_DATA_KIND		0x03
#ifndef DPNBUILD_SINGLEPROCESS
#define PROXIED_ENUM_DATA_KIND		0x04
#endif // ! DPNBUILD_SINGLEPROCESS
#ifdef DPNBUILD_XNETSECURITY
#define XNETSEC_ENUM_RESPONSE_DATA_KIND		0x05
#endif // DPNBUILD_XNETSECURITY

//
// DPlay port limits (inclusive) scanned to find an available port.
// Exclude 2300 and 2301 because there are network broadcasts on 2301
// that we may receive.
//
#define BASE_DPLAY8_PORT	((WORD) 2302)
#define MAX_DPLAY8_PORT		((WORD) 2400)

//
// mask for RTT sequence number
//
#define ENUM_RTT_MASK	0X0F

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// Structure used to prepend data to a send, this structure is byte aligned to
// save bandwidth.  The goal is to keep all data DWORD aligned so the structure
// elements should be sized such that any payload passed to a higher layer is
// DWORD aligned.  In the case of the proxied enum query, the full
// SOCKADDR(_STORAGE) structure is used to keep alignment.  Since this message
// should only ever be sent locally, we can be a little loose with our ifdefs regarding
// the size of the SOCKADDR(_STORAGE).
//
#pragma	pack( push, 1 )

typedef union	_PREPEND_BUFFER
{
	struct	_GENERIC_HEADER			// generic header to determine data kind
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;		//
	} GenericHeader;

	struct	_ENUM_DATA_HEADER		// header used to indicate enum query data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;		//
		WORD	wEnumPayload;			// combination of RTT sequence and enum key
	} EnumDataHeader;

	struct	_ENUM_RESPONSE_DATA_HEADER	// header used to indicate enum response data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;		//
		WORD	wEnumResponsePayload;	// combination of RTT sequence and enum key
	} EnumResponseDataHeader;	

	struct	_PROXIED_ENUM_DATA_HEADER	// header used to indicate proxied enum data
	{											//
		BYTE				bSPLeadByte;		//
		BYTE				bSPCommandByte;	//
		WORD				wEnumKey;			// key from the original enum
		union
		{
			SOCKADDR		AddressGeneric;
			SOCKADDR_IN	AddressIPv4;		//
#ifndef DPNBUILD_NOIPV6
			SOCKADDR_IPX	AddressIPX;			//
#endif // ! DPNBUILD_NOIPV6
#ifndef DPNBUILD_NOIPV6
			SOCKADDR_IN6	AddressIPv6;		//
#endif // ! DPNBUILD_NOIPV6
		} ReturnAddress;						// real socket address to return the data to
	} ProxiedEnumDataHeader;

#ifdef DPNBUILD_XNETSECURITY
	struct	_XNETSEC_ENUM_RESPONSE_DATA_HEADER	// header used to indicate secure enum response data
	{											//
		BYTE		bSPLeadByte;				//
		BYTE		bSPCommandByte;			//
		WORD		wEnumResponsePayload;		// combination of RTT sequence and enum key (same as EnumResponseDataHeader)
		XNADDR		xnaddr;						// secure transport address of session
	} XNetSecEnumResponseDataHeader;
#endif // DPNBUILD_XNETSECURITY

} PREPEND_BUFFER;
#pragma	pack( pop )

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


#endif	// __MESSAGE_STRUCTURES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\locals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.h
 *  Content:	Global information for the DNWSock service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __LOCALS_H__
#define __LOCALS_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// Smallest and largest reasonable values for the Maximum Transmission Unit.
//
#define	MIN_MTU							128
#define	MAX_MTU							1500

//
// Header sizes
//
#define	IP_HEADER_SIZE					20
#define	UDP_HEADER_SIZE					8
#define	IP_UDP_HEADER_SIZE				(IP_HEADER_SIZE + UDP_HEADER_SIZE)

#define	ESP_HEADER_SIZE					8
#define	ENCRYPTIONIV_HEADER_SIZE		8
#define	PADDING_FOR_MAX_PACKET			4
#define	ICV_AUTHENTICATION_SIZE			12
#define	MAX_ENCAPSULATION_SIZE			(ESP_HEADER_SIZE + ENCRYPTIONIV_HEADER_SIZE + UDP_HEADER_SIZE + PADDING_FOR_MAX_PACKET + ICV_AUTHENTICATION_SIZE)

// This should equal 1430 bytes, the Xbox secure networking UDP payload limit.
#define	NONDPLAY_HEADER_SIZE			(IP_UDP_HEADER_SIZE + MAX_ENCAPSULATION_SIZE)

#define	ENUM_PAYLOAD_HEADER_SIZE		(sizeof(PREPEND_BUFFER))


//
// Smallest and largest reasonable values for the maximum amount of data in
// a frame that we send.
//
#define	MIN_SEND_FRAME_SIZE				(MIN_MTU - NONDPLAY_HEADER_SIZE)
#define	MAX_SEND_FRAME_SIZE				(MAX_MTU - NONDPLAY_HEADER_SIZE)

//
// Default maximum user payload size in bytes.  We don't use just
// MAX_SEND_FRAME_SIZE because some broken routers can't handle IP
// fragmentation properly in cases where the MTU is actually less than 1500.
// The actual value used can be overridden (between MIN_SEND_FRAME_SIZE
// and MAX_SEND_FRAME_SIZE) via the registry.
//
#define	DEFAULT_MAX_USER_DATA_SIZE		(MAX_SEND_FRAME_SIZE - 48)

//
// Default maximume enum payload size in bytes.  We use something less than
// DEFAULT_MAX_USER_DATA_SIZE to give us room to expand our enum
// information.  The actual value used can be overridden (between
// MIN_SEND_FRAME_SIZE and MAX_SEND_FRAME_SIZE) via the registry.
//
#define	DEFAULT_MAX_ENUM_DATA_SIZE		1000

//
// Older versions of DPlay (or new ones with modified registry settings) may
// send us larger packets, so expect to handle that.
//
#define	MAX_RECEIVE_FRAME_SIZE			(MAX_MTU - IP_UDP_HEADER_SIZE)


//
// maximum value of a 32-bit unsigned variable
//
#define	UINT32_MAX	((DWORD) 0xFFFFFFFF)
#define	WORD_MAX	((WORD) 0xFFFF)

//
// default enum retries for Winsock SP and retry time (milliseconds)
//
#ifdef _XBOX
// Xbox design TCR 3-59 Session Discovery Time for System Link Play
// The game must discover sessions for system link play in no more than three seconds
#define	DEFAULT_ENUM_RETRY_COUNT		3
#define	DEFAULT_ENUM_RETRY_INTERVAL		750
#define	DEFAULT_ENUM_TIMEOUT			750
#else // ! _XBOX
#define	DEFAULT_ENUM_RETRY_COUNT		5
#define	DEFAULT_ENUM_RETRY_INTERVAL		1500
#define	DEFAULT_ENUM_TIMEOUT			1500
#endif // ! _XBOX
#define	ENUM_RTT_ARRAY_SIZE				16	// also see ENUM_RTT_MASK


#ifndef DPNBUILD_ONLYONEADAPTER
//
// Private address key that allows for friendlier multi-device commands issued
// using xxxADDRESSINFO indications; specifically, this allows us to detect
// responses sent to the "wrong" adapter when the core multiplexes an
// enum or connect into multiple adapters.
//
#define DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION		L"pk_ipsp_maa"


//
// Private address key that allows for friendlier multi-device commands issued
// using xxxADDRESSINFO indications; specifically, this allows us to distinguish
// between the user specifying a fixed port and the core handing us back the
// port we chose for a previous adapter when it multiplexes an enum, connect,
// or listen into multiple adapters.
//
#define DPNA_PRIVATEKEY_PORT_NOT_SPECIFIC					L"pk_ipsp_pns"
#endif // ! DPNBUILD_ONLYONEADAPTER


#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))
//
// Private address key designed to improve support for MS Proxy/ISA Firewall
// client software.  This key tracks the original target address for enums so
// that if the application closes the socketport before trying to connect to
// the responding address, the connect attempts will go to the real target
// instead of the old proxy address.
//
#define DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS	L"pk_ipsp_proa"
#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY


//
// 192.168.0.1 in network byte order
//
#define IP_PRIVATEICS_ADDRESS					0x0100A8C0

//
// 127.0.0.1 in network byte order
//
#define IP_LOOPBACK_ADDRESS						0x0100007F

//
// 1110 high bits or 224.0.0.0 - 239.255.255.255 multicast address, in network byte order
//
#define IS_CLASSD_IPV4_ADDRESS(dwAddr)			(( (*((BYTE*) &(dwAddr))) & 0xF0) == 0xE0)

#define NTOHS(x)								( (((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00) )
#define HTONS(x)								NTOHS(x)


#ifndef DPNBUILD_NOMULTICAST

#define MULTICAST_TTL_PRIVATE				1
#define MULTICAST_TTL_PRIVATE_AS_STRING		L"1"

#define MULTICAST_TTL_LOCAL					16
#define MULTICAST_TTL_LOCAL_AS_STRING		L"16"

#define MULTICAST_TTL_GLOBAL				255
#define MULTICAST_TTL_GLOBAL_AS_STRING		L"255"

#endif // ! DPNBUILD_NOMULTICAST



//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure and class references
//
typedef	struct	IDP8ServiceProvider	IDP8ServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

#if ((! defined(WINCE)) && (! defined(_XBOX)))
//
// DLL instance
//
extern	HINSTANCE				g_hDLLInstance;
#endif // ! WINCE and ! _XBOX
#ifdef _XBOX
extern BOOL						g_fStartedXNet;
#endif // _XBOX

#ifndef DPNBUILD_LIBINTERFACE
//
// count of outstanding COM interfaces
//
extern volatile	LONG			g_lOutstandingInterfaceCount;
#endif // ! DPNBUILD_LIBINTERFACE


#ifndef DPNBUILD_ONLYONETHREAD
//
// thread count
//
extern	LONG					g_iThreadCount;
#endif // ! DPNBUILD_ONLYONETHREAD


#ifndef DPNBUILD_NOREGISTRY
#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
extern	DWORD					g_dwWinsockVersion;
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_ONLYWINSOCK2
#endif // ! DPNBUILD_NOREGISTRY


//
// Winsock receive buffer size
//
extern	BOOL					g_fWinsockReceiveBufferSizeOverridden;
extern	INT						g_iWinsockReceiveBufferSize;


//
// GUIDs for munging device and scope IDs
//
extern	GUID					g_IPSPEncryptionGuid;

#ifndef DPNBUILD_NOIPX
extern	GUID					g_IPXSPEncryptionGuid;
#endif // ! DPNBUILD_NOIPX

#ifndef DPNBUILD_NOIPV6
//
// IPv6 link-local multicast address for enumerating DirectPlay sessions
//
extern	const IN6_ADDR			c_in6addrEnumMulticast;
#endif // ! DPNBUILD_NOIPV6




#ifndef DPNBUILD_NONATHELP
//
// global NAT/firewall traversal information
//
#ifdef DPNBUILD_ONLYONENATHELP
#define MAX_NUM_DIRECTPLAYNATHELPERS		1
#else // ! DPNBUILD_ONLYONENATHELP
#define MAX_NUM_DIRECTPLAYNATHELPERS		5
#endif // ! DPNBUILD_ONLYONENATHELP
#define FORCE_TRAVERSALMODE_BIT				0x80000000	// make the default mode override any app specific settings


#ifndef DPNBUILD_NOREGISTRY
extern	BOOL					g_fDisableDPNHGatewaySupport;
extern	BOOL					g_fDisableDPNHFirewallSupport;
extern	DWORD					g_dwDefaultTraversalMode;
#endif // ! DPNBUILD_NOREGISTRY

extern IDirectPlayNATHelp **	g_papNATHelpObjects;
#ifndef DPNBUILD_NOLOCALNAT
extern BOOL						g_fLocalNATDetectedAtStartup;
#endif // ! DPNBUILD_NOLOCALNAT
#endif // DPNBUILD_NONATHELP


#ifndef DPNBUILD_NOREGISTRY

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
extern	BOOL					g_fDisableMadcapSupport;
extern	MCAST_CLIENT_UID		g_mcClientUid;
#endif // WINNT and not DPNBUILD_NOMULTICAST



//
// ignore enums performance option
//
extern	BOOL					g_fIgnoreEnums;

//
// disconnect upon reception of ICMP port not reachable option
//
extern	BOOL					g_fDisconnectOnICMP;


#ifndef DPNBUILD_NOIPV6
//
// IPv4 only/IPv6 only/hybrid setting
//
extern	int						g_iIPAddressFamily;
#endif // ! DPNBUILD_NOIPV6


//
// IP banning globals
//
extern	CHashTable *			g_pHashBannedIPv4Addresses;
extern	DWORD					g_dwBannedIPv4Masks;



//
// proxy support options
//
#ifndef DPNBUILD_NOWINSOCK2
extern	BOOL					g_fDontAutoDetectProxyLSP;
#endif // !DPNBUILD_NOWINSOCK2
extern	BOOL					g_fTreatAllResponsesAsProxied;


//
// settings for overriding MTU
//
extern	DWORD					g_dwMaxUserDataSize;
extern	DWORD					g_dwMaxEnumDataSize;

//
// default port range
//
extern	WORD					g_wBaseDPlayPort;
extern	WORD					g_wMaxDPlayPort;

#endif // ! DPNBUILD_NOREGISTRY


//
// ID of most recent endpoint generated
//
extern	DWORD					g_dwCurrentEndpointID;

#ifdef DBG
//
// Bilink for tracking DPNWSock critical sections
//
extern CBilink					g_blDPNWSockCritSecsHeld;
#endif // DBG

#ifdef DPNBUILD_WINSOCKSTATISTICS
//
// Winsock debugging/tuning stats
//
extern DWORD					g_dwWinsockStatNumSends;
extern DWORD					g_dwWinsockStatSendCallTime;
#endif // DPNBUILD_WINSOCKSTATISTICS

#ifndef DPNBUILD_NOREGISTRY
//
// Registry strings
//
extern	const WCHAR	g_RegistryBase[];

extern	const WCHAR	g_RegistryKeyReceiveBufferSize[];
#ifndef DPNBUILD_ONLYONETHREAD
extern	const WCHAR	g_RegistryKeyThreadCount[];
#endif // ! DPNBUILD_ONLYONETHREAD

#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
extern	const WCHAR	g_RegistryKeyWinsockVersion[];
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_ONLYWINSOCK2


#ifndef DPNBUILD_NONATHELP
extern	const WCHAR	g_RegistryKeyDisableDPNHGatewaySupport[];
extern	const WCHAR	g_RegistryKeyDisableDPNHFirewallSupport[];
extern	const WCHAR g_RegistryKeyTraversalModeSettings[];
extern	const WCHAR g_RegistryKeyDefaultTraversalMode[];
#endif // ! DPNBUILD_NONATHELP

extern	const WCHAR	g_RegistryKeyAppsToIgnoreEnums[];
extern	const WCHAR	g_RegistryKeyAppsToDisconnectOnICMP[];

#ifndef DPNBUILD_NOIPV6
extern	const WCHAR	g_RegistryKeyIPAddressFamilySettings[];
extern	const WCHAR	g_RegistryKeyDefaultIPAddressFamily[];
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOWINSOCK2
extern	const WCHAR	g_RegistryKeyDontAutoDetectProxyLSP[];
#endif // ! DPNBUILD_NOWINSOCK2
extern	const WCHAR	g_RegistryKeyTreatAllResponsesAsProxied[];

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
extern	const WCHAR	g_RegistryKeyDisableMadcapSupport[];
#endif // WINNT and not DPNBUILD_NOMULTICAST

extern	const WCHAR	g_RegistryKeyMaxUserDataSize[];
extern	const WCHAR	g_RegistryKeyMaxEnumDataSize[];

extern	const WCHAR	g_RegistryKeyBaseDPlayPort[];
extern	const WCHAR	g_RegistryKeyMaxDPlayPort[];

extern	const WCHAR	g_RegistryKeyBannedIPv4Addresses[];

#endif // ! DPNBUILD_NOREGISTRY


#endif	// __LOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\socketdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	    socketdata.cpp
 *  Content:	Socket list that can be shared between DPNWSOCK service provider interfaces.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/25/2001	vanceo	Extracted from spdata.cpp
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketData::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to item
//				Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketData::PoolAllocFunction"

BOOL	CSocketData::PoolAllocFunction( void* pvItem, void* pvContext )
{
	BOOL	fCritSecInitted = FALSE;


	CSocketData* pSocketData = (CSocketData*)pvItem;

	pSocketData->m_Sig[0] = 'S';
	pSocketData->m_Sig[1] = 'O';
	pSocketData->m_Sig[2] = 'D';
	pSocketData->m_Sig[3] = 'T';

	pSocketData->m_lRefCount = 0;

#ifdef DPNBUILD_ONLYONEADAPTER
	pSocketData->m_blSocketPorts.Initialize();
#else // ! DPNBUILD_ONLYONEADAPTER
	pSocketData->m_blAdapters.Initialize();
#endif // ! DPNBUILD_ONLYONEADAPTER

	//
	// No socket ports yet.
	//
	pSocketData->m_lSocketPortRefCount = 0;

	pSocketData->m_pThreadPool = NULL;


	//
	// attempt to initialize the internal critical section
	//
	if (! DNInitializeCriticalSection(&pSocketData->m_csLock))
	{
		DPFX(DPFPREP, 0, "Problem initializing critical section for this endpoint!");
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount(&pSocketData->m_csLock, 0);
	DebugSetCriticalSectionGroup( &pSocketData->m_csLock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes
	fCritSecInitted = TRUE;
	
	//
	// Create a manual reset event that is initially set.
	//
	pSocketData->m_hSocketPortShutdownEvent = DNCreateEvent(NULL, TRUE, TRUE, NULL);
	if (pSocketData->m_hSocketPortShutdownEvent == NULL)
	{
#ifdef DBG
		DWORD	dwError;

		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create socket port shutdown event (err = %u)!", dwError);
#endif // DBG
		goto Failure;
	}

	return TRUE;


Failure:

	if (pSocketData->m_hSocketPortShutdownEvent != NULL)
	{
		DNCloseHandle(pSocketData->m_hSocketPortShutdownEvent);
		pSocketData->m_hSocketPortShutdownEvent = NULL;
	}

	if (fCritSecInitted)
	{
		DNDeleteCriticalSection(&pSocketData->m_csLock);
		fCritSecInitted = FALSE;
	}
	
	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketData::PoolInitFunction - function called when item is removed from pool
//
// Entry:		Pointer to item
//				Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketData::PoolInitFunction"

void CSocketData::PoolInitFunction( void* pvItem, void* pvContext )
{
	CSocketData *	pSocketData = (CSocketData*) pvItem;


	DPFX(DPFPREP, 8, "This = 0x%p, context = 0x%p", pvItem, pvContext);
	
	DNASSERT(pSocketData->m_lRefCount == 0);
#ifdef DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_blSocketPorts.IsEmpty());
#else // ! DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_blAdapters.IsEmpty());
#endif // ! DPNBUILD_ONLYONEADAPTER
	pSocketData->m_lRefCount = 1;	// the person retrieving from the pool will have a reference

	pSocketData->m_pThreadPool = (CThreadPool*) pvContext;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketData::PoolReleaseFunction - function called when item is returning
//		to the pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketData::PoolReleaseFunction"

void	CSocketData::PoolReleaseFunction( void* pvItem )
{
	CSocketData *		pSocketData = (CSocketData*) pvItem;


	DPFX(DPFPREP, 8, "This = 0x%p", pvItem);
	
	DNASSERT(pSocketData->m_lRefCount == 0);
#ifdef DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_blSocketPorts.IsEmpty());
#else // ! DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_blAdapters.IsEmpty());
#endif // ! DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_lSocketPortRefCount == 0);

	pSocketData->m_pThreadPool = NULL;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSocketData::PoolDeallocFunction - function called when item is deallocated
//		from the pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketData::PoolDeallocFunction"

void	CSocketData::PoolDeallocFunction( void* pvItem )
{
	CSocketData *	pSocketData = (CSocketData*) pvItem;


	DPFX(DPFPREP, 8, "This = 0x%p", pvItem);
	
	DNASSERT(pSocketData->m_lRefCount == 0);
#ifdef DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_blSocketPorts.IsEmpty());
#else // ! DPNBUILD_ONLYONEADAPTER
	DNASSERT(pSocketData->m_blAdapters.IsEmpty());
#endif // ! DPNBUILD_ONLYONEADAPTER

	DNCloseHandle(pSocketData->m_hSocketPortShutdownEvent);
	pSocketData->m_hSocketPortShutdownEvent = NULL;

	DNDeleteCriticalSection(&pSocketData->m_csLock);

	DNASSERT(pSocketData->m_pThreadPool == NULL);
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSocketData::FindSocketPort - looks up the socket port with the given address.
//								The socketdata lock must be held.
//
// Entry:		Pointer to socketport address, place to store socketport pointer
//
// Exit:		TRUE if socketport found, FALSE if not
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketData::FindSocketPort"

BOOL	CSocketData::FindSocketPort(const CSocketAddress * const pSocketAddress, CSocketPort ** const ppSocketPort )
{
	CBilink *		pBilinkSocketPorts;
	CSocketPort *	pTempSocketPort;
#ifndef DPNBUILD_ONLYONEADAPTER
	CBilink *		pBilinkAdapters;
	CAdapterEntry*	pTempAdapterEntry;
#endif // ! DPNBUILD_ONLYONEADAPTER


	AssertCriticalSectionIsTakenByThisThread(&m_csLock, TRUE);

#ifdef DPNBUILD_ONLYONEADAPTER
	//
	// Loop through all socket ports.
	//
	pBilinkSocketPorts = m_blSocketPorts.GetNext();
	while ( pBilinkSocketPorts != &m_blSocketPorts )
	{
		pTempSocketPort = CSocketPort::SocketPortFromBilink( pBilinkSocketPorts );
		if ( CSocketAddress::CompareFunction( (PVOID) pSocketAddress, (PVOID) pTempSocketPort->GetNetworkAddress() ) )
		{
			DPFX(DPFPREP, 3, "Socket port 0x%p matches address", pTempSocketPort );
			DumpSocketAddress( 3, pSocketAddress->GetAddress(), pSocketAddress->GetFamily() );
			(*ppSocketPort) = pTempSocketPort;
			return TRUE;
		}
	
		pBilinkSocketPorts = pBilinkSocketPorts->GetNext();
	}
#else // ! DPNBUILD_ONLYONEADAPTER
	//
	// Loop through all adapters.
	//
	pBilinkAdapters = m_blAdapters.GetNext();
	while ( pBilinkAdapters != &m_blAdapters )
	{
		pTempAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pBilinkAdapters );
		if ( pSocketAddress->CompareToBaseAddress( pTempAdapterEntry->BaseAddress() ) == 0 )
		{
			//
			// Loop through all socket ports for this adapter.
			//
			pBilinkSocketPorts = pTempAdapterEntry->SocketPortList()->GetNext();
			while ( pBilinkSocketPorts != pTempAdapterEntry->SocketPortList() )
			{
				pTempSocketPort = CSocketPort::SocketPortFromBilink( pBilinkSocketPorts );
				if ( CSocketAddress::CompareFunction( (PVOID) pSocketAddress, (PVOID) pTempSocketPort->GetNetworkAddress() ) )
				{
					DPFX(DPFPREP, 3, "Socket port 0x%p matches address", pTempSocketPort );
					DumpSocketAddress( 3, pSocketAddress->GetAddress(), pSocketAddress->GetFamily() );
					(*ppSocketPort) = pTempSocketPort;
					return TRUE;
				}
			
				pBilinkSocketPorts = pBilinkSocketPorts->GetNext();
			}
		}
	
		pBilinkAdapters = pBilinkAdapters->GetNext();
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	DPFX(DPFPREP, 3, "Couldn't find socket port matching address.");
	DumpSocketAddress( 3, pSocketAddress->GetAddress(), pSocketAddress->GetFamily() );
	return FALSE;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\sources.inc ===
TARGETNAME=dpnwsock
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnwsocki.h
PRECOMPILED_PCH=dnwsocki.pch
PRECOMPILED_OBJ=dnwsocki.obj

INCLUDES=..\;..\..\..\inc;..\..\..\common;..\..\..\..\dpnathlp\inc;..\..\..\core;..\..\..\threadpool;..\..\..\dnaddress;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=AdapterEntry.cpp \
	Classfac.cpp \
        CMDData.cpp \
	DebugUtils.cpp \
	DWinsock.cpp \
	Endpoint.cpp \
	IOData.cpp \
	IPUI.cpp \
	Locals.cpp \
        Pools.cpp \
	Socketdata.cpp \
	Socketport.cpp \
	SPAddress.cpp \
 	SPData.cpp \
	ThreadPool.cpp \
	Unk.cpp \
	Utils.cpp \
	WSockSP.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\socketport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SocketPort.cpp
 *  Content:	Winsock socket port that manages data flow on a given adapter,
 *				address and port.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/12/1999	jtk		Derived from modem endpoint class
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	SOCKET_RECEIVE_BUFFER_SIZE		( 128 * 1024 )

#ifndef DPNBUILD_NONATHELP
#define NAT_LEASE_TIME					3600000 // ask for 1 hour, in milliseconds
#endif // ! DPNBUILD_NONATHELP


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSocketPort::Initialize - initialize this socket port
//
// Entry:		Pointer to CSPData
//				Pointer to address to bind to
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Initialize"

HRESULT	CSocketPort::Initialize( CSocketData *const pSocketData,
								CThreadPool *const pThreadPool,
								CSocketAddress *const pAddress )
{
	HRESULT	hr;
	HRESULT	hTempResult;


	DNASSERT( pSocketData != NULL );
	DNASSERT( pThreadPool != NULL );
	DNASSERT( pAddress != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p, 0x%p)",
		this, pSocketData, pThreadPool, pAddress);

	//
	// initialize
	//
	hr = DPN_OK;
	pSocketData->AddSocketPortRef();
	m_pSocketData = pSocketData;
	pThreadPool->AddRef();
	m_pThreadPool = pThreadPool;

	// Deinitialize will assert that these are set in the fail cases, so we set them up front
	DEBUG_ONLY( m_fInitialized = TRUE );
	DNASSERT( m_State == SOCKET_PORT_STATE_UNKNOWN );
	m_State = SOCKET_PORT_STATE_INITIALIZED;

	//
	// attempt to initialize the internal critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		// CReadWriteLock::Deinitialize requires that CReadWriteLock::Initialize was called.
		m_EndpointDataRWLock.Initialize();

		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to initialize critical section for socket port!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes

	if ( m_EndpointDataRWLock.Initialize() == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to initialize EndpointDataRWLock read/write lock!" );
		goto Failure;
	}

	//
	// allocate addresses:
	//		local address this socket is binding to
	//		address of received messages
	//
	DNASSERT( m_pNetworkSocketAddress == NULL );
	m_pNetworkSocketAddress = pAddress;


#ifndef DPNBUILD_ONLYONEPROCESSOR
	//
	// Initially assume it can be used on any CPU.
	//
	m_dwCPU = -1;
#endif // ! DPNBUILD_ONLYONEPROCESSOR

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem in CSocketPort::Initialize()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 6, "(0x%p) Leave [0x%lx]", this, hr);

	return hr;

Failure:
	DEBUG_ONLY( m_fInitialized = FALSE );

	hTempResult = Deinitialize();
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem deinitializing CSocketPort on failed Initialize!" );
		DisplayDNError( 0, hTempResult );
	}

	m_pNetworkSocketAddress = NULL;

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Deinitialize - deinitialize this socket port
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Deinitialize"

HRESULT	CSocketPort::Deinitialize( void )
{
	HRESULT	hr;


	DPFX(DPFPREP, 6, "(0x%p) Enter", this);

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();
	DNASSERT( ( m_State == SOCKET_PORT_STATE_INITIALIZED ) ||
			  ( m_State == SOCKET_PORT_STATE_UNBOUND ) );
	DEBUG_ONLY( m_fInitialized = FALSE );

	DNASSERT( m_iEndpointRefCount == 0 );
	DNASSERT( m_iRefCount == 0 );

	//
	// return base network socket addresses
	//
	if ( m_pNetworkSocketAddress != NULL )
	{
		g_SocketAddressPool.Release( m_pNetworkSocketAddress );
		m_pNetworkSocketAddress = NULL;
	}


#ifdef DBG
#ifndef DPNBUILD_NONATHELP
	DWORD	dwTemp;
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT( m_ahNATHelpPorts[dwTemp] == NULL );
	}
#endif // DPNBUILD_NONATHELP
#endif // DBG

	Unlock();

	// Calling this is only safe if CReadWriteLock::Initialize was called, regardless of
	// whether or not it succeeded.
	m_EndpointDataRWLock.Deinitialize();

	DNDeleteCriticalSection( &m_Lock );

	if (m_pThreadPool != NULL)
	{
		m_pThreadPool->DecRef();
		m_pThreadPool = NULL;
	}

	if (m_pSocketData != NULL)
	{
		m_pSocketData->DecSocketPortRef();
		m_pSocketData = NULL;
	}


	DPFX(DPFPREP, 6, "(0x%p) Leave [0x%lx]", this, hr);

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::PoolAllocFunction - initializes a newly allocated socket port
//
// Entry:		Pointer to item
//				Context
//
// Exit:		TRUE if successful, FALSE otherwise
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::PoolAllocFunction"

BOOL	CSocketPort::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CSocketPort* 			pSocketPort = (CSocketPort*) pvItem;
	BOOL					fConnectEndpointHashTableInitted = FALSE;
	BOOL					fEnumEndpointHashTableInitted = FALSE;
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	XDP8CREATE_PARAMS *		pDP8CreateParams = (XDP8CREATE_PARAMS*) pvContext;
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL


	pSocketPort->m_pSocketData = NULL;
	pSocketPort->m_pThreadPool = NULL;
	pSocketPort->m_iRefCount = 0;
	pSocketPort->m_iEndpointRefCount = 0;
	pSocketPort->m_State = SOCKET_PORT_STATE_UNKNOWN;
	pSocketPort->m_pNetworkSocketAddress = NULL;
#ifndef DPNBUILD_ONLYONEADAPTER
	pSocketPort->m_pAdapterEntry = NULL;
#endif // ! DPNBUILD_ONLYONEADAPTER
	pSocketPort->m_Socket = INVALID_SOCKET;
	pSocketPort->m_pListenEndpoint = NULL;
	pSocketPort->m_iEnumKey = DNGetFastRandomNumber(); // pick an arbitrary starting point for the key value
	pSocketPort->m_dwSocketPortID = 0;
#ifndef DPNBUILD_NOWINSOCK2
	pSocketPort->m_fUsingProxyWinSockLSP = FALSE;
#endif // !DPNBUILD_NOWINSOCK2
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DBG)))
	pSocketPort->m_iThreadsInReceive = 0;
#endif // ! DPNBUILD_ONLYONETHREAD or DBG

	pSocketPort->m_Sig[0] = 'S';
	pSocketPort->m_Sig[1] = 'O';
	pSocketPort->m_Sig[2] = 'K';
	pSocketPort->m_Sig[3] = 'P';
	
	DEBUG_ONLY( pSocketPort->m_fInitialized = FALSE );
	pSocketPort->m_ActiveListLinkage.Initialize();
	pSocketPort->m_blConnectEndpointList.Initialize();
#ifndef DPNBUILD_NONATHELP
	ZeroMemory( pSocketPort->m_ahNATHelpPorts, sizeof(pSocketPort->m_ahNATHelpPorts) );
#endif // DPNBUILD_NONATHELP
#ifndef DPNBUILD_NOMULTICAST
	pSocketPort->m_bMulticastTTL = 0;
#endif // ! DPNBUILD_NOMULTICAST

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Initialize the connect endpoint hash with the desired number of entries,
	// rounded up to a power of 2.  Keep in mind we don't care about the local
	// player (-1).
	//
#pragma BUGBUG(vanceo, "Don't use loop")
	DWORD	dwTemp;
	BYTE	bPowerOfTwo;
	
	dwTemp = pDP8CreateParams->dwMaxNumPlayers - 1;
	bPowerOfTwo = 0;
	while (dwTemp > 0)
	{
		dwTemp = dwTemp >> 1;
		bPowerOfTwo++;
	}
	if ((pDP8CreateParams->dwMaxNumPlayers - 1) != (1 << (DWORD) bPowerOfTwo))
	{
		bPowerOfTwo++;
	}

	if (! (pSocketPort->m_ConnectEndpointHash.Initialize(bPowerOfTwo,
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
//
	// Initialize the connect endpoint hash with 16 entries and grow by a factor of 8.
	//
	if (! (pSocketPort->m_ConnectEndpointHash.Initialize(4,
														3,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
														CSocketAddress::CompareFunction,
														CSocketAddress::HashFunction)))
	{
		DPFX(DPFPREP, 0, "Could not initialize the connect endpoint list!");
		goto Failure;
	}
	fConnectEndpointHashTableInitted = TRUE;

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Initialize the connect endpoint hash with the desired number of entries.
	//
	if (! (pSocketPort->m_EnumEndpointHash.Initialize(1,
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Initialize the enum endpoint hash with 2 entries and grow by a factor of 2.
	//
	if (! (pSocketPort->m_EnumEndpointHash.Initialize(1,
													1, 
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
													CEndpointEnumKey::CompareFunction,
													CEndpointEnumKey::HashFunction)))
	{
		DPFX(DPFPREP, 0, "Could not initialize the enum endpoint list!");
		goto Failure;
	}
	fEnumEndpointHashTableInitted = TRUE;

	return TRUE;

Failure:

	if (fEnumEndpointHashTableInitted)
	{
		pSocketPort->m_EnumEndpointHash.Deinitialize();
		fEnumEndpointHashTableInitted = FALSE;
	}

	if (fConnectEndpointHashTableInitted)
	{
		pSocketPort->m_ConnectEndpointHash.Deinitialize();
		fConnectEndpointHashTableInitted = FALSE;
	}

	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::PoolInitFunction - initializes a socket port being retrieved from the pool
//
// Entry:		Pointer to item
//				Context
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::PoolInitFunction"

void	CSocketPort::PoolInitFunction( void* pvItem, void* pvContext )
{
	CSocketPort* 	pSocketPort = (CSocketPort*) pvItem;


#ifdef DBG
	DNASSERT( pSocketPort->m_fInitialized == FALSE );

	DNASSERT( pSocketPort->m_iRefCount == 0 );
	DNASSERT( pSocketPort->m_iEndpointRefCount == 0 );
#endif // DBG

	pSocketPort->m_iRefCount = 1;
	pSocketPort->m_iEndpointRefCount = 1;
}
//**********************************************************************


#ifdef DBG
//**********************************************************************
// ------------------------------
// CSocketPort::PoolDeinitFunction - returns a socket port to the pool
//
// Entry:		Pointer to item
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::PoolDeinitFunction"

void	CSocketPort::PoolDeinitFunction( void* pvItem )
{
	const CSocketPort* 	pSocketPort = (CSocketPort*) pvItem;


	DNASSERT( pSocketPort->m_fInitialized == FALSE );

	DNASSERT( pSocketPort->m_iRefCount == 0 );
	DNASSERT( pSocketPort->m_iEndpointRefCount == 0 );
}
//**********************************************************************
#endif // DBG


//**********************************************************************
// ------------------------------
// CSocketPort::PoolDeallocFunction - frees a socket port
//
// Entry:		Pointer to item
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::PoolDeallocFunction"

void	CSocketPort::PoolDeallocFunction( void* pvItem )
{
	CSocketPort* pSocketPort = (CSocketPort*) pvItem;

	
#ifdef DBG
	//
	// m_pThis needs to be around for the life of the endpoint
	// it should be part of the constructor, but can't be since we're using
	// a pool manager
	//
	DNASSERT( pSocketPort->m_fInitialized == FALSE );

	DNASSERT( pSocketPort->m_iRefCount == 0 );
	DNASSERT( pSocketPort->m_iEndpointRefCount == 0 );
	DNASSERT( pSocketPort->m_State == SOCKET_PORT_STATE_UNKNOWN );
	DNASSERT( pSocketPort->GetSocket() == INVALID_SOCKET );
	DNASSERT( pSocketPort->m_pNetworkSocketAddress == NULL );
#ifndef DPNBUILD_ONLYONEADAPTER
	DNASSERT( pSocketPort->m_pAdapterEntry == NULL );
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifndef DPNBUILD_NONATHELP
	DWORD	dwTemp;
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT( pSocketPort->m_ahNATHelpPorts[dwTemp] == NULL );
	}
#endif // DPNBUILD_NONATHELP

	DNASSERT( pSocketPort->m_ActiveListLinkage.IsEmpty() != FALSE );
	DNASSERT( pSocketPort->m_blConnectEndpointList.IsEmpty() != FALSE );
	DNASSERT( pSocketPort->m_pListenEndpoint == NULL );
	DNASSERT( pSocketPort->m_pThreadPool == NULL );
	DNASSERT( pSocketPort->m_pSocketData == NULL );

	DNASSERT( pSocketPort->m_iThreadsInReceive == 0);
#endif // DBG

	pSocketPort->m_EnumEndpointHash.Deinitialize();
	pSocketPort->m_ConnectEndpointHash.Deinitialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::EndpointAddRef - increment endpoint reference count, unless socketport is unbinding
//
// Entry:		Nothing
//
// Exit:		TRUE if endpoint ref added, FALSE if socketport is unbinding.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::EndpointAddRef"

BOOL	CSocketPort::EndpointAddRef( void )
{
	BOOL	fResult;

	
	Lock();

	//
	// add a global reference and then add an endpoint reference, unless it's 0
	//
	DNASSERT( m_iEndpointRefCount != -1 );
	if (m_iEndpointRefCount > 0)
	{
		m_iEndpointRefCount++;
		AddRef();

		DPFX(DPFPREP, 9, "(0x%p) Endpoint refcount is now %i.",
			this, m_iEndpointRefCount );

		fResult = TRUE;
	}
	else
	{
		DPFX(DPFPREP, 9, "(0x%p) Endpoint refcount is 0, not adding endpoint ref.",
			this );
		
		fResult = FALSE;
	}

	Unlock();

	return fResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::EndpointDecRef - decrement endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Endpoint reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::EndpointDecRef"

DWORD	CSocketPort::EndpointDecRef( void )
{
	DWORD	dwReturn;


	Lock();

	DNASSERT( m_iEndpointRefCount != 0 );

	m_iEndpointRefCount--;
	dwReturn = m_iEndpointRefCount;
	if ( m_iEndpointRefCount == 0 )
	{
		HRESULT				hr;
		SOCKET_PORT_STATE	PreviousState;
#ifndef DPNBUILD_ONLYONETHREAD
		DWORD				dwInterval;
#endif // ! DPNBUILD_ONLYONETHREAD


		DPFX(DPFPREP, 7, "(0x%p) Endpoint refcount hit 0, beginning to unbind from network.", this );
		
		//
		// No more endpoints are referencing this item, unbind this socket port
		// from the network and then remove it from the active socket port list.
		// If we're on Winsock1, tell the other thread that this socket needs to
		// be removed so we can get rid of our outstanding I/O reference.
		//
#ifdef WINCE
		m_pThreadPool->RemoveSocketPort( this );
#endif // WINCE
#ifdef WIN95
		if ( ( LOWORD( GetWinsockVersion() ) == 1 )
#ifndef DPNBUILD_NOIPX
			|| ( m_pNetworkSocketAddress->GetFamily() == AF_IPX ) 
#endif // DPNBUILD_NOIPX
			) 
		{
			m_pThreadPool->RemoveSocketPort( this );
		}
#endif // WIN95

		PreviousState = m_State;
		// Don't allow any more receives through
		m_State = SOCKET_PORT_STATE_UNBOUND;

		Unlock();

#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DBG
		DNASSERT(m_iThreadsInReceive == 0);
#endif // DBG
#else // ! DPNBUILD_ONLYONETHREAD
		// Wait for any receives that were already in to get out
		dwInterval = 10;
		while (m_iThreadsInReceive != 0)
		{
			DPFX(DPFPREP, 9, "There are %i threads still receiving for socketport 0x%p...", m_iThreadsInReceive, this);
			IDirectPlay8ThreadPoolWork_SleepWhileWorking(m_pThreadPool->GetDPThreadPoolWork(),
														dwInterval,
														0);
			dwInterval += 5;	// next time wait a bit longer
			DNASSERT(dwInterval < 600);
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		//
		// If we didn't failing before completing the bind, unbind.
		//
		if ( PreviousState == SOCKET_PORT_STATE_BOUND )
		{
			hr = UnbindFromNetwork();
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Problem unbinding from network when final endpoint has disconnected!" );
				DisplayDNError( 0, hr );
			}
		}

		DNASSERT( m_pNetworkSocketAddress != NULL );
	}
	else
	{
		Unlock();
		
		DPFX(DPFPREP, 9, "(0x%p) Endpoint refcount is %i, not unbinding from network.",
			this, m_iEndpointRefCount );
	}

	//
	// Decrement global reference count.  This normally doesn't result in this
 	// socketport being returned to the pool because there is always at least
 	// one more regular reference than an endpoint reference.  However, there
 	// are race conditions where this could be our caller's last reference.
	//
	DecRef();

	return	dwReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindEndpoint - add an endpoint to this SP's list
//
// Entry:		Pointer to endpoint
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindEndpoint"

HRESULT	CSocketPort::BindEndpoint( CEndpoint *const pEndpoint, GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT					hr;
	CEndpoint *				pExistingEndpoint;
#ifdef DBG
	const CSocketAddress *	pSocketAddress;
	const SOCKADDR *		pSockAddr;
#endif // DBG


	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p, %i)",
		this, pEndpoint, GatewayBindType);

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_iRefCount != 0 );
	DNASSERT( m_iEndpointRefCount != 0 );

	//
	// Munge/convert the loopback address to the local device address.
	//
	// Note that doing this causes all other multiplexed operations to use this first
	// adapter because we indicate the modified address info, not the original
	// loopback address.
	//
	pEndpoint->ChangeLoopbackAlias( GetNetworkAddress() );

	WriteLockEndpointData();


	switch ( pEndpoint->GetType() )
	{
		//
		// Treat 'connect', 'connect on listen', and multicast receive endpoints
		// as the same type.
		//
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_MULTICAST_SEND:
		case ENDPOINT_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
		{
#ifdef DBG
			//
			// Make sure it's a valid address.  Be aware that we may be trying
			// to bind an IPv4 address to an IPv6 socket, or vice versa.  We
			// will detect and handle this later (CEndpoint::CompleteConnect).
			//

			pSocketAddress = pEndpoint->GetRemoteAddressPointer();
			DNASSERT(pSocketAddress != NULL);
			pSockAddr = pSocketAddress->GetAddress();
			DNASSERT(pSockAddr != NULL);

			if (pSocketAddress->GetFamily() == AF_INET)
			{
				DNASSERT( ((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr != 0 );
				DNASSERT( ((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr != INADDR_BROADCAST );
#ifndef DPNBUILD_NOMULTICAST
				if ( pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND )
				{
					//
					// Make sure it's a multicast address.
					//
					DNASSERT(IS_CLASSD_IPV4_ADDRESS((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr));
				}
#endif // ! DPNBUILD_NOMULTICAST
			}
			DNASSERT( pSocketAddress->GetPort() != 0 );
#endif // DBG


#ifndef DPNBUILD_NOMULTICAST
			//
			// Multicast send endpoints need to know their multicast TTL settings.
			// We can only set the multicast TTL once, so if it's been set to
			// something different already, we have to fail.
			//
			if ( pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND )
			{
				GUID	guidScope;
				int		iMulticastTTL;
				int		iSocketOption;


				pEndpoint->GetScopeGuid( &guidScope );
				if ( memcmp( &guidScope, &GUID_DP8MULTICASTSCOPE_PRIVATE, sizeof(guidScope) ) == 0 )
				{
					iMulticastTTL = MULTICAST_TTL_PRIVATE;
				}
				else if ( memcmp( &guidScope, &GUID_DP8MULTICASTSCOPE_LOCAL, sizeof(guidScope) ) == 0 )
				{
					iMulticastTTL = MULTICAST_TTL_LOCAL;
				}
				else if ( memcmp( &guidScope, &GUID_DP8MULTICASTSCOPE_GLOBAL, sizeof(guidScope) ) == 0 )
				{
					iMulticastTTL = MULTICAST_TTL_GLOBAL;
				}
				else
				{
					//
					// Assume it's a valid MADCAP scope.  Even on non-NT platforms
					// where we don't know about MADCAP, we can still parse out the
					// TTL value.
					//
					iMulticastTTL = CSocketAddress::GetScopeGuidTTL( &guidScope );
				}

				if ( ( GetMulticastTTL() != 0 ) && ( GetMulticastTTL() != (BYTE) iMulticastTTL ) )
				{
					hr = DPNERR_ALREADYINITIALIZED;
					DPFX(DPFPREP, 0, "Attempted to reuse port with a different multicast scope!" );
					goto Failure;
				}


				//
				// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
				// make sure we use the proper constant.
				//
#ifdef DPNBUILD_ONLYWINSOCK2
				iSocketOption = 10;
#else // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NOWINSOCK2
				switch (GetWinsockVersion())
				{
					//
					// Winsock1, use the IP_MULTICAST_TTL value for Winsock1.
					// See WINSOCK.H
					//
					case 1:
					{
#endif // ! DPNBUILD_NOWINSOCK2
						iSocketOption = 3;
#ifndef DPNBUILD_NOWINSOCK2
						break;
					}

					//
					// Winsock2, or greater, use the IP_MULTICAST_TTL value for Winsock2.
					// See WS2TCPIP.H
					//
					case 2:
					default:
					{
						DNASSERT(GetWinsockVersion() == 2);
						iSocketOption = 10;
						break;
					}
				}
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2

				DPFX(DPFPREP, 3, "Socketport 0x%p setting IP_MULTICAST_TTL option (%i) to %i.",
					this, iSocketOption, iMulticastTTL);
				DNASSERT((iMulticastTTL > 0) && (iMulticastTTL < 255));

				if (setsockopt(GetSocket(),
								IPPROTO_IP,
								iSocketOption,
								(char*) (&iMulticastTTL),
								sizeof(iMulticastTTL)) == SOCKET_ERROR)
				{
#ifdef DBG
					DWORD	dwError;


					dwError = WSAGetLastError();
					DPFX(DPFPREP, 0, "Failed to set multicast TTL to %i (err = %u)!",
						iMulticastTTL, dwError);
					DisplayWinsockError(0, dwError);
#endif // DBG
					hr = DPNERR_GENERIC;
					goto Failure;
				}


				//
				// Save the TTL setting.  It's now carved in stone so no one else
				// can change it for this socket ever again.
				//
				m_bMulticastTTL = (BYTE) iMulticastTTL;
			}
#endif // ! DPNBUILD_NOMULTICAST


			//
			// We don't care how many connections are made through this socket port,
			// just make sure we're not connecting to the same place more than once.
			//
			if ( m_ConnectEndpointHash.Find( (PVOID)pEndpoint->GetRemoteAddressPointer(), (PVOID*)&pExistingEndpoint ) != FALSE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP, 0, "Attempted to connect twice to the same destination address!" );
				DumpSocketAddress( 0, pEndpoint->GetRemoteAddressPointer()->GetAddress(), pEndpoint->GetRemoteAddressPointer()->GetFamily() );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			if ( m_ConnectEndpointHash.Insert( (PVOID)pEndpoint->GetRemoteAddressPointer(), pEndpoint ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0, "Problem adding endpoint to connect socket port hash!" );
				goto Failure;
			}

#ifdef DPNBUILD_NOMULTICAST
			if (pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT)
#else // ! DPNBUILD_NOMULTICAST
			if ((pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT) ||
				(pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND) ||
				(pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_RECEIVE))
#endif // ! DPNBUILD_NOMULTICAST
			{
				pEndpoint->AddToSocketPortList(&m_blConnectEndpointList);

				//
				// CONNECT, MULTICAST_SEND, and MULTICAST_RECEIVE, endpoints must be
				// on a DPlay selected or fixed port.  They can't be shared but the
				// underlying socketport should be mapped on the gateway (or in the
				// case of MULTICAST_RECEIVE, it shouldn't hurt if it is).
				//
				DNASSERT((GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC));
			}
			else
			{
				//
				// CONNECT_ON_LISTEN endpoints should always be bound as NONE since
				// they should not need port mappings on the gateway.
				//
				DNASSERT(GatewayBindType == GATEWAY_BIND_TYPE_NONE);
			}
			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();
			break;
		}

		case ENDPOINT_TYPE_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_MULTICAST_LISTEN:
#endif // ! DPNBUILD_NOMULTICAST
		{
			//
			// We only allow one listen or multicast listen endpoint on a
			// socketport.
			//
			if ( m_pListenEndpoint != NULL )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP, 0, "Attempted to listen/receive multicasts more than once on a given SocketPort!" );
				goto Failure;
			}
			
#ifndef DPNBUILD_NOMULTICAST
			//
			// If this is a multicast listen, subscribe to multicast group
			//
			if ( pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN )
			{
				hr = pEndpoint->EnableMulticastReceive( this );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Couldn't enable multicast receive!");
					goto Failure;
				}
			}
#endif // ! DPNBUILD_NOMULTICAST


			//
			// LISTENs can be on a DPlay selected or fixed port, and the fixed port
			// may be shared.
			//
			DNASSERT((GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC_SHARED));


			m_pListenEndpoint = pEndpoint;
			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
#ifdef DBG
			//
			// Make sure it's a valid address.  Be aware that we may be trying
			// to bind an IPv4 address to an IPv6 socket, or vice versa.  We
			// will detect and handle this later (CEndpoint::CompleteEnumQuery).
			//

			pSocketAddress = pEndpoint->GetRemoteAddressPointer();
			DNASSERT(pSocketAddress != NULL);
			pSockAddr = pSocketAddress->GetAddress();
			DNASSERT(pSockAddr != NULL);

			if (pSocketAddress->GetFamily() == AF_INET)
			{
				DNASSERT( ((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr != 0 );
			}
			DNASSERT( pSocketAddress->GetPort() != 0 );
#endif // DBG


			//
			// We don't allow duplicate enum endpoints.
			//
			pEndpoint->SetEnumKey( GetNewEnumKey() );
			if ( m_EnumEndpointHash.Find( (PVOID)pEndpoint->GetEnumKey(), (PVOID*)&pExistingEndpoint ) != FALSE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP, 0, "Attempted to enum twice to the same endpoint!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			if ( m_EnumEndpointHash.Insert( (PVOID)pEndpoint->GetEnumKey(), pEndpoint ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0, "Problem adding endpoint to enum socket port hash!" );
				goto Failure;
			}

			//
			// ENUMs must be on a DPlay selected or fixed port.  They can't be
			// shared, but the underlying socketport should be mapped on the gateway.
			//
			DNASSERT((GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC));

			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// unknown endpoint type
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}

	pEndpoint->SetGatewayBindType(GatewayBindType);
	

Exit:

	UnlockEndpointData();

	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;


Failure:
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::UnbindEndpoint - remove an endpoint from the SP's list
//
// Entry:		Pointer to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::UnbindEndpoint"

void	CSocketPort::UnbindEndpoint( CEndpoint *const pEndpoint )
{
#ifndef DPNBUILD_ONLYONEADAPTER
	BOOL		fRemoveFromMultiplex = FALSE;
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifdef DBG
	CEndpoint *	pFindTemp;
#endif // DBG

	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p)", this, pEndpoint);

	WriteLockEndpointData();


	pEndpoint->SetGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


	//
	// adjust any special pointers before removing endpoint
	//
	switch ( pEndpoint->GetType() )
	{
		//
		// Connect, connect-on-listen, multicast send and multicast receive endpoints are
		// treated the same.  Remove endpoint from connect list.
		//
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_MULTICAST_SEND:
		case ENDPOINT_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
		{
#ifdef DBG
			DNASSERT( m_ConnectEndpointHash.Find( (PVOID)pEndpoint->GetRemoteAddressPointer(), (PVOID*)&pFindTemp ) );
			DNASSERT( pFindTemp == pEndpoint );
#endif // DBG
			m_ConnectEndpointHash.Remove( (PVOID)pEndpoint->GetRemoteAddressPointer() );

#ifdef DPNBUILD_NOMULTICAST
			if (pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT)
#else // ! DPNBUILD_NOMULTICAST
			if ((pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT) ||
				(pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND) ||
				(pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_RECEIVE))
#endif // ! DPNBUILD_NOMULTICAST
			{
				pEndpoint->RemoveFromSocketPortList();
			}

			pEndpoint->SetSocketPort( NULL );

#ifdef DPNBUILD_ONLYONEADAPTER
			pEndpoint->DecRef();
#else // ! DPNBUILD_ONLYONEADAPTER
			fRemoveFromMultiplex = TRUE;
#endif // ! DPNBUILD_ONLYONEADAPTER

			break;
		}

		//
		// Make sure this is really the active listen/multicast listen and
		// then remove it.
		//
#ifndef DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_MULTICAST_LISTEN:
#endif // ! DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( m_pListenEndpoint == pEndpoint );
			m_pListenEndpoint = NULL;


#ifndef DPNBUILD_NOMULTICAST
			//
			// If this is a multicast listen, subscribe to multicast group
			//
			if (pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN)
			{
				HRESULT		hr;


				hr = pEndpoint->DisableMulticastReceive();
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't disable multicast receive (err = 0x%lx)!", hr);
					DisplayDNError(0, hr);
				}
			}
#endif // ! DPNBUILD_NOMULTICAST
			
			pEndpoint->SetSocketPort( NULL );

			pEndpoint->DecRef();
			break;
		}

		//
		// Remove endpoint from enum list.
		//
		case ENDPOINT_TYPE_ENUM:
		{
#ifdef DBG
			DNASSERT( m_EnumEndpointHash.Find( (PVOID)pEndpoint->GetEnumKey(), (PVOID*)&pFindTemp ) );
			DNASSERT( pFindTemp == pEndpoint );
#endif // DBG
			m_EnumEndpointHash.Remove( (PVOID)pEndpoint->GetEnumKey() );

			pEndpoint->SetSocketPort( NULL );
			
#ifdef DPNBUILD_ONLYONEADAPTER
			pEndpoint->DecRef();
#else // ! DPNBUILD_ONLYONEADAPTER
			fRemoveFromMultiplex = TRUE;
#endif // ! DPNBUILD_ONLYONEADAPTER

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	UnlockEndpointData();

#ifndef DPNBUILD_ONLYONEADAPTER
	if (fRemoveFromMultiplex)
	{
		//
		// The multiplex list is protected by the SPData's socket data lock which
		// we must take now.
		// Removing from a list when not in a list does not cause any problems.
		//
		DNASSERT(m_pSocketData != NULL);
		m_pSocketData->Lock();
		pEndpoint->RemoveFromMultiplexList();
		m_pSocketData->Unlock();
		fRemoveFromMultiplex = FALSE;

		pEndpoint->DecRef();
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendData - send data
//
// Entry:		Pointer to write data buffer
//				Buffer count
//				Pointer to destination socket address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendData"

#ifdef DPNBUILD_ASYNCSPSENDS
void	CSocketPort::SendData( BUFFERDESC *pBuffers, UINT_PTR uiBufferCount, const CSocketAddress *pDestinationSocketAddress, OVERLAPPED * pOverlapped )
#else // ! DPNBUILD_ASYNCSPSENDS
void	CSocketPort::SendData( BUFFERDESC *pBuffers, UINT_PTR uiBufferCount, const CSocketAddress *pDestinationSocketAddress )
#endif // ! DPNBUILD_ASYNCSPSENDS
{
	INT		iSendToReturn;
#ifdef DPNBUILD_WINSOCKSTATISTICS
	DWORD	dwStartTime;
#endif // DPNBUILD_WINSOCKSTATISTICS


	DNASSERT(pBuffers != NULL);
	DNASSERT( uiBufferCount != 0 );
	DNASSERT( pDestinationSocketAddress != NULL );

	DNASSERT( m_State == SOCKET_PORT_STATE_BOUND );

	//
	// Win9x WinSock 1 only systems or Win9x WinSock2 systems running IPX
	// need to use the WinSock 1 code path.  Everyone else should use the
	// WinSock 2 code path.
	//
#ifndef DPNBUILD_ONLYWINSOCK2
#ifndef DPNBUILD_NOWINSOCK2
	if ( ( LOWORD( GetWinsockVersion() ) < 2 ) 
#ifndef DPNBUILD_NOIPX
		|| ( m_pNetworkSocketAddress->GetFamily() != AF_INET ) 
#endif // ! DPNBUILD_NOIPX
		)
#endif // ! DPNBUILD_NOWINSOCK2
	{
		UINT_PTR	uOutputBufferIndex;
		INT			iOutputByteCount;
		char		TempBuffer[ MAX_SEND_FRAME_SIZE ];


		//
		// flatten output data
		//
		iOutputByteCount = 0;
		uOutputBufferIndex = 0;

		do
		{
			DNASSERT( ( iOutputByteCount + pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
			memcpy( &TempBuffer[ iOutputByteCount ], pBuffers[ uOutputBufferIndex ].pBufferData, pBuffers[ uOutputBufferIndex ].dwBufferSize );
			iOutputByteCount += pBuffers[ uOutputBufferIndex ].dwBufferSize;

			uOutputBufferIndex++;
		} while( uOutputBufferIndex < uiBufferCount );

#ifdef DBG
		DPFX(DPFPREP, 7, "(0x%p) Winsock1 sending %i bytes (in 0x%p's %u buffers) from + to:",
			this, iOutputByteCount, pBuffers, uOutputBufferIndex );
		DumpSocketAddress( 7, GetNetworkAddress()->GetAddress(), GetNetworkAddress()->GetFamily() );
		DumpSocketAddress( 7, pDestinationSocketAddress->GetAddress(), pDestinationSocketAddress->GetFamily() );

		DNASSERT(iOutputByteCount > 0);
#endif // DBG

#ifdef DPNBUILD_WINSOCKSTATISTICS
		dwStartTime = GETTIMESTAMP();
#endif // DPNBUILD_WINSOCKSTATISTICS

		//
		// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
		//
		iSendToReturn = sendto( GetSocket(),			// socket
								  TempBuffer,			// data to send
								  iOutputByteCount,		// number of bytes to send
								  0,					// flags (none)
								  pDestinationSocketAddress->GetAddress(),		// pointer to destination address
								  pDestinationSocketAddress->GetAddressSize()		// size of destination address
								  );

#ifdef DPNBUILD_WINSOCKSTATISTICS
#ifndef WINCE
		DNInterlockedExchangeAdd((LPLONG) (&g_dwWinsockStatSendCallTime),
								(GETTIMESTAMP() - dwStartTime));
#endif // ! WINCE
		DNInterlockedIncrement((LPLONG) (&g_dwWinsockStatNumSends));
#endif // DPNBUILD_WINSOCKSTATISTICS
	}
#ifndef DPNBUILD_NOWINSOCK2
	else
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2
#ifndef DPNBUILD_NOWINSOCK2
	{
		DWORD	dwBytesSent;


		DBG_CASSERT( sizeof( pBuffers ) == sizeof( WSABUF* ) );
		DBG_CASSERT( sizeof( *pBuffers ) == sizeof( WSABUF ) );

#ifdef DBG
		{
			UINT_PTR	uiBuffer;
			UINT_PTR	uiTotalSize;


			uiTotalSize = 0;
			
			for(uiBuffer = 0; uiBuffer < uiBufferCount; uiBuffer++)
			{
				DNASSERT(pBuffers[uiBuffer].pBufferData != NULL);
				DNASSERT(pBuffers[uiBuffer].dwBufferSize != 0);

				uiTotalSize += pBuffers[uiBuffer].dwBufferSize;
			}
			
			DPFX(DPFPREP, 7, "(0x%p) Winsock2 sending %u bytes (in 0x%p's %u buffers) from + to:",
				this, uiTotalSize, pBuffers, uiBufferCount );
			DumpSocketAddress( 7, GetNetworkAddress()->GetAddress(), GetNetworkAddress()->GetFamily() );
			DumpSocketAddress( 7, pDestinationSocketAddress->GetAddress(), pDestinationSocketAddress->GetFamily() );

			DNASSERT(uiTotalSize > 0);
			if (pBuffers[0].pBufferData[0] == 0)
			{
				PREPEND_BUFFER *	pPrependBuffer;


				//
				// Make sure the data is formed correctly.
				//
				DNASSERT(uiBufferCount > 1);
				pPrependBuffer = (PREPEND_BUFFER*) pBuffers[0].pBufferData;
				switch (pPrependBuffer->GenericHeader.bSPCommandByte)
				{
					case ENUM_DATA_KIND:
					case ENUM_RESPONSE_DATA_KIND:
#ifndef DPNBUILD_SINGLEPROCESS
					case PROXIED_ENUM_DATA_KIND:
#endif // ! DPNBUILD_SINGLEPROCESS
#ifdef DPNBUILD_XNETSECURITY
					case XNETSEC_ENUM_RESPONSE_DATA_KIND:
#endif // DPNBUILD_XNETSECURITY
					{
						DNASSERT(pBuffers[1].dwBufferSize > 0);
						break;
					}
					
					default:
					{
						DNASSERT(FALSE);
						break;
					}
				}
			}

			switch (pDestinationSocketAddress->GetFamily() )
			{
				case AF_INET:
				{
					SOCKADDR_IN *	psaddrin;


					psaddrin = (SOCKADDR_IN *) pDestinationSocketAddress->GetAddress();
					
					DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
					DNASSERT( psaddrin->sin_port != 0 );

					break;
				}
				
#ifndef DPNBUILD_NOIPX
				case AF_IPX:
				{
					break;
				}
#endif // ! DPNBUILD_NOIPX
				
#ifndef DPNBUILD_NOIPV6
				case AF_INET6:
				{
					SOCKADDR_IN6 *	psaddrin6;

					
					psaddrin6 = (SOCKADDR_IN6 *) pDestinationSocketAddress->GetAddress();
					
					DNASSERT (! IN6_IS_ADDR_UNSPECIFIED(&psaddrin6->sin6_addr));		
					DNASSERT( psaddrin6->sin6_port != 0 );
					break;
				}
#endif // ! DPNBUILD_NOIPV6

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
		}
#endif // DBG

		DNASSERT( uiBufferCount <= UINT32_MAX );

#ifdef DPNBUILD_WINSOCKSTATISTICS
		dwStartTime = GETTIMESTAMP();
#endif // DPNBUILD_WINSOCKSTATISTICS

#ifdef DPNBUILD_ASYNCSPSENDS
		iSendToReturn = p_WSASendTo( GetSocket(),									// socket
									reinterpret_cast<WSABUF*>( pBuffers ),			// buffers
									static_cast<DWORD>( uiBufferCount ),			// count of buffers
									&dwBytesSent,									// pointer to number of bytes sent
									0,												// send flags
									pDestinationSocketAddress->GetAddress(),		// pointer to destination address
									pDestinationSocketAddress->GetAddressSize(),	// size of destination address
									pOverlapped,									// pointer to overlap structure
									NULL);											// APC callback (unused)
#else // ! DPNBUILD_ASYNCSPSENDS
		iSendToReturn = p_WSASendTo( GetSocket(),									// socket
									reinterpret_cast<WSABUF*>( pBuffers ),			// buffers
									static_cast<DWORD>( uiBufferCount ),			// count of buffers
									&dwBytesSent,									// pointer to number of bytes sent
									0,												// send flags
									pDestinationSocketAddress->GetAddress(),		// pointer to destination address
									pDestinationSocketAddress->GetAddressSize(),	// size of destination address
									NULL,											// pointer to overlap structure
									NULL);											// APC callback (unused)
#endif // ! DPNBUILD_ASYNCSPSENDS

#ifdef DPNBUILD_WINSOCKSTATISTICS
		DNInterlockedExchangeAdd((LPLONG) (&g_dwWinsockStatSendCallTime),
								(GETTIMESTAMP() - dwStartTime));
		DNInterlockedIncrement((LPLONG) (&g_dwWinsockStatNumSends));
#endif // DPNBUILD_WINSOCKSTATISTICS
	}
#endif // ! DPNBUILD_NOWINSOCK2
#ifdef DBG
	if ( iSendToReturn == SOCKET_ERROR )
	{
		DWORD	dwWinsockError;


		dwWinsockError = WSAGetLastError();
#ifdef DPNBUILD_ASYNCSPSENDS
		if (dwWinsockError == ERROR_IO_PENDING)
		{
			DPFX(DPFPREP, 8, "(0x%p) Overlapped 0x%p send is pending.",
				this, pOverlapped);
			DNASSERT(pOverlapped != NULL);
		}
		else
#endif // DPNBUILD_ASYNCSPSENDS
		{
			DPFX(DPFPREP, 0, "Problem with sendto (err = %u)!", dwWinsockError );
			DisplayWinsockError( 0, dwWinsockError );
			DNASSERTX(! "SendTo failed!", 3);
		}

		//
		// Continue anyway, send failures are ignored.
		// For async sends, our overlapped structure should always get signalled.
		//
	}
#endif // DBG
}
//**********************************************************************


#ifndef DPNBUILD_ONLYWINSOCK2
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock1ReadService - service a read request on a socket
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock1ReadService"

BOOL	CSocketPort::Winsock1ReadService( void )
{
	BOOL						fIOServiced;
	INT							iSocketReturn;
	CReadIOData					*pReadData;
	READ_IO_DATA_POOL_CONTEXT	PoolContext;

	//
	// initialize
	//
	fIOServiced = FALSE;
	
	//
	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
	// just fail to service this read and the socket will still be labeled
	// as ready to receive so we'll try again later.
	//
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	PoolContext.sSPType = m_pNetworkSocketAddress->GetFamily();
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifndef DPNBUILD_ONLYONEPROCESSOR
	PoolContext.dwCPU = 0;	// we always only use CPU 0, systems using Winsock 1 should only have 1 CPU anyway
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifdef DPNBUILD_NOWINSOCK2
	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
#else // ! DPNBUILD_NOWINSOCK2
	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext, FALSE );
#endif // ! DPNBUILD_NOWINSOCK2
	if ( pReadData == NULL )
	{
		DPFX(DPFPREP, 0, "Could not get read data to perform a Winsock1 read!" );
		goto Exit;
	}

	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
	pReadData->SetSocketPort( NULL );
	iSocketReturn = recvfrom( GetSocket(),												// socket to read from
								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
								0,															// flags (none)
								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
								&pReadData->m_iSocketAddressSize							// size of address of sending socket
								);

#ifdef WINCE
	//
	// On a Pocket PC 2002 machine recvfrom() can stomp the from address,
	// causing the address family to be invalid.  This is not good, so to
	// workaround, we will forcefully restore it.
	//
	pReadData->m_pSourceSocketAddress->GetWritableAddress()->sa_family = m_pNetworkSocketAddress->GetFamily();
#endif // WINCE

	switch ( iSocketReturn )
	{
		//
		// socket has been closed
		//
		case 0:
		{
			break;
		}

		//
		// problem
		//
		case SOCKET_ERROR:
		{
			DWORD	dwWinsockError;


			dwWinsockError = WSAGetLastError();
			switch ( dwWinsockError )
			{
				//
				// one of our previous sends failed to get through,
				// and we don't really care anymore
				//
				case WSAECONNRESET:
				{
					DPFX(DPFPREP, 7, "(0x%p) Send failure reported from + to:", this);
					DumpSocketAddress(7, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
					DumpSocketAddress(7, GetNetworkAddress()->GetAddress(), GetNetworkAddress()->GetFamily());
					break;
				}

				//
				// the socket isn't valid, it was probably closed
				//
				case WSAENOTSOCK:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting 'Not a socket' on receive." );
					break;
				}

				//
				// the socket appears to have been shut down
				//
				case WSAESHUTDOWN:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting socket was shut down." );
					break;
				}

				//
				// there is no data to read
				//
				case WSAEWOULDBLOCK:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting there is no data to receive on a socket." );
					break;
				}

				//
				// read operation was interrupted
				//
				case WSAEINTR:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting receive was interrupted." );
					break;
				}

				//
				// something bad happened
				//
				default:
				{
					DPFX(DPFPREP, 0, "Problem with Winsock1 recvfrom!" );
					DisplayWinsockError( 0, dwWinsockError );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// bytes were read
		//
		default:
		{
			fIOServiced = TRUE;
			if (pReadData->m_pSourceSocketAddress->IsValidUnicastAddress(FALSE))
			{
				pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
				ProcessReceivedData( pReadData );
			}
			else
			{
				DPFX(DPFPREP, 7, "(0x%p) Invalid source address, ignoring %i bytes of data from + to:",
					this, iSocketReturn);
				DumpSocketAddress(7, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
				DumpSocketAddress(7, GetNetworkAddress()->GetAddress(), GetNetworkAddress()->GetFamily());
			}

			break;
		}
	}

	DNASSERT( pReadData != NULL );
	pReadData->DecRef();

Exit:
	return fIOServiced;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock1ErrorService - service an error on this socket
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock1ErrorService"

BOOL	CSocketPort::Winsock1ErrorService( void )
{
	//
	// this function doesn't do anything because errors on sockets will usually
	// result in the socket being closed soon
	//
	return	FALSE;
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYWINSOCK2


#ifndef DPNBUILD_NOWINSOCK2
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2Receive - receive data in a Winsock 2.0 fashion
//
// Entry:		CPU number on which to receive (multi-proc builds only)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2Receive"

#ifdef DPNBUILD_ONLYONEPROCESSOR
HRESULT	CSocketPort::Winsock2Receive( void )
#else // ! DPNBUILD_ONLYONEPROCESSOR
HRESULT	CSocketPort::Winsock2Receive( const DWORD dwCPU )
#endif // ! DPNBUILD_ONLYONEPROCESSOR
{
	HRESULT						hr;
	INT							iWSAReturn;
	READ_IO_DATA_POOL_CONTEXT	PoolContext;
	CReadIOData					*pReadData;
	DWORD						dwFlags;


	//
	// initialize
	//
	hr = DPN_OK;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	PoolContext.sSPType = m_pNetworkSocketAddress->GetFamily();
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifndef DPNBUILD_ONLYONEPROCESSOR
	PoolContext.dwCPU = dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifdef DPNBUILD_ONLYWINSOCK2
	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
#else // ! DPNBUILD_ONLYWINSOCK2
	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext, TRUE );
#endif // ! DPNBUILD_ONLYWINSOCK2
	if ( pReadData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Out of memory attempting Winsock2 read!" );
		goto Exit;
	}

	//
	// pReadData has one reference so far, the one for this function.
	//


	//
	// note the IO reference before attempting the read
	//
	AddRef();

	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );
	DNASSERT( pReadData->SocketPort() == NULL );

	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc ) == sizeof( WSABUF ) );
	DBG_CASSERT( OFFSETOF( BUFFERDESC, dwBufferSize ) == OFFSETOF( WSABUF, len ) );
	DBG_CASSERT( OFFSETOF( BUFFERDESC, pBufferData ) == OFFSETOF( WSABUF, buf ) );

	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
	pReadData->SetSocketPort( this );


	DPFX(DPFPREP, 8, "Submitting read 0x%p (socketport 0x%p, socket 0x%p).",
		pReadData, this, GetSocket());


	//
	// Add a reference for submitting the read to WinSock.  This should be
	// removed when the receive completes.
	//
	pReadData->AddRef();

	DNASSERT( pReadData->m_dwOverlappedBytesReceived == 0 );

Reread:

	dwFlags = 0;

	if ( GetSocket() == INVALID_SOCKET )
	{
		DPFX(DPFPREP, 1, "Attempting to submit read 0x%p on socketport (0x%p) that does not have a valid handle.",
			pReadData, this);
	}
	
	iWSAReturn = p_WSARecvFrom( GetSocket(),															// socket
								reinterpret_cast<WSABUF*>(&pReadData->ReceivedBuffer()->BufferDesc),	// pointer to receive buffers
								1,																		// number of receive buffers
								&pReadData->m_dwBytesRead,												// pointer to bytes received (if command completes immediately)
								&dwFlags,																// flags (none)
								pReadData->m_pSourceSocketAddress->GetWritableAddress(),				// address of sending socket
								&pReadData->m_iSocketAddressSize,										// size of address of sending socket
								(WSAOVERLAPPED*) pReadData->GetOverlapped(),							// pointer to overlapped structure
								NULL																	// APC callback (unused)
								);	
	if ( iWSAReturn == 0 )
	{
		DPFX(DPFPREP, 8, "WSARecvFrom for read data 0x%p completed immediately.",
			pReadData );


#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
		//
		// Winsock still generates a completion, even though it returned a
		// result immediately.
		//
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
		//
		// Return the read data's overlapped structure since it won't be used
		// but we can't wait for the read data pool release function to return
		// the overlapped structure (because the
		// CSocketPort::Winsock2ReceiveComplete call assumes it was invoked by
		// the I/O completion where this isn't necessary).
		//
		// First retrieve the overlapped result, though.
		//
		if (! p_WSAGetOverlappedResult(GetSocket(),
										(WSAOVERLAPPED*) pReadData->GetOverlapped(),
										&pReadData->m_dwOverlappedBytesReceived,
										FALSE,
										&dwFlags))
		{
			pReadData->m_ReceiveWSAReturn = WSAGetLastError();
		}
		else
		{
			pReadData->m_ReceiveWSAReturn = ERROR_SUCCESS;
		}


		hr = IDirectPlay8ThreadPoolWork_ReleaseOverlapped(m_pThreadPool->GetDPThreadPoolWork(),
														pReadData->GetOverlapped(),
														0);
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't release overlapped structure 0x%p for read data 0x%p!",
				pReadData->GetOverlapped(), pReadData);
			DNASSERT(FALSE);
		}
		pReadData->SetOverlapped(NULL);
		pReadData->m_ReceiveWSAReturn = iWSAReturn;


		//
		// Queue a job up so that the receive gets processed.  Technically we
		// could just handle it here, but since new receives get submitted
		// when handling a previous receive *prior* to actually processing the
		// data, that would cause unnecessary out-of-order receives.
		//
		// We transfer our read data object reference to the delayed completion.
		//
#ifdef DPNBUILD_ONLYONEPROCESSOR
		hr = m_pThreadPool->SubmitDelayedCommand( CSocketPort::Winsock2ReceiveComplete,		// callback function
												pReadData );								// callback context
#else // ! DPNBUILD_ONLYONEPROCESSOR
		hr = m_pThreadPool->SubmitDelayedCommand( dwCPU,									// CPU
												CSocketPort::Winsock2ReceiveComplete,		// callback function
												pReadData );								// callback context
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't submit delayed processing command for read data 0x%p!",
				pReadData);
			DNASSERT(FALSE);
		}
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
	}
	else
	{
		DWORD	dwWSAReceiveError;


		//
		// failure, check for pending operation
		//
		dwWSAReceiveError = WSAGetLastError();
		switch ( dwWSAReceiveError )
		{
			//
			// the send is pending, nothing to do
			//
			case ERROR_IO_PENDING:
			{
				hr = IDirectPlay8ThreadPoolWork_SubmitIoOperation(m_pThreadPool->GetDPThreadPoolWork(),
																	pReadData->GetOverlapped(),
																	0);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't start monitoring read data 0x%p!",
						pReadData);
					DNASSERT(FALSE);
				}

				//
				// We transfer the read data reference to the I/O
				// monitoring code.
				//

				break;
			}

			//
			// Since this is a UDP socket, this is an indication
			// that a previous send failed.  Ignore it and move
			// on.
			//
			case WSAECONNRESET:
			{
				DPFX(DPFPREP, 8, "WSARecvFrom issued a WSACONNRESET." );
				goto Reread;
				break;
			}

			case WSAENOTSOCK:
			{
				DPFX(DPFPREP, 8, "Got WSAENOTSOCK on RecvFrom." );

				hr = DPNERR_GENERIC;

				DNASSERT( pReadData != NULL );

				//
				// Remove the WinSock reference.
				//
				pReadData->DecRef();

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
			}

			//
			// there was a problem, no completion notification will
			// be given, decrement our IO reference count
			//
			default:
			{
				hr = DPNERR_GENERIC;
				
				//
				// 'Known Errors' that we don't want to ASSERT on.
				//
				// WSAEINTR: the socket has been shut down and is about to be/has been closed
				// WSAESHUTDOWN: the socket has been shut down and is about to be/has been closed
				// WSAENOBUFS: out of memory (stress condition)
				//
				switch ( dwWSAReceiveError )
				{
					case WSAEINTR:
					{
						DPFX(DPFPREP, 1, "Got WSAEINTR while trying to RecvFrom." );
						break;
					}

					case WSAESHUTDOWN:
					{
						DPFX(DPFPREP, 1, "Got WSAESHUTDOWN while trying to RecvFrom." );
						break;
					}

					case WSAENOBUFS:
					{
						DPFX(DPFPREP, 1, "Got WSAENOBUFS while trying to RecvFrom." );
						break;
					}

					default:
					{
						DPFX(DPFPREP, 0, "Unknown WinSock error when issuing read!" );
						DisplayWinsockError( 0, dwWSAReceiveError );
						DNASSERT( FALSE );
					}
				}

				DNASSERT( pReadData != NULL );

				//
				// Remove the WinSock reference.
				//
				pReadData->DecRef();

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
			}
		}
	}

Exit:
	
	if ( pReadData != NULL )
	{
		pReadData->DecRef();
	}
	return	hr;
}
//**********************************************************************
#endif // DPNBUILD_NOWINSOCK2



#ifndef WINCE

//**********************************************************************
// ------------------------------
// CSocketPort::SetWinsockBufferSize -  set the buffer size used by Winsock for
//			this socket.
//
// Entry:		Buffer size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SetWinsockBufferSize"

void	CSocketPort::SetWinsockBufferSize( const INT iBufferSize ) const
{
	INT	iReturnValue;


	DPFX(DPFPREP, 3, "(0x%p) Setting socket 0x%p receive buffer size to: %d",
		this, GetSocket(), g_iWinsockReceiveBufferSize );

	iReturnValue = setsockopt( GetSocket(),
								 SOL_SOCKET,
								 SO_RCVBUF,
								 reinterpret_cast<char*>( &g_iWinsockReceiveBufferSize ),
								 sizeof( g_iWinsockReceiveBufferSize )
								 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to set the socket buffer receive size!" );
		DisplayWinsockError( 0, dwErrorCode );
	}
}
//**********************************************************************

#endif // ! WINCE




//**********************************************************************
// ------------------------------
// CSocketPort::BindToNetwork - bind this socket port to the network
//
// Entry:		Handle of I/O completion port (NT old thread pool only)
//				CPU number (mult-proc builds only)
//				How to map socket on gateway
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToNetwork"

#ifdef DPNBUILD_ONLYONEPROCESSOR
HRESULT	CSocketPort::BindToNetwork( const GATEWAY_BIND_TYPE GatewayBindType )
#else // ! DPNBUILD_ONLYONEPROCESSOR
HRESULT	CSocketPort::BindToNetwork( const DWORD dwCPU, const GATEWAY_BIND_TYPE GatewayBindType )
#endif // ! DPNBUILD_ONLYONEPROCESSOR
{
	HRESULT				hr;
	INT					iReturnValue;
	BOOL				fTemp;
#ifndef WINCE
	INT					iSendBufferSize;
#endif // !WINCE
	CSocketAddress *	pBoundSocketAddress;
	WORD				wBasePort;
	DWORD				dwErrorCode;
	DWORD *				pdwAddressChunk;
	DWORD *				pdwLastAddressChunk;
#if ((! defined(DPNBUILD_ONLYWINSOCK2)) || (defined(WINNT)))
	DWORD				dwTemp;
#endif // ! DPNBUILD_ONLYWINSOCK2 or WINNT


	DPFX(DPFPREP, 7, "(0x%p) Parameters: (%i)", this, GatewayBindType );

	//
	// initialize
	//
	hr = DPN_OK;
	pBoundSocketAddress = NULL;

	//
	// If we're picking a port, start at the base port.  If we're on the
	// ICS machine itself. pick a different starting point to workaround
	// port stealing.
	//
#ifdef DPNBUILD_NOREGISTRY
	wBasePort = BASE_DPLAY8_PORT;

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
	if ((IsNATTraversalEnabled()) &&
		(g_fLocalNATDetectedAtStartup))
	{
#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
		if (m_pNetworkSocketAddress->GetFamily() == AF_INET)
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
		{
			wBasePort += (MAX_DPLAY8_PORT - BASE_DPLAY8_PORT) / 2;
		}
	}
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT
#else // ! DPNBUILD_NOREGISTRY
	wBasePort = g_wBaseDPlayPort;

#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_NOLOCALNAT)))
	if ((GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE) &&
		(g_fLocalNATDetectedAtStartup))
	{
#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
		if (m_pNetworkSocketAddress->GetFamily() == AF_INET)
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
		{
			wBasePort += (g_wMaxDPlayPort - g_wBaseDPlayPort) / 2;
		}
	}
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_NOLOCALNAT
#endif // ! DPNBUILD_NOREGISTRY


#ifndef DPNBUILD_ONLYONEPROCESSOR
	//
	// Save the CPU to use.
	//
	m_dwCPU = dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR


#ifndef DPNBUILD_NONATHELP
RebindToNextPort:
#endif // ! DPNBUILD_NONATHELP

#ifdef DBG
	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
#endif // DBG

	//
	// get a socket for this socket port
	//
	DNASSERT( GetSocket() == INVALID_SOCKET );

	m_Socket = socket( m_pNetworkSocketAddress->GetFamily(),		// address family
						SOCK_DGRAM,									// datagram (connectionless) socket
						m_pNetworkSocketAddress->GetProtocol() );	// protocol
	if ( GetSocket() == INVALID_SOCKET )
	{
		hr = DPNERR_NOCONNECTION;
		DPFX(DPFPREP, 0, "Failed to bind to socket!" );
		goto Failure;
	}

	DPFX(DPFPREP, 5, "Created socketport 0x%p socket 0x%p.", this, m_Socket);


	//
	// set socket to allow broadcasts
	//
	fTemp = TRUE;
	DBG_CASSERT( sizeof( &fTemp ) == sizeof( char * ) );
	iReturnValue = setsockopt( GetSocket(),		// socket
	    						 SOL_SOCKET,		// level (set socket options)
	    						 SO_BROADCAST,		// set broadcast option
	    						 reinterpret_cast<char *>( &fTemp ),	// allow broadcast
	    						 sizeof( fTemp )	// size of parameter
	    						 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = WSAGetLastError();
	    DPFX(DPFPREP, 0, "Unable to set broadcast socket option (err = %u)!",
	    	dwErrorCode );
	    DisplayWinsockError( 0, dwErrorCode );
	    hr = DPNERR_GENERIC;
	    goto Failure;
	}

#ifndef WINCE // WinCE fails these with WSAENOPROTOOPT
	//
	// set socket receive buffer space if the user overrode it
	// Failing this is a preformance hit so ignore and errors.
	//
	if ( g_fWinsockReceiveBufferSizeOverridden != FALSE )
	{
		SetWinsockBufferSize( g_iWinsockReceiveBufferSize );
	}
	
	//
	// set socket send buffer space to 0 (we will supply all buffers).
	// Failing this is only a performance hit so ignore any errors.
	//
	iSendBufferSize = 0;
	iReturnValue = setsockopt( GetSocket(),
								 SOL_SOCKET,
								 SO_SNDBUF,
								 reinterpret_cast<char*>( &iSendBufferSize ),
								 sizeof( iSendBufferSize )
								 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to set the socket buffer send size (err = %u)!", dwErrorCode );
		DisplayWinsockError( 0, dwErrorCode );
	}
#endif // ! WINCE


#ifndef DPNBUILD_ONLYWINSOCK2
	//
	// put socket into non-blocking mode, if WinSock 1 or 9x IPX
	//
#ifndef DPNBUILD_NOWINSOCK2
	if ( ( LOWORD( GetWinsockVersion() ) == 1 )
#ifndef DPNBUILD_NOIPX
		|| ( m_pNetworkSocketAddress->GetFamily() == AF_IPX ) 
#endif // ! DPNBUILD_NOIPX
		) 
#endif // ! DPNBUILD_NOWINSOCK2
	{
		DPFX(DPFPREP, 5, "Marking socket as non-blocking." );
		
		dwTemp = 1;
		iReturnValue = ioctlsocket( GetSocket(),	// socket
		    						  FIONBIO,		// I/O option to set (blocking mode)
		    						  &dwTemp		// I/O option value (non-zero puts socket into non-block mode)
		    						  );
		if ( iReturnValue == SOCKET_ERROR )
		{
			dwErrorCode = WSAGetLastError();
			DPFX(DPFPREP, 0, "Could not set socket into non-blocking mode (err = %u)!",
				dwErrorCode );
			DisplayWinsockError( 0, dwErrorCode );
			hr = DPNERR_GENERIC;
			goto Failure;
		}
	}
#else // DPNBUILD_ONLYWINSOCK2
#ifdef WINNT
	//
	// Attempt to make buffer circular.
	//

	iReturnValue = p_WSAIoctl(GetSocket(),					// socket
							SIO_ENABLE_CIRCULAR_QUEUEING,	// io control code
							NULL,							// in buffer
							0,								// in buffer size
							NULL,							// out buffer
							0,								// out buffer size
							&dwTemp,						// pointer to bytes returned
							NULL,							// overlapped
							NULL							// completion routine
							);
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = WSAGetLastError();
		DPFX(DPFPREP, 1, "Could not enable circular queuing (err = %u), ignoring.",
		    dwErrorCode );
		DisplayWinsockError( 1, dwErrorCode );
	}


#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
	if ( m_pNetworkSocketAddress->GetFamily() == AF_INET ) 
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
	{
		//
		// Make broadcasts only go out on the interface on which they were sent
		// (as opposed to all interfaces).
		//

		fTemp = TRUE;
		iReturnValue = p_WSAIoctl(GetSocket(),			// socket
								SIO_LIMIT_BROADCASTS,	// io control code
								&fTemp,					// in buffer
								sizeof(fTemp),			// in buffer size
								NULL,					// out buffer
								0,						// out buffer size
								&dwTemp,				// pointer to bytes returned
								NULL,					// overlapped
								NULL					// completion routine
								);
		if ( iReturnValue == SOCKET_ERROR )
		{
			dwErrorCode = WSAGetLastError();
			DPFX(DPFPREP, 1, "Could not limit broadcasts (err = %u), ignoring.",
			    dwErrorCode );
			DisplayWinsockError( 1, dwErrorCode );
		}
	}
#endif // WINNT
#endif // DPNBUILD_ONLYWINSOCK2


	//
	// bind socket
	//
	DPFX(DPFPREP, 1, "Binding to socket addess:" );
	DumpSocketAddress( 1, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
	
	DNASSERT( GetSocket() != INVALID_SOCKET );
	
	hr = BindToNextAvailablePort( m_pNetworkSocketAddress, wBasePort );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind to network!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
	m_State = SOCKET_PORT_STATE_BOUND;

	//
	// Find out what address we really bound to.  This information is needed to
	// talk to the Internet gateway and will be needed when someone above queries for
	// what the local network address is.
	//
	pBoundSocketAddress = GetBoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
	if ( pBoundSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get bound adapter address!" );
		goto Failure;
	}
	DPFX(DPFPREP, 1, "Socket we really bound to:" );
	DumpSocketAddress( 1, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );


#ifndef DPNBUILD_NONATHELP
	//
	// Perform the same error handling twice for two different functions.
	//	0 = check for an existing mapping
	//	1 = attempt to create a new mapping
	//
#ifdef DPNBUILD_NOLOCALNAT
	for(dwTemp = 1; dwTemp < 2; dwTemp++)
#else // ! DPNBUILD_NOLOCALNAT
	for(dwTemp = 0; dwTemp < 2; dwTemp++)
#endif // ! DPNBUILD_NOLOCALNAT
	{
		if (dwTemp == 0)
		{
#ifdef DPNBUILD_NOLOCALNAT
			DNASSERT( FALSE );
#else // ! DPNBUILD_NOLOCALNAT
			//
			// Make sure we're not slipping under an existing Internet gateway mapping.
			// We have to do this because the current Windows NAT implementations do
			// not mark the port as "in use", so if you bound to a port on the public
			// adapter that had a mapping, you'd never receive any data.  It would all
			// be forwarded according to the mapping.
			//
			hr = CheckForOverridingMapping( pBoundSocketAddress );
#endif // ! DPNBUILD_NOLOCALNAT
		}
		else
		{
			//
			// Attempt to bind to an Internet gateway.
			//
			hr = BindToInternetGateway( pBoundSocketAddress, GatewayBindType );
		}
		
		switch (hr)
		{
			case DPN_OK:
			{
				//
				// 0 = there's no existing mapping that would override our socket
				// 1 = mapping on Internet gateway (if any) was successful
				//
				break;
			}
			
			case DPNERR_ALREADYINITIALIZED:
			{
				//
				// 0 = there's an existing mapping that would override our socket
				// 1 = Internet gateway already had a conflicting mapping
				//
				// If we can, try binding to a different port.  Otherwise we have to fail.
				//
				if (GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT)
				{
					DPFX(DPFPREP, 1, "%s address already in use on Internet gateway (port = %u), rebinding.",
						((dwTemp == 0) ? _T("Private") : _T("Public")),
						NTOHS(pBoundSocketAddress->GetPort()));


					//
					// Whether we succeed in unbinding or not, don't consider this bound anymore.
					//
					DNASSERT( m_State == SOCKET_PORT_STATE_BOUND );
					m_State = SOCKET_PORT_STATE_INITIALIZED;
					
					hr = UnbindFromNetwork();
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't unbind network socket address 0x%p from network before rebind attempt!",
							this );
						goto Failure;
					}


					//
					// Move to the next port and try again.
					//
					wBasePort = NTOHS(pBoundSocketAddress->GetPort()) + 1;
					
					//
					// If we weren't in the DPlay range, then we must have gone through all
					// of the DPlay range, plus let WinSock pick at least once.  Since we can't
					// trust WinSock to not keep picking the same port, we need to manually
					// increase the port number.
					//
#pragma TODO(vanceo, "Don't limit ICS machines to only half the ports in the range")
#ifdef DPNBUILD_NOREGISTRY
					if ((NTOHS(pBoundSocketAddress->GetPort()) < BASE_DPLAY8_PORT) || (NTOHS(pBoundSocketAddress->GetPort()) > MAX_DPLAY8_PORT))
#else // ! DPNBUILD_NOREGISTRY
					if ((NTOHS(pBoundSocketAddress->GetPort()) < g_wBaseDPlayPort) || (NTOHS(pBoundSocketAddress->GetPort()) > g_wMaxDPlayPort))
#endif // ! DPNBUILD_NOREGISTRY
					{
						//
						// If we just walked back into the DPlay range, skip over it.
						//
#ifdef DPNBUILD_NOREGISTRY
						if ((wBasePort >= BASE_DPLAY8_PORT) && (wBasePort <= MAX_DPLAY8_PORT))
						{
							wBasePort = MAX_DPLAY8_PORT + 1;
						}
#else // ! DPNBUILD_NOREGISTRY
						if ((wBasePort >= g_wBaseDPlayPort) && (wBasePort <= g_wMaxDPlayPort))
						{
							wBasePort = g_wMaxDPlayPort + 1;
						}
#endif // ! DPNBUILD_NOREGISTRY

						//
						// If we have wrapped all the way back to 0 (!) then fail, to prevent
						// infinite looping.
						//
						if (wBasePort == 0)
						{
							DPFX(DPFPREP, 0, "Managed to fail binding socket address 0x%p to every port, aborting!",
								this );
							hr = DPNERR_ALREADYINITIALIZED;
							goto Failure;
						}
						
						//
						// Force the "fixed port" code path in BindToNextAvailablePort, even
						// though it isn't really fixed.
						//
	 					DPFX(DPFPREP, 5, "Forcing port %u.", wBasePort );
						m_pNetworkSocketAddress->SetPort(HTONS(wBasePort));
					}

					
					//
					// Return the previous address and try again.
					//
					g_SocketAddressPool.Release( pBoundSocketAddress );
					pBoundSocketAddress = NULL;

					
					goto RebindToNextPort;
				}

				DPFX(DPFPREP, 0, "%s address already in use on Internet gateway (port = %u)!",
					((dwTemp == 0) ? _T("Private") : _T("Public")),
					NTOHS(pBoundSocketAddress->GetPort()));
				goto Failure;
				break;
			}
			
			case DPNERR_UNSUPPORTED:
			{
				//
				// 0 & 1 = NATHelp not loaded or isn't supported for SP
				//
				if (dwTemp == 0)
				{
					DPFX(DPFPREP, 2, "Not able to find existing private mapping for socketport 0x%p on local Internet gateway, unsupported/not necessary.",
						this);
				}
				else
				{
					DPFX(DPFPREP, 2, "Didn't bind socketport 0x%p to Internet gateway, unsupported/not necessary.",
						this);
				}
				
				//
				// Ignore the error.
				//
				break;
			}
			
			default:
			{
				//
				// 0 & 1 = ?
				//
				if (dwTemp == 0)
				{
					DPFX(DPFPREP, 1, "Unable to look for existing private mapping for socketport 0x%p on local Internet gateway (error = 0x%lx), ignoring.",
						this, hr);
				}
				else
				{
					DPFX(DPFPREP, 1, "Unable to bind socketport 0x%p to Internet gateway (error = 0x%lx), ignoring.",
						this, hr);
				}
				
				//
				// Ignore the error, we can survive without the mapping.
				//
				break;
			}
		}

		//
		// Go to the next function to be handled in this manner.
		//
	}
#endif // ! DPNBUILD_NONATHELP


	//
	// Save the address we actually ended up with.
	//
	g_SocketAddressPool.Release( m_pNetworkSocketAddress );
	m_pNetworkSocketAddress = pBoundSocketAddress;
	pBoundSocketAddress = NULL;


#ifndef DPNBUILD_NOMULTICAST
	//
	// If IP, set socket option that makes broadcasts go out the device we
	// intended instead of the primary device.  Failing this is not fatal, it only
	// applies to multihomed machines with devices on different networks, and
	// might already work the way the user wants.
	//
	// We do this here because we want the socket to be bound so we can
	// use its address for the setsockopt call.
	//
#ifndef DPNBUILD_NOIPX
	if (m_pNetworkSocketAddress->GetFamily() == AF_INET)
#endif // ! DPNBUILD_NOIPX
	{
		int				iSocketOption;
		SOCKADDR_IN *	psaddrin;


		//
		// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
		// make sure we use the proper constant.
		//

#ifdef DPNBUILD_ONLYWINSOCK2
		iSocketOption = 9;
#else // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NOWINSOCK2
		switch ( GetWinsockVersion() )
		{
			//
			// Winsock1, use the IP_MULTICAST_IF value for Winsock1
			// see WINSOCK.H
			//
			case 1:
			{
#endif // ! DPNBUILD_NOWINSOCK2
				iSocketOption = 2;
#ifndef DPNBUILD_NOWINSOCK2
				break;
			}

			//
			// Winsock2, or greater, use the IP_MULTICAST_IF value for Winsock2
			// see WS2TCPIP.H
			//
			case 2:
			default:
			{
				DNASSERT( GetWinsockVersion() == 2 );
				iSocketOption = 9;
				break;
			}
		}
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2

		psaddrin = (SOCKADDR_IN*) m_pNetworkSocketAddress->GetWritableAddress();

		DPFX(DPFPREP, 9, "Setting IP_MULTICAST_IF option (%i).", iSocketOption);

		iReturnValue = setsockopt( GetSocket(),
									 IPPROTO_IP,
									 iSocketOption,
									 reinterpret_cast<char*>( &psaddrin->sin_addr ),
									 sizeof( psaddrin->sin_addr )
									 );
		if ( iReturnValue == SOCKET_ERROR )
		{
			dwErrorCode = WSAGetLastError();
			DPFX(DPFPREP, 0, "Failed to set the multicast interface socket option (err = %u)!", dwErrorCode );
			DisplayWinsockError( 0, dwErrorCode );
		}
	}
#endif // ! DPNBUILD_NOMULTICAST


	//
	// Generate a unique socketport ID.  Start with the current time and
	// combine in the address.
	//
	m_dwSocketPortID = GETTIMESTAMP();
	pdwAddressChunk = (DWORD*) m_pNetworkSocketAddress->GetAddress();
	pdwLastAddressChunk = (DWORD*) (((BYTE*) pdwAddressChunk) + m_pNetworkSocketAddress->GetAddressSize() - sizeof(DWORD));
	while (pdwAddressChunk <= pdwLastAddressChunk)
	{
		m_dwSocketPortID ^= (*pdwAddressChunk);
		pdwAddressChunk++;
	}


#ifndef _XBOX
#ifndef DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_NOIPX
	if (m_pNetworkSocketAddress->GetFamily() == AF_IPX)
	{
		//
		// IPX, don't worry about proxies.
		//
	}
	else
#endif // ! DPNBUILD_NOIPX
	{
		//
		// Detect whether this socket has WinSock Proxy Client a.k.a. ISA Firewall
		// Client installed (unless the user turned auto-detection off in the
		// registry).  We do this by looking at the name of the protocol that got
		// bound to the socket.  If it contains "Proxy", consider it proxied.
		//
		// Ignore failure (WinSock 1 probably doesn't have this socket option), and
		// assume the proxy client isn't installed.
		//
#ifndef DPNBUILD_NOREGISTRY
		if (! g_fDontAutoDetectProxyLSP)
#endif // ! DPNBUILD_NOREGISTRY
		{
#ifndef DPNBUILD_ONLYWINSOCK2
			if (GetWinsockVersion() != 2)
			{
				//
				// WinSock 1 doesn't have the required entry point.
				//
				DPFX(DPFPREP, 1, "Unable to auto-detect proxy client on WinSock 1, assuming not present.");
			}
			else
#endif // ! DPNBUILD_ONLYWINSOCK2
			{
				int					aiProtocols[2];
				WSAPROTOCOL_INFO *	pwsapi;
				DWORD				dwBufferSize;
				int					i;
#ifdef DBG
#ifdef UNICODE
				WCHAR				wszProtocol[WSAPROTOCOL_LEN+1];
#else // ! UNICODE
				char					szProtocol[WSAPROTOCOL_LEN+1];
#endif // ! UNICODE
#endif // DBG


				aiProtocols[0] = IPPROTO_UDP;
				aiProtocols[1] = 0;

				pwsapi = NULL;
				dwBufferSize = 0;

				//
				// Keep trying to get the list of protocols until we get no error or some
				// error other than WSAENOBUFS.
				//
				do
				{
#ifdef UNICODE
					iReturnValue = p_WSAEnumProtocolsW(aiProtocols, pwsapi, &dwBufferSize);
#else // ! UNICODE
					iReturnValue = p_WSAEnumProtocolsA(aiProtocols, pwsapi, &dwBufferSize);
#endif // ! UNICODE
					if (iReturnValue != SOCKET_ERROR)
					{
						//
						// We succeeded, drop out of the loop.
						//
						break;
					}

					dwErrorCode = WSAGetLastError();
					if (dwErrorCode != WSAENOBUFS)
					{
						DPFX(DPFPREP, 0, "Unable to enumerate protocols (error = 0x%lx)!  Continuing.",
							dwErrorCode);
						DisplayWinsockError(0, dwErrorCode);
						iReturnValue = 0;
						break;
					}

					//
					// We need more space.  Make sure the size is valid.
					//
					if (dwBufferSize < sizeof(WSAPROTOCOL_INFO))
					{
						DPFX(DPFPREP, 0, "Enumerating protocols didn't return any items (%u < %u)!  Continuing",
							dwBufferSize, sizeof(WSAPROTOCOL_INFO));
						iReturnValue = 0;
						break;
					}

					//
					// If we previously had a buffer, free it.
					//
					if (pwsapi != NULL)
					{
						DNFree(pwsapi);
					}

					//
					// Allocate the buffer.
					//
					pwsapi = (WSAPROTOCOL_INFO*) DNMalloc(dwBufferSize);
					if (pwsapi == NULL)
					{
						DPFX(DPFPREP, 0, "Unable to allocate memory for protocol list!  Continuing.");
						iReturnValue = 0;
						break;
					}
				}
				while (TRUE);


				//
				// If we read a valid buffer, parse it.
				//
				if ((iReturnValue > 0) &&
					(dwBufferSize >= (sizeof(WSAPROTOCOL_INFO) * iReturnValue)))
				{
					//
					// Loop through all the UDP protocols installed.
					//
					for(i = 0; i < iReturnValue; i++)
					{
						//
						// See if the name contains "Proxy", case insensitive.
						// Save the original string in debug so we can print it.
						//
#ifdef UNICODE
#ifdef DBG
						wcsncpy(wszProtocol, pwsapi[i].szProtocol, WSAPROTOCOL_LEN);
						wszProtocol[WSAPROTOCOL_LEN] = 0;	// ensure it's NULL terminated
#endif // DBG
						_wcslwr(pwsapi[i].szProtocol);
						if (wcsstr(pwsapi[i].szProtocol, L"proxy") != NULL)
						{
							DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) appears to be using proxy client (protocol %i = \"%ls\").",
								this, m_dwSocketPortID, i, wszProtocol);
							m_fUsingProxyWinSockLSP = TRUE;

							//
							// Stop searching.
							//
							break;
						}

						
						DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) protocol %i (\"%ls\") does not contain \"proxy\".",
							this, m_dwSocketPortID, i, wszProtocol);
#else // ! UNICODE
#ifdef DBG
						strncpy(szProtocol, pwsapi[i].szProtocol, WSAPROTOCOL_LEN);
						szProtocol[WSAPROTOCOL_LEN] = 0;	// ensure it's NULL terminated
#endif // DBG
						_strlwr(pwsapi[i].szProtocol);
						if (strstr(pwsapi[i].szProtocol, "proxy") != NULL)
						{
							DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) appears to be using proxy client (protocol %i = \"%hs\").",
								this, m_dwSocketPortID, i, szProtocol);
							m_fUsingProxyWinSockLSP = TRUE;

							//
							// Stop searching.
							//
							break;
						}

						
						DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) protocol %i (\"%hs\") does not contain \"proxy\".",
							this, m_dwSocketPortID, i, szProtocol);
#endif // ! UNICODE
					} // end for (each returned protocol)
				}
				else
				{
					DPFX(DPFPREP, 1, "Couldn't enumerate UDP protocols for socketport 0x%p ID 0x%x, assuming not using proxy client (return = %i, size = %u).",
						this, m_dwSocketPortID, iReturnValue, dwBufferSize);
				}

				if (pwsapi != NULL)
				{
					DNFree(pwsapi);
				}
			} // end else (Winsock 2)
		}
#ifndef DPNBUILD_NOREGISTRY
		else
		{
			DPFX(DPFPREP, 5, "Not auto-detecting whether socketport 0x%p (ID 0x%x) is using proxy client.",
				this, m_dwSocketPortID);
		}
#endif // ! DPNBUILD_NOREGISTRY
	}
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! _XBOX


	//
	// start processing input messages
	// It's possible that messages will arrive before an endpoint is officially
	// bound to this socket port, but that's not a problem, the contents will
	// be lost
	//
	hr = StartReceiving();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem starting endpoint receiving!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( m_State == SOCKET_PORT_STATE_BOUND );

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem in CSocketPort::BindToNetwork()" );
		DisplayDNError( 0, hr );
	}

	if ( pBoundSocketAddress != NULL )
	{
		g_SocketAddressPool.Release( pBoundSocketAddress );
		pBoundSocketAddress = NULL;
	}

	DPFX(DPFPREP, 7, "(0x%p) Returning [0x%lx]", this, hr );

	return hr;

Failure:
	DEBUG_ONLY( m_fInitialized = FALSE );
	if ( m_State == SOCKET_PORT_STATE_BOUND )
	{
		UnbindFromNetwork();
		m_State = SOCKET_PORT_STATE_INITIALIZED;
	}
	else
	{
		DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
		
		//
		// If we were bound to network, m_Socket will be reset to
		// INVALID_SOCKET.
		// Otherwise, we will take care of this ourselves (!)
		//
		if ( m_Socket != INVALID_SOCKET )
		{
			DPFX(DPFPREP, 5, "Closing socketport 0x%p socket 0x%p.", this, m_Socket);
			
			iReturnValue = closesocket( m_Socket );
			if ( iReturnValue == SOCKET_ERROR )
			{
				dwErrorCode = WSAGetLastError();
				DPFX(DPFPREP, 0, "Problem closing socket!" );
				DisplayWinsockError( 0, dwErrorCode );
			}
			m_Socket = INVALID_SOCKET;
		}
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::UnbindFromNetwork - unbind this socket port from the network
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	It is assumed that this socket port's information is locked!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::UnbindFromNetwork"

HRESULT	CSocketPort::UnbindFromNetwork( void )
{
	INT			iWSAReturn;
	SOCKET		TempSocket;
	DWORD		dwErrorCode;
#ifndef DPNBUILD_NONATHELP
	DWORD		dwTemp;
#endif // DPNBUILD_NONATHELP


	DPFX(DPFPREP, 7, "(0x%p) Enter", this );


	TempSocket = GetSocket();
	m_Socket = INVALID_SOCKET;
	DNASSERT( TempSocket != INVALID_SOCKET );

	iWSAReturn = shutdown( TempSocket, 0 );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		dwErrorCode = WSAGetLastError();
		DPFX(DPFPREP, 0, "Problem shutting down socket!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

	DPFX(DPFPREP, 5, "Closing socketport 0x%p socket 0x%p.", this, TempSocket);

	iWSAReturn = closesocket( TempSocket );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		dwErrorCode = WSAGetLastError();
		DPFX(DPFPREP, 0, "Problem closing socket!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

#ifndef DPNBUILD_NONATHELP
	//
	// Unbind with all DirectPlayNATHelp instances.
	//
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		if ( m_ahNATHelpPorts[dwTemp] != NULL )
		{
			DNASSERT( m_pThreadPool != NULL );
			DNASSERT( m_pThreadPool->IsNATHelpLoaded() );

			//
			// Ignore error.
			//
			IDirectPlayNATHelp_DeregisterPorts( g_papNATHelpObjects[dwTemp], m_ahNATHelpPorts[dwTemp], 0 );
			m_ahNATHelpPorts[dwTemp] = NULL;
		}
	}
#endif // DPNBUILD_NONATHELP

#ifndef DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_ONLYWINSOCK2
	if (
		(GetWinsockVersion() == 2) 
#ifndef DPNBUILD_NOIPX
		&& ( m_pNetworkSocketAddress->GetFamily() != AF_IPX )
#endif // ! DPNBUILD_NOIPX
		)
#endif // ! DPNBUILD_ONLYWINSOCK2
	{
		HRESULT		hr;


#ifdef DPNBUILD_ONLYONEPROCESSOR
		hr = IDirectPlay8ThreadPoolWork_StopTrackingFileIo(m_pThreadPool->GetDPThreadPoolWork(),
															0,
															(HANDLE) TempSocket,
															0);
#else // ! DPNBUILD_ONLYONEPROCESSOR
		hr = IDirectPlay8ThreadPoolWork_StopTrackingFileIo(m_pThreadPool->GetDPThreadPoolWork(),
															m_dwCPU,
															(HANDLE) TempSocket,
															0);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't stop tracking socket 0x%p I/O (err = 0x%lx)!  Ignoring.",
				TempSocket, hr);
		}
	}
#endif // ! DPNBUILD_NOWINSOCK2

	DPFX(DPFPREP, 7, "(0x%p) Returning [DPN_OK]", this );
	
	return	DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindToNextAvailablePort - bind to next available port
//
// Entry:		Pointer adapter address to bind to
//				Base port to try assigning.
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToNextAvailablePort"

HRESULT	CSocketPort::BindToNextAvailablePort( const CSocketAddress *const pNetworkAddress,
												const WORD wBasePort) const
{
	HRESULT				hr;
	INT					iSocketReturn;
	CSocketAddress *	pDuplicateNetworkAddress;
#ifdef _XBOX
	SOCKADDR_IN *		psaddrin;
#endif // _XBOX

	
	DNASSERT( pNetworkAddress != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	
	pDuplicateNetworkAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pNetworkAddress->GetFamily()));
	if ( pDuplicateNetworkAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get address for walking DPlay port range!" );
		goto Failure;
	}

	pDuplicateNetworkAddress->CopyAddressSettings( pNetworkAddress );

#ifdef _XBOX
	//
	// Xbox doesn't want you to bind to anything other than INADDR_ANY
	// so in case we discovered our IP address, force it 0.0.0.0 at bind time.
	//
	psaddrin = (SOCKADDR_IN*) pDuplicateNetworkAddress->GetWritableAddress();
	DNASSERT(psaddrin->sin_family == AF_INET);
	psaddrin->sin_addr.S_un.S_addr = INADDR_ANY;	
#endif // _XBOX


	//
	// If a port was specified, try to bind to that port.  If no port was
	// specified, start walking the reserved DPlay port range looking for an
	// available port.  If none is found, let Winsock choose the port.
	//
	if ( pNetworkAddress->GetPort() != ANY_PORT )
	{
		iSocketReturn = bind( GetSocket(),
								pDuplicateNetworkAddress->GetAddress(),
								pDuplicateNetworkAddress->GetAddressSize()
								);
		if ( iSocketReturn == SOCKET_ERROR )
		{
			DWORD	dwErrorCode;


			hr = DPNERR_ALREADYINITIALIZED;
			dwErrorCode = WSAGetLastError();
			DPFX(DPFPREP, 0, "Failed to bind socket to fixed port!" );
			DumpSocketAddress(0, pDuplicateNetworkAddress->GetAddress(), pDuplicateNetworkAddress->GetFamily() );
			DisplayWinsockError( 0, dwErrorCode );
			goto Failure;
		}
	}
	else
	{
		WORD	wPort;
		BOOL	fBound;


		wPort = wBasePort;
		fBound = FALSE;

		//
		// Try picking the next port in the DPlay range.
		//
#ifdef DPNBUILD_NOREGISTRY
		while ( ( wPort >= BASE_DPLAY8_PORT ) && ( wPort <= MAX_DPLAY8_PORT ) && ( fBound == FALSE ) )
#else // ! DPNBUILD_NOREGISTRY
		while ( ( wPort >= g_wBaseDPlayPort ) && ( wPort <= g_wMaxDPlayPort ) && ( fBound == FALSE ) )
#endif // ! DPNBUILD_NOREGISTRY
		{
			pDuplicateNetworkAddress->SetPort( HTONS( wPort ) );
			iSocketReturn = bind( GetSocket(),
									pDuplicateNetworkAddress->GetAddress(),
									pDuplicateNetworkAddress->GetAddressSize()
									);
			if ( iSocketReturn == SOCKET_ERROR )
			{
				DWORD	dwErrorCode;


				dwErrorCode = WSAGetLastError();
				switch ( dwErrorCode )
				{
					case WSAEADDRINUSE:
					{
						DPFX(DPFPREP, 8, "Port %u in use, skipping to next port.", wPort );
						break;
					}

					default:
					{
						hr = DPNERR_NOCONNECTION;
						DPFX(DPFPREP, 0, "Failed to bind socket to port in DPlay range!" );
						DumpSocketAddress(0, pDuplicateNetworkAddress->GetAddress(), pDuplicateNetworkAddress->GetFamily() );
						DisplayWinsockError( 0, dwErrorCode );
						goto Failure;
						
						break;
					}
				}
			}
			else
			{
				DNASSERT( hr == DPN_OK );
				fBound = TRUE;
			}

			wPort++;
		}
	
		//
		// For some reason, all of the default DPlay ports were in use, let
		// Winsock choose.  We can use the network address passed because it
		// has 'ANY_PORT'.
		//
		if ( fBound == FALSE )
		{
			DNASSERT( pNetworkAddress->GetPort() == ANY_PORT );
			iSocketReturn = bind( GetSocket(),
									pNetworkAddress->GetAddress(),
									pNetworkAddress->GetAddressSize()
									);
			if ( iSocketReturn == SOCKET_ERROR )
			{
				DWORD	dwErrorCode;


				hr = DPNERR_NOCONNECTION;
				dwErrorCode = WSAGetLastError();
				DPFX(DPFPREP, 0, "Failed to bind socket (any port)!" );
				DumpSocketAddress(0, pNetworkAddress->GetAddress(), pNetworkAddress->GetFamily() );
				DisplayWinsockError( 0, dwErrorCode );
				goto Failure;
			}
		}
	}

Exit:
	if ( pDuplicateNetworkAddress != NULL )
	{
		g_SocketAddressPool.Release( pDuplicateNetworkAddress );
		pDuplicateNetworkAddress = NULL;
	}

	return	hr;

Failure:
	
	goto Exit;
}
//**********************************************************************


#ifndef DPNBUILD_NONATHELP

#ifndef DPNBUILD_NOLOCALNAT

//**********************************************************************
// ------------------------------
// CSocketPort::CheckForOverridingMapping - looks for an existing mapping if there's a local NAT
//
// Entry:		Pointer to SocketAddress to query
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::CheckForOverridingMapping"

HRESULT	CSocketPort::CheckForOverridingMapping( const CSocketAddress *const pBoundSocketAddress )
{
	HRESULT		hr;
	DWORD		dwTemp;
	SOCKADDR	saddrSource;
	SOCKADDR	saddrPublic;


	DNASSERT( pBoundSocketAddress != NULL );
	DNASSERT( GetAdapterEntry() != NULL );
	DNASSERT( m_pThreadPool != NULL );

	
	if ((pBoundSocketAddress->GetFamily() != AF_INET) ||
		( ! m_pThreadPool->IsNATHelpLoaded() ) ||
		( GetUserTraversalMode() == DPNA_TRAVERSALMODE_NONE ))
	{
		//
		// We skipped initializing NAT Help, it failed starting up, or this is just
		// not an IP socket.
		//
		hr = DPNERR_UNSUPPORTED;
		goto Exit;
	}


	//
	// Query using INADDR_ANY.  This will ensure that the best device is picked
	// (i.e. the private interface on a NAT, whose public mappings matter when
	// we're looking for overriding mappings on the public adapter).
	// Alternatively, we could query on every device, but this should do the trick.
	//
	ZeroMemory(&saddrSource, sizeof(saddrSource));
	saddrSource.sa_family				= AF_INET;
	//saddrinSource.sin_addr.S_un.S_addr	= INADDR_ANY;
	//saddrinSource.sin_port				= 0;
	

	//
	// Query all DirectPlayNATHelp instances for the port.  We might break
	// out of the loop if we detect a gateway mapping.
	//
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT(m_ahNATHelpPorts[dwTemp] == NULL);

		if ( g_papNATHelpObjects[dwTemp] != NULL )
		{
			hr = IDirectPlayNATHelp_QueryAddress( g_papNATHelpObjects[dwTemp],
												&saddrSource,
												pBoundSocketAddress->GetAddress(),
												&saddrPublic,
												sizeof (saddrPublic),
												0 );
			switch ( hr )
			{
				case DPNH_OK:
				{
					//
					// Uh oh, this address is in use.
					//
					DPFX(DPFPREP, 0, "Private address already in use according to NAT Help object %u!", dwTemp );
					DumpSocketAddress( 0, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );
					DumpSocketAddress( 0, &saddrPublic, pBoundSocketAddress->GetFamily() );
					hr = DPNERR_ALREADYINITIALIZED;
					goto Exit;
					break;
				}
				
				case DPNHERR_NOMAPPING:
				{
					//
					// It's not in use.
					//
					DPFX(DPFPREP, 8, "Private address not in use according to NAT Help object %u.", dwTemp );
					break;
				}
				
				case DPNHERR_SERVERNOTAVAILABLE:
				{
					//
					// There's no server.
					//
					DPFX(DPFPREP, 8, "Private address not in use because NAT Help object %u didn't detect any servers.",
						dwTemp );
					break;
				}
				
				default:
				{
					//
					// Something else.  Assume it's not in use.
					//
					DPFX(DPFPREP, 1, "NAT Help object %u failed private address lookup (err = 0x%lx), assuming not in use.",
						dwTemp, hr );
					break;
				}
			}
		}
		else
		{
			//
			// No NAT Help object.
			//
		}
	}


	//
	// If we're here, no Internet gateways reported the port as in use.
	//
	DPFX(DPFPREP, 2, "No NAT Help object reported private address as in use." );
	hr = DPN_OK;


Exit:
	
	return	hr;
}
//**********************************************************************

#endif // ! DPNBUILD_NOLOCALNAT


//**********************************************************************
// ------------------------------
// CSocketPort::BindToInternetGateway - binds a socket to a NAT, if available
//
// Entry:		Pointer to SocketAddress we bound to
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToInternetGateway"

HRESULT	CSocketPort::BindToInternetGateway( const CSocketAddress *const pBoundSocketAddress,
										   const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT		hr;
	DWORD		dwTemp;
	DWORD		dwRegisterFlags;
	DWORD		dwAddressTypeFlags;
	BOOL		fUnavailable;
#ifdef DBG
	BOOL		fFirewallMapping;
#endif // DBG


	DNASSERT( pBoundSocketAddress != NULL );
	DNASSERT( GetAdapterEntry() != NULL );
	DNASSERT( m_pThreadPool != NULL );

	
	if (
#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
		(pBoundSocketAddress->GetFamily() != AF_INET) ||
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
		( ! m_pThreadPool->IsNATHelpLoaded() ) ||
		( GetUserTraversalMode() == DPNA_TRAVERSALMODE_NONE ) )
	{
		//
		// We skipped initializing NAT Help, it failed starting up, or this is just
		// not an IP socket.
		//
		DPFX(DPFPREP, 5, "Not using NAT traversal, socket family = %u, NAT Help loaded = %i, traversal mode = %u.",
			pBoundSocketAddress->GetFamily(), m_pThreadPool->IsNATHelpLoaded(), GetUserTraversalMode());
		hr = DPNERR_UNSUPPORTED;
		goto Exit;
	}
	DNASSERT(m_pThreadPool->IsNATHelpLoaded());
	
	switch ( GatewayBindType )
	{
		//
		// just ask the server to open a generic port for us (connect, listen, enum)
		//
		case GATEWAY_BIND_TYPE_DEFAULT:
		{
			dwRegisterFlags = 0;
			break;
		}

		//
		// ask the NAT to open a fixed port for us (address is specified)
		//
		case GATEWAY_BIND_TYPE_SPECIFIC:
		{
			dwRegisterFlags = DPNHREGISTERPORTS_FIXEDPORTS;
			break;
		}

		//
		// ask the NAT to share the listen for us (this should be DPNSVR only)
		//
		case GATEWAY_BIND_TYPE_SPECIFIC_SHARED:
		{
			dwRegisterFlags = DPNHREGISTERPORTS_FIXEDPORTS | DPNHREGISTERPORTS_SHAREDPORTS;
			break;
		}

		//
		// no binding
		//
		case GATEWAY_BIND_TYPE_NONE:
		{
			DPFX(DPFPREP, 8, "Not binding socket address 0x%p to NAT because bind type is NONE.",
				pBoundSocketAddress);

			hr = DPNERR_UNSUPPORTED;
			goto Exit;
			break;
		}

		//
		// unknown condition, someone broke the code!
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}


RetryMapping:
	
	//
	// Detect whether any servers said the port was unavailable.
	//
	fUnavailable = FALSE;

#ifdef DBG
	fFirewallMapping = FALSE;
#endif // DBG


	//
	// Register the ports with all DirectPlayNATHelp instances.  We might break
	// out of the loop if we detect a gateway mapping.
	//
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT(m_ahNATHelpPorts[dwTemp] == NULL);

		if ( g_papNATHelpObjects[dwTemp] != NULL )
		{
			hr = IDirectPlayNATHelp_RegisterPorts( g_papNATHelpObjects[dwTemp],
												pBoundSocketAddress->GetAddress(),
												sizeof (SOCKADDR),
												1,
												NAT_LEASE_TIME,
												&m_ahNATHelpPorts[dwTemp],
												dwRegisterFlags );
			if ( hr != DPNH_OK )
			{
				DNASSERT(m_ahNATHelpPorts[dwTemp] == NULL);
				DPFX(DPFPREP, 0, "Failed to register port with NAT Help object %u!  Ignoring.", dwTemp );
				DumpSocketAddress( 0, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );
				DisplayDNError( 0, hr );
				hr = DPN_OK;
			}
			else
			{
				//
				// There might be an Internet gateway device already present.  If so,
				// then DPNATHelp already tried to register the port mapping with it, which
	 			// might have failed because the port is already in use.  If we're not
	  			// binding to a fixed port, then we could just pick a different port and try
	  			// again.  So check if there's a UPnP device but DPNATHelp couldn't map
	  			// the port and return that error to the caller so he can make the
	  			// decision to retry or not.
	  			//
	  			// IDirectPlayNATHelp::GetCaps had better have been called with the
	  			// DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to this.
	 			// See CThreadPool::EnsureNATHelpLoaded
				//
				hr = IDirectPlayNATHelp_GetRegisteredAddresses( g_papNATHelpObjects[dwTemp],	// object
																m_ahNATHelpPorts[dwTemp],		// port binding
																NULL,							// don't need address
																NULL,							// don't need address buffer size
																&dwAddressTypeFlags,			// get address type flags
																NULL,							// don't need lease time remaining
																0 );							// no flags
				switch (hr)
				{
					case DPNH_OK:
					{
						//
						// If this is a mapping on a gateway, then we're done.
						// We don't need to try to make any more NAT mappings.
						//
						if (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAY)
						{
							DPFX(DPFPREP, 4, "Address has already successfully been registered with gateway using object index %u (type flags = 0x%lx), not trying additional mappings.",
								dwTemp, dwAddressTypeFlags);
							goto Exit;
						}

						DNASSERT(dwAddressTypeFlags & DPNHADDRESSTYPE_LOCALFIREWALL);

						DPFX(DPFPREP, 4, "Address has already successfully been registered with firewall using object index %u (type flags = 0x%lx), looking for gateways.",
							dwTemp, dwAddressTypeFlags);
						
#ifdef DBG
						fFirewallMapping = TRUE;
#endif // DBG
					
						break;
					}

					case DPNHERR_NOMAPPING:
					{
						DPFX(DPFPREP, 4, "Address already registered with Internet gateway index %u, but it does not have a public address (type flags = 0x%lx).",
							dwTemp, dwAddressTypeFlags);


						//
						// It doesn't make any sense for a firewall not to have a
						// mapping.
						//
						DNASSERT(dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAY);
						DNASSERT(! (dwAddressTypeFlags & DPNHADDRESSTYPE_LOCALFIREWALL));


						//
						// Since it is a gateway (that might have a public address
						// at some point, we don't need to try to make any more
						// NAT mappings.
						//
						goto Exit;
						
						break;
					}

					case DPNHERR_PORTUNAVAILABLE:
					{
						DPFX(DPFPREP, 1, "Port is unavailable on Internet gateway device index %u (type flags = 0x%lx).",
							dwTemp, dwAddressTypeFlags);
						
						fUnavailable = TRUE;
						break;
					}

					case DPNHERR_SERVERNOTAVAILABLE:
					{
						DPFX(DPFPREP, 6, "No Internet gateway detected by object index %u at this time.", dwTemp);
						break;
					}

					default:
					{
						DPFX(DPFPREP, 1, "An error (0x%lx) occurred while getting registered address mapping (index %u)! Ignoring.",
							hr, dwTemp);
						break;
					}
				}
			}
		}
		else
		{
			//
			// No NAT Help object.
			//
		}
	}


	//
	// If we're here, no Internet gateways were detected, or if one was, the
	// mapping was already in use there.  If it's the latter, fail so our caller
	// can unbind locally and possibly try again.  Note that we are ignoring
	// firewall mappings, since it's assumed we can make those with pretty
	// much any port, so there's no point in hanging on to those mappings
	// if the NAT port is in use.
	//
	if (fUnavailable)
	{
		//
		// If the user wanted to try the fixed port first, but could handle
		// using a different port if the fixed port was in use, try again
		// without the FIXEDPORTS flag.
		//
		if ((dwRegisterFlags & DPNHREGISTERPORTS_FIXEDPORTS) &&
			(GetUserTraversalMode() == DPNA_TRAVERSALMODE_PORTRECOMMENDED))
		{
			DPFX(DPFPREP, 1, "At least one Internet gateway reported port as unavailable, trying a different port.");
			dwRegisterFlags &= ~DPNHREGISTERPORTS_FIXEDPORTS;
			goto RetryMapping;
		}
		
		DPFX(DPFPREP, 2, "At least one Internet gateway reported port as unavailable, failing.");
		hr = DPNERR_ALREADYINITIALIZED;
	}
	else
	{
#ifdef DBG
		if (fFirewallMapping)
		{
			DPFX(DPFPREP, 2, "No gateway mappings but there is at least one firewall mapping.");
		}
		else
		{
			DPFX(DPFPREP, 2, "No gateway or firewall mappings detected.");
		}
#endif // DBG
		hr = DPN_OK;
	}


Exit:
	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************

#endif // ! DPNBUILD_NONATHELP


//**********************************************************************
// ------------------------------
// CSocketPort::StartReceiving - start receiving data on this socket port
//
// Entry:		Handle of I/O completion port to bind to (NT old threadpool only)
//
// Exit:		Error code
//
// Notes:	There is no 'Failure' label in this function because failures need
//			to be cleaned up for each OS variant.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::StartReceiving"

HRESULT	CSocketPort::StartReceiving( void )
{
	HRESULT			hr;
#ifndef DPNBUILD_NOWINSOCK2
	DWORD			dwNumReceivesStarted = 0;
	DWORD			dwStartCPU;
	DWORD			dwEndCPU;
	DWORD			dwCPU;
#ifndef DPNBUILD_ONLYONETHREAD
	DWORD			dwReceiveNum;
	DWORD			dwThreadCount;
#endif // ! DPNBUILD_ONLYONETHREAD
#ifndef DPNBUILD_ONLYONEPROCESSOR
	SYSTEM_INFO		SystemInfo;


	GetSystemInfo(&SystemInfo);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#endif // ! DPNBUILD_NOWINSOCK2

	//
	// On Win9x, if this is an IPX socket and Winsock 2 is not available,
	// use the Winsock 1 non-overlapped I/O routines.
	//
	// CE without Winsock 2 has the same limitation.
	//
	// On NT, we can always use overlapped I/O.
	//
#ifndef DPNBUILD_ONLYWINSOCK2
#ifndef DPNBUILD_NOWINSOCK2
	if ( ( LOWORD( GetWinsockVersion() ) < 2 ) 
#ifndef DPNBUILD_NOIPX
		|| ( m_pNetworkSocketAddress->GetFamily() == AF_IPX )
#endif // ! DPNBUILD_NOIPX
		)
#endif // ! DPNBUILD_NOWINSOCK2
	{
		hr = m_pThreadPool->AddSocketPort( this );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to add to active socket list!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
#ifndef DPNBUILD_NOWINSOCK2
	else
#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2
#ifndef DPNBUILD_NOWINSOCK2
	{
#ifdef DPNBUILD_ONLYONEPROCESSOR
		dwStartCPU = 0;
		dwEndCPU = 1;
#else // ! DPNBUILD_ONLYONEPROCESSOR
		if (m_dwCPU == -1)
		{
			dwStartCPU = 0;
			dwEndCPU = SystemInfo.dwNumberOfProcessors;
		}
		else
		{
			dwStartCPU = m_dwCPU;
			dwEndCPU = dwStartCPU + 1;
		}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

		for(dwCPU = dwStartCPU; dwCPU < dwEndCPU; dwCPU++)
		{
			hr = IDirectPlay8ThreadPoolWork_StartTrackingFileIo(m_pThreadPool->GetDPThreadPoolWork(),
																dwCPU,
																(HANDLE) GetSocket(),
																0);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't start tracking file I/O on CPU %u!  Ignoring.", dwCPU);
				DisplayDNError(0, hr);
			}
			else
			{
#ifndef DPNBUILD_ONLYONETHREAD
				DNASSERT(! m_pThreadPool->IsThreadCountReductionAllowed());
				hr = IDirectPlay8ThreadPoolWork_GetThreadCount(m_pThreadPool->GetDPThreadPoolWork(),
																dwCPU,
																&dwThreadCount,
																0);
				DNASSERT((hr == DPN_OK) || (hr == DPNSUCCESS_PENDING));

				//
				// Always start at least one receive, even in DoWork mode.
				//
				if (dwThreadCount == 0)
				{
					dwThreadCount++;
				}

				for(dwReceiveNum = 0; dwReceiveNum < dwThreadCount; dwReceiveNum++)
#endif // ! DPNBUILD_ONLYONETHREAD
				{
#ifdef DPNBUILD_ONLYONEPROCESSOR
					hr = Winsock2Receive();
#else // ! DPNBUILD_ONLYONEPROCESSOR
					hr = Winsock2Receive(dwCPU);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't submit receive on CPU %u!  Ignoring.", dwCPU);
						DisplayDNError(0, hr);
						break;
					}

					dwNumReceivesStarted++;
				}
			}
		}

		if (dwNumReceivesStarted == 0)
		{
			DPFX(DPFPREP, 0, "Didn't start any receives!");
			hr = DPNERR_OUTOFMEMORY;
		}
		else
		{
			DPFX(DPFPREP, 5, "Started %u receives.", dwNumReceivesStarted);
			hr = DPN_OK;
		}
	}
#endif // ! DPNBUILD_NOWINSOCK2

#ifdef DPNBUILD_ONLYWINSOCK2
	return	hr;
#else // ! DPNBUILD_ONLYWINSOCK2
Exit:
	return	hr;

Failure:

	goto Exit;
#endif // ! DPNBUILD_ONLYWINSOCK2
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::GetBoundNetworkAddress - get the full network address that
//		this socket port was really bound to
//
// Entry:		Address type for bound address
//
// Exit:		Pointer to network address
//
// Note:	Since this function creates a local address to derive the network
//			address from, it needs to know what kind of address to derive.  This
//			address type is supplied as the function parameter.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::GetBoundNetworkAddress"

CSocketAddress	*CSocketPort::GetBoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const
{
	CSocketAddress			*pTempSocketAddress;
#ifdef DPNBUILD_NOIPV6
	SOCKADDR				BoundSocketAddress;
#else // ! DPNBUILD_NOIPV6
	SOCKADDR_STORAGE		BoundSocketAddress;
#endif // ! DPNBUILD_NOIPV6
	INT_PTR					iReturnValue;
	INT						iBoundSocketAddressSize;
#ifdef _XBOX
	SOCKADDR_IN *			psaddrinOriginal;
	SOCKADDR_IN *			psaddrinTemp;
#endif // _XBOX


	//
	// initialize
	//
	pTempSocketAddress = NULL;

	//
	// create addresses
	//
	pTempSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) m_pNetworkSocketAddress->GetFamily()));
	if ( pTempSocketAddress == NULL )
	{
		DPFX(DPFPREP, 0, "GetBoundNetworkAddress: Failed to create socket address!" );
		goto Failure;
	}

	//
	// find out what address we really bound to and reset the information for
	// this socket port
	//
	iBoundSocketAddressSize = pTempSocketAddress->GetAddressSize();
	DNASSERT(iBoundSocketAddressSize <= sizeof(BoundSocketAddress));
	iReturnValue = getsockname( GetSocket(), (SOCKADDR*) (&BoundSocketAddress), &iBoundSocketAddressSize );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = WSAGetLastError();
		DPFX(DPFPREP, 0, "GetBoundNetworkAddress: Failed to get local socket name after bind!" );
		DisplayWinsockError( 0, dwErrorCode );
		goto Failure;
	}
	pTempSocketAddress->SetAddressFromSOCKADDR( (SOCKADDR*) (&BoundSocketAddress), iBoundSocketAddressSize );
	DNASSERT( iBoundSocketAddressSize == pTempSocketAddress->GetAddressSize() );

#ifdef _XBOX
	//
	// On Xbox, we'll always be told we bound to 0.0.0.0, even though we might
	// have determined the real IP address.  Mash the original IP back in.
	//
	psaddrinOriginal = (SOCKADDR_IN*) m_pNetworkSocketAddress->GetWritableAddress();
	psaddrinTemp = (SOCKADDR_IN*) pTempSocketAddress->GetWritableAddress();

	psaddrinTemp->sin_addr.S_un.S_addr = psaddrinOriginal->sin_addr.S_un.S_addr;
#endif // _XBOX

	//
	// Since this address was created locally, we need to tell it what type of
	// address to export according to the input.
	//
	switch ( AddressType )
	{
		//
		//  known types
		//
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		case SP_ADDRESS_TYPE_DEVICE:
		case SP_ADDRESS_TYPE_HOST:
		case SP_ADDRESS_TYPE_READ_HOST:
#ifndef DPNBUILD_NOMULTICAST
		case SP_ADDRESS_TYPE_MULTICAST_GROUP:
#endif // ! DPNBUILD_NOMULTICAST
		{
			break;
		}

		//
		// if we're looking for a public address, we need to make sure that this
		// is not an undefined address.  If it is, don't return an address.
		// Otherwise, remap the address type to a 'host' address.
		//
		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		{
			if ( pTempSocketAddress->IsUndefinedHostAddress() != FALSE )
			{
				g_SocketAddressPool.Release( pTempSocketAddress );
				pTempSocketAddress = NULL;
			}

			break;
		}

		//
		// unknown address type, fix the code!
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}

	}

Exit:
	return	pTempSocketAddress;

Failure:
	
	if ( pTempSocketAddress != NULL )
	{
		g_SocketAddressPool.Release( pTempSocketAddress );
		pTempSocketAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::GetDP8BoundNetworkAddress - get the network address this machine
//		is bound to according to the input parameter.  If the requested address
//		for the public address and an Internet gateway are available, use the
//		public address.  If a public address is requested but is unavailable,
//		fall back to the bound network address for local host-style device
//		addresses.  If a public address is unavailable but we're explicitly
//		looking for a public address, return NULL.
//
// Entry:		Type of address to get (local adapter vs. host)
//
// Exit:		Pointer to network address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::GetDP8BoundNetworkAddress"

IDirectPlay8Address *CSocketPort::GetDP8BoundNetworkAddress( const SP_ADDRESS_TYPE AddressType,
#ifdef DPNBUILD_XNETSECURITY
																ULONGLONG * const pullKeyID,
#endif // DPNBUILD_XNETSECURITY
																const GATEWAY_BIND_TYPE GatewayBindType ) const
{
#if ((! defined(DPNBUILD_ONLYONEADAPTER)) || (! defined(DPNBUILD_ONLYONEPROCESSOR)) || (! defined(DPNBUILD_NONATHELP)))
	HRESULT					hr;
#endif // ! DPNBUILD_ONLYONEADAPTER or ! DPNBUILD_ONLYONEPROCESSOR or ! DPNBUILD_NONATHELP
	IDirectPlay8Address *	pAddress;
	CSocketAddress *		pTempAddress = NULL;

#if ((defined(DBG)) || (defined(DPNBUILD_XNETSECURITY)))
	SOCKADDR_IN *			psaddrin;
#endif // DBG or DPNBUILD_XNETSECURITY

#if ((defined(DBG)) && (! defined(DPNBUILD_NONATHELP)))
	DWORD					dwAddressTypeFlags;
#endif // DBG and ! DPNBUILD_NONATHELP

#ifndef DPNBUILD_NONATHELP
	SOCKADDR				saddr;
	DWORD					dwAddressSize;
	DWORD					dwTemp;
#endif // DPNBUILD_NONATHELP

	DPFX(DPFPREP, 8, "(0x%p) Parameters: (0x%i)", this, AddressType );

	//
	// initialize
	//
	pAddress = NULL;


	DNASSERT( m_pThreadPool != NULL );
	DNASSERT( m_pNetworkSocketAddress != NULL );

#ifdef DBG
	switch ( m_pNetworkSocketAddress->GetFamily() )
	{
		case AF_INET:
		{
			psaddrin = (SOCKADDR_IN *) m_pNetworkSocketAddress->GetAddress();
#ifndef DPNBUILD_ONLYONEADAPTER
			DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
#endif // ! DPNBUILD_ONLYONEADAPTER
			DNASSERT( psaddrin->sin_addr.S_un.S_addr != INADDR_BROADCAST );
			DNASSERT( psaddrin->sin_port != 0 );
			break;
		}
		
#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			break;
		}
#endif // ! DPNBUILD_NOIPX
		
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			DNASSERT (! IN6_IS_ADDR_UNSPECIFIED(&(((SOCKADDR_IN6*) m_pNetworkSocketAddress->GetAddress())->sin6_addr)));		
			DNASSERT( m_pNetworkSocketAddress->GetPort() != 0 );
			break;
		}
#endif // ! DPNBUILD_NOIPV6
		
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
#endif // DBG

	switch ( AddressType )
	{
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		case SP_ADDRESS_TYPE_DEVICE:
		{
#ifdef DPNBUILD_XNETSECURITY
			pAddress = m_pNetworkSocketAddress->DP8AddressFromSocketAddress( pullKeyID, NULL, AddressType );
#else // ! DPNBUILD_XNETSECURITY
			pAddress = m_pNetworkSocketAddress->DP8AddressFromSocketAddress( AddressType );
#endif // ! DPNBUILD_XNETSECURITY
			if (pAddress == NULL)
			{
				break;
			}


			//
			// We hand up the exact device address we ended up using for this adapter.
			// 
#ifndef DPNBUILD_ONLYONEADAPTER
			//
			// Special case where any port will do:
			// In multi-adapter systems, our user is probably going to switch in a different
			// device GUID and pass it back down for another connect attempt (because
			// we told them we support ALL_ADAPTERS).  This can pose a problem since
			// we include the specific port in this address.  If the port was available on this
			// adapter but not on others.  The other attempts will fail.  This can also cause
			// problems when indicating the device with enum responses.  If the application
			// allowed us to select a local port, enumerated and got a response, shutdown
			// the interface (or just the enum), then connected with the device address, we
			// would try to use that port again, even though it may now be in use by
			// another local application (or more likely, on the NAT).
			// 
			// We are not required to use the same port on all adapters if the caller did
			// not choose a specific port in the first place, so there's no reason why we
			// couldn't try a different one.
			//
			// We know whether the port was specified or not, because GatewayBindType
			// will be GATEWAY_BIND_TYPE_DEFAULT if the port can float, _SPECIFIC or
			// _SPECIFIC_SHARED if not.
			//
			// So we can add a special key to the device address indicating that while it
			// does contain a port, don't take that too seriously.  That way, if this device
			// address is reused, we can detect the special key and handle port-in-use
			// problems gracefully by trying a different one.
			//
			// This special key is not documented and should not be used by anyone but
			// us.  We'll use the socketport ID as the value so that it's seemingly random,
 			// just to try to scare anyone off from mimicking it in addresses they generate.
 			// But we're not going to actually use the value.  If the component is present
 			// and the value is the right size, we'll use it.  If someone puts this into an
 			// address on their own, they get what they deserve (not like this will cause
 			// us to blow up or anything)...
 			//
 			// Look in CSPData::BindEndpoint for where this gets read back in.
			//

			if (( AddressType == SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT ) &&
				( GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT ))
			{
				//
				// Add the component, but ignore failure, we can still survive without it.
				//
				hr = IDirectPlay8Address_AddComponent( pAddress,							// interface
														DPNA_PRIVATEKEY_PORT_NOT_SPECIFIC,	// tag
														&(m_dwSocketPortID),				// component data
														sizeof(m_dwSocketPortID),			// component data size
														DPNA_DATATYPE_DWORD					// component data type
														);
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Couldn't add private port-not-specific component (err = 0x%lx)!  Ignoring.", hr);
					//hr = DPN_OK;
				}
			}
#endif // ! DPNBUILD_ONLYONEADAPTER


#ifndef DPNBUILD_NONATHELP
			//
			// Add the traversal mode component, but ignore failure, we can still
			// survive without it.
			//
			hr = IDirectPlay8Address_AddComponent( pAddress,							// interface
													DPNA_KEY_TRAVERSALMODE,		// tag
													&(m_dwUserTraversalMode),			// component data
													sizeof(m_dwUserTraversalMode),		// component data size
													DPNA_DATATYPE_DWORD			// component data type
													);
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Couldn't add traversal mode component (err = 0x%lx)!  Ignoring.", hr);
				//hr = DPN_OK;
			}
#endif // ! DPNBUILD_NONATHELP


#ifndef DPNBUILD_ONLYONEPROCESSOR
			//
			// If we're using a specific CPU, add that information.
			//
			if ( m_dwCPU != -1 )
			{
				//
				// Add the component, but ignore failure, we can still survive without it.
				//
				hr = IDirectPlay8Address_AddComponent( pAddress,				// interface
														DPNA_KEY_PROCESSOR,		// tag
														&(m_dwCPU),				// component data
														sizeof(m_dwCPU),		// component data size
														DPNA_DATATYPE_DWORD		// component data type
														);
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Couldn't add processor component (err = 0x%lx)!  Ignoring.", hr);
					//hr = DPN_OK;
				}
			}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			break;
		}

		case SP_ADDRESS_TYPE_HOST:
		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		{
#ifndef DPNBUILD_NONATHELP
			//
			// Try to get the public address, if we have one.
			//
			if ( ( m_pNetworkSocketAddress->GetFamily() == AF_INET ) &&
				( m_pThreadPool->IsNATHelpLoaded() ) &&
				( GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE ) )		
			{
				pTempAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) m_pNetworkSocketAddress->GetFamily()));
				if ( pTempAddress != NULL)
				{
			  		//
				  	// IDirectPlayNATHelp::GetCaps had better have been called with the
			  		// DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to this.
			  		// See CThreadPool::EnsureNATHelpLoaded
			  		//
			  		
					for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
					{
						if (g_papNATHelpObjects[dwTemp] != NULL)
						{
							dwAddressSize = sizeof(saddr);
#ifdef DBG
							hr = IDirectPlayNATHelp_GetRegisteredAddresses( g_papNATHelpObjects[dwTemp],	// object
																			m_ahNATHelpPorts[dwTemp],		// port binding
																			&saddr,							// place to store address
																			&dwAddressSize,					// address buffer size
																			&dwAddressTypeFlags,			// get type flags for printing in debug
																			NULL,							// don't need lease time remaining
																			0 );							// no flags
#else
							hr = IDirectPlayNATHelp_GetRegisteredAddresses( g_papNATHelpObjects[dwTemp],	// object
																			m_ahNATHelpPorts[dwTemp],		// port binding
																			&saddr,							// place to store address
																			&dwAddressSize,					// address buffer size
																			NULL,							// don't bother getting type flags in retail
																			NULL,							// don't need lease time remaining
																			0 );							// no flags
#endif // DBG
							if (hr == DPNH_OK)
							{
								pTempAddress->SetAddressFromSOCKADDR( &saddr, sizeof(saddr) );

								DPFX(DPFPREP, 2, "Internet gateway index %u currently maps address (type flags = 0x%lx):",
									dwTemp, dwAddressTypeFlags);
								DumpSocketAddress( 2, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
								DumpSocketAddress( 2, pTempAddress->GetAddress(), pTempAddress->GetFamily() );

								//
								// Double check that the address we got was valid.
								//
								DNASSERT( ((SOCKADDR_IN*) (&saddr))->sin_addr.S_un.S_addr != 0 );

								//
								// Get out of the loop since we have a mapping.
								//
								break;
							}


#ifdef DBG
							switch (hr)
							{
								case DPNHERR_NOMAPPING:
								{
									DPFX(DPFPREP, 1, "Internet gateway (index %u, type flags = 0x%lx) does not have a public address.",
										dwTemp, dwAddressTypeFlags);
									break;
								}

								case DPNHERR_PORTUNAVAILABLE:
								{
									DPFX(DPFPREP, 1, "Port is unavailable on Internet gateway (index %u).", dwTemp );
									break;
								}

								case DPNHERR_SERVERNOTAVAILABLE:
								{
									DPFX(DPFPREP, 1, "No Internet gateway (index %u).", dwTemp );
									break;
								}

								default:
								{
									DPFX(DPFPREP, 1, "An error (0x%lx) occurred while getting registered address mapping index %u.",
										hr, dwTemp);
									break;
								}
							}
#endif // DBG
						}
						else
						{
							//
							// No object in this slot.
							//
						}
					} // end for (each DPNATHelp object)


					//
					// If we found a mapping, pTempAddress is not NULL and contains the mapping's
					// address.  If we couldn't find any mappings with any of the NAT Help objects,
					// pTempAddress will be non-NULL, but bogus.  We should return the local address
					// if it's a HOST address, or NULL if the caller was trying to get the public
					// address.
					//
					if (hr != DPNH_OK)
					{
						if (AddressType == SP_ADDRESS_TYPE_HOST)
						{
							DPFX(DPFPREP, 1, "No NAT Help mappings exist, using regular address:");
							DumpSocketAddress( 1, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
							pTempAddress->CopyAddressSettings( m_pNetworkSocketAddress );
						}
						else
						{
							DPFX(DPFPREP, 1, "No NAT Help mappings exist, not returning address.");
							g_SocketAddressPool.Release( pTempAddress );
							pTempAddress = NULL;
						}
					}
					else
					{
						//
						// We found a mapping.
						//
					}
				}
				else
				{
					//
					// Couldn't get temporary address object, we won't return an address.
					//
				}
			}
			else
#endif DPNBUILD_NONATHELP
			{
				//
				// NAT Help not loaded or not necessary.
				//
				
				if (AddressType == SP_ADDRESS_TYPE_HOST)
				{
					pTempAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) m_pNetworkSocketAddress->GetFamily()));
					if ( pTempAddress != NULL )
					{
						pTempAddress->CopyAddressSettings( m_pNetworkSocketAddress );

#ifdef DPNBUILD_XNETSECURITY
						//
						// Force the IP address to the loopback address for
						// secure mode, since it barfs when looking up the
						// real local IP.
						//
						if (pullKeyID != NULL)
						{
							DNASSERT(pTempAddress->GetFamily() == AF_INET);

							psaddrin = (SOCKADDR_IN *) pTempAddress->GetWritableAddress();
							psaddrin->sin_addr.S_un.S_addr = IP_LOOPBACK_ADDRESS;
						}
#endif // ! DPNBUILD_XNETSECURITY
					}
					else
					{
						//
						// Couldn't allocate memory, we won't return an address.
						//
					}
				}
				else
				{
					//
					// Public host address requested.  NAT Help not available, so of course
					// there won't be a public address.  Return NULL.
					//
				}
			}


			//
			// If we determined we had an address to return, convert it to the
			// IDirectPlay8Address object our caller is expecting.
			//
			if ( pTempAddress != NULL )
			{
				//
				// We have an address to return.
				//
#ifdef DBG
#if ((! defined (DPNBUILD_NOIPX)) || (! defined (DPNBUILD_NOIPV6)))
				if (pTempAddress->GetFamily() == AF_INET)
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
				{
					psaddrin = (SOCKADDR_IN *) pTempAddress->GetAddress();
#ifndef DPNBUILD_ONLYONEADAPTER
					DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
#endif // ! DPNBUILD_ONLYONEADAPTER
					DNASSERT( psaddrin->sin_addr.S_un.S_addr != INADDR_BROADCAST );
					DNASSERT( psaddrin->sin_port != 0 );
				}
#endif // DBG


				//
				// Convert the socket address to an IDirectPlay8Address
				//
#ifdef DPNBUILD_XNETSECURITY
				pAddress = pTempAddress->DP8AddressFromSocketAddress( pullKeyID, NULL, SP_ADDRESS_TYPE_HOST );
#else // ! DPNBUILD_XNETSECURITY
				pAddress = pTempAddress->DP8AddressFromSocketAddress( SP_ADDRESS_TYPE_HOST );
#endif // ! DPNBUILD_XNETSECURITY

				g_SocketAddressPool.Release( pTempAddress );
				pTempAddress = NULL;
			}
			else
			{
				//
				// Not returning an address.
				//
				DNASSERT( pAddress == NULL );
			}

			break;
		}

		default:
		{
			//
			// shouldn't be here
			//
			DNASSERT( FALSE );
			break;
		}
	}


	DPFX(DPFPREP, 8, "(0x%p) Returning [0x%p]", this, pAddress );
	
	return	pAddress;
}
//**********************************************************************


#ifndef DPNBUILD_NOWINSOCK2
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2ReceiveComplete - a Winsock2 socket receive completed
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2ReceiveComplete"

void	CSocketPort::Winsock2ReceiveComplete( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique )
{
	CReadIOData *	pReadData;
	CSocketPort *	pThisSocketPort;
	DWORD			dwFlags;


	DNASSERT( pvContext != NULL );
	pReadData = (CReadIOData*) pvContext;
	DNASSERT( pReadData->m_pSocketPort != NULL );
	pThisSocketPort = pReadData->m_pSocketPort;


	//
	// If we are handling an I/O completion via the threadpool, get the result
	// and clear the overlapped field because it has been reclaimed already.
	//
	if (pReadData->GetOverlapped() != NULL)
	{
		if (pThisSocketPort->GetSocket() != INVALID_SOCKET)
		{
			if (! p_WSAGetOverlappedResult(pThisSocketPort->GetSocket(),
											(WSAOVERLAPPED*) pReadData->GetOverlapped(),
											&pReadData->m_dwOverlappedBytesReceived,
											FALSE,
											&dwFlags))
			{
				pReadData->m_ReceiveWSAReturn = WSAGetLastError();
			}
			else
			{
				pReadData->m_ReceiveWSAReturn = ERROR_SUCCESS;
			}
		}
		else
		{
			DNASSERT(pThisSocketPort->m_State == SOCKET_PORT_STATE_UNBOUND);
			pReadData->m_ReceiveWSAReturn = WSAENOTSOCK;
		}

		pReadData->SetOverlapped(NULL);
	}


	DPFX(DPFPREP, 8, "Socket port 0x%p completing read data 0x%p with result %i, bytes %u.",
		pThisSocketPort, pReadData, pReadData->m_ReceiveWSAReturn, pReadData->m_dwOverlappedBytesReceived);
	
#ifdef WIN95
	if ((pReadData->m_ReceiveWSAReturn == ERROR_SUCCESS) &&
		(pReadData->m_dwOverlappedBytesReceived == 0))
	{
		DPFX(DPFPREP, 2, "Marking 0 byte success read data 0x%p as aborted.",
			pReadData);
		pReadData->m_ReceiveWSAReturn = ERROR_OPERATION_ABORTED;
	}
#endif // WIN95


	//
	// figure out what's happening with this socket port
	//
	pThisSocketPort->Lock();
	switch ( pThisSocketPort->m_State )
	{
		//
		// we're unbound, discard this message and don't ask for any more
		//
		case SOCKET_PORT_STATE_UNBOUND:
		{
			DPFX(DPFPREP, 1, "Socket port 0x%p is unbound ignoring result %i (%u bytes).",
				pThisSocketPort, pReadData->m_ReceiveWSAReturn, pReadData->m_dwOverlappedBytesReceived );
			pThisSocketPort->Unlock();
			break;
		}

		//
		// we're initialized, process input data and submit a new receive if
		// applicable
		//
		case SOCKET_PORT_STATE_BOUND:
		{
			//
			// success, or non-socket closing error, submit another receive
			// and process data if applicable
			//

#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DBG)))
			//
			// The socket state must not go to UNBOUND while we are in a
			// receive or we will be using an invalid socket handle.
			//
			pThisSocketPort->m_iThreadsInReceive++;
#endif // ! DPNBUILD_ONLYONETHREAD or DBG

			pThisSocketPort->Unlock();

			//
			// Resubmit a receive for the same CPU as this one that's completing.
			//
#ifdef DPNBUILD_ONLYONEPROCESSOR
			pThisSocketPort->Winsock2Receive();
#else // ! DPNBUILD_ONLYONEPROCESSOR
			pThisSocketPort->Winsock2Receive(pReadData->GetCPU());
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DBG)))
			pThisSocketPort->Lock();
			pThisSocketPort->m_iThreadsInReceive--;
			pThisSocketPort->Unlock();
#endif // ! DPNBUILD_ONLYONETHREAD or DBG

			switch ( pReadData->m_ReceiveWSAReturn )
			{
				//
				// ERROR_SUCCESS = no problem (process received data)
				//
				case ERROR_SUCCESS:
				{
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
					pThisSocketPort->ProcessReceivedData( pReadData );
					break;
				}
				
				//
				// WSAECONNRESET = previous send failed (process received data with the intention of disconnecting endpoint)
				// ERROR_PORT_UNREACHABLE = same
				//
				case WSAECONNRESET:
				case ERROR_PORT_UNREACHABLE:
				{
					DPFX(DPFPREP, 7, "(0x%p) Send failure reported from + to:", pThisSocketPort);
					DNASSERT(pReadData->m_dwOverlappedBytesReceived == 0);
					DumpSocketAddress(7, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
					DumpSocketAddress(7, pThisSocketPort->GetNetworkAddress()->GetAddress(), pThisSocketPort->GetNetworkAddress()->GetFamily());

#ifndef DPNBUILD_NOREGISTRY
					if (g_fDisconnectOnICMP)
					{
						HRESULT		hr;
						CEndpoint *	pEndpoint;


						//	
						// Look for an active connection for which the disconnection was
						// indicated.	
						//
						pThisSocketPort->ReadLockEndpointData();
						if ( pThisSocketPort->m_ConnectEndpointHash.Find( (PVOID)pReadData->m_pSourceSocketAddress, (PVOID*)&pEndpoint ) )
						{
							if ( pEndpoint->AddCommandRef() )
							{
								pThisSocketPort->UnlockEndpointData();

								DPFX(DPFPREP, 7, "(0x%p) Disconnecting endpoint 0x%p.", pThisSocketPort, pEndpoint);

								hr = pEndpoint->Disconnect();
								if ( hr != DPN_OK )
								{
									DPFX(DPFPREP, 0, "Couldn't disconnect endpoint 0x%p (err = 0x%lx)!", pEndpoint, hr);
								}
								
								pEndpoint->DecCommandRef();
							}
							else
							{
								pThisSocketPort->UnlockEndpointData();

								DPFX(DPFPREP, 3, "Not disconnecting endpoint 0x%p, it's already unbinding.",
									pEndpoint );
							}
						}
						else
						{
							//
							// No active connection, we won't bother handling proxy case.
							//
							pThisSocketPort->UnlockEndpointData();
							
							DPFX(DPFPREP, 7, "(0x%p) No corresponding endpoint found.", pThisSocketPort);
						}
					}
#endif // ! DPNBUILD_NOREGISTRY
					break;
				}
				
				//
				// ERROR_FILE_NOT_FOUND = socket was closed or previous send failed
				// ERROR_MORE_DATA = datagram was sent that was too large
				// ERROR_NO_SYSTEM_RESOURCES = out of memory
				//
				case ERROR_FILE_NOT_FOUND:
				case ERROR_MORE_DATA:
				case ERROR_NO_SYSTEM_RESOURCES:
				{
					DPFX(DPFPREP, 1, "Ignoring known receive err 0x%lx.", pReadData->m_ReceiveWSAReturn );
					break;
				}

				//
				// ERROR_OPERATION_ABORTED = I/O was cancelled for a thread (it also is the same
				//								as 9x "socket closed", but we assume that's not
				//								happening and would be caught by socket bind
				//								state above)
				//
				case ERROR_OPERATION_ABORTED:
				{
					DPFX(DPFPREP, 1, "Thread I/O cancelled, ignoring receive err %u/0x%lx.",
						pReadData->m_ReceiveWSAReturn, pReadData->m_ReceiveWSAReturn );
					break;
				}

				default:
				{
					DPFX(DPFPREP, 0, "Unexpected return from WSARecvFrom() 0x%lx.", pReadData->m_ReceiveWSAReturn );
					DisplayErrorCode( 0, pReadData->m_ReceiveWSAReturn );
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			pThisSocketPort->Unlock();
			break;
		}
	}

	//
	// Return the current data to the pool and note that this I/O operation is
	// complete.  Clear the overlapped bytes received so they aren't misinterpreted
	// if this item is reused from the pool.
	//
	DNASSERT( pReadData != NULL );
	pReadData->m_dwOverlappedBytesReceived = 0;	
	pReadData->DecRef();	
	pThisSocketPort->DecRef();

	return;
}
//**********************************************************************
#endif // DPNBUILD_NOWINSOCK2



//**********************************************************************
// ------------------------------
// CSocketPort::ProcessReceivedData - process received data
//
// Entry:		Pointer to CReadIOData
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::ProcessReceivedData"

void	CSocketPort::ProcessReceivedData( CReadIOData *const pReadData )
{
	PREPEND_BUFFER *	pPrependBuffer;
	CEndpoint *			pEndpoint;
	BOOL				fDataClaimed;
	CBilink *			pBilink;
	CEndpoint *			pCurrentEndpoint;
	CSocketAddress *	pSocketAddress;


	DNASSERT( pReadData != NULL );


	DPFX(DPFPREP, 7, "(0x%p) Processing %u bytes of data from + to:", this, pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
	DumpSocketAddress(7, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
	DumpSocketAddress(7, GetNetworkAddress()->GetAddress(), GetNetworkAddress()->GetFamily());

	
	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( PREPEND_BUFFER* ) );
	pPrependBuffer = reinterpret_cast<PREPEND_BUFFER*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData );

	//
	// Check data for integrity and decide what to do with it.  If there is
	// enough data to determine an SP command type, try that.  If there isn't
	// enough data, and it looks spoofed, reject it.
	//
	
	DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > 0 );

	if ( pPrependBuffer->GenericHeader.bSPLeadByte != SP_HEADER_LEAD_BYTE )
	{
		goto ProcessUserData;
	}
	
	if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize < sizeof( pPrependBuffer->GenericHeader ) )
	{
		DPFX(DPFPREP, 7, "Ignoring %u bytes of malformed SP command data.",
			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize );
		DNASSERTX(! "Received malformed message using invalid SP command!", 2);
		goto Exit;
	}
	
	switch ( pPrependBuffer->GenericHeader.bSPCommandByte )
	{
		//
		// Enum data, send it to the active listen (if there is one).
		//
		case ENUM_DATA_KIND:
		{
			if (! pReadData->m_pSourceSocketAddress->IsValidUnicastAddress(FALSE))
			{
				DPFX(DPFPREP, 7, "Invalid source address, ignoring %u byte enum.",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				goto Exit;
			}
			
#ifndef DPNBUILD_NOREGISTRY
			if ( g_fIgnoreEnums )
			{
				DPFX(DPFPREP, 7, "Ignoring enumeration attempt." );
				DNASSERTX(! "Received enum message when ignoring enums!", 2);
				goto Exit;
			}
			
			if ( pReadData->m_pSourceSocketAddress->IsBannedAddress() )
			{
				DPFX(DPFPREP, 6, "Ignoring %u byte enum sent by banned address.",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				goto Exit;
			}
#endif // ! DPNBUILD_NOREGISTRY

			//
			// Validate size.  We use <= instead of < because there must be a user payload.
			//
			if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize <= sizeof( pPrependBuffer->EnumDataHeader ) )
			{
				DPFX(DPFPREP, 7, "Ignoring data, not large enough to be a valid enum (%u <= %u).",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize, sizeof( pPrependBuffer->EnumDataHeader ));
				DNASSERTX(! "Received invalid enum message!", 2);
				goto Exit;
			}
			
			ReadLockEndpointData();

			//
			// Make sure there is a listen, and isn't going away.
			//
			if ( m_pListenEndpoint != NULL )
			{
				//
				// Try to add a reference to this endpoint so it doesn't go away while we're
				// processing this data.  If the endpoint is already being unbound, this can fail.
				//
				if ( m_pListenEndpoint->AddCommandRef() )
				{
					pEndpoint = m_pListenEndpoint;
					UnlockEndpointData();

					if ( pEndpoint->IsEnumAllowedOnListen() )
					{
						//
						// skip prepended enum header
						//
						pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EnumDataHeader ) ];
						DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumDataHeader ) );
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EnumDataHeader );

						//
						// process data
						//
						pEndpoint->ProcessEnumData( pReadData->ReceivedBuffer(),
													pPrependBuffer->EnumDataHeader.wEnumPayload,
													pReadData->m_pSourceSocketAddress );
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring enumeration because not allowed on listen endpoint 0x%p.",
							m_pListenEndpoint );
					}
					
					pEndpoint->DecCommandRef();
				}
				else
				{
					//
					// the listen is being unbound, return the receive buffer to the pool
					//
					UnlockEndpointData();

					DPFX(DPFPREP, 3, "Ignoring enumeration, listen endpoint 0x%p is unbinding.",
						m_pListenEndpoint );
				}
			}
			else
			{
				//
				// there's no listen active, return the receive buffer to the pool
				//
				UnlockEndpointData();

				DPFX(DPFPREP, 7, "Ignoring enumeration, no associated listen." );
			}
			break;
		}

		//
		// Enum response data, find the appropriate enum and pass it on.
		//
		case ENUM_RESPONSE_DATA_KIND:
#ifdef DPNBUILD_XNETSECURITY
		case XNETSEC_ENUM_RESPONSE_DATA_KIND:
#endif // DPNBUILD_XNETSECURITY
		{
			CEndpointEnumKey	Key;
#ifdef DPNBUILD_XNETSECURITY
			XNADDR *			pxnaddr;
#endif // DPNBUILD_XNETSECURITY

			
			if (! pReadData->m_pSourceSocketAddress->IsValidUnicastAddress(FALSE))
			{
				DPFX(DPFPREP, 7, "Invalid source address, ignoring %u byte enum response.",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				goto Exit;
			}
			
#ifndef DPNBUILD_NOREGISTRY
			if ( g_fIgnoreEnums )
			{
				DPFX(DPFPREP, 7, "Ignoring enumeration response attempt." );
				DNASSERTX(! "Received enum response message when ignoring enums!", 2);
				goto Exit;
			}

			if ( pReadData->m_pSourceSocketAddress->IsBannedAddress() )
			{
				DPFX(DPFPREP, 6, "Ignoring %u byte enum response sent by banned address.",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				goto Exit;
			}
#endif // ! DPNBUILD_NOREGISTRY

			//
			// Validate size.  We use <= instead of < because there must be a user payload.
			//
			if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize <= sizeof( pPrependBuffer->EnumResponseDataHeader ) )
			{
				DPFX(DPFPREP, 7, "Ignoring data, not large enough to be a valid enum response (%u <= %u).",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize, sizeof( pPrependBuffer->EnumResponseDataHeader ));
				DNASSERTX(! "Received invalid enum response message!", 2);
			}


#ifdef DPNBUILD_XNETSECURITY
			//
			// Secure transport enum replies also include an address.
			//
			if ( pPrependBuffer->GenericHeader.bSPCommandByte == XNETSEC_ENUM_RESPONSE_DATA_KIND )
			{
				//
				// Validate size.  We use <= instead of < because there must be a user payload.
				//
				if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize <= sizeof( pPrependBuffer->XNetSecEnumResponseDataHeader ) )
				{
					DPFX(DPFPREP, 7, "Ignoring data, not large enough to be a valid secure enum response (%u < %u).",
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize, sizeof( pPrependBuffer->XNetSecEnumResponseDataHeader ));
					DNASSERTX(! "Received invalid secure enum response message!", 2);
					goto Exit;
				}

				pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->XNetSecEnumResponseDataHeader ) ];
				DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->XNetSecEnumResponseDataHeader ) );
				pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->XNetSecEnumResponseDataHeader );

				pxnaddr = &pPrependBuffer->XNetSecEnumResponseDataHeader.xnaddr;	
			}
			else
#endif // DPNBUILD_XNETSECURITY
			{
				pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EnumResponseDataHeader ) ];
				DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EnumResponseDataHeader ) );
				pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EnumResponseDataHeader );

#ifdef DPNBUILD_XNETSECURITY
				pxnaddr = NULL;
#endif // DPNBUILD_XNETSECURITY
			}


			Key.SetKey( pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload );
			ReadLockEndpointData();
			if ( m_EnumEndpointHash.Find( (PVOID)&Key, (PVOID*)&pEndpoint ) )
			{
				//
				// Try to add a reference to this endpoint so it doesn't go away while we're
				// processing this data.  If the endpoint is already being unbound, this can fail.
				//
				if ( pEndpoint->AddCommandRef() )
				{
					UnlockEndpointData();

					pEndpoint->ProcessEnumResponseData( pReadData->ReceivedBuffer(),
														pReadData->m_pSourceSocketAddress,
#ifdef DPNBUILD_XNETSECURITY
														pxnaddr,
#endif // DPNBUILD_XNETSECURITY
														( pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload & ENUM_RTT_MASK ) );
					pEndpoint->DecCommandRef();
				}
				else
				{
					//
					// the associated ENUM is being unbound, return the receive buffer
					//
					UnlockEndpointData();

					DPFX(DPFPREP, 3, "Ignoring enumeration response, enum endpoint 0x%p is unbinding.",
						pEndpoint );
				}
			}
			else
			{
				//
				// the associated ENUM doesn't exist, return the receive buffer
				//
				UnlockEndpointData();

				DPFX(DPFPREP, 7, "Ignoring enumeration response, no enum associated with key (%u).",
					pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload );
				DNASSERTX(! "Received enum response with unrecognized key!", 3);
			}
			break;
		}

#ifndef DPNBUILD_SINGLEPROCESS
		//
		// proxied query data, this data was forwarded from another port.  Munge
		// the return address, modify the buffer pointer and then send it up
		// through the normal enum data processing pipeline.
		//
		case PROXIED_ENUM_DATA_KIND:
		{
			//
			// Ignore the message if it wasn't sent by the local IP address from
			// the DPNSVR port.
			//
			if ((pReadData->m_pSourceSocketAddress->GetPort() != HTONS(DPNA_DPNSVR_PORT)) ||
				(pReadData->m_pSourceSocketAddress->CompareToBaseAddress(m_pNetworkSocketAddress->GetAddress()) != 0))
			{
				DPFX(DPFPREP, 7, "Ignoring %u byte proxied enum not sent by local DPNSVR.",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				goto Exit;
			}

#ifndef DPNBUILD_NOREGISTRY
			if ( g_fIgnoreEnums )
			{
				DPFX(DPFPREP, 7, "Ignoring proxied enumeration attempt." );
				DNASSERTX(! "Received proxied enum message when ignoring enums!", 2);
				goto Exit;
			}
#endif // ! DPNBUILD_NOREGISTRY

			//
			// Validate size.  We use <= instead of < because there must be a user payload.
			//
			if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize <= sizeof( pPrependBuffer->ProxiedEnumDataHeader ) )
			{
				DPFX(DPFPREP, 7, "Ignoring data, not large enough to be a valid proxied enum (%u <= %u).",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize, sizeof( pPrependBuffer->ProxiedEnumDataHeader ));
				DNASSERTX(! "Received invalid proxied enum message!", 2);
				goto Exit;
			}

			//
			// Make sure the original socket address family is expected.
			//
			if (pPrependBuffer->ProxiedEnumDataHeader.ReturnAddress.AddressGeneric.sa_family != pReadData->m_pSourceSocketAddress->GetFamily())
			{
				DPFX(DPFPREP, 7, "Original address is not correct family, (%u <> %u), ignoring proxied enum.",
					pPrependBuffer->ProxiedEnumDataHeader.ReturnAddress.AddressGeneric.sa_family, pReadData->m_pSourceSocketAddress->GetFamily());
				DNASSERTX(! "Received proxied enum message with invalid original address family!", 2);
				goto Exit;
			}

			//
			// Find out who really sent the message.  Overwrite the received address since
			// we don't care about that (it was DPNSVR).  Normally these checks shouldn't
			// fail because DPNSVR ought to be doing similar validation when it receives
			// the original.  However, someone could potentially spoof the local address
			// and port so we should validate it here, too.
			//
			pReadData->m_pSourceSocketAddress->SetAddressFromSOCKADDR( &pPrependBuffer->ProxiedEnumDataHeader.ReturnAddress.AddressGeneric,
																	   pReadData->m_pSourceSocketAddress->GetAddressSize() );
			
			if (! pReadData->m_pSourceSocketAddress->IsValidUnicastAddress(FALSE))
			{
				DPFX(DPFPREP, 7, "Invalid original address, ignoring %u byte proxied enum from:",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				DumpSocketAddress(7, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
				DNASSERTX(! "Received proxied enum message with invalid original address!", 2);
				goto Exit;
			}
			
#ifndef DPNBUILD_NOREGISTRY
			if ( pReadData->m_pSourceSocketAddress->IsBannedAddress() )
			{
				DPFX(DPFPREP, 6, "Ignoring %u byte proxied enum originally sent by banned address:",
					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
				DumpSocketAddress(6, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
				goto Exit;
			}
#endif // ! DPNBUILD_NOREGISTRY
			
			ReadLockEndpointData();

			//
			// Make sure there is a listen, and isn't going away.
			//
			if ( m_pListenEndpoint != NULL )
			{
				//
				// Try to add a reference to this endpoint so it doesn't go away while we're
				// processing this data.  If the endpoint is already being unbound, this can fail.
				//
				if ( m_pListenEndpoint->AddCommandRef() )
				{
					pEndpoint = m_pListenEndpoint;
					UnlockEndpointData();

					if ( pEndpoint->IsEnumAllowedOnListen() )
					{
						pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->ProxiedEnumDataHeader ) ];

						DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->ProxiedEnumDataHeader ) );
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->ProxiedEnumDataHeader );

						pEndpoint->ProcessEnumData( pReadData->ReceivedBuffer(),
													pPrependBuffer->ProxiedEnumDataHeader.wEnumKey,
													pReadData->m_pSourceSocketAddress );
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring enumeration because not allowed on listen endpoint 0x%p.",
							m_pListenEndpoint );
					}
					
					pEndpoint->DecCommandRef();
				}
				else
				{
					//
					// the listen is being unbound, return the receive buffer to the pool
					//
					UnlockEndpointData();

					DPFX(DPFPREP, 3, "Ignoring proxied enumeration, listen endpoint 0x%p is unbinding.",
						m_pListenEndpoint );
				}
			}
			else
			{
				//
				// there's no listen active, return the receive buffer to the pool
				//
				UnlockEndpointData();

				DPFX(DPFPREP, 7, "Ignoring proxied enumeration, no associated listen." );
				DNASSERTX(! "Received proxied enum response without a listen!", 3);
			}
			break;
		}
#endif // ! DPNBUILD_SINGLEPROCESS

		default:
		{
			DPFX(DPFPREP, 7, "Ignoring %u bytes of data using invalid SP command %u.",
				pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize, pPrependBuffer->GenericHeader.bSPCommandByte);
			DNASSERTX(! "Received message using invalid SP command!", 3);
			break;
		}
	}

Exit:
	return;

ProcessUserData:
	//	
	// If there's an active connection, send it to the connection.  If there's
	// no active connection, send it to an available 'listen' to indicate a
	// potential new connection.	
	//
	ReadLockEndpointData();
	DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize != 0 );
	
	if ( m_ConnectEndpointHash.Find( (PVOID)pReadData->m_pSourceSocketAddress, (PVOID*)&pEndpoint ) )
	{
		//
		// Try to add a reference to this endpoint so it doesn't go away while we're
		// processing this data.  If the endpoint is already being unbound, this can fail.
		//
		if ( pEndpoint->AddCommandRef() )
		{
			pEndpoint->IncNumReceives();

			UnlockEndpointData();

			pEndpoint->ProcessUserData( pReadData );
			pEndpoint->DecCommandRef();
		}
		else
		{
			//
			// the endpoint is being unbound, return the receive buffer to the pool
			//
			UnlockEndpointData();

			DPFX(DPFPREP, 3, "Ignoring user data, endpoint 0x%p is unbinding.",
				pEndpoint );
		}

		goto Exit;
	}


	//
	// Next see if the data is a proxied response
	//
#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))
	if (
#ifndef DPNBUILD_NOWINSOCK2
		(IsUsingProxyWinSockLSP())
#endif // ! DPNBUILD_NOWINSOCK2
#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_NOREGISTRY)))
		||
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_NOREGISTRY
#ifndef DPNBUILD_NOREGISTRY
		(g_fTreatAllResponsesAsProxied)
#endif // ! DPNBUILD_NOREGISTRY
		)
	{
		pEndpoint = NULL;
		pBilink = m_blConnectEndpointList.GetNext();
		while (pBilink != &m_blConnectEndpointList)
		{
			pCurrentEndpoint = CEndpoint::EndpointFromSocketPortListBilink(pBilink);
			
			if ((pCurrentEndpoint->GetNumReceives() == 0) &&
				(pCurrentEndpoint->GetType() == ENDPOINT_TYPE_CONNECT))
			{
				if (pEndpoint != NULL)
				{
					DPFX(DPFPREP, 1, "Receiving data from unknown source, but two or more connects are pending on socketport 0x%p, no proxied association can be made.",
						this);
					pEndpoint = NULL;
					break;
				}

				pEndpoint = pCurrentEndpoint;
				
				//
				// Continue, so we can verify there aren't two simultaneous
				// connects going on.
				//
			}
			else
			{
				//
				// This endpoint has already received some data or it's not
				// a CONNECT endpoint.  It can't have been proxied.
				//
			}

			pBilink = pBilink->GetNext();
		}

		if ( pEndpoint != NULL )
		{
			//
			// Try to add a reference to this endpoint so it doesn't go away while we're
			// processing this data.  If the endpoint is already being unbound, this can fail.
			//
			if ( pEndpoint->AddCommandRef() )
			{
#ifdef DBG
				CEndpoint *	pTempEndpoint;
#endif // DBG

				//
				// Prevent other threads from doing the same thing while we drop the
				// lock.
				//
				pEndpoint->IncNumReceives();

				//
				// Drop the lock so we can retake it in write mode.  The endpoint shouldn't
				// go away because we took a command reference.
				//
				UnlockEndpointData();


				//
				// Make sure the source address is valid.
				//
				if (! pReadData->m_pSourceSocketAddress->IsValidUnicastAddress(FALSE))
				{
					DPFX(DPFPREP, 7, "Invalid source address, ignoring %u bytes of potentially proxied user connect data.",
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
					pEndpoint->DecCommandRef();
					goto Exit;
				}
				
#ifndef DPNBUILD_NOREGISTRY
				//
				// Make sure this wasn't sent by any banned address.
				//
				if (pReadData->m_pSourceSocketAddress->IsBannedAddress())
				{
					DPFX(DPFPREP, 6, "Ignoring %u byte user message sent by potentially proxied but banned address.",
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
					pEndpoint->DecCommandRef();
					goto Exit;
				}
#endif // ! DPNBUILD_NOREGISTRY



				pSocketAddress = pEndpoint->GetWritableRemoteAddressPointer();

				DPFX(DPFPREP, 1, "Found connecting endpoint 0x%p off socketport 0x%p, assuming data from unknown source is a proxied response.  Changing target (was + now):",
					pEndpoint, this);
				DumpSocketAddress(1, pSocketAddress->GetAddress(), pSocketAddress->GetFamily());
				DumpSocketAddress(1, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());

				//
				// We could have a regkey to leave the target socketaddress the same
				// so outbound always goes to that address and inbound always comes
				// in via the different one, however that means adding a variable to
				// hold the original target address because we currently pull the
				// endpoint out of the hash table by its remoteaddress pointer (if that
				// differed from what was in the hash, we would fail to find the object.
				// Since we're not trying to enable that scenario for now (we're just
				// doing this for ISA Server proxy), I'm not doing that work yet.  See
				// CSPData::BindEndpoint.
				//

				WriteLockEndpointData();
			
#ifdef DBG
				DNASSERT( m_ConnectEndpointHash.Find( (PVOID)pSocketAddress, (PVOID*)&pTempEndpoint ) );
				DNASSERT( pTempEndpoint == pEndpoint );
#endif // DBG
				m_ConnectEndpointHash.Remove( pSocketAddress );

				pSocketAddress->CopyAddressSettings( pReadData->m_pSourceSocketAddress );
				
				if ( m_ConnectEndpointHash.Insert( (PVOID)pSocketAddress, pEndpoint ) == FALSE )
				{
					UnlockEndpointData();

					DPFX(DPFPREP, 0, "Problem adding endpoint 0x%p to connect socket port hash!",
						pEndpoint );

					//
					// Nothing we can really do... We're hosed.
					//
				}
				else
				{
					//
					// Indicate the data via the new address.
					//

					UnlockEndpointData();

					pEndpoint->ProcessUserData( pReadData );
					pEndpoint->DecCommandRef();
				}
			}
			else
			{
				UnlockEndpointData();

				DPFX(DPFPREP, 3, "Endpoint 0x%p unbinding, not indicating data as proxied response.",
					pEndpoint );
			}
		
			fDataClaimed = TRUE;
		}
		else
		{
			//
			// Either there weren't any connects pending, or there
			// were 2 or more so we couldn't pick.
			//

			fDataClaimed = FALSE;
		}
	}
	else
#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY
	{
		//
		// Not considering data as proxied.
		//

		fDataClaimed = FALSE;
	}


	if (! fDataClaimed)
	{
		//
		// Make sure there is a listen, and isn't going away.
		//
		if ( m_pListenEndpoint != NULL )
		{
			if ( m_pListenEndpoint->AddCommandRef() )
			{
				pEndpoint = m_pListenEndpoint;
				UnlockEndpointData();


				//
				// Make sure the source address is valid.
				//
				if (! pReadData->m_pSourceSocketAddress->IsValidUnicastAddress(FALSE))
				{
					pEndpoint->DecCommandRef();
					
					DPFX(DPFPREP, 7, "Invalid source address, ignoring %u bytes of user data on listen.",
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
					goto Exit;
				}
			
#ifndef DPNBUILD_NOREGISTRY
				//
				// Make sure this wasn't sent by any banned address.
				//
				if (pReadData->m_pSourceSocketAddress->IsBannedAddress())
				{
					pEndpoint->DecCommandRef();
					
					DPFX(DPFPREP, 6, "Ignoring %u bytes of user data on listen sent by banned address.",
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
					goto Exit;
				}
#endif // ! DPNBUILD_NOREGISTRY


				pEndpoint->ProcessUserDataOnListen( pReadData, pReadData->m_pSourceSocketAddress );
				pEndpoint->DecCommandRef();
			}
			else
			{
				UnlockEndpointData();
				
				DPFX(DPFPREP, 3, "Listen endpoint 0x%p unbinding, not indicating new connection.",
					m_pListenEndpoint );
			}
		}
		else
		{
			//
			// Nobody claimed this data.
			//
			UnlockEndpointData();
			DPFX(DPFPREP, 1, "Ignoring %u bytes of user data, no listen is active.",
				pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
		}
	}

	goto Exit;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\socketport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		SocketPort.h
 *  Content:	Winsock socket port that manages data flow on a given adapter,
 *				address and port.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/11/1999	jtk		Split out to make a base class
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SOCKET_PORT_H__
#define __SOCKET_PORT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// states of socket port
//
typedef	enum
{
	SOCKET_PORT_STATE_UNKNOWN = 0,
	SOCKET_PORT_STATE_INITIALIZED,
	SOCKET_PORT_STATE_BOUND,
	SOCKET_PORT_STATE_UNBOUND,
} SOCKET_PORT_STATE;

//
// enumeration of socket types
//
typedef	enum	_GATEWAY_BIND_TYPE
{
	GATEWAY_BIND_TYPE_UNKNOWN = 0,		// uninitialized
	GATEWAY_BIND_TYPE_DEFAULT,			// map the local port to any random port on the server
	GATEWAY_BIND_TYPE_SPECIFIC,			// map the local port to the same port on the server
	GATEWAY_BIND_TYPE_SPECIFIC_SHARED,	// map the local port to the same port on the server and share it (DPNSVR listen socket port)
	GATEWAY_BIND_TYPE_NONE				// don't map the local port on the server
} GATEWAY_BIND_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSocketPort;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );

//**********************************************************************
// Class definition
//**********************************************************************

//
// reference to other classes and structures
//
#ifndef DPNBUILD_ONLYONEADAPTER
class	CAdapterEntry;
#endif // ! DPNBUILD_ONLYONEADAPTER
class	CEndpoint;
class	CEndpointEnumKey;
class	CSPData;

//
// main class definition
//
class	CSocketPort
{
	public:
		HRESULT	Initialize( CSocketData *const pSocketData,
							CThreadPool *const pThreadPool,
							CSocketAddress *const pAddress );
		HRESULT	Deinitialize( void );

#ifdef DPNBUILD_ONLYONEPROCESSOR
		HRESULT	BindToNetwork( const GATEWAY_BIND_TYPE GatewayBindType );
#else // ! DPNBUILD_ONLYONEPROCESSOR
		HRESULT	BindToNetwork( const DWORD dwCPU, const GATEWAY_BIND_TYPE GatewayBindType );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		HRESULT	UnbindFromNetwork( void );

		const CSocketAddress *const	GetNetworkAddress( void ) const { return m_pNetworkSocketAddress; }
		const SOCKET	GetSocket( void ) const { return m_Socket; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::AddRef"
		void	AddRef( void )
		{
			LONG	lResult;

			
			lResult = DNInterlockedIncrement( const_cast<LONG*>(&m_iRefCount) );

			//
			// NOTE: This generates a lot of spew, especially when running WinSock1 code
			//		path, so it is at secret level 10!
			//
			DPFX(DPFPREP, 10, "Socket port 0x%p refcount = %i.", this, lResult );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::DecRef"
		void	DecRef( void )
		{
			LONG	lResult;

			
			DNASSERT( m_State != SOCKET_PORT_STATE_UNKNOWN );
			DNASSERT( m_iRefCount != 0 );

			//
			// Decrement the reference counts and return this item to the pool if nobody
			// is referencing it anymore.
			//
			lResult = DNInterlockedDecrement( const_cast<LONG*>(&m_iRefCount) );
			if ( lResult == 0 )
			{
				HRESULT	hr;


				DNASSERT( m_iEndpointRefCount == 0 );

				//
				// There's no need to lock this socket port because this is the last
				// reference to it, nobody else will access it.
				//
				hr = Deinitialize();
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem deinitializing socket port 0x%p in DecRef!", this );
					DisplayDNError( 0, hr );
				}

				m_State = SOCKET_PORT_STATE_UNKNOWN;
				g_SocketPortPool.Release( this );
			}
			else
			{
				//
				// NOTE: This generates a lot of spew, especially when running WinSock1 code
				//		path, so it is at secret level 10!
				//
				DPFX(DPFPREP, 10, "Not deinitializing socket port 0x%p, refcount = %i.", this, lResult );
			}
		}
		
		BOOL	EndpointAddRef( void );
		DWORD	EndpointDecRef( void );
		
		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	BindEndpoint( CEndpoint *const pEndpoint, GATEWAY_BIND_TYPE GatewayBindType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint );
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetNewEnumKey"
		const WORD	GetNewEnumKey( void )
		{
			WORD	wReturn;


			DBG_CASSERT( ENUM_RTT_MASK == 0x0F );
			Lock();
			m_iEnumKey++;
			wReturn = (WORD) (m_iEnumKey << 4);
			Unlock();

			return	wReturn;
		}

		DWORD	GetSocketPortID( void ) const { return m_dwSocketPortID; }
#ifndef DPNBUILD_NOWINSOCK2
		BOOL	IsUsingProxyWinSockLSP( void ) const { return m_fUsingProxyWinSockLSP; }
#endif // !DPNBUILD_NOWINSOCK2

		CSocketAddress	*GetBoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const;
		IDirectPlay8Address	*GetDP8BoundNetworkAddress( const SP_ADDRESS_TYPE AddressType,
#ifdef DPNBUILD_XNETSECURITY
															ULONGLONG * const pullKeyID,
#endif // DPNBUILD_XNETSECURITY
															const GATEWAY_BIND_TYPE GatewayBindType ) const;

#ifndef DPNBUILD_ONLYONEADAPTER
		CAdapterEntry	*GetAdapterEntry( void ) const { return m_pAdapterEntry; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SetAdapterEntry"
		void	SetAdapterEntry( CAdapterEntry *const pAdapterEntry )
		{
			DNASSERT( ( m_pAdapterEntry == NULL ) || ( pAdapterEntry == NULL ) );
			m_pAdapterEntry = pAdapterEntry;
		}
#endif // ! DPNBUILD_ONLYONEADAPTER

		static void		WINAPI Winsock2ReceiveComplete( void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique );

		//
		// Public service functions for Winsock1 since we can't get asynchronous
		// notification.
		//
#ifndef DPNBUILD_ONLYWINSOCK2
		BOOL	Winsock1ReadService( void );
		BOOL	Winsock1ErrorService( void );
#endif // ! DPNBUILD_ONLYWINSOCK2

		void	ReadLockEndpointData( void ) { m_EndpointDataRWLock.EnterReadLock(); }
		void	WriteLockEndpointData( void ) { m_EndpointDataRWLock.EnterWriteLock(); }
		void	UnlockEndpointData( void ) { m_EndpointDataRWLock.LeaveLock(); }


		//
		// functions for active list
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::AddToActiveList"
		void	AddToActiveList( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			m_ActiveListLinkage.InsertBefore( pBilink );
		}

		void	RemoveFromActiveList( void ) { m_ActiveListLinkage.RemoveFromList(); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SocketPortFromBilink"
		static CSocketPort	*SocketPortFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CSocketPort* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CSocketPort*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CSocketPort, m_ActiveListLinkage ) ] );
		}

#ifndef WINCE
		void	SetWinsockBufferSize( const INT iBufferSize ) const;
#endif // ! WINCE

#ifndef DPNBUILD_NONATHELP
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetNATHelpPort"
		DPNHHANDLE	GetNATHelpPort( const DWORD dwPortIndex )
		{
			DNASSERT( dwPortIndex < MAX_NUM_DIRECTPLAYNATHELPERS );
			return m_ahNATHelpPorts[dwPortIndex];
		}
#endif // DPNBUILD_NONATHELP

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetListenEndpoint"
		CEndpoint *	GetListenEndpoint( void )
		{
			return m_pListenEndpoint;
		}

#ifndef DPNBUILD_NOMULTICAST
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::FindConnectEndpoint"
		BOOL	FindConnectEndpoint( CSocketAddress * const pSocketAddress, CEndpoint ** ppEndpoint )
		{
			return m_ConnectEndpointHash.Find( (PVOID) pSocketAddress, (PVOID*) ppEndpoint );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetMulticastTTL"
		BYTE	GetMulticastTTL( void ) const
		{
			return m_bMulticastTTL;
		}
#endif // ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_ONLYONEPROCESSOR
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetCPU"
		DWORD	GetCPU( void ) const
		{
			return m_dwCPU;
		}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#ifndef DPNBUILD_NONATHELP
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetUserTraversalMode"
		void SetUserTraversalMode( DWORD dwMode )
		{
			DNASSERT((dwMode == DPNA_TRAVERSALMODE_NONE) || (dwMode == DPNA_TRAVERSALMODE_PORTREQUIRED) || (dwMode == DPNA_TRAVERSALMODE_PORTRECOMMENDED));
			m_dwUserTraversalMode = dwMode;
		}
		DWORD GetUserTraversalMode( void ) const			{ return m_dwUserTraversalMode; }
#endif // ! DPNBUILD_NONATHELP


		//
		// Pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolInitFunction( void* pvItem, void* pvContext );
#ifdef DBG
		static void	PoolDeinitFunction( void* pvItem );
#endif // DBG
		static void	PoolDeallocFunction( void* pvItem );


#ifdef DPNBUILD_ASYNCSPSENDS
		void	SendData( BUFFERDESC *pBuffers, UINT_PTR uiBufferCount, const CSocketAddress *pDestinationSocketAddress, OVERLAPPED * pOverlapped );
#else // ! DPNBUILD_ASYNCSPSENDS
		void	SendData( BUFFERDESC *pBuffers, UINT_PTR uiBufferCount, const CSocketAddress *pDestinationSocketAddress );
#endif // ! DPNBUILD_ASYNCSPSENDS


	protected:

	private:
		BYTE						m_Sig[4];					// debugging signature ('SOKP')
		
		CSocketData					*m_pSocketData;				// pointer to owning socket data object
		CThreadPool					*m_pThreadPool;				// pointer to thread pool
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION			m_Lock;						// thread lock
#endif // !DPNBUILD_ONLYONETHREAD
		volatile LONG				m_iRefCount;				// count of all outstanding references (endpoint and I/O)
		volatile LONG				m_iEndpointRefCount;		// count of outstanding endpoint references
		volatile SOCKET_PORT_STATE	m_State;					// state of socket port
		
		volatile SOCKET				m_Socket;					// communications socket
		CSocketAddress				*m_pNetworkSocketAddress;	// network address this socket is bound to

#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DBG)))
		volatile LONG				m_iThreadsInReceive;		// Number of threads currently in the process of calling WSARecvFrom
#endif // ! DPNBUILD_ONLYONETHREAD or DBG

#ifndef DPNBUILD_ONLYONEADAPTER
		CAdapterEntry				*m_pAdapterEntry;			// pointer to adapter entry to use
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NONATHELP
		DPNHHANDLE					m_ahNATHelpPorts[MAX_NUM_DIRECTPLAYNATHELPERS];	// array NAT Help registered port handles associated with this socket
#endif //  DPNBUILD_NONATHELP
		CBilink						m_ActiveListLinkage;		// linkage to list of active socket ports

		CReadWriteLock				m_EndpointDataRWLock;		// read/write lock for endpoint data
		CHashTable					m_ConnectEndpointHash;		// hash table of connect endpoints
		CBilink						m_blConnectEndpointList;	// list of connect endpoints
		CHashTable					m_EnumEndpointHash;			// hash table of enum endpoints
		CEndpoint					*m_pListenEndpoint;			// associated listen/multicast listen endpoint (there can only be one!)
#ifndef DPNBUILD_NOMULTICAST
		BYTE						m_bMulticastTTL;			// the multicast TTL setting for this socket port, or 0 if not set yet
#endif // ! DPNBUILD_NOMULTICAST

		volatile LONG				m_iEnumKey;					// current 'key' to be assigned to an enum
		DWORD						m_dwSocketPortID;			// unique identifier for this socketport
#ifndef DPNBUILD_NOWINSOCK2
		BOOL						m_fUsingProxyWinSockLSP;	// whether the socket is bound to a proxy client WinSock layered service provider
#endif // !DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_ONLYONEPROCESSOR
		DWORD						m_dwCPU;					// CPU to which this socket is bound
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_NONATHELP
		DWORD						m_dwUserTraversalMode;	// the traversal mode specified by the user for this socketport
#endif // ! DPNBUILD_NONATHELP

#ifdef DBG
		BOOL						m_fInitialized;
#endif // DBG


		HRESULT	BindToNextAvailablePort( const CSocketAddress *const pNetworkSocketAddress,
											const WORD wBasePort ) const;

#ifndef DPNBUILD_NONATHELP
#ifndef DPNBUILD_NOLOCALNAT
		HRESULT	CheckForOverridingMapping( const CSocketAddress *const pBoundSocketAddress);
#endif // ! DPNBUILD_NOLOCALNAT
		HRESULT	BindToInternetGateway( const CSocketAddress *const pBoundSocketAddress,
									  const GATEWAY_BIND_TYPE GatewayBindType );
#endif // ! DPNBUILD_NONATHELP
		
		HRESULT	StartReceiving( void );

#ifndef DPNBUILD_ONLYWINSOCK2
#endif // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NOWINSOCK2
#ifdef DPNBUILD_ONLYONEPROCESSOR
		HRESULT					Winsock2Receive( void );
#else // ! DPNBUILD_ONLYONEPROCESSOR
		HRESULT					Winsock2Receive( const DWORD dwCPU );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#endif // ! DPNBUILD_NOWINSOCK2

		void	ProcessReceivedData( CReadIOData *const pReadData );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CSocketPort( const CSocketPort & );
		CSocketPort& operator=( const CSocketPort & );
};

#undef DPF_MODNAME

#endif	// __SOCKET_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\socketdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		socketdata.h
 *  Content:	Socket list that can be shared between DPNWSOCK service provider interfaces.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/25/2001	vanceo	Extracted from spdata.h
 ***************************************************************************/

#ifndef __SOCKETDATA_H__
#define __SOCKETDATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for information used by the provider
//
class	CSocketData
{	
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketData::AddRef"
		LONG AddRef(void) 
		{
			LONG	lResult;

			lResult = DNInterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 9, "(0x%p) Refcount = %i.", this, lResult);
			return lResult;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketData::Release"
		LONG Release(void)
		{
			LONG	lResult;


			DNASSERT(m_lRefCount != 0);	
			lResult = DNInterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
			if (lResult == 0)
			{
				DPFX(DPFPREP, 3, "(0x%p) Refcount = 0, waiting for shutdown event.", this);

				IDirectPlay8ThreadPoolWork_WaitWhileWorking(m_pThreadPool->GetDPThreadPoolWork(),
															HANDLE_FROM_DNHANDLE(m_hSocketPortShutdownEvent),
															0);

				DPFX(DPFPREP, 9, "(0x%p) Releasing this object back to pool.", this);
				g_SocketDataPool.Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Refcount = %i.", this, lResult);
			}

			return lResult;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketData::AddSocketPortRef"
		LONG AddSocketPortRef(void) 
		{
			LONG	lResult;

			lResult = DNInterlockedIncrement(const_cast<LONG*>(&m_lSocketPortRefCount));
			if (lResult == 1)
			{
				DPFX(DPFPREP, 3, "(0x%p) Refcount = 1, resetting socketport shutdown event.", this);
				DNResetEvent(m_hSocketPortShutdownEvent);
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Refcount = %i, not resetting socketport shutdown event.", this, lResult);
			}
			return lResult;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketData::DecSocketPortRef"
		LONG DecSocketPortRef(void)
		{
			LONG	lResult;


			DNASSERT(m_lSocketPortRefCount != 0);	
			lResult = DNInterlockedDecrement(const_cast<LONG*>(&m_lSocketPortRefCount));
			if (lResult == 0)
			{
				DPFX(DPFPREP, 3, "(0x%p) Refcount = 0, setting socketport shutdown event.", this);
				DNSetEvent(m_hSocketPortShutdownEvent);
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Refcount = %i, not setting socketport shutdown event.", this, lResult);
			}

			return lResult;
		}

		inline void Lock(void)					{ DNEnterCriticalSection(&m_csLock); }
		inline void Unlock(void)				{ DNLeaveCriticalSection(&m_csLock); }

#ifdef DPNBUILD_ONLYONEADAPTER
		inline CBilink * GetSocketPorts(void)	{ return &m_blSocketPorts; }
#else // ! DPNBUILD_ONLYONEADAPTER
		inline CBilink * GetAdapters(void)		{ return &m_blAdapters; }
#endif // ! DPNBUILD_ONLYONEADAPTER

		BOOL FindSocketPort(const CSocketAddress * const pSocketAddress, CSocketPort ** const ppSocketPort );


		//
		// pool functions
		//
		static BOOL	PoolAllocFunction(void * pvItem, void * pvContext);
		static void	PoolInitFunction(void * pvItem, void * pvContext);
		static void	PoolReleaseFunction(void * pvItem);
		static void	PoolDeallocFunction(void * pvItem);
		


	private:
		BYTE				m_Sig[4];					// debugging signature ('SODT')
		volatile LONG		m_lRefCount;				// reference count
		CThreadPool *		m_pThreadPool;				// pointer to thread pool used
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION	m_csLock;					// lock
#endif // !DPNBUILD_ONLYONETHREAD
#ifdef DPNBUILD_ONLYONEADAPTER
		CBilink				m_blSocketPorts;			// list of active socket ports
#else // ! DPNBUILD_ONLYONEADAPTER
		CBilink				m_blAdapters;				// list of active adapters (upon which socket ports are bound)
#endif // ! DPNBUILD_ONLYONEADAPTER
		volatile LONG		m_lSocketPortRefCount;		// number of socket ports that have references on the object
		DNHANDLE			m_hSocketPortShutdownEvent;	// event to set when all socketports have unbound
};

#undef DPF_MODNAME

#endif	// __SOCKETDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\spdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.cpp
 *  Content:	Global variables for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Dereived from Locals.cpp
 *  01/10/2000	rmt		Updated to build with Millennium build process
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Initialize - initialize
//
// Entry:		SP type
//				Pointer to SP COM vtable
//
// Exit:		Error code
//
// Note:	This function assumes that someone else is preventing reentry!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Initialize"

HRESULT	CSPData::Initialize(
							IDP8ServiceProviderVtbl *const pVtbl
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
							,const short sSPType
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							,const XDP8CREATE_PARAMS * const pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
							)
{
	HRESULT							hr;
	BOOL							fLockInitialized;
#ifndef DPNBUILD_LIBINTERFACE
	BOOL							fWinsockLoaded;
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DWORD							dwNumToAllocate;
	DWORD							dwAllocated;
	READ_IO_DATA_POOL_CONTEXT		ReadIODataPoolContext;
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	DPFX(DPFPREP, 4, "(0x%p) Parameters:(0x%p, 0x%p, 0x%p)", this, pVtbl, pDP8CreateParams);
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	DPFX(DPFPREP, 4, "(0x%p) Parameters:(0x%p, 0x%p, %u, 0x%p)", this, pVtbl, sSPType, pDP8CreateParams);
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	DPFX(DPFPREP, 4, "(0x%p) Parameters:(0x%p, 0x%p)", this, pVtbl);
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	DPFX(DPFPREP, 4, "(0x%p) Parameters:(0x%p, 0x%p, %u)", this, pVtbl, sSPType);
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	DNASSERT( pVtbl != NULL );
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT( pDP8CreateParams != NULL );
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	//
	// initialize
	//
	hr = DPN_OK;
#ifndef DPNBUILD_LIBINTERFACE
	fWinsockLoaded = FALSE;
#endif // ! DPNBUILD_LIBINTERFACE
	fLockInitialized = FALSE;

	m_lRefCount = 0;
	m_lObjectRefCount = 0;
	m_hShutdownEvent = NULL;
	m_SPState = SPSTATE_UNINITIALIZED;
	m_pThreadPool = NULL;
	m_pSocketData = NULL;

	m_Sig[0] = 'S';
	m_Sig[1] = 'P';
	m_Sig[2] = 'D';
	m_Sig[3] = 'T';
	
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );

#ifndef DPNBUILD_LIBINTERFACE
	DNInterlockedIncrement( const_cast<LONG*>(&g_lOutstandingInterfaceCount) );
#endif // ! DPNBUILD_LIBINTERFACE


#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	m_sSPType = sSPType;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	
	DNASSERT( m_COMInterface.m_pCOMVtbl == NULL );
	m_COMInterface.m_pCOMVtbl = pVtbl;


#ifndef DPNBUILD_LIBINTERFACE
	//
	// Attempt to load Winsock.
	//
	if ( LoadWinsock() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to load winsock!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	fWinsockLoaded = TRUE;
#endif // ! DPNBUILD_LIBINTERFACE


	//
	// initialize internal critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Problem initializing main critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes
	fLockInitialized = TRUE;

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Pre-allocate a socket data object.
	//
	dwNumToAllocate = 1;
	dwAllocated = g_SocketDataPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested socket data objects!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	
	//
	// Allocate a couple addresses for each remote player (one for
	// each receive plus one for the endpoint), and an address for
	// a local listen endpoint.
	// Also allocate an address per command since we frequently
	// use temporary addresses (see below).
	// And finally, include addresses for the pending receives (see
	// below).
	//
	DNASSERT(pDP8CreateParams->dwMaxNumPlayers > 0);
	dwNumToAllocate = (pDP8CreateParams->dwMaxNumPlayers - 1)
						* (pDP8CreateParams->dwMaxReceivesPerPlayer + 1)
						+ 1;
	dwNumToAllocate += pDP8CreateParams->dwMaxNumPlayers
						+ pDP8CreateParams->dwNumSimultaneousEnumHosts;
#pragma TODO(vanceo, "This represents outstanding receives; on multi-proc machines this would be multiplied by # CPUs")
	dwNumToAllocate += 1;
	dwNumToAllocate++; // include one to cover a receive that's being processed
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	dwAllocated = g_SocketAddressPool.Preallocate(dwNumToAllocate, NULL);
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	dwAllocated = g_SocketAddressPool.Preallocate(dwNumToAllocate, ((PVOID) ((DWORD_PTR) GetType())));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested socket addresses!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Pre-allocate one socketport.
	//
	dwNumToAllocate = 1;
	dwAllocated = g_SocketPortPool.Preallocate(dwNumToAllocate, (PVOID) pDP8CreateParams);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested socket ports!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Allocate an endpoint for each remote player, plus one for a
	// listen endpoint.  If more simultaneous enums are expected than
	// remote players, use that instead, and allow for the connect to
	// be bound while the enumerations are still running.
	//
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers;
	if (dwNumToAllocate <= pDP8CreateParams->dwNumSimultaneousEnumHosts)
	{
		dwNumToAllocate = pDP8CreateParams->dwNumSimultaneousEnumHosts + 1;
	}
	dwAllocated = g_EndpointPool.Preallocate(dwNumToAllocate, this);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested endpoints!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Set the handle table size to hold all the endpoints.
	//
	hr = m_HandleTable.SetTableSize(dwNumToAllocate);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set handle table size to %u entries!",
			dwNumToAllocate);
		goto Failure;
	}

	//
	// Allocate a command for connects to each remote player, plus
	// one for a listen endpoint.
	// Add in one for each enum host operation.
	//
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers;
	dwNumToAllocate += pDP8CreateParams->dwNumSimultaneousEnumHosts;
	dwAllocated = g_CommandDataPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u command data objects!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Allocate an endpoint command parameter object for each command.
	//
	dwAllocated = g_EndpointCommandParametersPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u endpoint command parameter objects!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
 	//	Pre-allocate two address objects for each command to support the
 	//	address info indications.
	//
	hr = DNAddress_PreallocateInterfaces(dwNumToAllocate);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't pre-allocate %u address objects!",
			dwNumToAllocate);
		goto Failure;
	}

#pragma TODO(vanceo, "This is located in DN_PopulateCorePools because m_pThreadPool isn't set at this point")
	/*
	//
	//	Pre-allocate per-CPU items for the threadpool.  We want:
	//	+ one work item for each command
	//	+ one timer per enum hosts operation
	//	+ one I/O operation per simultaneous read
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	hr = IDirectPlay8ThreadPoolWork_Preallocate(m_pThreadPool->GetDPThreadPoolWork(),
												dwNumToAllocate,
												pDP8CreateParams->dwNumSimultaneousEnumHosts,
												1,
												0);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't pre-allocate %u work items, %u timers, or 1 I/O operation!",
			dwNumToAllocate,
			pDP8CreateParams->dwNumSimultaneousEnumHosts);
		goto Failure;
	}
#else // ! DPNBUILD_ONLYONEPROCESSOR
#pragma TODO(vanceo, "This would be multiplied by number of CPUs")
	hr = IDirectPlay8ThreadPoolWork_Preallocate(m_pThreadPool->GetDPThreadPoolWork(),
												dwNumToAllocate,
												pDP8CreateParams->dwNumSimultaneousEnumHosts,
												1,
												0);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't pre-allocate %u work items, %u timers, or %u I/O operations!",
			dwNumToAllocate,
			pDP8CreateParams->dwNumSimultaneousEnumHosts,
			1);
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	*/
	

	//
	// Allocate a timer entry for each enum command.
	//
	dwNumToAllocate = pDP8CreateParams->dwNumSimultaneousEnumHosts;
	dwAllocated = g_TimerEntryPool.Preallocate(dwNumToAllocate, NULL);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u timer entries!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Allocate the desired number of receives.
 	// Include extras for the outstanding receives that haven't been
 	// completed by Winsock.
 	// See socket address preallocation above.
	//

	ReadIODataPoolContext.pThreadPool = NULL;
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	ReadIODataPoolContext.sSPType = GetType();
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifndef DPNBUILD_ONLYONEPROCESSOR
	ReadIODataPoolContext.dwCPU = -1; // unknown right now
#endif // ! DPNBUILD_ONLYONEPROCESSOR

	dwNumToAllocate = (pDP8CreateParams->dwMaxNumPlayers - 1)
						* pDP8CreateParams->dwMaxReceivesPerPlayer;
#pragma TODO(vanceo, "This would be multiplied by number of CPUs on multiproc machines")
	dwNumToAllocate += 1;
	dwNumToAllocate++; // include one to cover a receive that's being processed
	dwAllocated = g_ReadIODataPool.Preallocate(dwNumToAllocate,
											&ReadIODataPoolContext);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u read I/O data buffers!",
			dwAllocated, dwNumToAllocate);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

Exit:

	DPFX(DPFPREP, 4, "(0x%p) Return [0x%lx]", this, hr);

	return	hr;


Failure:
	
	if ( fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		fLockInitialized = FALSE;
	}

#ifndef DPNBUILD_LIBINTERFACE
	if ( fWinsockLoaded != FALSE )
	{
		UnloadWinsock();
		fWinsockLoaded = FALSE;
	}
#endif // ! DPNBUILD_LIBINTERFACE
	
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	m_sSPType = 0;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	This function assumes that someone else is preventing reentry.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Deinitialize"

void	CSPData::Deinitialize( void )
{
	DPFX(DPFPREP, 4, "(0x%p) Enter", this );


#ifndef DPNBUILD_LIBINTERFACE
	UnloadWinsock();
#endif // ! DPNBUILD_LIBINTERFACE

	DNASSERT( m_pSocketData == NULL );

	DNDeleteCriticalSection( &m_Lock );

	SetState( SPSTATE_UNINITIALIZED );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	m_sSPType = 0;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );

	// The shutdown event and thread pool should have been closed in Shutdown.
	DNASSERT( m_hShutdownEvent == NULL );
	DNASSERT( GetThreadPool() == NULL );


	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( m_hShutdownEvent == NULL );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	DNASSERT( m_sSPType == 0 );
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	DNASSERT( m_SPState == SPSTATE_UNINITIALIZED );
	DNASSERT( m_pThreadPool == NULL );
	
#ifndef DPNBUILD_LIBINTERFACE
	DNInterlockedDecrement( const_cast<LONG*>(&g_lOutstandingInterfaceCount) );
#endif // ! DPNBUILD_LIBINTERFACE


	DPFX(DPFPREP, 4, "(0x%p) Leave", this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Startup - start this set of SP data
//
// Entry:		Pointer to initialization data
//
// Exit:		Error
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Startup"

HRESULT	CSPData::Startup( SPINITIALIZEDATA *pInitializeData )
{
	HRESULT		hr;
	SOCKET		TestSocket;
	BOOL		fInterfaceGlobalsInitialized;
#ifdef DBG
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	TCHAR *		ptszSocketType;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pInitializeData);

	//
	// initialize
	//
	hr = DPN_OK;
	TestSocket = INVALID_SOCKET;
	fInterfaceGlobalsInitialized = FALSE;


	//
	// Before we get too far, check for the existance of this protocol by
	// attempting to create a socket.
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	TestSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
	if ( TestSocket == INVALID_SOCKET )
	{
		DPFX(DPFPREP, 1, "Creating IPv4 socket failed, is that transport protocol installed?");
		hr = DPNERR_UNSUPPORTED;
		goto Failure;
	}

	DPFX(DPFPREP, 3, "Successfully created IPv4 socket.");
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	switch (GetType())
	{
#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
#ifdef DBG
			ptszSocketType = _T("IPX");
#endif // DBG
			TestSocket = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
			break;
		}
#endif // ! DPNBUILD_NOIPX

		case AF_INET:
		{
#ifdef DBG
#ifdef DPNBUILD_NOIPV6
			ptszSocketType = _T("IPv4");
#else // ! DPNBUILD_NOIPV6
			ptszSocketType = _T("IPv4 or IPv6");
#endif // ! DPNBUILD_NOIPV6
#endif // DBG
			DNASSERT(GetType() == AF_INET);
			TestSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
#ifndef DPNBUILD_NOIPV6
			if (TestSocket == INVALID_SOCKET )
			{
				TestSocket = socket( AF_INET6, SOCK_DGRAM, IPPROTO_IP );
			}
#endif // ! DPNBUILD_NOIPV6
			break;
		}
		
		default:
		{
			DNASSERT(FALSE);
			break;
		}
	}

	if ( TestSocket == INVALID_SOCKET )
	{
		DPFX(DPFPREP, 1, "Creating %s socket failed, are the necessary transport protocols installed?",
			ptszSocketType);
		hr = DPNERR_UNSUPPORTED;
		goto Failure;
	}

	DPFX(DPFPREP, 3, "Successfully created %s socket.", ptszSocketType);
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX

	closesocket( TestSocket );
	TestSocket = INVALID_SOCKET;


	//
	// attempt to initialize shutdown event
	//
	DNASSERT( m_hShutdownEvent == NULL );
	m_hShutdownEvent = DNCreateEvent( NULL,		// pointer to security (none)
									TRUE,		// manual reset
									TRUE,		// start signalled (so close can be called without any endpoints being created)
									NULL		// pointer to name (none)
									);
	if ( m_hShutdownEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create event for shutting down spdata!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// get a thread pool
	//
	DNASSERT( m_pThreadPool == NULL );
	hr = InitializeInterfaceGlobals( this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to create thread pool!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fInterfaceGlobalsInitialized = TRUE;
	

	//
	// remember our init data
	//
	DNASSERT( pInitializeData != NULL );

	DNASSERT( 	pInitializeData->dwFlags == SP_SESSION_TYPE_SERVER ||
				pInitializeData->dwFlags == SP_SESSION_TYPE_CLIENT ||
				pInitializeData->dwFlags == SP_SESSION_TYPE_PEER ||
				pInitializeData->dwFlags == 0);
	m_InitData.dwFlags = pInitializeData->dwFlags;

	DNASSERT( pInitializeData->pIDP != NULL );
	m_InitData.pIDP = pInitializeData->pIDP;


	//
	// Success from here on in
	//
	IDP8SPCallback_AddRef( DP8SPCallbackInterface() );
	SetState( SPSTATE_INITIALIZED );


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Return [0x%lx]", this, hr);

	return hr;

Failure:
	
	if ( fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		fInterfaceGlobalsInitialized = FALSE;
	}

	if ( m_hShutdownEvent != NULL )
	{
		DNCloseHandle( m_hShutdownEvent );
		m_hShutdownEvent = NULL;
	}

	goto Exit;
}


//**********************************************************************
// ------------------------------
// CSPData::Shutdown - shut down this set of SP data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Shutdown"

void	CSPData::Shutdown( void )
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Enter", this);

	//
	// Unbind this interface from the globals.  This will cause a closure of all
	// of the I/O which will release endpoints, socket ports and then this data.
	//
	
	DNASSERT( GetThreadPool() != NULL );
	DeinitializeInterfaceGlobals( this );

	SetState( SPSTATE_CLOSING );
	

	//
	// Release the socket data, if we have any.
	//
	if ( m_pSocketData != NULL )
	{
		m_pSocketData->Release();
		m_pSocketData = NULL;
	}


	DNASSERT( m_hShutdownEvent != NULL );

#ifdef DBG
#ifndef DPNBUILD_ONLYONEADAPTER
	DebugPrintOutstandingAdapterEntries();
#endif // ! DPNBUILD_ONLYONEADAPTER
#endif // DBG

	DPFX(DPFPREP, 3, "(0x%p) Waiting for shutdown event 0x%p.",
		this, m_hShutdownEvent);
	hr = IDirectPlay8ThreadPoolWork_WaitWhileWorking(m_pThreadPool->GetDPThreadPoolWork(),
													HANDLE_FROM_DNHANDLE(m_hShutdownEvent),
													0);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed to wait for shutdown event 0x%p (err = 0x%lx!",
			m_hShutdownEvent, hr );
	}

	if ( DNCloseHandle( m_hShutdownEvent ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to close shutdown event 0x%p!", m_hShutdownEvent );
		DisplayErrorCode( 0, dwError );
	}
	m_hShutdownEvent = NULL;


	DNASSERT( GetThreadPool() != NULL );
	GetThreadPool()->DecRef();
	SetThreadPool( NULL );


	if ( DP8SPCallbackInterface() != NULL)
	{
		IDP8SPCallback_Release( DP8SPCallbackInterface() );
		memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	}

	
	DPFX(DPFPREP, 2, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::BindEndpoint - bind an endpoint to a socket port
//
// Entry:		Pointer to endpoint
//				Pointer to IDirectPlay8Address for socket port
//				Pointer to CSocketAddress for socket port
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::BindEndpoint"

HRESULT	CSPData::BindEndpoint( CEndpoint *const pEndpoint,
							   IDirectPlay8Address *const pDeviceAddress,
							   const CSocketAddress *const pSocketAddress,
							   const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT					hr;
	CSocketAddress *		pDeviceSocketAddress;
	CSocketData *			pSocketData;
	CSocketPort *			pSocketPort;
	BOOL					fSocketCreated;
	BOOL					fSocketDataLocked;
#ifndef DPNBUILD_ONLYONEADAPTER
	BOOL					fAdapterEntrySet;
	CAdapterEntry *			pAdapterEntry;
#endif // ! DPNBUILD_ONLYONEADAPTER
	BOOL					fSocketPortInActiveList;
	BOOL					fEndpointReferenceAdded;
	CBilink *				pBilink;
	CBilink *				pBilinkEndOfList;
	GATEWAY_BIND_TYPE		NewGatewayBindType;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_NOMULTICAST
	BYTE					bMulticastTTL;
#endif // ! DPNBUILD_NOMULTICAST
#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))
	IDirectPlay8Address *	pHostAddress;
#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY


	DNASSERT( pEndpoint != NULL );
	DNASSERT( ( pDeviceAddress != NULL ) || ( pSocketAddress != NULL ) );

	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i)",
		this, pEndpoint, pDeviceAddress, pSocketAddress, GatewayBindType);

	//
	// initialize
	//
	hr = DPN_OK;
	pDeviceSocketAddress = NULL;
	pSocketData = NULL;
	pSocketPort = NULL;
	fSocketCreated = FALSE;
	fSocketDataLocked = FALSE;
#ifndef DPNBUILD_ONLYONEADAPTER
	fAdapterEntrySet = FALSE;
	pAdapterEntry = NULL;
#endif // ! DPNBUILD_ONLYONEADAPTER
	fSocketPortInActiveList = FALSE;
	fEndpointReferenceAdded = FALSE;
	
	//
	// create and initialize a device address to be used for this socket port
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pDeviceSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pDeviceSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) GetType()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ( pDeviceSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to allocate address for new socket port!" );
		goto Failure;
	}

	//
	// Initialize the socket address with the provided base addresses.
	//
	if ( pDeviceAddress != NULL )
	{
#if ((! defined(DPNBUILD_ONLYONEADAPTER)) || (! defined(DPNBUILD_ONLYONEPROCESSOR)))
		DWORD	dwComponentSize;
		DWORD	dwComponentType;
#endif // ! DPNBUILD_ONLYONEADAPTER or ! DPNBUILD_ONLYONEPROCESSOR


		DNASSERT( pSocketAddress == NULL );
		hr = pDeviceSocketAddress->SocketAddressFromDP8Address( pDeviceAddress,
#ifdef DPNBUILD_XNETSECURITY
																NULL,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
																FALSE,
#endif // DPNBUILD_ONLYONETHREAD
																SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to parse device address!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


#ifndef DPNBUILD_ONLYONEADAPTER
		//
		// If the device gave a specific port, it's possible that the address has
		// our special "it's not actually a specific port" key (see
		// CSocketPort::GetDP8BoundNetworkAddress).
		//
		if ( pDeviceSocketAddress->GetPort() != ANY_PORT )
		{
			DWORD	dwSocketPortID;
			

			
			dwComponentSize = sizeof(dwSocketPortID);
			dwComponentType = 0;
			hr = IDirectPlay8Address_GetComponentByName( pDeviceAddress,					// interface
														DPNA_PRIVATEKEY_PORT_NOT_SPECIFIC,	// tag
														&dwSocketPortID,					// component buffer
														&dwComponentSize,					// component size
														&dwComponentType					// component type
														);
			if ( hr == DPN_OK )
			{
				//
 				// We found the component.  Make sure it's the right size and type.
				//
				if (( dwComponentSize == sizeof(dwSocketPortID) ) && ( dwComponentType == DPNA_DATATYPE_DWORD ))
				{
					DPFX(DPFPREP, 3, "Found correctly formed private port-not-specific key (socketport ID = %u), ignoring port %u.",
						dwSocketPortID, NTOHS(pDeviceSocketAddress->GetPort()) );
					
					pDeviceSocketAddress->SetPort( ANY_PORT ) ;
				}
				else
				{
					//
					// We are the only ones who should know about this key, so if it
					// got there without being formed correctly, either someone is
					// trying to imitate our address format, or it got corrupted.
					// We'll just ignore it.
					//
					DPFX(DPFPREP, 0, "Private port-not-specific key exists, but doesn't match expected type (%u != %u) or size (%u != %u), is someone trying to get cute with device address 0x%p?!",
						dwComponentSize, sizeof(dwSocketPortID),
						dwComponentType, DPNA_DATATYPE_DWORD,
						pDeviceAddress );
				}
			}
			else
			{
				//
				// The key is not there, it's the wrong size (too big for our buffer
				// and returned BUFFERTOOSMALL), or something else bad happened.
				// It doesn't matter.  Carry on.
				//
				DPFX(DPFPREP, 8, "Could not get appropriate private port-not-specific key, error = 0x%lx, component size = %u, type = %u, continuing.",
					hr, dwComponentSize, dwComponentType);
			}
		}
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifndef DPNBUILD_ONLYONEPROCESSOR
		//
		// Try to retrieve the CPU component, if any.
		//
		dwComponentSize = sizeof(dwCPU);
		dwComponentType = 0;
		hr = IDirectPlay8Address_GetComponentByName( pDeviceAddress,		// interface
													DPNA_KEY_PROCESSOR,		// tag
													&dwCPU,					// component buffer
													&dwComponentSize,		// component size
													&dwComponentType		// component type
													);
		if ( hr == DPN_OK )
		{
			SYSTEM_INFO		SystemInfo;


			//
 			// We found the component.  Make sure it's the right size and type.
			//
			if (( dwComponentSize != sizeof(dwCPU) ) || ( dwComponentType != DPNA_DATATYPE_DWORD ))
			{
				DPFX(DPFPREP, 0, "Processor address component exists, but doesn't match expected type (%u != %u) or size (%u != %u)!",
					dwComponentSize, sizeof(dwCPU),
					dwComponentType, DPNA_DATATYPE_DWORD );
				hr = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}


			//
			// Make sure the processor is valid.
			//
			GetSystemInfo(&SystemInfo);
			if ((dwCPU != -1) && (dwCPU >= SystemInfo.dwNumberOfProcessors))
			{
				DPFX(DPFPREP, 0, "Processor address component exists, but is not valid (%i)!",
					dwCPU );
				hr = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}

			if (dwCPU == -1)
			{
				DPFX(DPFPREP, 3, "Found correctly formed processor component, explicitly using any/all CPUs.");
			}
			else
			{
				DPFX(DPFPREP, 3, "Found correctly formed processor component, CPU = %i.",
					dwCPU );
			}
		}
		else
		{
			//
			// The key is not there, it's the wrong size (too big for our buffer
			// and returned BUFFERTOOSMALL), or something else bad happened.
			// It doesn't matter, we'll just use any/all processors.
			//
			DPFX(DPFPREP, 8, "Could not get processor address component, error = 0x%lx, component size = %u, type = %u, using any CPU.",
				hr, dwComponentSize, dwComponentType);
			dwCPU = -1;
		}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	}
	else
	{
		DNASSERT( pSocketAddress != NULL );
		pDeviceSocketAddress->CopyAddressSettings( pSocketAddress );

#ifndef DPNBUILD_ONLYONEPROCESSOR
		//
		// Use any CPU.
		//
		dwCPU = -1;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	}


#pragma BUGBUG(vanceo, "Find a way to organize and delay the munges (both here and in CSocketPort::BindEndpoint)")


#ifndef DPNBUILD_NONATHELP
	//
	// Munge the public address into a local alias, if there is one for the given device.
	// It's OK for the device socket address to not have a port yet.
	//
	// Note that doing this causes all other multiplexed operations to use the munged
	// result from this first adapter because we indicate the modified address info,
	// not the original public address.  The assumption is that the public address
	// must be globally reachable, so if we munge it here, we should be the only
	// adapter that can reach it locally, or if not, the other adapters should be able
	// to reach it using the same local address.
	//
	if ( pEndpoint->GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE )
	{
		switch ( pEndpoint->GetType() )
		{
			case ENDPOINT_TYPE_CONNECT:
#ifndef DPNBUILD_NOMULTICAST
			case ENDPOINT_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
			{
				MungePublicAddress( pDeviceSocketAddress, pEndpoint->GetWritableRemoteAddressPointer(), FALSE );
				break;
			}
			
			case ENDPOINT_TYPE_ENUM:
			{
				MungePublicAddress( pDeviceSocketAddress, pEndpoint->GetWritableRemoteAddressPointer(), TRUE );
				break;
			}

			default:
			{
				break;
			}
		}
	}
#endif // ! DPNBUILD_NONATHELP

#ifndef DPNBUILD_NOIPV6
	//
	// Munge/convert the IPv4 broadcast address to the IPv6 multicast enum
	// address, and vice versa.
	//
	// Note that doing this causes all other multiplexed operations to use this first
	// adapter because we indicate the modified address info, not the original
	// broadcast address.
	//
	if ( pEndpoint->GetType() == ENDPOINT_TYPE_ENUM )
	{
		if ((pDeviceSocketAddress->GetFamily() == AF_INET6) &&
			(pEndpoint->GetWritableRemoteAddressPointer()->GetFamily() == AF_INET) &&
			(((SOCKADDR_IN*) pEndpoint->GetWritableRemoteAddressPointer()->GetAddress())->sin_addr.S_un.S_addr == INADDR_BROADCAST))
		{
			SOCKADDR_IN6	saddrin6MulticastEnum;


			memset(&saddrin6MulticastEnum, 0, sizeof(saddrin6MulticastEnum));
			saddrin6MulticastEnum.sin6_family = AF_INET6;
			memcpy(&saddrin6MulticastEnum.sin6_addr, &c_in6addrEnumMulticast, sizeof(saddrin6MulticastEnum.sin6_addr));
			saddrin6MulticastEnum.sin6_port = pEndpoint->GetWritableRemoteAddressPointer()->GetPort();

			pEndpoint->GetWritableRemoteAddressPointer()->SetFamilyProtocolAndSize(AF_INET6);
			pEndpoint->GetWritableRemoteAddressPointer()->SetAddressFromSOCKADDR((SOCKADDR*) (&saddrin6MulticastEnum),
																				sizeof(saddrin6MulticastEnum));
			
			DPFX(DPFPREP, 7, "Converting IPv4 broadcast address to IPv6 multicast enum address:");
			DumpSocketAddress( 7, pEndpoint->GetWritableRemoteAddressPointer()->GetAddress(), pEndpoint->GetWritableRemoteAddressPointer()->GetFamily() );
		}
		else if ((pDeviceSocketAddress->GetFamily() == AF_INET) &&
			(pEndpoint->GetWritableRemoteAddressPointer()->GetFamily() == AF_INET6) &&
			(IN6_ADDR_EQUAL(&(((SOCKADDR_IN6*) pEndpoint->GetWritableRemoteAddressPointer()->GetAddress())->sin6_addr), &c_in6addrEnumMulticast)))
		{
			SOCKADDR_IN	saddrinBroadcast;


			memset(&saddrinBroadcast, 0, sizeof(saddrinBroadcast));
			saddrinBroadcast.sin_family = AF_INET;
			saddrinBroadcast.sin_addr.S_un.S_addr = INADDR_BROADCAST;
			saddrinBroadcast.sin_port = pEndpoint->GetWritableRemoteAddressPointer()->GetPort();

			pEndpoint->GetWritableRemoteAddressPointer()->SetFamilyProtocolAndSize(AF_INET);
			pEndpoint->GetWritableRemoteAddressPointer()->SetAddressFromSOCKADDR((SOCKADDR*) (&saddrinBroadcast),
																				sizeof(saddrinBroadcast));
			
			DPFX(DPFPREP, 7, "Converting IPv6 multicast enum address to IPv4 broadcast address:");
			DumpSocketAddress( 7, pEndpoint->GetWritableRemoteAddressPointer()->GetAddress(), pEndpoint->GetWritableRemoteAddressPointer()->GetFamily() );
		}
	}


	//
	// Mash in the appropriate IPv6 scope ID in case we don't have it.
	//
	if ((pDeviceSocketAddress->GetFamily() == AF_INET6) &&
		(pEndpoint->GetWritableRemoteAddressPointer()->GetFamily() == AF_INET6))
	{
		SOCKADDR_IN6 *		psaddrin6Device;
		SOCKADDR_IN6 *		psaddrin6Remote;
		
		
		psaddrin6Device = (SOCKADDR_IN6*) (pDeviceSocketAddress->GetAddress());
		psaddrin6Remote = (SOCKADDR_IN6*) (pEndpoint->GetWritableRemoteAddressPointer()->GetAddress());

		psaddrin6Remote->sin6_scope_id = psaddrin6Device->sin6_scope_id;
	}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOMULTICAST
	//
	// If this is a multicast send endpoint, figure out what TTL we will
	// be using.
	//
	if ( pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND )
	{
		GUID	guidScope;


		pEndpoint->GetScopeGuid( &guidScope );
		if ( memcmp( &guidScope, &GUID_DP8MULTICASTSCOPE_PRIVATE, sizeof(guidScope) ) == 0 )
		{
			bMulticastTTL = MULTICAST_TTL_PRIVATE;
		}
		else if ( memcmp( &guidScope, &GUID_DP8MULTICASTSCOPE_LOCAL, sizeof(guidScope) ) == 0 )
		{
			bMulticastTTL = MULTICAST_TTL_LOCAL;
		}
		else if ( memcmp( &guidScope, &GUID_DP8MULTICASTSCOPE_GLOBAL, sizeof(guidScope) ) == 0 )
		{
			bMulticastTTL = MULTICAST_TTL_GLOBAL;
		}
		else
		{
			//
			// Assume it's a valid MADCAP scope.  Even on non-NT platforms
			// where we don't know about MADCAP, we can still parse out the
			// TTL value.
			//
			bMulticastTTL = CSocketAddress::GetScopeGuidTTL( &guidScope );
		}
	}
#endif // ! DPNBUILD_NOMULTICAST

	//
	// Get the socket port data.  This shouldn't fail, because in order to have
	// an open endpoint, we must have created the socket data.
	//
	pSocketData = GetSocketDataRef();
	if (pSocketData == NULL)
	{
		DNASSERT(! "Couldn't retrieve socket data!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	pSocketData->Lock();
	fSocketDataLocked = TRUE;	

#ifndef DPNBUILD_ONLYONEADAPTER
	//
	// Find the base adapter entry for this network address.  If none is found,
	// create a new one.  If a new one cannot be created, fail.
	//
	pBilink = pSocketData->GetAdapters()->GetNext();
	while ( pBilink != pSocketData->GetAdapters() )
	{
		CAdapterEntry	*pTempAdapterEntry;
	
		
		pTempAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pBilink );
		if ( pDeviceSocketAddress->CompareToBaseAddress( pTempAdapterEntry->BaseAddress() ) == 0 )
		{
			DPFX(DPFPREP, 5, "Found adapter for network address (0x%p).", pTempAdapterEntry );
			DNASSERT( pAdapterEntry == NULL );
			pTempAdapterEntry->AddRef();
			pAdapterEntry = pTempAdapterEntry;
		}
	
		pBilink = pBilink->GetNext();
	}

	if ( pAdapterEntry == NULL )
	{
		pAdapterEntry = (CAdapterEntry*)g_AdapterEntryPool.Get();
		if ( pAdapterEntry == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Failed to create a new adapter entry!