e(&cnode, sizeof (cnode), 1, fp);
								}

							// write to cache out file
							UINT ucount = reccount;
							fwrite(&ucount, sizeof (UINT), 1, fp);

							for (j=0;j<reccount;j++)
							{
								UINT rgval = rg[j];
								fwrite(&rgval, sizeof (UINT), 1, fp);
							}

							m_nCount++;
						}
						LogOut(_T("\n"));
					}
					else
					{
						LogOut(_T("NO RECOMMENDATIONS - ALL AVAILABLE MARKED AS UNKNOWN\n"));
						bEnd = TRUE;
					}
				}
				else
					LogOut(_T("STATE COUNT 0 - INTERNAL ERROR\n"));
			}
			else
				LogOut(_T("NO RECOMMENDATIONS\n"));
		}
	}

	LogOut(_T("\n"));


	// recommendations - let's figure out what to do with them

	// the first rec in the returned array will be array[1] in the set array
	// so we have to watch for that

	if (bp->CInt() && !bEnd)
	{
		// have rec
		CArray<int,int> states;

		int node = rg[i];

		if (bp->BNodeSetCurrent(node))
		{
			ESTDLBL albl = bp->ELblNode();
			
			if (albl == ESTDLBL_info)
			{
				states.Add(0);
				states.Add(1);
				if (m_bScanAll)
					states.Add(STATE_UNKNOWN);
			}
			else if (albl == ESTDLBL_fixobs ||
					albl == ESTDLBL_fixunobs ||
					albl == ESTDLBL_unfix)
			{
				states.Add(0);
				if (m_bScanAll)
					states.Add(STATE_UNKNOWN);
			}
			else
			{
				LogOut(_T("Unexpected Node Type\n"));
			}
		}
		else
			LogOut(_T("Can't set node current\n"));

		int count = (int)states.GetSize();

		for (i=0;i<count;i++)
		{
			if (!NodeTraverse( fp, bp, depth, newnodes, newstates, node, states[i] ))
				return FALSE;
		}
	}
	
	// done, remove references to our current node
	newnodes.RemoveAt(depth - 1);
	newstates.RemoveAt(depth - 1);

	return TRUE;
}


//
//
void GTSCacheGenerator::UninstantiateAll(BNTS *bp)
{
	int count = (int)m_oldnodes.GetSize();
	// uninstantiate all nodes
	if (!count)
		return;

	for (int j=0;j<count;j++)
	{
		if (bp->BNodeSetCurrent(m_oldnodes[j]))
		{
			if (bp->BNodeSet(-1))
			{
			}
			else
			{
				LogOut(_T("Can't uninstantiate node\n"));
			}
		}
		else
		{
			LogOut(_T("Can't set node %d to uninstantiate\n"), m_oldnodes[j]);
		}
	}
}

//
//
void GTSCacheGenerator::SetNodes(BNTS *bp, CArray<int,int> &nodes, CArray<int,int> &states)
{
	m_oldnodes.Copy(nodes);

	int count = (int)nodes.GetSize();
	
	if (!count)
		return;

	LogOut(_T("\nSetNodes:"));
	for (int j=0;j<count;j++)
	{
		if (bp->BNodeSetCurrent(nodes[j]))
		{
			if (states[j] != STATE_UNKNOWN)
			{
				LogOut(_T("(%d=%d)"), nodes[j], states[j]);

				if (bp->BNodeSet(states[j], false))
				{
				}
				else
				{
					LogOut(_T("Can't set node\n"));
				}
			}
			else
				LogOut(_T("(%d=X)"), nodes[j]);
		}
		else
			LogOut(_T("Can't set node %d\n"), nodes[j]);
	}

	LogOut(_T("\n"));
}

//
//
BOOL GTSCacheGenerator::ReadCacheFileHeader(CString &sCacheFilename, const CString& strCacheFileWithinCHM)
{
	GTS_CACHE_FILE_HEADER header;
	bool bUseCHM = strCacheFileWithinCHM.GetLength() != 0;

	if (bUseCHM)
	{
		DWORD size =0;
		if (S_OK != ::ReadChmFile(sCacheFilename, strCacheFileWithinCHM, (void**)&m_filedata, &size))
		{
			return FALSE;
		}
	}
	else
	{
		UINT size;
		// must be binary
		FILE *cfp = _tfopen(sCacheFilename, _T("rb"));
		if (cfp==NULL)
		{
			LogOut(_T("Error opening cache file for reading\n"));
			return FALSE;
		}

		// get file size
		if (fseek(cfp, 0, SEEK_END))
		{
			LogOut(_T("Can't set pos to end of file\n"));
			fclose(cfp);
			return FALSE;
		}

		fpos_t position;
		if (fgetpos(cfp, &position))
		{
			LogOut(_T("Can't get pos at end of file\n"));
			fclose(cfp);
			return FALSE;
		}

		size = (UINT) position;

		rewind(cfp);
		
		// allocate space for file
		m_filedata = (char *) malloc(size);
		if (m_filedata == NULL)
		{
			LogOut(_T("Error allocating memory\n"));
			fclose(cfp);
			return FALSE;
		}
		
		if (fread(m_filedata, size, 1, cfp) != 1)
		{
			LogOut(_T("Error reading file into memory\n"));
			fclose(cfp);
			return FALSE;
		}

		fclose(cfp);
	}

	memcpy(&header, m_filedata, sizeof(header));

	if (memcmp(header.signature, GTS_CACHE_SIG, sizeof (header.signature)) != 0)
	{
		LogOut(_T("Bad file signature!\n"));
		return FALSE;
	}

	if (!header.count)
	{
		LogOut(_T("No items in file!\n"));
		return FALSE;
	}

	m_netstartoffset = header.netoffset;

	LogOut(_T("ItemCount: %d\n"), header.count);

	m_nItemCount = header.count;

	m_cachepos = (GTS_CACHE_FILE_SETDATA *) (m_filedata + sizeof (GTS_CACHE_FILE_HEADER));

	return TRUE;
}

//
//
BOOL GTSCacheGenerator::FindNetworkProperty(LPCSTR szName, CString &sResult, int index)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
		(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_STR_BLK *netstrblk =
			(GTS_CACHE_PROP_STR_BLK *) (m_filedata + netstart->netpropoffset);

	for (UINT i = 0; i < netstart->netpropcount; i++, netstrblk++)
	{
		LPCSTR szItem = (LPCSTR) (m_filedata + netstrblk->nameoffset);
		if (!strcmp(szName, szItem))
		{
			if (!index)
			{
				sResult = (LPCSTR) (m_filedata + netstrblk->stringoffset);
				return TRUE;
			}
			else
			{
				LPCSTR szStrArrItem = (LPCSTR) (m_filedata + netstrblk->stringoffset);
				int len = strlen(szStrArrItem);
				
				for (int j=0;(j < index) && len ;j++)
				{
					szStrArrItem += len + 1;
					len = strlen(szStrArrItem);
				}

				if (!len)
					return FALSE;

				sResult = szStrArrItem;
				return TRUE;
			}
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::FindNodeProperty(UINT nodeid, LPCSTR szName, CString &sResult, int index)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		if (nodeid == nodeblk->nodeid)
		{
			GTS_CACHE_PROP_NODESTART_BLK *nodestart =
					(GTS_CACHE_PROP_NODESTART_BLK *)(m_filedata + nodeblk->nodeoffset);

			GTS_CACHE_PROP_STR_BLK *nodestr =
					(GTS_CACHE_PROP_STR_BLK *)(m_filedata + nodeblk->nodeoffset + sizeof (GTS_CACHE_PROP_NODESTART_BLK));

			// now try to find string
			for (UINT j=0;j<nodestart->nodestringcount;j++, nodestr++)
			{
				LPCSTR szItem = (LPCSTR) (m_filedata + nodestr->nameoffset);

				if (!strcmp(szName, szItem))
				{
					if (!index)
					{
						sResult = (LPCSTR) (m_filedata + nodestr->stringoffset);
						return TRUE;
					}
					else
					{
						LPCSTR szStrArrItem = (LPCSTR) (m_filedata + nodestr->stringoffset);
						int len = strlen(szStrArrItem);
						
						for (int j=0;(j < index) && len ;j++)
						{
							szStrArrItem += len + 1;
							len = strlen(szStrArrItem);
						}

						if (!len)
							return FALSE;

						sResult = szStrArrItem;
						return TRUE;
					}
				}
			}

			return FALSE;
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::IsNodePresent(UINT nodeid)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		if (nodeid == nodeblk->nodeid)
			return TRUE;
	}
	return FALSE;
}

// returns the node count for the network, not what's in the file
//
int GTSCacheGenerator::GetNodeCount()
{
	if (m_filedata == NULL)
		return 0;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	return netstart->nodecountnetwork;
}

//
//
BOOL GTSCacheGenerator::GetNodeIDFromSymName(LPCTSTR szSymName, UINT &nodeid)
{
	char sznSymName[MAX_SYM_NAME_BUF_LEN];
	int nSymLen = MAX_SYM_NAME_BUF_LEN;
	if (m_filedata == NULL)
		return FALSE;

	if (!TcharToChar(sznSymName, szSymName, nSymLen))
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		GTS_CACHE_PROP_NODESTART_BLK *nodestart =
				(GTS_CACHE_PROP_NODESTART_BLK *)(m_filedata + nodeblk->nodeoffset);

		GTS_CACHE_PROP_STR_BLK *nodestr =
				(GTS_CACHE_PROP_STR_BLK *)(m_filedata + nodeblk->nodeoffset + sizeof (GTS_CACHE_PROP_NODESTART_BLK));

		// now try to find string
		for (UINT j=0;j<nodestart->nodestringcount;j++, nodestr++)
		{
			LPCSTR szItem = (LPCSTR) (m_filedata + nodestr->nameoffset);

			if (!strcmp(G_SYMBOLIC_NAME, szItem))
			{
				if (!strcmp(sznSymName, (LPCSTR) (m_filedata + nodestr->stringoffset)))
				{
					nodeid = nodeblk->nodeid;
					return TRUE;
				}
				break;
			}
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::GetLabelOfNode(UINT nodeid, UINT &lbl)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		if (nodeid == nodeblk->nodeid)
		{
			GTS_CACHE_PROP_NODESTART_BLK *nodestart =
					(GTS_CACHE_PROP_NODESTART_BLK *)(m_filedata + nodeblk->nodeoffset);

			lbl = nodestart->labelnode;
			return TRUE;
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::GetNextCacheEntryFromFile(BOOL &bErr, CBNCache *pCache)
{
	BOOL bStat = FALSE;
	bErr = TRUE;

	if (m_filedata == NULL)
		return FALSE;

	if (!m_nItemCount)
	{
		bErr = FALSE;
		return FALSE;
	}

	m_nItemCount--;

	BN_CACHE_ITEM CacheItem;

	// initialize
	CacheItem.uNodeCount = 0;
	CacheItem.uRecCount = 0;
	CacheItem.uName = NULL;
	CacheItem.uValue = NULL;
	CacheItem.uRec = NULL;

	bStat = GetNCEFF(&CacheItem, pCache);

	// free allocated space as necessary
	if (CacheItem.uName)
		free(CacheItem.uName);
	if (CacheItem.uValue)
		free(CacheItem.uValue);
	if (CacheItem.uRec)
		free(CacheItem.uRec);

	if (!bStat)
	{
		bErr = TRUE;
		return FALSE;
	}
	
	bErr = FALSE;
	return TRUE;
}

//
//
BOOL GTSCacheGenerator::GetNCEFF(BN_CACHE_ITEM *pCacheItem, CBNCache *pCache)
{
	UINT j;
	UINT setcount;
	UINT reccount;

	GTS_CACHE_FILE_SETDATA *setp = m_cachepos;

	setcount = setp->count;

	if (!setcount || setcount > 1000)
	{
		LogOut(_T("Set Count out of bounds: %d\n"), setcount);
		return FALSE;
	}

	// initialize
	pCacheItem->uNodeCount = setcount;
	pCacheItem->uName = (UINT *)malloc(setcount * sizeof (UINT));
	pCacheItem->uValue = (UINT *)malloc(setcount * sizeof (UINT));

	LogOut(_T("Count: %d\n"), setcount);

	GTS_CACHE_NODE *cachenode = &setp->item[0];

	// second, read in node = state pairs
	for (j=0;j<setcount;j++, cachenode++)
	{
		pCacheItem->uName[j] = cachenode->node;
		pCacheItem->uValue[j] = cachenode->state;
		
		LogOut(_T("(%d,%d)"), cachenode->node, cachenode->state);

	}
	LogOut(_T("\n"));

	GTS_CACHE_FILE_RECDATA *recp = (GTS_CACHE_FILE_RECDATA *) cachenode;

	reccount = recp->count;

	if (!reccount || reccount > 1000)
	{
		LogOut(_T("Rec Count out of bounds: %d\n"), reccount);
		return FALSE;
	}

	pCacheItem->uRecCount = reccount;
	pCacheItem->uRec = (UINT *)malloc(reccount * sizeof (UINT));

	UINT *uitem = &recp->item[0];

	for (j=0;j<reccount;j++, uitem++)
	{
		pCacheItem->uRec[j] = *uitem;

		LogOut(_T("(%d)"), *uitem);
	}
	LogOut(_T("\n"));

	if (!pCache->AddCacheItem(pCacheItem))
	{
		LogOut(_T("Error Adding Item To Cache\n"));
		return FALSE;
	}

	m_cachepos = (GTS_CACHE_FILE_SETDATA *) uitem;

	// success!
	return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\chmread.h ===
//
// MODULE: CHMREAD.H
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7/1/98
//

#ifndef __CHMREAD_H_
#define __CHMREAD_H_

HRESULT ReadChmFile(LPCTSTR szFileName, LPCTSTR szStreamName, void** ppBuffer, DWORD* pdwRead);
bool GetNetworkRelatedResourceDirFromReg(CString network, CString* path);
bool IsNetworkRelatedResourceDirCHM(CString path);
CString ExtractResourceDir(CString path);
CString ExtractFileName(CString path);
CString ExtractCHM(CString path);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\chmread.cpp ===
//
// MODULE: CHMREAD.CPP
//
// PURPOSE: Template file decoder
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 07.01.98
//
//
#include "stdafx.h"

#include "fs.h"
#include "apgts.h"
#include "chmread.h"

#define CHM_READ_BUFFER_INITIAL_SIZE    1024

// reads ALL stream (ppBuffer is reallocated)
// IN: szStreamName - file name within CHM file
// IN: szFileName - full oath and name of CHM file
// OUT: ppBuffer - data read
HRESULT ReadChmFile(LPCTSTR szFileName, LPCTSTR szStreamName, void** ppBuffer, DWORD* pdwRead)
{
   HRESULT hr =S_OK;
   CFileSystem*    pFileSystem =NULL;
   CSubFileSystem* pSubFileSystem =NULL;
   int i =0;

   // Init ITSS.

   pFileSystem = new CFileSystem();
   if (! SUCCEEDED((hr = pFileSystem->Init())) )
   {
      delete pFileSystem;
      return hr;                       // Unable to init the ITSS store.
   }

   // attempt to open the .CHM file.

   if (! SUCCEEDED((hr = pFileSystem->Open(szFileName))) )
   {
      delete pFileSystem;
      return hr;                       // Unable to open and init the ITSS store.
   }

   while (true, ++i)
   {
	   ULONG read =0;
	   
	   // attempt to open the stream.
	   pSubFileSystem = new CSubFileSystem(pFileSystem);
	   if (! SUCCEEDED((hr = pSubFileSystem->OpenSub(szStreamName))) )
	   {
		  delete pSubFileSystem;
		  delete pFileSystem;
		  return hr;                       // Unable to open the specified stream.
	   }

	   // alloc
	   *ppBuffer = new char[i * CHM_READ_BUFFER_INITIAL_SIZE];
	   if (*ppBuffer == NULL)
	   {
		  delete pSubFileSystem;
		  delete pFileSystem;
		  return S_FALSE;      // THOUGH need to return error indicating disability to allocate memory
	   }
	   
	   // read.
	   hr = pSubFileSystem->ReadSub(*ppBuffer, i * CHM_READ_BUFFER_INITIAL_SIZE, &read);

	   if (read < ULONG(i * CHM_READ_BUFFER_INITIAL_SIZE))
	   {
		  *pdwRead = read;
		  break;
	   }
	   else
	   {
		  delete pSubFileSystem;
		  delete [] *ppBuffer;
	   }
   }

   delete pSubFileSystem;
   delete pFileSystem;
   return hr;
}

bool GetNetworkRelatedResourceDirFromReg(CString network, CString* path)
{
	HKEY hKey = 0;
	CString sub_key = CString(TSREGKEY_TL) + "\\" + network;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
									  sub_key, 
									  NULL,
									  KEY_READ, 
									  &hKey))
	{
		DWORD dwType = REG_SZ;
		TCHAR buf[MAXBUF] = {_T('\0')};
		DWORD dwSize = MAXBUF - 1;

		if (ERROR_SUCCESS == RegQueryValueEx(hKey,
											 FRIENDLY_PATH,
											 NULL,
											 &dwType,
											 (LPBYTE)buf,
											 &dwSize))
		{
			*path = buf;
			return true;
		}
	}

	return false;
}

bool IsNetworkRelatedResourceDirCHM(CString path)
{
	path.TrimRight();
	CString extension = path.Right(4 * sizeof(TCHAR));
	return 0 == extension.CompareNoCase(CHM_DEFAULT);
}

CString ExtractResourceDir(CString path)
{
// For example, from string
// "d:\TShooter Projects\TShootLocal\http\lan_chm\lan.chm"
// need to extract "d:\TShooter Projects\TShootLocal\http\lan_chm"
	int index =0;
	CString strCHM = ExtractCHM(path);
	CString strRes;

	if (strCHM.GetLength())
	{
		index = path.Find(strCHM);
		if (index > 0 && path.GetAt(index-sizeof(_T('\\'))) == _T('\\'))
			strRes = path.Left(index-sizeof(_T('\\')));
		else if (index == 0)
			strRes = "";
	}

	return strRes;
}

CString ExtractFileName(CString path)
{
// Extracts file name (with extension)
	int index =0;

	if (-1 == (index = path.ReverseFind(_T('\\'))))
	{
		if (-1 == (index = path.ReverseFind(_T(':'))))
			index = 0;
		else
			index += sizeof(_T(':'));
	}
	else
		index += sizeof(_T('\\'));

	return (LPCTSTR)path + index;
}

CString ExtractCHM(CString path)
{
// For example, from string
// "d:\TShooter Projects\TShootLocal\http\lan_chm\lan.chm"
// need to extract "lan.chm"
	if (!IsNetworkRelatedResourceDirCHM(path))
		return "";
	return ExtractFileName(path);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\crc.h ===
//
// MODULE: CRC.H
//
// PURPOSE: Header for CRC support
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CCRC_H_
#define __CCRC_H_ 1

#include "GenException.h"

inline CString GlobFormatMessage(DWORD dwLastError)
{
	CString strMessage;
	void *lpvMessage;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 0, NULL);
	strMessage = (LPCTSTR) lpvMessage;
	LocalFree(lpvMessage);
	return strMessage;
}

class CCRC
{
	const DWORD POLYNOMIAL;
public:
	CCRC();
	
	DWORD DscEncode(LPCTSTR szDsc);
	void AppendCRC(LPCTSTR szCache, DWORD dwCRCValue);
	bool Decode(LPCTSTR szDsc, LPCTSTR szCache, const CString& strCacheFileWithinCHM);
	

protected:

	DWORD dwCrcTable[256];

	void BuildCrcTable();
	DWORD ComputeCRC(LPCSTR sznBuffer, DWORD dwBufSize, DWORD dwAccum);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\cathelp.cpp ===
//=--------------------------------------------------------------------------=
// CatHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "stdafx.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\crc.cpp ===
//
// MODULE: CRC.CPP
//
// PURPOSE: Cache File CRC Calculator Class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "crc.h"

#include <stdlib.h>
#include <memory.h>

#include "ChmRead.h"

CCRC::CCRC() : POLYNOMIAL(0x04C11DB7)
{
	dwCrcTable[0] = 0;
	BuildCrcTable();
	return;
}

DWORD CCRC::DscEncode(LPCTSTR szDsc)
{
	DWORD dwBytesRead;
	DWORD dwCRCValue;
	const int BUF_SIZE = 4096;
	char sznInputFileBuf[BUF_SIZE + 1];
	if (NULL == szDsc)
	{
		CGenException *pErr = new CGenException;
		pErr->m_OsError = 0;
		pErr->m_strError = _T("The dsc file was not specified.");
		throw pErr;
	}
	// Read the source file.
	HANDLE hFile = CreateFile(szDsc,
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("Dsc file, %s was not opened.\nReason: %s"),
				szDsc, (LPCTSTR) strErr);
		throw pErr;
	}
	// Get the crc.
	dwCRCValue = 0xFFFFFFFF;
	do
	{
		if (!ReadFile(hFile, (LPVOID) sznInputFileBuf, BUF_SIZE, &dwBytesRead, NULL))
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("The dsc file, %s could not be read.\nReason: %s"),
					szDsc, (LPCTSTR) strErr);
			CloseHandle(hFile);
			throw pErr;
		}
		sznInputFileBuf[dwBytesRead] = NULL;
		dwCRCValue = ComputeCRC(sznInputFileBuf, dwBytesRead, dwCRCValue);
	} while(BUF_SIZE == dwBytesRead);
	CloseHandle(hFile);
	return dwCRCValue;
}

void CCRC::AppendCRC(LPCTSTR szCache, DWORD dwCRCValue)
{
	DWORD dwBytesWritten;
	// Open the cache file.
	HANDLE hDestFile = CreateFile(szCache,
						GENERIC_WRITE,
						0,	// No Sharing.
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_WRITE_THROUGH |
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL);
	if (INVALID_HANDLE_VALUE == hDestFile)
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("The cache file, %s could not be opened.\nReason: %s"),
			szCache, (LPCTSTR) strErr);
		throw pErr;
	}	
	if (0xFFFFFFFF == SetFilePointer(hDestFile, 0, NULL, FILE_END))
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("Seek to end of the cache file, %s failed.\nReason: %s"),
			szCache, (LPCTSTR) strErr);
		CloseHandle(hDestFile);
		throw pErr;
	}
	// Append crc value.
	if (!WriteFile(hDestFile, (LPVOID) &dwCRCValue, 4, &dwBytesWritten, NULL))
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("The crc value was not appened to cache file %s.\nReason: %s"),
						szCache, (LPCTSTR) strErr);
		CloseHandle(hDestFile);
		throw pErr;
	}
	CloseHandle(hDestFile);
	if (4 != dwBytesWritten)
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("%d bytes of the crc were not appended to the cache file %s.Reason: %s"),
						4 - dwBytesWritten, szCache, (LPCTSTR) strErr);		
		throw pErr;
	}
	return;
}

bool CCRC::Decode(LPCTSTR szDsc, LPCTSTR szCache, const CString& strCacheFileWithinCHM)
{
	DWORD dwDecodeFileCrc;
	DWORD dwComputedCrc;
	DWORD dwBytesRead;
	DWORD dwLen;
	char sznDecodeBytes[5] = {0};
	bool bRet = true;
	bool bUseCHM = strCacheFileWithinCHM.GetLength() != 0;

	if (NULL == szDsc)
	{
		CGenException *pErr = new CGenException;
		pErr->m_OsError = 0;
		pErr->m_strError = _T("The source file was not specified.");
		throw pErr;
	}
	if (NULL == szCache)
	{
		CGenException *pErr = new CGenException;
		pErr->m_OsError = 0;
		pErr->m_strError = _T("The destination file was not specified.");
		throw pErr;
	}

	if (bUseCHM)
	{
		void* buf =NULL;

		if (S_OK != ::ReadChmFile(szCache, strCacheFileWithinCHM, &buf, &dwBytesRead))
		{
			CGenException *pErr = new CGenException;
			pErr->m_OsError = 0;
			pErr->m_strError = _T("Can not read cache from the CHM file.");
			throw pErr;
		}
		
		if (dwBytesRead < 5)
			return false;

		memcpy(sznDecodeBytes, (char*)buf + dwBytesRead - 4, 4);
	}
	else
	{
		// Read the source file.
		HANDLE hDecodeFile = CreateFile(szCache,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_SEQUENTIAL_SCAN,
							NULL);
		if (INVALID_HANDLE_VALUE == hDecodeFile)
		{	// Should continue as if the check sums did not match.
			return false;
		}
		// Return false if the file is shorter than 1 byte + crc length.
		dwLen = GetFileSize(hDecodeFile, NULL);
		if (0xFFFFFFFF == dwLen)
		{
			CGenException *pExc = new CGenException;
			pExc->m_OsError = GetLastError();
			pExc->m_strOsMsg = GlobFormatMessage(pExc->m_OsError);
			pExc->m_strError.Format(
					_T("Could not get the size of cache file %s.\nReason: %s"),
					szCache, (LPCTSTR) pExc->m_strOsMsg);
			CloseHandle(hDecodeFile);
			throw pExc;
		}
		if (dwLen < 5)
		{
			CloseHandle(hDecodeFile);
			return false;
		}
		// Seek to end and backup 4 bytes.
		if (0xFFFFFFFF == SetFilePointer(hDecodeFile, -4, NULL, FILE_END))
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("Seek to end of the cache file, %s failed.\nReason: %s"),
				szCache, (LPCTSTR) strErr);
			CloseHandle(hDecodeFile);
			throw pErr;
		}
		if (!ReadFile(hDecodeFile, (LPVOID) sznDecodeBytes, 4, &dwBytesRead, NULL))
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("The cache file, %s could not be read.\nReason: %s"),
					szDsc, (LPCTSTR) strErr);
			CloseHandle(hDecodeFile);
			throw pErr;
		}
		if (4 != dwBytesRead)
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("%d bytes of the cache file were not read.\nReason: %s"),
					4 - dwBytesRead, szDsc, (LPCTSTR) strErr);
			CloseHandle(hDecodeFile);
			throw pErr;
		}
		CloseHandle(hDecodeFile);
	}
	
	// Read the crc.
	sznDecodeBytes[4] = NULL;
	DWORD byte;
	byte = (BYTE) sznDecodeBytes[0];
	dwDecodeFileCrc = byte;
	byte = (BYTE) sznDecodeBytes[1];
	byte <<= 8;
	dwDecodeFileCrc |= byte;
	byte = (BYTE) sznDecodeBytes[2];
	byte <<= 16;
	dwDecodeFileCrc |= byte;
	byte = (BYTE) sznDecodeBytes[3];
	byte <<= 24;
	dwDecodeFileCrc |= byte;
	// Get the crc value.
	dwComputedCrc = DscEncode(szDsc);
	if (dwComputedCrc != dwDecodeFileCrc)
		bRet = false;
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\cachegen.h ===
//
// MODULE: CACHEGEN.H
//
// PURPOSE: Cache Generator Header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. >>> Data members in this file could sure use documentation!  - JM
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CACHEGEN_H_
#define __CACHEGEN_H_ 1

typedef struct _GTS_CACHE_FILE_HEADER
{
	unsigned char signature[8];
	UINT crcdsc;
	UINT crcself;
	UINT count; // item count of node data (one item = a set node and rec node structure)
	UINT netoffset;
	unsigned char reserved[28];
} GTS_CACHE_FILE_HEADER;


// -- property data --
//

// property start block
typedef struct _GTS_CACHE_PROP_NETSTART_BLK
{
	UINT netpropoffset;
	UINT netpropcount;
	UINT nodecountnetwork;
	UINT nodecountfile;
} GTS_CACHE_PROP_NETSTART_BLK;

// node item offset block
typedef struct _GTS_CACHE_PROP_NODEOFF_BLK
{
	UINT nodeid;
	UINT nodeoffset;
} GTS_CACHE_PROP_NODEOFF_BLK;

// node item offset block
typedef struct _GTS_CACHE_PROP_NODESTART_BLK
{
	UINT labelnode;
	UINT nodestringcount;
} GTS_CACHE_PROP_NODESTART_BLK;

// node item offset block
typedef struct _GTS_CACHE_PROP_STR_BLK
{
	UINT nameoffset;
	UINT stringoffset;
} GTS_CACHE_PROP_STR_BLK;

#define G_SYMBOLIC_NAME	"GSN"
#define G_FULL_NAME		"GFN"
#define G_S0_NAME		"GS0"
#define G_S1_NAME		"GS1"


// node property support
/*
typedef struct _GTS_NODE_SUPPORT
{
	fpos_t ctlposition;
	fpos_t dataposition;
	UINT nodeid;
	ESTDLBL albl;
	CString sGSymName;
	CString sGFullName;
	CString sGState0Name;
	CString sGState1Name;
	CString sHProbTxt;
	CString sHNodeHd;
	CArray<CString,CString> sHNodeTxt;

} GTS_NODE_SUPPORT;
*/

class GTS_NODE_ITEM : public CObject
{
public:
	GTS_NODE_ITEM(CString sStringN) { sStringName = sStringN; };
	CString sStringName;
	CStringArray sStringArr;
	fpos_t ctlposition;
	fpos_t snameposition;
	fpos_t sdataposition;
};


class GTS_NODE_SUPPORT : public CObject
{
public:
	fpos_t ctlposition;
	fpos_t dataposition;
	UINT nodeid;
	UINT albl;
	CPtrList lData;
};

// -- recommendation data --
//
typedef struct _GTS_CACHE_NODE
{
	UINT node; // may be more than one UINT if count > 1
	UINT state; // may be more than one UINT if count > 1
} GTS_CACHE_NODE;

// reference structure for set node and rec node
typedef struct _GTS_CACHE_FILE_SETDATA
{
	UINT count;
	GTS_CACHE_NODE item[1]; // may be more than one UINT if count > 1
} GTS_CACHE_FILE_SETDATA;

// reference structure for rec node
typedef struct _GTS_CACHE_FILE_RECDATA
{
	UINT count;
	UINT item[1]; // may be more than one UINT if count > 1
} GTS_CACHE_FILE_RECDATA;

// -- node ordering structure
typedef struct _GTS_NODE_ORDER
{
	UINT nodeid;
	int depth;
} GTS_NODE_ORDER;


// cache item data
/*
typedef struct _BN_CACHE_ITEM {
	UINT uNodeCount, uRecCount;
	UINT *uName;
	UINT *uValue;
	UINT *uRec;
} BN_CACHE_ITEM;
*/

#define GTS_CACHE_SIG	"TSCACH02"

#define STATE_UNKNOWN	102
#define MAX_SYM_NAME_BUF_LEN 500

class GTSCacheGenerator
{
	friend class BCache;

public:
	GTSCacheGenerator(	BOOL bScanAll = FALSE, \
						const char *szLogFile = NULL, \
						const char *szBNTSLogFile = NULL);
	~GTSCacheGenerator();
	static bool TcharToChar(char szOut[], LPCTSTR szIn, int &OutLen);

	BOOL ReadCacheFileHeader(CString &sCacheFilename, const CString& strCacheFileWithinCHM);
	BOOL GetNextCacheEntryFromFile(BOOL &bErr, CBNCache *pCache);
	

	BOOL FindNetworkProperty(LPCSTR szName, CString &sResult, int index = 0);
	BOOL FindNodeProperty(UINT nodeid, LPCSTR szName, CString &sResult, int index = 0);
	BOOL IsNodePresent(UINT nodeid);
	int GetNodeCount();
	BOOL GetNodeIDFromSymName(LPCTSTR szSymName, UINT &nodeid);
	BOOL GetLabelOfNode(UINT nodeid, UINT &lbl);


protected:
	BOOL NodeTraverse(	FILE *fp, \
						BNTS *bp, \
						int depth, \
						CArray<int,int> &newnodes, \
						CArray<int,int> &newstates, \
						int currnode, \
						int currstate);
	void UninstantiateAll(BNTS *bp);
	void SetNodes(BNTS *bp, CArray<int,int> &nodes, CArray<int,int> &states);
	void LogOut(TCHAR *szcFormat, ...);
	BOOL GetNCEFF(BN_CACHE_ITEM *pCacheItem, CBNCache *pCache);

	void SaveNetItem(CPtrList *nsp, BNTS *bp, FILE *fp, LPCSTR name);

protected:
	BOOL m_bScanAll;
	UINT m_nCount;
	UINT m_nItemCount;
	CArray<int,int> m_oldnodes;
	const char *m_szBNTSLogFile;
	FILE *m_fp;
	fpos_t m_headposition;
	UINT m_netstartoffset;
	char *m_filedata;
	GTS_NODE_ORDER *m_nodeorder;
	GTS_CACHE_FILE_SETDATA *m_cachepos;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\crccompute.cpp ===
//
// MODULE: CRCCOMPUTE.CPP
//
// PURPOSE: CRC Calculator
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach (based on existing CRC designs)
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "crc.h"

void CCRC::BuildCrcTable()
{
	DWORD dwX;
	int y;
	DWORD dwAccum;
	for (dwX = 0; dwX < 256; dwX++)
	{
		dwAccum = dwX << 24;
		for (y = 0; y < 8; y++)
		{
			if (dwAccum & 0x80000000)
				dwAccum = (dwAccum << 1) ^ POLYNOMIAL;
			else
				dwAccum <<= 1;
		}
		dwCrcTable[dwX] = dwAccum;
	}
	return;
}

DWORD CCRC::ComputeCRC(LPCSTR sznBuffer, DWORD dwBufSize, DWORD dwAccum)
{
	DWORD dwX;
	DWORD dwY;
	// DWORD dwAccum = 0xFFFFFFFF;
	for (dwX = 0; dwX < dwBufSize; dwX++)
	{
		dwY = ((dwAccum >> 24) ^ *sznBuffer++) & 0xFF;
		dwAccum = (dwAccum << 8) ^ dwCrcTable[dwY];
	}
	return dwAccum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\errorenums.h ===
//
// MODULE: ERRORENUMS.H
//
// PURPOSE: Defines error messages that are returned by GetExtendedError.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

// Error numbers for the ocx.

#ifndef __ERRORENUMS_H_RWM
#define __ERRORENUMS_H_RWM

// All of the error values in this file need to be unique.

// The original error messages from the server version.
#include "apgtsevt.h"

// Errors for the down load portion.
// These are hresults.

// GetExtendedError returns the lower 16 bits.

enum DLSTATTYPES {

	// normal
	LTSC_OK	=			0,
	LTSC_STARTBIND,		//1
	LTSC_RCVDATA,		//2
	LTSC_DATADONE,		//3
	LTSC_STOPBIND,		//4
	LTSC_NOMOREITEMS,	//5


	LTSC_START = 10,
	LTSC_STOP = 10,
	LTSC_FIRST = 20,

	// error
	LTSCERR_NOPATH =		1000,
	LTSCERR_NOMEM,			//1001
	LTSCERR_DNLD,			//1002
	LTSCERR_STOPBINDINT,	//1003
	LTSCERR_STOPBINDPROC,	//1004
	LTSCERR_UNSUPP,			//1005
	LTSCERR_NOITEMS,		//1006
	LTSCERR_UNKNATYPE,		//1007
	LTSCERR_DNLDNOTDONE,	//1008
	LTSCERR_FILEUPDATE,		//1009
	LTSCERR_BASEKQ,			//1010
	LTSCERR_NOBASEPATH,		//1011

	
	// extended error for debugging
	LTSCERR_PARAMMISS =		2000,
	LTSCERR_PARAMSLASH,		//2001
	LTSCERR_PARAMNODOT,		//2002
	LTSCERR_KEYOPEN,		//2003
	LTSCERR_KEYOPEN2,		//2004
	LTSCERR_KEYQUERY,		//2005
	LTSCERR_KEYCREATE,		//2006
	LTSCERR_KEYUNSUPP,		//2007
	LTSCERR_FILEWRITE,		//2008
	LTSCERR_KEYSET1,		//2009
	LTSCERR_KEYSET2,		//2010
	LTSCERR_KEYSET3,		//2011
	LTSCERR_BADTYPE,		//2012
	LTSCERR_CABWRITE,		//2013
	

	// Trouble Shooter Codes
	TSERR_SCRIPT				= ((DWORD)0xC0000800L),		// Parameters from VB not decoded.
	TSERR_ENGINE				= ((DWORD)0xC0000801L),		// DSC file could not be loaded.
	TSERR_ENGINE_BNTS			= ((DWORD)0xC0001801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_REC		= ((DWORD)0xC0002801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ		= ((DWORD)0xC0003801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_CAB	= ((DWORD)0xC0004801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_CACH	= ((DWORD)0xC0005801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_NCAB	= ((DWORD)0xC0006801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_CHECK		= ((DWORD)0xC0007801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_GEN	= ((DWORD)0xC0008801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_EXTRACT		= ((DWORD)0xC0009801L),		// DSC file could not be loaded.  Cab file not extracted properly.
	TSERR_ENGINE_CACHE_LOW		= ((DWORD)0xC0009802L),		// Had a tsc cache miss while converting symoblic node names to numbers.

	TSERR_RESOURCE			= ((DWORD)0xC0000802L),		// HTI file or other resource not loaded.
	TSERR_RES_MISSING		= ((DWORD)0xC0000803L),		// An include file is missing.
	TSERR_AT_START			= ((DWORD)0xC0000804L),		// Can not backup from the problem page.
	TSERR_NOT_STARTED		= ((DWORD)0xC0000805L),		// Can not use the ProblemPage to start the trouble shooter.
	TSERR_LIB_STATE_INFO	= ((DWORD)0xC0000806L),		// Could not get an interface to the state info class.

};

// Throws a CBasicException.
void ReportError(DLSTATTYPES Error);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\download.cpp ===
//
// MODULE:  DOWNLOAD.CPP
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on PROGRESS.CPP from Microsoft Platform Preview SDK
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"

class CTSHOOTCtrl;


#include "download.h"
#include "dnldlist.h"

#include "TSHOOT.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "apgtsfst.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "TSHOOTCtl.h"

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(CTSHOOTCtrl *pEvent, DLITEMTYPES dwItem)
{
    m_pbinding = NULL;
    m_pstm = NULL;
    m_cRef = 1;

	m_pEvent = pEvent;
	m_data = NULL;
	m_datalen = 0;
	m_dwItem = dwItem;

}  // CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::~CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
	if (m_data)
		delete[] m_data;
}  // ~CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
        {
        *ppv = this;
        AddRef();
        return S_OK;
        }
    return E_NOINTERFACE;
}  // CBindStatusCallback::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    if (m_pbinding != NULL)
        m_pbinding->Release();
    m_pbinding = pbinding;
    if (m_pbinding != NULL)
	{
        m_pbinding->AddRef();
		//m_pEvent->StatusEventHelper(m_dwItem, LTSC_STARTBIND);
	}
    return S_OK;
}  // CBindStatusCallback::OnStartBinding

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
	return E_NOTIMPL;
}  // CBindStatusCallback::GetPriority

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CBindStatusCallback::OnLowResource

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
	m_pEvent->ProgressEventHelper(m_dwItem, ulProgress, (ulProgress>ulProgressMax)?ulProgress:ulProgressMax);

    return(NOERROR);
}  // CBindStatusCallback::OnProgress

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    if (hrStatus)
		m_pEvent->StatusEventHelper(m_dwItem, LTSCERR_STOPBINDINT, hrStatus & 0xFFFF, TRUE);
	else 
	{
		DLSTATTYPES dwStat = m_pEvent->ProcessReceivedData(m_dwItem, m_data, m_datalen);

		if (dwStat == LTSC_OK)
			m_pEvent->StatusEventHelper(m_dwItem, LTSC_STOPBIND, 0, TRUE);
		else
			m_pEvent->StatusEventHelper(m_dwItem, LTSCERR_STOPBINDPROC, dwStat, TRUE);
	}


	if (m_pbinding)
	{
		m_pbinding->Release();
		m_pbinding = NULL;
	}

    return S_OK;
}  // CBindStatusCallback::OnStopBinding

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    *pgrfBINDF |= BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CBindStatusCallback::GetBindInfo

 

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
	HRESULT hr=S_OK;
	DWORD dStrlength=0;

	//m_pEvent->StatusEventHelper(m_dwItem, LTSC_START);

	// Get the Stream passed
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {
        if (!m_pstm && pstgmed->tymed == TYMED_ISTREAM)
	    {
		    m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
			//m_pEvent->StatusEventHelper(m_dwItem, LTSC_FIRST);
    	}
    }

    // If there is some data to be read then go ahead and read them
    if (m_pstm && dwSize)
	{
        DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		do 
		{
			TCHAR * pNewstr = new TCHAR[dwSize + 1 + m_datalen];
			
			if (pNewstr==NULL) 
			{
				hr = S_FALSE;
				break;
			}

			hr = m_pstm->Read(&pNewstr[m_datalen], dwSize, &dwActuallyRead);

			if (dwActuallyRead) 
			{
				pNewstr[m_datalen + dwActuallyRead] = 0;

				if (m_data && m_datalen) 
				{
					memcpy(pNewstr, m_data, m_datalen);
					delete[] m_data;
					m_data = NULL;
				}

				//m_pEvent->StatusEventHelper(m_dwItem, LTSC_RCVDATA);

				m_data = pNewstr;
				m_datalen += dwActuallyRead;
			}
			else
				delete[] pNewstr;

		} while (!(hr == E_PENDING || hr == S_FALSE) && SUCCEEDED(hr));
	}

	if (BSCF_LASTDATANOTIFICATION & grfBSCF)
	{
        if (m_pstm)
            m_pstm->Release();

		hr=S_OK;  // If it was the last data then we should return S_OK as we just finished reading everything
	
		//m_pEvent->StatusEventHelper(m_dwItem, LTSC_DATADONE);
	}

	//m_pEvent->StatusEventHelper(m_dwItem, LTSC_STOP);

    return hr;
}  // CBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}  // CBindStatusCallback::OnObjectAvailable


// ===========================================================================
//                           CDownload Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CDownload::CDownload
// ---------------------------------------------------------------------------
CDownload::CDownload()
{
    m_pmk = 0;
    m_pbc = 0;
    m_pbsc = 0;
}  // CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::~CDownload
// ---------------------------------------------------------------------------
CDownload::~CDownload()
{
    if (m_pmk)
        m_pmk->Release();
    if (m_pbc)
        m_pbc->Release();
    if (m_pbsc)
        m_pbsc->Release();
}  // ~CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::DoDownload
// ---------------------------------------------------------------------------
 HRESULT
CDownload::DoDownload(CTSHOOTCtrl *pEvent, LPCTSTR pURL, DLITEMTYPES dwItem)
{
    IStream* pstm = NULL;
    HRESULT hr;
#ifndef _UNICODE
	WCHAR rgwchPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pURL, -1, rgwchPath, MAX_PATH);
    hr = CreateURLMoniker(NULL, rgwchPath, &m_pmk);
#else
	hr = CreateURLMoniker(NULL, pURL, &m_pmk);
#endif
    if (FAILED(hr))
        goto LErrExit;

    m_pbsc = new CBindStatusCallback(pEvent, dwItem);
    if (m_pbsc == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
        }
    hr = CreateBindCtx(0, &m_pbc);
    if (FAILED(hr))
        goto LErrExit;
    hr = RegisterBindStatusCallback(m_pbc,
            m_pbsc,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;
    hr = m_pmk->BindToStorage(m_pbc, 0, IID_IStream, (void**)&pstm);
    if (FAILED(hr))
        goto LErrExit;
    return hr;
	while (S_OK == m_pmk->IsRunning(m_pbc, NULL, NULL));
			Sleep(200);
LErrExit:
    if (m_pbc != NULL)
        {
        m_pbc->Release();
        m_pbc = NULL;
        }
    if (m_pbsc != NULL)
        {
        m_pbsc->Release();
        m_pbsc = NULL;
        }
    if (m_pmk != NULL)
        {
        m_pmk->Release();
        m_pmk = NULL;
        }
	if (pstm)
		{
		pstm->Release();
		pstm = NULL;
		}
    return hr;
}  // CDownload::DoDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\download.h ===
//
// MODULE:  DOWNLOAD.H
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on PROGRESS.CPP from Microsoft Platform Preview SDK
// 2. Not supported functionality 3/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//
#include "urlmon.h"
#include "wininet.h"
#include "resource.h"
#include "commctrl.h"

#define EDIT_BOX_LIMIT 0x7FFF    //  The Edit box limit

//
#include "ErrorEnums.h"
//
enum DLITEMTYPES {
	DLITEM_INI = 0,
	DLITEM_DSC = 1,
};


//
//
class CDownload {
  public:
    CDownload();
    ~CDownload();
    HRESULT DoDownload(CTSHOOTCtrl *pEvent, LPCTSTR pURL, DLITEMTYPES dwItem);

  private:
    IMoniker*            m_pmk;
    IBindCtx*            m_pbc;
    IBindStatusCallback* m_pbsc;
};

//
//
class CBindStatusCallback : public IBindStatusCallback {
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // constructors/destructors
    CBindStatusCallback(CTSHOOTCtrl *pEvent, DLITEMTYPES dwItem);
    ~CBindStatusCallback();

    // data members
    DWORD           m_cRef;
    IBinding*       m_pbinding;
	IStream*        m_pstm;

	CTSHOOTCtrl *m_pEvent;
	DLITEMTYPES m_dwItem;

	TCHAR *m_data;
	int m_datalen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\dnldlist.h ===
//
// MODULE:  DNLDIST.H
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: Not supported functionality 3/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//
//
//
class CDnldObj : public CObject
{
public:
	CDnldObj(CString &sType, CString &sFilename, DWORD dwVersion, CString &sFriendlyName, CString &sKeyName);
	~CDnldObj();

	CString m_sType;
	CString m_sFilename;
	CString m_sKeyname;
	DWORD m_dwVersion;
	CString m_sFriendlyName;
	CString	m_sExt;
};

//
//
class CDnldObjList : public CObList
{
public:
	CDnldObjList();
	~CDnldObjList();

	void RemoveHead();
	void RemoveAll();
	void AddTail(CDnldObj *pDnld);

	VOID SetFirstItem();
	BOOL FindNextItem();

	const CString GetCurrFile();
	const CString GetCurrFileKey();
	const CString GetCurrFriendly();
	const CString GetCurrType();
	const CString GetCurrExt();
	DWORD CDnldObjList::GetCurrVersion();

protected:

	POSITION m_pos;
	CDnldObj *m_pDnld;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\dnldlist.cpp ===
//
// MODULE:  DNLDIST.CPP
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"

#include "apgts.h"
#include "dnldlist.h"

//--------------------------------------------------------------------
//
CDnldObj::CDnldObj(CString &sType,
				   CString &sFilename, 
				   DWORD dwVersion, 
				   CString &sFriendlyName, 
				   CString &sKeyName)
{
	m_sType = sType;
	m_sFilename = sFilename;
	m_sKeyname = sKeyName;
	m_dwVersion = dwVersion;
	m_sFriendlyName = sFriendlyName;
	
	// force all ext entries to .DSZ
	m_sExt = DSC_COMPRESSED;
	//	int pos = sFilename.Find(_T('.'));
	//	if (pos != -1) 
	//		m_sExt = sFilename.Right(sFilename.GetLength() - pos);
};

//
//
CDnldObj::~CDnldObj()
{
}

//--------------------------------------------------------------------
//
CDnldObjList::CDnldObjList()
{
	m_pos = NULL;
	m_pDnld = NULL;
}

//
//
CDnldObjList::~CDnldObjList()
{
	RemoveAll();
}

//
//
void CDnldObjList::RemoveHead()
{
	if (this->IsEmpty())
		return;

	CDnldObj *pDnld = (CDnldObj *)CObList::RemoveHead();
	if (pDnld)
		delete pDnld;
}

//
//
void CDnldObjList::AddTail(CDnldObj *pDnld)
{
	if (!pDnld)
		return;

	CObList::AddTail(pDnld);
}

//
//
void CDnldObjList::RemoveAll()
{
	CDnldObj *pDnld;
	POSITION pos;

	if(!this->IsEmpty()) 
	{
		pos = this->GetHeadPosition();
		while(pos != NULL) 
		{
			pDnld = (CDnldObj *)this->GetNext(pos);
			delete pDnld;
		}
	}

	CObList::RemoveAll();
}

//
//
VOID CDnldObjList::SetFirstItem()
{
	m_pDnld = NULL;
	m_pos = this->GetHeadPosition();
}

//
//
BOOL CDnldObjList::FindNextItem()
{
	if(this->IsEmpty()) 
		return FALSE;

	if (m_pos == NULL)
		return FALSE;

	m_pDnld = (CDnldObj *)this->GetNext(m_pos);
	return (m_pDnld != NULL);
}	

//
//
const CString CDnldObjList::GetCurrFile()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sFilename;
}

//
//
const CString CDnldObjList::GetCurrFileKey()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sKeyname;
}

//
//
const CString CDnldObjList::GetCurrFriendly()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sFriendlyName;
}

//
//
const CString CDnldObjList::GetCurrType()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sType;
}

//
//
const CString CDnldObjList::GetCurrExt()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sExt;
}

//
//
DWORD CDnldObjList::GetCurrVersion()
{
	if (m_pDnld == NULL)
		return 0;

	return m_pDnld->m_dwVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\fdi.h ===
/*
 *  FDI.H -- File Decompression Interface
 *
 *  Copyright (C) Microsoft Corporation 1993-1997
 *  All Rights Reserved.
 */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)

//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_TYPES_FCI_FDI

/*
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since FCI concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but FCI does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since FCI compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require FDI to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint,...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *
 *              default:
 *                  return 0;               // more messages may be defined
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

#ifndef INCLUDED_FDI
#define INCLUDED_FDI    1

//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)


/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of FCI.LIB used to
        //              create the cabinet and the FDI.LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinets
        //              in a set.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When MAKECAB.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT,
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;

/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    FDIERROR erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT,                       // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    };
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FDI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
//** Memory functions for FDI
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
//** File I/O functions for FDI
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);

#define FNOPEN(fn) int FAR DIAMONDAPI fn(char FAR *pszFile, int oflag, int pmode)
#define FNREAD(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNWRITE(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNCLOSE(fn) int FAR DIAMONDAPI fn(int hf)
#define FNSEEK(fn) long FAR DIAMONDAPI fn(int hf, long dist, int seektype)



/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          FCI will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    char FAR *psz1;
    char FAR *psz2;
    char FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    int       hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)
    USHORT    iFolder;                  // Folder number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintENUMERATE        // Starting enumeration
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *      fdintENUMERATE        // Ending enumeration
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *          pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *
 *              IMPORTANT NOTE IMPORTANT:
 *                  pfdin->cb is overloaded to no longer be the size of
 *                  the file but to be a binary indicated run or not
 *
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintENUMERATE:
 *        Called once after a call to FDICopy() starts scanning a CAB's
 *        CFFILE entries, and again when there are no more CFFILE entries.
 *        If CAB spanning occurs, an additional call will occur after the
 *        first spanned file is completed.  If the pfdin->iFolder value is
 *        changed from zero, additional calls will occur next time it reaches
 *        zero.  If iFolder is changed to zero, FDICopy will terminate, as if
 *        there were no more CFFILE entries.  Primarily intended to allow an
 *        application with it's own file list to help FDI advance quickly to
 *        a CFFILE entry of interest.  Can also be used to allow an
 *        application to determine the cb values for each file in the CAB.
 *      Entry:
 *        pfdin->cb        = current CFFILE position
 *        pfdin->iFolder   = number of files remaining
 *        pfdin->setID     = current CAB's setID value
 *      Exit-Don't Care:
 *        Don't change anything.
 *        Return anything but -1.
 *      Exit-Forcing a skip:
 *        pfdin->cb        = desired CFFILE position
 *        pfdin->iFolder   = desired # of files remaining
 *        Return anything but -1.
 *      Exit-Stop:
 *        pfdin->iFolder    = set to 0
 *        Return anything but -1.
 *      Exit-Failure:
 *        Return -1 => Abort FDICopy call ("user aborted".)
 *      Notes:
 *        This call can be ignored by applications which want normal file
 *        searching.  The application can adjust the supplied values to
 *        force FDICopy() to continue it's search at another location, or
 *        to force FDICopy() to terminate the search, by setting iFolder to 0.
 *        (FDICopy() will report no error when terminated this way.)
 *        FDI has no means to verify the supplied cb or iFolder values.
 *        Arbitrary values are likely to cause undesirable results.  An
 *        application should cross-check pfdin->setID to be certain the
 *        external database is in sync with the CAB.  Reverse-skips are OK
 *        (but may be inefficient) unless fdintNEXT_CABINET has been called.
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET,              // File continued to next cabinet
    fdintENUMERATE,                 // Enumeration status
} FDINOTIFICATIONTYPE; /* fdint */

typedef int (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                           PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) int FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                              PFDINOTIFICATION    pfdin)


/*** cpuType values for FDICreate()
 *
 *  (Ignored by 32-bit FDI.)
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 */
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);


/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.
 */
BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici);


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).
 */
BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char FAR     *pszCabinet,
                            char FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);


/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 */
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_FDI

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\enumstd.h ===
//
// MODULE:  ENUMSTD.H
//
// PURPOSE: enumerations relevant to belief networks
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Apparently originated at MSR
// 
// ORIGINAL DATE: unknown
//
// NOTES: 
// 1. included because we use ESTDLBL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef _ENUMSTD_H_
#define _ENUMSTD_H_

////////////////////////////////////////////////////////////////////
//	Property flags
////////////////////////////////////////////////////////////////////
const UINT fPropString = 1;			//  Property is a string (!fPropString ==> real)
const UINT fPropArray = 2;			//	Property is an array (!fPropArray  ==> scalar)
const UINT fPropChoice = 4;			//	Property is an enumerated value
const UINT fPropStandard = 8;		//  Property is standard (stored in Registry)
const UINT fPropPersist = 16;		//  Property is persistent (stored in Registry)

////////////////////////////////////////////////////////////////////
//	Definitions to enable usage of "MS_" standard properties
////////////////////////////////////////////////////////////////////
enum ESTDPROP
{
	ESTDP_label,			//  Node troubleshooting label (choice)
	ESTDP_cost_fix,			//  Cost to fix	(real)
	ESTDP_cost_observe,		//  Cost to observe (real)
	ESTDP_category,			//  Category (string)
	ESTDP_normalState,		//  Index of troubleshooting "normal" state (int)
	ESTDP_max				//  End
};

enum ESTDLBL		//  VOI-relative node label
{
	ESTDLBL_other,
	ESTDLBL_hypo,
	ESTDLBL_info,
	ESTDLBL_problem,
	ESTDLBL_fixobs,
	ESTDLBL_fixunobs,
	ESTDLBL_unfix,
	ESTDLBL_config,
	ESTDLBL_max
};


#endif // _ENUMSTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\fs.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "stdafx.h"

// to avoid linker error related to undefined GUIDs
#include "initguid.h"
#include "fs.h"

#pragma data_seg(".text", "CODE")

static const WCHAR txtwUncompressed[] =  L"uncompressed";

#pragma data_seg()

// returns poinder inside pszPath string that points to file name
// for example in "d:\Tshooter\http\lan.chm\lan.htm" it points
// to "lan.htm"
LPCSTR FindFilePortion(LPCSTR pszPath)
{
	int index =0;
	CString path(pszPath);

	if (-1 == (index = path.ReverseFind(_T('\\'))))
	{
		if (-1 == (index = path.ReverseFind(_T('/'))))
			index = 0;
		else
			index += sizeof(_T('/'));
	}
	else
		index += sizeof(_T('\\'));

	return pszPath + index;
}

CFileSystem::CFileSystem()
{
   m_pITStorage    = NULL;
   m_pStorage      = NULL;
   m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
  ReleaseObjPtr(m_pStorage);
  ReleaseObjPtr(m_pITStorage);
}

HRESULT CFileSystem::Init(void)
{
   if (! m_pITStorage) {
      IClassFactory* pICFITStorage;

      HRESULT hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **) &pICFITStorage);

      if (!SUCCEEDED(hr)) 
         return hr;
      
      hr = pICFITStorage->CreateInstance(NULL, IID_ITStorage,(void **) &m_pITStorage);
      ReleaseObjPtr( pICFITStorage );

      if (!SUCCEEDED(hr)) 
         return hr;
      
   }
   return S_OK;
}

typedef struct tagITSControlData
{
   UINT cdwFollowing;          // Must be 6 or 13
   DWORD cdwITFS_Control;      // Must be 5
   DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
   DWORD dwVersionITS;         // Must be 1
   DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
   DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                               // which we'll cache in memory. (Default is 20)
   DWORD fFlags;               // Control bit flags (see below).
                               // Default value is fDefaultIsCompression.
   UINT  cdwControlData;       // Must be 6
   DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
   DWORD dwVersion;            // Must be 2
   DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
   DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
   DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
   DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

HRESULT CFileSystem::Create( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 13;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 4096;     // default = 8192
   itcd.cMinCacheEntries  = 10;       // default = 20
   itcd.fFlags            = 1;        // 0 == Uncompressed, 1 == Compressed.
   itcd.cdwControlData        = 6;
   itcd.dwLZXMagic            = LZX_MAGIC;
   itcd.dwVersion             = 2;
   itcd.dwMulResetBlock       = 2;    // Default = 4
   itcd.dwMulWindowSize       = 2;    // Default = 4
   itcd.dwMulSecondPartition  = 1;    // Default = 2
   itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 6;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 8192;     // default = 8192
   itcd.cMinCacheEntries  = 20;        // default = 20
   itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CFileSystem::Open(PCSTR pszPathName, DWORD dwAccess)
{
   HRESULT hr = S_OK;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgOpenStorage( (LPCWSTR) wsz, NULL, dwAccess, NULL, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return hr;
}

HRESULT CFileSystem::Compact(LPCSTR pszPathName)
{
   WCHAR wszPathName[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, wszPathName, sizeof(wszPathName));
   m_pITStorage->Compact(wszPathName, COMPACT_DATA_AND_PATH);

   return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr(m_pStorage);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem(CFileSystem* pFS)
{
   m_pFS = pFS;
   m_pStorage = NULL;
   m_pStream = NULL;
   m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
   if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
      ReleaseObjPtr(m_pStorage);

   ReleaseObjPtr(m_pStream);
}

HRESULT CSubFileSystem::CreateSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';

      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);

      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;
   IStorageITEx* pIStorageEx;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile(PCSTR pszPathName)
{
   m_pStorage = m_pFS->m_pStorage;
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   HRESULT hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile(PCSTR pszPathName)
{
   IStorageITEx* pIStorageEx;
   HRESULT hr;

   m_pStorage = m_pFS->m_pStorage;

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::OpenSub(PCSTR pszPathName, DWORD dwAccess)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   if ((pszFilePortion = FindFilePortion(pszPathName)) &&
         pszFilePortion > pszPathName + 2) // +2 to support / && ./
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, dwAccess, NULL, 0, &m_pStorage);

      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage ? m_pFS->m_pStorage : m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->OpenStream(wszStream, NULL, dwAccess, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

ULONG CSubFileSystem::WriteSub(const void* pData, int cb)
{
   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   ULONG cbWritten;

   HRESULT hr = m_pStream->Write(pData, cb, &cbWritten);

   if (!SUCCEEDED(hr) || (cbWritten != (ULONG)cb) )
   {
      return (ULONG) -1;
   }
   // REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
   // we don't write cb bytes.
   return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub(int cb, int iOrigin)
{
   LARGE_INTEGER liCount = {0,0};
   ULARGE_INTEGER liNewPos;

   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   liCount.LowPart = cb;
   HRESULT hr =  m_pStream->Seek(liCount, iOrigin, &liNewPos);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return liNewPos.LowPart;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize(unsigned uSize)
{
   ULARGE_INTEGER liSize = {0,0};
   HRESULT hr;

   if ( !m_pStorage || !m_pStream )
      return E_FAIL;

   liSize.LowPart = uSize;
   hr =  m_pStream->SetSize(liSize);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return hr;
}

//
// Delete substorage.
//
HRESULT 
CSubFileSystem::DeleteSub()
{
    if (m_pStorage)
    {
        if (m_pStream)
        {
            // Release the stream.
            ReleaseObjPtr(m_pStream) ;
        }

        // Now delete the storage.
        WCHAR element[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szPathName, -1, (PWSTR) element, MAX_PATH);

        HRESULT hr = m_pStorage->DestroyElement(element) ;
        if (SUCCEEDED(hr))
        {
            // Get back to the constructor state.
            if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
            {
                ReleaseObjPtr(m_pStorage);
            }
            return S_OK ;
        }
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\genexception.h ===
//
//
// MODULE: GenException.h
//
// PURPOSE: Communicates Operating System error messages and a custom 
//			message accross function boundries.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/96
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CGENEXCEPTION_H_
#define __CGENEXCEPTION_H_ 1

class CGenException
{
public:
	CGenException() {m_OsError=0;m_strOsMsg=_T("");m_strError=_T("");};

	long m_OsError;
	CString m_strOsMsg;
	CString m_strError;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\functions.h ===
//
// MODULE: FUNCTIONS.H
//
// PURPOSE:  Decodes the the variant structures.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
/// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __FUNCTIONS_H_
#define __FUNCTIONS_H_ 1

inline CString GlobFormatMessage(DWORD dwLastError)
{
	CString strMessage;
	void *lpvMessage;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 0, NULL);
	strMessage = (LPCTSTR) lpvMessage;
	LocalFree(lpvMessage);
	return strMessage;
}

inline CString DecodeVariantTypes(VARTYPE vt)
{
	CString str = _T("");
	if (VT_EMPTY == vt)
		str = _T("Empty  ");
	else if(VT_ILLEGAL == vt)
		str = _T("ILLEGAL  ");
	else if(VT_ILLEGALMASKED == vt)
		str = _T("ILLEGALMASKED  ");
	else
	{
		if (VT_VECTOR == (VT_VECTOR & vt))
			str += _T("VECTOR  ");
		if (VT_ARRAY == (VT_ARRAY & vt))
			str += _T("ARRAY  ");
		if (VT_BYREF == (VT_BYREF & vt))
			str += _T("BYREF  ");
		if (VT_RESERVED == (VT_RESERVED & vt))
			str += _T("RESERVED  ");
		if (VT_TYPEMASK == (VT_TYPEMASK & vt))
			str += _T("TYPEMASK  ");
		vt &= 0xFFF;
		if (VT_NULL == vt)
			str += _T("Null  ");
		if (VT_I2 == vt)
			str += _T("I2  ");
		if (VT_I4 == vt)
			str += _T("I4  ");
		if (VT_R4 == vt)
			str += _T("R4  ");
		if (VT_R8 == vt)
			str += _T("R8  ");
		if (VT_CY == vt)
			str += _T("CY  ");
		if (VT_DATE == vt)
			str += _T("DATE  ");
		if (VT_BSTR == vt)
			str += _T("BSTR  ");
		if (VT_DISPATCH == vt)
			str += _T("DISPATCH  ");
		if (VT_ERROR == vt)
			str += _T("ERROR  ");
		if (VT_BOOL == vt)
			str += _T("BOOL  ");
		if (VT_VARIANT == vt)
			str += _T("VARIANT  ");
		if (VT_UNKNOWN == vt)
			str += _T("UNKNOWN  ");
		if (VT_DECIMAL == vt)
			str += _T("DECIMAL  ");
		if (VT_I1 == vt)
			str += _T("I1  ");
		if (VT_UI1 == vt)
			str += _T("UI1  ");
		if (VT_UI2 == vt)
			str += _T("UI2  ");
		if (VT_UI4 == vt)
			str += _T("UI4  ");
		if (VT_I8 == vt)
			str += _T("I8  ");
		if (VT_UI8 == vt)
			str += _T("UI8  ");
		if (VT_INT == vt)
			str += _T("INT  ");
		if (VT_UINT == vt)
			str += _T("UINT  ");
		if (VT_VOID == vt)
			str += _T("VOID  ");
		if (VT_HRESULT == vt)
			str += _T("HRESULT  ");
		if (VT_PTR == vt)
			str += _T("PTR  ");
		if (VT_SAFEARRAY == vt)
			str += _T("SAFEARRAY  ");
		if (VT_CARRAY == vt)
			str += _T("CARRAY  ");
		if (VT_USERDEFINED == vt)
			str += _T("USERDEFINED  ");
		if (VT_LPSTR == vt)
			str += _T("LPSTR  ");
		if (VT_LPWSTR == vt)
			str += _T("LPWSTR  ");
		if (VT_FILETIME == vt)
			str += _T("FILETIME  ");
		if (VT_BLOB == vt)
			str += _T("BLOB  ");
		if (VT_STREAM == vt)
			str += _T("STREAM  ");
		if (VT_STORAGE == vt)
			str += _T("STORAGE  ");
		if (VT_STREAMED_OBJECT == vt)
			str += _T("STREAMED_OBJECT  ");
		if (VT_STORED_OBJECT == vt)
			str += _T("STORED_OBJECT  ");
		if (VT_BLOB_OBJECT == vt)
			str += _T("BLOB_OBJECT  ");
		if (VT_CF == vt)
			str += _T("CF  ");
		if (VT_CLSID == vt)
			str += _T("CLSID  ");
	}
	return str;
}

inline CString DecodeSafeArray(unsigned short Features)
{
/*
#define FADF_AUTO		0x0001	// Array is allocated on the stack.
#define FADF_STATIC		0x0002	// Array is statically allocated.
#define FADF_EMBEDDED	0x0004	// Array is embedded in a structure.
#define FADF_FIXEDSIZE	0x0010	// Array may not be resized or 
								// reallocated.
#define FADF_BSTR		0x0100	// An array of BSTRs.
#define FADF_UNKNOWN		0x0200	// An array of IUnknown*.
#define FADF_DISPATCH	0x0400	// An array of IDispatch*.
#define FADF_VARIANT		0x0800	// An array of VARIANTs.
#define FADF_RESERVED	0xF0E8	// Bits reserved for future use.
*/
	CString str = _T("");
	if (FADF_AUTO == (FADF_AUTO & Features))
		str += _T("Array is allocated on the stack.\n");
	if (FADF_STATIC == (FADF_STATIC & Features))
		str += _T("Array is statically allocated.\n");
	if (FADF_EMBEDDED == (FADF_EMBEDDED & Features))
		str += _T("Array is embedded in a structure.\n");
	if (FADF_FIXEDSIZE == (FADF_FIXEDSIZE & Features))
		str += _T("Array may not be resized of reallocated.\n");
	if (FADF_BSTR == (FADF_BSTR & Features))
		str += _T("An array of BSTRs.\n");
	if (FADF_UNKNOWN == (FADF_UNKNOWN & Features))
		str += _T("An array of IUnknown.\n");
	if (FADF_DISPATCH == (FADF_DISPATCH & Features))
		str += _T("An array of IDispatch.\n");
	if (FADF_VARIANT == (FADF_VARIANT & Features))
		str += _T("An array of VARIANTS.\n");
	if (FADF_RESERVED == (FADF_RESERVED & Features))
		str+= _T("Array is using all of the reserved bits.\n");
	return str; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\httpqueryexception.h ===
//
// MODULE: HTTPQUERYEXCEPTION.CPP
//
// PURPOSE: Execption that is thrown from the CHttpQuery class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//


#ifndef __HTTPQUERYEXCEPTION_H_
#define __HTTPQUERYEXCEPTION_H_ 1

class CHttpQueryException : public CBasicException
{
public:
	CHttpQueryException(){m_strError = _T("");m_dwBErr=TSERR_SCRIPT;};

	CString m_strError;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\fs.h ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _FS_H_
#define _FS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <unknwn.h>
#include "msitstg.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{

public:
   CSubFileSystem(class CFileSystem* pfs);
   ~CSubFileSystem();

   HRESULT CreateSub(PCSTR pszPathName);
   HRESULT CreateUncompressedSub(PCSTR pszPathName);
   HRESULT OpenSub(PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   ULONG WriteSub(const void* pData, int cb);
   ULONG SeekSub(int cb, int iOrigin);
   HRESULT CreateSystemFile(PCSTR pszPathName);
   HRESULT CreateUncompressedSystemFile(PCSTR pszPathName);
   HRESULT SetSize(unsigned uSize);
   HRESULT DeleteSub() ;

   inline HRESULT ReadSub(void* pData, ULONG cb, ULONG* pcbRead) {
      return m_pStream->Read(pData, cb, pcbRead);
   }

   inline ULONG GetUncompressedSize(void) { return SeekSub(0,2); }

   inline HRESULT Stat(STATSTG *pstatstg, DWORD grfStatFalg)
   {
      return m_pStream->Stat(pstatstg,grfStatFalg);
   }

   inline HRESULT CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER* pcbWritten)
   {
      return m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
   }

   inline IStream * GetStream(void)
   {
      return m_pStream;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   class CFileSystem* m_pFS;
   IStorage*          m_pStorage;
   IStream*           m_pStream;
   char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
   friend class CSubFileSystem;

public:
   CFileSystem();
   ~CFileSystem();

   HRESULT Init(void);
   HRESULT Create( PCSTR pszPathName );
   HRESULT CreateUncompressed( PCSTR pszPathName );
   HRESULT Open( PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   HRESULT Compact(LPCSTR lpszFileName);
   HRESULT Close(void);

   inline HRESULT GetPathName( LPSTR pszPathName ) { strcpy(pszPathName, m_szPathName); return S_OK; }

   inline IITStorage* GetITStorageObj(void) const
   {
      return m_pITStorage;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   IITStorage*   m_pITStorage;
   IStorage*     m_pStorage;
   char          m_szPathName[MAX_PATH];

};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\ocxglobals.h ===
// 
// MODULE: ComGlobals.h
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
///////////////////////

#ifndef __COMGLOBALS_H_
#define __COMGLOBALS_H_ 1

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize);

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\ocxglobals.cpp ===
// 
// MODULE: OcxGlobals.cpp
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
///////////////////////

#include "stdafx.h"
#include "..\launcher\server\ComGlobals.h"

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize)
{
	int x = 0;
	while(x < CharBufSize)
	{
		szChar[x] = (TCHAR) bstr[x];
		if (NULL == szChar[x])
			break;
		x++;
	}
	return x < CharBufSize;
}

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize)
{
	HKEY hKey;
	DWORD dwType = REG_SZ;
	DWORD dwBufSize = *pdwBufSize;
	LPTSTR szUnExpanded = new TCHAR[dwBufSize];
	if (NULL == szUnExpanded)
		return false;
	__try
	{
		if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, szKey, NULL, KEY_READ, &hKey))
		{
			////Delete before you return.
			if (NULL != szUnExpanded)
				delete [] szUnExpanded;

			return false;
		}
		if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, NULL, &dwType, 
				(PBYTE) szUnExpanded, pdwBufSize))
		{
			RegCloseKey(hKey);
			return false;
		}			
		RegCloseKey(hKey);
		if (REG_EXPAND_SZ == dwType || dwType == REG_SZ)	// NT 5.0 beta bug requires all strings to be expanded.
		{
			DWORD dwBytesUsed;
			dwBytesUsed = ExpandEnvironmentStrings(szUnExpanded, szBuffer, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 == dwBytesUsed)
				return false;
			*pdwBufSize = dwBytesUsed;
			if (dwBytesUsed > dwBufSize)
				return false;
		}
		else
		{
			_tcsncpy(szBuffer, szUnExpanded, dwBufSize);
		}
	}
	__finally
	{
		if (NULL != szUnExpanded)
			delete [] szUnExpanded;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TSHOOT.rc
//
#define IDS_TSHOOT                      1
#define IDD_ABOUTBOX_TSHOOT             1
#define IDB_TSHOOT                      1
#define IDI_ABOUTDLL                    1
#define IDS_TSHOOT_PPG                  2
#define IDS_TSHOOT_PPG_CAPTION          100
#define IDD_PROPPAGE_TSHOOT             100
#define IDS_ER_RELOADFAILED             201
#define IDS_ER_RELOADDEPFAILED          202
#define IDS_ER_RELOADIDEPFAILED         203
#define IDS_ER_RELOADIDEPFAILEDA        204
#define IDS_ER_ERRORS_OCCURED           205
#define IDS_ER_NO_INPUT_PARAMS          206
#define IDS_ER_UNEXP_CMD                207
#define IDS_I_OBJ_MOVED                 208
#define IDS_ER_SVR_BAD_DATA             209
#define IDS_FP_TITLE                    210
#define IDS_FP_BODY_ATTRIB              211
#define IDS_FP_HEADER                   212
#define IDS_ER_NO_API                   213
#define IDS__ER_HTX_PARSE               214
#define IDS_ER_MEM1                     215
#define IDS_ER_ASSERT_FAILED            216
#define IDS_I_NO_RESULT                 217
#define IDS_ER_MISSING_API              218
#define IDS_ER_UNEXP_CMDA               219
#define IDS_ER_GEN_HDR1                 220
#define IDS_ER_GEN_FDR1                 221
#define IDS_I_NO_TS1                    222
#define IDS_I_NO_TS2                    223
#define IDS_FPA_HEADER                  224
#define IDS_FPA_FOOTER                  225
#define IDS_FPA_BODY                    226
#define IDS_CONTROL_SCRIPT1             227
#define IDS_CONTROL_SCRIPT2             228
#define IDS_CONTROL_OBJECT              229
#define IDS_FORM_START                  230
#define IDS_FPA_TS_BUTTON               231
#define IDS_CONTROL_FRAME_SCRIPT1       232
#define IDS_CONTROL_FRAME_SCRIPT2       233
#define IDS_CONTROL_FRAME_SCRIPT3       234
#define IDS_HTM_IDH1                    235
#define IDS_HTM_HEADER1                 236
#define IDS_HTM_ST_LIST1                237
#define IDS_HTM_EN_LIST1                238
#define IDS_HTM_RADIO1A                 239
#define IDS_HTM_RADIO1B                 240
#define IDS_HTM_TEXT1                   241
#define IDS_HTM_RADIO2A                 242
#define IDS_HTM_RADIO2B                 243
#define IDS_HTM_EN_LIST2                244
#define IDS_HTM_EN_LIST2A               244
#define IDS_HTM_HEADER2                 245
#define IDS_HTM_IDH2                    246
#define IDS_HTM_BR1                     247
#define IDS_HTM_ST_LIST2                248
#define IDS_HTM_IDS_BYE                 249
#define IDS_HTM_IDS_FAIL                250
#define IDS_HTM_EN_LIST2B               250
#define IDS_HTM_IDH3                    251
#define IDS_HTM_IDH4                    252
#define IDS_HTM_IDH5                    253
#define IDS_HTM_HEADER3                 254
#define IDS_HTM_HEADER4                 255
#define IDS_HTM_HEADER5                 256
#define IDS_HTM_BODY2                   257
#define IDS_HTM_BODY1                   258
#define IDS_HTM_BODY3                   259
#define IDS_HTM_ST_LIST3                260
#define IDS_HTM_BACK_START              260
#define IDS_HTM_RADIO3A                 261
#define IDS_HTM_RADIO3B                 262
#define IDS_HTM_EN_LIST3                263
#define IDS_HTM_ST_LIST4                264
#define IDS_HTM_RADIO4A                 265
#define IDS_HTM_RADIO4B                 266
#define IDS_HTM_EN_LIST4                267
#define IDS_PROBLEM                     268
#define IDS_STRING269                   269
#define IDS_STRING270                   270
#define IDS_STRING271                   271
#define IDS_STRING272                   272
#define IDS_HTM_EN_BYE_MSG              273
#define IDS_EN_IMP                      274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
//#include <afxdb.h>			// MFC database classes
//#include <afxdao.h>			// MFC DAO database classes

#endif //_UNICODE

#include <afxtempl.h>
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\sniff.cpp ===
//
// MODULE: SNIFF.CPP
//
// PURPOSE: sniffed data container
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 3-27-99
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5

#include "stdafx.h"

#include "sniff.h"

#include "apgts.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"

//////////////////////////////////////////////////////////////////////////////////////
// CSniffedNodeContainer class definition
//
CSniffedNodeContainer::CSniffedNodeContainer()
					 : m_pBNTS(NULL)
{
}

CSniffedNodeContainer::CSniffedNodeContainer(GTSAPI* bnts)
				     : m_pBNTS(bnts)
{
}

CSniffedNodeContainer::~CSniffedNodeContainer()
{
}

void CSniffedNodeContainer::SetBNTS(GTSAPI* bnts)
{
	m_pBNTS = bnts;
}

inline GTSAPI* CSniffedNodeContainer::GetBNTS()
{
	return m_pBNTS;
}

bool CSniffedNodeContainer::AddNode(CString name, int state)
{
	if (GetBNTS())
	{
		CSniffedNodeInfo info(name, state);
	
		// use GTSAPI:: since it should be unicode - compliant
		if (SNIFF_INVALID_NODE_ID != (info.m_iId = m_pBNTS->GTSAPI::INode(LPCTSTR(name))))
		{
			if (!HasNode(info.m_iId))
			{
				m_arrInfo.Add(info);
				return true;
			}
		}
	}

	return false;
}

bool CSniffedNodeContainer::ResetIds()
{
	CArray<CSniffedNodeInfo, CSniffedNodeInfo&> tmp;

	tmp.Copy(m_arrInfo);
	Flush();
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		if (!AddNode(m_arrInfo[i].m_strName, m_arrInfo[i].m_iState))
		{
			m_arrInfo.Copy(tmp);
			return false;
		}
	}

	return true;
}

bool CSniffedNodeContainer::HasNode(int id)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
		if (m_arrInfo[i].m_iId == id)
				return true;
	return false;
}

bool CSniffedNodeContainer::GetState(int id, int* state)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		if (m_arrInfo[i].m_iId == id)
		{
				*state = m_arrInfo[i].m_iState;
				return true;
		}
	}
	return false;
}

inline
bool CSniffedNodeContainer::IsEmpty()
{
	return 0 == m_arrInfo.GetSize();
}

void CSniffedNodeContainer::Flush()
{
	m_arrInfo.RemoveAll();
}

CSniffedNodeInfo* CSniffedNodeContainer::GetInfo(int id)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
		if (m_arrInfo[i].m_iId == id)
				return &m_arrInfo[i];
	return NULL;
}

bool CSniffedNodeContainer::GetLabel(int id, int* label)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		if (m_arrInfo[i].m_iId == id)
		{
			if (SNIFF_INVALID_NODE_LABEL != m_arrInfo[i].m_iLabel)
			{
				*label = m_arrInfo[i].m_iLabel;
			}
			else
			{
				if (GetLabelFromBNTS(id, label))
				{
					// once we have got label from BNTS - save it
					m_arrInfo[i].m_iLabel = *label;
				}
				else
				{
					return false;
				}
			}
			return true;
		}
	}
	return false;
}

bool CSniffedNodeContainer::GetLabelFromBNTS(int node, int* label)
{
	// work strictly with BNTS class
	
	int old_node = m_pBNTS->BNTS::INodeCurrent();

	if (m_pBNTS->BNTS::BNodeSetCurrent(node))
	{	
		*label = m_pBNTS->BNTS::ELblNode();		
		m_pBNTS->BNTS::BNodeSetCurrent(old_node); // we do not check if successful - old_node might be -1
		return true;
	}

	return false;
}

int CSniffedNodeContainer::GetSniffedFixobsThatWorked()
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		int label = SNIFF_INVALID_NODE_LABEL;

		if (GetLabel(m_arrInfo[i].m_iId, &label) && // fixobs node is set to 1 - WORKED!
			ESTDLBL_fixobs == label &&
			m_arrInfo[i].m_iState == 1
		   )
		   return m_arrInfo[i].m_iId;
	}

	return SNIFF_INVALID_NODE_ID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\sniff.h ===
//
// MODULE: SNIFF.H
//
// PURPOSE: sniffed data container
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 3-27-99
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef TSHOOT_SNIFF_H
#define TSHOOT_SNIFF_H


#define SNIFF_INVALID_NODE_ID      -1
#define SNIFF_INVALID_STATE        -1
#define SNIFF_INVALID_NODE_LABEL   -1

//////////////////////////////////////////////////////////////////////////////////////
// CSniffedNodeInfo struct
//

struct CSniffedNodeInfo
{
	CSniffedNodeInfo() 
								: m_iState(SNIFF_INVALID_STATE),
								  m_iId(SNIFF_INVALID_NODE_ID),
								  m_iLabel(SNIFF_INVALID_NODE_LABEL) 
	{}

	CSniffedNodeInfo(CString& name, int state) 
								: m_strName(name), 
								  m_iState(state), 
								  m_iId(SNIFF_INVALID_NODE_ID),
								  m_iLabel(SNIFF_INVALID_NODE_LABEL) 
	{}
	
	int  m_iId; // node id
	int  m_iState; // node state (sniffed)
	int  m_iLabel; // node label
	CString	 m_strName; // node symbolic name
};

//////////////////////////////////////////////////////////////////////////////////////
// CSniffedContainer class declaration
//
class GTSAPI;
class CSniffedNodeContainer
{
public:
	CSniffedNodeContainer();
	CSniffedNodeContainer(GTSAPI*);
	virtual ~CSniffedNodeContainer();

// interface
	GTSAPI* GetBNTS();
	void SetBNTS(GTSAPI* bnts);

	bool AddNode(CString name, int state);
	bool ResetIds(); // should be called if we (re)set BNTS
	bool HasNode(int id);
	CSniffedNodeInfo* GetInfo(int id);
	bool GetState(int id, int* state);
	bool GetLabel(int id, int* label);
	bool IsEmpty();
	void Flush();

	int  GetSniffedFixobsThatWorked();

protected:
	bool GetLabelFromBNTS(int node, int* label);

protected:
	GTSAPI*  m_pBNTS; // pointer to BNTS (or inherited class)
	CArray<CSniffedNodeInfo, CSniffedNodeInfo&> m_arrInfo; // data array
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\rsstack.h ===
//
//
// MODULE: RSStack.h
//
// PURPOSE:  First in first out single linked list.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/96
//
// NOTES: 
// 1.	A stack of any structure.  Can be used for pointers, but
//		will cause a memory leak when the stack is destroyed with
//		objects on it.
//
// 2.	This file has no .cpp file. Every thing is inline, due to the
//		template class.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __RSSTACK_H_
#define __RSSTACK_H_ 1

template<class T>
class RSStack
{
public:
	RSStack();
 	virtual ~RSStack();
// Attributes
public:

private:
	typedef struct tagRSStackNode
	{
		T SItem;
		struct tagRSStackNode *pNext;
	} RSStackNode;

	RSStackNode *m_pTop;
	RSStackNode *m_pPeak;

// Operations
public:
/*	
	Push returns -1 when out of memory.
*/
int Push(T);
/*
	Pop returns the top T item.
*/
T Pop();
/*
	1 is the top most item in the stack.  Returns the T item at
	tdown index by copying the value to refedItem.  False is returned if 
	tdown is greater than the number of items in the stack.
*/
BOOL GetAt(int tdown, T &refedItem);
/*
	PeakFirst returns the top most item and initializes variables that are
	used by PeakNext.  PeakFirst returns false when the stack is empty.
*/
BOOL PeakFirst(T &refedItem);
/*
	Use PeakNext to quickly peak at all of the items on the stack.
	PeakNext returns false when it can not copy a T item to refedItem.
*/
BOOL PeakNext(T &refedItem);
/*
	Empty returns TRUE (Non-Zero) when the stack is empty.
*/
BOOL Empty();
/*
	RemoveAll throws away the contents of the stack.
*/
void RemoveAll();
};

template<class T>
inline RSStack<T>::RSStack()
{
	m_pTop = NULL;
	m_pPeak = NULL;
}

template<class T>
inline RSStack<T>::~RSStack()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline int RSStack<T>::Push(T Item)
{
	int Ret;
	RSStackNode *pNew = new RSStackNode;
	if(NULL == pNew)
	{
		Ret = -1;
	}
	else
	{
		Ret = 1;
		pNew->pNext = m_pTop;
		m_pTop = pNew;
		pNew->SItem = Item;
	}
	return Ret;
}

template<class T>
inline T RSStack<T>::Pop()
{
	T Ret;
	if(NULL != m_pTop)
	{
		RSStackNode *pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		Ret = pOld->SItem;
		delete pOld;
	}
	return Ret;
}

template<class T>
inline BOOL RSStack<T>::Empty()
{
	BOOL bRet;
	if(NULL == m_pTop)
		bRet = TRUE;
	else
		bRet = FALSE;
	return bRet;
}

template<class T>
inline void RSStack<T>::RemoveAll()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline BOOL RSStack<T>::GetAt(int tdown, T &refedItem)
{
	BOOL bRet = FALSE;
	RSStackNode *pNode = m_pTop;
	while(pNode != NULL && tdown > 1)
	{
		pNode = pNode->pNext;
		tdown--;
	}
	if (pNode && 1 == tdown)
	{
		refedItem = pNode->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakFirst(T &refedItem)
{
	BOOL bRet = FALSE;
	if (NULL != m_pTop)
	{
		m_pPeak = m_pTop;
		refedItem = m_pTop->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakNext(T &refedItem)
{
	ASSERT(NULL != m_pPeak);
	BOOL bRet = FALSE;
	m_pPeak = m_pPeak->pNext;
	if (NULL != m_pPeak)
	{
		refedItem = m_pPeak->SItem;
		bRet = TRUE;
	}
	return bRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\tshoot.h ===
// MODULE: TSHOOT.h : main header file for TSHOOT.DLL
//
// PURPOSE: Declaration of the CTSHOOTCtrl OLE control class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTApp : See TSHOOT.cpp for implementation.

class CTSHOOTApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\tshoot.cpp ===
//
// MODULE: TSHOOT.CPP
//
// PURPOSE: Implementation of CTSHOOTApp and DLL registration.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "TSHOOT.h"

#include "apgts.h"

#include "ErrorEnums.h"
#include "BasicException.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CTSHOOTApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x4b106871, 0xdd36, 0x11d0, { 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CTSHOOTApp::InitInstance - DLL initialization

BOOL CTSHOOTApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		::AfxOleInit();
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CTSHOOTApp::ExitInstance - DLL termination

int CTSHOOTApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}

void ReportError(DLSTATTYPES Error)
{
	CBasicException *pBExc = new CBasicException;
	pBExc->m_dwBErr = Error;
	throw pBExc;
	return;
}
// ReportWFEvent (Based on Microsoft code)
//
// report an event to the NT event watcher
// pass 1, 2 or 3 strings
//
// no return value

VOID ReportWFEvent(LPTSTR string1,LPTSTR string2,LPTSTR string3,LPTSTR string4,DWORD eventID)
{
	CBasicException *pBExc = new CBasicException;
	pBExc->m_dwBErr = (DLSTATTYPES) eventID;
	throw pBExc;
	return;
/*
	HANDLE hEvent;
	PTSTR pszaStrings[4];
	WORD cStrings;

	cStrings = 0;
	if ((pszaStrings[0] = string1) && (string1[0])) cStrings++;
	if ((pszaStrings[1] = string2) && (string2[0])) cStrings++;
	if ((pszaStrings[2] = string3) && (string3[0])) cStrings++;
	if ((pszaStrings[3] = string4) && (string4[0])) cStrings++;
	if (cStrings == 0)
		return;
	
	hEvent = RegisterEventSource(
					NULL,		// server name for source (NULL means this computer)
					REG_EVT_ITEM_STR);		// source name for registered handle  
	if (hEvent) {
		ReportEvent(hEvent,					// handle returned by RegisterEventSource 
				    evtype(eventID),		// event type to log 
				    0,						// event category 
				    eventID,				// event identifier 
				    0,						// user security identifier (optional) 
				    cStrings,				// number of strings to merge with message  
				    0,						// size of binary data, in bytes
				    (LPCTSTR *)pszaStrings,	// array of strings to merge with message 
				    NULL);		 			// address of binary data 
		DeregisterEventSource(hEvent);
	} 
*/
}
/*
	Addbackslash appends a \ to null terminated strings that do
	not already have a \.
*/
void _addbackslash(LPTSTR sz)
{
	int len = _tcslen(sz);
	if (len && (0 == _tcsncmp(&sz[len - 1], _T("/"), 1)))
	{
		sz[len - 1] = _T('\\');
	}
	else if (len && (0 != _tcsncmp(&sz[len - 1], _T("\\"), 1)))
	{
		sz[len] = _T('\\');
		sz[len + 1] = NULL;
	}
	return;
}
void _addforwardslash(LPTSTR sz)
{
	int len = _tcslen(sz);
	if (len && (0 == _tcsncmp(&sz[len - 1], _T("\\"), 1)))
	{
		sz[len - 1] = _T('/');
	}
	else if (len && (0 != _tcsncmp(&sz[len - 1], _T("/"), 1)))
	{
		sz[len] = _T('/');
		sz[len + 1] = NULL;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\tshootctl.cpp ===
// MODULE: TSHOOTCTL.CPP
//
// PURPOSE: Interface for the componet.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 6/4/96
//
// NOTES:
// 1. Based on Print Troubleshooter DLL.
// 2. Richard Meadows wrote the RunQuery, BackUp, Problem Page and
//	  PreLoadURL functions.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "ErrorEnums.h"

#include "cathelp.h"

#include "TSHOOT.h"

#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "apgtsfst.h"

#include "ErrorEnums.h"

#include "CabUnCompress.h"

#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "OcxGlobals.h"


class CTSHOOTCtrl;

#include "dnldlist.h"
#include "download.h"

#include "TSHOOTCtl.h"
#include "TSHOOTPpg.h"

#include "Functions.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "HttpQueryException.h"

#include <stdlib.h>

#include "LaunchServ.h"
#include "LaunchServ_i.c"

// >>> test
#include "fstream.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CTSHOOTCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTSHOOTCtrl, COleControl)
	//{{AFX_MSG_MAP(CTSHOOTCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CTSHOOTCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CTSHOOTCtrl)
	DISP_PROPERTY_NOTIFY(CTSHOOTCtrl, "DownloadURL", m_downloadURL, OnDownloadURLChanged, VT_BSTR)
	DISP_PROPERTY_NOTIFY(CTSHOOTCtrl, "DownloadListFilename", m_downloadListFilename, OnDownloadListFilenameChanged, VT_BSTR)
	DISP_FUNCTION(CTSHOOTCtrl, "RunQuery", RunQuery, VT_BSTR, VTS_VARIANT VTS_VARIANT VTS_I2)
	DISP_FUNCTION(CTSHOOTCtrl, "SetSniffResult", SetSniffResult, VT_BOOL, VTS_VARIANT VTS_VARIANT)
	DISP_FUNCTION(CTSHOOTCtrl, "GetExtendedError", GetExtendedError, VT_I4, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "GetCurrentFriendlyDownload", GetCurrentFriendlyDownload, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "GetCurrentFileDownload", GetCurrentFileDownload, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "DownloadAction", DownloadAction, VT_I4, VTS_I4)
	DISP_FUNCTION(CTSHOOTCtrl, "BackUp", BackUp, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "ProblemPage", ProblemPage, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "PreLoadURL", PreLoadURL, VT_BSTR, VTS_BSTR)
	DISP_FUNCTION(CTSHOOTCtrl, "Restart", Restart, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "RunQuery2", RunQuery2, VT_BSTR, VTS_BSTR VTS_BSTR VTS_BSTR)
	DISP_FUNCTION(CTSHOOTCtrl, "SetPair", SetPair, VT_EMPTY, VTS_BSTR VTS_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CTSHOOTCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CTSHOOTCtrl, COleControl)
	//{{AFX_EVENT_MAP(CTSHOOTCtrl)
	EVENT_CUSTOM("BindProgress", FireBindProgress, VTS_BSTR  VTS_I4  VTS_I4)
	EVENT_CUSTOM("BindStatus", FireBindStatus, VTS_I4  VTS_I4  VTS_I4  VTS_BOOL)
	EVENT_CUSTOM("Sniffing", FireSniffing, VTS_BSTR  VTS_BSTR  VTS_BSTR  VTS_BSTR)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CTSHOOTCtrl, 1)
	PROPPAGEID(CTSHOOTPropPage::guid)
END_PROPPAGEIDS(CTSHOOTCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CTSHOOTCtrl, "TSHOOT.TSHOOTCtrl.1",
	0x4b106874, 0xdd36, 0x11d0, 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CTSHOOTCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DTSHOOT =
		{ 0x4b106872, 0xdd36, 0x11d0, { 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff } };
const IID BASED_CODE IID_DTSHOOTEvents =
		{ 0x4b106873, 0xdd36, 0x11d0, { 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff } };

const CATID CATID_SafeForScripting		= {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing	= {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwTSHOOTOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CTSHOOTCtrl, IDS_TSHOOT, _dwTSHOOTOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::CTSHOOTCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CTSHOOTCtrl

BOOL CTSHOOTCtrl::CTSHOOTCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	HRESULT hr;
	BOOL bRes;
	if (bRegister)
	{
		bRes = AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_TSHOOT,
			IDB_TSHOOT,
			afxRegApartmentThreading,
			_dwTSHOOTOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);

		hr = CreateComponentCategory(CATID_SafeForScripting, L"Controls that are safely scriptable");
		ASSERT(SUCCEEDED(hr));
		hr = CreateComponentCategory(CATID_SafeForInitializing, L"Controls safely initializable from persistent data");
		ASSERT(SUCCEEDED(hr));
		hr = RegisterCLSIDInCategory(m_clsid, CATID_SafeForScripting);
		ASSERT(SUCCEEDED(hr));
		hr = RegisterCLSIDInCategory(m_clsid, CATID_SafeForInitializing);
		ASSERT(SUCCEEDED(hr));
	}
	else
	{
		hr = UnRegisterCLSIDInCategory(m_clsid, CATID_SafeForScripting);
		ASSERT(SUCCEEDED(hr));
		hr = UnRegisterCLSIDInCategory(m_clsid, CATID_SafeForInitializing);
		ASSERT(SUCCEEDED(hr));

		bRes = AfxOleUnregisterClass(m_clsid, m_lpszProgID);
	}
	return bRes;
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::CTSHOOTCtrl - Constructor

CTSHOOTCtrl::CTSHOOTCtrl()
{
	InitializeIIDs(&IID_DTSHOOT, &IID_DTSHOOTEvents);

	// TODO: Initialize your control's instance data here.
	m_strCurShooter = _T("");
	m_download = NULL;
	m_bComplete = TRUE;
	m_dwExtendedErr = LTSC_OK;
	m_pSniffedContainer = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::~CTSHOOTCtrl - Destructor

CTSHOOTCtrl::~CTSHOOTCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::OnDraw - Drawing function

void CTSHOOTCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::DoPropExchange - Persistence support

void CTSHOOTCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::OnResetState - Reset control to default state

void CTSHOOTCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::AboutBox - Display an "About" box to the user

void CTSHOOTCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_TSHOOT);
	dlgAbout.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl message handlers

bool CTSHOOTCtrl::SetSniffResult(const VARIANT FAR& varNodeName, const VARIANT FAR& varNodeState)
{
	BSTR bstrNodeName = NULL;
	int iNodeState = 0;
	short sNodeNameLen = 0;
	TCHAR* tszNodeName = NULL;
	bool ret = true;

// >>> test
#ifdef _DEBUG
//	AfxDebugBreak();
#endif

	if (VT_BYREF == (VT_BYREF & varNodeName.vt) &&  // data type is VT_VARIANT | VT_BYREF
		VT_VARIANT == (VT_VARIANT & varNodeName.vt) // this means that data in VB script was passed as a variable
	   )
	{
		bstrNodeName = varNodeName.pvarVal->bstrVal;
	}
	else
	{
		if (VT_BSTR == (VT_BSTR & varNodeName.vt)) // data is of VT_BSTR type
												   // this means that data in VB script was passed as a constant
			bstrNodeName = varNodeName.bstrVal;
		else
			return false;
	}

	if (VT_BYREF == (VT_BYREF & varNodeState.vt) &&  // data type is VT_VARIANT | VT_BYREF
		VT_VARIANT == (VT_VARIANT & varNodeState.vt) // this means that data in VB script was passed as a variable
	   )
	{
		iNodeState = varNodeState.pvarVal->iVal;
	}
	else
	{
		if (VT_I2 == (VT_I2 & varNodeState.vt)) // data is of VT_I2 type
										        // this means that data in VB script was passed as a constant
			iNodeState = varNodeState.iVal;
		else
			return false;
	}
	
	sNodeNameLen = (short)::SysStringLen(bstrNodeName);
	tszNodeName = new TCHAR[sNodeNameLen+1];

	tszNodeName[sNodeNameLen] = 0;
    ::BSTRToTCHAR(tszNodeName, bstrNodeName, sNodeNameLen);

	//
	// implement set node state functionality here
	//
	if (m_pSniffedContainer)
	{
		ret = m_pSniffedContainer->AddNode(tszNodeName, iNodeState);
	}
	else
	{
		MessageBox(_T("Sniffed data will be lost!"));
		ret = false;
	}
	//

	delete [] tszNodeName;
	return ret;
}

BSTR CTSHOOTCtrl::RunQuery(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size)
{
	CString strCmd1;
	CString strTxt;
	CString strResult = _T("");

	try
	{
		HMODULE hModule = AfxGetInstanceHandle();
		ASSERT(INVALID_HANDLE_VALUE != hModule);

		m_httpQuery.Initialize(varCmds, varVals, size);

		if (m_httpQuery.GetFirstCmd() == C_ASK_LIBRARY)
		{	
			// Added to support launching by the TS Launcher.
			// Get an ILaunchTS interface.
			HRESULT hRes;
			DWORD dwResult;
			ILaunchTS *pILaunchTS = NULL;
			CLSID clsidLaunchTS = CLSID_LaunchTS;
			IID iidLaunchTS = IID_ILaunchTS;

			// Get an interface on the launch server
			hRes = CoCreateInstance(clsidLaunchTS, NULL,
					CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER | CLSCTX_INPROC_SERVER,
					iidLaunchTS, (void **) &pILaunchTS);
			if (FAILED(hRes))
			{
				m_dwExtendedErr = TSERR_LIB_STATE_INFO;
				strResult = _T("LaunchServ interface not found.");
				return strResult.AllocSysString();
			}

			// Get all of the query values.
			hRes = pILaunchTS->GetShooterStates(&dwResult);
			if (FAILED(hRes))
			{
				m_dwExtendedErr = dwResult;
				strResult.Format(_T("<html>GetShooterStates Failed. %ld</html>"), dwResult);
				pILaunchTS->Release();			
				return strResult.AllocSysString();
			}

			// Run the query.
			OLECHAR *poleShooter;
			hRes = pILaunchTS->GetTroubleShooter(&poleShooter);
			if (FAILED(hRes))
			{
				m_dwExtendedErr = TSERR_LIB_STATE_INFO;
				strResult = _T("<html>GetTroubleShooter Failed. </html>");
				pILaunchTS->Release();
				return strResult.AllocSysString();
			}
			m_strCurShooter = poleShooter;

			// Ignoring, for now, any other information we may get from the launch server
			//	(e.g. problem node) set up m_httpQuery and other things as if we just had
			//	a request for this troubleshooting belief network.
			m_httpQuery.SetFirst(CString(C_TYPE), m_strCurShooter);
			SysFreeString(poleShooter);
			m_Conf.Initialize(hModule, (LPCTSTR) m_strCurShooter
								);	// CDBLoadConfiguration				
			m_apgts.Initialize(	m_Conf.GetAPI(),		// APGTSContext
								&m_Conf,
								&m_httpQuery);
			m_apgts.RemoveSkips();
			m_Conf.GetAPI()->api.pAPI->SetHttpQuery(&m_httpQuery);

			// sniffing
			m_Conf.GetAPI()->api.pAPI->ReadTheDscModel();
			m_pSniffedContainer = m_Conf.GetAPI()->api.pAPI;

			m_httpQuery.FinishInitFromServ(m_Conf.GetAPI()->api.pAPI, pILaunchTS);

			FireSniffing(m_httpQuery.GetMachine(),
						 m_httpQuery.GetPNPDevice(),
						 m_httpQuery.GetDeviceInstance(),
						 m_httpQuery.GetGuidClass());

			pILaunchTS->Release();
			pILaunchTS = NULL;

			m_httpQuery.SetStackDirection();
			m_Conf.SetValues(m_httpQuery);
			m_apgts.ClearBackup();

			m_Conf.GetAPI()->api.pAPI->SetReverse(false);
			m_apgts.DoContent(&m_httpQuery);

			// now add sniffed nodes that were automatically traversed
			// to the stack of navigated nodes - UGLY
			m_httpQuery.PushNodesLastSniffed(m_Conf.GetAPI()->api.pAPI->GetArrLastSniffed());

			// Now that we've done all the processing render the appropriate page.
			// This is the first page the user sees when launching a torubleshooter.
			m_apgts.RenderNext(strResult);
			m_apgts.Empty();
		}	
		else if (m_httpQuery.GetFirstCmd() == C_SELECT)
		{	// Unsupported function.
			// Returns a page that has all of the trouble shooters.
			try
			{
				CFirstPage firstPage;
				CString str = m_httpQuery.GetTroubleShooter();
				firstPage.RenderFirst(strResult, str);	// Here I am getting an hit file.
			}
			catch(CBasicException *pExc)
			{
				m_dwExtendedErr = pExc->m_dwBErr;
				strResult = _T("");
				delete pExc;
			}
		}
		else
		{	// Normal operation.
			if (m_httpQuery.GetTroubleShooter() != m_strCurShooter)
			{
				m_strCurShooter = m_httpQuery.GetTroubleShooter();
				m_Conf.Initialize(hModule, (LPCTSTR) m_strCurShooter
									);	// CDBLoadConfiguration				
				m_apgts.Initialize(	m_Conf.GetAPI(),		// APGTSContext
									&m_Conf,
									&m_httpQuery);
				m_apgts.RemoveSkips();
				m_Conf.GetAPI()->api.pAPI->SetHttpQuery(&m_httpQuery);

				// sniffing
				m_Conf.GetAPI()->api.pAPI->ReadTheDscModel();
				m_pSniffedContainer = m_Conf.GetAPI()->api.pAPI;
				FireSniffing(m_httpQuery.GetMachine(),
							 m_httpQuery.GetPNPDevice(),
							 m_httpQuery.GetDeviceInstance(),
							 m_httpQuery.GetGuidClass());
			}
			m_httpQuery.FinishInit(m_Conf.GetAPI()->api.pAPI, varCmds, varVals);
			
			m_httpQuery.SetStackDirection();
			m_Conf.SetValues(m_httpQuery);
			m_apgts.ClearBackup();

			m_Conf.GetAPI()->api.pAPI->SetReverse(false);
			m_apgts.DoContent(&m_httpQuery);

			// now add sniffed nodes that were automatically traversed
			// to the stack of navigated nodes - UGLY
			m_httpQuery.PushNodesLastSniffed(m_Conf.GetAPI()->api.pAPI->GetArrLastSniffed());

			// >>> test
			//static int step = 0;
			//char name[16] = {0};
			//sprintf(name, "next_step%d.htm", ++step);
			//ofstream file(name);
			m_apgts.RenderNext(strResult);
			//file << (LPCTSTR)strResult;
			m_apgts.Empty();
		}		
	}
	catch(COleException *pOExc)
	{
		m_dwExtendedErr = (DLSTATTYPES) pOExc->m_sc;
		pOExc->Delete();
		strResult = _T("");
	}
	catch(CBasicException *pExc)
	{
		m_dwExtendedErr = pExc->m_dwBErr;
		delete pExc;
		strResult = _T("");
	}
	unsigned short pErrorStr[2] = { NULL, NULL };
	if (strResult.GetLength() > 0)
	{
		return strResult.AllocSysString();
	}
	else
	{
		return SysAllocString((unsigned short *) pErrorStr);
	}
}

BSTR CTSHOOTCtrl::BackUp()
{
	BCache *pApi = m_Conf.GetAPI()->api.pAPI;
	CString strResult = _T("");
	if (m_httpQuery.BackUp(pApi, &m_apgts))
	{
		m_Conf.GetAPI()->api.pAPI->SetReverse(true);
		m_apgts.DoContent(&m_httpQuery);
		m_apgts.RenderNext(strResult);
		m_apgts.Empty();
	}
	else
		m_dwExtendedErr = TSERR_AT_START;
	return strResult.AllocSysString();
}
// Starter
// Historically (until March '98) this was called when the "Restart button" is pressed.
//	However, that assumed we would always want to go clear back to the problem page, which
//	is no longer policy now that the Launcher is introduced.
BSTR CTSHOOTCtrl::ProblemPage()
{
	BCache *pApi = m_Conf.GetAPI()->api.pAPI;
	CString strResult = _T("");
	if (m_strCurShooter.GetLength() > 0)
	{
		m_httpQuery.RemoveNodes(pApi);
		m_apgts.DoContent(&m_httpQuery);
		m_apgts.RenderNext(strResult);
		m_apgts.Empty();
	}	
	else
		m_dwExtendedErr = TSERR_NOT_STARTED;
	m_apgts.ResetService();
	return strResult.AllocSysString();
}

// Called when the "Restart button" is pressed.
//	If TS Launcher was not involved, go clear back to the problem page.
//	If TS Launcher is involved, go back to the page we launched to, which may or may not
//		be the problem page.
BSTR CTSHOOTCtrl::Restart()
{
	BCache *pApi = m_Conf.GetAPI()->api.pAPI;
	CString strResult;

// >>> test
#ifdef _DEBUG
//	AfxDebugBreak();
#endif

	// resniffing
	m_pSniffedContainer->Flush();
	FireSniffing(m_httpQuery.GetMachine(),
				 m_httpQuery.GetPNPDevice(),
				 m_httpQuery.GetDeviceInstance(),
				 m_httpQuery.GetGuidClass());

	if (m_strCurShooter.GetLength() > 0)
	{
		m_httpQuery.RemoveNodes(pApi);
		m_httpQuery.RestoreStatesFromServ();
		m_apgts.ClearBackup();
		m_apgts.DoContent(&m_httpQuery);
		m_apgts.RenderNext(strResult);
		m_apgts.Empty();
	}	
	else
		m_dwExtendedErr = TSERR_NOT_STARTED;

	return strResult.AllocSysString();
}


BSTR CTSHOOTCtrl::PreLoadURL(LPCTSTR szRoot)
{
	// SzRoot should look like one of these.
	// _T("http://www.microsoft.com/isapi/support/apgts/");
	// _T("http://localhost/isapi/support/apgts/");
	// _T("http://catbert.saltmine.com/scripts/apgts/");
	CString strResult;
	strResult = szRoot;
	strResult += PRELOAD_LIBRARY + m_strCurShooter +
		m_httpQuery.GetSubmitString(m_Conf.GetAPI()->api.pAPI);
	return strResult.AllocSysString();
}

const CString CTSHOOTCtrl::GetListPath()
{
	if (!m_downloadURL.GetLength() || !m_downloadListFilename.GetLength())
		return _T("");

	return m_downloadURL + m_downloadListFilename;
}

//
// Types:
//
// 0 = Get INI file contents and fill up list
//		Returns: 0 = ok, other = Error connecting
//
// 1 = Download and register DSC files based on list
//		Returns: 0 = ok, other = Error, typically no more data in list
//
// Notes:
// 1. This function starts downloading and calls BindStatus event
// as download progresses.
// 2. Type 0 must always be called after type 1 is finished to reset
// the list otherwise an error is returned
// 3. Keep dwActionType and DLITEMTYPES in sync
//
long CTSHOOTCtrl::DownloadAction(long dwActionType)
{
	DLITEMTYPES dwType;
	CString sURL;

	if (!GetListPath().GetLength())
		return LTSCERR_NOPATH;

	if (dwActionType == 0)
	{
		dwType = DLITEM_INI;
		sURL = GetListPath();
		// initialize to 'no error'
		m_dwExtendedErr = LTSC_OK;
		//m_bComplete = FALSE;
	}
	else if (dwActionType == 1)
	{
		//if (!m_bComplete)
		//	return LTSCERR_DNLDNOTDONE;

		dwType = DLITEM_DSC;
		sURL = m_downloadURL;

		if (!m_dnldList.FindNextItem())
			return LTSC_NOMOREITEMS;


		sURL += m_dnldList.GetCurrFile();
	}
	else
		return LTSCERR_UNKNATYPE;

	if (m_download == NULL)
		m_download = new CDownload();
	
	if (m_download == NULL)
		return LTSCERR_NOMEM;

	HRESULT hr = m_download->DoDownload( this, sURL, dwType);

	if (FAILED(hr))
		return LTSCERR_DNLD;

	return LTSC_OK;
}

void CTSHOOTCtrl::OnDownloadListFilenameChanged()
{
	SetModifiedFlag();
}

void CTSHOOTCtrl::OnDownloadURLChanged()
{
	SetModifiedFlag();
}

BSTR CTSHOOTCtrl::GetCurrentFileDownload()
{
	CString strResult = m_dnldList.GetCurrFile();

	return strResult.AllocSysString();
}

BSTR CTSHOOTCtrl::GetCurrentFriendlyDownload()
{
	CString strResult = m_dnldList.GetCurrFriendly();

	return strResult.AllocSysString();
}

long CTSHOOTCtrl::GetExtendedError()
{
	return (m_dwExtendedErr & 0x0000FFFF);
}

VOID CTSHOOTCtrl::StatusEventHelper(DLITEMTYPES dwItem,
										 DLSTATTYPES dwStat,
										 DWORD dwExtended,
										 BOOL bComplete)
{
	m_bComplete = bComplete;
	FireBindStatus(dwItem, dwStat, dwExtended, bComplete);
}

VOID CTSHOOTCtrl::ProgressEventHelper(	DLITEMTYPES dwItem, ULONG ulCurr, ULONG ulTotal )
{
	if (dwItem == DLITEM_INI)
		FireBindProgress(m_downloadListFilename, ulCurr, ulTotal);
	else
		FireBindProgress(m_dnldList.GetCurrFile(), ulCurr, ulTotal);
}

// Input data is null terminated for both binary and text data to simplify processing
//
DLSTATTYPES CTSHOOTCtrl::ProcessReceivedData(DLITEMTYPES dwItem, TCHAR *pData, UINT uLen)
{
	DLSTATTYPES dwStat = LTSC_OK;

	switch(dwItem)
	{
	case DLITEM_INI:
		// processing INI file
		dwStat = ProcessINI(pData);
		break;

	case DLITEM_DSC:
		// processing DSC file
		dwStat = ProcessDSC(pData, uLen);
		break;

	default:
		dwStat = LTSCERR_UNSUPP;
		break;
	}
	return dwStat;
}

// Returns true if we need to update this file
//
BOOL CTSHOOTCtrl::FileRegCheck(CString &sType,
									CString &sFilename,
									CString &sKeyName,
									DWORD dwCurrVersion)
{
	HKEY hk, hknew;
	BOOL bStat = FALSE;
	CString sMainKey;
	
	// figure out what our main key is for this file
	if (sType == TSINI_TYPE_TS)
		sMainKey = TSREGKEY_TL;
	else if (sType == TSINI_TYPE_SF)
		sMainKey = TSREGKEY_SFL;
	else
	{
		m_dwExtendedErr = LTSCERR_BADTYPE;
		return FALSE;
	}

	// first open the main key (try open all access now just in case of permissions problems)
	if (RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
						sMainKey,
						0,
						KEY_ALL_ACCESS,
						&hk) == ERROR_SUCCESS)
	{
		CString sValueName;
		CString sValueClass;
		FILETIME ftLastWriteTime;
		
		DWORD count = 0;
		LONG ldStat = ERROR_SUCCESS;
		BOOL bFound = FALSE;

		while (ldStat == ERROR_SUCCESS)
		{
			LPTSTR lptname = sValueName.GetBuffer(MAX_PATH + 1);
			LPTSTR lptclass = sValueClass.GetBuffer(MAX_PATH + 1);
			
			DWORD namesize = MAX_PATH;
			DWORD classsize = MAX_PATH;
			
			ldStat = RegEnumKeyEx(	hk,
									count,
									lptname,
									&namesize,
									NULL,
									lptclass,
									&classsize,
									&ftLastWriteTime);

			sValueName.ReleaseBuffer();
			sValueClass.ReleaseBuffer();
			
			if (ldStat != ERROR_SUCCESS)
			{
				break;
			}

			if (!sValueName.CompareNoCase(sKeyName))
			{
				// open specific troubleshooter key data (read only)

				if (RegOpenKeyEx(	hk,
									sKeyName,
									0,
									KEY_ALL_ACCESS,
									&hknew) == ERROR_SUCCESS)
				{
					DWORD dwData, dwValue;
					BYTE szValue[MAXCHAR];
					//dwData = REG_DWORD;
					dwData = REG_SZ;
					DWORD dwSize = MAXCHAR;

					if (RegQueryValueEx(hknew,
										TSLCL_FVERSION,
										0,
										&dwData,
										szValue,
										&dwSize) == ERROR_SUCCESS)
					{
						dwValue = _ttoi((TCHAR *) szValue);
						if (dwValue < dwCurrVersion)
							bStat = TRUE;
						else
						{
							// check if file exists
							HANDLE hCurrFind;
							WIN32_FIND_DATA FindCurrData;
							CString sFullPath;

							sFullPath = m_sBasePath + _T("\\") + sFilename;

							hCurrFind = FindFirstFile(sFullPath, &FindCurrData);
							if (hCurrFind != INVALID_HANDLE_VALUE)
							{
								FindClose(hCurrFind);
							}
							else
								bStat = TRUE;
						}

					}
					else
						m_dwExtendedErr = LTSCERR_KEYQUERY;

					RegCloseKey(hknew);
				}
				else
					m_dwExtendedErr = LTSCERR_KEYOPEN2;

				// this is important: set this true to prevent default from trying to download
				// we wont download if we found the key but can't update
				bFound = TRUE;
				break;
			}
			count++;
		}

		if (!bFound)
		{
			bStat = TRUE;
		}

		RegCloseKey(hk);
	}
	else
		m_dwExtendedErr = LTSCERR_KEYOPEN;

	return bStat;
}

DLSTATTYPES CTSHOOTCtrl::ProcessINI(TCHAR *pData)
{
	BOOL bFoundHeader = FALSE;
	int dwCount = 0;
	int dwMaxLines = 10000;
	DLSTATTYPES dwStat = LTSC_OK;

	dwStat = GetPathToFiles();
	if (dwStat != LTSC_OK)
		return dwStat;

	m_dnldList.RemoveAll();

	CString sData = pData;
	
	int dwFullLen = sData.GetLength();

	// just to be safe...
	while (dwMaxLines--)
	{
		CString sFullString = sData.SpanExcluding(_T("\r\n"));
		int dwPartLen = sFullString.GetLength();

		if (!dwPartLen)
			break;

		dwFullLen -= dwPartLen;

		CString sSkipString1 = sData.Right(dwFullLen);
		CString sSkipString2 = sSkipString1.SpanIncluding(_T("\r\n"));

		dwFullLen -= sSkipString2.GetLength();

		sData = sSkipString1.Right(dwFullLen);

		sFullString.TrimLeft();
		sFullString.TrimRight();

		int dwLineLen = sFullString.GetLength();

		if (!dwLineLen)
			continue;

		if (sFullString[0] == _T(';'))
			continue;

		if (sFullString == TSINI_GROUP_STR)
		{
			bFoundHeader = TRUE;
			continue;
		}
		else if (sFullString[0] == _T('['))
		{
			bFoundHeader = FALSE;
			continue;
		}

		if (bFoundHeader)
		{	
			CString sParam[TSINI_LINE_PARAM_COUNT];
			int posstart = 0;

			// now break apart components
			for (int i=0;i<TSINI_LINE_PARAM_COUNT;i++)
			{
				int posend = sFullString.Find(_T(','));
				if (posend == -1 && i < (TSINI_LINE_PARAM_COUNT - 1))
				{
					m_dwExtendedErr = LTSCERR_PARAMMISS;
					break;
				}

				// so we don't find it next time
				if (posend != -1)
					sFullString.SetAt(posend, _T('.'));
				else
					posend = dwLineLen;

				sParam[i] = sFullString.Mid(posstart, posend - posstart);
				sParam[i].TrimLeft();
				sParam[i].TrimRight();

				posstart = posend + 1;
			}

			if (i==TSINI_LINE_PARAM_COUNT)
			{
				// add to object list if (1) version newer or (2) not in list yet
				CString sKeyName;
				DWORD dwVersion = _ttoi(sParam[TSINI_OFFSET_VERSION]);
				int pos;

				pos = sParam[TSINI_OFFSET_FILENAME].Find(_T('\\'));
				if (pos == -1)
				{
					pos = sParam[TSINI_OFFSET_FILENAME].Find(_T('.'));
					if (pos != -1)
					{
						if (sParam[TSINI_OFFSET_TYPE] == TSINI_TYPE_TS)
							sKeyName = sParam[TSINI_OFFSET_FILENAME].Left(pos);
						else {
							sKeyName = sParam[TSINI_OFFSET_FILENAME];
							//sKeyName.SetAt(pos, _T('_'));
						}

						// for now, check if we meet criteria
						// if yes, just add to list and download on a later iteration
						if (FileRegCheck(sParam[TSINI_OFFSET_TYPE], sParam[TSINI_OFFSET_FILENAME], sKeyName, dwVersion))
						{
							CDnldObj *pDnld = new CDnldObj(	sParam[TSINI_OFFSET_TYPE],
															sParam[TSINI_OFFSET_FILENAME],
															dwVersion,
															sParam[TSINI_OFFSET_FRIENDLY],
															sKeyName);

							if (pDnld)
							{
								m_dnldList.AddTail(pDnld);
								dwCount++;
							}
							else
							{
								dwStat = LTSCERR_NOMEM;
								break;
							}
						}
					}
					else
						m_dwExtendedErr = LTSCERR_PARAMNODOT;
				}
				else
					m_dwExtendedErr = LTSCERR_PARAMSLASH;
			}
		}
	}

	ASSERT(dwCount == m_dnldList.GetCount());

	if (!dwCount)
		dwStat = LTSCERR_NOITEMS;
	
	m_dnldList.SetFirstItem();

	return dwStat;
}

//
//
DLSTATTYPES CTSHOOTCtrl::GetPathToFiles()
{
	DLSTATTYPES dwStat = LTSC_OK;
	HKEY hk;
	
	if (RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
						TSREGKEY_MAIN,
						0,
						KEY_READ,
						&hk) == ERROR_SUCCESS)
	{
		DWORD dwData = REG_SZ;
		DWORD dwSize = MAX_PATH;
		LPTSTR lptBuf = m_sBasePath.GetBuffer(MAX_PATH + 2);

		if (RegQueryValueEx(hk,
							FULLRESOURCE_STR,
							0,
							&dwData,
							(LPBYTE) lptBuf,
							&dwSize) != ERROR_SUCCESS)
		{
			dwStat = LTSCERR_BASEKQ;
		}

		m_sBasePath.ReleaseBuffer();

		RegCloseKey(hk);
	}
	else
		dwStat = LTSCERR_NOBASEPATH;
	return dwStat;
}


DLSTATTYPES CTSHOOTCtrl::ProcessDSC(TCHAR *pData, UINT uLen)
{
	DLSTATTYPES dwStat = LTSC_OK;
	HKEY hknew;
	DWORD dwDisposition;
	CString sMainKey;
	
	// we get here if we need to update this file
	// at this point we have the file downloaded and need to save it
	// we also need to create/update the necessary registry keys

	// since we know the entire key name, let's go ahead to create it
	if (m_dnldList.GetCurrType() == TSINI_TYPE_SF)
		sMainKey = TSREGKEY_SFL;
	else
		sMainKey = TSREGKEY_TL;

	sMainKey += _T("\\") + m_dnldList.GetCurrFileKey();

	// open specific troubleshooter key data
	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE,
						sMainKey,
						0,
						TSLCL_REG_CLASS,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&hknew,
						&dwDisposition) == ERROR_SUCCESS)
	{
		if (dwDisposition == REG_CREATED_NEW_KEY || dwDisposition == REG_OPENED_EXISTING_KEY)
		{
			DWORD dwData = m_dnldList.GetCurrVersion();
			CString str;
			str.Format(_T("%d"), dwData);
			if (RegSetValueEx(	hknew,
								TSLCL_FVERSION,
								0,
								//REG_DWORD,
								REG_SZ,
								(LPBYTE) (LPCTSTR) str,
								str.GetLength() + sizeof(TCHAR)) != ERROR_SUCCESS)
			{
				dwStat = LTSCERR_FILEUPDATE;
				m_dwExtendedErr = LTSCERR_KEYSET1;
			}

			if (dwStat == LTSC_OK)
			{
				CString sTemp = m_dnldList.GetCurrFriendly();
				DWORD dwSize = sTemp.GetLength() + sizeof(TCHAR);
				LPCTSTR lpctFN = sTemp.GetBuffer(100);
				
				if (RegSetValueEx(	hknew,
									FRIENDLY_NAME,
									0,
									REG_SZ,
									(LPBYTE) lpctFN,
									dwSize) == ERROR_SUCCESS)
				{
					CFile sF;
					CFileException exc;
					CString sFullPath;

					sFullPath = m_sBasePath + _T("\\") + m_dnldList.GetCurrFile();

					if (sF.Open(sFullPath, CFile::modeCreate | CFile::modeWrite, &exc))
					{
						TRY
						{
							sF.Write(pData, uLen);
						}
						CATCH (CFileException, e)
						{
							dwStat = LTSCERR_FILEUPDATE;
							m_dwExtendedErr = LTSCERR_FILEWRITE;						
						}
						END_CATCH
						
						sF.Close();

						// uncompress if a cab file (be dumb, assume .cab really means a cab file)

						int pos = sFullPath.Find(_T('.'));
						if (pos != -1)
						{
							CString sTemp = sFullPath.Right(sFullPath.GetLength() - pos);
							if (!sTemp.CompareNoCase(_T(".cab")))
							{
								CCabUnCompress cab;
								CString strDestDir = m_sBasePath + "\\";
		
								if (!cab.ExtractCab(sFullPath, strDestDir, ""))
								{
									dwStat = LTSCERR_FILEUPDATE;
									m_dwExtendedErr = LTSCERR_CABWRITE;
								}

								TRY
								{
									CFile::Remove(sFullPath);
								}
								CATCH (CFileException, e)
								{
									// error is not very interesting
								}
								END_CATCH
							}
						}
					}
					else
					{		
						dwStat = LTSCERR_FILEUPDATE;
						m_dwExtendedErr = LTSCERR_FILEWRITE;
					}
				}
				else
				{
					dwStat = LTSCERR_FILEUPDATE;
					m_dwExtendedErr = LTSCERR_KEYSET2;
				}
				sTemp.ReleaseBuffer();
			}

			if (dwStat == LTSC_OK)
			{
				CString sTemp = m_dnldList.GetCurrExt();
				DWORD dwSize = sTemp.GetLength() + sizeof(TCHAR);
				LPCTSTR lpctFN = sTemp.GetBuffer(100);
				
				if (RegSetValueEx(	hknew,
									TSLCL_FMAINEXT,
									0,
									REG_SZ,
									(LPBYTE) lpctFN,
									dwSize) != ERROR_SUCCESS)
				{
					dwStat = LTSCERR_FILEUPDATE;
					m_dwExtendedErr = LTSCERR_KEYSET3;
				}
				sTemp.ReleaseBuffer();
			}
		}
		else
		{
			dwStat = LTSCERR_FILEUPDATE;
			m_dwExtendedErr = LTSCERR_KEYUNSUPP;
		}
	
		RegCloseKey(hknew);
	}
	else
	{
		dwStat = LTSCERR_FILEUPDATE;
		m_dwExtendedErr = LTSCERR_KEYCREATE;
	}
	return dwStat;
}

// Added 1/20/99 JM because RunQuery() can't be made to work with JScript, even though it
//	worked fine with VB Script.
// Simulates the form in which RunQuery() would normally get its arguments, then pass them
//	into RunQuery.
BSTR CTSHOOTCtrl::RunQuery2(LPCTSTR szTopic, LPCTSTR szCmd, LPCTSTR szVal)
{
	VARIANT varCommands;
	VARIANT varValues;
	VARIANT varCommandsWrap;
	VARIANT varValuesWrap;
	SAFEARRAY *psafearrayCmds;
	SAFEARRAY *psafearrayVals;

	VariantInit(&varCommands);
	VariantInit(&varValues);
	VariantInit(&varCommandsWrap);
	VariantInit(&varValuesWrap);

	SAFEARRAYBOUND sabCmd;
	sabCmd.cElements = 2;
	sabCmd.lLbound = 0;
	SAFEARRAYBOUND sabVal = sabCmd;

	V_VT(&varCommands) = VT_ARRAY | VT_BYREF | VT_VARIANT;
	V_VT(&varValues) = VT_ARRAY | VT_BYREF | VT_VARIANT;
	V_ARRAYREF(&varCommands) = &psafearrayCmds;
	V_ARRAYREF(&varValues) = &psafearrayVals;

	V_VT(&varCommandsWrap) = VT_BYREF | VT_VARIANT;
	V_VT(&varValuesWrap) = VT_BYREF | VT_VARIANT;

	V_VARIANTREF(&varCommandsWrap) = &varCommands;
	V_VARIANTREF(&varValuesWrap) = &varValues;

	// If first character in szCmd is a null, then there will be only one significant
	//	element in each of the arrays we are constructing below, otherwise 2.
	short size = (*szCmd) ? 2 : 1;

	CString strType(C_TYPE);
	BSTR bstrType = strType.AllocSysString();
	VARIANT varType;
	VariantInit(&varType);
	V_VT(&varType) = VT_BSTR;
	varType.bstrVal=bstrType;

	CString strTopic(szTopic);
	BSTR bstrTopic = strTopic.AllocSysString();
	VARIANT varTopic;
	VariantInit(&varTopic);
	V_VT(&varTopic) = VT_BSTR;
	varTopic.bstrVal=bstrTopic;

	CString strCmd(szCmd);
	BSTR bstrCmd = strCmd.AllocSysString();
	VARIANT varCmd;
	VariantInit(&varCmd);
	V_VT(&varCmd) = VT_BSTR;
	varCmd.bstrVal=bstrCmd;

	CString strVal(szVal);
	BSTR bstrVal = strVal.AllocSysString();
	VARIANT varVal;
	VariantInit(&varVal);
	V_VT(&varVal) = VT_BSTR;
	varVal.bstrVal=bstrVal;

	// create two vectors of BSTRs
	psafearrayCmds = SafeArrayCreate( VT_VARIANT, 1, &sabCmd);
	psafearrayVals = SafeArrayCreate( VT_VARIANT, 1, &sabVal);

	long i=0;
	SafeArrayPutElement(psafearrayCmds, &i, &varType);
	SafeArrayPutElement(psafearrayVals, &i, &varTopic);

	i=1;
	SafeArrayPutElement(psafearrayCmds, &i, &varCmd);
	SafeArrayPutElement(psafearrayVals, &i, &varVal);

	BSTR ret = RunQuery(varCommandsWrap, varValuesWrap, size);

	SafeArrayDestroy(psafearrayCmds);
	SafeArrayDestroy(psafearrayVals);

	SysFreeString(bstrType);
	SysFreeString(bstrTopic);
	SysFreeString(bstrCmd);
	SysFreeString(bstrVal);

	return ret;
}

// This function is a no-op and exist solely to allow us to write JScript that is
//	forward compatible to Local Troubleshooter version 3.1
void CTSHOOTCtrl::SetPair(LPCTSTR szName, LPCTSTR szValue)
{	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\properties.cpp ===
// 
// MODULE: Properties.cpp
//
// PURPOSE: State variables that are changed here are not
//			reset when TSLReInit is used.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>

#include "TSLError.h"
#include "LaunchServ.h"

#include <comdef.h>
#include "Properties.h"


DWORD MachineID(ITShootATL *pITShootATL, _bstr_t &bstrMachineID)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->MachineID(bstrMachineID, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD DeviceInstanceID(ITShootATL *pITShootATL, _bstr_t &bstrDeviceInstanceID)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->DeviceInstanceID(bstrDeviceInstanceID, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD PreferOnline(ITShootATL *pITShootATL, BOOL bPreferOnline)
{
	HRESULT hRes;
	DWORD dwResult = TSL_OK;
	hRes = pITShootATL->put_PreferOnline(bPreferOnline);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\launchers.h ===
// 
// MODULE: Launchers.h
//
// PURPOSE: All of the functions here launch a troubleshooter or
//			do a query to find if a mapping exists.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

DWORD LaunchKnownTSA(ITShootATL *pITShootATL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, 
		const char ** pszNode, DWORD* pVal);		// Launches to a known network.  Optionaly can set any node.
DWORD LaunchKnownTSW(ITShootATL *pITShootATL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, 
		const wchar_t ** pszNode, DWORD* pVal);		// Launches to a known network.  Optionaly can set any node.


DWORD Launch(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrAppProblem, short bLaunch);

DWORD LaunchDevice(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrPNPDeviceID, 
				_bstr_t &bstrDeviceClassGUID, _bstr_t &bstrAppProblem, short bLaunch);

void SetStatusA(DWORD dwStaus, DWORD nChar, char szBuf[]);
void SetStatusW(DWORD dwStaus, DWORD nChar, wchar_t szBuf[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\tshootctl.h ===
//
// MODULE: TSHOOTCTL.H
//
// PURPOSE: Declaration of the CTSHOOTCtrl OLE control class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

// INI section header
#define TSINI_GROUP_STR			_T("[TSLocalDownload.V1]")

// file types (maps to sub key lists)
#define TSINI_TYPE_TS			_T("TS")
#define TSINI_TYPE_SF			_T("SF")

// parameter offset in INI
#define TSINI_OFFSET_TYPE		0
#define TSINI_OFFSET_FILENAME	1
#define TSINI_OFFSET_VERSION	2
#define TSINI_OFFSET_FRIENDLY	3
//
#define TSINI_LINE_PARAM_COUNT	4

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl : See TSHOOTCtl.cpp for implementation.

// Roman Mach believes (3/14/98) that there is exactly one object of this type in the Local
//	Troubleshooter and that this object persists intact as we move from node to node within 
//	a troubleshooting belief network.  (This may not be strictly true if the "Download"  
//	feature is used.)  Since this class can be DYNCREATEd it's hard to verify this definitively.
class CTSHOOTCtrl : public COleControl
{
#define PRELOAD_LIBRARY _T("apgts.dll?preload=")
	DECLARE_DYNCREATE(CTSHOOTCtrl)

// Constructor
public:
	CTSHOOTCtrl();

	VOID StatusEventHelper(	DLITEMTYPES dwItem, 
							DLSTATTYPES dwStat, 
							DWORD dwExtended = 0, 
							BOOL bComplete = FALSE);
	
	VOID ProgressEventHelper( DLITEMTYPES dwItem, ULONG ulCurr, ULONG ulTotal );

	DLSTATTYPES ProcessReceivedData(DLITEMTYPES dwItem, TCHAR *pData, UINT uLen);
	
	const CString GetListPath();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTSHOOTCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CTSHOOTCtrl();
	CString m_strCurShooter;
	APGTSContext m_apgts;
	CDBLoadConfiguration m_Conf;
	CHttpQuery m_httpQuery;

	DECLARE_OLECREATE_EX(CTSHOOTCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CTSHOOTCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CTSHOOTCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CTSHOOTCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CTSHOOTCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CTSHOOTCtrl)
	CString m_downloadURL;
	afx_msg void OnDownloadURLChanged();
	CString m_downloadListFilename;
	afx_msg void OnDownloadListFilenameChanged();
	afx_msg BSTR RunQuery(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size);
	afx_msg bool SetSniffResult(const VARIANT FAR& varNodeName, const VARIANT FAR& varState);
	afx_msg long GetExtendedError();
	afx_msg BSTR GetCurrentFriendlyDownload();
	afx_msg BSTR GetCurrentFileDownload();
	afx_msg long DownloadAction(long dwActionType);
	afx_msg BSTR BackUp();
	afx_msg BSTR ProblemPage();
	afx_msg BSTR PreLoadURL(LPCTSTR szRoot);
	afx_msg BSTR Restart();
	afx_msg BSTR RunQuery2(LPCTSTR szTopic, LPCTSTR szCmd, LPCTSTR szVal);
	afx_msg void SetPair(LPCTSTR szName, LPCTSTR szValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CTSHOOTCtrl)
	void FireBindProgress(LPCTSTR sFile, long ulCurr, long ulTotal)
		{FireEvent(eventidBindProgress,EVENT_PARAM(VTS_BSTR  VTS_I4  VTS_I4), sFile, ulCurr, ulTotal);}
	void FireBindStatus(long uItem, long uStat, long uExtended, BOOL bComplete)
		{FireEvent(eventidBindStatus,EVENT_PARAM(VTS_I4  VTS_I4  VTS_I4  VTS_BOOL), uItem, uStat, uExtended, bComplete);}
	void FireSniffing(LPCTSTR strMachine, LPCTSTR strPNPDevice, LPCTSTR strDeviceInstance, LPCTSTR strClassGuid)
		{FireEvent(eventidSniffing,EVENT_PARAM(VTS_BSTR  VTS_BSTR  VTS_BSTR  VTS_BSTR), strMachine, strPNPDevice, strDeviceInstance, strClassGuid);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CTSHOOTCtrl)
	dispidDownloadURL = 1L,
	dispidDownloadListFilename = 2L,
	dispidRunQuery = 3L,
	dispidSetSniffResult = 4L,
	dispidGetExtendedError = 5L,
	dispidGetCurrentFriendlyDownload = 6L,
	dispidGetCurrentFileDownload = 7L,
	dispidDownloadAction = 8L,
	dispidBackUp = 9L,
	dispidProblemPage = 10L,
	dispidPreLoadURL = 11L,
	dispidRestart = 12L,
	dispidRunQuery2 = 13L,
	dispidSetPair = 14L,
	eventidBindProgress = 1L,
	eventidBindStatus = 2L,
	eventidSniffing = 3L,
	//}}AFX_DISP_ID
	};

protected:
	DLSTATTYPES ProcessINI(TCHAR *pData);
	DLSTATTYPES ProcessDSC(TCHAR *pData, UINT uLen);
	BOOL FileRegCheck(CString &sType, CString &sFilename, CString &sKeyName, DWORD dwCurrVersion);
	DLSTATTYPES GetPathToFiles();

protected:
	BOOL m_bComplete;
	CDownload *m_download;
	CDnldObjList m_dnldList;
	DWORD m_dwExtendedErr;
	CString m_sBasePath;
	CSniffedNodeContainer* m_pSniffedContainer; // pointer to container to save results of sniffing
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Status.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING1006                  1006
#define IDS_STRING1007                  1007
#define IDS_STRING1008                  1008
#define IDS_STRING1009                  1009
#define IDS_STRING1010                  1010
#define IDS_STRING1011                  1011
#define IDS_STRING1012                  1012
#define IDS_STRING1013                  1013
#define IDS_STRING1014                  1014
#define IDS_STRING1015                  1015
#define IDS_STRING1016                  1016
#define IDS_STRING1017                  1017
#define IDS_STRING4002                  4002
#define IDS_STRING4003                  4003
#define IDS_STRING4004                  4004
#define IDS_STRING4005                  4005
#define IDS_STRING4006                  4006
#define IDS_STRING4007                  4007
#define IDS_STRING4008                  4008
#define IDS_STRING4009                  4009
#define IDS_STRING4010                  4010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\properties.h ===
// 
// MODULE: Properties.cpp
//
// PURPOSE: State variables that are changed here are not
//			reset when TSLReInit is used.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

DWORD MachineID(ITShootATL *pITShootATL, _bstr_t &bstrMachineID);

DWORD DeviceInstanceID(ITShootATL *pITShootATL, _bstr_t &bstrDeviceInstanceID);

DWORD PreferOnline(ITShootATL *pITShootATL, BOOL bPreferOnline);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\tshootppg.cpp ===
//
// MODULE: TSHOOTPPG.CPP
//
// PURPOSE: Implementation of the CTSHOOTPropPage property page class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "TSHOOT.h"
#include "TSHOOTPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CTSHOOTPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTSHOOTPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CTSHOOTPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CTSHOOTPropPage, "TSHOOT.TSHOOTPropPage.1",
	0x4b106875, 0xdd36, 0x11d0, 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff)


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage::CTSHOOTPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CTSHOOTPropPage

BOOL CTSHOOTPropPage::CTSHOOTPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_TSHOOT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage::CTSHOOTPropPage - Constructor

CTSHOOTPropPage::CTSHOOTPropPage() :
	COlePropertyPage(IDD, IDS_TSHOOT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CTSHOOTPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage::DoDataExchange - Moves data between page and properties

void CTSHOOTPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CTSHOOTPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\launchers.cpp ===
// 
// MODULE: Launchers.cpp
//
// PURPOSE: All of the functions here launch a troubleshooter or
//			do a query to find if a mapping exists.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>

#include "TSLError.h"
#include <TSLauncher.h>
#include "LaunchServ.h"

#include <comdef.h>
#include "Launchers.h"

#include "tsmfc.h"

#include <stdio.h>
#include <string.h>


// LaunchKnownTS:  Launches the trouble shooter to a specified 
// network, problem node, and can also set nodes.
DWORD LaunchKnownTSA(ITShootATL *pITShootATL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, const char ** pszNode, DWORD* pVal)
{
	HRESULT hRes;
	CHAR szValue[512];
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->ReInit();
	// Set the network and problem node.
	_bstr_t bstrNet(szNet);
	_bstr_t bstrProblem(szProblemNode);
	hRes = pITShootATL->SpecifyProblem(bstrNet, bstrProblem, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		return TSL_ERROR_OBJECT_GONE;
	if (TSLIsError(dwResult))
		return dwResult;
	// Set the nodes
	for (DWORD x = 0; x < nNode; x++)
	{
		sprintf(szValue, "%ld", pVal[x]);
		_bstr_t bstrNode(pszNode[x]);
		_bstr_t bstrVal(szValue);
		hRes = pITShootATL->SetNode(bstrNode, bstrVal, &dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		if (TSLIsError(dwResult))
			return dwResult;
	}
	hRes = pITShootATL->LaunchKnown(&dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD LaunchKnownTSW(ITShootATL *pITShootATL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, const wchar_t ** pszNode, DWORD* pVal)
{
	HRESULT hRes;
	WCHAR szValue[512];
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->ReInit();
	// Set the network and problem node.
	_bstr_t bstrNet(szNet);
	_bstr_t bstrProblem(szProblemNode);
	hRes = pITShootATL->SpecifyProblem(bstrNet, bstrProblem, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		return TSL_ERROR_OBJECT_GONE;
	if (TSLIsError(dwResult))
		return dwResult;
	// Set the nodes
	for (DWORD x = 0; x < nNode; x++)
	{
		swprintf(szValue, L"%ld", pVal[x]);
		_bstr_t bstrNode(pszNode[x]);
		_bstr_t bstrVal(szValue);
		hRes = pITShootATL->SetNode(bstrNode, bstrVal, &dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		if (TSLIsError(dwResult))
			return dwResult;
	}
	hRes = pITShootATL->LaunchKnown(&dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD Launch(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrAppProblem, short bLaunch)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->Launch(bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD LaunchDevice(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrPNPDeviceID, 
				_bstr_t &bstrDeviceClassGUID, _bstr_t &bstrAppProblem, short bLaunch)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->LaunchDevice(bstrCallerName, bstrCallerVersion, bstrPNPDeviceID,
							bstrDeviceClassGUID, bstrAppProblem, bLaunch, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

void SetStatusA(DWORD dwStatus, DWORD nChar, char szBuf[])
{
	AfxLoadStringA(dwStatus, szBuf, nChar);
	return;
}

void SetStatusW(DWORD dwStatus, DWORD nChar, wchar_t szBuf[])
{
	AfxLoadStringW(dwStatus, szBuf, nChar);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\control\tshootppg.h ===
//
// MODULE: TSHOOTPPG.H
//
// PURPOSE: Declaration of the CTSHOOTPropPage property page class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage : See TSHOOTPpg.cpp.cpp for implementation.

class CTSHOOTPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CTSHOOTPropPage)
	DECLARE_OLECREATE_EX(CTSHOOTPropPage)

// Constructor
public:
	CTSHOOTPropPage();

// Dialog Data
	//{{AFX_DATA(CTSHOOTPropPage)
	enum { IDD = IDD_PROPPAGE_TSHOOT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CTSHOOTPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\shortlist.h ===
// 
// MODULE: ShortList.h
//
// PURPOSE: A list of all of the handles that are currently open.
//			There is an instance of a COM interface for every open handle.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

// Smart Struct
class CShortListItem
{
public:
	CShortListItem() {	m_hSelf = NULL; m_pInterface = NULL; 
						m_pNext = NULL; 
						return;};

	HANDLE m_hSelf;				// The items in the queue are indexed by the handle.
	IUnknown *m_pInterface;		// For now the ITShootATL interface pointers are the only thing TSLaunch needs to keep.
	CShortListItem *m_pNext;	// Points to the next item in the list.
};

class CShortList
{
public:
	CShortList();
	~CShortList();	// Frees the memory used by all of the items in the list and releases the interfaces.

	bool Add(HANDLE hItem, IUnknown *pInterface);	// Returns false only if there is no memory left.
												// and the new function did not throw an exception.
	bool Remove(HANDLE hItem);	// Removes the item from the queue frees the items memory and releases the interface.
	void RemoveAll();		// Removes all of the items from the queue.  Releases all of the interfaces.  Deletes all of the items.
	IUnknown *LookUp(HANDLE hItem);	// Returns a pointer to the interface or NULL if hItem is not in the list.

protected:

	CShortListItem *m_pFirst;
	CShortListItem *m_pLast;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\shortlist.cpp ===
// 
// MODULE: ShortList.cpp
//
// PURPOSE: A list of all of the handles that are currently open.
//			There is an instance of a COM interface for every open handle.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>
#include <ole2.h>
#include "ShortList.h"

CShortList::CShortList()
{
	m_pFirst = NULL;
	m_pLast = NULL;
	return;
}

CShortList::~CShortList()
{
	RemoveAll();
	return;
}
// Removes all of the items from the queue.  Releases all of the interfaces.  Deletes all of the items.
void CShortList::RemoveAll()
{
	CShortListItem *pDelItem;
	while (NULL != m_pFirst)
	{
		pDelItem = m_pFirst;
		m_pFirst = m_pFirst->m_pNext;
		pDelItem->m_pInterface->Release();
		delete pDelItem;
	}
	m_pFirst = NULL;
	m_pLast = NULL;
	return;
}
// Add:  Returns false only if there is no memory left.
bool CShortList::Add(HANDLE hItem, IUnknown *pInterface)
{
	bool bHaveMemory = true;
	CShortListItem *pItem = new CShortListItem;
	if (NULL == pItem)
	{
		bHaveMemory = false;
	}
	else
	{
		pItem->m_hSelf = hItem;
		pItem->m_pInterface = pInterface;
		if (NULL == m_pFirst)
		{
			m_pFirst = pItem;
			m_pLast = pItem;
		}
		else
		{	// Add the item to the end of the list.
			m_pLast->m_pNext = pItem;
			m_pLast = pItem;
		}
	}
	return bHaveMemory;
}
// Remove:  Removes the item from the queue, frees the item's memory and releases the interface.
// Returns false if the hItem is not found.
bool CShortList::Remove(HANDLE hItem)
{
	CShortListItem *pPrevious;
	CShortListItem *pItem;
	bool bItemFound = true;
	if (NULL == m_pFirst)
		return false;
	// Case 1 item.
	if (m_pLast == m_pFirst)
	{
		if (m_pFirst->m_hSelf == hItem)
		{
			m_pLast->m_pInterface->Release();
			delete m_pLast;
			m_pFirst = NULL;
			m_pLast = NULL;
		}
		else
		{
			bItemFound = false;
		}
	} // Case 2 items.
	else if (m_pFirst->m_pNext == m_pLast)
	{
		if (hItem == m_pFirst->m_hSelf)
		{
			m_pFirst->m_pInterface->Release();
			delete m_pFirst;
			m_pFirst = m_pLast;
		}
		else if (hItem == m_pLast->m_hSelf)
		{
			m_pLast->m_pInterface->Release();
			delete m_pLast;
			m_pLast = m_pFirst;
		}
		else
		{
			bItemFound = false;
		}
	} // Case 3 or more items.
	else if (NULL != m_pFirst)
	{	
		// Case First item in the list.
		if (hItem == m_pFirst->m_hSelf)
		{
			pItem = m_pFirst;
			m_pFirst = m_pFirst->m_pNext;
			pItem->m_pInterface->Release();
			delete pItem;
		}
		else
		{	// Look for the item in the list.
			pItem = m_pFirst;
			bItemFound = false;
			do
			{
				pPrevious = pItem;
				pItem = pItem->m_pNext;
				if (hItem == pItem->m_hSelf)
				{
					bItemFound = true;
					// Case last item.
					if (pItem == m_pLast)
					{
						pItem->m_pInterface->Release();
						delete pItem;
						m_pLast = pPrevious;
						m_pLast->m_pNext = NULL;
					}
					else
					{	// Some where in the middle.
						CShortListItem *pDelItem = pItem;
						pPrevious->m_pNext = pItem->m_pNext;
						pDelItem->m_pInterface->Release();
						delete pDelItem;
					}
					pItem = NULL;
				}
			} while (NULL != pItem);
		}
	}
	else
	{
		bItemFound = false;
	}
	return bItemFound;
}
// LookUp:  Returns a pointer to the interface or NULL if hItem is not in the list.
IUnknown *CShortList::LookUp(HANDLE hItem)
{
	IUnknown *pIAny = NULL;
	CShortListItem *pItem = m_pFirst;
	while(NULL != pItem)
	{
		if (hItem == pItem->m_hSelf)
		{
			pIAny = pItem->m_pInterface;
			break;
		}
		pItem = pItem->m_pNext;
	}
	return pIAny;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\tslauncher.cpp ===
// 
// MODULE: TSLaunchDLL.cpp
//
// PURPOSE: The functions that are exported by TSLauncher.dll.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHORS: Joe Mabel and Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>
#include <ole2.h>
#include "TSLError.h"
#define __TSLAUNCHER	    1
#include <TSLauncher.h>
#include "ShortList.h"

#include "LaunchServ_i.c"
#include "LaunchServ.h"

#include <comdef.h>
#include "Properties.h"
#include "Launchers.h"

#include <objbase.h>

static int g_NextHandle = 1;
static CShortList g_unkList;
HINSTANCE g_hInst;

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	switch(fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		g_hInst = hinstDLL;
		break;
	case DLL_PROCESS_DETACH :
	case DLL_THREAD_DETACH :
//		g_unkList.RemoveAll();		This causes an access violation if the list is not already empty.
		// Saltmine Creative should not be providing a library that uses a com object.
		// Saltmine Creative should be providing com objects and not this legacy dll.
		break;
	}
	return TRUE;
}

/* TSLOpen
	Returns a handle that should be passed into subsequent Troubleshooter Launcher calls 
	as hTSL.  Returns NULL handle on failure.  (Should only fail on out of memory, 
	probably will never arise.)
*/
HANDLE WINAPI TSLOpen()
{
	HRESULT hRes;
	CLSID clsidLaunchTS = CLSID_TShootATL;
	IID iidLaunchTS = IID_ITShootATL;
	HANDLE hResult = (HANDLE) g_NextHandle;
	ITShootATL *pITShootATL = NULL;
	hRes = CoCreateInstance(clsidLaunchTS, NULL, 
				CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER | CLSCTX_INPROC_SERVER, 
					iidLaunchTS, (void **) &pITShootATL);
	if (FAILED(hRes))
	{
		hResult = NULL;
	}
	else
	{
		if (g_unkList.Add(hResult, pITShootATL))
			g_NextHandle++;
		else
			hResult = NULL;
	}
	return hResult;
}

/* TSLClose
	Closes handle.  Returns TSL_OK (== 0) if handle was open, otherwise TSL_ERROR_BAD_HANDLE.
*/
DWORD WINAPI TSLClose (HANDLE hTSL)
{
	DWORD dwResult = TSL_OK;
	if (!g_unkList.Remove(hTSL))
		dwResult = TSL_ERROR_BAD_HANDLE;
	return dwResult;
}

/* TSLReInit
	Reinitializes handle.  Functionally the same as a TSLClose followed by TSLOpen, but more
	efficient.  Returns same handle as passed in, if handle was OK, otherwise NULL.
*/
HANDLE WINAPI TSLReInit (HANDLE hTSL)
{
	HRESULT hRes;
	HANDLE hResult = NULL;

	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		hRes = pITShootATL->ReInit();
		if (!FAILED(hRes))
			hResult = hTSL;
	}
	return hResult;
}

/* TSLLaunchKnownTS
	Launches to a known troubleshooting belief network and (optionally) problem node. 
	If you know the particular troubleshooting network and problem, use this call.  
	If setting network but not problem, pass in a NULL for szProblemNode.

	Also allows setting arbitrary nodes.  
	nNode gives the number of nodes to set. pszNode, pVal are 
	arrays (dimension nNode) of symbolic node names and corresponding values. 

   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch failed, call TSLStatus
	TSL_WARNING_GENERAL			launch succeded, call TSLStatus for warnings
*/
DWORD WINAPI TSLLaunchKnownTSA(HANDLE hTSL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, const char ** pszNode, DWORD* pVal)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = LaunchKnownTSA(pITShootATL, szNet, szProblemNode, nNode, pszNode, pVal);
	}
	return dwResult;
}

DWORD WINAPI TSLLaunchKnownTSW(HANDLE hTSL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, const wchar_t ** pszNode, DWORD* pVal)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = LaunchKnownTSW(pITShootATL, szNet, szProblemNode, nNode, pszNode, pVal);
	}
	return dwResult;
}
/* TSLLaunch
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeeded, call TSLStatus for warnings
*/
DWORD WINAPI TSLLaunchA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szAppProblem, bool bLaunch)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrAppProblem(szAppProblem);
		dwResult = Launch(pITShootATL, bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch);
	}
	return dwResult;
}

DWORD WINAPI TSLLaunchW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szAppProblem, bool bLaunch)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrAppProblem(szAppProblem);
		dwResult = Launch(pITShootATL, bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch);
	}
	return dwResult;
}

/* TSLLaunchDevice
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, Plug & Play Device ID, Device Class GUID, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeded, call TSLStatus for warnings
*/
DWORD WINAPI TSLLaunchDeviceA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szPNPDeviceID, 
				const char * szDeviceClassGUID, const char * szAppProblem, bool bLaunch)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrPNPDeviceID(szPNPDeviceID);
		_bstr_t bstrDeviceClassGUID(szDeviceClassGUID);
		_bstr_t bstrAppProblem(szAppProblem);

		dwResult = LaunchDevice(pITShootATL, bstrCallerName, bstrCallerVersion, 
								bstrPNPDeviceID, bstrDeviceClassGUID, 
								bstrAppProblem, bLaunch);
	}
	return dwResult;
}

DWORD WINAPI TSLLaunchDeviceW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szPNPDeviceID, 
				const wchar_t * szDeviceClassGUID, const wchar_t * szAppProblem, bool bLaunch) 
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrPNPDeviceID(szPNPDeviceID);
		_bstr_t bstrDeviceClassGUID(szDeviceClassGUID);
		_bstr_t bstrAppProblem(szAppProblem);

		dwResult = LaunchDevice(pITShootATL, bstrCallerName, bstrCallerVersion, 
								bstrPNPDeviceID, bstrDeviceClassGUID, 
								bstrAppProblem, bLaunch);
	}
	return dwResult;
}

/* Preferences ----------------------------------- */

/* TSLPreferOnline
	Specify a preference for or against online debugger.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
*/
DWORD WINAPI TSLPreferOnline(HANDLE hTSL, BOOL bPreferOnline)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = PreferOnline(pITShootATL, bPreferOnline);
	}
	return dwResult;
}


/* TSLLanguage 
	Specify language, using Unicode-style 3-letter language ID.  This overrides the system 
	default.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
   Cannot return TSL_WARNING_LANGUAGE, because we will not know this till we try combining
	language and troubleshooting network.
*/
DWORD WINAPI TSLLanguageA(HANDLE hTSL, const char * szLanguage)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{

		dwResult = TSL_OK;
	}
	return dwResult;
}

DWORD WINAPI TSLLanguageW(HANDLE hTSL, const wchar_t * szLanguage)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{

		dwResult = TSL_OK;
	}
	return dwResult;
}


/* Sniffing ---------------------------- */
/* TSLMachineID
	Necessary to support sniffing on a remote machine.  
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_MACHINE_ID
	TSL_ERROR_BAD_MACHINE_ID
*/
DWORD WINAPI TSLMachineIDA(HANDLE hTSL, const char* szMachineID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrMachineID(szMachineID);
		dwResult = MachineID(pITShootATL, bstrMachineID);
	}
	return dwResult;
}

DWORD WINAPI TSLMachineIDW(HANDLE hTSL, const wchar_t* szMachineID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrMachineID(szMachineID);
		dwResult = MachineID(pITShootATL, bstrMachineID);
	}
	return dwResult;
}

/* TSLDeviceInstanceIDA
	Necessary to support sniffing.  For example, if there are two of the same card on a 
	machine, the Plug & Play ID is of limited use for sniffing.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_DEVINST_ID
	TSL_ERROR_BAD_DEVINST_ID
*/
DWORD WINAPI TSLDeviceInstanceIDA(HANDLE hTSL, const char* szDeviceInstanceID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrDeviceInstanceID(szDeviceInstanceID);
		dwResult = DeviceInstanceID(pITShootATL, bstrDeviceInstanceID);
	}
	return dwResult;
}

DWORD WINAPI TSLDeviceInstanceIDW(HANDLE hTSL, const wchar_t* szDeviceInstanceID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrDeviceInstanceID(szDeviceInstanceID);
		dwResult = DeviceInstanceID(pITShootATL, bstrDeviceInstanceID);
	}
	return dwResult;
}

/* Status (after launch) ----------------------- */
/* TSLStatus
	After TSLGo (or after an event flag is returned by TSLGoAsynch) can return one status. 
	Repeated calls to this function allow any number of problems to be reported.  
	Should be called in a loop after TSLGo (or after an event flag is returned by TSLGoAsynch), 
	loop until it returns 0.

	Returns TSL_OK if all OK or if all problems are already reported.  nChar indicates size of 
	buffer szBuf in characters.  255 is recommended. if present, szBuf is used to return  
	a detailed error message.  The buffer will always return appropriate text. Typically, 
	it is just a text appropriate to the error/warning return.  In the case of 
	TSL_WARNING_NO_NODE or TSL_WARNING_NO_STATE, this text identifies what node has the 
	problem.  However, that is relevant only if there has been a call to TSLSetNodes.
*/
DWORD WINAPI TSLStatusA (HANDLE hTSL, DWORD nChar, char * szBuf)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = TSL_OK;
		hRes = pITShootATL->GetStatus(&dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		SetStatusA(dwResult, nChar, szBuf);
	}
	return dwResult;
}

DWORD WINAPI TSLStatusW (HANDLE hTSL, DWORD nChar, wchar_t * szBuf)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = TSL_OK;
		hRes = pITShootATL->GetStatus(&dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		SetStatusW(dwResult, nChar, szBuf);
	}
	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\tsmfc.h ===
// 
// MODULE: tsmfc.cpp
//
// PURPOSE: Imitate the MFC string resource functions that are not available 
//			in Win32 programs.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

int AfxLoadStringA(UINT nID, LPSTR lpszBuf, UINT nMaxBuf);
int AfxLoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf);

HINSTANCE AfxGetResourceHandle();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\tslerror.h ===
// 
// MODULE: tslerror.h
//
// PURPOSE: Warning and error codes for the TSLauncher.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHORS: Joe Mabel and Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#define TSL_OK 0
#define TSL_ERROR_BAD_HANDLE            1	// Handle hTSL passed into function is bad.
#define TSL_ERROR_OUT_OF_MEMORY         2	// Out-of-memory detected
#define TSL_ERROR_OBJECT_GONE			3	// The LaunchServ returned a negative HRESULT.
#define TSL_ERROR_GENERAL               4	// Can't launch a troubleshooter.  There are 
											//	error statuses to be accessed by TSLStatus.
#define TSL_ERROR_NO_NETWORK            5	// Can't identify an appropriate troubleshooting 
											//	network.
#define TSL_ERROR_ILLFORMED_MACHINE_ID  6	// Machine ID is not correctly formed.  Sniffing 
											//	disabled.
#define TSL_ERROR_BAD_MACHINE_ID        7	// A machine ID was specified but can't be used.  
											//	Sniffing disabled.
#define TSL_ERROR_ILLFORMED_DEVINST_ID  8	// Device Instance ID is not correctly formed.
											//	Sniffing disabled.
#define TSL_ERROR_BAD_DEVINST_ID        9	// Device Instance ID was specified but can't be 
											//	used.  Sniffing disabled.
#define TSL_ERROR_UNKNOWN_APP		   10	// An unrecognized application was specified.
#define TSL_ERROR_UNKNOWN_VER		   11	// Unrecognized version (no such version 
											//	associated with application)
#define TSL_ERROR_ASSERTION	           13   // An assertion failed

// The next several errors could be thought of as "hard failures of mapping", but we do not 
//	treat them as hard errors because even if mapping fails totally, we may still be able to
//	launch to a generic troubleshooter.
#define TSL_ERROR_MAP_BAD_SEEK			101	 // failure while seeking in the mapping file.
// Although, at a low level, a bad seek just indicates seeking to an inappropriate file 
//	offset, in practice a bad seek would indicate a serious problem either in the mapping file 
//	or in the code: we should only be seeking to offsets which the contents of the mapping file
//	told us to seek to.
#define TSL_ERROR_MAP_BAD_READ			102	 // failure while reading from the mapping file.
// Although, at a low level, a bad read just indicates (for example) reading past EOF, in 
//	practice a bad read would indicate a serious problem either in the mapping file or in 
//	the code: we should only be reading (1) the header or (2) records which the contents of 
//	the mapping file told us to read.
#define TSL_ERROR_MAP_CANT_OPEN_MAP_FILE 103
#define TSL_ERROR_MAP_BAD_HEAD_MAP_FILE	 104	// failed to read even the header of the map file

// The next several errors should never be seen by applications.  They would mean that the
//	launch server is mis-using the mapping code.
#define TSM_STAT_NEED_VER_TO_SET_DEF_VER 111	// Trying to apply a version default, but you
												//	haven't yet successfully set a version
												//	as a basis to look up the default
#define TSM_STAT_NEED_APP_TO_SET_VER	112		// tried to look up version without previously
												// setting application
#define TSM_STAT_UID_NOT_FOUND			113		// a string could not be mapped to a UID.
												// In the existing TSMapClient class, 
												// this means that the name could not be found
												// in the region of the mapping file where 
												// it belongs (e.g. that a version string is
												// not in the list of versions for the
												// current application.)
												// This should always be turned into something
												// more specific before it is passed to
												// higher-level code.

#define TSL_MIN_WARNING 1000
#define TSL_WARNING_NO_PROBLEM_NODE  1004	// Can't identify an appropriate problem node.  
											//	Troubleshooting will proceed from "first page" 
											//	for this troubleshooting network.
#define TSL_WARNING_NO_NODE          1005	// A state value was specified for a nonexistent 
											//	node 
#define TSL_WARNING_NO_STATE         1006	// A non-existent state value was specified for an 
											//	otherwise valid node.
#define TSL_WARNING_LANGUAGE         1007	// Can't apply specified language to this 
											//	particular problem (no language-appropriate 
											//	troubleshooting network).  Successively default 
											//	to standard language of this machine and to 
											//	English.
#define TSL_WARNING_NO_ONLINE        1008	// Can't obey stated preference for Online 
											//	Troubleshooter
#define TSL_WARNING_ONLINE_ONLY      1009	// Can't obey stated preference against Online 
											//	Troubleshooter
#define TSL_WARNING_GENERAL          1010	// Can launch a troubleshooter, but there are 
											//	warnings to be accessed by TSLStatus.

#define TSL_WARNING_ILLFORMED_DEV_ID 1011	// Device ID is not correctly formed.
#define TSL_WARNING_BAD_DEV_ID       1012	// A correctly formed but invalid device ID
#define TSL_WARNING_ILLFORMED_CLASS_GUID 1013	// Device Class GUID is not correctly formed.
#define TSL_WARNING_BAD_CLASS_GUID       1014	// A correctly formed but invalid device Class GUID
#define TSL_WARNING_UNKNOWN_APPPROBLEM	 1015	// App problem passed in, but this problem 
											//	name is nowhere in the mapping file.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem
#define TSL_WARNING_UNUSED_APPPROBLEM	 1016	// App problem passed in, and the name is
											//	recognized but can't be used in conjunction
											//	with the device information given.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem

#define TSL_W_CONTAINER_WAIT_TIMED_OUT	1017	// The container did not respond within the time 
												//	out value specified in the go method.
#define TSL_WARNING_END_OF_VER_CHAIN	1018	// Should never be seen by the calling app.
											// Indicates that we are at the end of the chain
											// in applying default versions.

#define TSL_MAX_WARNING 1999

// the range 2000-2099 is reserved for internal use by the mapping code.
// statuses in this range should not ever be exposed outside of class TSMapRuntimeAbstract 
// and its subclasses.
#define TSL_MIN_RESERVED_FOR_MAPPING 2000
#define TSL_MAX_RESERVED_FOR_MAPPING 2099

// Errors generated by LaunchServ.  Need to start @ 4,000 to avoid confusion with
// codes returned by the local troubleshooter.
#define TSL_E_CONTAINER_REG		4000	// Could not find the path to hh.exe / iexplore.exe in the registry.
#define TSL_E_CONTAINER_NF		4001	// Found the path to the browser, but it is not at that location.
#define TSL_E_WEB_PAGE_REG		4002	// Could not find the path to the web page in the registry.
#define TSL_E_WEB_PAGE_NF		4003	// Found the path to the web page, but it is not at that location.
#define TSL_E_CREATE_PROC		4004	// Could not create the hh.exe / iexplore.exe process.
#define TSL_E_MEM_EXCESSIVE		4005	// An unexpected amount of memory is required.  i.e. a path name that is longer than MAX_PATH.
#define TSL_E_MAPPING_DB_REG	4006	// Could not find the path to the binary mapping file in the registry.
#define TSL_E_MAPPING_DB_NF		4007	// Found the path to the mapping file, but it is not at that location.
#define TSL_E_NETWORK_REG		4008	// Could not find the path to the network resources (DSZ files).
#define TSL_E_NETWORK_NF		4009	// Could not find a DSC or DSZ file with the network name.
#define TSL_E_NODE_EMP			4010	// A call to set node had a null node name or node state.
#define TSL_E_NO_DEFAULT_NET	4011	// The mapping class failed to get a network and there is not a default network defined in the registry.
#define TSL_E_SNIFF_SCRIPT_REG	4012	// Could not find the path to the sniff script in the registry.
#define TSL_E_COPY_SNIFF_SCRIPT	4013	// Could not create the hh.exe / iexplore.exe process.


inline bool TSLIsHardError(DWORD dwStatus)
{
	return (dwStatus == TSL_ERROR_BAD_HANDLE 
		|| dwStatus == TSL_ERROR_OUT_OF_MEMORY 
		|| dwStatus == TSL_ERROR_OBJECT_GONE);
}

inline bool TSLIsError(DWORD dwStatus) 
{
	return (TSL_OK != dwStatus && dwStatus < TSL_MIN_WARNING || dwStatus > TSL_MAX_WARNING);
}

inline bool TSLIsWarning(DWORD dwStatus) 
{
	return (dwStatus >= TSL_MIN_WARNING && dwStatus <= TSL_MAX_WARNING);
}

#define TSL_E_FAIL		-1
#define TSL_SERV_FAILED(hRes) (FAILED(hRes) && TSL_E_FAIL != hRes)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\client\tsmfc.cpp ===
// 
// MODULE: tsmfc.cpp
//
// PURPOSE: Imitate the MFC string resource functions that are not available 
//			in Win32 programs.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include "tsmfc.h"

int AfxLoadStringA(UINT nID, LPSTR lpszBuf, UINT nMaxBuf)
{
	LPCSTR lpszName = MAKEINTRESOURCEA((nID>>4)+1);
	HINSTANCE hInst;
	int nLen = 0;
	// Unlike MFC, this function call is guarenteed to work.
	// AfxGetResourceHandle gets the handle that was passed
	// to DllMain().
	hInst = AfxGetResourceHandle();
	if (::FindResourceA(hInst, lpszName, (LPCSTR)RT_STRING) != NULL)
		nLen = ::LoadStringA(hInst, nID, lpszBuf, nMaxBuf);
	return nLen;
}

int AfxLoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
	LPCWSTR lpszName = MAKEINTRESOURCEW((nID>>4)+1);
	HINSTANCE hInst;
	int nLen = 0;
	// Unlike MFC, this function call is guarenteed to work.
	// AfxGetResourceHandle gets the handle that was passed
	// to DllMain().
	hInst = AfxGetResourceHandle();
	if (::FindResourceW(hInst, lpszName, (LPCWSTR)RT_STRING) != NULL)
		nLen = ::LoadStringW(hInst, nID, lpszBuf, nMaxBuf);
	return nLen;
}

HINSTANCE AfxGetResourceHandle()
{
	extern HINSTANCE g_hInst;
	return g_hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\inc\tslauncher.h ===
// 
// MODULE: TSLaunchDLL.cpp
//
// PURPOSE: The functions that are exported by TSLauncher.dll.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef _TSLAUNCH_
#define _TSLAUNCH_ 1
 
#ifdef __TSLAUNCHER
#define DLLEXPORT_IMPORT __declspec(dllexport)
#else
#define DLLEXPORT_IMPORT __declspec(dllimport)
#endif


DLLEXPORT_IMPORT BOOL APIENTRY DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

/* TSLOpen
	Returns a handle that should be passed into subsequent Troubleshooter Launcher calls 
	as hTSL.  Returns NULL handle on failure.  (Should only fail on out of memory, 
	probably will never arise.)
*/
DLLEXPORT_IMPORT HANDLE WINAPI TSLOpen(void);

/* TSLClose
	Closes handle.  Returns TSL_OK (== 0) if handle was open, otherwise TSL_ERROR_BAD_HANDLE.
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLClose (HANDLE hTSL);


/* TSLReInit
	Reinitializes handle.  Functionally the same as a TSLClose followed by TSLOpen, but more
	efficient.  Returns same handle as passed in, if handle was OK, otherwise NULL.
*/
DLLEXPORT_IMPORT HANDLE WINAPI TSLReInit (HANDLE hTSL);

/* TSLLaunchKnownTS
	Launches to a known troubleshooting belief network and (optionally) problem node. 
	If you know the particular troubleshooting network and problem, use this call.  
	If setting network but not problem, pass in a NULL for szProblemNode.

	Also allows setting arbitrary nodes.  
	nNode gives the number of nodes to set. pszNode, pVal are 
	arrays (dimension nNode) of symbolic node names and corresponding values. 

   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch failed, call TSLStatus
	TSL_WARNING_GENERAL			launch succeded, call TSLStatus for warnings
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchKnownTSA(HANDLE hTSL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, const char ** pszNode, DWORD* pVal); 
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchKnownTSW(HANDLE hTSL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, const wchar_t ** pszNode, DWORD* pVal); 
#ifdef UNICODE
	#define TSLLaunchKnownTS TSLLaunchKnownTSW
#else
	#define TSLLaunchKnownTS TSLLaunchKnownTSA
#endif

/* TSLLaunch
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeded, call TSLStatus for warnings
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szAppProblem, bool bLaunch); 
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szAppProblem, bool bLaunch); 
#ifdef UNICODE
	#define TSLLaunch TSLLaunchW
#else
	#define TSLLaunch TSLLaunchA
#endif

/* TSLLaunchDevice
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, Plug & Play Device ID, Device Class GUID, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeded, call TSLStatus for warnings
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchDeviceA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szPNPDeviceID, 
				const char * szDeviceClassGUID, const char * szAppProblem, bool bLaunch);
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchDeviceW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szPNPDeviceID, 
				const wchar_t * szDeviceClassGUID, const wchar_t * szAppProblem, bool bLaunch); 
#ifdef UNICODE
	#define TSLLaunchDevice TSLLaunchDeviceW
#else
	#define TSLLaunchDevice TSLLaunchDeviceA
#endif

				
/* Preferences ----------------------------------- */

/* TSLPreferOnline
	Specify a preference for or against online debugger.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLPreferOnline(HANDLE hTSL, BOOL bPreferOnline);

/* TSLLanguage 
	Specify language, using Unicode-style 3-letter language ID.  This overrides the system 
	default.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
   Cannot return TSL_WARNING_LANGUAGE, because we will not know this till we try combining
	language and troubleshooting network.
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLanguageA(HANDLE hTSL, const char * szLanguage);
DLLEXPORT_IMPORT DWORD WINAPI TSLLanguageW(HANDLE hTSL, const wchar_t * szLanguage);
#ifdef UNICODE
	#define TSLLanguage TSLLanguageW
#else
	#define TSLLanguage TSLLanguageA
#endif

/* Sniffing ---------------------------- */
/* TSLMachineID
	Necessary to support sniffing on a remote machine.  
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_MACHINE_ID
	TSL_ERROR_BAD_MACHINE_ID
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLMachineIDA(HANDLE hTSL, const char* szMachineID);
DLLEXPORT_IMPORT DWORD WINAPI TSLMachineIDW(HANDLE hTSL, const wchar_t* szMachineID);
#ifdef UNICODE
	#define TSLMachineID TSLMachineIDW
#else
	#define TSLMachineID TSLMachineIDA
#endif

/* TSLDeviceInstanceIDA
	Necessary to support sniffing.  For example, if there are two of the same card on a 
	machine, the Plug & Play ID is of limited use for sniffing.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_DEVINST_ID
	TSL_ERROR_BAD_DEVINST_ID
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLDeviceInstanceIDA(HANDLE hTSL, 
												   const char* szDeviceInstanceID);
DLLEXPORT_IMPORT DWORD WINAPI TSLDeviceInstanceIDW(HANDLE hTSL, 
												   const wchar_t* szDeviceInstanceID);
#ifdef UNICODE
	#define TSLDeviceInstanceID TSLDeviceInstanceIDW
#else
	#define TSLDeviceInstanceID TSLDeviceInstanceIDA
#endif

/* Status (after launch) ----------------------- */
/* TSLStatus
	After any of the TSLLaunch... functions return TSL_ERROR_GENERAL or TSL_WARNING_GENERAL,
	this function can return one status. 
	Repeated calls to this function allow any number of problems to be reported.  
	Should be called in a loop until it returns 0.

	Returns TSL_OK if all OK or if all problems are already reported.  nChar indicates size of 
	buffer szBuf in characters.  255 is recommended. If present, szBuf is used to return  
	a detailed error message.  The buffer will always return appropriate text. Typically, 
	it is just a text appropriate to the error/warning return.  In the case of 
	TSL_WARNING_NO_NODE or TSL_WARNING_NO_STATE, this text identifies what node has the 
	problem.  However, that is relevant only if there has been a call to TSLSetNodes.
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLStatusA (HANDLE hTSL, DWORD nChar, char * szBuf);
DLLEXPORT_IMPORT DWORD WINAPI TSLStatusW (HANDLE hTSL, DWORD nChar, wchar_t * szBuf);

#ifdef UNICODE
	#define TSLStatus TSLStatusW
#else
	#define TSLStatus TSLStatusA
#endif

#endif _TSLAUNCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\comglobals.cpp ===
// 
// MODULE: ComGlobals.cpp
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "ComGlobals.h"

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize)
{
	int x = 0;
	while(x < CharBufSize)
	{
		szChar[x] = (TCHAR) bstr[x];
		if (NULL == szChar[x])
			break;
		x++;
	}
	return x < CharBufSize;
}

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize)
{
	HKEY hKey;
	DWORD dwType = REG_SZ;
	DWORD dwBufSize = *pdwBufSize;
	LPTSTR szUnExpanded = new TCHAR[dwBufSize];
	if (NULL == szUnExpanded)
		return false;
	__try
	{
		if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, szKey, NULL, KEY_READ, &hKey))
			return false;
		if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, NULL, &dwType, 
				(PBYTE) szUnExpanded, pdwBufSize))
		{
			RegCloseKey(hKey);
			return false;
		}			
		RegCloseKey(hKey);
		if (REG_EXPAND_SZ == dwType || dwType == REG_SZ)	// NT 5.0 beta bug requires all strings to be expanded.
		{
			DWORD dwBytesUsed;
			dwBytesUsed = ExpandEnvironmentStrings(szUnExpanded, szBuffer, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 == dwBytesUsed)
				return false;
			*pdwBufSize = dwBytesUsed;
			if (dwBytesUsed > dwBufSize)
				return false;
		}
		else
		{
			_tcsncpy(szBuffer, szUnExpanded, dwBufSize);
		}
	}
	__finally
	{
		if (NULL != szUnExpanded)
			delete [] szUnExpanded;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\launchts.h ===
// 
// MODULE: LaunchTS.h
//
// PURPOSE: The interface that TSHOOT.OCX uses to get network and node information
//			from the LaunchServ.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef __LAUNCHTS_H_
#define __LAUNCHTS_H_

#include "resource.h"       // main symbols

#include "stdio.h"

/////////////////////////////////////////////////////////////////////////////
// CLaunchTS

class ATL_NO_VTABLE CLaunchTS : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLaunchTS, &CLSID_LaunchTS>,
	public IObjectWithSiteImpl<CLaunchTS>,
	public IDispatchImpl<ILaunchTS, &IID_ILaunchTS, &LIBID_LAUNCHSERVLib>
{
public:
	CLaunchTS()
	{
		_stprintf(m_szEvent, _T("Event "));
		m_csThreadSafeBr.Init();
	}
	~CLaunchTS()
	{
		m_csThreadSafeBr.Term();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_LAUNCHTS)

BEGIN_COM_MAP(CLaunchTS)
	COM_INTERFACE_ENTRY(ILaunchTS)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

	TCHAR m_szEvent[50];
	CItem m_refedLaunchState;		// Used only by the process that is created by the Go method.
	CComCriticalSection m_csThreadSafeBr;
// ILaunchTS
public:
	STDMETHOD(Test)();
	STDMETHOD(GetState)(/*[in]*/ short iNode, /*[out, retval]*/ BSTR *pbstrState);
	STDMETHOD(GetNode)(/*[in]*/ short iNode, /*[out, retval]*/ BSTR *pbstrNode);
	STDMETHOD(GetProblem)(/*[out, retval]*/ BSTR *pbstrProblem);
	STDMETHOD(GetTroubleShooter)(/*[out, retval]*/ BSTR *pbstrShooter);
	STDMETHOD(GetShooterStates)(/*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(GetMachine)(/*[out, retval]*/ BSTR *pbstrMachine);
	STDMETHOD(GetPNPDevice)(/*[out, retval]*/ BSTR *pbstr);
	STDMETHOD(GetGuidClass)(/*[out, retval]*/ BSTR *pbstr);
	STDMETHOD(GetDeviceInstance)(/*[out, retval]*/ BSTR *pbstr);
};

#endif //__LAUNCHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\launchts.cpp ===
// 
// MODULE: LaunchTS.cpp
//
// PURPOSE: The interface that TSHOOT.OCX uses to get network and node information
//			from the LaunchServ.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "LaunchServ.h"
#include "StateInfo.h"
#include "LaunchTS.h"

#include "ComGlobals.h"

extern CSMStateInfo g_StateInfo;

/////////////////////////////////////////////////////////////////////////////
// CLaunchTS - Created as a plain apartment model interface.

// This fills in m_refedLaunchState from TSLaunchServ's global memory.
//	The resulting values tell us what troubleshooting network to use and can 
//	indicate a problem node and even indicate states to set for other nodes.
STDMETHODIMP CLaunchTS::GetShooterStates(DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafeBr.Lock();
	hRes = g_StateInfo.GetShooterStates(m_refedLaunchState, pdwResult);
	m_csThreadSafeBr.Unlock();
	return hRes;
}

// OUTPUT pbstrShooter is the name of the Troubleshooting network to launch to
//	Note that this string is allocated by this function
// Returns true if there is a Troubleshooting network to launch to
// Must be called after CLaunchTS::GetShooterStates, since it assumes
//	m_refedLaunchState contains good values
STDMETHODIMP CLaunchTS::GetTroubleShooter(BSTR * pbstrShooter)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetNetwork(&pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrShooter = SysAllocString((BSTR) CComBSTR(pszVal));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// OUTPUT pbstrProblem is the symbolic name of the selected problem node
//	Note that this string is allocated by this function
// Returns true if there is a selected problem node
// Must be called after CLaunchTS::GetShooterStates, since it assumes
//	m_refedLaunchState contains good values
STDMETHODIMP CLaunchTS::GetProblem(BSTR * pbstrProblem)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetProblem(&pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrProblem = SysAllocString((BSTR) CComBSTR(pszVal));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetMachine(BSTR * pbstrMachine)
{
	m_csThreadSafeBr.Lock();
	*pbstrMachine = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szMachineID));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetPNPDevice(BSTR *pbstrPNPDevice)
{
	m_csThreadSafeBr.Lock();
	*pbstrPNPDevice = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szPNPDeviceID));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetGuidClass(BSTR *pbstrGuidClass)
{
	m_csThreadSafeBr.Lock();
	*pbstrGuidClass = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szGuidClass));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetDeviceInstance(BSTR *pbstrDeviceInstance)
{
	m_csThreadSafeBr.Lock();
	*pbstrDeviceInstance = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szDeviceInstanceID));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// INPUT iNode - index of (non-problem) node.  Typically, this function should be called
//	in a loop where we first see if there is a pbstrNode value for iNode == 0 and then
//	increment iNode until we reach a value for which pbstrNode is undefined.
// OUTPUT pbstrNode is the symbolic name of a (non-problem) node whose state we want to set
//	Note that this string is allocated by this function
// Returns true if there is a selected problem node
// Must be called after CLaunchTS::GetShooterStates, since it assumes
//	m_refedLaunchState contains good values
STDMETHODIMP CLaunchTS::GetNode(short iNode, BSTR * pbstrNode)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetNodeState(iNode, &pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrNode = SysAllocString((BSTR) CComBSTR(pszCmd));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// see comments on CLaunchTS::GetNode; this returns the node state rather than
//	the symbolic node name
STDMETHODIMP CLaunchTS::GetState(short iNode, BSTR * pbstrState)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetNodeState(iNode, &pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrState = SysAllocString((BSTR) CComBSTR(pszVal));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// Test:  Used to get network and node information from the server without
// launching the browser.  Use the TShootATL::Test method before ILaunchTS::Test.
STDMETHODIMP CLaunchTS::Test()
{
	extern CSMStateInfo g_StateInfo;
	m_csThreadSafeBr.Lock();
	g_StateInfo.TestGet(m_refedLaunchState);
	m_csThreadSafeBr.Unlock();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\comglobals.h ===
// 
// MODULE: ComGlobals.h
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef __COMGLOBALS_H_
#define __COMGLOBALS_H_ 1

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize);

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\registry.h ===
// 
// MODULE: Registry.h
//
// PURPOSE: All of the registry keys and values for the LaunchServ are 
//			defined here.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

// Registry Keys
#define SZ_LAUNCHER_ROOT		_T("SOFTWARE\\Microsoft\\TShoot\\Launcher")
#define SZ_LAUNCHER_APP_ROOT	_T("SOFTWARE\\Microsoft\\TShoot\\Launcher\\Applications")
#define SZ_TSHOOT_ROOT			_T("SOFTWARE\\Microsoft\\TShoot")
// Registry Values
#define SZ_GLOBAL_MAP_FILE		_T("MapFile")
#define SZ_GLOBAL_LAUNCHER_RES	_T("ResourcePath")	// The applications also use SZ_GLOBAL_LAUNCHER_RES for their map files.
#define SZ_APPS_MAP_FILE		_T("MapFile")
#define SZ_TSHOOT_RES			_T("FullPathToResource")
#define SZ_DEFAULT_NETWORK		_T("DefaultNetwork")	// The dsc network that will be used if the mapping fails.
#define SZ_DEFAULT_PAGE		    _T("DefaultPage")	// The default web page


// Define _HH_CHM for normal NT 5 release builds.
// Undefine _HH_CHM to use with iexplore.exe on NT 4.
#define _HH_CHM 1		// Don't need the full path to hh.exe, but iexplore.exe will not run without the full path.
// The container that will use the ILaunchTS interface.
#ifndef _HH_CHM
#define SZ_CONTAINER_APP_KEY	_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
#define SZ_CONTAINER_APP_VALUE _T("")
#endif

// These are NOT in registry
// These are sniff related names
#define SZ_SNIFF_SCRIPT_NAME		_T("tssniffAsk.htm")
#define SZ_SNIFF_SCRIPT_APPENDIX    _T("_sniff.htm")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LaunchServ.rc
//
#define IDS_SERVICENAME                 100
#define IDR_LaunchServ                  100
#define IDR_LAUNCHTS                    101
#define IDR_T3                          102
#define IDR_TSHOOTLAUNCH                103
#define IDR_TSHOOT                      104
#define IDR_TSHOOTATL                   105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\launch.cpp ===
// 
// MODULE: Launch.cpp
//
// PURPOSE: Starts the container that will query the LaunchServ for 
//			troubleshooter network and nodes.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "StateInfo.h"

#include "RSSTACK.H"

#include "TSMapAbstract.h"
#include "TSMap.h"
#include "TSMapClient.h"

#include "Launch.h"
#include "ComGlobals.h"
#include "TSLError.h"
#include "Registry.h"

#include <rpc.h> 

#define LAUNCH_WAIT_TIMEOUT 60 * 1000   // One minute wait.

#define SZ_WEB_PAGE _T("asklibrary.htm") // name of hardcoded .htm file that contains troubleshooter OCX


// uncomment the following line to turn on Joe's hard-core debugging
//#define JDEBUG 1

#ifdef JDEBUG
#include <stdio.h>
// Convert TCHAR *szt to char *sz.  *sz should point to a big enough buffer
//	to contain an SNCS version of *szt.  count indicates the size of buffer *sz.
// returns sz (convenient for use in string functions).
static char* ToSBCS (char * const sz, const TCHAR * szt, size_t count)
{
	if (sz)
	{
		if (count != 0 && !szt)
			sz[0] = '\0';
		else
		{
			#ifdef  _UNICODE
				wcstombs( sz, szt, count );
			#else
				strcpy(sz, szt);
			#endif
		}
	}
	return sz;
}
#endif


CLaunch::CLaunch()
{
	InitFiles();
	InitRequest();
	m_lLaunchWaitTimeOut = LAUNCH_WAIT_TIMEOUT;
	m_bPreferOnline = false;
}

CLaunch::~CLaunch()
{
	if (m_pMap)
		delete(m_pMap);
}

// This initialization happens exactly once for the object.
// Once we've looked in the registry and found a file, it isn't going anywhere.
void CLaunch::InitFiles()
{
	DWORD dwBufSize;
	CRegKey reg;
	DWORD dwBytesUsed;

	m_bHaveMapPath = false;
	m_bHaveDefMapFile = false;
	m_bHaveDszPath = false;
	m_szLauncherResources[0] = NULL;
	m_szDefMapFile[0] = NULL;
	m_szLaunchMapFile[0] = NULL;
	m_szDszResPath[0] = NULL;
	m_szMapFile[0] = NULL;
	m_pMap = NULL;

	if (ERROR_SUCCESS == reg.Open(
				HKEY_LOCAL_MACHINE, SZ_LAUNCHER_ROOT))
	{
		dwBufSize = MAX_PATH;
		TCHAR szLauncherResources[MAX_PATH];
		if (ERROR_SUCCESS == reg.QueryValue(
			szLauncherResources, SZ_GLOBAL_LAUNCHER_RES, &dwBufSize))
		{
			if ('\\' != szLauncherResources[_tcslen(szLauncherResources) - 1])
				_tcscat(szLauncherResources, _T("\\"));

			dwBufSize = MAX_PATH;
			dwBytesUsed = ExpandEnvironmentStrings(szLauncherResources, m_szLauncherResources, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.

		}
		dwBufSize = MAX_PATH;
		TCHAR szDefMapFile[MAX_PATH];
		if (ERROR_SUCCESS == reg.QueryValue(
					szDefMapFile, SZ_GLOBAL_MAP_FILE, &dwBufSize))
		{
			WIN32_FIND_DATA data;
			HANDLE hFind;

			dwBufSize = MAX_PATH;
			dwBytesUsed = ExpandEnvironmentStrings(szDefMapFile, m_szDefMapFile, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 != dwBytesUsed)
			{
				m_bHaveMapPath = true;
				_tcscpy(m_szLaunchMapFile, m_szLauncherResources);
				_tcscat(m_szLaunchMapFile, m_szDefMapFile);
				hFind = FindFirstFile(m_szLaunchMapFile, &data);
				if (INVALID_HANDLE_VALUE != hFind)
				{
					m_bHaveDefMapFile = true;
					FindClose(hFind);
				}
				else
				{
					m_bHaveDefMapFile = false;
				}
			}
		}
		reg.Close();
	}
	// Need the TShoot.ocx resource path to verify that the networks exist.
	if (ERROR_SUCCESS == reg.Open(HKEY_LOCAL_MACHINE, SZ_TSHOOT_ROOT))
	{
		dwBufSize = MAX_PATH;
		TCHAR szDszResPath[MAX_PATH];
		if (ERROR_SUCCESS == reg.QueryValue(szDszResPath, SZ_TSHOOT_RES, &dwBufSize))
		{
			if ('\\' != szDszResPath[_tcslen(szDszResPath) - 1])
				_tcscat(szDszResPath, _T("\\"));
			
			dwBufSize = MAX_PATH;
			dwBytesUsed = ExpandEnvironmentStrings(szDszResPath, m_szDszResPath, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 == dwBytesUsed)
				m_bHaveDszPath = false;
			else
				m_bHaveDszPath = true;
		}
		reg.Close();
	}

	return;
}

// This initialization can happen more than once for the object.
// If we are going to use the same object to make a second request, there are things we
//	want to clean up.
void CLaunch::InitRequest()
{
	m_szAppName[0] = NULL;
	m_szAppVersion[0] = NULL;
	m_szAppProblem[0] = NULL;
	m_stkStatus.RemoveAll();
	m_Item.ReInit();
}

// >>> Why does this exist distinct from InitRequest()?
void CLaunch::ReInit()
{
	InitRequest();	
	return;
}

// >>> What exactly is the use of this? What is the distinction from InitRequest()?
void CLaunch::Clear()
{
	m_szAppName[0] = NULL;
	m_szAppVersion[0] = NULL;
	m_szAppProblem[0] = NULL;
	m_stkStatus.RemoveAll();
	m_Item.Clear();
	return;
}

// Verify that a given troubleshooting belief network exists.
bool CLaunch::VerifyNetworkExists(LPCTSTR szNetwork)
{
	bool bResult = true;
	if (NULL == szNetwork || NULL == szNetwork[0])
	{
		// Null name, don't even bother with a lookup.		
		m_stkStatus.Push(TSL_E_NETWORK_NF);
		bResult = false;
	}
	else
	{
		if (m_bHaveDszPath)
		{
			WIN32_FIND_DATA data;
			HANDLE hFind;
			TCHAR szDszFile[MAX_PATH];

			_tcscpy(szDszFile, m_szDszResPath);
			_tcscat(szDszFile, szNetwork);
			_tcscat(szDszFile, _T(".ds?"));
			
			hFind = FindFirstFile(szDszFile, &data);
			if (INVALID_HANDLE_VALUE == hFind)
			{
				m_stkStatus.Push(TSL_E_NETWORK_NF);
				bResult = false;
			}
			FindClose(hFind);
		}
		else
		{
			// we don't know what directory to look in.
			m_stkStatus.Push(TSL_E_NETWORK_REG);
			bResult = false;
		}
	}
	return bResult;
}

// Allows explicit specification of the troubleshooting network (and, optionally, 
//	problem node) to launch to.
// This is an alternative to determining network/node via a mapping.
// INPUT szNetwork
// INPUT szProblem: null pointer of null string ==> no problem node
//					any other value is symbolic name of problem node
bool CLaunch::SpecifyProblem(LPCTSTR szNetwork, LPCTSTR szProblem)
{
	bool bResult = true;
	if (!VerifyNetworkExists(szNetwork))	// Sets the network not found error.
	{
		bResult = false;
	}
	else
	{
		m_Item.SetNetwork(szNetwork);

		// Set problem node, if any.  OK if there is none.
		if (NULL != szProblem && NULL != szProblem[0])
			m_Item.SetProblem(szProblem);
	}
	return bResult;
}

// Allows explicit setting of a non-problem node.
// Obviously, node names only acquire meaning in the context of a belief network.
// INPUT szNode: symbolic node name
// INPUT szState: >>> not sure what is intended.  The corresponding value in TSLaunch API is
//	an integer state value.  Is this the decimal representation of that value or what? JM

bool CLaunch::SetNode(LPCTSTR szNode, LPCTSTR szState)
{
	bool bResult = true;
	if (NULL != szNode && NULL != szState)
	{
		m_Item.SetNode(szNode, szState);
	}
	else
	{
		m_stkStatus.Push(TSL_E_NODE_EMP);		
		bResult = false;
	}
	return bResult;
}

// Sets machine ID so that WBEM can sniff on a remote machine.
HRESULT CLaunch::MachineID(BSTR &bstrMachineID, DWORD *pdwResult)
{
	HRESULT hRes = S_OK;
	if (!BSTRToTCHAR(m_Item.m_szMachineID, bstrMachineID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		hRes = TSL_E_FAIL;
	}
	return hRes;
}

// Sets Device Instance ID so that WBEM can sniff correct device
HRESULT CLaunch::DeviceInstanceID(BSTR &bstrDeviceInstanceID, DWORD *pdwResult)
{
	HRESULT hRes = S_OK;
	if (!BSTRToTCHAR(m_Item.m_szDeviceInstanceID, bstrDeviceInstanceID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		hRes = TSL_E_FAIL;
	}
	return hRes;
}

void CLaunch::SetPreferOnline(short bPreferOnline)
{
	// The next line's ugly, but correct.  bPreferOnline is not necessarily a valid
	//	Boolean; we want to make sure we get a valid Boolean in	m_bPreferOnline.
	m_bPreferOnline = (0 != bPreferOnline);
	return;
}

// CheckMapFile:  Uses szAppName member to set szMapFile.  
// First, check the registry for an application-specific map file.  If we can't find one,
//	check for a default map file.  If that doesn't exist either, fail.
// INPUT szAppName
// OUTPUT szMapFile
bool CLaunch::CheckMapFile(TCHAR * szAppName, TCHAR szMapFile[MAX_PATH], DWORD *pdwResult)
{
	bool bHaveMapFile = false;

	if (NULL == szAppName || NULL == szAppName[0])
	{
		// Application name may not be null.
		m_stkStatus.Push(TSL_ERROR_UNKNOWN_APP);
		*pdwResult = TSL_ERROR_GENERAL;
		return false;
	}
	else
	{
		DWORD dwBufSize;
		CRegKey reg;
		if (ERROR_SUCCESS == reg.Open(HKEY_LOCAL_MACHINE, SZ_LAUNCHER_APP_ROOT))
		{
			dwBufSize = MAX_PATH;
			if (ERROR_SUCCESS == reg.Open(reg.m_hKey, szAppName))
			{
				if (ERROR_SUCCESS == reg.QueryValue(szMapFile, SZ_APPS_MAP_FILE, &dwBufSize))
					return true;
			}
		}
	}

	// Does a default map file exist?
	if (m_bHaveDefMapFile)
	{
		_tcscpy(szMapFile, m_szLaunchMapFile);
	}
	else
	{	// Either the registry setting is missing or the file is not 
		// where the registry says it is.
		if (m_bHaveMapPath)	// Have the registry entry.
			m_stkStatus.Push(TSL_E_MAPPING_DB_NF);
		else
			m_stkStatus.Push(TSL_E_MAPPING_DB_REG);
		*pdwResult = TSL_ERROR_GENERAL;
	}
	return m_bHaveDefMapFile;
}

// Uses the mapping classes to map Caller() and DeviceID() information, then copies the 
//	CItem to global memory.
// >> Why is this called TestPut()?
// Returns false when the mapping fails.
bool CLaunch::TestPut()
{
	extern CSMStateInfo g_StateInfo;
	DWORD dwResult;
	Map(&dwResult);
	if (TSL_OK != dwResult)
		return false;
	g_StateInfo.TestPut(m_Item);	// Copies m_Item to global memory.
	return true;
}

// Perform any necessary mapping, then launch the Local Troubleshooter.
bool CLaunch::Go(DWORD dwTimeOut, DWORD *pdwResult)
{
	DWORD dwRes;
	bool bResult = true;
	extern CSMStateInfo g_StateInfo;
	TCHAR szContainerPathName[MAX_PATH];  szContainerPathName[0] = 0;
	TCHAR szSniffScriptFile[MAX_PATH];    szSniffScriptFile[0] = 0;
	TCHAR szSniffStandardFile[MAX_PATH];  szSniffStandardFile[0] = 0;
	TCHAR szWebPage[MAX_PATH];            szWebPage[0] = 0;
	TCHAR szDefaultNetwork[SYM_LEN];      szDefaultNetwork[0] = 0;
	TCHAR *szCmd = NULL, *szNetwork = NULL;

	if (TSL_OK == (dwRes = GetContainerPathName(szContainerPathName)))
	{
		m_Item.SetContainerPathName(szContainerPathName);
		m_Item.SetSniffScriptFile(szSniffScriptFile);
	}
	else 
	{
		m_stkStatus.Push(dwRes);
		// if container is not found - no reason to continue
		*pdwResult = TSL_ERROR_GENERAL;
		return false;
	}

	if (!m_Item.NetworkSet())	
	{
		if (Map(&dwRes) &&
			TSL_OK == (dwRes = GetWebPage(szWebPage)) // get web page
		   )
		{
			m_Item.SetWebPage(szWebPage);
			// network and problem are set by Map function
			m_Item.SetLaunchRegime(launchMap);
		}
		else
		{
			m_stkStatus.Push(dwRes);
			if (TSL_OK == (dwRes = GetDefaultURL(szWebPage))) // get "DEFAULT PAGE",
												// actually a URL which might (for example)
												// refernce a page compiled into a .CHM file
			{
				m_Item.SetWebPage(szWebPage);
				m_Item.SetNetwork(NULL); // network are set to NULL in this case
				m_Item.SetProblem(NULL); // problem are set to NULL in this case
				m_Item.SetLaunchRegime(launchDefaultWebPage);
			}
			else
			{	
				if (TSL_OK == (dwRes = GetDefaultNetwork(szDefaultNetwork)) && // get default network 
					TSL_OK == (dwRes = GetWebPage(szWebPage)) // get web page
				   )  
				{
					m_Item.SetWebPage(szWebPage);
					m_Item.SetNetwork(szDefaultNetwork);
					m_Item.SetProblem(NULL); // problem is set to NULL in this case
					m_Item.SetLaunchRegime(launchDefaultNetwork);
				}
				else
				{
					// complete failure
					m_stkStatus.Push(dwRes);
					*pdwResult = TSL_ERROR_GENERAL;
					m_Item.SetLaunchRegime(launchIndefinite);
					return false; 
				}
			}
		}
	}							  
	else
	{
		if (TSL_OK == (dwRes = GetWebPage(szWebPage)))
		{
			m_Item.SetWebPage(szWebPage);
			// network is known, problem can be either known(set) or unknown(not set)
			m_Item.SetLaunchRegime(launchKnownNetwork);
		}
		else
		{
			// complete failure
			m_stkStatus.Push(dwRes);
			*pdwResult = TSL_ERROR_GENERAL;
			m_Item.SetLaunchRegime(launchIndefinite);
			return false; 
		}
	}
								  
	// set sniff script and standard file
	m_Item.GetNetwork(&szCmd, &szNetwork);
	if (TSL_OK == (dwRes = GetSniffScriptFile(szSniffScriptFile, szNetwork[0] ? szNetwork : NULL)) &&
		TSL_OK == (dwRes = GetSniffStandardFile(szSniffStandardFile))
	   )
	{
		m_Item.SetSniffScriptFile(szSniffScriptFile);
		m_Item.SetSniffStandardFile(szSniffStandardFile);
	}
	else
	{
		// can not find script file path - failure
		m_stkStatus.Push(dwRes);
		*pdwResult = TSL_ERROR_GENERAL;
		m_Item.SetLaunchRegime(launchIndefinite);
		return false; 
	}
    
	// parse warnings according to the launch regime
	//
	if (launchMap == m_Item.GetLaunchRegime() ||
		launchKnownNetwork == m_Item.GetLaunchRegime()
	   )
	{
		if (!m_Item.ProblemSet())
		{
				m_stkStatus.Push(TSL_WARNING_NO_PROBLEM_NODE);
				*pdwResult = TSL_WARNING_GENERAL;
		}
	}

	// parse launches according to the launch regime
	//
	if (launchMap == m_Item.GetLaunchRegime() ||
		launchDefaultNetwork == m_Item.GetLaunchRegime()
	   )
	{
		if (m_Item.NetworkSet())
		{

#ifdef JDEBUG
			HANDLE hDebugFile;
			char* szStart = "START\n";
			char* szEnd = "END\n";
			DWORD dwBytesWritten;

			hDebugFile = CreateFile(
				_T("jdebug.txt"),  
				GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
			WriteFile( 
				hDebugFile, 
				szStart, 
				strlen(szStart),
				&dwBytesWritten,
				NULL);
				
			TCHAR *sztCmd, *sztVal;
			char sz[200], szCmd[100], szVal[100];

			m_Item.GetNetwork(&sztCmd, &sztVal);

			ToSBCS (szCmd, sztCmd, 100);
			ToSBCS (szVal, sztVal, 100);

			sprintf(sz, "%s %s\n", szCmd, szVal);

			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
				
			if (m_Item.ProblemSet())
			{
				m_Item.GetProblem(&sztCmd, &sztVal);

				ToSBCS (szCmd, sztCmd, 100);
				ToSBCS (szVal, sztVal, 100);

				sprintf(sz, "%s %s\n", szCmd, szVal);

				WriteFile( 
					hDebugFile, 
					sz, 
					strlen(sz),
					&dwBytesWritten,
					NULL);
			}

			WriteFile( 
				hDebugFile, 
				szEnd, 
				strlen(szEnd),
				&dwBytesWritten,
				NULL);
			CloseHandle(hDebugFile);
#endif
			bResult = g_StateInfo.GoGo(dwTimeOut, m_Item, pdwResult);
		}
		else
		{
			*pdwResult = TSL_ERROR_GENERAL;
			m_stkStatus.Push(TSL_ERROR_NO_NETWORK);
			bResult = false;
		}
	}

	if (launchKnownNetwork == m_Item.GetLaunchRegime() )
	{
		bResult = g_StateInfo.GoGo(dwTimeOut, m_Item, pdwResult);
	}

	if (launchDefaultWebPage == m_Item.GetLaunchRegime())
	{
		bResult = g_StateInfo.GoURL(m_Item, pdwResult);

	}	

	return bResult;
}

HRESULT CLaunch::LaunchKnown(DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	// Launch the shooter.
	if (!Go(m_lLaunchWaitTimeOut, pdwResult))
		hRes = TSL_E_FAIL;
	return hRes;
}

HRESULT CLaunch::Launch(BSTR bstrCallerName, BSTR bstrCallerVersion, 
								BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	Clear();
	if (!BSTRToTCHAR(m_szAppName, bstrCallerName, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppVersion, bstrCallerVersion, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppProblem, bstrAppProblem, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (bLaunch)
	{
		if (!Go(m_lLaunchWaitTimeOut, pdwResult))
			hRes = TSL_E_FAIL;
	}
	else
	{
		if (!Map(pdwResult))
			hRes = TSL_E_FAIL;
	}
	return hRes;
}

HRESULT CLaunch::LaunchDevice(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrPNPDeviceID, 
							  BSTR bstrDeviceClassGUID, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes;
	Clear();

	if (!BSTRToTCHAR(m_szAppName, bstrCallerName, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppVersion, bstrCallerVersion, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppProblem, bstrAppProblem, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_Item.m_szPNPDeviceID, bstrPNPDeviceID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_Item.m_szGuidClass, bstrDeviceClassGUID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (m_Item.m_szGuidClass[0])
	{
		// Device Class GUID is non-null.  Make sure it's a valid GUID.
		GUID guidClass;
#ifdef _UNICODE
		RPC_STATUS rpcstatus = UuidFromString(
			m_Item.m_szGuidClass, &guidClass );
#else
		RPC_STATUS rpcstatus = UuidFromString(
			(unsigned char *) m_Item.m_szGuidClass, &guidClass );
#endif
		if ( rpcstatus == RPC_S_INVALID_STRING_UUID)
		{
			m_stkStatus.Push(TSL_WARNING_ILLFORMED_CLASS_GUID);
		}
	}

	if (bLaunch)
	{
		if (!Go(m_lLaunchWaitTimeOut, pdwResult))
			hRes = TSL_E_FAIL;
	}
	else
	{
		if (!Map(pdwResult))
			hRes = TSL_E_FAIL;
	}
	return hRes;
}

DWORD CLaunch::GetStatus()
{
	DWORD dwStatus = TSL_OK;
	if (!m_stkStatus.Empty())
		dwStatus = m_stkStatus.Pop();
	return dwStatus;
}

// OUTPUT *szPathName = Name of application to launch to (either IE or HTML Help System)
// Returns:
//	TSL_OK - success
//	TSL_E_CONTAINER_REG - failure to find IE (Internet Explorer) in registry
//	TSL_E_CONTAINER_NF - IE isn't where registry says to find it.
int CLaunch::GetContainerPathName(TCHAR szPathName[MAX_PATH])
{
	DWORD dwPathNameLen = MAX_PATH;
	int tslaHaveContainer = TSL_OK;
#ifndef _HH_CHM
	// use IE instead of HTML Help System
	if (!ReadRegSZ(HKEY_LOCAL_MACHINE,
				SZ_CONTAINER_APP_KEY,
				SZ_CONTAINER_APP_VALUE, szPathName, &dwPathNameLen))
	{
		tslaHaveContainer = TSL_E_CONTAINER_REG;
	}
	else
	{	// Need to verify that the container exists.
		WIN32_FIND_DATA data;
		HANDLE hContainer = FindFirstFile(szPathName, &data);
		if (INVALID_HANDLE_VALUE == hContainer)
			tslaHaveContainer = TSL_E_CONTAINER_NF;
		else
			FindClose(hContainer);
	}
#else
	_tcscpy(szPathName, _T("hh.exe"));
#endif
	return tslaHaveContainer;
}

// OUTPUT *szWebPage = Name of web page to launch to 
// We always launch to the same web page.  The information passed in m_Item ditinguishes
//	what will actually show on the screen.
// Path is from registry.  We concatenate on a backslash and SZ_WEB_PAGE (== "asklibrary.htm")
// Returns:
//	TSL_OK - success
//	TSL_E_WEB_PAGE_REG - failure to find web page for this purpose in registry
//	TSL_E_MEM_EXCESSIVE - Web page name longer than we can handle
//	TSL_E_WEB_PAGE_NF - Web page isn't where registry says to find it.
int CLaunch::GetWebPage(TCHAR szWebPage[MAX_PATH])
{
	int tslaHavePage = TSL_OK;
	DWORD dwWebPageLen = MAX_PATH;
	if (!ReadRegSZ(HKEY_LOCAL_MACHINE,
				SZ_LAUNCHER_ROOT,
				SZ_GLOBAL_LAUNCHER_RES, 
				szWebPage, 
				&dwWebPageLen))
	{
		tslaHavePage = TSL_E_WEB_PAGE_REG;
	}
	else
	{
		int Len = _tcslen(szWebPage);
		dwWebPageLen = Len + 1 + _tcslen(SZ_WEB_PAGE); 
		if (dwWebPageLen > MAX_PATH)
		{
			tslaHavePage = TSL_E_MEM_EXCESSIVE;
		}
		else
		{
			if (szWebPage[Len - 1] != '\\')
				_tcscat(szWebPage, _T("\\"));
			_tcscat(szWebPage, SZ_WEB_PAGE);

			WIN32_FIND_DATA data;
			HANDLE hWebPage = FindFirstFile(szWebPage, &data);
			if (INVALID_HANDLE_VALUE == hWebPage)
				tslaHavePage = TSL_E_WEB_PAGE_NF;
			else
				FindClose(hWebPage);
		}
	}
	return tslaHavePage;
}

// OUTPUT *szSniffScriptFile = full path and file name either to "network"_sniff.htm file or null len string if file is not found
//	TSL_OK - success
//	TSL_E_SNIFF_SCRIPT_REG - failure to find file for this purpose in registry
int CLaunch::GetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH], TCHAR* szNetwork)
{
	int tslaHavePage = TSL_OK;
	DWORD dwSniffScriptLen = MAX_PATH;
	TCHAR szSniffScriptPath[MAX_PATH] = {0};

	if (ReadRegSZ(HKEY_LOCAL_MACHINE,
			      SZ_TSHOOT_ROOT,
				  SZ_TSHOOT_RES, 
				  szSniffScriptPath, 
				  &dwSniffScriptLen))
	{
		int Len = _tcslen(szSniffScriptPath);

		dwSniffScriptLen = Len + 1 + (szNetwork ? _tcslen(szNetwork) + _tcslen(SZ_SNIFF_SCRIPT_APPENDIX) 
												: 0); 

		if (dwSniffScriptLen > MAX_PATH)
		{
			tslaHavePage = TSL_E_MEM_EXCESSIVE;
		}
		else
		{
			if (szSniffScriptPath[Len - 1] != '\\')
				_tcscat(szSniffScriptPath, _T("\\"));

			if (szNetwork)
			{
				TCHAR tmp[MAX_PATH] = {0};
				_tcscpy(tmp, szSniffScriptPath);
				_tcscat(tmp, szNetwork);
				_tcscat(tmp, SZ_SNIFF_SCRIPT_APPENDIX);

				WIN32_FIND_DATA data;
				HANDLE hSniffScript = FindFirstFile(tmp, &data);

				if (INVALID_HANDLE_VALUE == hSniffScript)
				{
					szSniffScriptFile[0] = 0;
				}
				else
				{
					_tcscpy(szSniffScriptFile, tmp);
					FindClose(hSniffScript);
				}
			}
			else
			{
				szSniffScriptFile[0] = 0;
			}
		}
	}
	else
	{
		tslaHavePage = TSL_E_SNIFF_SCRIPT_REG;
	}

	return tslaHavePage;
}

// OUTPUT *szSniffScriptFile = full path and file name of tssniffAsk.htm file no matter if it exists
//	TSL_OK - success
//	TSL_E_SNIFF_SCRIPT_REG - failure to find file for this purpose in registry
int CLaunch::GetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH])
{
	int tslaHavePage = TSL_OK;
	DWORD dwSniffStandardLen = MAX_PATH;
	TCHAR szSniffStandardPath[MAX_PATH] = {0};

	if (ReadRegSZ(HKEY_LOCAL_MACHINE,
			      SZ_LAUNCHER_ROOT,
				  SZ_GLOBAL_LAUNCHER_RES, 
				  szSniffStandardPath, 
				  &dwSniffStandardLen))
	{
		int Len = _tcslen(szSniffStandardPath);

		dwSniffStandardLen = Len + 1 + _tcslen(SZ_SNIFF_SCRIPT_NAME);

		if (dwSniffStandardLen > MAX_PATH)
		{
			tslaHavePage = TSL_E_MEM_EXCESSIVE;
		}
		else
		{
			if (szSniffStandardPath[Len - 1] != '\\')
				_tcscat(szSniffStandardPath, _T("\\"));

			_tcscpy(szSniffStandardFile, szSniffStandardPath);
			_tcscat(szSniffStandardFile, SZ_SNIFF_SCRIPT_NAME);
		}
	}
	else
	{
		tslaHavePage = TSL_E_SNIFF_SCRIPT_REG;
	}

	return tslaHavePage;
}

// OUTPUT *szURL = URL to go to when mapping fails.  We get this from registry.
//	TSL_OK - success
//	TSL_E_WEB_PAGE_REG - failure to find web page for this purpose in registry
int CLaunch::GetDefaultURL(TCHAR szURL[MAX_PATH])
{
	int tslaHaveURL = TSL_OK;
	DWORD dwURLLen = MAX_PATH;
	if (!ReadRegSZ(HKEY_LOCAL_MACHINE,
				SZ_LAUNCHER_ROOT,
				SZ_DEFAULT_PAGE, 
				szURL, 
				&dwURLLen))
	{
		tslaHaveURL = TSL_E_WEB_PAGE_REG;
	}
	return tslaHaveURL;
}

// Returns TSL_OK and default network name in szDefaultNetwork
// if successful
int CLaunch::GetDefaultNetwork(TCHAR szDefaultNetwork[SYM_LEN])
{
	DWORD dwLen = SYM_LEN;

	if (ReadRegSZ(HKEY_LOCAL_MACHINE, SZ_LAUNCHER_ROOT, SZ_DEFAULT_NETWORK,
		     	  szDefaultNetwork, &dwLen))
		if (VerifyNetworkExists(szDefaultNetwork))

			return TSL_OK;

	return TSL_E_NO_DEFAULT_NET;
}

bool CLaunch::Map(DWORD *pdwResult)
{
	bool bOK = true;
	TCHAR szMapFile[MAX_PATH];
	TCHAR szNetwork[SYM_LEN];           szNetwork[0] = NULL;
	TCHAR szTShootProblem[SYM_LEN];     szTShootProblem[0] = NULL;

	bOK = CheckMapFile(m_szAppName, szMapFile, pdwResult);

	// bOK false at this point means either the registry setting is missing or the file 
	//	is not where the registry says it is.  PdwResult has already been set in CheckMapFile.

	if (bOK && _tcscmp(m_szMapFile, szMapFile))
	{
		// The mapping file we desire is _not_ already loaded
		if (m_pMap)
		{
			// we were using a different mapping file.  We have to get rid of it.
			delete m_pMap;
		}
		// else we weren't using a mapping file yet.

		m_pMap = new TSMapClient(szMapFile);
		if (TSL_OK != m_pMap->GetStatus())
		{
			*pdwResult = m_pMap->GetStatus();
			bOK = false;
		}
		else
		{
			// We've successfully init'd m_pMap on the basis of the new map file.
			// Indicate that it's loaded.
			_tcscpy(m_szMapFile, szMapFile);
		}
	}

	if (bOK)
    {
		DWORD dwRes;
		
		// Now perform mapping itself
		//		
		dwRes = m_pMap->FromAppVerDevAndClassToTS(m_szAppName, m_szAppVersion,
				m_Item.m_szPNPDeviceID, m_Item.m_szGuidClass, m_szAppProblem,
				szNetwork, szTShootProblem);

		// As documented for TSMapRuntimeAbstract::FromAppVerDevAndClassToTS(), there are two
		//	return values here which require that we check for further status details: TSL_OK
		//	(which means we found a mapping, but doesn't rule out warnings) and 
		//	TSL_ERROR_NO_NETWORK (which means we didn't find a mapping, and is typically 
		//	accompanied by further clarifications).
		if (TSL_OK == dwRes || TSL_ERROR_NO_NETWORK == dwRes)
		{
			DWORD dwStatus;
			while (0 != (dwStatus = m_pMap->MoreStatus()))
				m_stkStatus.Push(dwStatus);
		}

		if (TSL_OK != dwRes)
			m_stkStatus.Push(dwRes);	// save the precise error status

		if (TSLIsError(dwRes) )
			bOK = false;

		if (bOK)
		{
			// We have a network name.
			bOK = VerifyNetworkExists(szNetwork);
		}

		if (bOK)
		{
			// We have a network name and we've verified that the network exists.
			// Set the item's network and tshoot problem.
			m_Item.SetNetwork(szNetwork);
			m_Item.SetProblem(szTShootProblem);
		}
		else
			*pdwResult = TSL_ERROR_GENERAL;
	} 
	
    return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\launch.h ===
// 
// MODULE: Launch.cpp
//
// PURPOSE: Starts the container that will query the LaunchServ for 
//			troubleshooter network and nodes.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

class TSMapClient;

class CLaunch
{
public:
	enum { SYM_LEN = CItem::SYM_LEN };
public:
	CLaunch();
	~CLaunch();
	void ReInit();	// 

	void Clear();	// Clears properties that are set by the launch functions.

	bool SetNode(LPCTSTR szNode, LPCTSTR szState);
	bool SpecifyProblem(LPCTSTR szNetwork, LPCTSTR szProblem);

	// Properties that are reset when ReInit is used.
	HRESULT MachineID(BSTR &bstrMachineID, DWORD *pdwResult);
	HRESULT DeviceInstanceID(BSTR &bstrDeviceInstanceID, DWORD *pdwResult);
	void SetPreferOnline(short bPreferOnline);

	// Launch functions.
	HRESULT LaunchKnown(DWORD * pdwResult);
	HRESULT Launch(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult);
	HRESULT LaunchDevice(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrPNPDeviceID, BSTR bstrDeviceClassGUID, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult);

	DWORD GetStatus();	// Used to get the stats information that is saved durring a launch or query.

	// Testing function.
	bool TestPut();	// Uses the mapping classes to map Caller() and DeviceID() information, then copies the CItem to global memory.

	// These two properties are not reset by ReInit or Clear.
	long m_lLaunchWaitTimeOut;
	bool m_bPreferOnline;				// Keeps track of an application-program-indicated
										// preference for online troubleshooter.  As of 
										// 1/98, this preference is ignored.


protected:
	void InitFiles();
	void InitRequest();
	bool VerifyNetworkExists(LPCTSTR szNetwork);

	int GetContainerPathName(TCHAR szPathName[MAX_PATH]);
	int GetWebPage(TCHAR szWebPage[MAX_PATH]);
	int GetDefaultURL(TCHAR szURL[MAX_PATH]);
	int GetDefaultNetwork(TCHAR szDefaultNetwork[SYM_LEN]);
	int GetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH], TCHAR* szNetwork);
	int GetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH]);

protected:

	// Use szAppName to check the registry for an application specific map file.
	bool CheckMapFile(TCHAR * szAppName, TCHAR szMapFile[MAX_PATH], DWORD *pdwResult);
	
	bool Go(DWORD dwTimeOut, DWORD *pdwResult);

	bool Map(DWORD *pdwResult);

	bool m_bHaveMapPath;		// Set when the path and file name for the default mapping file is read from the registry.
	bool m_bHaveDefMapFile;		// Set when the path name for the default mapping file is verified.
	bool m_bHaveDszPath;		// Set when the path name for the network resources is found.

	CItem m_Item;

	TCHAR m_szAppName[SYM_LEN];
	TCHAR m_szAppVersion[SYM_LEN];
	TCHAR m_szAppProblem[SYM_LEN];

	TCHAR m_szLauncherResources[MAX_PATH];	// The folder where the map file is kept.
	TCHAR m_szDefMapFile[MAX_PATH];			// The file name without the path.
	TCHAR m_szLaunchMapFile[MAX_PATH];		// m_szLauncherResources + m_szDefMapFile.
	TCHAR m_szDszResPath[MAX_PATH];			// The folder where the network resource files are located.  (Need to check for the existance of dsz/dsc files).
	TCHAR m_szMapFile[MAX_PATH];			// map file.
	TSMapClient *m_pMap;					// pointer to a (client-machine-style) mapping object

	RSStack<DWORD> m_stkStatus;				// Status and Error codes that happened durring a launch or mapping.

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\launchserv.cpp ===
// 
// MODULE: LaunchServ.cpp
//
// PURPOSE: Implementation of WinMain.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
// NOTES:  
// 1.	90% of this file was wrote by the ATL wizzard.
// 2.	This project is working fine without the proxy/stub dll.
//		The interfaces are using the IDispatch interface.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

// ATL Wizzard Note:
// 
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f LaunchServps.mk in the project directory.
//

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "LaunchServ.h"

#include "LaunchServ_i.c"

#include "StateInfo.h"

#include "RSSTACK.h"
#include "TSLError.h"
#include "TSMapAbstract.h"
#include "TSMap.h"
#include "TSMapClient.h"
#include "Launch.h"

#include <stdio.h>
#include "LaunchTS.h"
#include "TShootATL.h"

CServiceModule _Module;
CSMStateInfo g_StateInfo;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LaunchTS, CLaunchTS)
	OBJECT_ENTRY(CLSID_TShootATL, CTShootATL)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove any previous service since it may point to
	// the incorrect file
	Uninstall();

	// Add service entries
	UpdateRegistryFromResource(IDR_LaunchServ, TRUE);

	// Adjust the AppID for Local Server or Service
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{131CC292-7634-11D1-8B6B-0060089BD8C4}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;
	key.DeleteValue(_T("LocalService"));
	
	if (bService)
	{
		key.SetValue(_T("LaunchServ"), _T("LocalService"));
		key.SetValue(_T("-Service"), _T("ServiceParameters"));
		// Create service
		Install();
	}

	// Add object entries
	hr = CComModule::RegisterServer(bRegTypeLib);

	CoUninitialize();
	return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove service entries
	UpdateRegistryFromResource(IDR_LaunchServ, FALSE);
	// Remove service
	Uninstall();
	// Remove object entries
	CComModule::UnregisterServer();

	CoUninitialize();
	return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID)
{
	CComModule::Init(p, h);

	m_bService = TRUE;

	LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0 && !m_bService)
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
	return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
	{
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
		{
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
	if (IsInstalled())
		return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
	}

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
		hSCM, m_szServiceName, m_szServiceName,
		SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
		SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
	{
        ::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
		return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
	return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
	if (!IsInstalled())
		return TRUE;

	SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
		return FALSE;
	}

	SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

	if (hService == NULL)
	{
		::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
		return FALSE;
	}
	SERVICE_STATUS status;
	::ControlService(hService, SERVICE_CONTROL_STOP, &status);

	BOOL bDelete = ::DeleteService(hService);
	::CloseServiceHandle(hService);
	::CloseServiceHandle(hSCM);

	if (bDelete)
		return TRUE;

	MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
	va_list	pArg;

	va_start(pArg, pFormat);
	_vstprintf(chMsg, pFormat, pArg);
	va_end(pArg);

    lpszStrings[0] = chMsg;

	if (m_bService)
	{
	    /* Get a handle to use with ReportEvent(). */
		hEventSource = RegisterEventSource(NULL, m_szServiceName);
	    if (hEventSource != NULL)
	    {
	        /* Write to event log. */
	        ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
	        DeregisterEventSource(hEventSource);
	    }
	}
	else
	{
		// As we are not running as a service, just write the error to the console.
		_putts(chMsg);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
	{
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
	{
		m_bService = FALSE;
	}
	if (m_bService == FALSE)
		Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
	{
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
	LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
	switch (dwOpcode)
	{
	case SERVICE_CONTROL_STOP:
		SetServiceStatus(SERVICE_STOP_PENDING);
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
		break;
	case SERVICE_CONTROL_PAUSE:
		break;
	case SERVICE_CONTROL_CONTINUE:
		break;
	case SERVICE_CONTROL_INTERROGATE:
		break;
	case SERVICE_CONTROL_SHUTDOWN:
		break;
	default:
		LogEvent(_T("Bad service request"));
	}
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
	_Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
	_Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
	m_status.dwCurrentState = dwState;
	::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
	HRESULT hr;

	_Module.dwThreadID = GetCurrentThreadId();

//	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	_ASSERTE(SUCCEEDED(hr));

	// This provides a NULL DACL which will allow access to everyone.
	CSecurityDescriptor sd;
	sd.InitializeFromThreadToken();
	hr = CoInitializeSecurity(sd, -1, NULL, NULL,
		RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
	_ASSERTE(SUCCEEDED(hr));

	hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
	_ASSERTE(SUCCEEDED(hr));

	LogEvent(_T("Service started"));
    SetServiceStatus(SERVICE_RUNNING);

	MSG msg;
	while (GetMessage(&msg, 0, 0, 0))
		DispatchMessage(&msg);

	_Module.RevokeClassObjects();

	CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	_Module.Init(ObjectMap, hInstance, IDS_SERVICENAME);
	_Module.m_bService = TRUE;

	TCHAR szTokens[] = _T("-/");

	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	HRESULT hRes;
	TCHAR szMsg[50];
	bool bRegAttempt = false;
	bool bShowUsage = false;
	bool bSilent = false;
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			bRegAttempt = true;
			_tcscpy(szMsg, _T("UnregServer "));
			hRes = _Module.UnregisterServer();
		}
		else if (lstrcmpi(lpszToken, _T("RegServer"))==0)	// Register as Local Server
		{
			bRegAttempt = true;
			_tcscpy(szMsg, _T("RegServer "));
			hRes = _Module.RegisterServer(TRUE, FALSE);
		}
		else if (lstrcmpi(lpszToken, _T("Service"))==0)		// Register as Service
		{
			bRegAttempt = true;
			_tcscpy(szMsg, _T("Service "));
			hRes = _Module.RegisterServer(TRUE, TRUE);
		}
		else if (lstrcmpi(lpszToken, _T("?"))==0)
		{
			bShowUsage = true;
		}
		else if (lstrcmpi(lpszToken, _T("h"))==0)
		{
			bShowUsage = true;
		}
		else if (_tcsncmp(lpszToken, _T("s"), 1)==0)
		{
			bSilent = true;
		}
		else if (_tcsncmp(lpszToken, _T("S"), 1)==0)
		{
			bSilent = true;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (true == bRegAttempt)
	{
		if (!FAILED(hRes) && false == bSilent)
		{
			_tcscat(szMsg, _T("Succeded"));
			MessageBox(NULL, szMsg, _Module.m_szServiceName, MB_OK | MB_ICONINFORMATION);
			return hRes;
		}
		else if (false == bSilent)
		{
			_tcscat(szMsg, _T("Failed"));
			MessageBox(NULL, szMsg, _Module.m_szServiceName, MB_OK | MB_ICONEXCLAMATION);
			return hRes;
		}
		else
		{
			return hRes;
		}
	}

	if (true == bShowUsage)
	{
		MessageBox(NULL, _T("Usage: <[/UnregServer] [/RegServer] [/Service]>"),
					_Module.m_szServiceName, MB_OK | MB_ICONINFORMATION);
		return S_OK;
	}

	// Are we Service or Local Server
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{131CC292-7634-11D1-8B6B-0060089BD8C4}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	TCHAR szValue[_MAX_PATH];
	DWORD dwLen = _MAX_PATH;
	lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

	_Module.m_bService = FALSE;
	if (lRes == ERROR_SUCCESS)
		_Module.m_bService = TRUE;

	_Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\rsstack.h ===
//
// MODULE: RSSTACK,H
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/96
//
// NOTES: 
// 1.	A stack of any structure.  Can be used for pointers, but
//		will cause a memory leak when the stack is destroyed with
//		objects on it.
//
// 2.	This file has no .cpp file. Every thing is inline, due to the
//		template class.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
//

#ifndef __RSSTACK_H_
#define __RSSTACK_H_ 1

template<class T>
class RSStack
{
public:
	RSStack();
 	virtual ~RSStack();
// Attributes
public:

private:
	typedef struct tagRSStackNode
	{
		T SItem;
		struct tagRSStackNode *pNext;
	} RSStackNode;

	RSStackNode *m_pTop;
	RSStackNode *m_pPeak;

// Operations
public:
/*	
	Push returns -1 when out of memory.
*/
int Push(T);
/*
	Pop returns the top T item.
*/
T Pop();
/*
	1 is the top most item in the stack.  Returns the T item at
	tdown index by copying the value to refedItem.  False is returned if 
	tdown is greater than the number of items in the stack.
*/
BOOL GetAt(int tdown, T &refedItem);
/*
	PeakFirst returns the top most item and initializes variables that are
	used by PeakNext.  PeakFirst returns false when the stack is empty.
*/
BOOL PeakFirst(T &refedItem);
/*
	Use PeakNext to quickly peak at all of the items on the stack.
	PeakNext returns false when it can not copy a T item to refedItem.
*/
BOOL PeakNext(T &refedItem);
/*
	Empty returns TRUE (Non-Zero) when the stack is empty.
*/
BOOL Empty();
/*
	RemoveAll throws away the contents of the stack.
*/
void RemoveAll();
};

template<class T>
inline RSStack<T>::RSStack()
{
	m_pTop = NULL;
	m_pPeak = NULL;
}

template<class T>
inline RSStack<T>::~RSStack()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline int RSStack<T>::Push(T Item)
{
	int Ret;
	RSStackNode *pNew = new RSStackNode;
	if(NULL == pNew)
	{
		Ret = -1;
	}
	else
	{
		Ret = 1;
		pNew->pNext = m_pTop;
		m_pTop = pNew;
		pNew->SItem = Item;
	}
	return Ret;
}

template<class T>
inline T RSStack<T>::Pop()
{
	T Ret;
	if(NULL != m_pTop)
	{
		RSStackNode *pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		Ret = pOld->SItem;
		delete pOld;
	}
	return Ret;
}

template<class T>
inline BOOL RSStack<T>::Empty()
{
	BOOL bRet;
	if(NULL == m_pTop)
		bRet = TRUE;
	else
		bRet = FALSE;
	return bRet;
}

template<class T>
inline void RSStack<T>::RemoveAll()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline BOOL RSStack<T>::GetAt(int tdown, T &refedItem)
{
	BOOL bRet = FALSE;
	RSStackNode *pNode = m_pTop;
	while(pNode != NULL && tdown > 1)
	{
		pNode = pNode->pNext;
		tdown--;
	}
	if (pNode && 1 == tdown)
	{
		refedItem = pNode->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakFirst(T &refedItem)
{
	BOOL bRet = FALSE;
	if (NULL != m_pTop)
	{
		m_pPeak = m_pTop;
		refedItem = m_pTop->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakNext(T &refedItem)
{
	ASSERT(NULL != m_pPeak);
	BOOL bRet = FALSE;
	m_pPeak = m_pPeak->pNext;
	if (NULL != m_pPeak)
	{
		refedItem = m_pPeak->SItem;
		bRet = TRUE;
	}
	return bRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\stateinfo.h ===
// 
// MODULE: StateInfo.cpp
//
// PURPOSE: Contains sniffing, network and node information.  Also is used
//			by the Launch module to start the container application.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

enum ELaunchRegime 
{
	launchIndefinite = 0, 
	launchMap, 
	launchDefaultWebPage, 
	launchDefaultNetwork,
	launchKnownNetwork
};

//  Basically, this is the structure to pass information to the launched 
//	Local Troubleshooter OCX
class CItem
{
public:
	enum { SYM_LEN = 512 };
	enum { NODE_COUNT = 55 };
	enum { GUID_LEN = 256 };		// this is used for other things besides GUIDs, so
									// don't shrink it just because GUIDs are smaller.
public:
	CItem();

	void ReInit();
	void Clear();

	void SetNetwork(LPCTSTR szNetwork);
	void SetProblem(LPCTSTR szProblem);
	void SetNode(LPCTSTR szNode, LPCTSTR szState);
	bool GetNetwork(LPTSTR *pszCmd, LPTSTR *pszVal);
	bool GetProblem(LPTSTR *szCmd, LPTSTR *szVal);
	bool GetNodeState(int iNodeC, LPTSTR *szCmd, LPTSTR *szVal);
	TCHAR m_szEventName[SYM_LEN];		// an arbitrary, unique event name related to this
										//	launch.

	// ProblemSet and NetworkSet are used to query the state of the item.
	bool ProblemSet();
	bool NetworkSet();	

    // Interface to other member variables recponsible for launching
	void SetLaunchRegime(ELaunchRegime eLaunchRegime);
	void SetContainerPathName(TCHAR szContainerPathName[MAX_PATH]);
	void SetWebPage(TCHAR m_szWebPage[MAX_PATH]);
	void SetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH]);
	void SetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH]);
	ELaunchRegime GetLaunchRegime();
	TCHAR* GetContainerPathName();
	TCHAR* GetWebPage();
	TCHAR* GetSniffScriptFile();
	TCHAR* GetSniffStandardFile();

	// Although the troubleshooting network & problem node are already specified, 
	//	this info is here for sniffing.  That is, the Troubleshooter OCX can get the 
	//	P&P device ID & use it for sniffing purposes.
	TCHAR m_szPNPDeviceID[GUID_LEN];	// Plug & Play Device ID
	TCHAR m_szGuidClass[GUID_LEN];		// Standard text representation of Device Class GUID
	TCHAR m_szMachineID[GUID_LEN];		// Machine name (in format like "\\holmes")
										// Needed so that we can sniff on a remote machine
	TCHAR m_szDeviceInstanceID[GUID_LEN];	// Needed so that we can sniff correct device

protected:

	TCHAR m_szProblemDef[SYM_LEN];		// "TShootProblem", typically used as m_aszCmds[1]
										//		so that m_aszVals[1] is the name of the 
										//		problem node
	TCHAR m_szTypeDef[SYM_LEN];			// "type", typically used as m_aszCmds[0]
										//		so that m_aszVals[0] is the name of the 
										//		troubleshooting belief network
	int m_cNodesSet;					// The number of nodes, other than the problem
										//		node, for which we've set states.

	// The next two arrays are used jointly.  m_aszCmds[i] and m_aszVals[i] are
	//	a name/value pair similar to what would be returned by an HTML form,
	//	although, in practice, the Local Troubleshooter OCX does the work that
	//	(on the Web) would be performed by server-side code.
	// Typically these arrays have m_cNodesSet+2 significant entries (with the first 
	//	2 locations indicating troubleshooting network and problem node).
	// Second dimension is just amount of space for each string.
	TCHAR m_aszCmds[NODE_COUNT][SYM_LEN];
	TCHAR m_aszVals[NODE_COUNT][SYM_LEN];

	TCHAR m_szContainerPathName[MAX_PATH]; // name (possibly full path) of executable intended to start
	TCHAR m_szWebPage[MAX_PATH]; // full path of web page file (possibly default) to start container with
	TCHAR m_szSniffScriptFile[MAX_PATH]; // contains full path and file name of "network"_sniff.htm file
	TCHAR m_szSniffStandardFile[MAX_PATH]; // contains full path and file name of tssniffAsk.htm file

	ELaunchRegime m_eLaunchRegime; // regime of launch
};

class CSMStateInfo
{
	enum { HANDLE_VAL = 1 };
public:		
	CSMStateInfo();
	~CSMStateInfo();
	
	/* Made for the ILaunchTS interface .  */
	HRESULT GetShooterStates(CItem &refLaunchState, DWORD *pdwResult);

	/* Made for the ITShootATL  interface . */
	bool GoGo(DWORD dwTimeOut, CItem &item, DWORD *pdwResult);
	bool GoURL(CItem &item, DWORD *pdwResult);

	/* Made to verify the mapping code. */
	// The ILaunchTS interface uses TestGet directly.
	// The ITShootATL interface uses TestPut indirectly through the CLaunch class.
	// CLaunch does the mapping and then calls TestPut.
	void TestPut(CItem &item);	// Simply copies item to m_Item.
	void TestGet(CItem &item);	// Simply copies m_Item to item.

protected:
	CComCriticalSection m_csGlobalMemory;	// Critical section to protect global
											// memory against simultaneous use by 
											// TSLaunch.DLL & Local Troubleshooter OCX
	CComCriticalSection m_csSingleLaunch;	// Critical section to prevent distinct
											// launches (say, by 2 different applications)
											// from overlapping dangerously.
	CItem m_Item;

	BOOL CreateContainer(CItem &item, LPTSTR szCommand);
	BOOL CopySniffScriptFile(CItem &item);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tshootatl.h ===
// 
// MODULE: TShootATL.cpp
//
// PURPOSE: The interface that device manager uses to launch troubleshooters.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef __TSHOOTATL_H_
#define __TSHOOTATL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTShootATL
class ATL_NO_VTABLE CTShootATL : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTShootATL, &CLSID_TShootATL>,
	public IObjectWithSiteImpl<CTShootATL>,
	public IDispatchImpl<ITShootATL, &IID_ITShootATL, &LIBID_LAUNCHSERVLib>
{
public:
	CTShootATL()
	{
		m_csThreadSafe.Init();
	}
	~CTShootATL()
	{
		m_csThreadSafe.Term();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TSHOOTATL)

BEGIN_COM_MAP(CTShootATL)
	COM_INTERFACE_ENTRY(ITShootATL)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

protected:
	CLaunch m_Launcher;		// The real implementation.
	CComCriticalSection m_csThreadSafe;	// For minimal thread safety.  I expect that the interface will be used by only one thread per CoCreateInstance call.

// ITShootATL
public:
	STDMETHOD(GetStatus)(/*[out, retval]*/ DWORD *pdwStatus);
	STDMETHOD(get_PreferOnline)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_PreferOnline)(/*[in]*/ BOOL newVal);
	STDMETHOD(LaunchDevice)(/*[in]*/ BSTR bstrCallerName, /*[in]*/ BSTR bstrCallerVersion, /*[in]*/ BSTR bstrPNPDeviceID, /*[in]*/ BSTR bstrDeviceClassGUID, /*[in]*/ BSTR bstrAppProblem, /*[in]*/ short bLaunch, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(Launch)(/*[in]*/ BSTR bstrCallerName, /*[in]*/ BSTR bstrCallerVersion, /*[in]*/ BSTR bstrAppProblem, /*[in]*/ short bLaunch, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(get_LaunchWaitTimeOut)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_LaunchWaitTimeOut)(/*[in]*/ long newVal);
	STDMETHOD(LaunchKnown)(/*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(ReInit)();
	STDMETHOD(DeviceInstanceID)(/*[in]*/BSTR bstrDeviceInstanceID, /*[out, retval]*/DWORD * pdwResult);
	STDMETHOD(Test)();
	STDMETHOD(MachineID)(/*[in]*/ BSTR bstrMachineID, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(Language)(/*[in]*/ BSTR bstrLanguage, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(SetNode)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrState, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(SpecifyProblem)(/*[in]*/ BSTR bstrNetwork, /*[in]*/ BSTR bstrProblem, /*[out, retval]*/ DWORD *pdwResult);
};

#endif //__TSHOOTATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\stateinfo.cpp ===
// 
// MODULE: StateInfo.cpp
//
// PURPOSE: Contains sniffing, network and node information.  Also is used
//			by the Launch module to start the container application.
//
//			Basically, this is how the Launch Server packages up info for the 
//			Local TShoot OCX, launches either IE or HTML Help System to a page 
//			containing the Local TShoot OCX, and handshakes with the Local TShoot OCX
//			to pass that information 
//
//			Note that CSMStateInfo::GetShooterStates() is called by the 
//			Local TShoot OCX to pick up the CItem object which contains
//			the packaged-up info.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "atlbase.h"
#include "StateInfo.h"

#include "TSLError.h"
#include "ComGlobals.h"

#include "Registry.h"

#include <stdio.h>
#include <string.h>
#include <memory.h>
//#include <fstream.h>
#include <strstrea.h>

////////////////////////////////////////////////////////
//	CItem : 
//	Data structure for pseudo HTTP "get" in launching Local Troubleshooters 
//

CItem::CItem()
{
	// initializing this is exactly the same as reinitializing.
	ReInit();
}

void CItem::ReInit()
{
	memset(m_aszCmds, NULL, SYM_LEN * NODE_COUNT);
	memset(m_aszVals, NULL, SYM_LEN * NODE_COUNT);
	m_cNodesSet = 0;
	_tcscpy(m_szProblemDef, _T("TShootProblem"));
	_tcscpy(m_szTypeDef, _T("type"));
	m_szPNPDeviceID[0] = NULL;
	m_szGuidClass[0] = NULL;
	m_szContainerPathName[0] = NULL;
	m_szWebPage[0] = NULL;
	m_szSniffScriptFile[0] = NULL;
    m_eLaunchRegime = launchIndefinite;
	m_szMachineID[0] = NULL;
	m_szDeviceInstanceID[0] = NULL;

#ifdef _DEBUG
	
//	There are some other things you need to comment out in GetShooterStates
//	to allow debugging this service from a tshoot.ocx debug sesstion.
/*	
	_tcscpy(m_aszCmds[0], m_szTypeDef);
	_tcscpy(m_aszVals[0], _T("ras"));
	_tcscpy(m_aszCmds[1],  m_szProblemDef);
	_tcscpy(m_aszVals[1], _T("CnntCnnctAftrDlngWthRS"));
	_tcscpy(m_aszCmds[2], _T("SoftwareCompression"));
	_tcscpy(m_aszVals[2], _T("0"));
	m_cNodesSet = 1;
*/
#endif
	return;
}

void CItem::Clear()
{
	memset(m_aszCmds, NULL, SYM_LEN * NODE_COUNT);
	memset(m_aszVals, NULL, SYM_LEN * NODE_COUNT);
	m_cNodesSet = 0;
	_tcscpy(m_szProblemDef, _T("TShootProblem"));
	_tcscpy(m_szTypeDef, _T("type"));
	m_szPNPDeviceID[0] = NULL;
	m_szGuidClass[0] = NULL;
	m_szContainerPathName[0] = NULL;
	m_szWebPage[0] = NULL;
	m_szSniffScriptFile[0] = NULL;
    m_eLaunchRegime = launchIndefinite;
	return;
}

// ----------- Routines to build command/value pairs ------------------
//	see documentation of m_aszCmds, m_aszVals for further explanation

void CItem::SetNetwork(LPCTSTR szNetwork)
{
	if (NULL != szNetwork && NULL != szNetwork[0])
	{
		_tcscpy(m_aszCmds[0], m_szTypeDef);
		_tcsncpy(m_aszVals[0], szNetwork, SYM_LEN);
	}
	else
	{
		m_aszCmds[0][0] = NULL;
		m_aszVals[0][0] = NULL;
	}
	return;
}

void CItem::SetProblem(LPCTSTR szProblem)
{
	if (NULL != szProblem && NULL != szProblem[0])
	{
		_tcscpy(m_aszCmds[1], m_szProblemDef);
		_tcsncpy(m_aszVals[1], szProblem, SYM_LEN);
	}
	else
	{
		m_aszCmds[1][0] = NULL;
		m_aszVals[1][0] = NULL;
	}
	return;
}

void CItem::SetNode(LPCTSTR szNode, LPCTSTR szState)
{
	if (NULL != szNode && NULL != szNode[0] 
	&& NULL != szState && NULL != szState[0])
	{
		_tcsncpy(m_aszCmds[m_cNodesSet + 2], szNode, SYM_LEN);
		_tcsncpy(m_aszVals[m_cNodesSet + 2], szState, SYM_LEN);
		m_cNodesSet++;
	}
	return;
}

// ----------- Routines to query command/value pairs ------------------
// See documentation of m_aszCmds, m_aszVals for further explanation

// returns true if network has been set
// On success, OUTPUT *pszCmd is "type", *pszVal is network name
bool CItem::GetNetwork(LPTSTR *pszCmd, LPTSTR *pszVal)
{
	*pszCmd = m_szTypeDef;
	*pszVal = m_aszVals[0];
	return *m_aszVals[0] != NULL;
}

// returns true if problem node has been set
// On success, OUTPUT *pszCmd is "TShootProblem", *pszVal is problem node's symbolic name
bool CItem::GetProblem(LPTSTR *pszCmd, LPTSTR *pszVal)
{
	*pszCmd = m_szProblemDef;
	*pszVal = m_aszVals[1];
	return *m_aszVals[1] != NULL;;
}

// output the iNodeC-th non-problem node for which a state has been set.
// On success, OUTPUT *pszCmd is symbolic node name, *pszVal is state
// returns true if at least iNodeC non-problem nodes have been set
bool CItem::GetNodeState(int iNodeC, LPTSTR *pszCmd, LPTSTR *pszVal)
{
	if (iNodeC >= m_cNodesSet)
		return false;
	*pszCmd = m_aszCmds[iNodeC + 2];
	*pszVal = m_aszVals[iNodeC + 2];
	return true;
}

// ----------- Routines to query whether we know a network ------------
// ----------- & problem node to launch to ----------------------------
// See documentation of m_aszCmds, m_aszVals for further explanation

// NetworkSet returns true if we know which troubleshooter to launch.
bool CItem::NetworkSet()
{
	return NULL != m_aszVals[0][0];
}
// ProblemSet returns true if we know which problem to choose.
bool CItem::ProblemSet()
{
	return NULL != m_aszVals[1][0];
}

// --------- Interface to other member variables recponsible for launching -----------

void CItem::SetLaunchRegime(ELaunchRegime eLaunchRegime)
{
	m_eLaunchRegime = eLaunchRegime;
}

void CItem::SetContainerPathName(TCHAR szContainerPathName[MAX_PATH])
{
	if (NULL != szContainerPathName && NULL != szContainerPathName[0])
		_tcscpy(m_szContainerPathName, szContainerPathName);
	else
		m_szContainerPathName[0] = NULL;
	return;
}

void CItem::SetWebPage(TCHAR szWebPage[MAX_PATH])
{
	if (NULL != szWebPage && NULL != szWebPage[0])
		_tcscpy(m_szWebPage, szWebPage);
	else
		m_szWebPage[0] = NULL;
	return;
}

void CItem::SetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH])
{
	if (NULL != szSniffScriptFile && NULL != szSniffScriptFile[0])
		_tcscpy(m_szSniffScriptFile, szSniffScriptFile);
	else
		m_szSniffScriptFile[0] = NULL;
	return;
}

void CItem::SetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH])
{
	if (NULL != szSniffStandardFile && NULL != szSniffStandardFile[0])
		_tcscpy(m_szSniffStandardFile, szSniffStandardFile);
	else
		m_szSniffStandardFile[0] = NULL;
	return;
}

ELaunchRegime CItem::GetLaunchRegime()
{
	return m_eLaunchRegime;
}

inline TCHAR* CItem::GetContainerPathName()
{
	return m_szContainerPathName;
}

inline TCHAR* CItem::GetWebPage()
{
	return m_szWebPage;
}

inline TCHAR* CItem::GetSniffScriptFile()
{
	return m_szSniffScriptFile;
}

inline TCHAR* CItem::GetSniffStandardFile()
{
	return m_szSniffStandardFile;
}

////////////////////////////////////////////////////////
//	CSMStateInfo : 
//	State information on MSBN Troubleshooters
//	

CSMStateInfo::CSMStateInfo()
{
	m_csGlobalMemory.Init();
	m_csSingleLaunch.Init();
	return;
}

CSMStateInfo::~CSMStateInfo()
{
	m_csGlobalMemory.Term();
	m_csSingleLaunch.Term();
	return;
}

// TestPut:  Simply copies item to m_Item.
void CSMStateInfo::TestPut(CItem &item)
{
	m_csGlobalMemory.Lock();
	m_Item = item;
	m_csGlobalMemory.Unlock();
	return;
}

// TestGet:  Simply copies m_Item to item.
void CSMStateInfo::TestGet(CItem &item)
{
	m_csGlobalMemory.Lock();
	item = m_Item;
	m_csGlobalMemory.Unlock();
	return;
}

// Copy the item to the global memory and launch a process based on the command.
// Copying the item to global memory is here because the item is what tells the 
//	launched local troubleshooter what belief network etc. it is being launched to.
//	Once we unlock global memory, the Local Troubleshooter OCX can read that item
//	and act on it.
BOOL CSMStateInfo::CreateContainer(CItem &item, LPTSTR szCommand)
{
	BOOL bOk = TRUE;
	HRESULT hRes = S_OK;
	STARTUPINFO startup;
	PROCESS_INFORMATION process;

	memset(&startup, NULL, sizeof(STARTUPINFO));
	startup.cb = sizeof(STARTUPINFO);
	startup.wShowWindow = SW_SHOWNORMAL;

	m_csGlobalMemory.Lock();
	m_Item = item;

	bOk = CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL,
						&startup, &process);
	CloseHandle(process.hThread);
	CloseHandle(process.hProcess);	

	m_csGlobalMemory.Unlock();
	return bOk;
}

//
// Copy network_sniff.htm to tssniffAsk.htm if the former exists
// Create (modify) tssniffAsk.htm to be a sniffing stub otherwise 
//
BOOL CSMStateInfo::CopySniffScriptFile(CItem &item)
{
	TCHAR* szSniffScriptFile = item.GetSniffScriptFile();
	TCHAR* szSniffStandardFile = item.GetSniffStandardFile();

	if (!*szSniffScriptFile) // no network specific sniff file
	{
		// szSniffScriptFile contains tssniffAsk.htm
		// it means that we have to form this file as an empty stub
		ostrstream fileSniffScript;

		HANDLE hFile = ::CreateFile(szSniffStandardFile, 
									GENERIC_WRITE, 
									0,
									NULL,			// no security attributes 
									CREATE_ALWAYS, 
									FILE_FLAG_RANDOM_ACCESS, 
									NULL			// handle to template file
  								   );

		if (hFile != INVALID_HANDLE_VALUE)
		{
			// form html file - part preceding script
			fileSniffScript << "<HTML>" << endl;
			fileSniffScript << "<HEAD>" << endl;
			fileSniffScript << "<TITLE>GTS LOCAL</TITLE>" << endl;
			fileSniffScript << "</HEAD>" << endl;
			fileSniffScript << "<SCRIPT LANGUAGE=\"VBSCRIPT\">" << endl;
			fileSniffScript << "<!--" << endl;
			
			// form global function
			fileSniffScript << "function PerformSniffing()" << endl;
			fileSniffScript << "end function" << endl;

			// form html file - part after script
			fileSniffScript << "-->" << endl;
			fileSniffScript << "</SCRIPT>" << endl;
			fileSniffScript << "<BODY BGCOLOR=\"#FFFFFF\">" << endl;
			fileSniffScript << "</BODY>" << endl;
			fileSniffScript << "</HTML>" << endl;
			fileSniffScript << ends;

			char* str = fileSniffScript.str();
			DWORD read;
			
			if (!::WriteFile(hFile, str, strlen(str), &read, NULL))
			{
				::CloseHandle(hFile);
				fileSniffScript.rdbuf()->freeze(0);
				return false;
			}

			::CloseHandle(hFile);
			fileSniffScript.rdbuf()->freeze(0);
			return true;
		}	
		else
		{
			return false;
		}
	}
	else
	{
		return ::CopyFile(szSniffScriptFile, szSniffStandardFile, false);
	}
}

// Find the container (HTML Help System or IE) and starting web page, launch, wait to
//	see if launch succeeded
bool CSMStateInfo::GoGo(DWORD dwTimeOut, CItem &item, DWORD *pdwResult)
{
	bool bResult = true;
	HANDLE hLaunchedEvent = NULL;
	TCHAR szProcess[MAX_PATH];
	TCHAR szWebPage[MAX_PATH];
	LPTSTR pszCommand = NULL;
	int CommandLen;
	DWORD dwError;
	int Count = 34;

	if (item.GetLaunchRegime() == launchIndefinite ||
		!item.GetContainerPathName()[0] ||
		!item.GetWebPage()[0]
	   )
	{
		*pdwResult = TSL_ERROR_ASSERTION;
		return false;
	}
	
	do
	{
		_stprintf(item.m_szEventName, _T("TSL_SHOOTER_Event_%ld"), Count);
		if (NULL == (hLaunchedEvent = CreateEvent (NULL, FALSE, FALSE, item.m_szEventName)))
		{
			dwError = GetLastError();
			if (ERROR_ALREADY_EXISTS != dwError)
			{
				*pdwResult = dwError;
				return false;
			}
		}		
	} while (NULL == hLaunchedEvent);
	
	// Get the path to internet explorer (or HTML Help System).
	_tcscpy(szProcess, item.GetContainerPathName());

	// Need to know the location and name of the
	// page that asks the service for the CItem
	// information.
	_tcscpy(szWebPage, item.GetWebPage());

	CommandLen = _tcslen(szProcess) + 1 + _tcslen(szWebPage) + 2;
	pszCommand = new TCHAR[CommandLen];
	if (NULL == pszCommand)
	{
		*pdwResult = TSL_ERROR_OUT_OF_MEMORY;
		return false;
	}
	_tcscpy(pszCommand, szProcess);
	_tcscat(pszCommand, _T(" "));
	_tcscat(pszCommand, szWebPage);

	m_csSingleLaunch.Lock();

	// copy to or create tssniffAsk.htm
	if (!CopySniffScriptFile(item))
	{
		*pdwResult = TSL_E_COPY_SNIFF_SCRIPT;
		return false;
	}

	// CreateContainer copies the item to the global memory and 
	// launches the command.
	if (!CreateContainer(item, pszCommand))
	{
		*pdwResult = TSL_E_CREATE_PROC;
		bResult = false;
	}
	else
	{
		if (WAIT_OBJECT_0 == WaitForSingleObject(hLaunchedEvent, dwTimeOut))
		{	// The container has the information.
			*pdwResult = TSL_OK;
		}
		else
		{	// Wait timed out.  Don't know if the operation will work or not work.
			*pdwResult = TSL_W_CONTAINER_WAIT_TIMED_OUT;
		}
	}
	m_csSingleLaunch.Unlock();

	delete [] pszCommand;

	CloseHandle(hLaunchedEvent);
	return bResult;
}

// Find the container (HTML Help System or IE) and start it up to a URL which is _not_
//	expected to contain Local Troubleshooter, just an arbitrary web page.  This should 
//	only be used when the launch as such can't work, and we are just trying to give them
//	somewhere to start troubleshooting, typically the home page which lists all 
//	trobleshooting belief networks.
bool CSMStateInfo::GoURL(CItem &item, DWORD *pdwResult)
{
	bool bResult = true;
	TCHAR szProcess[MAX_PATH];
	TCHAR szWebPage[MAX_PATH];
	LPTSTR pszCommand = NULL;
	int CommandLen;

	if (item.GetLaunchRegime() != launchDefaultWebPage ||
		!item.GetContainerPathName()[0] ||
		!item.GetWebPage()[0]
	   )
	{
		*pdwResult = TSL_ERROR_ASSERTION;
		return false;
	}
	
	// Get the path to internet explorer (or HTML Help System).
	_tcscpy(szProcess, item.GetContainerPathName());

	// Need to know the location and name of the
	// page that asks the service for the CItem
	// information.
	_tcscpy(szWebPage, item.GetWebPage());

	CommandLen = _tcslen(szProcess) + 1 + _tcslen(szWebPage) + 2;
	pszCommand = new TCHAR[CommandLen];
	if (NULL == pszCommand)
	{
		*pdwResult = TSL_ERROR_OUT_OF_MEMORY;
		return false;
	}
	_tcscpy(pszCommand, szProcess);
	_tcscat(pszCommand, _T(" "));
	_tcscat(pszCommand, szWebPage);
	
	// CreateContainer is overkill here, but perfectly OK.
	if (!CreateContainer(item, pszCommand))
	{
		*pdwResult = TSL_E_CREATE_PROC;
		bResult = false;
	}

	delete [] pszCommand;

	return bResult;
}

// This function is used by the Local Troubleshooter OCX, not by the Launcher.
// This is how the Local Troubleshooter knows what troubleshooting network to launch
//	to, as well as any nodes whose states are set.
// GetShooterStates returns the commands and the number of commands for
// the Tshoot.ocx.
// refLaunchState is a member of this instance of the LaunchTS interface.
// 
HRESULT CSMStateInfo::GetShooterStates(CItem &refLaunchState, DWORD *pdwResult)
{
	HANDLE hHaveItemEvent;
	// Get a copy of the launch info state stored in this instance.
	// Synchronize with the process that launched the service.

	m_csGlobalMemory.Lock();

	if (NULL == (hHaveItemEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_Item.m_szEventName)))
	{
		*pdwResult = GetLastError();
		m_csGlobalMemory.Unlock();
		return TSL_E_FAIL;
	}

	// Get a copy of the state before unlocking the global memory.
	refLaunchState = m_Item;
	// Let the other process continue running.

	SetEvent(hHaveItemEvent);
	m_csGlobalMemory.Unlock();
	CloseHandle(hHaveItemEvent);

	*pdwResult = 0;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tsmap.h ===
// 
// MODULE: TSMap.h
//
// PURPOSE: Structures and other definitions for the Troubleshooter MAP file.
//			These use char rather than TCHAR because the file format is always strictly SBCS 
//			(Single Byte Character Set).
//			This should suffice for any values it is ever expected to contain, and saves space
//			considerably compared to Unicode, since the file is overwhelmingly text.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////

#ifndef _TSMAP_
#define _TSMAP_

const char * const k_szMapFileSignature = const_cast < const char * > ("TSMAP");

#define BUFSIZE 256

typedef struct TSMAPFILEHEADER {
	char szMapFileSignature[6];	// Always k_szMapFileSignature
	char szVersion[6];				// null terminated numeric version number, a positive
									//	integer <= 99999. Current version: always "00001"
	char szRelease[40];			// string uniquely identifying this file.
									//	plan 1/2/98 is use GUID
	DWORD dwOffApp;					// offset where applications list starts
	DWORD dwLastOffApp;				// offset where applications list ends
	DWORD dwOffProb;				// offset where problem names list starts
	DWORD dwLastOffProb;			// offset where problem names list ends
	DWORD dwOffDevID;				// offset where device IDs list starts
	DWORD dwLastOffDevID;			// offset where device IDs list ends
	DWORD dwOffDevClass;			// offset where device class GUIDs list starts
	DWORD dwLastOffDevClass;		// offset where device class GUIDs list ends

} TSMAPFILEHEADER;

typedef struct UIDMAP {
	unsigned short cb;	// count of bytes in this record
	UID uid;
	char szMapped[BUFSIZE];
} UIDMAP;

typedef struct APPMAP {
	unsigned short cb;	// count of bytes in this record
	DWORD dwOffVer;				// offset where versions list starts
	DWORD dwLastOffVer;			// offset where versions list ends
	char szMapped[BUFSIZE];
} APPMAP;

typedef struct VERMAP {
	unsigned short cb;	// count of bytes in this record
	UID uid;	// this version's own UID
	UID uidDefault;	// UID of version to default to if no data for this version
	DWORD dwOffProbUID;				// offset where problem UID list starts
	DWORD dwLastOffProbUID;			// offset where problem UID list ends
	DWORD dwOffDevUID;				// offset where device UID list starts
	DWORD dwLastOffDevUID;			// offset where device UID list ends
	DWORD dwOffDevClassUID;			// offset where device class UID list starts
	DWORD dwLastOffDevClassUID;		// offset where device class UID list ends
	char szMapped[BUFSIZE];
} VERMAP;

typedef struct PROBMAP {
	unsigned short cb;			// count of bytes in this record
	UID uidProb;
	DWORD dwOffTSName;	// file offset of troubleshooting belief network name
	char szProblemNode[BUFSIZE];  // null-terminated symbolic node name (may be null)
} PROBMAP;

typedef struct DEVMAP {
	unsigned short cb;			// count of bytes in this record
	UID uidDev;
	UID uidProb;
	DWORD dwOffTSName;	// file offset of troubleshooting belief network name
	char szProblemNode[BUFSIZE];  // null-terminated symbolic node name (may be null)
} DEVMAP;

typedef struct DEVCLASSMAP {
	unsigned short cb;			// count of bytes in this record
	UID uidDevClass;
	UID uidProb;
	DWORD dwOffTSName;	// file offset of troubleshooting belief network name
	char szProblemNode[BUFSIZE];  // null-terminated symbolic node name (may be null)
} DEVCLASSMAP;

#endif //_TSMAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__131CC295_7634_11D1_8B6B_0060089BD8C4__INCLUDED_)
#define AFX_STDAFX_H__131CC295_7634_11D1_8B6B_0060089BD8C4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN32_WINNT) || (defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0400))
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__131CC295_7634_11D1_8B6B_0060089BD8C4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tslerror.h ===
// 
// MODULE: tslerror.h
//
// PURPOSE: Warning and error codes for the TSLauncher.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHORS: Joe Mabel and Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#define TSL_OK 0
#define TSL_ERROR_BAD_HANDLE            1	// Handle hTSL passed into function is bad.
#define TSL_ERROR_OUT_OF_MEMORY         2	// Out-of-memory detected
#define TSL_ERROR_OBJECT_GONE			3	// The LaunchServ returned a negative HRESULT.
#define TSL_ERROR_GENERAL               4	// Can't launch a troubleshooter.  There are 
											//	error statuses to be accessed by TSLStatus.
#define TSL_ERROR_NO_NETWORK            5	// Can't identify an appropriate troubleshooting 
											//	network.
#define TSL_ERROR_ILLFORMED_MACHINE_ID  6	// Machine ID is not correctly formed.  Sniffing 
											//	disabled.
#define TSL_ERROR_BAD_MACHINE_ID        7	// A machine ID was specified but can't be used.  
											//	Sniffing disabled.
#define TSL_ERROR_ILLFORMED_DEVINST_ID  8	// Device Instance ID is not correctly formed.
											//	Sniffing disabled.
#define TSL_ERROR_BAD_DEVINST_ID        9	// Device Instance ID was specified but can't be 
											//	used.  Sniffing disabled.
#define TSL_ERROR_UNKNOWN_APP		   10	// An unrecognized application was specified.
#define TSL_ERROR_UNKNOWN_VER		   11	// Unrecognized version (no such version 
											//	associated with application)
#define TSL_ERROR_ASSERTION	           13   // An assertion failed

// The next several errors could be thought of as "hard failures of mapping", but we do not 
//	treat them as hard errors because even if mapping fails totally, we may still be able to
//	launch to a generic troubleshooter.
#define TSL_ERROR_MAP_BAD_SEEK			101	 // failure while seeking in the mapping file.
// Although, at a low level, a bad seek just indicates seeking to an inappropriate file 
//	offset, in practice a bad seek would indicate a serious problem either in the mapping file 
//	or in the code: we should only be seeking to offsets which the contents of the mapping file
//	told us to seek to.
#define TSL_ERROR_MAP_BAD_READ			102	 // failure while reading from the mapping file.
// Although, at a low level, a bad read just indicates (for example) reading past EOF, in 
//	practice a bad read would indicate a serious problem either in the mapping file or in 
//	the code: we should only be reading (1) the header or (2) records which the contents of 
//	the mapping file told us to read.
#define TSL_ERROR_MAP_CANT_OPEN_MAP_FILE 103
#define TSL_ERROR_MAP_BAD_HEAD_MAP_FILE	 104	// failed to read even the header of the map file

// The next several errors should never be seen by applications.  They would mean that the
//	launch server is mis-using the mapping code.
#define TSM_STAT_NEED_VER_TO_SET_DEF_VER 111	// Trying to apply a version default, but you
												//	haven't yet successfully set a version
												//	as a basis to look up the default
#define TSM_STAT_NEED_APP_TO_SET_VER	112		// tried to look up version without previously
												// setting application
#define TSM_STAT_UID_NOT_FOUND			113		// a string could not be mapped to a UID.
												// In the existing TSMapClient class, 
												// this means that the name could not be found
												// in the region of the mapping file where 
												// it belongs (e.g. that a version string is
												// not in the list of versions for the
												// current application.)
												// This should always be turned into something
												// more specific before it is passed to
												// higher-level code.

#define TSL_MIN_WARNING 1000
#define TSL_WARNING_NO_PROBLEM_NODE  1004	// Can't identify an appropriate problem node.  
											//	Troubleshooting will proceed from "first page" 
											//	for this troubleshooting network.
#define TSL_WARNING_NO_NODE          1005	// A state value was specified for a nonexistent 
											//	node 
#define TSL_WARNING_NO_STATE         1006	// A non-existent state value was specified for an 
											//	otherwise valid node.
#define TSL_WARNING_LANGUAGE         1007	// Can't apply specified language to this 
											//	particular problem (no language-appropriate 
											//	troubleshooting network).  Successively default 
											//	to standard language of this machine and to 
											//	English.
#define TSL_WARNING_NO_ONLINE        1008	// Can't obey stated preference for Online 
											//	Troubleshooter
#define TSL_WARNING_ONLINE_ONLY      1009	// Can't obey stated preference against Online 
											//	Troubleshooter
#define TSL_WARNING_GENERAL          1010	// Can launch a troubleshooter, but there are 
											//	warnings to be accessed by TSLStatus.

#define TSL_WARNING_ILLFORMED_DEV_ID 1011	// Device ID is not correctly formed.
#define TSL_WARNING_BAD_DEV_ID       1012	// A correctly formed but invalid device ID
#define TSL_WARNING_ILLFORMED_CLASS_GUID 1013	// Device Class GUID is not correctly formed.
#define TSL_WARNING_BAD_CLASS_GUID       1014	// A correctly formed but invalid device Class GUID
#define TSL_WARNING_UNKNOWN_APPPROBLEM	 1015	// App problem passed in, but this problem 
											//	name is nowhere in the mapping file.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem
#define TSL_WARNING_UNUSED_APPPROBLEM	 1016	// App problem passed in, and the name is
											//	recognized but can't be used in conjunction
											//	with the device information given.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem

#define TSL_W_CONTAINER_WAIT_TIMED_OUT	1017	// The container did not respond within the time 
												//	out value specified in the go method.
#define TSL_WARNING_END_OF_VER_CHAIN	1018	// Should never be seen by the calling app.
											// Indicates that we are at the end of the chain
											// in applying default versions.

#define TSL_MAX_WARNING 1999

// the range 2000-2099 is reserved for internal use by the mapping code.
// statuses in this range should not ever be exposed outside of class TSMapRuntimeAbstract 
// and its subclasses.
#define TSL_MIN_RESERVED_FOR_MAPPING 2000
#define TSL_MAX_RESERVED_FOR_MAPPING 2099

// Errors generated by LaunchServ.  Need to start @ 4,000 to avoid confusion with
// codes returned by the local troubleshooter.
#define TSL_E_CONTAINER_REG		4000	// Could not find the path to hh.exe / iexplore.exe in the registry.
#define TSL_E_CONTAINER_NF		4001	// Found the path to the browser, but it is not at that location.
#define TSL_E_WEB_PAGE_REG		4002	// Could not find the path to the web page in the registry.
#define TSL_E_WEB_PAGE_NF		4003	// Found the path to the web page, but it is not at that location.
#define TSL_E_CREATE_PROC		4004	// Could not create the hh.exe / iexplore.exe process.
#define TSL_E_MEM_EXCESSIVE		4005	// An unexpected amount of memory is required.  i.e. a path name that is longer than MAX_PATH.
#define TSL_E_MAPPING_DB_REG	4006	// Could not find the path to the binary mapping file in the registry.
#define TSL_E_MAPPING_DB_NF		4007	// Found the path to the mapping file, but it is not at that location.
#define TSL_E_NETWORK_REG		4008	// Could not find the path to the network resources (DSZ files).
#define TSL_E_NETWORK_NF		4009	// Could not find a DSC or DSZ file with the network name.
#define TSL_E_NODE_EMP			4010	// A call to set node had a null node name or node state.
#define TSL_E_NO_DEFAULT_NET	4011	// The mapping class failed to get a network and there is not a default network defined in the registry.
#define TSL_E_SNIFF_SCRIPT_REG	4012	// Could not find the path to the sniff script in the registry.
#define TSL_E_COPY_SNIFF_SCRIPT	4013	// Could not create the hh.exe / iexplore.exe process.


inline bool TSLIsHardError(DWORD dwStatus)
{
	return (dwStatus == TSL_ERROR_BAD_HANDLE 
		|| dwStatus == TSL_ERROR_OUT_OF_MEMORY 
		|| dwStatus == TSL_ERROR_OBJECT_GONE);
}

inline bool TSLIsError(DWORD dwStatus) 
{
	return (TSL_OK != dwStatus && dwStatus < TSL_MIN_WARNING || dwStatus > TSL_MAX_WARNING);
}

inline bool TSLIsWarning(DWORD dwStatus) 
{
	return (dwStatus >= TSL_MIN_WARNING && dwStatus <= TSL_MAX_WARNING);
}

#define TSL_E_FAIL		-1
#define TSL_SERV_FAILED(hRes) (FAILED(hRes) && TSL_E_FAIL != hRes)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tshootatl.cpp ===
// 
// MODULE: TShootATL.cpp
//
// PURPOSE: The interface that device manager uses to launch troubleshooters.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "LaunchServ.h"
#include "StateInfo.h"
#include "RSSTACK.H"
#include "Launch.h"

#include "TShootATL.h"

#include "TSLError.h"
#include "ComGlobals.h"

#include <atlimpl.cpp>

/////////////////////////////////////////////////////////////////////////////
// CTShootATL - Created as an internet explorer object with a dual interface


STDMETHODIMP CTShootATL::SpecifyProblem(BSTR bstrNetwork, BSTR bstrProblem, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	TCHAR szProblem[CLaunch::SYM_LEN];
	TCHAR szNetwork[CLaunch::SYM_LEN];
	if (!BSTRToTCHAR(szNetwork, bstrNetwork, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(szProblem, bstrProblem, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	m_csThreadSafe.Lock();
	try
	{
		if (!m_Launcher.SpecifyProblem(szNetwork, szProblem))
		{
			*pdwResult = TSL_ERROR_GENERAL;
			hRes = TSL_E_FAIL;
		}
		else
		{
			*pdwResult = TSL_OK;
		}
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::SetNode(BSTR bstrName, BSTR bstrState, DWORD *pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	TCHAR szName[CLaunch::SYM_LEN];
	TCHAR szState[CLaunch::SYM_LEN];
	if (!BSTRToTCHAR(szName, bstrName, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(szState, bstrState, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	m_csThreadSafe.Lock();
	try
	{
		if (!m_Launcher.SetNode(szName, szState))
		{
			*pdwResult = TSL_ERROR_GENERAL;
			hRes = TSL_E_FAIL;
		}
		else
		{
			*pdwResult = TSL_OK;
		}
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::Language(BSTR bstrLanguage, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	m_csThreadSafe.Lock();
	try
	{
		//hRes =
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::MachineID(BSTR bstrMachineID, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.MachineID(bstrMachineID, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}
// Test:  Call Test after setting the device and caller information.
// Test will return S_OK if the mapping worked.  The result of the mapping
// can then be obtained through the ILaunchTS interface.  Use the Test method
// of ILaunchTS before calling the other ILaunchTS methods.
STDMETHODIMP CTShootATL::Test()
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		if (m_Launcher.TestPut())	// Does the mapping and copies the information to global memory.
			hRes = S_OK;
		else
			hRes = TSL_E_FAIL;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::DeviceInstanceID(BSTR bstrDeviceInstanceID, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.DeviceInstanceID(bstrDeviceInstanceID, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::ReInit()
{
	m_csThreadSafe.Lock();
	try
	{
		m_Launcher.ReInit();
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return S_OK;
}

STDMETHODIMP CTShootATL::LaunchKnown(DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.LaunchKnown(pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::get_LaunchWaitTimeOut(long * pVal)
{
	HRESULT hRes = S_OK;
	m_csThreadSafe.Lock();
	try
	{
		*pVal = m_Launcher.m_lLaunchWaitTimeOut;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::put_LaunchWaitTimeOut(long newVal)
{
	HRESULT hRes = S_OK;
	m_csThreadSafe.Lock();
	try
	{
		m_Launcher.m_lLaunchWaitTimeOut = newVal;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::Launch(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.Launch(bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::LaunchDevice(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrPNPDeviceID, BSTR bstrDeviceClassGUID, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.LaunchDevice(bstrCallerName, bstrCallerVersion, bstrPNPDeviceID, bstrDeviceClassGUID, bstrAppProblem, bLaunch, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::get_PreferOnline(BOOL * pVal)
{
	m_csThreadSafe.Lock();
	try
	{
		if (m_Launcher.m_bPreferOnline)
			*pVal = 1;
		else
			*pVal = 0;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();	
	return S_OK;
}

STDMETHODIMP CTShootATL::put_PreferOnline(BOOL newVal)
{
	m_csThreadSafe.Lock();
	try
	{
		m_Launcher.m_bPreferOnline = (0 != newVal);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();	
	return S_OK;
}

STDMETHODIMP CTShootATL::GetStatus(DWORD * pdwStatus)
{
	m_csThreadSafe.Lock();
	try
	{
		*pdwStatus = m_Launcher.GetStatus();
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tsmapclient.cpp ===
// 
// MODULE: TSMapClient.cpp
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Class TSMapClient is available at runtime for mapping from the application's 
//			way of naming a problem to the Troubleshooter's way.
//			Only a single thread should operate on any one object of class TSMapClient.  The object is not
//			threadsafe.
//			In addition to the overtly noted returns, many methods can return a preexisting error.
//			However, if the calling program has wishes to ignore an error and continue, we 
//			recommend an explicit call to inherited method ClearStatus().
//			Note that the mapping file is always strictly SBCS (Single Byte Character Set), but the
//			calls into this code may use Unicode. This file consequently mixes char and TCHAR.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////


// TSMapClient
//
// AUTHOR: Joe Mabel

#include "stdafx.h"

#include "TSLError.h"
#include "RSSTACK.H"
#include "TSMapAbstract.h"
#include "TSMap.h"
#include "TSMapClient.h"

// uncomment the following line to turn on Joe's hard-core debugging
//#define KDEBUG 1
#ifdef KDEBUG
static HANDLE hDebugFile = INVALID_HANDLE_VALUE;
static DWORD dwBytesWritten;
#include <stdio.h>
#endif


// because the null string is a perfectly valid value for some strings, we reserve an 
//	arbitrary implausible value so we don't get a false cache match on startup.
const char * const szBogus = "**BOGUS**";

// Convert TCHAR *szt to char *sz.  *sz should point to a big enough buffer
//	to contain an SNCS version of *szt.  count indicates the size of buffer *sz.
// returns sz (convenient for use in string functions).
static char* ToSBCS (char * const sz, const TCHAR * szt, size_t count)
{
	if (sz)
	{
		if (count != 0 && !szt)
			sz[0] = '\0';
		else
		{
			#ifdef  _UNICODE
				wcstombs( sz, szt, count );
			#else
				strcpy(sz, szt);
			#endif
		}
	}
	return sz;
}

// Convert char *sz to TCHAR *szt.  *szt should point to a big enough buffer
//	to contain a TCHAR* version of *sz (twice as big if its Unicode).  
//	count indicates the size of buffer *szt.
// returns szt (convenient for use in string functions).
static TCHAR* FromSBCS (TCHAR * const szt, const char * const sz, size_t count)
{
	if (szt)
	{
		if (count != 0 && !sz)
			szt[0] = _T('\0');
		else
		{
			#ifdef  _UNICODE
				mbstowcs( szt, sz, count);
			#else
				strcpy(szt, sz);
			#endif
		}
	}
	return szt;
}

TSMapClient::TSMapClient(const TCHAR * const sztMapFile)
{
	TSMapRuntimeAbstract::TSMapRuntimeAbstract();
	_tcscpy(m_sztMapFile, sztMapFile);
	m_hMapFile = INVALID_HANDLE_VALUE;

	// >>> 1/16/98 we are setting these false until we can arrange to use the same'
	//	collating sequence in SQL Server & in this code.
	m_bAppAlphaOrder = false;
	m_bVerAlphaOrder = false;
	m_bDevIDAlphaOrder = false;
	m_bDevClassGUIDAlphaOrder = false;
	m_bProbAlphaOrder = false;

	Initialize();
	ClearAll();
}

TSMapClient::~TSMapClient()
{
	if (m_hMapFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hMapFile);
}

// If not already initialized, open the mapping file & read the header
// Note that this is not thread-safe.  Only a single thread should use a given TSMapClient
//	object.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// Typically, on entry m_dwStatus should be 0 and will be left alone if there are no errors
// Can set m_dwStatus to any of the following values:
//	TSL_ERROR_MAP_CANT_OPEN_MAP_FILE
//	TSL_ERROR_MAP_BAD_HEAD_MAP_FILE
DWORD TSMapClient::Initialize()
{
	static bool bInit = false;
	DWORD dwStatus = 0;

	if (!bInit)
	{
		m_hMapFile = CreateFile( 
			m_sztMapFile, 
			GENERIC_READ, 
			FILE_SHARE_READ,
			NULL,			// no security attributes 
			OPEN_EXISTING, 
			FILE_FLAG_RANDOM_ACCESS, 
			NULL			// handle to template file
			);

		if (m_hMapFile == INVALID_HANDLE_VALUE)
		{
			dwStatus = TSL_ERROR_MAP_CANT_OPEN_MAP_FILE;
		}
		else
		{
			DWORD dwBytesRead;

			if (!Read( &m_header, sizeof(m_header), &dwBytesRead))
				dwStatus = TSL_ERROR_MAP_BAD_HEAD_MAP_FILE;
		}

		if (dwStatus)
			m_dwStatus = dwStatus;
		else
			bInit = true;
	}

	return m_dwStatus;
}

// This function sets us back to a starting state, but has no effect on the mapping
//	file.  It should succeed unless we've encountered a "hard" error, which would indicate
//	a bug either in the code or in the mapping file.  Note that it wipes out the caching.
//	If you want ot leave caching intact, just call inherited method ClearStatus().
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.  returned value is either 0 or a _preexisting_ hard error we can't clear.
DWORD TSMapClient::ClearAll ()
{
	if (!HardMappingError(m_dwStatus))
	{
		ClearStatus();
		TSMapRuntimeAbstract::ClearAll();

		strcpy(m_szApp, szBogus);
		strcpy(m_appmap.szMapped, szBogus);
		strcpy(m_szVer, szBogus);
		strcpy(m_vermap.szMapped, szBogus);
		strcpy(m_szDevID, szBogus);
		m_uidDev = uidNil;
		strcpy(m_szDevClassGUID, szBogus);
		m_uidDevClass = uidNil;
		strcpy(m_szProb, szBogus);
		m_uidProb = uidNil;
	}

	return m_dwStatus;
}

// Get information about an application (input sztApp) from the mapping file into m_appmap
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.  
// RETURNS: 0 or TSL_ERROR_UNKNOWN_APP.
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetApp (const TCHAR * const sztApp)
{
	char szApp[BUFSIZE];
	bool bFound = false;

	ToSBCS (szApp, sztApp, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( strcmp(szApp, m_szApp) )
	{
		// it's not already in the cache; let's try to load it.
		int cmp = 1;		// in alpha order, it's still ahead
		DWORD dwPosition;
		bool bFirstTime = true;

		dwPosition = m_header.dwOffApp;

		while ( 
			!m_dwStatus 
		 && !bFound 
		 && dwPosition < m_header.dwLastOffApp
		 && ! (cmp < 0 && m_bAppAlphaOrder) )
		{
			if (ReadAppMap (m_appmap, dwPosition, bFirstTime) )
			{
				cmp = strcmp(szApp, m_appmap.szMapped);
				bFound = ( cmp == 0 );
			}

			bFirstTime = false;
		}

		if (bFound)
		{
			strcpy( m_szApp, szApp );
			// Different application invalidates the version
			strcpy( m_szVer, szBogus );
		}
		else
			m_dwStatus = TSL_ERROR_UNKNOWN_APP;
	}

	return m_dwStatus;
}

// Get information about a version (input sztVer) from the mapping file into m_vermap.
//	A version makes sense only in the context of an application. 
//	The null string is a valid input value and corresponds to leaving version blank.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSM_STAT_NEED_APP_TO_SET_VER
//	TSL_ERROR_UNKNOWN_VER
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetVer (const TCHAR * const sztVer)
{
	char szVer[BUFSIZE];
	bool bFound = false;

	ToSBCS (szVer, sztVer, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( !strcmp(m_szApp, szBogus) )
	{
		m_dwStatus = TSM_STAT_NEED_APP_TO_SET_VER;
		return m_dwStatus;
	}

	if (strcmp(m_szVer, szVer) )
	{
		// it's not already in the cache; let's try to load it.
		int cmp = 1;		// in alpha order, it's still ahead
		DWORD dwPosition;
		bool bFirstTime = true;

		dwPosition = m_appmap.dwOffVer;

		while ( 
			!m_dwStatus 
		 && !bFound 
		 && dwPosition < m_appmap.dwLastOffVer
		 && ! (cmp < 0 && m_bVerAlphaOrder) )
		{
			if (ReadVerMap (m_vermap, dwPosition, bFirstTime) )
			{
				cmp = strcmp(szVer, m_vermap.szMapped);
				bFound = ( cmp == 0 );
			}

			bFirstTime = false;
		}

		if (bFound)
			strcpy( m_szVer, szVer );
		else
			m_dwStatus = TSL_ERROR_UNKNOWN_VER;
	}

	return m_dwStatus;
}

// INPUT sztProb should be either a problem name or represent a number < 2**16.  In the
//	former case, we look up the UID in the mapping file.  In the latter
//	case, we just translate it to a number to get a problem UID.
//	The null string is a valid input value and corresponds to leaving version blank.  Only
//	makes sense if there is a device (or device class) specified before we try to launch.
// Sets m_uidProb, m_szProb
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_WARNING_UNKNOWN_APPPROBLEM - This is not necessarily bad, and results in setting
//		m_uidProb = uidNil
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetProb (const TCHAR * const sztProb)
{
	char szProb[BUFSIZE];
	bool bIsNumber = true;

	ToSBCS (szProb, sztProb, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	// Null string is not a number; any string with a non-digit in it is not a number
	if (szProb[0] == '\0')
		bIsNumber = false;
	else
	{
		int i = 0;
		while (szProb[i] != '\0')
			if (! isdigit(szProb[i]))
			{
				bIsNumber = false;
				break;
			}
			else
				i++;
	}

	if (bIsNumber)
		m_uidProb = atoi(szProb);
	else if ( strcmp(szProb, m_szProb) )
	{
		// it's not already in the cache; let's try to load it.
		m_uidProb = GetGenericMapToUID(sztProb, 
			m_header.dwOffProb, m_header.dwLastOffProb, m_bProbAlphaOrder);

		if (m_dwStatus == TSM_STAT_UID_NOT_FOUND)
			m_dwStatus = TSL_WARNING_UNKNOWN_APPPROBLEM;

		if (m_uidProb != uidNil)
			strcpy( m_szProb, szProb );
	}

	return m_dwStatus;
}

// Get information about a device (input sztDevID) from the mapping file into m_appmap.
//	The null string is a valid input value and corresponds to no specified device.
//	Except for Device Manager, this is typical usage.
// Sets m_uidDev, m_szDev
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_WARNING_BAD_DEV_ID -  This is not necessarily bad, and results in setting
//		m_uidDev = uidNil
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetDevID (const TCHAR * const sztDevID)
{
	char szDevID[BUFSIZE];

	ToSBCS (szDevID, sztDevID, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( strcmp(szDevID, m_szDevID) )
	{
		// it's not already in the cache; let's try to load it.
		m_uidDev = GetGenericMapToUID (sztDevID, 
			m_header.dwOffDevID, m_header.dwLastOffDevID, m_bDevIDAlphaOrder);

		if (m_dwStatus == TSM_STAT_UID_NOT_FOUND)
			m_dwStatus = TSL_WARNING_BAD_DEV_ID;

		if (m_uidDev != uidNil)
			strcpy( m_szDevID, szDevID );
	}

	return m_dwStatus;
}

// Get information about a device class (input sztDevClassGUID) from the mapping file 
//	into m_appmap.
//	The null string is a valid input value and corresponds to no specified device.
//	Except for Device Manager, this is typical usage.
// Sets m_uidDevClass, m_szDevClass
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_WARNING_BAD_CLASS_GUID - This is not necessarily bad, and results in setting
//		m_uidDevClass = uidNil
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetDevClassGUID (const TCHAR * const sztDevClassGUID)
{
	char szDevClassGUID[BUFSIZE];

	ToSBCS (szDevClassGUID, sztDevClassGUID, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( strcmp(szDevClassGUID, m_szDevClassGUID) )
	{
		// it's not already in the cache; let's try to load it.
		m_uidDevClass = GetGenericMapToUID (sztDevClassGUID, 
			m_header.dwOffDevClass, m_header.dwLastOffDevClass, m_bDevClassGUIDAlphaOrder);

		if (m_dwStatus == TSM_STAT_UID_NOT_FOUND)
			m_dwStatus = TSL_WARNING_BAD_CLASS_GUID;

		if (m_uidDevClass != uidNil)
			strcpy( m_szDevClassGUID, szDevClassGUID );
	}

	return m_dwStatus;
}

// Set troubleshooter (& possibly problem node) on the basis of application, version,
//	problem (ignoring device information).  This is achieved by a lookup in the mapping file
//	on the basis of previously set member values of this object.
// "TSBN" means "Troubleshooter Belief Network" 
// On INPUT, sztTSBN, sztNode must both point to buffers allowing BUFSIZE characters
// OUTPUT: *sztTSBN, *sztNode filled in.  If *sztNode is blank, that means launch to 
//	the problem page of the TSBN with no problem selected.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_ERROR_NO_NETWORK - Mapping failed
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::FromProbToTS (TCHAR * const sztTSBN, TCHAR * const sztNode )
{
	char szTSBN[BUFSIZE];
	char szNode[BUFSIZE];

	FromSBCS (sztTSBN, "", BUFSIZE);
	FromSBCS (sztNode, "", BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( m_uidProb == uidNil )
	{
		// Can't do this if m_uidProb is NIL
		m_dwStatus = TSL_ERROR_NO_NETWORK;
		return m_dwStatus;
	}

	DWORD dwPosition;
	bool bFirstTime = true;
	bool bFound = false;
	PROBMAP probmap;

	dwPosition = m_vermap.dwOffProbUID;

	while ( 
		!m_dwStatus 
	 && !bFound 
	 && dwPosition < m_vermap.dwLastOffProbUID )
	{
		if ( ReadProbMap (probmap, dwPosition, bFirstTime) )
		{
			bFound = ( probmap.uidProb == m_uidProb );
		}

		if (probmap.uidProb > m_uidProb)
			break; // we're past it.  No hit.

		bFirstTime = false;
	}

	if (bFound)
	{
		strcpy( szNode, probmap.szProblemNode );
		if (! ReadString (szTSBN, BUFSIZE, probmap.dwOffTSName, TRUE) )
		{
			m_dwStatus = TSL_ERROR_NO_NETWORK;
		}
	}
	else
		m_dwStatus = TSL_ERROR_NO_NETWORK;

	FromSBCS (sztTSBN, szTSBN, BUFSIZE);
	FromSBCS (sztNode, szNode, BUFSIZE);

	return m_dwStatus;
}

// Set troubleshooter (& possibly problem node) on the basis of application, version, device
//	and (optionally) problem.  This is achieved by a lookup in the mapping file on the basis 
//	of previously set member values of this object.
// "TSBN" means "Troubleshooter Belief Network" 
// On INPUT, sztTSBN, sztNode must both point to buffers allowing BUFSIZE characters
// OUTPUT: *sztTSBN, *sztNode filled in.  If *sztNode is blank, that means launch to 
//	the problem page of the TSBN with no problem selected.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_ERROR_NO_NETWORK - Mapping failed
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::FromDevToTS (TCHAR * const sztTSBN, TCHAR * const sztNode )
{
	char szTSBN[BUFSIZE];
	char szNode[BUFSIZE];

	FromSBCS (sztTSBN, "", BUFSIZE);
	FromSBCS (sztNode, "", BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( m_uidDev == uidNil )
	{
		// Can't do this if m_uidDev is NIL
		m_dwStatus = TSL_ERROR_NO_NETWORK;
		return m_dwStatus;
	}

	DWORD dwPosition;
	bool bFirstTime = true;
	bool bFoundDev = false;
	bool bFoundProb = false;
	DEVMAP devmap;

	dwPosition = m_vermap.dwOffDevUID;

	// Look in the version-specific list of device-mappings, till we find the right device.
	while ( 
		!m_dwStatus 
	 && !bFoundDev
	 && dwPosition < m_vermap.dwLastOffDevUID )
	{
		if ( ReadDevMap (devmap, dwPosition, bFirstTime) )
		{
			bFoundDev = ( devmap.uidDev == m_uidDev );
		}

		if (devmap.uidDev > m_uidDev)
			break; // we're past it.  No hit.

		bFirstTime = false;
	}

	if ( bFoundDev )
	{
		// The very first one might be the right problem, or we might have to scan through
		//	several mappings for this device before we get the right problem.
		bFoundProb = ( devmap.uidDev == m_uidDev && devmap.uidProb == m_uidProb );
		while ( 
			!m_dwStatus 
		 && !bFoundProb
		 && dwPosition < m_vermap.dwLastOffDevUID )
		{
			if ( ReadDevMap (devmap, dwPosition ) )
			{
				bFoundProb = ( devmap.uidDev == m_uidDev && devmap.uidProb == m_uidProb );
			}

			if ( devmap.uidDev > m_uidDev || devmap.uidProb > m_uidProb )
				break; // we're past it.  No hit.
		}
	}

	if (bFoundProb)
	{
		strcpy( szNode, devmap.szProblemNode );
		if (! ReadString (szTSBN, BUFSIZE, devmap.dwOffTSName, TRUE) )
		{
			m_dwStatus = TSL_ERROR_NO_NETWORK;
		}
	}
	else
		m_dwStatus = TSL_ERROR_NO_NETWORK;

	FromSBCS (sztTSBN, szTSBN, BUFSIZE);
	FromSBCS (sztNode, szNode, BUFSIZE);

	return m_dwStatus;
}

// Set troubleshooter (& possibly problem node) on the basis of application, version, device
//	class and (optionally) problem.  This is achieved by a lookup in the mapping file on 
//	the basis of previously set member values of this object.
// "TSBN" means "Troubleshooter Belief Network" 
// On INPUT, sztTSBN, sztNode must both point to buffers allowing BUFSIZE characters
// OUTPUT: *sztTSBN, *sztNode filled in.  If *sztNode is blank, that means launch to 
//	the problem page of the TSBN with no problem selected.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_ERROR_NO_NETWORK - Mapping failed
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
// >>> There is probably some way to share common code with FromDevToTS()
DWORD TSMapClient::FromDevClassToTS (TCHAR * const sztTSBN, TCHAR * const sztNode )
{
	char szTSBN[BUFSIZE];
	char szNode[BUFSIZE];

	FromSBCS (sztTSBN, "", BUFSIZE);
	FromSBCS (sztNode, "", BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

#ifdef KDEBUG
	char* szStart = "START\n";
	char* szEnd = "END\n";
	char sz[150];
	hDebugFile = CreateFile(
		(m_uidProb == uidNil) ? _T("k0debug.txt") : _T("k1debug.txt"),  
		GENERIC_WRITE, 
		FILE_SHARE_READ, 
		NULL, 
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	WriteFile( 
		hDebugFile, 
		szStart, 
		strlen(szStart),
		&dwBytesWritten,
		NULL);
	sprintf (sz, "look for DevClassUID %d, ProbUID %d\n", m_uidDevClass, m_uidProb);
	WriteFile( 
		hDebugFile, 
		sz, 
		strlen(sz),
		&dwBytesWritten,
		NULL);
#endif

	if ( m_uidDevClass == uidNil )
	{
		// Can't do this if m_uidDevClass is NIL
		m_dwStatus = TSL_ERROR_NO_NETWORK;
		return m_dwStatus;
	}

	DWORD dwPosition;
	bool bFirstTime = true;
	bool bFoundDevClass = false;
	bool bFoundProb = false;
	DEVCLASSMAP devclassmap;

	dwPosition = m_vermap.dwOffDevClassUID;

	// Look in the version-specific list of device-class-mappings, till we find the right device class.
	while ( 
		!m_dwStatus 
	 && !bFoundDevClass
	 && dwPosition < m_vermap.dwLastOffDevClassUID )
	{
		if ( ReadDevClassMap (devclassmap, dwPosition, bFirstTime) )
		{
			bFoundDevClass = ( devclassmap.uidDevClass == m_uidDevClass );
		}

		if (devclassmap.uidDevClass > m_uidDevClass)
			break; // we're past it.  No hit.

		bFirstTime = false;
	}

	if ( bFoundDevClass )
	{
#ifdef KDEBUG
	sprintf (sz, "found DevClassUID %d w/ ProbUID %d\n", m_uidDevClass, devclassmap.uidProb);
	WriteFile( 
		hDebugFile, 
		sz, 
		strlen(sz),
		&dwBytesWritten,
		NULL);
#endif
		// The very first one might be the right problem, or we might have to scan through
		//	several mappings for this device class before we get the right problem.
		bFoundProb = ( devclassmap.uidDevClass == m_uidDevClass && devclassmap.uidProb == m_uidProb );
		while ( 
			!m_dwStatus 
		 && !bFoundProb
		 && dwPosition < m_vermap.dwLastOffDevClassUID )
		{
			if ( ReadDevClassMap (devclassmap, dwPosition) )
			{
				bFoundProb = ( devclassmap.uidDevClass == m_uidDevClass && devclassmap.uidProb == m_uidProb );
			}

			if ( devclassmap.uidDevClass > m_uidDevClass || devclassmap.uidProb > m_uidProb )
				break; // we're past it.  No hit.

#ifdef KDEBUG
			sprintf (sz, "found DevClassUID %d w/ ProbUID %d\n", m_uidDevClass, devclassmap.uidProb);
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif

		}
	}

	if (bFoundProb)
	{
#ifdef KDEBUG
			sprintf (sz, "found right problem");
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif
		strcpy( szNode, devclassmap.szProblemNode );
		if (! ReadString (szTSBN, BUFSIZE, devclassmap.dwOffTSName, TRUE) )
		{
			m_dwStatus = TSL_ERROR_NO_NETWORK;
#ifdef KDEBUG
			sprintf (sz, ", but can't read its name\n");
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif
		}
		else
		{
#ifdef KDEBUG
			sprintf (sz, ": net [%s] node [%s]\n", szTSBN, szNode);
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif
		}
	}
	else
	{
		m_dwStatus = TSL_ERROR_NO_NETWORK;
#ifdef KDEBUG
		sprintf (sz, "No match");
		WriteFile( 
			hDebugFile, 
			sz, 
			strlen(sz),
			&dwBytesWritten,
			NULL);
#endif
	}

	FromSBCS (sztTSBN, szTSBN, BUFSIZE);
	FromSBCS (sztNode, szNode, BUFSIZE);

	return m_dwStatus;
#ifdef KDEBUG
	CloseHandle(hDebugFile);
	hDebugFile = INVALID_HANDLE_VALUE;
#endif
}

// To be used after we have failed to find a mapping for the currently selected version.
//	Each version can specify a version to try as a default, including the "blank" version,
//	which is distinct from "no version".
// The last version in a chain of defaults will "default" to uidNil: "no version".
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.  
// RETURNS:
//	0 - OK
//	TSL_WARNING_END_OF_VER_CHAIN - OK, but there's nothing to default to.
//	TSM_STAT_NEED_APP_TO_SET_VER
//	TSM_STAT_NEED_VER_TO_SET_VER - there was no version set, so no basis for a default
//	TSL_ERROR_UNKNOWN_VER
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::ApplyDefaultVer()
{
	bool bFound = false;

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( !strcmp(m_szApp, szBogus) )
	{
		m_dwStatus = TSM_STAT_NEED_APP_TO_SET_VER;
		return m_dwStatus;
	}

	if ( !strcmp(m_szVer, szBogus) )
	{
		m_dwStatus = TSM_STAT_NEED_VER_TO_SET_DEF_VER;
		return m_dwStatus;
	}
	
	DWORD dwPosition;
	bool bFirstTime = true;
	UID uidDefault = m_vermap.uidDefault;

	if (uidDefault == uidNil)
	{
		m_dwStatus =  TSL_WARNING_END_OF_VER_CHAIN;
		return m_dwStatus;
	}

	dwPosition = m_appmap.dwOffVer;

	while ( 
		!m_dwStatus 
	 && !bFound 
	 && dwPosition < m_appmap.dwLastOffVer )
	{
		if (ReadVerMap (m_vermap, dwPosition, bFirstTime) )
		{
			bFound = ( m_vermap.uid == uidDefault );
		}

		bFirstTime = false;
	}

	if (bFound)		
		strcpy( m_szVer, m_vermap.szMapped );
	else
		m_dwStatus = TSL_ERROR_UNKNOWN_VER;

	return m_dwStatus;
}

// Within a particular range of the mapping file, read UIDMAP records to try to map from 
//	input sztName to a UID.
// Return resulting UID, including possibly UidNil
// Sets m_dwStatus, which can be obtained via GetStatus(), inherited from the parent class.
// Can set m_dwStatus to:
//	0 - OK
//	TSM_STAT_UID_NOT_FOUND
// Can also set m_dwStatus to hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or may be left reflecting a preexisting hard error)
UID TSMapClient::GetGenericMapToUID (const TCHAR * const sztName, 
						DWORD dwOffFirst, DWORD dwOffLast,
						bool bAlphaOrder)
{
	char szName[BUFSIZE];
	DWORD dwPosition;
	UIDMAP uidmap;
	bool bFirstTime = true;
	bool bFound = false;

	ToSBCS (szName, sztName, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	dwPosition = dwOffFirst;

	while ( !m_dwStatus && !bFound && dwPosition < dwOffLast)
	{
		if (ReadUIDMap (uidmap, dwPosition, bFirstTime) )
		{
			int cmp = strcmp(szName, uidmap.szMapped);
			bFound = ( cmp == 0 );
			if ( cmp < 0 && bAlphaOrder )
				// relying here on alphabetical order; we've passed what we're looking for
				break;
		}
		else
		{
			m_dwStatus = TSM_STAT_UID_NOT_FOUND;
		}

		bFirstTime = false;
	}

	if (bFound)
		return uidmap.uid;
	else
	{
		m_dwStatus = TSM_STAT_UID_NOT_FOUND;
		return uidNil;
	}
}


// ------------------- utility functions ------------------------ 
// I/O, wrapped the way we are using it.

// SetFilePointerAbsolute sets map file to a location & returns that location if successful
//	returns -1 and sets m_dwStatus on failure
// Sets m_dwStatus, which can be obtained via GetStatus(), inherited from the parent class.
// Although, in theory, a bad seek just indicates a bad dwMoveTo value, in practice
//	a bad seek would indicate a serious problem either in the mapping file or in the calling
//	function: we should only be seeking to offsets which the contents of the mapping file
//	told us to seek to.
// RETURNS:
//	0 - OK
//	TSL_ERROR_MAP_BAD_SEEK
DWORD TSMapClient::SetFilePointerAbsolute( DWORD dwMoveTo )
{
	DWORD dwPosition = SetFilePointer(m_hMapFile, dwMoveTo, NULL, FILE_BEGIN);

	if( dwPosition != dwMoveTo)
	{
		// >>> could call GetLastError, but what do we do with it?
		m_dwStatus= TSL_ERROR_MAP_BAD_SEEK;
		dwPosition = -1;
	}

	return dwPosition;
}

// Low-level read n bytes.  Calls Win32 function ReadFile.
// Read from map file into lpBuffer
//	returns true if requested # of bytes are read
//	Returns false and sets m_dwStatus on failure
// Although, in theory, a bad read just indicates (for example) reading past EOF, in practice
//	a bad read would indicate a serious problem either in the mapping file or in the calling
//	function: we should only be reading (1) the header or (2) records which the contents of 
//	the mapping file told us to read.
// RETURNS:
//	0 - OK
//	TSL_ERROR_MAP_BAD_READ
//	TSL_ERROR_MAP_BAD_SEEK
bool TSMapClient::Read(LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpdwBytesRead)
{
	if (! ReadFile( m_hMapFile, lpBuffer, nNumberOfBytesToRead, lpdwBytesRead, NULL)
	|| *lpdwBytesRead != nNumberOfBytesToRead )
	{
		// >>> On ReadFile returning false, could call GetLastError, 
		//	but what do we do with it?
		m_dwStatus= TSL_ERROR_MAP_BAD_READ;
		return false;
	}
	return true;
}

// Read a single UIDMAP from the mapping file (maps text to a UID)
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT uidmap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadUIDMap (UIDMAP &uidmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &uidmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(uidmap.cb))+1, uidmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += uidmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single APPMAP from the mapping file (contains info about an application)
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT appmap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadAppMap (APPMAP &appmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &appmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(appmap.cb))+1, appmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += appmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single VERMAP from the mapping file (contains info about a version)
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadVerMap (VERMAP &vermap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &vermap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(vermap.cb))+1, vermap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += vermap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single PROBMAP from the mapping file (contains a mapping for use by FromProbToTS())
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadProbMap (PROBMAP &probmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &probmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(probmap.cb))+1, probmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += probmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single DEVMAP from the mapping file (contains a mapping for use by FromDevToTS())
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadDevMap (DEVMAP &devmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &devmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(devmap.cb))+1, devmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += devmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single DEVCLASSMAP from the mapping file (contains a mapping for use by 
//	FromDevClassToTS())
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadDevClassMap (DEVCLASSMAP &devclassmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &devclassmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(devclassmap.cb))+1, devclassmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += devclassmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Low-level read a null-terminated string.  Calls Win32 function ReadFile.
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// INPUT chMax is maximum # of bytes (not necessarily characters) to read.  The last character
//	will not actually be read: a null character will always be imposed.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
// Note that on completion the file position is unreliable.  It is based on the size of the 
//	buffer passed in, not the actual string.
bool TSMapClient::ReadString (char * sz, DWORD cbMax, DWORD &dwPosition, bool bSetPosition)
{
	DWORD dwBytesRead;



	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		if (cbMax == 0)
			return true;

		if ( cbMax == 1 || ReadFile( m_hMapFile, sz, cbMax-1, &dwBytesRead, NULL) )
		{
			sz[cbMax-1] = '\0';
			return true;
		}
	} 

	return false;
}

// Once one of these errors has occurred, we consider recovery impossible, except by closing
//	this object and opening a new one.
// Although, in theory, a bad seek or read just indicates bad arguments
//	to the relevant function, in practice a bad seek or read would indicate 
//	a serious problem either in the mapping file or in the calling
//	function: beyond the header, we should only be seeking to and reading 
//	from offsets which the contents of the mapping file old us to seek/read.
bool TSMapClient::HardMappingError (DWORD dwStatus)
{
	if (TSMapRuntimeAbstract::HardMappingError(dwStatus))
		return true;
	else
		switch (dwStatus)
		{
			case TSL_ERROR_MAP_BAD_SEEK:
			case TSL_ERROR_MAP_BAD_READ:
			case TSL_ERROR_MAP_CANT_OPEN_MAP_FILE:
			case TSL_ERROR_MAP_BAD_HEAD_MAP_FILE:
				return true;
			default:
				return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tsmapabstract.cpp ===
// 
// MODULE: TSMapAbstract.cpp
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Data types and abstract classes for mapping from the application's way of naming 
//			a problem to the Troubleshooter's way.
//			Implements the few concrete methods of abstract base class TSMapRuntimeAbstract.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////


#include "stdafx.h"
#include "TSLError.h"
#include "RSSTACK.H"
#include "TSMapAbstract.h"

TSMapRuntimeAbstract::TSMapRuntimeAbstract()
{
	m_dwStatus= 0;
}

TSMapRuntimeAbstract::~TSMapRuntimeAbstract()
{
}

DWORD TSMapRuntimeAbstract::ClearAll()
{
	m_stkStatus.RemoveAll();
	return 0;
}

// Given application, version, & problem, return troubleshooter & (optionally) problem node
// In order to succeed:
//	- application must be an application known in the mapping file
//	- version must be a known version of that application (including an empty string for
//		the "blank version"
//	- problem must be the name or number of a defined problem either for that application 
//		and version or for that application and some version down the chain of version 
//		defaults.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_WARNING_UNKNOWN_APPPROBLEM - couldn't find a UID for this problem, so we can't 
//		do this mapping
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
DWORD TSMapRuntimeAbstract::FromAppVerProbToTS (
	const TCHAR * const szApp, const TCHAR * const szVer, const TCHAR * const szProb, 
	TCHAR * const szTSBN, TCHAR * const szNode)
{
	if ( SetApp (szApp) == 0 && SetVer (szVer) == 0 && SetProb (szProb) == 0)
	{
		while ( FromProbToTS (szTSBN, szNode) == TSL_ERROR_NO_NETWORK
		&& ApplyDefaultVer() == 0 )
		{
			// do nothing; it's all in the while-condition
		}
	}

	return m_dwStatus;
}

// Given application, version, device ID & (optionally) problem, return troubleshooter 
//	& (independently optional) problem node 
// In order to succeed:
//	- application & version as in TSMapRuntimeAbstract::FromAppVerProbToTS
//	- the Device ID/Problem pair must be defined either for that application and version 
//		or for that application and some version down the chain of version defaults.
//		The szProb may be an empty string, meaning we want the mapping for this device and
//		no specified problem.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_WARNING_UNKNOWN_APPPROBLEM - couldn't find a UID for this problem, so we can't 
//		do this mapping.  Note that there if there are any defined mappings independent of
//		problem, there will be a UID for the null string as a problem name.  That will 
//		not yield a warning.  That's just dandy.
//	TSL_WARNING_BAD_DEV_ID - couldn't find a UID for this device, so we can't 
//			do this mapping 
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
DWORD TSMapRuntimeAbstract::FromAppVerDevIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode)
{
	if ( SetApp (szApp) == 0 && SetVer (szVer) == 0 
	&& SetDevID (szDevID) == 0 && SetProb (szProb) == 0 )
	{
		while ( FromDevToTS (szTSBN, szNode) == TSL_ERROR_NO_NETWORK
		&& ApplyDefaultVer() == 0 )
		{
			// do nothing; it's all in the while-condition
		}
	}

	return m_dwStatus;
}

// Given application, version, Device Class GUID & (optionally) problem, return troubleshooter 
//	& (independently optional) problem node 
// In order to succeed:
//	- application & version as in TSMapRuntimeAbstract::FromAppVerProbToTS
//	- the Device Class GUID/Problem pair must be defined either for that application and version 
//		or for that application and some version down the chain of version defaults.
//		The szProb may be an empty string, meaning we want the mapping for this device and
//		no specified problem.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_WARNING_UNKNOWN_APPPROBLEM - couldn't find a UID for this problem, so we can't 
//		do this mapping.  Note that there if there are any defined mappings independent of
//		problem, there will be a UID for the null string as a problem name.  That will 
//		not yield a warning.  That's just dandy.
//	TSL_WARNING_BAD_CLASS_GUID - couldn't find a UID for this Device Class GUID, so we can't 
//			do this mapping 
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
DWORD TSMapRuntimeAbstract::FromAppVerDevClassGUIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevClassGUID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode)
{
	if ( SetApp (szApp) == 0 && SetVer (szVer) == 0 
	&& SetDevClassGUID (szDevClassGUID) == 0 && SetProb (szProb) == 0 )
	{
		while ( FromDevClassToTS (szTSBN, szNode) == TSL_ERROR_NO_NETWORK
		&& ApplyDefaultVer() == 0 )
		{
			// do nothing; it's all in the while-condition
		}
	}

	return m_dwStatus;
}

// Given application, version, & at least one of
//	- problem
//	- device ID
//	- device class GUID
//	return troubleshooter & (optionally) problem node
// In order to succeed:
//	- application must be an application known in the mapping file
//	- version must be a known version of that application (including an empty string for
//		the "blank version"
//	- There must be a mapping defined either for this problem, device ID, or device class 
//		GUID alone, or for the combination of the problem & either the device ID or the
//		device class GUID, in conjunction with either that application and version 
//		or for that application and some version down the chain of version defaults.
// If there is more than one possible match, the algorithm dictates the following 
//	priorities:
//	  If there is an szProblem :
//		1. szProblem with no associated device information (the "standard" mapping) 
//		2. szProblem and szDeviceID
//		3. szProblem and pguidClass
//		4. szDeviceID with no associated problem
//		5. pguidClass with no associated problem
//	  Otherwise
//		1. szDeviceID with no associated problem
//		2. pguidClass with no associated problem
//	  Within each of these groupings, we follow up version defaults before we try the 
//		next grouping.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
// In the case where we return 0 (OK) or TSL_ERROR_NO_NETWORK, the caller will want to consult
//	MoreStatus() for more detailed errors/warnings.  In the other cases, the returned status
//	overwhelms any possible interest in other errors/warnings.
DWORD TSMapRuntimeAbstract::FromAppVerDevAndClassToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szDevClassGUID, 
		const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode)
{
	UID uidProb = uidNil;

	// keep some status info around so we don't ever notify of the same problem twice
	bool bBadProb = false;
	bool bCantUseProb = false;
	bool bBadDev = false;
	bool bBadDevClass = false;

	if (! HardMappingError (m_dwStatus) )
		ClearAll();

	if (! m_dwStatus)
	{
		if (szProb && *szProb)
		{
			// try problem name without device info.
			m_dwStatus = FromAppVerProbToTS (szApp, szVer, szProb, szTSBN, szNode);
			bBadProb = (m_dwStatus == TSL_WARNING_UNKNOWN_APPPROBLEM);

			if (DifferentMappingCouldWork (m_dwStatus))
			{
				// try the device ID + problem
				m_dwStatus = FromAppVerDevIDToTS (szApp, szVer, szDevID, szProb, 
													szTSBN, szNode);
				bBadDev = (m_dwStatus == TSL_WARNING_BAD_DEV_ID);
			}

			if (DifferentMappingCouldWork (m_dwStatus))
			{
				// try the device class GUID + problem
				m_dwStatus = FromAppVerDevClassGUIDToTS (szApp, szVer, szDevClassGUID, szProb, 
													szTSBN, szNode);
				bBadDevClass = (m_dwStatus == TSL_WARNING_BAD_CLASS_GUID);
			}

			// If we're still trying to map it, we couldn't make use of the problem name
			bCantUseProb = (DifferentMappingCouldWork(m_dwStatus));
		}
		else
			m_dwStatus = TSL_ERROR_NO_NETWORK;

		if (DifferentMappingCouldWork (m_dwStatus))
		{
			// try the device ID alone
			m_dwStatus = FromAppVerDevIDToTS (szApp, szVer, szDevID, NULL, szTSBN, szNode);
			bBadDev |= (m_dwStatus == TSL_WARNING_BAD_DEV_ID);
		}

		if (DifferentMappingCouldWork (m_dwStatus))
		{
			// try the device class GUID alone
			m_dwStatus = FromAppVerDevClassGUIDToTS (szApp, szVer, szDevClassGUID, NULL, 
												szTSBN, szNode);
			bBadDevClass |= (m_dwStatus == TSL_WARNING_BAD_CLASS_GUID);
		}

		if (DifferentMappingCouldWork(m_dwStatus))
			m_dwStatus = TSL_ERROR_NO_NETWORK;

	}

	if (bBadProb 
	&& AddMoreStatus(TSL_WARNING_UNKNOWN_APPPROBLEM) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	if (bCantUseProb && !bBadProb
	&& AddMoreStatus(TSL_WARNING_UNUSED_APPPROBLEM) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	if (bBadDev 
	&& AddMoreStatus(TSL_WARNING_BAD_DEV_ID) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	if (bBadDevClass
	&& AddMoreStatus(TSL_WARNING_BAD_CLASS_GUID) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	return m_dwStatus;
}

// certain statuses are "basically healthy" returns, meaning, "no, this particular mapping
//	doesn't exist, but there's nothing here to rule out the possibility of another mapping."
//	Those return true on this function.  
//	Note that dwStatus == 0 (OK) returns false because
//	if we already had a successful mapping, we don't want to try another.
bool TSMapRuntimeAbstract::DifferentMappingCouldWork (DWORD dwStatus)
{
	switch (dwStatus)
	{
		case TSL_ERROR_NO_NETWORK:
		case TSL_WARNING_BAD_DEV_ID:
		case TSL_WARNING_BAD_CLASS_GUID:
		case TSL_WARNING_UNKNOWN_APPPROBLEM:
		case TSM_STAT_UID_NOT_FOUND:
		case TSL_WARNING_END_OF_VER_CHAIN:
			return true;
		default:
			return false;
	}
}

bool TSMapRuntimeAbstract::HardMappingError (DWORD dwStatus)
{
	return (dwStatus == TSL_ERROR_OUT_OF_MEMORY);
}

// Add this status to the list of warnings.
// Normally returns 0, but can theoretically return TSL_ERROR_OUT_OF_MEMORY
inline DWORD TSMapRuntimeAbstract::AddMoreStatus(DWORD dwStatus)
{
	if (m_stkStatus.Push(dwStatus) == -1)
		return TSL_ERROR_OUT_OF_MEMORY;
	else
		return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "stdafx.h"

//jps 09/02/97 - Removed ATL wizard includes
//#ifdef _ATL_STATIC_REGISTRY
//#include <statreg.h>
//#include <statreg.cpp>
//#endif

#ifdef MSINFO_DEBUG_HACK
int	g_HackFindMe	= 0;
#endif // DEBUG_HACK

#include <atlimpl.cpp>

const CLSID CLSID_MSInfo = {0x45ac8c63,0x23e2,0x11d1,{0xa6,0x96,0x00,0xc0,0x4f,0xd5,0x8b,0xc3}};
const CLSID CLSID_About = {0x45ac8c65,0x23e2,0x11d1,{0xa6,0x96,0x00,0xc0,0x4f,0xd5,0x8b,0xc3}};
const CLSID CLSID_Extension = {0x45ac8c64,0x23e2,0x11d1,{0xa6,0x96,0x00,0xc0,0x4f,0xd5,0x8b,0xc3}};

LPCTSTR		cszClsidMSInfoSnapin	= _T("{45ac8c63-23e2-11d1-a696-00c04fd58bc3}");
LPCTSTR		cszClsidAboutMSInfo		= _T("{45ac8c65-23e2-11d1-a696-00c04fd58bc3}");
//	CHECK: Use the same value?
LPCTSTR		cszClsidMSInfoExtension	= _T("{45ac8c64-23e2-11d1-a696-00c04fd58bc3}");
#include "ndmgr_i.c"

// Static NodeType GUID in numeric & string formats.
const GUID	cNodeTypeStatic		= {0x45ac8c66,0x23e2,0x11d1,{0xA6,0x96,0x00,0xC0,0x4F,0xD5,0x8b,0xc3}};
LPCTSTR		cszNodeTypeStatic	= _T("{45ac8c66-23e2-11d1-a696-00c04fd58bc3}");

//	CHECK:	Will we use these?
// Dynamicaly created objects.
const GUID	cNodeTypeDynamic	= {0x0ac69b7a,0xafce,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
LPCTSTR		cszNodeTypeDynamic	= _T("{0ac69b7a-afce-11d0-a79b-00c04fd8d565}");

//
// OBJECT TYPE for result items.
//

//	Result items object type GUID in numeric & string formats.
const GUID	cObjectTypeResultItem	= {0x00c86e52,0xaf90,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
LPCTSTR		cszObjectTypeResultItem = _T("{00c86e52-af90-11d0-a79b-00c04fd8d565}");

//	Program Files 
LPCTSTR		cszWindowsCurrentKey	= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
LPCTSTR		cszCommonFilesValue		= _T("CommonFilesDir");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//
// Copyright (c) 1998-1999 Microsoft Corporation

#if !defined(MSINFO_STDAFX_H)
#define MSINFO_STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#include <afxwin.h>
#include <afxdisp.h>

//	jps 09/02/97 - This will be 0x0500.
//	#define _WIN32_WINNT 0x0400

//	jps 09/02/97 - The sample doesn't define this
//  #define _ATL_APARTMENT_THREADED


#include <atlbase.h>

#ifndef ATL_NO_NAMESPACE
using namespace ATL;
#endif

//	MMC requires unicode DLL's.
#ifndef _UNICODE
#define _UNICODE
#endif

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "consts.h"

//-----------------------------------------------------------------------------
// This class is used to encapsulate the instrumentation for the snap-in. We
// make this a class so a single instance can be created, and the file closed
// during the destructor.
//-----------------------------------------------------------------------------

class CMSInfoLog
{
public:
	enum { BASIC = 0x01, TOOL = 0x02, MENU = 0x04, CATEGORY = 0x08, WMI = 0x10 };

public:
	CMSInfoLog();
	~CMSInfoLog();

	BOOL IsLogging() { return m_fLoggingEnabled; };
	BOOL IsLogging(int iFlag) { return (m_fLoggingEnabled && ((iFlag & m_iLoggingMask) != 0)); };
	BOOL WriteLog(int iType, const CString & strMessage, BOOL fContinuation = FALSE);
	BOOL WriteLog(int iType, const CString & strFormat, const CString & strReplace1);
	
private:
	BOOL OpenLogFile();
	void ReadLoggingStatus();
	BOOL WriteLogInternal(const CString & strMessage);
	void WriteSpaces(DWORD dwCount);

private:
	CFile *	m_pLogFile;
	CString	m_strFilename;
	BOOL	m_fLoggingEnabled;
	int		m_iLoggingMask;
	DWORD	m_dwMaxFileSize;
	CString m_strEndMarker;
	BOOL	m_fTimestamp;
};

extern CMSInfoLog msiLog;

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
        TRACE(_T("Release called on NULL interface ptr\n")); 
    }
}

#define OLESTR_FROM_CSTRING(cstr)	\
	(T2OLE(const_cast<LPTSTR>((LPCTSTR)(cstr))))
#define WSTR_FROM_CSTRING(cstr)		\
	(const_cast<LPWSTR>(T2CW(cstr)))


#ifdef _DEBUG
//#define MSINFO_DEBUG_HACK
#endif // _DEBUG

// Taken from the Example Snap-in.
// Debug instance counter
#ifdef _DEBUG
	inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
	{
		char buf[100];
		wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
		::MessageBoxA(NULL, buf, "MSInfo Snapin: Memory Leak!!!", MB_OK);
	}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#ifdef MSINFO_DEBUG_HACK
	extern int g_HackFindMe;
	//	Temporary fix.
#undef ASSERT
#define ASSERT(f) \
	do \
	{ \
	if (!(g_HackFindMe && (f)) && AfxAssertFailedLine(THIS_FILE, __LINE__)) \
		g_HackFindMe = 1;	\
		AfxDebugBreak(); \
	} while (0)

#endif // DEBUG_HACK

#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif

	//		Unicode definitions
#ifdef _UNICODE
#define atoi(lpTStr)	_wtoi(lpTStr)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(MSINFO_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\consts.h ===
//	Consts.h	
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#ifndef MSINFO_CONSTS_H
#define MSINFO_CONSTS_H

extern const CLSID		CLSID_MSInfo;		// In-Proc server GUID
extern const CLSID		CLSID_About;
extern const CLSID		CLSID_Extension;	// In-Proc server GUID
extern const CLSID		CLSID_SystemInfo;

extern LPCTSTR			cszClsidMSInfoSnapin;
extern LPCTSTR			cszClsidAboutMSInfo;
extern LPCTSTR			cszClsidMSInfoExtension;

extern LPCTSTR			cszWindowsCurrentKey;
extern LPCTSTR			cszCommonFilesValue;

// Static NodeType GUID in numeric & string formats.
extern const GUID		cNodeTypeStatic;
extern LPCTSTR			cszNodeTypeStatic;

// Dynamicaly created objects.
extern const GUID		cNodeTypeDynamic;
extern LPCTSTR			cszNodeTypeDynamic;

// Result items object type GUID in numeric & string formats.
extern const GUID		cObjectTypeResultItem;
extern LPCTSTR			cszObjectTypeResultItem;

//	Prototypes required so that the linker munges the names properly.
extern const IID IID_IComponentData;
extern const IID IID_IConsole;
extern const IID IID_IConsoleNameSpace;
extern const IID IID_IComponent;
extern const IID IID_IEnumTASK;
extern const IID IID_IExtendContextMenu;
extern const IID IID_IExtendControlbar;
extern const IID IID_IExtendPropertySheet;
extern const IID IID_IExtendTaskPad;
extern const IID IID_IHeaderCtrl;
extern const IID IID_IResultData;
extern const IID IID_IResultDataCompare;
extern const IID IID_IResultOwnerData;
extern const IID IID_ISnapinAbout;
extern const IID IID_ISystemInfo;

extern const IID LIBID_MSINFOSNAPINLib;

// Clipboard format strings.
#define	CF_MACHINE_NAME			_T("MMC_SNAPIN_MACHINE_NAME")
#define CF_INTERNAL_OBJECT		_T("MSINFO_DATA_OBJECT")

//		This is the saved console file which contains the directory to try to
//		find MSInfo in, if for some reason we can't find find our key in the
//		registry.
extern LPCTSTR		cszDefaultDirectory;
//		The root registry key where we should find our data.
extern LPCTSTR		cszRegistryRoot;
//		The key which stores the Directory where we can find our saved console.
extern LPCTSTR		cszDirectoryKey;
//		The root name for our internal data structure.
extern LPCTSTR		cszRootName;
//		Constants for the access function.
enum	AccessConstants { A_EXIST = 0x00, A_WRITE = 0x02, A_READ = 0x04 };

#endif	// MSINFO_CONSTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tsmapclient.h ===
// 
// MODULE: TSMapClient.cpp
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Class TSMapClient is available at runtime for mapping from the application's 
//			way of naming a problem to the Troubleshooter's way.
//			Only a single thread should operate on any one object of class TSMapClient.  The object is not
//			threadsafe.
//			In addition to the overtly noted returns, many methods can return a preexisting error.
//			However, if the calling program has wishes to ignore an error and continue, we 
//			recommend an explicit call to inherited method ClearStatus().
//			Note that the mapping file is always strictly SBCS (Single Byte Character Set), but the
//			calls into this code may use Unicode. This file consequently mixes char and TCHAR.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////

#ifndef _TSMAPCLIENT_
#define _TSMAPCLIENT_ 1

// ----------------- TSMapClient ---------------
// Class providing mapping methods which will be available
//	at runtime when launching a troubleshooter.
class TSMapClient: public TSMapRuntimeAbstract {
public:
	TSMapClient(const TCHAR * const sztMapFile);
	~TSMapClient();
	DWORD Initialize();

private:
	// redefined inherited methods
	DWORD ClearAll ();
	DWORD SetApp (const TCHAR * const sztApp);
	DWORD SetVer (const TCHAR * const sztVer);
	DWORD SetProb (const TCHAR * const sztProb);
	DWORD SetDevID (const TCHAR * const sztDevID);
	DWORD SetDevClassGUID (const TCHAR * const sztDevClassGUID);
	DWORD FromProbToTS (TCHAR * const sztTSBN, TCHAR * const sztNode );
	DWORD FromDevToTS (TCHAR * const sztTSBN, TCHAR * const sztNode );
	DWORD FromDevClassToTS (TCHAR * const sztTSBN, TCHAR * const sztNode );
	DWORD ApplyDefaultVer();
	bool HardMappingError (DWORD dwStatus);

	UID GetGenericMapToUID (const TCHAR * const sztName, DWORD dwOffFirst, DWORD dwOffLast,
						bool bAlphaOrder);
	DWORD SetFilePointerAbsolute( DWORD dwMoveTo );
	bool Read(LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead);
	bool ReadUIDMap (UIDMAP &uidmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadAppMap (APPMAP &appmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadVerMap (VERMAP &vermap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadProbMap (PROBMAP &probmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadDevMap (DEVMAP &devmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadDevClassMap (DEVCLASSMAP &devclassmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadString (char * sz, DWORD cbMax, DWORD &dwPosition, bool bSetPosition);

private:
	TCHAR m_sztMapFile[BUFSIZE];	// pathname of file from which to draw mappings
	HANDLE m_hMapFile;			// corresponding handle
	TSMAPFILEHEADER m_header;	// header portion of map file

	// If we satisf ourselves that the SQL Server database used in preparing the mapping file
	//	will produce the collating order we want, we could gain some runtime efficiency
	//	by setting the following true: when we are reading through a file for a match, we
	//	could bail if we got past it.
	bool m_bAppAlphaOrder;
	bool m_bVerAlphaOrder;
	bool m_bDevIDAlphaOrder;
	bool m_bDevClassGUIDAlphaOrder;
	bool m_bProbAlphaOrder;

	// NOTE: because the mapping file is strictly SBCS, so are the cache values.  Typically,
	//	this requires conversion between these values and Unicode arguments to methods.

	// Cache info about selected app.  This lets us know (for example) at what offset
	//	to start a search for relevant versions.
	char m_szApp[BUFSIZE];
	APPMAP m_appmap;

	// Cache info about selected version.  This lets us know (for example) at what offset
	//	to start a search for relevant mappings to troubleshooting belief networks.
	char m_szVer[BUFSIZE];
	VERMAP m_vermap;

	// Cache info about selected device (just name & UID)
	char m_szDevID[BUFSIZE];
	UID m_uidDev;

	// Cache info about selected device class (just name -- a string representing a GUID --
	//	& UID)
	char m_szDevClassGUID[BUFSIZE];
	UID m_uidDevClass;

	// Cache info about selected problem (just name & UID)
	char m_szProb[BUFSIZE];
	UID m_uidProb;

};

#endif // _TSMAPCLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\launcher\server\tsmapabstract.h ===
// 
// MODULE: TSMapAbstract.h
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Data types and abstract classes for mapping from the application's way of naming 
//			a problem to the Troubleshooter's way.
//			Implements the few concrete methods of abstract base class TSMapRuntimeAbstract.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////

#ifndef _TSMAPABSTRACT_
#define _TSMAPABSTRACT_ 1

typedef DWORD UID;
const UID uidNil = -1;

// Abstract Base Class providing a minimal set of mapping methods which will be available
//	at runtime when launching a troubleshooter.
class TSMapRuntimeAbstract {
public:
	TSMapRuntimeAbstract();
	virtual ~TSMapRuntimeAbstract() = 0;

private:
	// High level mappings to troubleshooting networks.
	DWORD FromAppVerProbToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);
	DWORD FromAppVerDevIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);
	DWORD FromAppVerDevClassGUIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevClassGUID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);
public:
	DWORD FromAppVerDevAndClassToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szDevClassGUID, 
		const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);

	// current status 
	DWORD GetStatus() {return m_dwStatus;};
	void ClearStatus() {m_dwStatus = 0;};

	// other statuses reported back by FromAppVerDevAndClassToTS()
	// Call this in a loop until it returns 0;
	inline DWORD MoreStatus()
	{
		if (m_stkStatus.Empty())
			return 0;
		else
			return (m_stkStatus.Pop());
	}
protected:
	// normally returns 0, but can theoretically return TSL_ERROR_OUT_OF_MEMORY
	DWORD AddMoreStatus(DWORD dwStatus);

private:
	bool DifferentMappingCouldWork(DWORD dwStatus);
protected:
	// "Part 1": call these to set query.  Notes here are for the benefit of implementor
	//	of inherited class. -------------------------

	// Any non-zero return of ClearAll is a hard error, means this object cannot be used.
	virtual DWORD ClearAll ();

	// SetApp may return only 
	//	0 (OK) 
	//	TSL_ERROR_UNKNOWN_APP.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetApp (const TCHAR * const szApp)= 0;

	// SetVer may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_APP_TO_SET_VER  - must have successful call to SetApp before calling SetVer
	//	TSL_ERROR_UNKNOWN_VER
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetVer (const TCHAR * const szVer)= 0;

	// SetProb may return only 
	//	0 (OK)
	//	TSM_STAT_UID_NOT_FOUND.  This is not necessarily bad, and results in setting
	//		problem to uidNil. Calling fn must know if that's acceptable.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetProb (const TCHAR * const szProb)= 0;

	// SetDevID may return only 
	//	0 (OK)
	//	TSM_STAT_UID_NOT_FOUND.  This is not necessarily bad, and results in setting
	//		(P&P) device to uidNil. Calling fn must know if that's acceptable.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetDevID (const TCHAR * const szDevID)= 0;

	// SetDevClassGUID may return only 
	//	0 (OK)
	//	TSM_STAT_UID_NOT_FOUND.  This is not necessarily bad, and results in setting
	//		device class to uidNil. Calling fn must know if that's acceptable.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetDevClassGUID (const TCHAR * const szDevClassGUID)= 0;

	// "Part 2": Low level mappings to troubleshooting networks ------------

	// FromProbToTS may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_PROB_TO_SET_TS - Nil problem, so we can't do this mapping.
	//	TSL_ERROR_NO_NETWORK - Mapping failed
	//	hard error specific to the implementation of the concrete class
	virtual DWORD FromProbToTS (TCHAR * const szTSBN, TCHAR * const szNode )= 0;

	// FromDevToTS may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_DEV_TO_SET_TS - Nil device, so we can't do this mapping.
	//	TSL_ERROR_NO_NETWORK - Mapping failed
	//	hard error specific to the implementation of the concrete class
	virtual DWORD FromDevToTS (TCHAR * const szTSBN, TCHAR * const szNode )= 0;

	// FromDevClassToTS may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_DEVCLASS_TO_SET_TS - Nil device class, so we can't do this mapping.
	//	TSL_ERROR_NO_NETWORK - Mapping failed
	//	hard error specific to the implementation of the concrete class
	virtual DWORD FromDevClassToTS (TCHAR * const szTSBN, TCHAR * const szNode )= 0;

	// other functions -----------------------

	// ApplyDefaultVer may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_APP_TO_SET_VER - must have successful call to SetApp before calling 
	//									ApplyDefaultVer
	//	TSM_STAT_NEED_VER_TO_SET_VER - must have successful call to SetVer before calling 
	//									ApplyDefaultVer
	//	TSL_ERROR_UNKNOWN_VER - the version we are mapping _from_ is undefined.  This
	//									would mean a real coding mess someplace.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD ApplyDefaultVer() = 0;

	// HardMappingError returns true on errors considered "hard" by the concrete class.
	virtual bool HardMappingError (DWORD dwStatus);

protected:
	DWORD m_dwStatus;
	RSStack<DWORD> m_stkStatus;	// Status and Error codes that happened during mapping.

};

#endif // _TSMAPABSTRACT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubexe\msinfo32_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 09 14:08:57 2000
 */
/* Compiler settings for E:\inet\sysinfo\control\msinfo32.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMSInfo = {0x2A930152,0xAE13,0x4659,{0xA0,0x11,0x36,0x37,0x7D,0x5F,0xC4,0x38}};


const IID LIBID_MSINFO32Lib = {0x7AC18319,0x0739,0x4377,{0x89,0x84,0x84,0x85,0x73,0xD5,0x19,0xA5}};


const CLSID CLSID_MSInfo = {0x273380E8,0x1438,0x4B2C,{0x95,0xB0,0x71,0x32,0x84,0xFB,0xC3,0x02}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubexe\stubexe.h ===
//	StubExe.h	- Define the class for 
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afxwin.h>

extern const CLSID		CLSID_SystemInfo;
extern const IID		IID_ISystemInfo;

class CMSInfoApp : public CWinApp {
	BOOL	InitInstance();
	BOOL	RunMSInfoInHelpCtr();
};

CMSInfoApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubexe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by InfoStub.rc
//
// Copyright (c) 1998-2000 Microsoft Corporation

#define IDS_FILENOTFOUND                1
#define IDS_CANTACCESS                  2
#define IDS_UNKNOWN                     3
#define IDS_NOEXECUTABLE                4
#define IDS_DESCRIPTION                 5
#define IDS_MEMORY                      6
#define IDS_UNEXPECTED                  7
#define IDS_NOMSCFILE                   8
#define IDS_USAGE                       9
#define IDD_MSICMDLINE                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubmsd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by InfoStub.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation

#define IDS_FILENOTFOUND                1
#define IDS_CANTACCESS                  2
#define IDS_UNKNOWN                     3
#define IDS_NOEXECUTABLE                4
#define IDS_DESCRIPTION                 5
#define IDS_MEMORY                      6
#define IDS_UNEXPECTED                  7
#define IDS_NOMSCFILE                   8
#define IDS_NOMSINFO32					9
#define IDS_COMMONFILES_SUBPATH         10
#define IDS_MSINFO_PATH                 11
#define IDS_MSDNOTE			12

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__23D1AE2C_8023_11D3_8D47_00C04F949D33__INCLUDED_)
#define AFX_DLLDATAX_H__23D1AE2C_8023_11D3_8D47_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__23D1AE2C_8023_11D3_8D47_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "PPServer_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubmsd\stubmsd.cpp ===
// This file was originally stubexe.cpp (written by a-jsari), and was copied
// to create stubmsd.cpp to generate an identical stub program for winmsd.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afx.h>
#include <afxwin.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include <iostream.h>
#include "StdAfx.h"
#include "Resource.h"

#include "stubmsd.h"

#ifndef HRESULT
typedef long HRESULT;
#endif

//	For Windows 95, the maximum length of a command line is 1024 characters.
//	Not sure what it is for NT.
const int MAX_COMMAND_LINE	= 1024;

LPCTSTR		cszDefaultDirectory = _T("\\Microsoft Shared\\MSInfo\\");

LPCTSTR		cszRegistryRoot = _T("Software\\Microsoft\\Shared Tools\\MSInfo");
LPCTSTR		cszDirectoryKey = _T("Path");

LPCTSTR		cszWindowsRoot = _T("Software\\Microsoft\\Windows\\CurrentVersion");
LPCTSTR		cszCommonFilesKey = _T("CommonFilesDir");

CException *g_pException = NULL;

//		Microsoft Management Console is the program that hosts MSInfo.
//		This is a definition so that we can take its size.
#define		cszProgram	_T("mmc.exe")

/*
 * ThrowErrorException -
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
inline void ThrowErrorException()
{
	::g_pException = new CException;
	if (::g_pException == NULL) ::AfxThrowMemoryException();
	throw ::g_pException;
}

/* 
 * CSystemExecutable - The class that implements finding and running an
 *		executable.
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
class CSystemExecutable {
public:
	CSystemExecutable(LPTSTR szProgram);
	~CSystemExecutable() { DeleteStrings(); }
	void	Run();
	void	Find();
	void	ProcessCommandLine();

	//	Helper methods.
protected:

	void	DeleteStrings();
	void	FindFileOnSystem(CString &szFileName, CString &szDestination);

	//	Instance variables.
protected:
	CString		*m_pszPath;
	CString		*m_pszProgramName;
	CString		*m_pszCommandLine;
};

/*
 * CMSInfoExecutable - MSInfo-specific functions.
 *
 * History: a-jsari		10/15/97		Initial version
 */
class CMSInfoExecutable : public CSystemExecutable {
public:
	CMSInfoExecutable(LPTSTR szProgram);
	~CMSInfoExecutable() {}

	BOOL	ProcessCommandLine();

private:
	void	DeleteStrings();
	void	FindMSInfoEXE();

	//	Instance variables
private:
	static const LPCTSTR	cszMSInfo32;
};

const LPCTSTR CMSInfoExecutable::cszMSInfo32	 = _T("msinfo32.exe");

/*
 * CExecutable - Constructor which determines the type of the executable to
 *		be executed.
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
CSystemExecutable::CSystemExecutable(LPTSTR szProgram)
:m_pszProgramName(new CString), m_pszPath(new CString), m_pszCommandLine(new CString)
{
	if (!(m_pszProgramName && m_pszPath && m_pszCommandLine)) AfxThrowMemoryException();
	*m_pszProgramName = szProgram;
}

/*
 * DeleteStrings - Delete all of the strings used by the object.  Used to free
 *		our memory before calling exec.
 *
 * History: a-jsari		10/15/97		Initial version
 */
void CSystemExecutable::DeleteStrings()
{
	delete m_pszPath;
	m_pszPath = NULL;
	delete m_pszProgramName;
	m_pszProgramName = NULL;
	delete m_pszCommandLine;
	m_pszCommandLine = NULL;
}

/*
 * FindFileOnSystem - We may eventually put code here to test multiple
 *		found copies and use the right one.  But probably not.
 *
 * History:	a-jsari		10/15/97		Stub version
 */
void CSystemExecutable::FindFileOnSystem(CString &szFileName,
		CString &szDestination)
{
	//	Not reached.
	CFileFind		FileFinder;
	BOOL			bFindResult;

	bFindResult = FileFinder.FindFile(szFileName);
	if (!bFindResult) ThrowErrorException();
	szDestination = FileFinder.GetFilePath();
#if 0
	//	Choose among all versions of the file?
	while (bFindResult) {
		FileFinder.FindNextFile();
	}
#endif
}

/* 
 * Find - Return a pointer to a string containing the full path
 *		to the MMC executable.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
void CSystemExecutable::Find()
{
// We no longer call mmc, we instead call msinfo32.exe so that
// winmsd appears to support all the same command line options
// whatever they may be.
#ifdef BUILD_MMC_COMMAND_LINE 

	UINT		uReturnSize;
	TCHAR		szSystemDirectory[MAX_PATH + 1];

	uReturnSize = GetSystemDirectory(szSystemDirectory, MAX_PATH);
	if (uReturnSize == 0) ThrowErrorException();
	if (uReturnSize > MAX_PATH) {
		//	Our buffer isn't big enough.  This code will never get called.
		AfxThrowResourceException();
	}
	*m_pszPath += szSystemDirectory;
	*m_pszPath += _T("\\") + *m_pszProgramName;
	if (_taccess(*m_pszPath, A_READ) < 0) {
		//	These may eventually want to be distinct exceptions.
		if (errno == ENOENT) {
			ThrowErrorException();
		} else {
			ASSERT(errno == EACCES);
			ThrowErrorException();
		}
	}

#endif

}

/*
 * Run - Call exec with the parameters we so meticulously collected.
 *
 * History:	a-jsari		10/15/97		Initial version.
 */
void CSystemExecutable::Run()
{
#if !defined(UNICODE)
	TCHAR	szPath[MAX_PATH + 1];
	TCHAR	szProgramName[MAX_PATH + 1];
	TCHAR	szCommandLine[MAX_COMMAND_LINE + 1];

	_tcsncpy(szPath, (LPCTSTR)*m_pszPath, sizeof(szPath)/sizeof(TCHAR));
	_tcsncpy(szProgramName, (LPCTSTR)*m_pszProgramName, sizeof(szProgramName)/sizeof(TCHAR));
	_tcsncpy(szCommandLine, (LPCTSTR)*m_pszCommandLine, sizeof(szCommandLine)/sizeof(TCHAR));
	DeleteStrings();
	::_execlp(szPath, szProgramName, szCommandLine, 0);
	ThrowErrorException();
#else
	char	szPath[MAX_PATH + 1];
	char	szProgramName[MAX_PATH + 1];
	char	szCommandLine[MAX_COMMAND_LINE + 1];

	wcstombs(szPath, (LPCTSTR) *m_pszPath, MAX_PATH);
	wcstombs(szProgramName, (LPCTSTR) *m_pszProgramName, MAX_PATH);
	wcstombs(szCommandLine, (LPCTSTR) *m_pszCommandLine, MAX_COMMAND_LINE);

	DeleteStrings();
	::_execlp(szPath, szProgramName, szCommandLine, 0);
	ThrowErrorException();
#endif
}

/*
 * ProcessCommandLine - Pass all command line parameters to the called
 *		executable.
 *
 * History: a-jsari		10/14/97		Initial version
 */
void CSystemExecutable::ProcessCommandLine()
{
	*m_pszCommandLine = GetCommandLine();
	
	//	Skip over the first element in the line, which is the path to
	//	the current executable.  Preserve everything else.
	const int	FIND_NO_MATCH = -1;
	int			wIndex;

	m_pszCommandLine->TrimLeft();
	wIndex = m_pszCommandLine->FindOneOf(_T("\" \t\n"));
	if ((*m_pszCommandLine)[wIndex] == '"') {
		//	This is the primary, if not guaranteed method.
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
		wIndex = m_pszCommandLine->Find('"');
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
	} else if (wIndex == FIND_NO_MATCH) {
		*m_pszCommandLine = _T("");
	} else {
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
	}
}

/*
 * CMSInfoExecutable - Just pass all parameters to the base constructor.
 *
 * History: a-jsari		10/15/97		Initial version
 */
CMSInfoExecutable::CMSInfoExecutable(LPTSTR szProgram)
:CSystemExecutable(szProgram)
{
}

/*
 * ProcessCommandLine - Process the command line parameters we can handle; pass on
 *		the ones we can't, adding the saved console file.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
BOOL CMSInfoExecutable::ProcessCommandLine()
{
	// If the user specifies the "/?" switch on the winmsd.exe command line,
	// we need to inform the user that msinfo32.exe is the preferred way to
	// view the information now.

	CString strCommandLine = GetCommandLine();
	if (strCommandLine.Find(_T("/?")) != -1 && IDNO == ::AfxMessageBox(IDS_MSDNOTE, MB_YESNO))
		return FALSE;

	// builds m_pszCommandLine
	CSystemExecutable::ProcessCommandLine();

	FindMSInfoEXE();
	return TRUE;
}

//-----------------------------------------------------------------------------
// Locate the msinfo32.exe file. We'll look in the following places:
//
// 1.  In the current directory.
// 2.  In the directory in the registry under:
//	   HKLM\Software\Microsoft\Shared Tools\MSInfo\Path
// 3a. In the directory %CommonFilesDir%\Microsoft Shared\MSInfo, where 
//	   %CommonFilesDir% is found in 
//	   HKLM\Software\Microsoft\Windows\CurrentVersion\CommonFilesDir.
// 3b. Use the %CommonFilesDir% value with a subpath loaded from a
//     string resource.
// 4.  Last ditch is to look in a directory stored as a string resource
//	   for this file.
//-----------------------------------------------------------------------------

void CMSInfoExecutable::FindMSInfoEXE()
{
	m_pszPath->Empty();

	// First, check the current directory.

	if (::_taccess(_T("msinfo32.exe"), A_READ) == 0) 
	{
		*m_pszPath = _T("msinfo32.exe");
		return;
	}

	// Second, use the path key in the MSInfo registry key.

	HKEY hkey;
	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_READ, &hkey))
	{
		DWORD dwType;
		TCHAR szDirectory[MAX_PATH + 1];
		DWORD dwKeyLength = MAX_PATH * sizeof(TCHAR);

		if (ERROR_SUCCESS == ::RegQueryValueEx(hkey, _T("path"), 0, &dwType, (BYTE *) szDirectory, &dwKeyLength))
			if (::_taccess(szDirectory, A_READ) == 0)
			{
				*m_pszPath = szDirectory;
				RegCloseKey(hkey);
				return;
			}

		RegCloseKey(hkey);
	}

	// Third, look for it in the %CommonFilesDir% directory. Look both in the hardcoded
	// subdirectory, and in a subdirectory loaded from a string resource.

	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion"), 0, KEY_READ, &hkey))
	{
		DWORD dwKeyLength = MAX_PATH * sizeof(TCHAR);
		DWORD dwType;
		TCHAR szDirectory[MAX_PATH + 1];

		if (ERROR_SUCCESS == ::RegQueryValueEx(hkey, _T("CommonFilesDir"), 0, &dwType, (BYTE *) szDirectory, &dwKeyLength))
		{
			CString strTestPath(szDirectory);
			strTestPath += _T("\\Microsoft Shared\\MSInfo\\msinfo32.exe");
			if (::_taccess(strTestPath, A_READ) == 0)
			{
				*m_pszPath = strTestPath;
				RegCloseKey(hkey);
				return;
			}

			if (strTestPath.LoadString(IDS_COMMONFILES_SUBPATH))
			{
				strTestPath = CString(szDirectory) + strTestPath;
				if (::_taccess(strTestPath, A_READ) == 0)
				{
					*m_pszPath = strTestPath;
					RegCloseKey(hkey);
					return;
				}
			}
		}

		RegCloseKey(hkey);
	}

	// Finally, look for it using the string resource.

	CString strTestPath;
	if (strTestPath.LoadString(IDS_MSINFO_PATH))
	{
		TCHAR szExpandedPath[MAX_PATH];
		if (::ExpandEnvironmentStrings(strTestPath, szExpandedPath, MAX_PATH))
			if (::_taccess(szExpandedPath, A_READ) == 0)
			{
				*m_pszPath = szExpandedPath;
				return;
			}
	}

	CString	szNoMSCFile;
	szNoMSCFile.LoadString(IDS_NOMSCFILE);
	::AfxMessageBox(szNoMSCFile);
	::ThrowErrorException();
}


/*
 * main - The main entry point for the stub executable.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
BOOL CMSInfoApp::InitInstance()
{
	CString		szResText;
	CString		szResTitle;

//	Shouldn't need this.

	do {
		try {
			//	FIX:	Pre-load the memory resource in case memory problems develop.

			CMSInfoExecutable		exeMSInfo(cszProgram);

			exeMSInfo.Find();
			if (exeMSInfo.ProcessCommandLine())
				exeMSInfo.Run();
			//	We never get past this on successful completion.
		}
		catch (CMemoryException *e_Mem) {
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			VERIFY(szResText.LoadString(IDS_MEMORY));
			VERIFY(szResTitle.LoadString(IDS_DESCRIPTION));
			if (::MessageBox(NULL, szResText, szResTitle, MB_RETRYCANCEL | MB_ICONERROR) == IDCANCEL)
				break;
			continue;
		}
		catch (CException *e_Generic) {
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			VERIFY(szResText.LoadString(IDS_UNEXPECTED));
			::MessageBox(NULL, szResText, szResTitle, MB_OK | MB_ICONERROR);
			delete ::g_pException;
			break;
		}
		catch (...) {
			ASSERT(FALSE);
			break;
		}
		break;
	} while (TRUE);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubmsd\stubmsd.h ===
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afxwin.h>

class CMSInfoApp : public CWinApp {
	BOOL	InitInstance();
};

CMSInfoApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\msinfo\stubexe\stubexe.cpp ===
//	stubexe.cpp		A command line program which runs the appropriate version
//		of MSInfo, based on the registry settings
//
// History:	a-jsari		10/13/97
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afx.h>
#include <afxwin.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include "StdAfx.h"
#include "Resource.h"
#include "StubExe.h"

BOOL CMSInfoApp::InitInstance()
{
	if (!RunMSInfoInHelpCtr())
	{
		CDialog help(IDD_MSICMDLINE);
		help.DoModal();
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Required to use the new MSInfo DLL in HelpCtr.
//-----------------------------------------------------------------------------

typedef class MSInfo MSInfo;

EXTERN_C const IID IID_IMSInfo;

struct IMSInfo : public IDispatch
{
public:
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
        /* [in] */ VARIANT_BOOL vbool) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
        /* [in] */ OLE_COLOR clr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
        /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackStyle( 
        /* [in] */ long style) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackStyle( 
        /* [retval][out] */ long __RPC_FAR *pstyle) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
        /* [in] */ OLE_COLOR clr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
        /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
        /* [in] */ long style) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
        /* [retval][out] */ long __RPC_FAR *pstyle) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderWidth( 
        /* [in] */ long width) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderWidth( 
        /* [retval][out] */ long __RPC_FAR *width) = 0;
    
    virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Font( 
        /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
        /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
        /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
        /* [in] */ OLE_COLOR clr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
        /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
        /* [retval][out] */ long __RPC_FAR *phwnd) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderVisible( 
        /* [in] */ VARIANT_BOOL vbool) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderVisible( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
        /* [in] */ short appearance) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
        /* [retval][out] */ short __RPC_FAR *pappearance) = 0;
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetHistoryStream( 
        IStream __RPC_FAR *pStream) = 0;
    
    virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DCO_IUnknown( 
        /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pVal) = 0;
    
    virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DCO_IUnknown( 
        /* [in] */ IUnknown __RPC_FAR *newVal) = 0;
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveFile( 
        BSTR filename,
        BSTR computer,
        BSTR category) = 0;
    
};

#include "msinfo32_i.c"

//-----------------------------------------------------------------------------
// This function encapsulates the functionality to run the new MSInfo in
// HelpCtr. If this function returns false, the help should be displayed.
//-----------------------------------------------------------------------------

void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith);
BOOL CMSInfoApp::RunMSInfoInHelpCtr()
{
	//-------------------------------------------------------------------------
	// Parse the command line parameters into one big string to pass to the
	// ActiveX control. There are a few which would keep us from launching
	// HelpCtr.
	//-------------------------------------------------------------------------

	CString		strCommandLine(CWinApp::m_lpCmdLine);

	CString		strLastFlag;
	CString		strCategory;
	CString		strCategories;
	CString		strComputer;
	CString		strOpenFile;
	CString		strPrintFile;
	CString		strSilentNFO;
	CString		strSilentExport;
	CString		strTemp;
	BOOL		fShowPCH = FALSE;
	BOOL		fShowHelp = FALSE;
	BOOL		fShowCategories = FALSE;

	CString strFileFlag(_T("msinfo_file"));
	// treating a commandline that comes from the shell as a special case.
	// I'm assuming that the case of the shell flag will not vary
	// and no other paramters will be packaged on the command line, so everything to the right of 
	// msinfo_file will be the filename, which main contain spaces and multiple .'s
	// for XPServer bug: 609844	NFO file corrupt from Server 3615

	if (strCommandLine.Find(strFileFlag) > 0)
	{
		strOpenFile = strCommandLine.Right(strCommandLine.GetLength() - strFileFlag.GetLength() - 2);
	}
	else while (!strCommandLine.IsEmpty())
	{
		// Remove the leading whitespace from the string.
		
		strTemp = strCommandLine.SpanIncluding(_T(" \t=:"));
		strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strTemp.GetLength());

		// If the first character is a / or a -, then this is a flag.

		if (strCommandLine[0] == _T('/') || strCommandLine[0] == _T('-'))
		{
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - 1);
			strLastFlag = strCommandLine.SpanExcluding(_T(" \t=:"));
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strLastFlag.GetLength());
			strLastFlag.MakeLower();

			if (strLastFlag == CString(_T("pch")))
			{
				fShowPCH = TRUE;
				strLastFlag.Empty();
			}
			else if (strLastFlag == CString(_T("?")) || strLastFlag == CString(_T("h")))
			{
				fShowHelp = TRUE;
				strLastFlag.Empty();
			}
			else if (strLastFlag == CString(_T("showcategories")))
			{
				fShowCategories = TRUE;
				strLastFlag.Empty();
			}

			continue;
		}

		// Otherwise, this is either a filename to open, or a parameter from the
		// previous command line flag. This might have quotes around it.

		if (strCommandLine[0] != _T('"'))
		{
			strTemp = strCommandLine.SpanExcluding(_T(" \t"));
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strTemp.GetLength());
		}
		else
		{
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - 1);
			strTemp = strCommandLine.SpanExcluding(_T("\""));
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strTemp.GetLength() - 1);
		}

		if (strLastFlag.IsEmpty() || strLastFlag == CString(_T("msinfo_file")))
			strOpenFile = strTemp;
		else if (strLastFlag == CString(_T("p")))
			strPrintFile = strTemp;
		else if (strLastFlag == CString(_T("category")))
			strCategory = strTemp;
		else if (strLastFlag == CString(_T("categories")))
			strCategories = strTemp;
		else if (strLastFlag == CString(_T("computer")))
			strComputer = strTemp;
		else if (strLastFlag == CString(_T("report")))
			strSilentExport = strTemp;
		else if (strLastFlag == CString(_T("nfo")) || strLastFlag == CString(_T("s")))
			strSilentNFO = strTemp;

		strLastFlag.Empty();
	}

	if (fShowHelp)
		return FALSE;

	TCHAR szCurrent[MAX_PATH];
	GetCurrentDirectory(MAX_PATH, szCurrent);
	CString strCurrent(szCurrent);
	if (strCurrent.Right(1) != CString(_T("\\")))
		strCurrent += CString(_T("\\"));

	HRESULT hrInitialize = CoInitialize(NULL);

	if (!strSilentNFO.IsEmpty() || !strSilentExport.IsEmpty())
	{
		IMSInfo * pMSInfo = NULL;

		if (SUCCEEDED(CoCreateInstance(CLSID_MSInfo, NULL, CLSCTX_ALL, IID_IMSInfo, (void **)&pMSInfo)) && pMSInfo != NULL)
		{
			BSTR computer = strComputer.AllocSysString();
			BSTR category = strCategories.AllocSysString();

			if (!strSilentNFO.IsEmpty())
			{
				if (strSilentNFO.Find(_T('\\')) == -1)
					strSilentNFO = strCurrent + strSilentNFO;

				if (strSilentNFO.Right(4).CompareNoCase(CString(_T(".nfo"))) != 0)
					strSilentNFO += CString(_T(".nfo"));

				BSTR filename = strSilentNFO.AllocSysString();
				pMSInfo->SaveFile(filename, computer, category);
				SysFreeString(filename);
			}

			if (!strSilentExport.IsEmpty())
			{
				if (strSilentExport.Find(_T('\\')) == -1)
					strSilentExport = strCurrent + strSilentExport;

				BSTR filename = strSilentExport.AllocSysString();
				pMSInfo->SaveFile(filename, computer, category);
				SysFreeString(filename);
			}

			SysFreeString(computer);
			SysFreeString(category);
			pMSInfo->Release();
		}

		if (SUCCEEDED(hrInitialize))
			CoUninitialize();

		return TRUE;
	}

	CString strURLParam;

	if (fShowPCH)
		strURLParam += _T("pch");

	if (fShowCategories)
		strURLParam += _T(",showcategories");

	if (!strComputer.IsEmpty())
		strURLParam += _T(",computer=") + strComputer;

	if (!strCategory.IsEmpty())
		strURLParam += _T(",category=") + strCategory;

	if (!strCategories.IsEmpty())
		strURLParam += _T(",categories=") + strCategories;

	if (!strPrintFile.IsEmpty())
	{
		if (strPrintFile.Find(_T('\\')) == -1)
			strPrintFile = strCurrent + strPrintFile;

		strURLParam += _T(",print=") + strPrintFile;
	}

	if (!strOpenFile.IsEmpty())
	{
		if (strOpenFile.Find(_T('\\')) == -1)
			strOpenFile = strCurrent + strOpenFile;
		
		strURLParam += _T(",open=") + strOpenFile;
	}

	if (!strURLParam.IsEmpty())
	{
		strURLParam.TrimLeft(_T(","));
		strURLParam = CString(_T("?")) + strURLParam;
	}

	CString strURLAddress(_T("hcp://system/sysinfo/msinfo.htm"));
	CString strURL = strURLAddress + strURLParam;

	//-------------------------------------------------------------------------
	// Check to see if we can run MSInfo in HelpCtr. We need the HTM file
	// to be present.
	//-------------------------------------------------------------------------

	BOOL fRunVersion6 = TRUE;

	TCHAR szPath[MAX_PATH];
	if (ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\system\\sysinfo\\msinfo.htm"), szPath, MAX_PATH))
	{
		WIN32_FIND_DATA finddata;
		HANDLE			h = FindFirstFile(szPath, &finddata);

		if (INVALID_HANDLE_VALUE != h)
			FindClose(h);
		else
			fRunVersion6 = FALSE;
	}

	// This would be used to check if the control is registered. Turns out we want to run anyway.
	//
	// IUnknown * pUnknown;
	// if (fRunVersion6 && SUCCEEDED(CoCreateInstance(CLSID_MSInfo, NULL, CLSCTX_ALL, IID_IUnknown, (void **) &pUnknown)))
	//		pUnknown->Release();
	// else
	//		fRunVersion6 = FALSE;

	StringReplace(strURL, _T(" "), _T("%20"));

	if (fRunVersion6)
	{
		// HelpCtr now supports running MSInfo in its own window. We need to
		// execute the following:
		//
		//		helpctr -mode hcp://system/sysinfo/msinfo.xml
		//
		// Additionally, we can pass parameters in the URL using the
		// following flag:
		//
		//		-url hcp://system/sysinfo/msinfo.htm?open=c:\savedfile.nfo
		//
		// First, find out of the XML file is present.

		BOOL fXMLPresent = TRUE;
		if (ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\system\\sysinfo\\msinfo.xml"), szPath, MAX_PATH))
		{
			WIN32_FIND_DATA finddata;
			HANDLE			h = FindFirstFile(szPath, &finddata);

			if (INVALID_HANDLE_VALUE != h)
				FindClose(h);
			else
				fXMLPresent = FALSE;
		}

		// If the XML file is present and we can get the path for helpctr.exe, we
		// should launch it the new way.

		TCHAR szHelpCtrPath[MAX_PATH];
		if (fXMLPresent && ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\binaries\\helpctr.exe"), szHelpCtrPath, MAX_PATH))
		{
			CString strParams(_T("-mode hcp://system/sysinfo/msinfo.xml"));
			if (!strURLParam.IsEmpty())
				strParams += CString(_T(" -url ")) + strURL;

			ShellExecute(NULL, NULL, szHelpCtrPath, strParams, NULL, SW_SHOWNORMAL);
		}
		else
			ShellExecute(NULL, NULL, strURL, NULL, NULL, SW_SHOWNORMAL);
	}
	else
		ShellExecute(NULL, NULL, _T("hcp://system"), NULL, NULL, SW_SHOWNORMAL);

	if (SUCCEEDED(hrInitialize))
		CoUninitialize();

	return TRUE;
}

//-----------------------------------------------------------------------------
// This was used originally to replace some MFC functionality not in the ME
// build tree.
//-----------------------------------------------------------------------------

void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith)
{
	CString strWorking(str);
	CString strReturn;
	CString strLookFor(szLookFor);
	CString strReplaceWith(szReplaceWith);

	int iLookFor = strLookFor.GetLength();
	int iNext;

	while (!strWorking.IsEmpty())
	{
		iNext = strWorking.Find(strLookFor);
		if (iNext == -1)
		{
			strReturn += strWorking;
			strWorking.Empty();
		}
		else
		{
			strReturn += strWorking.Left(iNext);
			strReturn += strReplaceWith;
			strWorking = strWorking.Right(strWorking.GetLength() - (iNext + iLookFor));
		}
	}

	str = strReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PPServer.rc
//
#define IDS_PROJNAME                    100
#define IDR_PPSERVERCLASS               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__23D1AE24_8023_11D3_8D47_00C04F949D33__INCLUDED_)
#define AFX_STDAFX_H__23D1AE24_8023_11D3_8D47_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__23D1AE24_8023_11D3_8D47_00C04F949D33__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__26D19E4C_819E_11D3_8D49_00C04F949D33__INCLUDED_)
#define AFX_DLLDATAX_H__26D19E4C_819E_11D3_8D49_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__26D19E4C_819E_11D3_8D49_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\ppserverclass.h ===
// PPServerClass.h : Declaration of the CPPServerClass

#ifndef __PPSERVERCLASS_H_
#define __PPSERVERCLASS_H_

#include "resource.h"       // main symbols

#include <atlctl.h>

#include <vector>
using namespace std;


/////////////////////////////////////////////////////////////////////////////
// CPPServerClass
class ATL_NO_VTABLE CPPServerClass : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPPServerClass, &CLSID_PPServerClass>,
	public IDispatchImpl<IPPServerClass, &IID_IPPServerClass, &LIBID_PPSERVERLib>,
	public IObjectSafetyImpl<CPPServerClass, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CPPServerClass()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PPSERVERCLASS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPPServerClass)
	COM_INTERFACE_ENTRY(IPPServerClass)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// IPPServerClass
public:
	STDMETHOD(AllowAutomaticSniffing)(/*[out, retval]*/ VARIANT * pvarShow);

protected:
	
	bool Create(HKEY hKeyParent, LPCTSTR strKeyName, bool* bCreatedNew, REGSAM access =KEY_ALL_ACCESS);
	bool SetNumericValue(LPCTSTR strValueName, DWORD dwValue);
	bool GetNumericValue(LPCTSTR strValueName, DWORD& dwValue);
	void Close();
	
private:
	// Data
	HKEY m_hKey;				   // current key handle
	vector<HKEY> m_arrKeysToClose; // array of keys(subkeys) opened by the object
};

#endif //__PPSERVERCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\ppserver.cpp ===
// PPServer.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for PPServer.idl by adding the following 
//      files to the Outputs.
//          PPServer_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f PPServerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "PPServer.h"
#include "dlldatax.h"

#include "PPServer_i.c"
#include "PPServerClass.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PPServerClass, CPPServerClass)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_PPSERVERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SStub.rc
//
#define IDS_PROJNAME                    100
#define IDR_SNIFFSTUB                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sniffpol\ppserverclass.cpp ===
// PPServerClass.cpp : Implementation of CPPServerClass
#include "stdafx.h"
#include "PPServer.h"
#include "PPServerClass.h"

/////////////////////////////////////////////////////////////////////////////
// Keys
#define REG_LOCAL_TS_LOC		_T("SOFTWARE\\Microsoft")
#define REG_LOCAL_TS_PROGRAM	_T("TShoot")
// Values ///////////////////////////////////////////////////////////////////
#define SNIFF_AUTOMATIC_STR		_T("AutomaticSniffing")
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPPServerClass

bool CPPServerClass::Create(HKEY hKeyParent, LPCTSTR strKeyName, bool* bCreatedNew, REGSAM access)
{
	HKEY hRetKey = NULL;
	DWORD dwDisposition = 0;

	long nWinError = ::RegCreateKeyEx(
		hKeyParent,
		strKeyName,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		access,
		NULL,
		&hRetKey,
		&dwDisposition
		);

	if(nWinError == ERROR_SUCCESS)
	{
		m_hKey = hRetKey;
		*bCreatedNew = dwDisposition == REG_CREATED_NEW_KEY ? true : false;
		
		try
		{
			m_arrKeysToClose.push_back(hRetKey);
		}
		catch (exception&)
		{
			return false;
		}

		return true;
	}
	return false;
}

bool CPPServerClass::SetNumericValue(LPCTSTR strValueName, DWORD dwValue)
{
	BYTE* pData = (BYTE*)&dwValue;
	long nWinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_DWORD,
		pData,
		sizeof(DWORD)
		);

	if (nWinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CPPServerClass::GetNumericValue(LPCTSTR strValueName, DWORD& dwValue)
{
	DWORD tmp = 0;
	BYTE* pData = (BYTE*)&tmp;
	DWORD type = 0;
	DWORD size = sizeof(DWORD);

	long nWinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (type != REG_DWORD)
		return false;

	if (nWinError == ERROR_SUCCESS)
	{
		dwValue = tmp;
		return true;
	}
	return false;
}

void CPPServerClass::Close()
{
	for (vector<HKEY>::reverse_iterator i = m_arrKeysToClose.rbegin(); i != m_arrKeysToClose.rend(); i++)
		::RegCloseKey( *i );

	m_arrKeysToClose.clear();
}

STDMETHODIMP CPPServerClass::AllowAutomaticSniffing(VARIANT *pvarShow)
{

	bool was_created = false;
	DWORD dwAllowSniffing = 1;

	// [BC - 20010302] - Changed regsitry access level from WRITE to QUERY and READ. Write access
	// not allowed for certain user accts, such as WinXP built in guest acct. Write access should
	// not be required by this component.
	if (Create(HKEY_LOCAL_MACHINE, REG_LOCAL_TS_LOC, &was_created, KEY_QUERY_VALUE))
	{
		if (Create(m_hKey, REG_LOCAL_TS_PROGRAM, &was_created, KEY_READ))
		{
			// this call can be not successfull, if there is no such value.
			//  BUT we do not set this value,
			//  we leave dwAllowSniffing as initialized ("1")
			// This approach will comply the "Sniffing version 3.2.doc" statement,
			//  that if "AutomaticSniffing" value is missed, we treat it as set to "1"
			GetNumericValue(SNIFF_AUTOMATIC_STR, dwAllowSniffing);
		}
	}

	Close();

	::VariantInit(pvarShow);
	V_VT(pvarShow) = VT_I4;

	if (dwAllowSniffing == 1)
		pvarShow->lVal = 1;
	else
		pvarShow->lVal = 0;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "SStub_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\sniffstub.cpp ===
// SniffStub.cpp : Implementation of CSniffStub
#include "stdafx.h"
#include "SStub.h"
#include "SniffStub.h"

/////////////////////////////////////////////////////////////////////////////
// CSniffStub


STDMETHODIMP CSniffStub::Sniff(BSTR strNodeName, BSTR strLaunchBasis, BSTR strAdditionalArgs, VARIANT *nState)
{
	::VariantInit(nState);

	V_VT(nState) = VT_I4;
	nState->lVal = -1;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\sniffstub.h ===
// SniffStub.h : Declaration of the CSniffStub

#ifndef __SNIFFSTUB_H_
#define __SNIFFSTUB_H_

#include "resource.h"       // main symbols

#include <atlctl.h>

/////////////////////////////////////////////////////////////////////////////
// CSniffStub
class ATL_NO_VTABLE CSniffStub : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSniffStub, &CLSID_SniffStub>,
	public IDispatchImpl<ISniffStub, &IID_ISniffStub, &LIBID_SSTUBLib>,
	public IObjectSafetyImpl<CSniffStub, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CSniffStub()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SNIFFSTUB)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSniffStub)
	COM_INTERFACE_ENTRY(ISniffStub)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ISniffStub
public:
	STDMETHOD(Sniff)(/*[in]*/ BSTR strNodeName, /*[in]*/ BSTR strLaunchBasis, /*[in]*/ BSTR strAdditionalArgs, /*[out, retval]*/ VARIANT* nState);
};

#endif //__SNIFFSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__26D19E44_819E_11D3_8D49_00C04F949D33__INCLUDED_)
#define AFX_STDAFX_H__26D19E44_819E_11D3_8D49_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__26D19E44_819E_11D3_8D49_00C04F949D33__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsassert.h ===
#ifndef __APGTSASSERT_H_
#define __APGTSASSERT_H_

#ifdef _DEBUG
#define ASSERT(f) \
	do \
	{ \
	if (!(f)) \
		DebugBreak(); \
	} while (0) 
#else
#define ASSERT(f)
#endif //_DEBUG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\sstub\sstub.cpp ===
// SStub.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for SStub.idl by adding the following 
//      files to the Outputs.
//          SStub_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f SStubps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SStub.h"
#include "dlldatax.h"

#include "SStub_i.c"
#include "SniffStub.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SniffStub, CSniffStub)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SSTUBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgts.h ===
//
// MODULE: APGTS.H
//
// PURPOSE: Main header file for DLL
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-24-98		JM		Major revision, use STL.
//

#ifndef __APGTS_H_
#define __APGTS_H_ 1

#include <windows.h>

extern HANDLE ghModule;


///////////////////////////////////////////////////////////////////////////////
// Simple macros used to eliminate unnecessarily conditionally compiled code hopefully
// in a readable fashion.
#ifdef LOCAL_TROUBLESHOOTER
#define RUNNING_LOCAL_TS()	true
#define RUNNING_ONLINE_TS()	false
#else
#define RUNNING_LOCAL_TS()	false
#define RUNNING_ONLINE_TS()	true
#endif
///////////////////////////////////////////////////////////////////////////////

// Standard symbolic names for standard (implicit) nodes 
#define NODE_PROBLEM_ASK	_T("ProblemAsk")	// When we're posted a request, the second
										// field is ProblemAsk=<problem node symbolic name>
										// changed from "TShootProblem" 10/31/97 JM
#define NODE_LIBRARY_ASK	_T("asklibrary")	// When we're started from the Launcher,
										// name field is "asklibrary", and value is empty string
#define NODE_SERVICE		_T("Service")
#define NODE_FAIL			_T("Fail")
#define NODE_BYE			_T("Bye")
#define NODE_IMPOSSIBLE		_T("Impossible")
#define NODE_FAILALLCAUSESNORMAL _T("FailAllCausesNormal")

// Field names for HTTP request.  These are on the HTML <FORM>
#define C_TYPE			_T("type")			// pre version 3.0 normal request, now deprecated
											// First argument:
											//	type=<TS topic name>
											// Second argument:
											//	<IDH of Problem Page>=<IDH of Selected Problem>
											// or
											//	ProblemAsk=<IDH of Selected Problem>
											// Succeeding arguments may be:
											//	<number (IDH)>=<number (state)>
											// or
											//	<symbolic node name>=<number (state)>

#define C_FIRST			_T("first")			// Display "first" page (status page), which
											//	also provides access to all troubleshooting
											//	topics.
											// No further expected inputs here

#define C_FURTHER_GLOBAL	 _T("GlobalStatus")

#define C_THREAD_OVERVIEW	 _T("ThreadStatus")

#define C_TOPIC_STATUS	     _T("TopicStatus")

#define C_PRELOAD		_T("preload")		// pre version 3.0 integration with a sniffer,
											//	now deprecated
											// same inputs as C_TYPE
											// Only difference is that this means to 
											//  go looking to see if a cause is already
											//	established.

#define C_TOPIC			_T("topic")			// version 3.0 normal request
											// First argument:
											//	topic=<TS topic name>
											// Second argument:
											//	ProblemAsk=<NID or name of Selected Problem>
											// Succeeding arguments:
											//	<symbolic node name>=<number (state)>

#define C_TEMPLATE		_T("template")		// version 3.0 enhancement to permit the
											// the use of an arbitrary HTI file to be
											// used with an arbitrary DSC file.

#define C_PWD			_T("pwd")

#define C_TOPIC_AND_PROBLEM	_T("TopicAndProblem")	// version 3.x (not yet used in V3.0),
											// allows specification of topic & problem by 
											// a single radio button.  This enables an HTML
											// page seamlessly to put problems from multiple
											// topics in a single form.
											// First argument:
											//	TopicAndProblem=<TS topic name>,<NID or name of Selected Problem>
											//	The comma in the line above is a literal comma, e.g.
											//	TopicAndProblem=mem,OutOfMemory
											// Succeeding arguments:
											//	<symbolic node name>=<number (state)>

// Symbols from HTTP query
#define C_COOKIETAG		_T("CK_")		// V3.2 enhancement to support cookies passed in
										// via a GET or a POST.
#define C_SNIFFTAG		_T("SNIFFED_")	// V3.2 enhancement to allow indication of a
										// sniffed state for a particular node (independent
										// of its current state).
#define C_LAST_SNIFFED_MANUALLY	\
			_T("LAST_SNIFFED_MANUALLY")	// To identify that last node was sniffed manually
#define C_AMPERSAND		_T("&")			// Standard delimiter character.			
#define C_EQUALSIGN		_T("=")			// Standard delimiter character.


// These names serve "AllowAutomaticSniffing" checkbox.
//  Currently they are relevant for Local Troubleshooter only.
//  Oleg. 10.25.99
#define C_ALLOW_AUTOMATIC_SNIFFING_NAME			_T("boxAllowSniffing")
#define C_ALLOW_AUTOMATIC_SNIFFING_CHECKED		_T("checked")
#define C_ALLOW_AUTOMATIC_SNIFFING_UNCHECKED	_T("unchecked")


//------------- Config file manager object ---------------//

#define DLLNAME				_T("apgts.dll")
#define DLLNAME2			"apgts.dll"

#define CFG_HEADER			_T("[APGTS]")

#define REG_SOFTWARE_LOC	_T("SOFTWARE\\ISAPITroubleShoot")
#define REG_THIS_PROGRAM	_T("APGTS")

#define TS_REG_CLASS		_T("Generic_Troubleshooter_DLL")

#define REG_EVT_PATH		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application")
#define REG_EVT_MF			_T("EventMessageFile")
#define REG_EVT_TS			_T("TypesSupported")

// Default log file directory.
#define DEF_LOGFILEDIRECTORY		_T("d:\\http\\support\\tshoot\\log\\")

// maximum cache for belief networks
#define MAXCACHESIZE		200

// file extensions and suffixes
#define LOCALTS_EXTENSION_HTM   _T(".HTM") 
#define LOCALTS_SUFFIX_RESULT   _T("_result") 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscac.h ===
//
// MODULE: APGTSCAC.H
//
// PURPOSE: Cache (maps from a set of NID/IST pairs to a set of recommended NIDs)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-24-98		JM		pulled out of apgts.h
//

#ifndef _APGTSCAC_H_DEFINED
#define _APGTSCAC_H_DEFINED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <list>

#include "nodestate.h"

// maximum cache for belief networks
#define MAXCACHESIZE				200

// Maps from a set of node/state pairs to an ordered list of recommended nodes
// This is all within the context of a particular belief network.
class CCacheItem
{
private:
	CBasisForInference BasisForInference;  // Cache key.  Set of node/state pairs, not all
						//	the nodes in the belief network, just the ones on which we
						//	have state data from the user.  State is never ST_UNKNOWN.
						//	No "special" nodes like nidFailNode; these are all valid nodes
						//	on which to base an inference.  
	CRecommendations Recommendations;	// Cache value.  Unless nodes have been skipped, only the
						//	first element of the vector really matters because we will
						//	only give one recommendation at a time.

public:
	CCacheItem() {};
	CCacheItem(const CBasisForInference & Basis, const CRecommendations &Rec) :
		BasisForInference(Basis), Recommendations(Rec)
		{};

	// note that the following makes a copy; it does not return a reference.
	CRecommendations GetRecommendations() const {return Recommendations;}

	// The following comparison operators depend on the assumption that if the cache key 
	//	is identical, the cache value will be, too.
	// Note that this we do not use lexicographical order.  We're saying any shorter
	//	cache key compares as less than any longer.
	bool operator== (const CCacheItem &item) const;
	bool operator!= (const CCacheItem &item) const;
	bool operator< (const CCacheItem &item) const;
	bool operator> (const CCacheItem &item) const;
};

class CCache
{
private:
	list<CCacheItem> listItems;
	enum {k_CacheSizeMax = 200};
public:
	CCache() {};
	~CCache() {};
	void Clear() {listItems.clear();};
	bool AddCacheItem(const CBasisForInference &BasisForInference, const CRecommendations &Recommendations);
	bool FindCacheItem(const CBasisForInference &BasisForInference, CRecommendations &Recommendations) const;
	UINT GetCount() const;
};

#endif //_APGTSCAC_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscounters.cpp ===
// ApgtsCounters.cpp: implementation of the CApgtsCounters class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ApgtsCounters.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApgtsCounters::CApgtsCounters()
{

}

CApgtsCounters::~CApgtsCounters()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscfg.h ===
//
// MODULE: APGTSCFG.H
//	Fully implements class CDBLoadConfiguration
//
// PURPOSE: 
//	Brings together the persistent pieces ofthe online troubleshooter configuration:
//		- the Topic Shop
//		- the registry
//		- the pool threads
//		- the threads that maintain these.
//		- the CRecentUse object that tracks passwords
//	Provides functions to get latest values on registry variables and to acquire a 
//	smart pointer to a CTopic based on its name.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/21/98		JM		this file abstracted from apgtscls.h
//

#ifndef _H_APGTSCFG
#define _H_APGTSCFG

#include "pointer.h"
#include "RegistryMonitor.h"
#include "ThreadPool.h"
#include "RecentUse.h"

//
// Provides in-memory access to registry values & full content of the resource directory
// Basically, on initialization, this sucks EVERYTHING in.
class CDBLoadConfiguration
{
public:
	CDBLoadConfiguration(	HMODULE hModule, 
							CThreadPool * pThreadPool, 
							const CString& strTopicName, 
							CHTMLLog *pLog);
	~CDBLoadConfiguration();
	
	// registry functions
	CString GetFullResource();
	CString GetVrootPath();
	DWORD GetMaxWQItems();
	DWORD GetCookieLife();
	DWORD GetReloadDelay();
	CString GetLogDir();

	void GetListOfTopicNames(vector<CString>&arrstrTopic);
	CP_TOPIC & GetTopic(const CString & strTopic, CP_TOPIC & cpTopic, bool bNewCookie);
	CP_TEMPLATE & GetTemplate(const CString & strTemplate, CP_TEMPLATE & cpTemplate, bool bNewCookie);
	void AddTemplate( const CString & strTemplateName );
	bool RetTemplateInCatalogStatus( const CString& strTemplate, bool& bValid );

	void CreateErrorPage(const CString & strError, CString& out);

protected:
	friend class APGTSContext;
#ifdef LOCAL_TROUBLESHOOTER
	friend class CTSHOOTCtrl;
#endif
	// for use by status pages functions of APGTSContext
	CTopicShop& GetTopicShop() {return m_TopicShop;}
	CRegistryMonitor& GetRegistryMonitor() {return m_RegistryMonitor;}
	CThreadPool& GetThreadPool() {return *m_pThreadPool;}
	CPoolQueue& GetPoolQueue() {return *m_pThreadPool->m_pPoolQueue;}
	CDirectoryMonitor& GetDirectoryMonitor() {return m_DirectoryMonitor;}
	CRecentUse& GetRecentPasswords() {return m_RecentPasswords;}

protected:
	CTopicShop m_TopicShop;					// The collection of available topics.
	CThreadPool * m_pThreadPool;
	CDirectoryMonitor m_DirectoryMonitor;	// track changes to LST, DSC, HTI, BES files.
	CRegistryMonitor m_RegistryMonitor;		// access to registry values.
	CRecentUse m_RecentPasswords;

protected:
	DWORD GetMaxThreads();
	DWORD GetThreadsPP();
	bool HasDetailedEventLogging();
};
#endif // _H_APGTSCFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscfg.cpp ===
//
// MODULE: APGTSCFG.CPP
//	Fully implements class CDBLoadConfiguration
//
// PURPOSE: 
//	Brings together the persistent pieces of the online troubleshooter configuration:
//		- the Topic Shop
//		- the registry
//		- the threads that maintain these.
//		- the template file for error reporting
//	Provides functions to get latest values on registry variables and to acquire a 
//	smart pointer to a CTopic based on its name.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/14/98		JM		Major revisions as classes for file management have 
//								all been rewritten
//


#pragma warning(disable:4786)
#include "stdafx.h"
#include "apgtscfg.h"

//
//
CDBLoadConfiguration::CDBLoadConfiguration(HMODULE hModule, 
										   CThreadPool * pThreadPool, 
										   const CString& strTopicName,
										   CHTMLLog *pLog)
:	m_TopicShop(),
	m_pThreadPool(pThreadPool),
	m_DirectoryMonitor(m_TopicShop ,strTopicName ),
	m_RegistryMonitor(m_DirectoryMonitor, pThreadPool, strTopicName, pLog )
{
}

//
//
CDBLoadConfiguration::~CDBLoadConfiguration()
{
}

CString CDBLoadConfiguration::GetFullResource()
{
	CString str;
	m_RegistryMonitor.GetStringInfo(CAPGTSRegConnector::eResourcePath, str);
	return str;
}

CString CDBLoadConfiguration::GetLogDir()
{
	CString str;
	m_RegistryMonitor.GetStringInfo(CAPGTSRegConnector::eLogFilePath, str);
	return str;
}

CString CDBLoadConfiguration::GetVrootPath()
{
	CString str;
	m_RegistryMonitor.GetStringInfo(CAPGTSRegConnector::eVrootPath, str);
	return str;
}

DWORD CDBLoadConfiguration::GetMaxThreads() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxThreads, dw);
	return dw;
}

// cookie life in minutes (before V3.0, was hours)
DWORD CDBLoadConfiguration::GetCookieLife() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eCookieLife, dw);
	return dw;
}

DWORD CDBLoadConfiguration::GetReloadDelay() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eReloadDelay, dw);
	return dw;
}

DWORD CDBLoadConfiguration::GetThreadsPP() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eThreadsPP, dw);
	return dw;
}

DWORD CDBLoadConfiguration::GetMaxWQItems() 
{ 
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dw);
	return dw;
}

bool CDBLoadConfiguration::HasDetailedEventLogging() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eDetailedEventLogging, dw);
	return dw ? true : false;
}

void CDBLoadConfiguration::GetListOfTopicNames(vector<CString>&arrstrTopic)
{
	m_TopicShop.GetListOfTopicNames(arrstrTopic);
}

// Call this function to obtain a CP_TOPIC as a pointer to the topic (identified by 
//	strTopic) that you want to operate on.  As long as the CP_TOPIC remains undeleted, 
//	the associated CTopic is guaranteed to remain undeleted.
// Warning: this function can wait a long time for the topic to be built.
CP_TOPIC & CDBLoadConfiguration::GetTopic(
	const CString & strTopic, CP_TOPIC & cpTopic, bool bNewCookie)
{
	return m_TopicShop.GetTopic(strTopic, cpTopic, bNewCookie);
}

// Call this function to obtain a CP_TEMPLATE as a pointer to the template (identified by 
//	strTopic) that you want to operate on.  As long as the CP_TEMPLATE remains undeleted, 
//	the associated CAPGTSHTIReader is guaranteed to remain undeleted.
// Warning: this function can wait a long time for the template to be built.
CP_TEMPLATE & CDBLoadConfiguration::GetTemplate(
	const CString & strTemplate, CP_TEMPLATE & cpTemplate, bool bNewCookie)
{
	return m_TopicShop.GetTemplate(strTemplate, cpTemplate, bNewCookie);
}

// Call this function to add a template to the topic shop catalog of templates and
// to add it to the directory monitor list of templates to track for changes.
void CDBLoadConfiguration::AddTemplate( const CString & strTemplateName )
{
	m_TopicShop.AddTemplate( strTemplateName );

	// Notify the directory monitor to track this file.
	m_DirectoryMonitor.AddTemplateToTrack( strTemplateName );
	return;
}

bool CDBLoadConfiguration::RetTemplateInCatalogStatus( const CString & strTemplate, bool & bValid )
{
	return( m_TopicShop.RetTemplateInCatalogStatus( strTemplate, bValid ) );
}

void CDBLoadConfiguration::CreateErrorPage(const CString & strError, CString& out)
{
	m_DirectoryMonitor.CreateErrorPage(strError, out); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsbesread.cpp ===
//
// MODULE: APGTSBESREAD.CPP
//
// PURPOSE: template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
// 1. URLEncodeString() and DecodeInputString() come with only minor changes from Roman's 
//	old approach to BES.
//	
// 2. Typical BES file content might be:
//		<FORM METHOD=POST ACTION="/scripts/samples/search/query.idq">
//		<INPUT TYPE=HIDDEN NAME="CiMaxRecordsPerPage" VALUE="10">
//		<INPUT TYPE=HIDDEN NAME="CiScope" VALUE="/">
//		<INPUT TYPE=HIDDEN NAME="TemplateName" VALUE="query">
//		<INPUT TYPE=HIDDEN NAME="HTMLQueryForm" VALUE="/samples/search/query.htm">
//		Enter items to search for 
//		<INPUT TYPE=TEXT NAME="CiRestriction" VALUE="print OR &quot;network print&quot;">
//		<INPUT TYPE=SUBMIT VALUE="Search">
//		</FORM>
//
//	There are some tight restrictions because of a rather naive parse:
//		FORM, ACTION, TYPE, NAME, VALUE must be capitalized
//		No white space allowed in any of 
//			<FORM
//			ACTION="
//			<INPUT
//			TYPE=
//			TYPE=TEXT
//			NAME=
//			VALUE=
//			">		(value for TYPE=TEXT)
//		At least one character (typically CR) is mandatory between each use of <INPUT ...>
//		Each <INPUT ...> must include attribute TYPE=
//		For each <INPUT ...> NAME=, VALUE= are optional, but if present attributes must be 
//			in order TYPE=, NAME=, VALUE=
//		There should be exactly one TYPE=TEXT input, and it should come after all the 
//		HIDDENs and before the SUBMIT.
//
// 3. Back End Search (BES) is used only for the service node or for the fail node.
//	The fail node is the unique, implicit node in a belief network which we reach when 
//	there are no more recommendations and no explicit skips.  The service node is the 
//	unique, implicit node which we reach when there are no more recommendations and at least
//	one explicit skip.
//	The service node and fail node are not explicitly implemented as nodes.  Instead, 
//	they are implicitly constructed from either support text or the content of the BES file.  
//	(The latter supersedes the former.)
//
// 4. We call BuildURLEncodedForm() more often than is absolutely necessary.  It really 
//	could be called only "on demand" in GetURLEncodedForm().  Since this is all in-memory 
//	stuff, it's  pretty cheap to make the extra calls, and it should make debugging easier.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		08-31-98	JM		support both returning a raw & an URL encoded form
//

#include "stdafx.h"
#include "apgtsbesread.h"
#include "CharConv.h"
#include <algorithm>
#include "event.h"

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReaderException
////////////////////////////////////////////////////////////////////////////////////
CAPGTSBESReaderException::CAPGTSBESReaderException(	
		CFileReader* reader, 
		eAPGTSBESErr err, 
		LPCSTR source_file, 
		int line)
: CFileReaderException(reader, eErrParse, source_file, line),
  m_eAPGTSBESErr(err)
{
}

////////////////////////////////////////////////////////////////////////////////////
// CBESPair
////////////////////////////////////////////////////////////////////////////////////
// concatenate strings to produce new BESStr.  Place " AND " between each 
//	pair of strings.
// If resulting string is to be URL-encoded, then, on input, content of strings in vector 
//	must each be URL-encoded.  In practice, we don't URL-encode this, we URL-encode the 
//	output of GetBESStr() instead.
CBESPair& CBESPair::operator << (const vector<CString>& in)
{
	BESStr = _T(""); // clear
	for (vector<CString>::const_iterator i = in.begin(); i < in.end(); i++)
	{
		vector<CString>::iterator current = (vector<CString>::iterator)i;

		BESStr += _T("(");
		BESStr += *i;
		BESStr += _T(")");
		if (++current != in.end())
			BESStr += _T(" AND ");
	}
	return *this;
}

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReader
////////////////////////////////////////////////////////////////////////////////////
/*static*/ LPCTSTR CAPGTSBESReader::FORM = _T("FORM");
/*static*/ LPCTSTR CAPGTSBESReader::METHOD = _T("METHOD"); 
/*static*/ LPCTSTR CAPGTSBESReader::ACTION = _T("ACTION");
/*static*/ LPCTSTR CAPGTSBESReader::INPUT = _T("INPUT");
/*static*/ LPCTSTR CAPGTSBESReader::TYPE = _T("TYPE");
/*static*/ LPCTSTR CAPGTSBESReader::NAME = _T("NAME");
/*static*/ LPCTSTR CAPGTSBESReader::VALUE = _T("VALUE");
/*static*/ LPCTSTR CAPGTSBESReader::HIDDEN = _T("HIDDEN");
/*static*/ LPCTSTR CAPGTSBESReader::TEXT = _T("TEXT");

CAPGTSBESReader::CAPGTSBESReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /* = NULL */)
			   : CTextFileReader(pPhysicalFileReader, szDefaultContents)
{
}

CAPGTSBESReader::~CAPGTSBESReader()
{
}

void CAPGTSBESReader::GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw)
{
	LOCKOBJECT();

	ClearSearchString();
	for (vector<CString>::const_iterator i = arrstrIn.begin(); i < arrstrIn.end(); i++)
		operator << (*i);

	GetURLEncodedForm(strEncoded);
	GetRawForm(strRaw);

	UNLOCKOBJECT();
}

// string "in" will be ANDed onto the list of strings to search.
CAPGTSBESReader& CAPGTSBESReader::operator << (const CString& in)
{
	LOCKOBJECT();

	try
	{
		m_arrBESStr.push_back( in );
		m_SearchText << m_arrBESStr;
		BuildURLEncodedForm();
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	UNLOCKOBJECT();
	return *this;
}

// string "in" will be removed from the list of strings to search.
// This is provided for class completeness, not for any current need. (JM 8/98)
CAPGTSBESReader& CAPGTSBESReader::operator >> (const CString& in)
{
	LOCKOBJECT();
	
	vector<CString>::iterator i = find( m_arrBESStr.begin(), m_arrBESStr.end(), in );
	
	if (i != m_arrBESStr.end())
	{
		m_arrBESStr.erase(i);
		m_SearchText << m_arrBESStr;
		BuildURLEncodedForm();
	}
	UNLOCKOBJECT();
	return *this;
}

// Typically, you will want to call this to clear the search string before you start
//	appending new strings to it.
CAPGTSBESReader& CAPGTSBESReader::ClearSearchString()
{
	LOCKOBJECT();

	m_arrBESStr.clear();

	m_SearchText << m_arrBESStr;
	BuildURLEncodedForm();

	UNLOCKOBJECT();
	return *this;
}

void CAPGTSBESReader::GetURLEncodedForm(CString& out)
{
	LOCKOBJECT();
	out = m_strURLEncodedForm;
	UNLOCKOBJECT();
}

void CAPGTSBESReader::GetRawForm(CString& str)
{
	vector<CString>::iterator i = NULL;

	LOCKOBJECT();

	str.Empty();

	vector<CString>::iterator itBES = m_arrRawForm.begin() + m_iBES;

	for (i = m_arrRawForm.begin(); i < itBES; i++)
	{
		if ((i + 1) < itBES)
			str += *i;
		else
		{
			// Remove the default BES VALUE off the raw string.
			TCHAR *valuestr = _T("VALUE=\"");
			int	nFoundLoc;

			nFoundLoc= (*i).Find( valuestr );
			if (nFoundLoc == -1)
				str += *i;
			else
				str += (*i).Left( nFoundLoc + _tcslen( valuestr ) );
		}
	}

	str += m_SearchText.GetBESStr();

	for (i = itBES; i < m_arrRawForm.end(); i++)
		str += *i;

	UNLOCKOBJECT();
}

void CAPGTSBESReader::Parse()
{
	CString str, tmp, strSav;
	long save_pos = 0;

	LOCKOBJECT();
	save_pos = GetPos();
	SetPos(0);

	m_iBES = 0;
	vector<CString>::iterator itBES = NULL;

	try 
	{
		// pump file content into array of lines
		m_arrRawForm.clear();
		while (GetLine(str))
		{
			m_arrRawForm.push_back(str);
		}

		m_arrURLEncodedForm.clear();
		
		// parse string-by-string
		for (vector<CString>::iterator i = m_arrRawForm.begin(); i < m_arrRawForm.end(); i++)
		{
			if (IsMethodString(*i))
			{
				if (ParseMethodString(*i, tmp)) 
				{
					m_arrURLEncodedForm.push_back(tmp);
					continue;
				}
			}
			else if (IsBESString(*i))
			{
				if (ParseBESString(*i, m_SearchText)) // modifies m_SearchText.Name
				{   
					// do not include BES string into m_arrURLEncodedForm,
					//  include it in m_SearchText instead (although typically, we
					//	will throw it away unused).
					m_SearchText << m_arrBESStr;
					itBES = i+1;
					int loc = i->Find(_T("\">"));
					strSav = i->Mid(loc);
					*i = i->Left(loc);
					continue;
				}
			}
			else if (IsTypeString(*i))
			{
				if (ParseTypeString(*i, tmp)) 
				{
					m_arrURLEncodedForm.push_back(tmp);
					continue;
				}
			}
			// else can not be parsed, leave m_arrURLEncodedForm alone.
		}

		BuildURLEncodedForm();
	} 
	catch (CAPGTSBESReaderException&)	
	{
		// Log BES file parsing error and rethrow exception.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_ERROR_BES_PARSE ); 
		throw;
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log and rethrow exception.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		throw;
	}

	if (itBES)
	{
		m_iBES = itBES - m_arrRawForm.begin();
		try
		{
			m_arrRawForm.insert(itBES, strSav);
		}
		catch (exception& x)
		{
			CString str2;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str2), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}
	
	SetPos(save_pos);
	UNLOCKOBJECT();
}

void CAPGTSBESReader::BuildURLEncodedForm()
{
	CString strTemp;

	vector<CString>::const_iterator i = m_arrURLEncodedForm.begin();

	LOCKOBJECT();

	m_strURLEncodedForm = _T(*i); // URL of web app itself
	m_strURLEncodedForm += _T("?");
	i++;
	
	// form output string without BES string
	for (; i < m_arrURLEncodedForm.end(); i++)
	{
		m_strURLEncodedForm += *i;		// name/value pair
		m_strURLEncodedForm += _T("&");
	}

	// append BES string
	URLEncodeString(m_SearchText.Name, strTemp);
	m_strURLEncodedForm += strTemp;
	m_strURLEncodedForm += _T("=");
	URLEncodeString(m_SearchText.GetBESStr(), strTemp);
	m_strURLEncodedForm += strTemp;

	m_strURLEncodedForm += _T(" HTTP/1.0");

	UNLOCKOBJECT();
}

// Determine whether or not a string constitutes a "Method" string.  Method strings need
// to contain a FORM, METHOD, and ACTION string.  Here is an example Method string.
// <FORM METHOD=POST ACTION="/scripts/samples/search/query.idq">
bool CAPGTSBESReader::IsMethodString(const CString& str) const
{
	if (-1 == str.Find(FORM)   ||
		-1 == str.Find(METHOD) ||
		-1 == str.Find(ACTION))
	{
		// All required elements were not found.
	   return false;
	}

	return true;
}

// Determine whether or not a string constitutes a "Type" string.  Type strings need
// to contain a INPUT, TYPE, NAME, and VALUE string.  Here is an example Type string.
// <INPUT TYPE=HIDDEN NAME="TemplateName" VALUE="query">
bool CAPGTSBESReader::IsTypeString(const CString& str) const
{
	if (-1 == str.Find(INPUT) ||
		-1 == str.Find(TYPE)  ||
		-1 == str.Find(NAME)  ||
		-1 == str.Find(VALUE))
	{
		// All required elements were not found.
	   return false;
	}

	return true;
}

// Determine whether or not a string constitutes a "BES" string.  BES strings need
// to contain all of the elements of a "Type" string as well as a TEXT tag.
// The following is an example BES string.
// Enter items to search for <INPUT TYPE=TEXT NAME="CiRestriction" VALUE="print OR &quot;network print&quot;">
bool CAPGTSBESReader::IsBESString(const CString& str) const
{
	if (!IsTypeString(str) || -1 == str.Find(TEXT)) 
	{
		// All required elements were not found.
	   return false;
	}

	return true;
}

bool CAPGTSBESReader::ParseMethodString(const CString& in, CString& out)
{
	long index = -1;
	LPTSTR str = (LPTSTR)(LPCTSTR)in, start =NULL, end =NULL;

	if (-1 != (index = in.Find(ACTION)))
	{
		start = (LPTSTR)(LPCTSTR)in + index;
		while (*start && *start != _T('"'))
			start++;
		if (*start)
		{
			end = ++start;

			while (*end && *end != _T('"'))
				end++;
			if (*end)
			{
				try
				{
					TCHAR* path = new TCHAR[end - start + 1];

					_tcsncpy(path, start, end - start);
					path[end - start] = 0;
					out= path;
					delete [] path;

					return true;
				}
				catch (bad_alloc&)
				{
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
					return( false );
				}
			}
		}
	}

	return false;
}

bool CAPGTSBESReader::ParseTypeString(const CString& in, CString& out)
{
	CString type, name, value;
	CString name_encoded, value_encoded;
	
	if (DecodeInputString(this, in, type, name, value))
	{
		URLEncodeString(name, name_encoded);
		URLEncodeString(value, value_encoded);

		out = _T("");
		out += name_encoded;
		out += _T("=");
		out += value_encoded;

		return true;
	}
	return false;
}

bool CAPGTSBESReader::ParseBESString(const CString& in, CBESPair& out)
{
	CString type, name, value;
	CString name_encoded, value_encoded;
	
	if (DecodeInputString(this, in, type, name, value))
	{
		URLEncodeString(name, name_encoded);
		URLEncodeString(value, value_encoded);

		out.Name = name_encoded;
		
		// Note:	We do not care about the value_encoded string as it is no longer
		//			used as all of the search parameters come from nodes visited.  RAB-981028.

		return true;
	}
	return false;
}

// URL-encoding in the narrow sense.
//	INPUT in - normal text
//	OUTPUT out - equivalent URL-encoded string
/*static*/ void CAPGTSBESReader::URLEncodeString(const CString& in, CString& out)
{
	TCHAR tostr[2048]; 
	TCHAR *ptr = (LPTSTR)(LPCTSTR)in;

	TCHAR buf[5], *str;
	TCHAR EncodeByte;

	str = ptr;

	_tcscpy(tostr, _T(""));
	while (*str) {
		if (!_istalnum(*str) || *str < 0) {
			if (*str == _T(' '))
				_tcscat(tostr, _T("+"));
			else {
				if (!_istleadbyte(*str)) {
					EncodeByte = *str;
					_stprintf(buf, _T("%%%02X"), (unsigned char) EncodeByte);
					_tcscat(tostr, buf);
				}
				else {
					EncodeByte = *str;
					_stprintf(buf, _T("%%%02X"), (unsigned char) EncodeByte);
					_tcscat(tostr, buf);
					EncodeByte = *(str + 1);
					_stprintf(buf, _T("%%%02X"), (unsigned char) EncodeByte);
					_tcscat(tostr, buf);
				}
			}
		}
		else {
			_tcsncpy(buf, str, 2);
			if (_istleadbyte(*str))
				buf[2] = NULL;
			else
				buf[1] = NULL;
			_tcscat(tostr, buf);
		}
		str = _tcsinc(str);
	}
	
	out = tostr;
	return;
}

//	Parse a line from BES file
//		<INPUT TYPE=HIDDEN NAME="CiMaxRecordsPerPage" VALUE="10">
//	See note at head of this .cpp file for detailed requirements on these lines
//
//	If const_str is a null string, returns success with type, name, value all null strings
//	Otherwise, if successful, this function sets type, name, value to the content
//		of those respective attributes, if present (e.g "HIDDEN", "CiMaxRecordsPerPage", "10").
//	All of these physically point into the (altered) string originally passed in *str
//
//	Returns true on success.  All failures throw exceptions.
//	
/*static*/ bool CAPGTSBESReader::DecodeInputString(
	CFileReader* reader, 
	const CString& const_str, 
	CString& type, 
	CString& name, 
	CString& value
)
{
	CString temp_str = const_str;

	TCHAR*  str = (LPTSTR)(LPCTSTR)temp_str;
	TCHAR*	ptrtype = NULL;
	TCHAR*	ptrname = NULL;
	TCHAR*	ptrvalue = NULL;
	
	TCHAR *typestr = _T("TYPE=");
	TCHAR *namestr = _T("NAME=");
	TCHAR *valuestr = _T("VALUE=");
	TCHAR *ptr, *ptrstart;
	
	int typelen = _tcslen(typestr);
	int namelen = _tcslen(namestr);
	int valuelen = _tcslen(valuestr);

	ptr = str;
	ptrtype = str;
	ptrname = str;
	ptrvalue = str;

	if (*ptr == _T('\0')) 
		goto SUCCESS;

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	// must have TYPE
	if ((ptrstart = _tcsstr(ptr, typestr))==NULL) 
		throw CAPGTSBESReaderException(
					reader,
		 			CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_TYPE_TAG,
					__FILE__, 
					__LINE__);

	ptrstart = _tcsninc(ptrstart, typelen);

	if (*ptrstart == _T('"'))
		// Deal with optional quotation marks
		ptrstart = _tcsinc(ptrstart);

	if ((ptr = _tcschr(ptrstart, _T(' ')))==NULL) 
		if ((ptr = _tcschr(ptrstart, _T('>')))==NULL) 
			throw CAPGTSBESReaderException(
					reader,
		 			CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_CT_TAG,
					__FILE__, 
					__LINE__);

	if (ptrstart != ptr)
		ptr = _tcsdec(ptrstart, ptr);

	if (*ptr != _T('"'))
		ptr = _tcsinc(ptr);

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	ptrtype = ptrstart;

	// NAME must come next if present
	if ((ptrstart = _tcsstr(ptr, namestr))==NULL) 
		goto SUCCESS;

	ptrstart = _tcsninc(ptrstart, namelen);

	if (*ptrstart == _T('"'))
		ptrstart = _tcsinc(ptrstart);

	if ((ptr = _tcschr(ptrstart, _T('"')))==NULL) 
		if ((ptr = _tcschr(ptrstart, _T(' ')))==NULL) 
			if ((ptr = _tcschr(ptrstart, _T('>')))==NULL) 
				throw CAPGTSBESReaderException(
							reader,
		 					CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_CN_TAG,
							__FILE__, 
							__LINE__);

	if (ptrstart != ptr)
		ptr = _tcsdec(ptrstart, ptr);

	if (*ptr != _T('"'))
		ptr = _tcsinc(ptr);

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	ptrname = ptrstart;

	// VALUE must come next if present
	if ((ptrstart = _tcsstr(ptr, valuestr))==NULL) 
		goto SUCCESS;

	ptrstart = _tcsninc(ptrstart, valuelen);

	if (*ptrstart == _T('"'))
		ptrstart = _tcsinc(ptrstart);

	if ((ptr = _tcschr(ptrstart, _T('"')))==NULL) 
		if ((ptr = _tcschr(ptrstart, _T(' ')))==NULL) 
			if ((ptr = _tcschr(ptrstart, _T('>')))==NULL) 
				throw CAPGTSBESReaderException(
							reader,
		 					CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_CV_TAG,
							__FILE__, 
							__LINE__);

	if (ptrstart != ptr)
		ptr = _tcsdec(ptrstart, ptr);

	if (*ptr != _T('"'))
		ptr = _tcsinc(ptr);

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	ptrvalue = ptrstart;

SUCCESS:
	type = ptrtype;
	name = ptrname;
	value = ptrvalue;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsbesread.h ===
//
// MODULE: APGTSBESREAD.H
//
// PURPOSE: BES file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//	Typical BES file content might be:
//		<FORM METHOD=POST ACTION="/scripts/samples/search/query.idq">
//		<INPUT TYPE=HIDDEN NAME="CiMaxRecordsPerPage" VALUE="10">
//		<INPUT TYPE=HIDDEN NAME="CiScope" VALUE="/">
//		<INPUT TYPE=HIDDEN NAME="TemplateName" VALUE="query">
//		<INPUT TYPE=HIDDEN NAME="HTMLQueryForm" VALUE="/samples/search/query.htm">
//		Enter items to search for 
//		<INPUT TYPE=TEXT NAME="CiRestriction" VALUE="print OR &quot;network print&quot;">
//		<INPUT TYPE=SUBMIT VALUE="Search">
//		</FORM>
//	See corresponding .cpp file for details of restrictions & for other notes.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		08-31-98	JM		support both returning a raw & an URL encoded form
//

#ifndef __APGTSBESREAD_H_
#define __APGTSBESREAD_H_

#include "fileread.h"


////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReaderException
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSBESReader;
class CAPGTSBESReaderException : public CFileReaderException
{
public: 
	enum eAPGTSBESErr {	eEV_GTS_ERROR_BES_MISS_TYPE_TAG, //  %1 %2 Backend search file does not have TYPE tag (make sure tag is all caps in file): TYPE= %3 %4
						eEV_GTS_ERROR_BES_MISS_CT_TAG,	//  %1 %2 Backend search file is missing close tag '>' for TYPE tag %3 %4
						eEV_GTS_ERROR_BES_MISS_CN_TAG,	//  %1 %2 Backend search file is missing close tag '>' for NAME tag %3 %4
						eEV_GTS_ERROR_BES_MISS_CV_TAG	//  %1 %2 Backend search file is missing close tag '>' for VALUE tag %3 %4
	} m_eAPGTSBESErr;

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CAPGTSBESReaderException(CFileReader* reader, eAPGTSBESErr err, LPCSTR source_file, int line);
};

////////////////////////////////////////////////////////////////////////////////////
// CBESPair
// represents name value pair for TYPE=TEXT field in a form
//	value (BESStr) will reflect what we're searching for.
////////////////////////////////////////////////////////////////////////////////////
struct CBESPair
{
// data
	CString Name;		// in the example in the notes at the head of this file,
						//	this would be "CiRestriction"

// code
	CString GetBESStr() const {return BESStr;}
	CBESPair& operator << (const vector<CString>& in);

protected:
	CString BESStr;		// value
};

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReader
// Read BES file
//  Includes interface to modify content of BES file into GET-POST method
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSBESReader : public CTextFileReader
{
public:
	static LPCTSTR FORM;
	static LPCTSTR METHOD;
	static LPCTSTR ACTION;
	static LPCTSTR INPUT;
	static LPCTSTR TYPE;
	static LPCTSTR NAME;
	static LPCTSTR VALUE;
	static LPCTSTR HIDDEN;
	static LPCTSTR TEXT;

public:
	static void URLEncodeString(const CString& in, CString& out);
	static bool DecodeInputString(CFileReader* reader, const CString& str, CString& type, CString& name, CString& value);

protected:
	CString m_strURLEncodedForm;	// URL-encoded entire form (name-value pairs for a
									// GET-method query) including the string to search on.
	CBESPair m_SearchText;			// contains non-URL-encoded BES name - value pair
									// Initial BES content resides in CFileReader::m_StreamData,
									//	but is really of no interest.
	vector<CString> m_arrBESStr;    // contains array of encoded partial search strings
									//	for BES search.  In practice, these correspond to
									//	certain node/state pairs
	vector<CString> m_arrRawForm;	// contains array of unparsed strings exactly as they
									//	come from the BES file
	int m_iBES;						// index of element in m_arrRawForm before which
									// we place search string (to build a whole form).
	vector<CString> m_arrURLEncodedForm; // contains array of parsed and encoded strings
public:
	CAPGTSBESReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CAPGTSBESReader();

	void GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw);

protected:
	CAPGTSBESReader& operator << (const CString& in); // add (AND) new clause into search expression.
	CAPGTSBESReader& operator >> (const CString& in); // roll back clause addition
	CAPGTSBESReader& ClearSearchString();

	void GetURLEncodedForm(CString&);
	void GetRawForm(CString&);

protected:
	virtual void Parse(); 

protected:
	virtual void BuildURLEncodedForm();
	virtual bool IsMethodString(const CString&) const;
	virtual bool IsBESString(const CString&) const;
	virtual bool IsTypeString(const CString&) const;
	virtual bool ParseMethodString(const CString& in, CString& out);
	virtual bool ParseBESString(const CString& in, CBESPair& out);
	virtual bool ParseTypeString(const CString& in, CString& out);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscls.h ===
//
// MODULE: APGTSCLS.H
//
// PURPOSE: Class header file
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
// 
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-22-98		JM		Major revision, deprecate IDH.
// V3.1		1-06-99		JM		Extract APGTSEXT.H
//

#if !defined(APGTSCLS_H_INCLUDED)
#define APGTSCLS_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include"apgtsinf.h"
#include "apgtslog.h"
#include "LogString.h"
#include "apgtspl.h"
#include "maxbuf.h"
#include "apgts.h"

#include <map>
using namespace std;


// string constants involved in commands from sysop to take various actions.
#define SZ_OP_ACTION "TSHOOOT"		// Preface to all operator actions.  Note the extra "O".
#define SZ_EMERGENCY_DEF SZ_OP_ACTION
#define SZ_RELOAD_TOPIC "E1"		// Reload one topic
#define SZ_KILL_THREAD "E2"			// Kill (and restart) one pool thread
#define SZ_RELOAD_ALL_TOPICS "E3"	// Reload all monitored files.
#define SZ_SET_REG "E4"				// Set a registry value.

#define SZ_KILL_STUCK_THREADS "E8"	// Kill (and restart) all stuck pool threads
#define SZ_EMERGENCY_REBOOT "E9"	// want to reboot this DLL.


// The product version is loaded from the resource file upon DLL startup.
// Used for APGTS logging and status page reporting.
extern CString	gstrProductVersion;		

// HTTP spec for document type.  For validation of incoming HTTP POST request.
#define CONT_TYPE_STR	"application/x-www-form-urlencoded"


class CHttpQuery {
public:
	CHttpQuery();
	~CHttpQuery();

	BOOL GetFirst(LPCTSTR szInput, TCHAR *pchName, TCHAR *pchValue);
	BOOL GetNext(TCHAR *pchName, TCHAR *pchValue);
	void Push(LPCTSTR szPushed);

protected:
	BOOL LoopFind(TCHAR *pchName, TCHAR *pchValue);
	void AddBuffer( TCHAR ch, TCHAR *tostr);
	void PutStr(LPCTSTR instr, TCHAR *addtostr);
	static void CleanStr(TCHAR *str);

protected:
	enum decstates {
		ST_GETNEXT,
		ST_FINDNAME,		
		ST_GETDATA,	
		ST_DECODEHEX1,	
		ST_DECODEHEX2,
		ST_GETFIRST,
	};
	decstates m_state;			// used to track where we are in putting together
								// characters while deciphering HTTP encoding.
	CString m_strInput;			// The original input buffer, containing name/value pairs.
								// It is also possible to "push" a pair onto the front of 
								//	this buffer
	int m_nIndex;				// index into the string of m_strInput.  Keeps track of 
								//	where we are in the parse.
};



// forward declaration
class CDBLoadConfiguration;
class CTopic;
class CSniffConnector;
//
//
class APGTSContext
{
private:
	//
	// this nested class is an internal manager if nid-value pairs container
	//
	class CCommandsAddManager;
	class CCommands	
	{
		friend class CCommandsAddManager;

	private:
		//
		// this nested class represent name/value pairs we get from an HTML form
		//
		class NID_VALUE_PAIR 
		{
		friend class CCommands;
		private:
			NID	nid;						// Note two special values:
											//	nidProblem: value is a node
											//	nidNil: ignore value
			int	value;						// typically a node state, but for nidProblem, it's
											// problem node NID
		public:
			bool operator<(const NID_VALUE_PAIR & pair)const
				{return nid<pair.nid || value<pair.value;};
			bool operator==(const NID_VALUE_PAIR & pair)const
				{return nid==pair.nid || value==pair.value;};
		};

	private:
		vector<NID_VALUE_PAIR>m_arrPair;

	private: // CAddManager is managing addition to object of this class
		int Add( NID nid, int value );

	public:
		CCommands() {}
		~CCommands() {}

		int GetSize() const;
		void RemoveAll();
		bool GetAt( int nIndex, NID &nid, int &value ) const;
		void RotateProblemPageToFront();
	};
	//
	// this nested class is an internal manager of additions to 
	//  "Commands: and "Sniffed" objects of CCommands class
	//
	class CCommandsAddManager
	{
		CCommands& m_Commands;
		CCommands& m_Sniffed;

	public:
		CCommandsAddManager(CCommands& commands, CCommands& sniffed) : m_Commands(commands), m_Sniffed(sniffed) {}
		~CCommandsAddManager() {}

	public:
		void Add(NID nid, int value, bool sniffed);
	};
	//
	// this nested class is an internal manager if name-value pairs container
	//  carrying additional imformation from HTMP form
	//
	class CAdditionalInfo
	{
	private:
		//
		// this nested class represent name/value pairs we get from an HTML form
		//
		class NAME_VALUE_PAIR 
		{
		friend class CAdditionalInfo;
		private:
			CString name;
			CString value;

		public:
			bool operator<(const NAME_VALUE_PAIR & pair)const
				{return name<pair.name;};
			bool operator==(const NAME_VALUE_PAIR & pair)const
				{return name==pair.name;};
		};

	private:
		vector<NAME_VALUE_PAIR>m_arrPair;

	public:
		CAdditionalInfo() {}
		~CAdditionalInfo() {}

		int GetSize() const;
		void RemoveAll();
		bool GetAt( int nIndex, CString& name, CString& value ) const;
		int Add( const CString& name, const CString& value );
	};

protected:
	enum eOpAction {eNoOpAction, eReloadTopic, eKillThread, eReloadAllTopics, eSetReg};

public:
	APGTSContext(	CAbstractECB *pECB, 
					CDBLoadConfiguration *pConf, 
					CHTMLLog *pLog, 
					GTS_STATISTIC *pStat,
					CSniffConnector* pSniffConnector);
	~APGTSContext();

	void ProcessQuery();

	static BOOL StrIsDigit(LPCTSTR pSz);

	CString RetCurrentTopic() const;

protected:
	void CheckAndLogCookie();
	void DoContent();

	DWORD ProcessCommands(LPTSTR pszCmd, LPTSTR pszValue);
	VOID ClearCommandList();
	VOID ClearSniffedList();
	VOID ClearAdditionalInfoList();
	//bool PlaceNodeInCommandList(NID nid, IST ist);
	//bool PlaceNodeInSniffedList(NID nid, IST ist);
	//bool PlaceInAdditionalInfoList(const CString& name, const CString& value);
	VOID SetNodesPerCommandList();
	VOID SetNodesPerSniffedList();
	VOID ProcessAdditionalInfoList();
	VOID ReadPolicyInfo();
	VOID LogNodesPerCommandList();
	CString GetStartOverLink();
	bool StripSniffedNodePrefix(LPTSTR szName);

	DWORD DoInference(
		LPTSTR pszCmd, 
		LPTSTR pszValue, 
		CTopic * pTopic,
		bool bUsesIDH);

	DWORD NextCommand(LPTSTR pszCmd, LPTSTR pszValue, bool bUsesIDH);
	DWORD NextAdditionalInfo(LPTSTR pszCmd, LPTSTR pszValue);
	DWORD NextIgnore(LPTSTR pszCmd, LPTSTR pszValue);
	NID NIDFromSymbolicName(LPCTSTR szNodeName);
	char *GetCookieValue(char *pszName, char *pszNameValue);
	void asctimeCookie(const struct tm &gmt, char * szOut);

	void SetError(LPCTSTR szMessage);

// Operator actions
	eOpAction IdentifyOperatorAction(CAbstractECB *pECB);
	eOpAction ParseOperatorAction(CAbstractECB *pECB, CString & strArg);
	void ExecuteOperatorAction(
		CAbstractECB *pECB, 
		eOpAction action,
		const CString & strArg);

// Status pages: code is in separate StatusPage.cpp
	void DisplayFirstPage(bool bHasPwd);
	void DisplayFurtherGlobalStatusPage();
	void DisplayThreadStatusOverviewPage();
	void DisplayTopicStatusPage(LPCTSTR topic_name);
	bool ShowFullFirstPage(bool bHasPwd);
	void InsertPasswordInForm();
	void BeginSelfAddressingForm();
	
protected:
	CAbstractECB *m_pECB;					// effectively, everything that came in from
											// the user in a submitted HTML form
	DWORD m_dwErr;
	// The next 2 are arrays of TCHAR rather than being CString, because it's easier
	//	for when they need to be passed to methods of EXTENSION_CONTROL_BLOCK
	TCHAR m_ipstr[MAXBUF];					// Remote IP address (who submitted the form)
	TCHAR m_resptype[MAXBUF];				// HTTP response type e.g. "200 OK", 
											//	"302 Object Moved"
	CString m_strHeader;					// header for response file (indicates whether
											// we're sending HTML, setting a cookie, etc.)
											// >>> $UNICODE Is it OK that this is CString (based
											//	on TCHAR) or should it always be char? JM 10/27/98
	CString m_strText;						// this is where we build the string to pass 
											//	back over the net.
											// >>> $UNICODE Is it OK that this is CString (based
											//	on TCHAR) or should it always be char? JM 10/27/98
	CString m_strLocalIPAddress;			// IP address (in the dotted form) for the local machine
											//  If not defined: GetLength() == 0
	CLogString m_logstr;					// We log to this object & when we're all done
											//	destructor writes it to the log.

	CHttpQuery m_Qry;						// takes in raw URL-encoded string, gives us
											//	functions to get back scanned pairs.
	CDBLoadConfiguration *m_pConf;			// contains support-file data structures
	CString m_strVRoot;						// Local URL to this DLL
	TCHAR *m_pszQuery;						// a copy of what came in via GET or POST
	CInfer m_infer;							// belief-network handler, unique to this request
											// This works out what node to show and builds HTML
											//	fragments for the HTI template to render.
	CHTMLLog *m_pLog;						// access to writing to the log.
	bool m_bPostType;						// TRUE = post, FALSE = get
	DWORD m_dwBytes;						// length of query string in chars, excluding
											// terminating null.
	GTS_STATISTIC *m_pStat;

	CCommandsAddManager m_CommandsAddManager; // manages adding data to m_Commands and m_Sniffed
	CCommands m_Commands;					// name/value pairs we get from an HTML form
	CCommands m_Sniffed;					// name/value pairs (for sniffed nodes) we get 
											//	from an HTML form; "SNIFFED_" already stripped out.
	CAdditionalInfo m_AdditionalInfo;		// name/value pairs we get from HTML. They represent
											//  additional info. Additional info is name/value
											//  pair other then command pair (C_TYPE, C_TOPIC or C_PRELOAD), 
											//  though first in name/value pair's sequence 
											//  will be a command.
	bool m_bPreload;						// TRUE = name/value pairs aren't really from a 
											//	user, they're from a sniffer.
	bool m_bNewCookie;						// true = we had to create a new cookie for this
											//	query: they didn't already have one.
	CHourlyDailyCounter * const m_pcountUnknownTopics; // count requests where the topic is not known in
											// the LST file.
	CHourlyDailyCounter * const m_pcountAllAccessesFinish; // Each time we finish with any sort of request,
											//	successful or not, this gets incremented.
	CHourlyDailyCounter * const m_pcountStatusAccesses; // Each time we finish a request for system status											

	CHourlyDailyCounter * const m_pcountOperatorActions; // Count operator action requests.											

	CString m_TopicName;
// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifndef NOPWD
	CString m_strTempPwd;					// temporary password (if this is a status request)
#endif // ifndef NOPWD
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
	time_t timeCreateContext;
	time_t timeStartInfer;
	time_t timeEndInfer;
	time_t timeEndRender;
#endif // SHOWPROGRESS

private:
	// Functions to set and retrieve an alternate HTI file name.
	void	SetAltHTIname( const CString& strHTIname );
	CString GetAltHTIname() const;

	CString	m_strAltHTIname;	// name of the alternate HTI template file if specified.

	typedef map<CString,CString> CCookiePairs;
	CCookiePairs m_mapCookiesPairs;	// Map of command line cookie name-value pairs.
};

// global prototypes
//UINT PoolTask(LPVOID);
UINT WINAPI PoolTask( LPVOID lpParams );
bool ProcessRequest(CPoolQueue & PoolQueue);

DWORD WINAPI DirNotifyTask( LPDWORD lpParams );

/////////////////////////////////////////////////////////////////////////////
#endif // APGTSCLS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscac.cpp ===
//
// MODULE: APGTSCAC.CPP
//
// PURPOSE: Belief network caching support classes
//	Fully implements class CBNCacheItem
//	Fully implements class CBNCache
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel, modeled on earlier work by Roman Mach
// 
// ORIGINAL DATE: 10-2-96, completely rewritten 8/98
//
// NOTES: 
//	1. The strategy here builds a "Most-recently-used" cache (singly-linked list of 
//		CBNCacheItem ordered by how recently used)
//	2. Although you are first supposed to call FindCacheItem and only call AddCacheItem
//		if that fails, there is no support to do this in a threadsafe manner, so there
//		had better be only one thread with access to a given CCache.  Mutex protection
//		must come at a higher level.
//	3. One cache is associated with each [instance of a] Belief Network
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		8/7/98		JM		Original
//



#include "stdafx.h"
#include "event.h"
#include "apgtscac.h"
#include "baseexception.h"
#include "CharConv.h"
#include <algorithm>

// The CCacheItem comparison operators depend on the assumption that if the cache key 
//	is identical, the cache value will be, too.
bool CCacheItem::operator== (const CCacheItem &item) const
{
	return (BasisForInference == item.BasisForInference);
}

bool CCacheItem::operator!= (const CCacheItem &item) const
{
	return (BasisForInference != item.BasisForInference);
}

// Note that this is not lexicographical order.  We're saying any shorter
//	cache key compares as less than any longer.
bool CCacheItem::operator< (const CCacheItem &item) const
{
	const CBasisForInference::size_type thisSize = BasisForInference.size();
	const CBasisForInference::size_type otherSize = item.BasisForInference.size();

	if (thisSize < otherSize)
		return true;

	if (thisSize > otherSize)
		return false;

	// same length, use lexicographical order.
	return (BasisForInference < item.BasisForInference);
}

// Note that this is not lexicographical order.  We're saying any longer
//	cache key compares as greater than any shorter.
bool CCacheItem::operator> (const CCacheItem &item) const
{
	const CBasisForInference::size_type thisSize = BasisForInference.size();
	const CBasisForInference::size_type otherSize = item.BasisForInference.size();

	if (thisSize > otherSize)
		return true;

	if (thisSize < otherSize)
		return false;

	// same length, use lexicographical order.
	return (BasisForInference > item.BasisForInference);
}


// NOTE: Must call FindCacheItem first and not call this 
// function to prevent duplicate records from going into cache
bool CCache::AddCacheItem(
	const CBasisForInference &BasisForInference, 
	const CRecommendations &Recommendations)
{
	if (GetCount() >= MAXCACHESIZE)
		listItems.pop_back();

	try
	{
		CCacheItem item(BasisForInference, Recommendations);
		listItems.push_front(item);

		if (listItems.size() >= k_CacheSizeMax)
			listItems.pop_back();

		return true;	// always succeeds
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 

		return( false );
	}
}

bool CCache::FindCacheItem(
	const CBasisForInference &BasisForInference, 
	CRecommendations &Recommendations /* output */) const
{
	Recommendations.clear();
	CCacheItem item(BasisForInference, Recommendations /* effectively, a dummy */ );

	const list<CCacheItem>::const_iterator itBegin = listItems.begin();
	const list<CCacheItem>::const_iterator itEnd = listItems.end();
	const list<CCacheItem>::const_iterator itMatch = find(itBegin, itEnd, item);

	if (itMatch == itEnd)
		return false;

	Recommendations = itMatch->GetRecommendations();
	return true;
}

UINT CCache::GetCount() const
{
	return listItems.size();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtscounters.h ===
//
// MODULE: ApgtsCounters.h
//
// PURPOSE: interface and implementation for the CApgtsCounters class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10-01-1998
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-01-98	JM		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APGTSCOUNTERS_H__E3FD52E9_5944_11D2_9603_00C04FC22ADD__INCLUDED_)
#define AFX_APGTSCOUNTERS_H__E3FD52E9_5944_11D2_9603_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "counter.h"

// There should be exactly one (global) instance of this class.
// Any other class C that needs access to these counters should get a pointer to
//	the relevant counter(s) in its own constructor and thereafter access the counter
//	through the member.
// If class C only needs to increment the counter, it's pointer to the CHourlyDailyCounter
//	should be of type CAbstractCounter.
// A single .cpp file should define APGTS_COUNTER_OWNER before including the present file.
class CApgtsCounters
{
public:
	CHourlyDailyCounter m_ProgramContemporary; // really just used to track when program started.
	CHourlyDailyCounter m_StatusAccesses;
	CHourlyDailyCounter m_OperatorActions;
	CHourlyDailyCounter m_AllAccessesStart;
	CHourlyDailyCounter m_AllAccessesFinish;
	CHourlyDailyCounter m_QueueFullRejections;
	CHourlyDailyCounter m_UnknownTopics;
	CHourlyDailyCounter m_LoggedErrors;

	CApgtsCounters()
		:	m_ProgramContemporary(CCounterLocation::eIdProgramContemporary),
			m_StatusAccesses(CCounterLocation::eIdStatusAccess),
			m_OperatorActions(CCounterLocation::eIdActionAccess),
			m_AllAccessesStart(CCounterLocation::eIdTotalAccessStart),
			m_AllAccessesFinish(CCounterLocation::eIdTotalAccessFinish),
			m_QueueFullRejections(CCounterLocation::eIdRequestRejected),
			m_UnknownTopics(CCounterLocation::eIdRequestUnknown),
			m_LoggedErrors(CCounterLocation::eIdErrorLogged)
	{}
	~CApgtsCounters() {}
};

#ifdef APGTS_COUNTER_OWNER
	CApgtsCounters g_ApgtsCounters;
#else
	extern CApgtsCounters g_ApgtsCounters;
#endif

#endif // !defined(AFX_APGTSCOUNTERS_H__E3FD52E9_5944_11D2_9603_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtshtiscan.h ===
// apgtshtiscan.h: interface for the CAPGTSHTIScanner class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APGTSHTISCAN_H__05C561A4_6C50_11D3_8D37_00C04F949D33__INCLUDED_)
#define AFX_APGTSHTISCAN_H__05C561A4_6C50_11D3_8D37_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "apgtshtiread.h"

class CAPGTSHTIScanner : protected CAPGTSHTIReader  
{
public:
	CAPGTSHTIScanner(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
	CAPGTSHTIScanner(const CAPGTSHTIReader& htiReader);
	~CAPGTSHTIScanner();

public:
	bool Read();
	void Scan(const CHTMLFragments& fragments);

protected:	
	virtual void ParseInterpreted();
};

inline bool CAPGTSHTIScanner::Read()
{
	return CAPGTSHTIReader::Read();	
}

#endif // !defined(AFX_APGTSHTISCAN_H__05C561A4_6C50_11D3_8D37_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsecb.cpp ===
//
// MODULE: APGTSECB.CPP
//
// PURPOSE: Implementation of CAbstractECB class, which provides an abstraction from Win32's
//	EXTENSION_CONTROL_BLOCK.  Using this abstract class allows us to have common code for
//	the Online Troubleshooter (which actually uses an EXTENSION_CONTROL_BLOCK) and the Local
//	Troubleshooter (which needs to simulate similar capabilities).
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-04-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-04-99	JM		Original
//

#include "stdafx.h"
#include "apgtsECB.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtshtiscan.cpp ===
// apgtshtiscan.cpp: implementation of the CAPGTSHTIScanner class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "event.h"
#include "apgtshtiscan.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAPGTSHTIScanner::CAPGTSHTIScanner(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /*= NULL*/)
				: CAPGTSHTIReader(pPhysicalFileReader, szDefaultContents)
{
}

CAPGTSHTIScanner::CAPGTSHTIScanner(const CAPGTSHTIReader& htiReader)
				: CAPGTSHTIReader(htiReader)
{
}

CAPGTSHTIScanner::~CAPGTSHTIScanner()
{
}

void CAPGTSHTIScanner::Scan(const CHTMLFragments& fragments)
{
	LOCKOBJECT();
	try
	{
		m_pFragments = &fragments;
		InitializeInterpreted();
		////Interpret(); - NO interpretation here, we are scanning data, 
		////			  which is read from HTI file and not modified
		ParseInterpreted();
		SetOutputToInterpreted();
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();
}

void CAPGTSHTIScanner::ParseInterpreted()
{
	for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
	{
		CString command;

		if (GetCommand(*i, command))
		{
			if (command == COMMAND_VALUE)
			{
				CString variable;

				if (GetVariable(*i, variable))
					const_cast<CHTMLFragments*>(m_pFragments)->SetValue(variable);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtshtiread.h ===
//
// MODULE: APGTSHTIREAD.H
//
// PURPOSE: HTI template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __APGTSHTIREAD_H_
#define __APGTSHTIREAD_H_

#include "templateread.h"
#include "HTMLFrag.h"


// these are not really commands, just service symbols
#define COMMAND_STARTSTR		_T("<!GTS")
#define COMMAND_ENDSTR			_T(">")
#define COMMAND_IFSTR			_T("if")
#define COMMAND_STARTVARSTR		_T("$")
// JSM V3.2 -- used to decode string argumentss
#define COMMAND_DOUBLEQUOTE _T("\"")
#define COMMAND_ESCAPECHAR _T("\\")       
// commands that have to be interpreted
#define COMMAND_ELSESTR			_T("else")
#define COMMAND_ENDIFSTR		_T("endif")
#define COMMAND_FORANYSTR		_T("forany")
#define COMMAND_ENDFORSTR		_T("endfor")
// commands that presume putting substitution string on their place
#define COMMAND_DISPLAYSTR		_T("display")
#define COMMAND_RESOURCESTR		_T("resource")
// command that brings general information, that can be processed
//  in classes inherited from CHTMLFragmentsTS
#define COMMAND_INFORMATION		_T("information")
// command that makes CHTMLFragmentsTS store some value
#define COMMAND_VALUE			_T("value")
// command that substitutes Network Property in the HTML:
#define COMMAND_PROPERTY		_T("property")
//

// V3.2 Additions.
#define COMMAND_ELSEIFSTR		_T("elseif")
#define COMMAND_COOKIE			_T("<!Cookie")

#define DELIMITER_POSTFIX		_T("!")
#define DELIMITER_PREFIX		_T("_")

//
// NO error handling here - whatever the result is, it will be accepted, 
//  the program flow should go to the end. NO throw exception.
//

///////////////////////////////////////////////////////////////////////////////////////////
// CAPGTSHTIReader
//  Term "Interpret" here is: unwind initial script with <!GTS forany $Something> or
//	<!GTS if $Something> to <!GTS forany $Something!24_SomethingElse!2...>
//  This interpreted script is to be ready for direct substitutions of <!GTS display ...>
//  and <!GTS resource ...>, which are only commands left in the interpreted script
///////////////////////////////////////////////////////////////////////////////////////////
class CAPGTSHTIReader : public CTemplateReader
{
protected:	// we can use data in inherited class
	vector<CString>  m_arrInterpreted; // (partly) interpreted template - some clauses 
									   //  are interpreted, when fully parsed - ready
									   //  for simple template substitution.
	const CHTMLFragments*  m_pFragments;
	
public:
	CAPGTSHTIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CAPGTSHTIReader();

protected:
	virtual void Parse(); // do nothing - no traditional parsing, we first have to interpret

public:
	void CreatePage(	const CHTMLFragments& fragments, 
						CString& out, 
						const map<CString,CString> & mapStrs,
						CString strHTTPcookies= _T("") );

	bool HasHistoryTable();

	// JSM V3.2 returns a vector containing all net props which appear
	//  in the HTI file in lines like <!GTS property "fooprop">
	void ExtractNetProps(vector<CString> &arr_props);

protected:
	// level below CreatePage(...) 
	virtual void InitializeInterpreted();	// init string array with data read from HTI file
	virtual void Interpret();				// zoom this template in a simple template where all we need is string substitution
	virtual void ParseInterpreted();		// perform this substitution
	virtual void SetOutputToInterpreted();  // set standard template output (m_StreamOutput)
											//  from interpreted m_arrInterpreted
	//
	// we can read output by CTemplateReader::GetOutput();
	//
protected:
	// level below ...Interpret...(...)
	bool ExtractClause(vector<CString>& arr_text,
					   long* pstart_index,
					   vector<CString>& arr_clause);
	bool InterpretClause(vector<CString>& arr_clause);
protected:
	// used by previous ExtractClause
	// 	start_index is supposed to be positioned to beginning of clause
	bool ExtractClause(vector<CString>& arr_text,
					   long* pstart_index,
					   vector<CString>& arr_clause,
					   const CString& str_start_command,
					   const CString& str_end_command);
	// used by InterpretClause
	bool InterpretForanyClause(vector<CString>& arr_clause);
	bool InterpretIfClause(vector<CString>& arr_clause);
	// lowest level - parsing and changing <!GTS &...> - strings
	//  This function extracts command from line
	bool GetCommand(const CString& line, CString& command);
	//  This command composes <!GTS operator $variable>
	bool ComposeCommand(const CString& oper, const CString& variable, CString& command);
	//  This function extracts variable from line
	bool GetVariable(const CString& line, CString& variable);
	//  This function parses variable like Recommendations!199_States!99 into array
	void ParseVariable(const CString& variable, FragmentIDVector& out);
	//  This function composes variable from array
	void ComposeVariable(const FragmentIDVector& parsed, CString& variable);
	//  This function substitutes <!GTS ....> in "line" with "str_substitution"
	bool SubstituteCommandBlockWith(const CString& str_substitution, CString& line);
	// This function composes command block <!GTS command $variable >
	void ComposeCommandBlock(const CString& command, const CString& variable, CString& command_block);

	// NOTION of prefix - postfix. Prefix - parent variable, delimited by "_" from our variable,
	//  and postfix - number, delimited from our variable by "!"
	
	//  This function forms variable like Recommendations!11 where postfix == 11
	void PostfixVariable(const long postfix, CString& variable);
	//  This function forms variable like Recommendations!1_State where prefix == Recommendations!1
	void PrefixVariable(const CString& prefix, CString& variable);

private:
	// VERY low level
	//  This function reads command and variable from the <!GTS command $variable > block
	bool GetCommandVariableFromControlBlock(const CString& control_block, CString& command, CString& variable);
	//  This function reads command block (<!GTS command $variable >) from line
	bool GetControlBlockFromLine(const CString& line, CString& control_block);
	
	// JSM V3.2
	// extracts a string argument from a part of the command block; called by GetCommandVariableFromControlBlock
	CString GetStringArg(const CString & strText);
	// Converts a double-quoted string w/ an `escape character' to a correct CString.
	CString GetEscapedText(const CString &strText);
	// utility function called by the above:
	CString RemoveEscapesFrom(const CString &strIn);


#ifdef __DEBUG_CUSTOM
public:
	bool FlushOutputStreamToFile(const CString& file_name);
#endif

private:
	// This function handles the substituting of "<!Cookie" clauses with the either
	// values from cookies or the default value.
	void	SubstituteCookieValues( CString& strText );
	
	// This function searches the HTTP cookies for a given cookie name and attribute.  If
	// found, this function returns a value of true and the located cookie value.
	bool	LocateCookieValue(	const CString& strCookieName,
								const CString& strCookieAttr,
								CString& strCookieValue );
private:
	CString m_strHTTPcookies;	// V3.2 Enhancement, contains cookies from HTTP header
								// which are used in the Online Troubleshooter.
	map<CString,CString> m_mapCookies;
};

#endif // __APGTSHTIREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtshtiread.cpp ===
//
// MODULE: APGTSHTIREAD.CPP
//
// PURPOSE: HTI template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-27-98
//
// NOTES: 
// 1. HTI is loosely modeled on a Microsoft format called HTX.  It's a template for an 
//		HTML file.  Most of it is HTML, but certain pseudo-comments of the form 
//		<!GTS whatever> are intended to be interpreted as conditionals, places to 
//		insert text, etc. 
//
//		Variables are limited to the values 
//			$ProblemAsk
//			$Recommendations
//			$States
//			$Questions
//			$Success (introduced 9/24/98)
//			$StartForm
//		See class CHTMLFragmentsTS for more details. 

//		Commands are if/else/endif, forany/endfor, display
//			There is also a notion of a "resource", basically an include file.
//
//		EXAMPLE 1
//		<!GTS forany $States >
//		<!GTS display $States >
//		<!GTS endfor>
//
//		EXAMPLE 2
//		<!GTS if $ProblemAsk >
//			lots of HTML or nested calls to more GTS stuff could go here
//		<!GTS else >
//			lots of other HTML or nested calls to other GTS stuff could go here
//		<!GTS endif >
//	
//	each <!GTS...> command must fit on a single line.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include "apgtshtiread.h"
#include "event.h"
#include "CharConv.h"
#include "apgtsMFC.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "htmlfraglocal.h"
#endif

namespace
{
	CString k_strHTMLtag= _T("/HTML");
}

///////////////////////////////////////////////////////////////////////////////////////////
// CAPGTSHTIReader
///////////////////////////////////////////////////////////////////////////////////////////
CAPGTSHTIReader::CAPGTSHTIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /* NULL */)
			   : CTemplateReader(pPhysicalFileReader, szDefaultContents),
				 m_pFragments(NULL) 
{
}

CAPGTSHTIReader::~CAPGTSHTIReader()
{
}

void CAPGTSHTIReader::Parse()
{
#ifdef LOCAL_TROUBLESHOOTER
	// OVERVIEW:  For the Local Troubleshooter, search for a <!GTS resource $Previous.script>
	// token in the stream. If one is not found, then insert one for backwards 
	// compatibility.
	try
	{
		// Load the stream into a vector while searching for a "Previous.script" token and also
		// determining the position of the last closing HTML tag location in order to know where 
		// to insert the generated_previous() function.
		CString str;
		vector<CString> str_arr;
		long indexLastHTML = -1;

		// Place the content of m_StreamData, line by line, into str_arr
		SetPos( m_StreamData, 0 );
		while (GetLine( m_StreamData, str ))
		{
			// Determine whether or not this line contains the "Previous.script" token.
			CString strCommand;
			if (GetCommand( str, strCommand))
			{
				// Check if the command is the right type.
				if (strCommand == COMMAND_RESOURCESTR)
				{
					CString strVariable;
					if (GetVariable( str, strVariable ))
					{
						// Check if the variable is the right type.
						if (strVariable == VAR_PREVIOUS_SCRIPT)
						{
							// We found what we were looking for.
							// Reset the stream position and exit function.
							SetPos( m_StreamData, 0 );
							return;
						}
					}
				}
			}
			
			// Add this line to the vector.
			str_arr.push_back( str );

			// Look for an HTML closing tag in this line.
			if (str.Find( k_strHTMLtag ) != -1)
			{
				// Mark the location of the last \HTML tag found.
				indexLastHTML= str_arr.size() - 1;
			}
		}

		// Rebuild the input stream from the vector and insert the "Previous.script" token
		// in the location determined above.
		vector<CString>::iterator iLastElement = str_arr.end();
		iLastElement--;	
		m_StreamData.clear();
		CString strResult;

		long index = 0;
		for (vector<CString>::iterator i = str_arr.begin(); i < str_arr.end(); i++, index++)
		{
			if (index == indexLastHTML)
			{
				// Add the required token to the string.
				strResult+= COMMAND_STARTSTR;
				strResult+= _T(" ");
				strResult+= COMMAND_RESOURCESTR;
				strResult+= _T(" ");
				strResult+= COMMAND_STARTVARSTR;
				strResult+= VAR_PREVIOUS_SCRIPT;
				strResult+= COMMAND_ENDSTR;
				strResult+= _T("\r\n");
			}
			
			strResult += *i;
		
			if (i != iLastElement)
				strResult+= _T("\r\n");
		}
		m_StreamData.str( (LPCTSTR) strResult );
		SetPos( m_StreamData, 0 );
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
#endif
}

// JSM V3.2 adapted from CreatePage()
//  builds list of all Network props in this HTI file which appear
//   in lines like <!GTI property "fooprop">
//
//  called by apgtscontext to find network properties to pass to CHTMLFragmentsTS 
void CAPGTSHTIReader::ExtractNetProps(vector <CString> &arr_props)
{
	LOCKOBJECT();
	try
	{
		arr_props.clear();
		// InitializeInterpreted populates m_arrInterpreted and
		//   performs cookie substitutions. This is correct behavior,
		//   because cookie substitution is supposed to happen
		//   before !GTS processing, and it is conceivable
		//   that a cookie's value could be "<!GTS property fooprop>"
		InitializeInterpreted();
		// we should not call Interpret(), which involves parsing <!GTS clauses
		for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
		{
			CString command;
			if (GetCommand(*i, command))
			{
				if (command == COMMAND_PROPERTY)
				{
					CString strProperty;
					if (GetVariable(*i,strProperty))
						arr_props.push_back(strProperty);
				}
			}
		}
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();
}


void CAPGTSHTIReader::CreatePage(	const CHTMLFragments& fragments, 
									CString& out, 
									const map<CString,CString> & mapStrs,
									CString strHTTPcookies/*= _T("")*/ )
{
	LOCKOBJECT();
	try
	{
		m_pFragments = &fragments;

		// V3.2 Cookie related enhancement.
		// Opted to use a member variable rather than modifying class interface by
		// adding a parameter to virtual void method InitializeInterpreted().
		m_strHTTPcookies= strHTTPcookies;
		m_mapCookies= mapStrs;

		InitializeInterpreted();
		Interpret();
#ifdef __DEBUG_CUSTOM
		SetOutputToInterpreted();
		FlushOutputStreamToFile("..\\Files\\interpreted.hti");
#endif
		ParseInterpreted();
		SetOutputToInterpreted();
#ifdef __DEBUG_CUSTOM
		FlushOutputStreamToFile("..\\Files\\result.htm");
#endif
		out = m_StreamOutput.rdbuf()->str().c_str();
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();
}

void CAPGTSHTIReader::InitializeInterpreted()
{
	long savePos = 0;
	CString str;
	CString command;
	bool bOldFormat = true; // this is an old format (without $Success or $StartForm)
	bool bFoundFirstBlock= false;
	
	savePos = GetPos();
	bOldFormat = !Find(CString(COMMAND_STARTVARSTR)+VAR_SUCCESS) &&
			     !Find(CString(COMMAND_STARTVARSTR)+VAR_STARTFORM);
	SetPos(0);
	m_arrInterpreted.clear();

	try
	{
		while (GetLine(str)) 
		{
			if (bOldFormat && (!bFoundFirstBlock) && (-1 != str.Find( COMMAND_STARTSTR )))
			{
				// Output the $StartForm block only if it is not a resource string command.
				CString strCommand;
				if ((GetCommand( str, strCommand )) && (strCommand != COMMAND_RESOURCESTR))
				{
					/*
					<!GTS if $StartForm>
					<!GTS display $StartForm>
					<!GTS endif>
					*/
					ComposeCommand(COMMAND_IFSTR, VAR_STARTFORM, command);
					m_arrInterpreted.push_back(command);
					ComposeCommand(COMMAND_DISPLAYSTR, VAR_STARTFORM, command);
					m_arrInterpreted.push_back(command);
					ComposeCommand(COMMAND_ENDIFSTR, _T(""), command);
					m_arrInterpreted.push_back(command);

					bFoundFirstBlock = true;
				}
			}

			if (bOldFormat && (-1 != str.Find(_T("</FORM>"))))
			{
				/*
				<!GTS if $StartForm>
				*/
				ComposeCommand(COMMAND_IFSTR, VAR_STARTFORM, command);
				m_arrInterpreted.push_back(command);

				m_arrInterpreted.push_back(str);
				/*
				<!GTS endif>
				*/
				ComposeCommand(COMMAND_ENDIFSTR, _T(""), command);
				m_arrInterpreted.push_back(command);
			}
			else
			{
				// Check if we need to populate any cookie clauses.
				if (-1 != str.Find( COMMAND_COOKIE ))
					SubstituteCookieValues( str );

				m_arrInterpreted.push_back(str);
			}
		}
	}
	catch (exception& x)
	{
		CString str2;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str2), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	SetPos(savePos);
}

void CAPGTSHTIReader::Interpret()
{
	long curr_index = 0;
	long lLastIndex= -1;	// Used to detect a HTI file with incomplete clauses.

	while(true)
	{
		vector<CString> clause_arr;

		// tries to extract clause from m_arrInterpreted starting with curr_index
		//  and remove it from m_arrInterpreted
		if (ExtractClause(m_arrInterpreted,
						  &curr_index, // in - out
						  clause_arr))
		{
			// Reset the infinite loop detection counter.
			lLastIndex= -1;

			// Now curr_index is pointing to next element 
			//  of m_arrInterpreted (after removed clause) 
			//  OR OUTSIDE boundary of m_arrInterpreted.
			if (InterpretClause(clause_arr))
			{
				vector<CString>::iterator i = m_arrInterpreted.begin();
				{	// create iterator that points to m_arrInterpreted[curr_index]
					//  or is m_arrInterpreted.end()
					long tmp_index = curr_index;
					while(tmp_index--)
						i++;
				}

				try
				{
					// insert interpreted clause there
					for (vector<CString>::iterator j = clause_arr.begin(); j < clause_arr.end(); j++)
					{
						i = m_arrInterpreted.insert(i, *j); // inserts before "i"
						i++;
						curr_index++;
					}
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
		else
		{
			// If this condition is true, then we are in an infinite loop due to a bad HTI file.  
			if (lLastIndex == curr_index)
			{
				// Log that this HTI file does not parse correctly.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										GetPathName(), _T(""), 
										EV_GTS_BAD_HTI_FILE );		
				break;
			}

			// Update the infinite loop detection counter.
			lLastIndex= curr_index;

			if (curr_index)	{
				// we finished current pass of m_arrInterpreted, start new one
				curr_index = 0;
				continue;
			}
			else {
				// we can not extract clause though we start from beginning - 
				//  m_arrInterpreted is interpreted now
				break;
			}
		}
	}
}
// modified V3.2 JSM
void CAPGTSHTIReader::ParseInterpreted()
{
	for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
	{
		CString command;

		if (GetCommand(*i, command))
		{
			if (command == COMMAND_DISPLAYSTR ||
			    command == COMMAND_RESOURCESTR ||
			    command == COMMAND_INFORMATION
			   )
			{
				CString variable;

				if (GetVariable(*i, variable))
				{
					CString substitution;
					FragmentIDVector arr_fragment;

					ParseVariable(variable, arr_fragment);
					substitution = const_cast<CHTMLFragments*>(m_pFragments)->GetText(arr_fragment, (command == COMMAND_RESOURCESTR) ? CHTMLFragments::eResource : CHTMLFragments::eNotOfInterest );
					SubstituteCommandBlockWith(substitution, *i);
				}
				else // obvious misbehaviour - "display" command should have variable
					SubstituteCommandBlockWith(_T(""), *i);
			}
			else if (command == COMMAND_VALUE)
			{
				CString variable;

				if (GetVariable(*i, variable))
					const_cast<CHTMLFragments*>(m_pFragments)->SetValue(variable);

				SubstituteCommandBlockWith(_T(""), *i);
			}
			//  V3.2 JSM
			else if (command == COMMAND_PROPERTY)
			{
				CString strProperty;
				if (GetVariable(*i,strProperty))
				{
					CString substitution;
					substitution = const_cast<CHTMLFragments*>(m_pFragments)->GetNetProp(strProperty);
					SubstituteCommandBlockWith(substitution, *i);
				}
				else // obvious misbehaviour - "property" command should have variable
					SubstituteCommandBlockWith(_T(""), *i);
			} // end V3.2 JSM
			else // obvious misbehaviour - no other commands
				SubstituteCommandBlockWith(_T(""), *i);
		}
	}
}

void CAPGTSHTIReader::SetOutputToInterpreted()
{
	vector<CString>::iterator j = m_arrInterpreted.end();

	// Decrement to point to last element.
	j--;
	m_StreamOutput.str(_T(""));
	for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
	{
		m_StreamOutput << (LPCTSTR)*i;
		if (i != j) // not last element
			m_StreamOutput << _T('\r') << _T('\n');
	}
	m_StreamOutput << ends;
}

// INPUT:  arr_text (with clause)
// IMPUT:  *pstart_index - index in arr_text
// OUTPUT: arr_text without clause
// OUTPUT: *pstart_index points to element in arr_text next to where 
//          clause used to be or outside arr_text
// OUTPUT: arr_clause - extracted clause
bool CAPGTSHTIReader::ExtractClause(vector<CString>& arr_text,
								    long* pstart_index,
								    vector<CString>& arr_clause) 
{
	if (*pstart_index > arr_text.size() - 1) // quite possible
		return false;

	for (long i = *pstart_index; i < arr_text.size(); i++)
	{
		CString str_command;

		if (GetCommand(arr_text[i], str_command))
		{
			if (str_command == COMMAND_FORANYSTR)
			{
				if (ExtractClause(arr_text,
								  &i,
								  arr_clause,
								  COMMAND_FORANYSTR,
								  COMMAND_ENDFORSTR))
				{
					*pstart_index = i;
					return true;
				}
				else
				{
					*pstart_index = i;
					return false;
				}
			}
			if (str_command == COMMAND_IFSTR)
			{
				if (ExtractClause(arr_text,
								  &i,
								  arr_clause,
								  COMMAND_IFSTR,
								  COMMAND_ENDIFSTR))
				{
					*pstart_index = i;
					return true;
				}
				else
				{
					*pstart_index = i;
					return false;
				}
			}
		}
	}
	return false;
}

bool CAPGTSHTIReader::ExtractClause(vector<CString>& arr_text,
								    long* pstart_index,
								    vector<CString>& arr_clause,
									const CString& str_start_command,
								    const CString& str_end_command)
{
	CString str_command;
	long start = *pstart_index, end = *pstart_index;
	long nest_level_counter = 1;

	while (++end < arr_text.size())
	{
		if (GetCommand(arr_text[end], str_command))
		{
			if (str_command == str_start_command)
			{
				nest_level_counter++;
			}
			if (str_command == str_end_command)
			{
				nest_level_counter--;
				if (!nest_level_counter)
				{
					vector<CString>::iterator start_it = arr_text.begin();
					vector<CString>::iterator   end_it = arr_text.begin();
					
					arr_clause.clear();
					try
					{   
						// copy clause to arr_clause
						for (long j = start; j <= end; j++)
							arr_clause.push_back(arr_text[j]);
					}
					catch (exception& x)
					{
						CString str;
						// Note STL exception in event log.
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												CCharConversion::ConvertACharToString(x.what(), str), 
												_T(""), 
												EV_GTS_STL_EXCEPTION ); 
					}

					// make iterators correspond indexes
					while(start--)
						start_it++;
					while(end--)
						end_it++;
					// and, because we want to delete element pointed 
					//  at this moment by end_it:
					end_it++; 
					// remove clause from arr_text
					arr_text.erase(start_it, end_it);
					return true;
				}
			}
		}
	}
	*pstart_index = --end;;
	return false;
}

bool CAPGTSHTIReader::InterpretClause(vector<CString>& arr_clause)
{
	CString str_command;

	if (arr_clause.size() &&
		GetCommand(arr_clause[0], str_command))
	{
		if (str_command == COMMAND_FORANYSTR)
			return InterpretForanyClause(arr_clause);
		if (str_command == COMMAND_IFSTR)
			return InterpretIfClause(arr_clause);
		return false;
	}
	return false;
}

bool CAPGTSHTIReader::InterpretForanyClause(vector<CString>& arr_clause)
{
	long count = 0;
	CString strVariable; // variable from 1-st line of arr_clause
	vector<CString> arrUnfolded;
	FragmentIDVector arrVariable; // array from strVariable

	if (arr_clause.size() < 2) // "forany" and "endfor" commands
		return false;

	if (!GetVariable(arr_clause[0], strVariable))
		return false;

	ParseVariable(strVariable, arrVariable);
	
	count = m_pFragments->GetCount(arrVariable);

	try
	{
		for (long i = 0; i < count; i++)
		{
			for (long j = 1; j < arr_clause.size() - 1; j++)
			{
				CString command, variable;

				if (GetCommand(arr_clause[j], command) &&
					GetVariable(arr_clause[j], variable))
				{
					if (command == COMMAND_FORANYSTR && variable == strVariable) 
					{
						// if it is clause "forany" with the same variable,
						//  there should be neither prefixing nor postfixing
					}
					else
					{
						CString line = arr_clause[j];

						if (variable == strVariable) 
						{
							PostfixVariable(i, variable);
						} 
						else 
						{
							FragmentIDVector parents, children;
							CString strVariable_postfixed = strVariable;
							PostfixVariable(i, strVariable_postfixed);

							ParseVariable(strVariable_postfixed, parents);
							ParseVariable(variable, children);
							if (m_pFragments->IsValidSeqOfVars(parents, children))
								PrefixVariable(strVariable_postfixed, variable);
						}
						CString command_block;
						ComposeCommandBlock(command, variable, command_block);
						SubstituteCommandBlockWith(command_block, line);
						arrUnfolded.push_back(line);
						continue;
					}
				}
				arrUnfolded.push_back(arr_clause[j]);
			}
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	arr_clause = arrUnfolded;
	return true;
}

bool CAPGTSHTIReader::InterpretIfClause(vector<CString>& arr_clause)
{
	CString strVariable; // variable from a line of arr_clause
	FragmentIDVector arrVariable;

	if (arr_clause.size() < 2) // "if" and "endif" commands
		return false;

	if (!GetVariable( arr_clause[ 0 ], strVariable ))
		return false;
	
	ParseVariable( strVariable, arrVariable );

	// Scan for "if", "elseif", "else", and "endif" commands
	vector<int> arrElseIfIndices;
	int elseIndex = -1; // index of "else" inside arr_clause
	int i = 0;
	int nDepthOfNesting;	
	for (i= 1, nDepthOfNesting= 0; i < arr_clause.size() - 1; i++)
	{
		CString command;
		if (GetCommand(arr_clause[i], command))
		{
			if (command == COMMAND_IFSTR)
			{
				nDepthOfNesting++;
			}
			else if (command == COMMAND_ENDIFSTR)
			{
				nDepthOfNesting--;
			}
			else if (command == COMMAND_ELSEIFSTR)
			{
				// V3.2 - Check if this elseif clause is at the level we are looking for.
				if (nDepthOfNesting == 0) 
					arrElseIfIndices.push_back( i );
			}
			else if (command == COMMAND_ELSESTR)
			{
				// Check if this else clause is at the level we are looking for.
				if (nDepthOfNesting == 0) 
				{
					elseIndex = i;
					break;
				}
			}
		}
	}


	vector<CString> arrBody; // intermediate array
	try
	{
		CString strName; // name of strVariable associated through CHTMLFragments
		strName = const_cast<CHTMLFragments*>(m_pFragments)->GetText(arrVariable);
		if (strName.GetLength())
		{   
			// Standard processing of what is inside if ... else (or endif)
			int nEndOfClause= (arrElseIfIndices.size()) ? arrElseIfIndices[ 0 ] : elseIndex;
			for (i = 1; i < (nEndOfClause == -1 ? arr_clause.size() - 1 : nEndOfClause); i++)
				arrBody.push_back(arr_clause[i]);
		}
		else
		{   
			// Process any elseif or else clauses.
			bool bDoneProcessing= false;
			for (int nElseIf= 0; nElseIf < arrElseIfIndices.size(); nElseIf++)
			{
				if (!GetVariable( arr_clause[ arrElseIfIndices[ nElseIf ] ], strVariable ))
					return false;
	
				ParseVariable( strVariable, arrVariable );

				strName = const_cast<CHTMLFragments*>(m_pFragments)->GetText(arrVariable);
				if (strName.GetLength())
				{
					// Determine the ending point of this elseif clause and extract all clauses within.
					int nEndOfClause= ((nElseIf + 1) < arrElseIfIndices.size()) 
										? arrElseIfIndices[ nElseIf + 1 ] : elseIndex;
					for (i= arrElseIfIndices[ nElseIf ] + 1; i < nEndOfClause; i++)
						arrBody.push_back( arr_clause[ i ] );
				
					bDoneProcessing= true;
					break;
				}
			}

			if ((!bDoneProcessing) && (elseIndex != -1))
			{
				// All of the clauses failed, output all clauses following the "else".
				for (i = elseIndex + 1; i < arr_clause.size() - 1; i++)
					arrBody.push_back(arr_clause[i]);
			}
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
	
	arr_clause = arrBody;
	return true;
}

bool CAPGTSHTIReader::GetCommand(const CString& line, CString& command)
{
	CString control_block;
	CString variable;

	if (GetControlBlockFromLine(line, control_block))
		if (GetCommandVariableFromControlBlock(control_block, command, variable))
			return true;
	
	return false;
}

bool CAPGTSHTIReader::ComposeCommand(const CString& oper, const CString& variable, CString& command)
{
	command = _T("");
	LPCTSTR ws = _T(" ");

	command += COMMAND_STARTSTR;
	command += ws;
	command += oper;
	if (variable.GetLength()) {
		command += ws;
		command += COMMAND_STARTVARSTR;
		command += variable;
	}
	command += COMMAND_ENDSTR;
	
	return true;
}

bool CAPGTSHTIReader::GetVariable(const CString& line, CString& arg_variable)
{
	CString control_block;
	CString command, variable;

	if (GetControlBlockFromLine(line, control_block))
		if (GetCommandVariableFromControlBlock(control_block, command, variable))
			if (variable.GetLength()) {
				arg_variable = variable;
				return true;
			}
	return false;
}

void CAPGTSHTIReader::ParseVariable(const CString& variable, FragmentIDVector& out)
{
	vector<CString> arrStr;
	int start_index = 0;
	int end_index = -1;

	try
	{
		// arrStr contains strings between delimiter "_"
		while(-1 != (end_index = CString((LPCTSTR)variable + start_index).Find(DELIMITER_PREFIX)))
		{
			// end_index here is from "(LPCTSTR)variable + start_index" string
			//  so we can use it as length (2nd argument) in CString::Mid function
			arrStr.push_back(((CString&)variable).Mid(start_index, end_index));
			start_index = start_index + end_index + _tcslen(DELIMITER_PREFIX);
		}
		// pull the "tail" - after last (if any) "_"
		arrStr.push_back(((CString&)variable).Right(variable.GetLength() - start_index));

		out.clear();
		for (vector<CString>::iterator i = arrStr.begin(); i < arrStr.end(); i++)
		{
			FragmentID fragmentID;
			int curr = (*i).Find(DELIMITER_POSTFIX);
			
			if (-1 != curr)
			{
				fragmentID.VarName = (*i).Left(curr);

				curr += _tcslen(DELIMITER_POSTFIX); // skip delimiter
				
				CString strIndex = (LPCTSTR)(*i) + curr;
				strIndex.TrimLeft();
				strIndex.TrimRight();

				if (strIndex == _T("0"))
					fragmentID.Index = 0;
				else
					fragmentID.Index =    _ttol((LPCTSTR)strIndex) == 0 
										? fragmentID.Index 	// error occur
										: _ttol((LPCTSTR)strIndex);
			}
			else
				fragmentID.VarName = *i;

			out.push_back(fragmentID);
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

void CAPGTSHTIReader::ComposeVariable(const FragmentIDVector& arr_fragment, CString& variable)
{
	variable = _T("");

	for (FragmentIDVector::const_iterator i = arr_fragment.begin(); i < arr_fragment.end(); i++)
	{
		if (i != arr_fragment.begin())
			variable += DELIMITER_PREFIX;
		
		variable += (*i).VarName;

		if ((*i).Index != -1) 
		{
			TCHAR buf[128] = {0};

			variable += DELIMITER_POSTFIX;
			_stprintf(buf, _T("%d"), (*i).Index);
			variable += buf;
		}
	}
}

bool CAPGTSHTIReader::SubstituteCommandBlockWith(const CString& str_substitution, CString& line)
{
	int start_index = -1;
	int end_index = -1;

	if (-1 != (start_index = line.Find(COMMAND_STARTSTR)))
	{
		if (-1 != (end_index = CString((LPCTSTR)line + start_index).Find(COMMAND_ENDSTR)))
		{
			CString tmp;
			
			end_index += start_index;
			end_index += _tcslen(COMMAND_ENDSTR); // skip closing bracket

			tmp += line.Left(start_index);
			tmp += str_substitution;
			tmp += line.Right(line.GetLength() - end_index);

			line = tmp;
			return true;
		}
	}
	return false;
}

void CAPGTSHTIReader::ComposeCommandBlock(const CString& command, const CString& variable, CString& command_block)
{
	command_block  = COMMAND_STARTSTR;
	command_block += _T(" ");
	command_block += command;
	command_block += _T(" ");
	command_block += COMMAND_STARTVARSTR;
	command_block += variable;
	command_block += _T(" ");
	command_block += COMMAND_ENDSTR;
}

void CAPGTSHTIReader::PostfixVariable(const long postfix, CString& variable)
{
	TCHAR buf[128] = {0};
	
	_stprintf(buf, _T("%ld"), postfix);
	variable += DELIMITER_POSTFIX;
	variable += buf;
}

void CAPGTSHTIReader::PrefixVariable(const CString& prefix, CString& variable)
{
	CString tmp = variable;

	variable = prefix;
	variable += DELIMITER_PREFIX;
	variable += tmp;
}
// JSM V3.2 -- 
//   called by GetCommandVariableFromControlBlock to handle
//    decoding the variable part of commands like <!GTS property "fooprop">
//    finds the first string argument in strText, which is either:
//       any text beginning w/ anything other than '"', ending w/ whitespace or COMMAND_ENDSTR
//       all text between doublequote marks "...." where an escape char ('\') escapes the character following.
//
CString CAPGTSHTIReader::GetStringArg(const CString & strText)
{
	CString strArg = strText;

	// look for quoted text:
	int iStartQuote = strArg.Find(COMMAND_DOUBLEQUOTE);
	if (iStartQuote != -1)
	{
		strArg = strArg.Mid(iStartQuote);
		return GetEscapedText(strArg);
	}	
	// o/w, assume that we're dealing w/ ordinary text, which ends
	//  with first whitespace or with COMMAND_ENDSTR
	strArg.TrimLeft();

	int iWhiteSpace(0), iEndCmd(0);
	for(;(iWhiteSpace < strArg.GetLength()) && !(_istspace(strArg[iWhiteSpace])); iWhiteSpace++);

	iEndCmd = strArg.Find(COMMAND_ENDSTR);

	strArg = strArg.Left(min(iEndCmd,iWhiteSpace));
	return strArg;
}

// JSM V3.2
// Called by GetEscapedText
// recursive function which does the work of removing escapes (backslashes)
//  also checks for non-escaped endquote, which terminates the process
CString CAPGTSHTIReader::RemoveEscapesFrom(const CString &strIn)
{
	int iNextESC = strIn.Find(COMMAND_ESCAPECHAR);
	int iNextQuote = strIn.Find(COMMAND_DOUBLEQUOTE);

	//	(iNextQuote == -1) means a bad input, because the string
	//   we're looking at must terminate with quote.
	//   By default, however, we'll keep running to end of strIn.
	if (iNextQuote == -1)
		iNextQuote = strIn.GetLength();

	// no more escape chars
	if (iNextESC == -1 || (iNextESC > iNextQuote))
		return strIn.Left(iNextQuote);

	CString strEscapedChar;
	strEscapedChar = strIn.GetAt(iNextESC + _tcslen(COMMAND_ESCAPECHAR));
	return strIn.Left(iNextESC) +
		   strEscapedChar + 
		   RemoveEscapesFrom(strIn.Mid(iNextESC + _tcslen(COMMAND_ESCAPECHAR) + 1));
}

// Converts a double-quoted string using backslash as an escape character to a correct CString
CString CAPGTSHTIReader::GetEscapedText(const CString &strText)
{
	CString strEscaped;

	// remove leading quote and anything preceding:
	int iLeadQuote = strText.Find(COMMAND_DOUBLEQUOTE);
	if (iLeadQuote != -1)
	{
		strEscaped = RemoveEscapesFrom(strText.Mid(iLeadQuote + _tcslen(COMMAND_DOUBLEQUOTE)));
	}
	return strEscaped;
}

// JSM V3.2 added ability to read string arguments into variable
//  e.g. <!GTS property "FOO">
// 
bool CAPGTSHTIReader::GetCommandVariableFromControlBlock(const CString& control_block, CString& command, CString& variable)
{
	int start_command_index = -1;
	int end_command_index = -1;
	int start_variable_index = -1;
	int end_variable_index = -1;


	variable.Empty(); 
	command.Empty();

	start_command_index = control_block.Find(COMMAND_STARTSTR);
	if (start_command_index == -1)			          // invalid control block
		return false;
	start_command_index += _tcslen(COMMAND_STARTSTR); // skip prefix

	// extract the variable block, which can look like:
	//               ... $variable_name  ...
	//               ... "parameter_name\\\"" ... (text in quotes w/ backslash escape)
	//                   parameter_name           (plain text)
	if (-1 != (	end_command_index = (control_block.Mid(start_command_index)).Find(COMMAND_STARTVARSTR) ) )
	{
		// Variable prefixed with '$...'
		end_command_index += start_command_index; // make end_command_index relative to start of control block
		start_variable_index = end_command_index + _tcslen(COMMAND_STARTVARSTR); // skip "$"
		end_variable_index = control_block.Find(COMMAND_ENDSTR);

		// validation of indexes
		if (-1 == min(start_command_index, end_command_index) ||
			start_command_index > end_command_index)
			return false;

		command = ((CString&)control_block).Mid(start_command_index, end_command_index - start_command_index);
		command.TrimLeft();
		command.TrimRight();

		if (start_variable_index > end_variable_index)
			return false;
		if (-1 != start_variable_index)
		{
			// extract variable from "..$varname>"
			variable = ((CString&)control_block).Mid(start_variable_index, end_variable_index - start_variable_index);
			variable.TrimLeft();
			variable.TrimRight();
		}
	}
	else
	{
		// Not prefixed with $.
		// we don't know whether we're looking for a "\"quoted\"" or
		//  non-quoted string, or no variable at all.  Also, we need
		//  to handle special cases like:
		//           <!GTS parameter ">">
		//           <!GTS endfor >
		//  etc.
		command = ((CString&)control_block).Mid(start_command_index);
		command.TrimLeft();
		command.TrimRight();
		// step through looking for whitespace at end of command:
		int iWhiteSpace;
		for(iWhiteSpace = 0;
		    (iWhiteSpace < command.GetLength()) && !(_istspace(command[iWhiteSpace]));
			iWhiteSpace++);

		if (iWhiteSpace != command.GetLength())
		{
			// found whitespace; the rest of the string may be a variable:
			variable = GetStringArg(command.Mid(iWhiteSpace));
			command = command.Left(iWhiteSpace); // truncate command where appropriate
		}
		else
		{
			// If there wasn't a variable after the command, we
			//   may still need to truncate to remove the COMMAND_ENDSTR:
			end_command_index = command.Find(COMMAND_ENDSTR);
			if (end_command_index != -1)
				command = command.Left(end_command_index);
		}
	}


	return true;
}

bool CAPGTSHTIReader::GetControlBlockFromLine(const CString& line, CString& control_block)
{
	int start_index = -1;
	int end_index = -1;

	if (-1 == (start_index = line.Find(COMMAND_STARTSTR)))
		return false;
	if (-1 == (end_index = CString((LPCTSTR)line + start_index).Find(COMMAND_ENDSTR)))
		return false;

	end_index += _tcslen(COMMAND_ENDSTR); // points beyond closing bracket
	end_index += start_index; // points in "line" string

	control_block = ((CString&)line).Mid(start_index, end_index - start_index);
	control_block.TrimLeft();
	control_block.TrimRight();

	return true;
}

bool CAPGTSHTIReader::HasHistoryTable()
{
	bool bRet;

	LOCKOBJECT();
	CString indicator = CString(COMMAND_STARTVARSTR) + VAR_RECOMMENDATIONS;
	bRet= Find( indicator );
	UNLOCKOBJECT();

	return( bRet );
}

#ifdef __DEBUG_CUSTOM
#include <io.h>
#include <fcntl.h>
#include <sys\\stat.h>
bool CAPGTSHTIReader::FlushOutputStreamToFile(const CString& file_name)
{
	int hf = 0;
	
	hf = _open(
		file_name,
		_O_CREAT | _O_TRUNC | /*_O_TEMPORARY |*/
		_O_BINARY | _O_RDWR | _O_SEQUENTIAL ,
		_S_IREAD | _S_IWRITE 
	);
			
	if (hf != -1)
	{
		//tstringstream m_StreamOutput
		basic_string<TCHAR> str = m_StreamOutput.rdbuf()->str();
		long size = str.size();
		LPCTSTR buf = str.c_str();

		int ret = _write(hf, buf, size);

		_close(hf);

		if (-1 != ret)
			return true;
	}

	return false;
}
#endif

// V3.2 - Enhancement to support cookies.
// This function handles the substituting of "<!Cookie" clauses with the either
// values from cookies, "_CK" values passed in via Get/Post, or the default value.
void CAPGTSHTIReader::SubstituteCookieValues( CString& strText )
{
	CString strNewText;
	const CString kstr_CommaChar= _T(",");
	const CString kstr_DoubleQuote= _T("\"");

	// Loop until we have processed all cookie clauses.
	int nNumericCompareStart= strText.Find( kstrCond_NumericCompare );	
	int nCookieClauseStart= strText.Find( COMMAND_COOKIE );
	while (CString::FIND_FAILED != nCookieClauseStart)
	{
		CString strCookieClause;
		CString strCookieName, strCookieAttr, strCookieValue;
		int nCookieClauseEnd, nScratchMarker;
		
		// Add any text preceding the cookie clause to the return string.
		strNewText+= strText.Left( nCookieClauseStart );

		// Remove all preceding text.
		strText= strText.Mid( nCookieClauseStart + _tcslen( COMMAND_COOKIE ) );
		
		// Look for the ending clause.
		nCookieClauseEnd= strText.Find( COMMAND_ENDSTR );
		if (CString::FIND_FAILED == nCookieClauseEnd)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									COMMAND_ENDSTR, _T(""), 
									EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
			break;
		}

		// Pull out the current cookie clause and reset the working string.
		strCookieClause= strText.Left( nCookieClauseEnd );
		strText= strText.Mid( nCookieClauseEnd + 1 );

		// Extract the cookie name.
		nScratchMarker= strCookieClause.Find( kstr_CommaChar );
		if (CString::FIND_FAILED == nScratchMarker)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									kstr_CommaChar, _T(""), 
									EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
			break;
		}
		strCookieName= strCookieClause.Left( nScratchMarker );
		strCookieName.TrimLeft();
		strCookieName.TrimRight();

		// Extract the cookie setting.
		strCookieClause= strCookieClause.Mid( nScratchMarker + 1 );
		nScratchMarker= strCookieClause.Find( kstr_CommaChar );
		if (CString::FIND_FAILED == nScratchMarker)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									kstr_CommaChar, _T(""), 
									EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
			break;
		}
		strCookieAttr= strCookieClause.Left( nScratchMarker );
		strCookieAttr.TrimLeft();
		strCookieAttr.TrimRight();

		strCookieClause= strCookieClause.Mid( nScratchMarker + sizeof( TCHAR ) );

		// Attempt to locate the appropriate attribute/value pair, 
		// first checking the command line CK_ values, and
		// then checking the cookies passed in the HTTP header.
		bool bCookieNotFound= true;
		if (!m_mapCookies.empty())
		{
			// Search the command line CK_ values.
			map<CString,CString>::const_iterator iterMap= m_mapCookies.find( strCookieAttr );
			if (iterMap != m_mapCookies.end())
			{
				strCookieValue= iterMap->second;
				bCookieNotFound= false;
			}
		}
		if (bCookieNotFound)
		{
			if (!m_strHTTPcookies.IsEmpty())
			{
				// Attempt to locate the attribute in the HTTP header information.
				if (LocateCookieValue( strCookieName, strCookieAttr, strCookieValue ))
					bCookieNotFound= false;
			}
		}
		if (bCookieNotFound)
		{
			// Extract the default value for this attribute, which should be surrounded 
			//	by double quotes.
			nScratchMarker= strCookieClause.Find( kstr_DoubleQuote );
			if (CString::FIND_FAILED == nScratchMarker)
			{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										kstr_DoubleQuote, _T(""), 
										EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
				break;
			}
			strCookieClause= strCookieClause.Mid( nScratchMarker + sizeof( TCHAR ) );
			nScratchMarker= strCookieClause.Find( kstr_DoubleQuote );
			if (CString::FIND_FAILED == nScratchMarker)
			{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										kstr_DoubleQuote, _T(""), 
										EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
				break;
			}
			strCookieValue= strCookieClause.Left( nScratchMarker );
		}

		// Add the attribute value to the output string.  
		// >>> $MAINT - The determination of whether or not to output quotes should
		//				be improved.  I currently have no suggestions.  RAB-19990918.
		if ((nNumericCompareStart == CString::FIND_FAILED) || (nNumericCompareStart > nCookieClauseStart))
			strNewText+= _T("\"");
		strNewText+= strCookieValue;
		if ((nNumericCompareStart == CString::FIND_FAILED) || (nNumericCompareStart > nCookieClauseStart))
			strNewText+= _T("\"");

		// Look for another cookie clause.
		nNumericCompareStart= strText.Find( kstrCond_NumericCompare );
		nCookieClauseStart= strText.Find( COMMAND_COOKIE );
	}

	// Append any remaining text onto the end of the string.
	// If a cookie clause did not contain an ending marker it will be appended as well.
	strNewText+= strText;

	// Reassign the return string.
	strText= strNewText;

	return;
}


// V3.2 - Enhancement to support cookies.
// This function searches the HTTP cookies for a given cookie name and attribute.  If
// found, this function returns a value of true and the located cookie value.
bool CAPGTSHTIReader::LocateCookieValue(	const CString& strCookieName,
											const CString& strCookieAttr,
											CString& strCookieValue )
{
	bool	bCookieFound= false;
	CString strTmpCookieName= strCookieName + _T("=");
	int		nScratch;

	// URL encode the cookie name to handle underscores.
	APGTS_nmspace::CookieEncodeURL( strTmpCookieName );

	nScratch= m_strHTTPcookies.Find( strTmpCookieName );
	if (CString::FIND_FAILED != nScratch)
	{
		// Verify that we have not matched on a partial string for the cookie name.
		if ((nScratch == 0) || 
			(m_strHTTPcookies[ nScratch - 1 ] == _T(' ')) ||
			(m_strHTTPcookies[ nScratch - 1 ] == _T(';')))
		{
			// We have found the cookie that we are looking for, now look for the attribute name.
			CString strTmpCookieAttr= strCookieAttr + _T("=");
			
			// URL encode the cookie name to handle underscores.
			APGTS_nmspace::CookieEncodeURL( strTmpCookieAttr );

		
			// Jump past the starting point and the original cookie name length.
			CString strScratch = m_strHTTPcookies.Mid( nScratch + strCookieName.GetLength() );
			nScratch= strScratch.Find( _T(";") );
			if (CString::FIND_FAILED != nScratch)
			{
				// Truncate the string at the end of this particular cookie..
				if (nScratch > 0)
					strScratch= strScratch.Left( nScratch );
			}
			nScratch= strScratch.Find( strTmpCookieAttr );
			if (CString::FIND_FAILED != nScratch)  
			{
				if (nScratch > 0)
				{
					// Verify that we have not matched on a partial string for the cookie attribute.
					if ((strScratch[ nScratch - 1 ] == _T('=')) ||
						(strScratch[ nScratch - 1 ] == _T('&')))
					{
						strCookieValue= strScratch.Mid( nScratch + strTmpCookieAttr.GetLength() );
						
						// Look for and remove any delimiters.
						nScratch= strCookieValue.Find( _T("&") );
						if (CString::FIND_FAILED != nScratch)
						{	
							// Truncate the string.
							if (nScratch > 0)
								strCookieValue= strCookieValue.Left( nScratch );
						}
						nScratch= strCookieValue.Find( _T(";") );
						if (CString::FIND_FAILED != nScratch)
						{	
							// Truncate the string.
							if (nScratch > 0)
								strCookieValue= strCookieValue.Left( nScratch );
						}

						// Decode the cookie value.
						if (!strCookieValue.IsEmpty())
							APGTS_nmspace::CookieDecodeURL( strCookieValue );
						bCookieFound= true;
					}
				}
			}
		}
	}

	return( bCookieFound );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsctx.cpp ===
//
// MODULE: APGTSCTX.CPP
//
// PURPOSE: Implementation file for Thread Context
//	Fully implements class APGTSContext, which provides the full context for a "pool" thread
//	to perform a task
//	Also includes helper class CCommands.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//	1. Several things in this file are marked as $ENGLISH.  That means we've hard-coded
//	English-language returns.  This may yet be revisited, but as of 10/29/98 discussion
//	between Ron Prior of Microsoft and Joe Mabel of Saltmine, we couldn't come up with a
//	better solution to this.  Notes are in the specification for the fall 1998 work on
//	the Online Troubleshooter.  
//	2. some of the methods of APGTSContext are implemented in file STATUSPAGES.CPP
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-22-98		JM		Major revision, deprecate IDH, totally new approach to logging.
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include <time.h>
#include "event.h"
#include "apgts.h"
#include "apgtscls.h"
#include "apgtscfg.h"
#include "apgtsmfc.h"
#include "CounterMgr.h"
#include "CharConv.h"
#include "SafeTime.h"
#include "RegistryPasswords.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "HTMLFragLocal.h"
#endif
#include "Sniff.h"


// HTTP header variable name where cookie information is stored.
#define kHTTP_COOKIE	"HTTP_COOKIE"

//
// CCommands ------------------------------------------------------
// The next several CCommands functions are analogous to MFC CArray
//
int APGTSContext::CCommands::GetSize( ) const
{
	return m_arrPair.size();
}

void APGTSContext::CCommands::RemoveAll( )
{
	m_arrPair.clear();
}

bool APGTSContext::CCommands::GetAt( int nIndex, NID &nid, int &value ) const
{
	if (nIndex<0 || nIndex>=m_arrPair.size())
		return false;
	nid = m_arrPair[nIndex].nid;
	value = m_arrPair[nIndex].value;
	return true;
}

int APGTSContext::CCommands::Add( NID nid, int value )
{
	NID_VALUE_PAIR pair;

	pair.nid = nid;
	pair.value = value;

	try
	{
		m_arrPair.push_back(pair);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		return( -1 );
	}

	return m_arrPair.size();
}

//	a funky manipulation to deal with the following issue from old (pre V3.0) troubleshooters:
//	Pre V3.0 Logging sequence and the service node's behavior were both based on some assumptions
//	about the sequence of name/value pairs in the command list.  Basically, the
//	assumption was that the "table" would be on top of the form and the "questions"
//	below it.  This would result in ProblemAsk in first position (after any "template=
//	<template-name> and type=<troubleshooter-name>, but that's weeded out before we ever 
//	hit the command list).  If the HTI file has put	"the table" at the bottom, that assumption
//	is invalidated, so we have to manipulate the array.
//	Because we could get old GET-method queries, we still have to deal with this as a backward 
//	compatibility issue.
void APGTSContext::CCommands::RotateProblemPageToFront()
{
	int dwPairs = m_arrPair.size();

	// Rotate till ProblemAsk is in position 0. (no known scenario where it starts out
	//	anywhere past position 1)
	try
	{
		for (int i= 0; i<dwPairs; i++)
		{
			NID_VALUE_PAIR pair = m_arrPair.front(); // note: first element, not i-th element

			if (pair.nid == nidProblemPage)
				break;

			m_arrPair.erase(m_arrPair.begin());
			m_arrPair.push_back(pair);
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}
//
// CCommandsAddManager --------------------------------------------------
//
void APGTSContext::CCommandsAddManager::Add(NID nid, int value, bool sniffed)
{
	if (sniffed)
	{
		int nCommands = m_Commands.GetSize();
		for (int i = nCommands - 1; i >= 0; i--) // higher possibility, that matching
		{										 //  node will be in the end of array
			NID nid_curr;
			int value_curr;
			m_Commands.GetAt(i, nid_curr, value_curr);
			if (nid_curr == nid)
			{
				if (value_curr != value)
				{
					// If we're here, it means, that user has changed value
					//  of sniffed node in history table, therefore it is
					//  no longer treated as sniffed. 
					return;
				}
				else
				{
					m_Sniffed.Add(nid, value);
					return;
				}
			}
		}
		// sniffed node does not have matches in m_Commands
		ASSERT(false);
	}
	else
	{
		m_Commands.Add(nid, value);
	}
}
//
// CAdditionalInfo ------------------------------------------------------
// The next several CAdditionalInfo functions are analogous to MFC CArray
//
int APGTSContext::CAdditionalInfo::GetSize( ) const
{
	return m_arrPair.size();
}

void APGTSContext::CAdditionalInfo::RemoveAll( )
{
	m_arrPair.clear();
}

bool APGTSContext::CAdditionalInfo::GetAt( int nIndex, CString& name, CString& value ) const
{
	if (nIndex<0 || nIndex>=m_arrPair.size())
		return false;
	name = m_arrPair[nIndex].name;
	value = m_arrPair[nIndex].value;
	return true;
}

int APGTSContext::CAdditionalInfo::Add( const CString& name, const CString& value )
{
	NAME_VALUE_PAIR pair;

	pair.name = name;
	pair.value = value;

	try
	{
		m_arrPair.push_back(pair);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		return( -1 );
	}

	return m_arrPair.size();
}


//-----------------
// INPUT *pECB		- Describes the user request that has come in.  This is our abstraction of
//						Win32 EXTENSION_CONTROL_BLOCK, which is ISAPI's packaging of CGI data.
// INPUT *pConf		- access to registry info & contents of all loaded troubleshooters
// INPUT *pLog		- access to logging
// INPUT *pStat		- statistical info, including pStat->dwRollover which is a unique number
//						for this request, unique within the time the DLL has been loaded
APGTSContext::APGTSContext(	CAbstractECB *pECB, 
							CDBLoadConfiguration *pConf,
							CHTMLLog *pLog,
							GTS_STATISTIC *pStat,
							CSniffConnector* pSniffConnector
							) :
	m_pECB(pECB),
	m_dwErr(0),
	m_strHeader(_T("Content-Type: text/html\r\n")),
	m_pConf(pConf),
	m_strVRoot(m_pConf->GetVrootPath()),
	m_pszQuery(NULL),
	m_pLog(pLog),
	m_bPostType(true),
	m_dwBytes(0),
	m_pStat(pStat),
	m_bPreload(false),
	m_bNewCookie(false),
	m_pcountUnknownTopics (&(g_ApgtsCounters.m_UnknownTopics)), 
	m_pcountAllAccessesFinish (&(g_ApgtsCounters.m_AllAccessesFinish)),
	m_pcountStatusAccesses (&(g_ApgtsCounters.m_StatusAccesses)),
	m_pcountOperatorActions (&(g_ApgtsCounters.m_OperatorActions)),
	m_TopicName(_T("")),
	m_infer(pSniffConnector),
	m_CommandsAddManager(m_Commands, m_Sniffed)
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
	, timeCreateContext(0),
	timeStartInfer(0),
	timeEndInfer(0),
	timeEndRender(0)
#endif // SHOWPROGRESS
{
#ifdef SHOWPROGRESS
	time(&timeCreateContext);
#endif // SHOWPROGRESS
	// obtain local host IP address
	APGTS_nmspace::GetServerVariable(m_pECB, "SERVER_NAME", m_strLocalIPAddress);
		
	// HTTP response code.  This or 302 Object Moved.
	_tcscpy(m_resptype, _T("200 OK"));	// initially assume we will respond without trouble

	// supports GET, POST
	if (!strcmp(m_pECB->GetMethod(), "GET")) {
		m_bPostType = false;
		m_dwBytes = strlen(m_pECB->GetQueryString());
	}
	else 
		m_dwBytes = m_pECB->GetBytesAvailable();

	_tcscpy(m_ipstr,_T(""));

	DWORD bufsize = MAXBUF - 1;
	if (! m_pECB->GetServerVariable("REMOTE_ADDR", m_ipstr, &bufsize)) 
	 	_stprintf(m_ipstr,_T("IP?"));
	
	try
	{
		m_pszQuery = new TCHAR[m_dwBytes + 1];

		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!m_pszQuery)
			throw bad_alloc();
	}
	catch (bad_alloc&)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		m_dwErr = EV_GTS_ERROR_NO_CHAR;
		return;
	}

	if (m_bPostType) 
		memcpy(m_pszQuery, m_pECB->GetData(), m_dwBytes);
	else 
		memcpy(m_pszQuery, m_pECB->GetQueryString(), m_dwBytes);

	m_pszQuery[m_dwBytes] = _T('\0');
	
}

//
// Even though this is a destructor, it does a lot of work:
//	- sends the HTTP (HTML or cookie)to the user over the net
//	- writes to the log.
APGTSContext::~APGTSContext()
{
	DWORD dwLen;
	TCHAR *ptr;

	// RESPONSE_HEADER
	m_strHeader += _T("\r\n");

	dwLen = m_strHeader.GetLength();
	ptr = m_strHeader.GetBuffer(0);

	m_pECB->ServerSupportFunction(	HSE_REQ_SEND_RESPONSE_HEADER,
									m_resptype,
									&dwLen,
									(LPDWORD) ptr );

	m_strHeader.ReleaseBuffer();

	// HTML content follows
	{
		//////////////////////////////////////////////////////////////////////////////////////
		//
		// mando : 01.28.2002
		//
		// Fixing a PREfast bug: Renaming dwLen to dwLen1 because one more dwLen is being
		//						 declared in the outer scope.
		//
		//////////////////////////////////////////////////////////////////////////////////////
//		DWORD dwLen= 0;
		DWORD dwLen1= 0;

		if (! m_dwErr) 
			dwLen1 = m_strText.GetLength();
		
		if (!dwLen1)
		{
			// $ENGLISH (see note at head of file)
			SetError(_T("<P>Errors Occurred in This Context"));
			dwLen1 = m_strText.GetLength();
		}
#ifdef SHOWPROGRESS
		CString strProgress;
		CSafeTime safetimeCreateContext(timeCreateContext);
		CSafeTime safetimeStartInfer(timeStartInfer);
		CSafeTime safetimeEndInfer(timeEndInfer);
		CSafeTime safetimeEndRender(timeEndRender);
			
		strProgress = _T("\nRequested ");
		strProgress += safetimeCreateContext.StrLocalTime();
		strProgress += _T("\n<BR>Start Infer ");
		strProgress += safetimeStartInfer.StrLocalTime();
		strProgress += _T("\n<BR>End Infer ");
		strProgress += safetimeEndInfer.StrLocalTime();
		strProgress += _T("\n<BR>End Render ");
		strProgress += safetimeEndRender.StrLocalTime();
		strProgress += _T("\n<BR>");

		int i = m_strText.Find(_T("<BODY"));
		i = m_strText.Find(_T('>'), i);		// end of BODY tag
		if (i>=0)
		{
			m_strText= m_strText.Left(i+1) 
					 + strProgress 
					 + m_strText.Mid(i+1);
		}
		dwLen1 += strProgress.GetLength();
#endif // SHOWPROGRESS

		// (LPCTSTR) cast gives us the underlying text bytes.
		//	>>> $UNICODE Actually, this would screw up under Unicode compile, because for HTML, 
		//	this must be SBCS.  Should really be a conversion to LPCSTR, which is non-trivial
		//	in a Unicode compile. JM 1/7/99
		m_pECB->WriteClient((LPCTSTR)m_strText, &dwLen1);

		//////////////////////////////////////////////////////////////////////////////////////
	}

	// connection complete
	m_logstr.AddCurrentNode(m_infer.NIDSelected());

	if (m_dwErr)
		m_logstr.AddError(m_dwErr, 0);
	
	// finish up log
	{
		if (m_pLog) 
		{
			CString strLog (m_logstr.GetStr());

			m_dwErr = m_pLog->NewLog(strLog);
			if (m_dwErr) 
			{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""),
										_T(""),
										m_dwErr ); 
			}		
		}
	}

	if (m_pszQuery)
		delete [] m_pszQuery;
}


//	Fully process a normal user request
//	Should be called within the user context created by ImpersonateLoggedOnUser
void APGTSContext::ProcessQuery()
{
	CheckAndLogCookie();

	if (m_dwErr) 
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Remote IP Address:"),
								m_ipstr,
								m_dwErr ); 
	}
	else
	{
		DoContent();
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
	time (&timeEndRender);
#endif // SHOWPROGRESS
	}

	// Log the completion of all queries, good and bad.
	m_pcountAllAccessesFinish->Increment();
}

//
//
void APGTSContext::DoContent()
{	
	TCHAR pszCmd[MAXBUF], pszValue[MAXBUF];
	
	if (m_bPostType)
	{
		// validate incoming POST request
		if (strcmp(m_pECB->GetContentType(), CONT_TYPE_STR) != 0) 
		{
			// Output the content type to the event log.
			CString strContentType;
			if (strlen( m_pECB->GetContentType() ))
				strContentType= m_pECB->GetContentType();
			else
				strContentType= _T("not specified");

			m_strText += _T("<P>Bad Data Received\n");
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									m_ipstr,
									strContentType,
									EV_GTS_USER_BAD_DATA ); 
			return;
		}
	}

	if (RUNNING_ONLINE_TS())
	{
		// Cookies are only used in the Online TS.
		if (_tcsstr( m_pszQuery, C_COOKIETAG ) != NULL)
		{
			// V3.2 - Parse out cookies passed in either as hidden fields or as part of the URL.
			if (m_Qry.GetFirst(m_pszQuery, pszCmd, pszValue))
			{
				CString strCookieFreeQuery;
				bool	bFoundAtLeastOneCookie= false;
				do
				{
					// This is supposed to be a case sensitive setting as per the specification.
					if (!_tcsncmp( pszCmd, C_COOKIETAG, _tcslen( C_COOKIETAG )))
					{
						// Found a cookie, add it to the map.
						CString strCookieAttr= pszCmd + _tcslen( C_COOKIETAG );
						APGTS_nmspace::CookieDecodeURL( strCookieAttr );
						CString strCookieValue= pszValue;
						APGTS_nmspace::CookieDecodeURL( strCookieValue );

						// Check the cookie name for compliance.
						bool bCookieIsCompliant= true;
						for (int nPos= 0; nPos < strCookieAttr.GetLength(); nPos++)
						{
							TCHAR tcTmp= strCookieAttr.GetAt( nPos );
							if ((!_istalnum( tcTmp )) && (tcTmp != _T('_')))
							{
								bCookieIsCompliant= false;
								break;
							}
						}
						if (bCookieIsCompliant)
						{
							// Check the cookie setting for compliance.
							if (strCookieValue.Find( _T("&lt") ) != -1)
							{
								bCookieIsCompliant= false;
							}
							else if (strCookieValue.Find( _T("&gt") ) != -1)
							{
								bCookieIsCompliant= false;
							}
#if ( 0 )
							// >>> I don't think that this check is necessary. RAB-20000408.
							else
							{
								for (int nPos= 0; nPos < strCookieValue.GetLength(); nPos++)
								{
									TCHAR tcTmp= strCookieValue.GetAt( nPos );
									if ((tcTmp == _T('<')) || (tcTmp == _T('>')))
									{
										bCookieIsCompliant= false;
										break;
									}
								}
							}
#endif
						}

						if (bCookieIsCompliant)
						{
							try
							{
								m_mapCookiesPairs[ strCookieAttr ]= strCookieValue;
							}
							catch (exception& x)
							{
								CString str;
								// Note STL exception in event log.
								CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
								CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
														SrcLoc.GetSrcFileLineStr(), 
														CCharConversion::ConvertACharToString(x.what(), str), 
														_T(""), 
														EV_GTS_STL_EXCEPTION ); 
							}
						}
						bFoundAtLeastOneCookie= true;
					}
					else
					{
						// Not a cookie, add it to the cookie free query.
						if (strCookieFreeQuery.GetLength())
							strCookieFreeQuery+= C_AMPERSAND;
						strCookieFreeQuery+= pszCmd;
						strCookieFreeQuery+= C_EQUALSIGN;
						strCookieFreeQuery+= pszValue;
					}
				}
				while (m_Qry.GetNext( pszCmd, pszValue )) ;

				if (bFoundAtLeastOneCookie)
				{
					// Replace the original query string with a cookie free query.
					memcpy( m_pszQuery, strCookieFreeQuery, strCookieFreeQuery.GetLength() );
					m_pszQuery[ strCookieFreeQuery.GetLength() ] = _T('\0');
				}
			}
		}
	}

	// >>> The following code is commented by me as it is raw, and it will not work since
	//  topic pointer in m_infer is not set yet. Now we are taking SNIFFED_ nodes down
	//  to the level of APGTSContext::NextCommand, and parsing it there by 
	//  APGTSContext::StripSniffedNodePrefix, and adding to sniffed array using
	//  functionality of APGTSContext::CCommandsAddManager class.
	// Oleg. 10.29.99
	/*
	// In v3.2, sniffing is only in the Local TS. There's nothing inherent about that,
	// but as long as it's so, might as well optimize for it.
	if (RUNNING_LOCAL_TS())
	{
		ClearSniffedList();
		if (_tcsstr( m_pszQuery, C_SNIFFTAG ) != NULL)
		{
			// V3.2 - Parse out sniffed nodes passed in as hidden fields
			if (m_Qry.GetFirst(m_pszQuery, pszCmd, pszValue))
			{
				CString strSniffFreeQuery;
				bool	bFoundAtLeastOneSniff= false;
				do
				{
					// This is supposed to be a case sensitive setting as per the specification.
					if (!_tcsncmp( pszCmd, C_SNIFFTAG, _tcslen( C_SNIFFTAG )))
					{
						// Found a sniffed node, add it to the list of sniffed nodes.
						CString strSniffedNode= pszCmd + _tcslen( C_SNIFFTAG );
						// >>> I believe that despite its name, CookieDecodeURL is
						//	exactly what we want - JM 10/11/99
						APGTS_nmspace::CookieDecodeURL( strSniffedNode );
						CString strSniffedState= pszValue;
						APGTS_nmspace::CookieDecodeURL( strSniffedState );

						NID nid= NIDFromSymbolicName(strSniffedNode);
						int ist = _ttoi(strSniffedState);

						if (ist != -1)
							PlaceNodeInSniffedList(nid, ist);

						bFoundAtLeastOneSniff= true;
					}
					else
					{
						// Not a Sniffed node, add it to the sniff-free query.
						if (strSniffFreeQuery.GetLength())
							strSniffFreeQuery+= C_AMPERSAND;
						strSniffFreeQuery+= pszCmd;
						strSniffFreeQuery+= C_EQUALSIGN;
						strSniffFreeQuery+= pszValue;
					}
				}
				while (m_Qry.GetNext( pszCmd, pszValue )) ;

				if (bFoundAtLeastOneSniff)
				{
					// Replace the original query string with a cookie free query.
					memcpy( m_pszQuery, strSniffFreeQuery, strSniffFreeQuery.GetLength() );
					m_pszQuery[ strSniffFreeQuery.GetLength() ] = _T('\0');
				}
			}
		}
	}
	*/
	eOpAction OpAction = IdentifyOperatorAction(m_pECB);
	if (OpAction != eNoOpAction)
	{
		if (m_bPostType == true)
		{
			// Note: Hard-coded text that should be replaced.
			m_strText += _T("<P>Post method not permitted for operator actions\n");
		}
		else
		{
			// Increment the number of operator action requests.
			m_pcountOperatorActions->Increment();

			CString strArg;
			OpAction = ParseOperatorAction(m_pECB, strArg);
			if (OpAction != eNoOpAction)
				ExecuteOperatorAction(m_pECB, OpAction, strArg);
		}
	}
	else if (m_Qry.GetFirst(m_pszQuery, pszCmd, pszValue))
	{
		DWORD dwStat = ProcessCommands(pszCmd, pszValue);

		if (dwStat != 0) 
		{
			if (dwStat == EV_GTS_INF_FIRSTACC ||
				dwStat == EV_GTS_INF_FURTHER_GLOBALACC ||
				dwStat == EV_GTS_INF_THREAD_OVERVIEWACC ||
				dwStat == EV_GTS_INF_TOPIC_STATUSACC)
			{
				// Don't want to show contents of query, because it would put the actual 
				//	password in the file.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""),
										_T(""),
										dwStat ); 
			}
			else
			{
				m_dwErr = dwStat;

				if (m_dwBytes > 78) 
				{
					// It's longer than we want to stick in the event log.
					// Cut it off with an ellipsis at byte 75, then null terminate it.
					m_pszQuery[75] = _T('.');
					m_pszQuery[76] = _T('.');
					m_pszQuery[77] = _T('.');
					m_pszQuery[78] = _T('\0');
				}

				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										m_pszQuery,
										_T(""),
										dwStat ); 
			}
		}
	}
	else {
		m_strText += _T("<P>No Input Parameters Specified\n");
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								m_ipstr,
								_T(""),
								EV_GTS_USER_NO_STRING ); 

	}
}

//
// Read a cookie (or write one, if there isn't one already)
void APGTSContext::CheckAndLogCookie()
{
	// Suppressed this in Local TS, becuase it isn't using any cookies.
	if (RUNNING_LOCAL_TS())
		return;
	
	CString		str;	// scratch only
	char		szCookieNameValue[256];		// never Unicode, because cookies always ASCII
	char		*pszValue= NULL;			// never Unicode, because cookies always ASCII
	DWORD		dwCookieLen = 255; 
	
	if ( m_pECB->GetServerVariable(	kHTTP_COOKIE,
									szCookieNameValue,
									&dwCookieLen)) 
	{
		// Got a Cookie. Parse it
		pszValue = GetCookieValue("GTS-COOKIE", szCookieNameValue);
	}

	if( !pszValue )
	{
		// Build a funky string for the cookie value.  We want uniqueness for logging purposes.
		// Make a local copy of remote IP address, then massage its dots into letters, each 
		//	dependent on 4 bits of dwTempRO
		// While not strictly unique, there are 12 bits worth of "uniqueness" here.  However,
		//	every time the DLL is restarted, we go back to zero.  Also, all servers start at zero.
		// Later we form the cookie value by appending time to this, so it should be "pretty unique"
		DWORD		dwTempRO = m_pStat->dwRollover; // this value is unique to this user request
		TCHAR		*pch;

		////////////////////////////////////////////////////////////////////////////////////////////////
		//
		// mando : 10.28.2002
		//
		// PREfast bug # 517884 being fixed.
		//
		////////////////////////////////////////////////////////////////////////////////////////////////

//		TCHAR		szTemp[50];
		TCHAR		szTemp[MAX_PATH + 1];
		////////////////////////////////////////////////////////////////////////////////////////////////
		_tcscpy(szTemp, m_ipstr);
		while ((pch = _tcschr(szTemp, _T('.'))) != NULL) 
		{
			*pch = (TCHAR)(dwTempRO & 0x0F) + _T('A');
			dwTempRO >>= 4;
		}

		// Create a cookie
		time_t		timeNow;					// current time
		time_t		timeExpire;					// when we set the cookie to expire
		time(&timeNow);
		timeExpire = timeNow + (m_pConf->GetCookieLife() * 60 /* secs in a minute */);

		// char, not TCHAR: cookie is always ASCII.
		char szExpire[30];

		{
			CSafeTime safetimeExpire (timeExpire);
			asctimeCookie(safetimeExpire.GMTime(), szExpire);
		}

		// char, not TCHAR: cookie is always ASCII.
		char szNewCookie[256];
		char szHeader[256];

		sprintf(szNewCookie, "%s%ld, ", szTemp, timeNow); 
		sprintf(szHeader, "Set-Cookie: GTS-COOKIE=%s; expires=%s; \r\n",
						   szNewCookie, szExpire);

		CCharConversion::ConvertACharToString(szHeader, str);
		m_strHeader += str;

		pszValue = szNewCookie;
		m_bNewCookie = true;
	}

	m_logstr.AddCookie(CCharConversion::ConvertACharToString(pszValue, str));
}

//
// This takes the string returned by getting the cookie environment 
// variable and a specific cookie name and returns a the value
// of that cookie (if it exists). There could potentially be
// more than one cookie in the cookie string
//
// Cookies contain one or more semicolon-separated name/value pair:
//	name1=value1;name2=value2;   (etc.)
//
// INPUT *pszName		name we're seeking
// INPUT *pszCookie		the whole cookie string
// OUTPUT *pszCookie	this string has been written to & should not be relied on
// RETURN	value corresponding to *pszName (physically points into *pszCookie string)
//		Returns NULL if not found
char *APGTSContext::GetCookieValue(char *pszName, char *pszCookie)
{
	char *sptr, *eptr;

	sptr = pszCookie;
	while (sptr != NULL) {
		if ((eptr = strstr(sptr,"=")) == NULL)
			return(NULL);

		// replace the '=' with NULL
		*eptr = _T('\0');
		if (!strncmp(sptr,pszName,strlen(pszName)) ){
			// get the value
			sptr = eptr + 1;
			if ((eptr = strstr(sptr,";")) != NULL){
				*eptr = _T('\0');
				return(sptr);
			} else {
				// this is the last variable
				return(sptr);
			}
		}
		if ((eptr = strstr(sptr,";")) != NULL)
			sptr = eptr +1;
		else
			sptr = NULL;
	}
	return(NULL);
}

// INPUT gmt
// INPUT szOut must point to a buffer of at least 29 characters to hold 28 character
//	text plus terminating null.
// OUTPUT szOut: a pointer to a string containing a text version of date/time info.
//	Typical form would be "Sun, 3-Jan-1998 12:03:08 GMT"  There is no choice about
//	this form.  It should always be exactly 28 characters.
// Regardless of whether the program is compiled for Unicode, this must always be ASCII:
//	HTTP cookies are ASCII.
void APGTSContext::asctimeCookie(const struct tm &gmt, char * szOut)
{
	char temp[20];

	switch (gmt.tm_wday) {
		case 0: strcpy(szOut, "Sun, "); break;
		case 1: strcpy(szOut, "Mon, "); break;
		case 2: strcpy(szOut, "Tue, "); break;
		case 3: strcpy(szOut, "Wed, "); break;
		case 4: strcpy(szOut, "Thu, "); break;
		case 5: strcpy(szOut, "Fri, "); break;
		case 6: strcpy(szOut, "Sat, "); break;
		default: return;
	}

	sprintf(temp, "%02d-", gmt.tm_mday);
	strcat(szOut, temp);

	switch (gmt.tm_mon) {
		case 0: strcat(szOut, "Jan-"); break;
		case 1: strcat(szOut, "Feb-"); break;
		case 2: strcat(szOut, "Mar-"); break;
		case 3: strcat(szOut, "Apr-"); break;
		case 4: strcat(szOut, "May-"); break;
		case 5: strcat(szOut, "Jun-"); break;
		case 6: strcat(szOut, "Jul-"); break;
		case 7: strcat(szOut, "Aug-"); break;
		case 8: strcat(szOut, "Sep-"); break;
		case 9: strcat(szOut, "Oct-"); break;
		case 10: strcat(szOut, "Nov-"); break;
		case 11: strcat(szOut, "Dec-"); break;
		default: return;
	}

	sprintf(temp, "%04d ", gmt.tm_year +1900);
	strcat(szOut, temp);

	sprintf(temp, "%d:%02d:%02d GMT", gmt.tm_hour, gmt.tm_min, gmt.tm_sec);
	strcat(szOut, temp);
}

//
// Assumes m_Qry.GetFirst has already been called.
// INPUT pszCmd & pszValue are the outputs of m_Qry.GetFirst.
DWORD APGTSContext::ProcessCommands(LPTSTR pszCmd, 
									LPTSTR pszValue) 
{
	bool bTryStatus = false;	// true = try to parse as an operator status request.
	CString str;				// strictly scratch
	DWORD dwStat = 0;

	// Check first if this is a HTI independent of DSC request.
	if (!_tcsicmp( pszCmd, C_TEMPLATE))
	{
		CString strBaseName, strHTItemplate;
		bool	bValid;
	
		// Force the HTI file to be in the resource directory and have a HTI extension.
		strBaseName= CAbstractFileReader::GetJustNameWithoutExtension( pszValue );

		// Check for the case where the filename passed in was just a name.
		// This is a workaround for what is a questionable implementation of 
		// GetJustNameWithoutExtension() i.e. returning an empty string when no
		// forward slashes or backslashes or dots are detected.  RAB-981215.
		if ((strBaseName.IsEmpty()) && (_tcslen( pszValue )))
		{
			// Set the base name from the passed in string.
			strBaseName= pszValue;
			strBaseName.TrimLeft();
			strBaseName.TrimRight();
		}

		if (!strBaseName.IsEmpty())
		{
			strHTItemplate= m_pConf->GetFullResource();
			strHTItemplate+= strBaseName;
			strHTItemplate+= _T(".hti");
		}

		// Check if HTI file already exists in the map of alternate HTI templates.
		if (m_pConf->RetTemplateInCatalogStatus( strHTItemplate, bValid ))
		{
			// Template has been loaded, check if it is valid.
			if (!bValid)
				strHTItemplate= _T("");
		}
		else
		{
			CP_TEMPLATE cpTemplate;
			// Add the HTI file to the list of active alternate templates and then attempt to 
			// load the template.
			m_pConf->AddTemplate( strHTItemplate );
			m_pConf->GetTemplate( strHTItemplate, cpTemplate, m_bNewCookie);

			// If the load failed then set the alternate name to blank so that the default
			// template is used instead.
			if (cpTemplate.IsNull())
				strHTItemplate= _T("");
		}
		

		// If we have a valid HTI file, set the alternate HTI template.
		if (!strHTItemplate.IsEmpty())
			SetAltHTIname( strHTItemplate );

		// Attempt to acquire the next step of name-value pairs.
		m_Qry.GetNext( pszCmd, pszValue );
	}

	if (!_tcsicmp(pszCmd, C_TOPIC_AND_PROBLEM))
	{
		// Code in this area uses ++ and -- on TCHAR* pointers, rather than using _tcsinc()
		//	and _tcsdec.  This is OK because we never use non-ASCII in the query string.

		// value attached to first command is commma-separated topic & problem
		TCHAR * pchComma= _tcsstr(pszValue, _T(","));
		if (pchComma)
		{
			// commma found
			*pchComma = 0;	// replace it with a null
			TCHAR * pchProblem = pchComma;
			++pchProblem;	// to first character past the comma

			// strip any blanks or other junk after the comma
			while (*pchProblem > _T('\0') && *pchProblem <= _T(' '))
				++pchProblem;

			--pchComma;	// make pchComma point to last character before the comma
			// strip any blanks or other junk before the comma
			while (pchComma > pszValue && *pchComma > _T('\0') && *pchComma<= _T(' '))
				*(pchComma--) = 0;

			// Now push the problem back onto the query string to be found by a later GetNext()
			CString strProbPair(_T("ProblemAsk="));
			strProbPair += pchProblem;

			m_Qry.Push(strProbPair);
		}
		// else treat this as just a topic

		_tcscpy(pszCmd, C_TOPIC);
	}

	// first command should be troubleshooter type (symbolic name)
	// C_PRELOAD here means we've already done some "sniffing"
	// All of these commands take type symbolic belief-network name as their value
	//	C_TYPE & C_PRELOAD use (deprecated) IDHs
	//	C_TOPIC uses NIDs
	if (!_tcsicmp(pszCmd, C_TYPE) || !_tcsicmp(pszCmd, C_PRELOAD)
	||  !_tcsicmp(pszCmd, C_TOPIC) )
	{
		bool bUsesIDH = _tcsicmp(pszCmd, C_TOPIC)? true:false;  // True if NOT "topic".  
											//	The (deprecated) others use IDH.

		CString strTopicName = pszValue;
		strTopicName.MakeLower();

		m_TopicName= pszValue; // let outer world know what topic we are working on

		// We use a reference-counting smart pointer to hold onto the CTopic.  As long as
		//	cpTopic remains in scope, the relevant CTopic is guaranteed to remain in 
		//	existence.
		CP_TOPIC cpTopic;
		m_pConf->GetTopic(strTopicName, cpTopic, m_bNewCookie);
		CTopic * pTopic = cpTopic.DumbPointer();
		if (pTopic) 
		{
			m_logstr.AddTopic(strTopicName);
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
			time (&timeStartInfer);
#endif // SHOWPROGRESS
			dwStat = DoInference(pszCmd, pszValue, pTopic, bUsesIDH);
#ifdef SHOWPROGRESS
			time (&timeEndInfer);
#endif // SHOWPROGRESS
		}
		else 
		{
			dwStat = EV_GTS_ERROR_INF_BADTYPECMD;

			// $ENGLISH (see note at head of file)
			str = _T("<P>Unexpected troubleshooter topic:");
			str += strTopicName;
			SetError(str);

			m_logstr.AddTopic(_T("*UNKNOWN*"));
			m_pcountUnknownTopics->Increment();
		}
	}
	//
	//
	// Now we are going to deal with status pages.
	//  But those pages require knowing of the IP address of the local machine.
	//  If m_strLocalIPAddress.GetLength() == 0, we were not able to identify 
	//  the IP address and have to display an error message.
	else if (0 == m_strLocalIPAddress.GetLength())
	{
			dwStat = EV_GTS_ERROR_IP_GET;

			// $ENGLISH (see note at head of file)
			SetError(_T("<P>Status request must explicitly give IP address of the server."));
	}
#ifndef LOCAL_TROUBLESHOOTER
	else if (!_tcsicmp(pszCmd, C_FIRST)) 
	{
		DisplayFirstPage(false);
		dwStat = EV_GTS_INF_FIRSTACC;
		m_pcountStatusAccesses->Increment();
	}
#endif

// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifdef NOPWD
	else 
		bTryStatus = true;
#else 
	else if (!_tcsicmp(pszCmd, C_PWD)) 
	{
		CString strPwd;
		CCharConversion::ConvertACharToString( pszValue, strPwd );

		CRegistryPasswords pwd;
		if (pwd.KeyValidate( _T("StatusAccess"), strPwd) )
		{
			time_t timeNow;
			time(&timeNow);

			// Generate a temporary password
			m_strTempPwd = CCharConversion::ConvertACharToString(m_ipstr, str);
			str.Format(_T("%d"), timeNow);
			m_strTempPwd += str;

			m_pConf->GetRecentPasswords().Add(m_strTempPwd);

			// Attempt to acquire the next step of name-value pairs.
			m_Qry.GetNext( pszCmd, pszValue );
			bTryStatus = true;
		}
		else if (m_pConf->GetRecentPasswords().Validate(strPwd) )
		{
			m_strTempPwd = strPwd;

			// Attempt to acquire the next step of name-value pairs.
			m_Qry.GetNext( pszCmd, pszValue );
			bTryStatus = true;
		}
	}
#endif // ifndef NOPWD
	else {
		dwStat = EV_GTS_ERROR_INF_BADCMD;

		// $ENGLISH (see note at head of file)
		str = _T("<P>Unexpected command: ");
		str += pszCmd;
		SetError(str);
	}

#ifndef LOCAL_TROUBLESHOOTER
	if (bTryStatus)
	{
		if (!_tcsicmp(pszCmd, C_FIRST)) 
		{
			DisplayFirstPage(true);
			dwStat = EV_GTS_INF_FIRSTACC;
			m_pcountStatusAccesses->Increment();
		}
		else if (!_tcsicmp(pszCmd, C_FURTHER_GLOBAL)) 
		{
			DisplayFurtherGlobalStatusPage();
			dwStat = EV_GTS_INF_FURTHER_GLOBALACC;
			m_pcountStatusAccesses->Increment();
		}
		else if (!_tcsicmp(pszCmd, C_THREAD_OVERVIEW)) 
		{
			DisplayThreadStatusOverviewPage();
			dwStat = EV_GTS_INF_THREAD_OVERVIEWACC;
			m_pcountStatusAccesses->Increment();
		}
		else if (!_tcsicmp(pszCmd, C_TOPIC_STATUS)) 
		{
			DisplayTopicStatusPage(pszValue);
			dwStat = EV_GTS_INF_TOPIC_STATUSACC;
			m_pcountStatusAccesses->Increment();
		}
		else {
			dwStat = EV_GTS_ERROR_INF_BADCMD;

			// $ENGLISH (see note at head of file)
			str = _T("<P>Unexpected command: ");
			str += pszCmd;
			SetError(str);
		}
	}
#endif
	return (dwStat);
}

BOOL APGTSContext::StrIsDigit(LPCTSTR pSz)
{
	BOOL bRet = TRUE;
	while (*pSz)
	{
		if (!_istdigit(*pSz))
		{
			bRet = FALSE;
			break;
		}
		pSz = _tcsinc(pSz);
	}
	return bRet;
}

// INPUT szNodeName - symbolic name of node.
// RETURNS symbolic node number.  
//	On unrecognized symbolic name, returns nidNil
NID APGTSContext::NIDFromSymbolicName(LPCTSTR szNodeName)
{
	// first handle all the special cases
	if (0 == _tcsicmp(szNodeName, NODE_PROBLEM_ASK))
		return nidProblemPage;

	if (0 == _tcsicmp(szNodeName, NODE_SERVICE))
		return nidService;

	if (0 == _tcsicmp(szNodeName, NODE_FAIL))
		return nidFailNode;

	if (0 == _tcsicmp(szNodeName, NODE_FAILALLCAUSESNORMAL))
		return nidSniffedAllCausesNormalNode;

	if (0 == _tcsicmp(szNodeName, NODE_IMPOSSIBLE))
		return nidImpossibleNode;

	if (0 == _tcsicmp(szNodeName, NODE_BYE))
		return nidByeNode;

	// normal symbolic name
	NID nid = m_infer.INode(szNodeName);
	if (nid == -1)
		return nidNil;
	else
		return nid;
	
}


// Validate and convert a list of nodes and their associated states.
//
// INPUT pszCmd & pszValue are the outputs of m_Qry.GetNext.
// INPUT index into the HTTP query parameters.  Parameters may follow any of the following
//		PATTERNS.  
// INPUT dwCount is the number shown at left in each of these patterns.  Remember that this 
//		function never sees dwCount=1; that's been used to set m_bPreload:
// INPUT bUsesIDH - Interpret numerics as IDHs (a deprecated feature) rather than NIDs
// DEPRECATED BUT SUPPORTED PATTERNS when bUsesIDH == true
//	"Preload"
//	PROBABLY NOT EFFECTIVE BACKWARD COMPATIBLITY
//	because if they've added any nodes,  # of nodes in network will have changed)
//		1 -		preload=<troubleshooter symbolic name>
//		2 -		<# of nodes in network + 1000>=<problem node number + 1000>
//		3+ -	<node symbolic name>=<node state value>
//	Old "type" (we never generate these, but we have them here for backward compatibility.
//	PROBABLY NOT EFFECTIVE BACKWARD COMPATIBLITY
//	because if they've added any nodes,  # of nodes in network will have changed)
//		1 -		type=<troubleshooter symbolic name>
//		2 -		<# of nodes in network + 1000>=<problem node number + 1000>
//		3+ -	<node # + 1000>=<node state value>
//	Newer "type", should be fully backward compatible.
//		1 -		type=<troubleshooter symbolic name>
//		2 -		ProblemAsk=<problem node symbolic name>
//		3+ -	<node symbolic name>=<node state value>
//	It is presumably OK for us to allow a slight superset of the known formats, which yields:
//		1 -		preload=<troubleshooter symbolic name> OR
//				type=<troubleshooter symbolic name>
//					Determines m_bPreload before this fn is called
//		2 -		<# of nodes in network + 1000>=<problem node number + 1000> OR
//				ProblemAsk=<problem node symbolic name>
//					We can distinguish between these by whether pszCmd is numeric
//		3+ -	<node # + 1000>=<node state value> OR
//				<node symbolic name>=<node state value>
//					We can distinguish between these by whether pszCmd is numeric
//	The only assumption in this overloading is that a symbolic name will never be entirely
//	numeric.
// SUPPORTED PATTERN when bUsesIDH == false
//		1 -		topic=<troubleshooter symbolic name> 
//		2 -		ProblemAsk=<problem node symbolic name>
//		3+ -	<node symbolic name>=<node state value>
// 
// LIMITATION ON STATE NUMBERS
//	As of 11/97, <node state value> must always be one of:
//		0 - Fixed/Unfixed: Haven't solved problem 
//			Info: First option
//		1 - Info: Second option
//		101	- Go to "Bye" Page (User succeeded - applies to Fixed/Unfixed or Support Nodes only)
//		102	- Unknown (user doesn't know the correct answer here - applies to Fixed/Unfixed and 
//		  Info nodes only)
//		103	- "Anything Else I Can Try"
//  Since inputs of state values should always come from forms we generated, we don't 
//	 systematically limit state numbers in the code here.
//	V3.0 allows other numeric states: 0-99 should all be legal.
//
//	RETURN 0 on success, otherwise an error code
DWORD APGTSContext::NextCommand(LPTSTR pszCmd, LPTSTR pszValue, bool bUsesIDH)
{
	NID nid;
	int value = 0;			// if pszValue is numeric, a NID or state.
							// otherwise, pszValue is the symbolic name of a node,
							//	and this is its NID
	bool sniffed = false;

	if (StrIsDigit(pszCmd)) 
	{
		// only should arise for bUsesIDH

		// it's an IDH (typically node # + 1000), but can be <# of nodes in network> + 1000,
		//	interpreted as "ProblemAsk"
		// The pages we generate never give us these values, but we recognize them.
		IDH idh = _ttoi(pszCmd);
		nid = m_infer.NIDFromIDH(idh);
	}
	else
	{	
		// The command is a symbolic name.
		sniffed = StripSniffedNodePrefix(pszCmd);
		nid= NIDFromSymbolicName(pszCmd);
	}

	if (StrIsDigit(pszValue))
	{
		if (bUsesIDH)
		{
			int valueIDH = _ttoi(pszValue);
			if (nid == nidProblemPage)
				// problem node number + 1000
				value = m_infer.NIDFromIDH(valueIDH);
			else 
				// state value
				value = valueIDH;
		}
		else
		{
			// value is a state number.
			value = _ttoi(pszValue);
		}
	}
	else if (nid == nidProblemPage) 
	{
		// Symbolic name of problem node
		value = NIDFromSymbolicName(pszValue);
	}
    else
		return EV_GTS_ERROR_INF_BADPARAM;

	m_CommandsAddManager.Add(nid, value, sniffed);

	return 0;
}

DWORD APGTSContext::NextAdditionalInfo(LPTSTR pszCmd, LPTSTR pszValue)
{
	if (RUNNING_LOCAL_TS())
	{
		if ( 0 == _tcscmp(pszCmd, C_ALLOW_AUTOMATIC_SNIFFING_NAME) &&
			(0 == _tcsicmp(pszValue, C_ALLOW_AUTOMATIC_SNIFFING_CHECKED) || 
			 0 == _tcsicmp(pszValue, C_ALLOW_AUTOMATIC_SNIFFING_UNCHECKED)))
		{
			m_AdditionalInfo.Add(pszCmd, pszValue);
			return 0;
		}
		if (0 == _tcscmp(pszCmd, C_LAST_SNIFFED_MANUALLY))
		{
			if (0 == _tcscmp(pszValue, SZ_ST_SNIFFED_MANUALLY_TRUE))
				m_infer.SetLastSniffedManually(true);
			return 0;
		}
	}
	return EV_GTS_ERROR_INF_BADPARAM;
}

// Name - value pairs that we can ignore
DWORD APGTSContext::NextIgnore(LPTSTR pszCmd, LPTSTR pszValue)
{
	if (RUNNING_LOCAL_TS())
	{
		// Value "-1" can come from a field, used for manual sniffing,
		//  when other then "Sniff" button is pressed
		
		CString strValue(pszValue);
		CString strSniffFailure;

		strValue.TrimLeft();
		strValue.TrimRight();
		strSniffFailure.Format(_T("%d"), SNIFF_FAILURE_RESULT);
		if (strValue == strSniffFailure)
		{
			// Name in this case should be a valid node name
			
			NID nid = nidNil;

			StripSniffedNodePrefix(pszCmd);
			nid = NIDFromSymbolicName(pszCmd);
			if (nid != nidNil)
				return 0;
		}
	}
	return EV_GTS_ERROR_INF_BADPARAM;
}

VOID APGTSContext::ClearCommandList()
{
	m_Commands.RemoveAll();
}

VOID APGTSContext::ClearSniffedList()
{
	m_Sniffed.RemoveAll();
}

VOID APGTSContext::ClearAdditionalInfoList()
{
	m_AdditionalInfo.RemoveAll();
}
/*
// Return false on failure; shouldn't ever arise.
bool APGTSContext::PlaceNodeInCommandList(NID nid, IST ist)
{
	return (m_Commands.Add(nid, ist) > 0);
}
*/
/*
// Return false on failure; shouldn't ever arise.
bool APGTSContext::PlaceNodeInSniffedList(NID nid, IST ist)
{
	return (m_Sniffed.Add(nid, ist) > 0);
}
*/
/*
// Return false on failure; shouldn't ever arise.
bool APGTSContext::PlaceInAdditionalInfoList(const CString& name, const CString& value)
{
	return (m_AdditionalInfo.Add(name, value) > 0);
}
*/
// INPUT: node short name, possibly prefixed by SNIFFED_
// OUTPUT: node short name
// RETURN: true is prefix was stripped
bool APGTSContext::StripSniffedNodePrefix(LPTSTR szName)
{
	if (0 == _tcsnicmp(szName, C_SNIFFTAG, _tcslen(C_SNIFFTAG)))
	{
		// use "memmove" since we are operating with overlapped regions!
		memmove(szName, 
			    szName + _tcslen(C_SNIFFTAG), 
				_tcslen(szName + _tcslen(C_SNIFFTAG)) + 1);
		return true;
	}
	return false;
}

VOID APGTSContext::SetNodesPerCommandList()
{
	int nCommands = m_Commands.GetSize();
	for (int i= 0; i<nCommands; i++)
	{
		NID nid;
		int value;	// typically a state (IST), except if nid==nidProblemPage, where value is a NID
		m_Commands.GetAt( i, nid, value );
		m_infer.SetNodeState(nid, value);
	}
}

VOID APGTSContext::SetNodesPerSniffedList()
{
	int nSniffed = m_Sniffed.GetSize();
	for (int i= 0; i<nSniffed; i++)
	{
		NID nid;
		int ist;
		m_Sniffed.GetAt( i, nid, ist );
		m_infer.AddToSniffed(nid, ist);
	}
}

VOID APGTSContext::ProcessAdditionalInfoList()
{
	int nCount = m_AdditionalInfo.GetSize();
	
	for (int i= 0; i < nCount; i++)
	{
		if (RUNNING_LOCAL_TS())
		{
			CString name;
			CString value;
			
			m_AdditionalInfo.GetAt( i, name, value );
			if (name == C_ALLOW_AUTOMATIC_SNIFFING_NAME)
			{
				value.MakeLower();
				if (m_infer.GetSniff())
				{
					// set AllowAutomaticSniffing flag
					if (value == C_ALLOW_AUTOMATIC_SNIFFING_CHECKED)
						m_infer.GetSniff()->SetAllowAutomaticSniffingPolicy(true);
					if (value == C_ALLOW_AUTOMATIC_SNIFFING_UNCHECKED)
						m_infer.GetSniff()->SetAllowAutomaticSniffingPolicy(false);
				}
			}
		}
		else
		{
			// process additional info in Online TS here
		}
	}
}

VOID APGTSContext::ReadPolicyInfo()
{
	if (RUNNING_LOCAL_TS())
	{
		if (m_infer.GetSniff())
		{
			// set AllowManualSniffing flag
			DWORD dwManualSniffing = 0;
			m_pConf->GetRegistryMonitor().GetNumericInfo(CAPGTSRegConnector::eSniffManual, dwManualSniffing);
			m_infer.GetSniff()->SetAllowManualSniffingPolicy(dwManualSniffing ? true : false);
			// >>> $TODO$ I do not like setting Policy Editor values explicitely, 
			//  as it done here. Probably we will have to implement 
			//  CSniffPolicyInfo (abstract) class, designed for passing
			//  those values to sniffer (CSniff).
			// Oleg. 11.05.99
		}
	}
}

VOID APGTSContext::LogNodesPerCommandList()
{
	int nCommands = m_Commands.GetSize();
	for (int i= 0; i<nCommands; i++)
	{
		NID nid;
		int value;	// typically a state (IST), except if nid==nidProblemPage, where value is a NID
		m_Commands.GetAt( i, nid, value );
		if (nid == nidProblemPage)
			m_logstr.AddNode(value, 1);
		else
			m_logstr.AddNode(nid, value);
	}
}

// builds and returns the Start Over link
// only relevant for Online TS
// >>> JM 10/8/99: I believe it would be redundant to URL-encode
CString APGTSContext::GetStartOverLink()
{
	CString str;
#ifndef LOCAL_TROUBLESHOOTER
	bool bHasQuestionMark = false;

	// ISAPI DLL's URL
	str = m_strVRoot;

	// CK_ name value pairs 
	if (!m_mapCookiesPairs.empty())
	{
		// V3.2 - Output any CK_name-value pairs as hidden fields.
		for (CCookiePairs::const_iterator it = m_mapCookiesPairs.begin(); it != m_mapCookiesPairs.end(); ++it)
		{
			if (bHasQuestionMark)
				str += _T("&");
			else
			{
				str += _T("?");
				bHasQuestionMark = true;
			}
			CString strAttr= it->first;
			CString strValue= it->second;
			APGTS_nmspace::CookieEncodeURL( strAttr );
			APGTS_nmspace::CookieEncodeURL( strValue );
			str += C_COOKIETAG + strAttr;
			str += _T("=");
			str += strValue;
		}	
	}

	// template
	const CString strAltHTIname= GetAltHTIname();
	if (!strAltHTIname.IsEmpty())
	{
		if (bHasQuestionMark)
			str += _T("&");
		else
		{
			str += _T("?");
			bHasQuestionMark = true;
		}
		str += C_TEMPLATE;
		str += _T("=");
		str += strAltHTIname;
	}

	// topic
	if (!m_TopicName.IsEmpty())
	{
		if (bHasQuestionMark)
			str += _T("&");
		else
		{
			str += _T("?");
			bHasQuestionMark = true;
		}
		str += C_TOPIC;
		str += _T("=");
		str += m_TopicName;
	}
#endif
	return str;
}


// Assumes m_Qry.GetFirst has already been called.
// INPUT pszCmd & pszValue are the outputs of m_Qry.GetFirst.
//	These same buffers are used for subsequent calls to m_Qry.GetNext. 
// INPUT *pTopic - represents contents of appropriate DSC, HTI, BES
// INPUT bUsesIDH - Interpret numerics as IDHs (a deprecated feature) rather than NIDs
// Return 0 on success, EV_GTS_ERROR_INF_BADPARAM on failure.
DWORD APGTSContext::DoInference(LPTSTR pszCmd, 
								LPTSTR pszValue, 
								CTopic * pTopic,
								bool bUsesIDH)
{
	DWORD dwStat = 0;
	CString strTopic = pszValue;
	CString strHTTPcookies;
	
	if (!_tcsicmp(pszCmd, C_PRELOAD))
		m_bPreload = true;

	m_infer.SetTopic(pTopic);

	ClearCommandList();
	ClearSniffedList();
	ClearAdditionalInfoList();

	while (m_Qry.GetNext(pszCmd, pszValue)) 
	{		
		if ((dwStat = NextCommand(pszCmd, pszValue, bUsesIDH)) != 0)
			if ((dwStat = NextAdditionalInfo(pszCmd, pszValue)) != 0)
				if ((dwStat = NextIgnore(pszCmd, pszValue)) != 0)
					break;
	}

	if (!dwStat) 
	{
		m_Commands.RotateProblemPageToFront();
		LogNodesPerCommandList();
		SetNodesPerCommandList();
		SetNodesPerSniffedList();
		ProcessAdditionalInfoList();
		ReadPolicyInfo();

		// Append to m_strText: contents of an HTML page based on HTI template.
		// History & next recommendation

		// Build the $StartForm string.
		CString strStartForm;
		CString strTmpLine;
		const CString strAltHTIname= GetAltHTIname();

		if (RUNNING_LOCAL_TS())
			strStartForm =  _T("<FORM NAME=\"ButtonForm\">\n");
		else
			strStartForm.Format( _T("<FORM METHOD=POST ACTION=\"%s\">\n"), m_pConf->GetVrootPath() );

		if (RUNNING_ONLINE_TS())
		{
			// This processes name-value pairs, parallel to those which would come
			//	from a cookie to determine look and feel, but which in this case actually
			//	were originally sent in as CK_ pairs in Get or Post.
			// These values are only used in the Online TS.
			try
			{
				if (!m_mapCookiesPairs.empty())
				{
					// V3.2 - Output any CK_name-value pairs as hidden fields.
					for (CCookiePairs::const_iterator it = m_mapCookiesPairs.begin(); it != m_mapCookiesPairs.end(); ++it)
					{
						CString strAttr= it->first;
						CString strValue= it->second;
						APGTS_nmspace::CookieEncodeURL( strAttr );
						APGTS_nmspace::CookieEncodeURL( strValue );

						strTmpLine.Format(	_T("<INPUT TYPE=HIDDEN NAME=\"%s%s\" VALUE=\"%s\">\n"),
											C_COOKIETAG, strAttr, strValue );
						strStartForm+= strTmpLine;
					}	
				}
	
				// This processes name-value pairs, which actually come
				//	from a cookie to determine look and feel.
				// These values are only used in the Online TS.
				// V3.2 - Extract all look-and-feel cookie name-value pairs from the HTTP headers.
				char	szCookieNameValue[ 1024 ];	// never Unicode, because cookies always ASCII
				DWORD	dwCookieLen= 1023; 
				if ( m_pECB->GetServerVariable(	kHTTP_COOKIE,	szCookieNameValue, &dwCookieLen )) 
					strHTTPcookies= szCookieNameValue;
				else
				{
					// Determine if the buffer was too small.
					if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						// never Unicode, because cookies always ASCII.
						char *pszCookieNameValue= new char[ dwCookieLen + 1 ];
						if ( m_pECB->GetServerVariable(	kHTTP_COOKIE, pszCookieNameValue, &dwCookieLen )) 
							strHTTPcookies= pszCookieNameValue;
						delete [] pszCookieNameValue;
					}
					else
					{
						// Note memory failure in event log.
						CString strLastError;
						strLastError.Format( _T("%d"), ::GetLastError() );
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												strLastError, _T(""), 
												EV_GTS_ERROR_EXTRACTING_HTTP_COOKIES ); 
					}
				}
			}
			catch (bad_alloc&)
			{
				// Note memory failure in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str), 
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}

		if (!strAltHTIname.IsEmpty())
		{
			// Add the alternate HTI template name to the $StartForm string.
			strTmpLine.Format(	_T("<INPUT TYPE=HIDDEN NAME=\"template\" VALUE=\"%s\">\n"),
								CAbstractFileReader::GetJustName( strAltHTIname ) );
			strStartForm+= strTmpLine;
		}
		strTmpLine.Format(	_T("<INPUT TYPE=HIDDEN NAME=\"topic\" VALUE=\"%s\">\n"), strTopic );
		strStartForm+= strTmpLine;

		// Determine whether an alternate HTI template should be used.
		bool bAlternatePageGenerated= false;
		if (!strAltHTIname.IsEmpty())
		{
			// Attempt to extract a pointer to the requested HTI template and if successful
			// then create a page from it.
			CP_TEMPLATE cpTemplate;

			m_pConf->GetTemplate( strAltHTIname, cpTemplate, m_bNewCookie );
			CAPGTSHTIReader	*pHTI= cpTemplate.DumbPointer();
			if (pHTI) 
			{
				CString strResourcePath;
				m_pConf->GetRegistryMonitor().GetStringInfo(CAPGTSRegConnector::eResourcePath, strResourcePath);
#ifdef LOCAL_TROUBLESHOOTER
				CHTMLFragmentsLocal frag( strResourcePath, pHTI->HasHistoryTable() );
#else
				CHTMLFragmentsTS frag( strResourcePath, pHTI->HasHistoryTable() );
#endif

				// Add the $StartForm string to the HTML fragments.
				frag.SetStartForm(strStartForm);

				frag.SetStartOverLink(GetStartOverLink());
				
				// JSM V3.2 get list of Net prop names needed by HTI;
				//   pass them to frag.  CInfer will fill in
				//   the net prop values, using these names, in FillInHTMLFragments()
				{
					vector<CString> arr_props;
					pHTI->ExtractNetProps(arr_props);
					for(vector<CString>::iterator i = arr_props.begin(); i < arr_props.end(); i++)
						frag.AddNetPropName(*i);
				}

				m_infer.IdentifyPresumptiveCause();
				m_infer.FillInHTMLFragments(frag);

				pHTI->CreatePage( frag, m_strText, m_mapCookiesPairs, strHTTPcookies );
				bAlternatePageGenerated= true;
			}
		}
		if (!bAlternatePageGenerated)
		{
			// The page was not generated from an alternate HTI template, generate it now.
			// >>> $MAINT an awful lot of common code with the above.  Can't we
			//		set up a private method?
			CString strResourcePath;
			m_pConf->GetRegistryMonitor().GetStringInfo(CAPGTSRegConnector::eResourcePath, strResourcePath);
#ifdef LOCAL_TROUBLESHOOTER
			CHTMLFragmentsLocal frag( strResourcePath, pTopic->HasHistoryTable() );
#else
			CHTMLFragmentsTS frag( strResourcePath, pTopic->HasHistoryTable() );
#endif

			// Add the $StartForm string to the HTML fragments.
			frag.SetStartForm(strStartForm);

			frag.SetStartOverLink(GetStartOverLink());

			// JSM V3.2 get list of Net prop names needed by HTI;
			//   pass them to frag.  CInfer will fill in
			//   the net prop values, using these names, in FillInHTMLFragments()
			{
				vector<CString> arr_props;
				pTopic->ExtractNetProps(arr_props);
				for(vector<CString>::iterator i = arr_props.begin(); i < arr_props.end(); i++)
					frag.AddNetPropName(*i);
			}
			
			m_infer.IdentifyPresumptiveCause();
			m_infer.FillInHTMLFragments(frag);

			pTopic->CreatePage( frag, m_strText, m_mapCookiesPairs, strHTTPcookies );
		}


		if (m_infer.AppendBESRedirection(m_strHeader)) 
			// We have no more recommendations, but there is a BES file present, so we
			//	have to redirect the user
			_tcscpy(m_resptype, _T("302 Object Moved"));
		
	}
	else 
	{
		SetError(_T(""));
	}

	return dwStat;
}

CString APGTSContext::RetCurrentTopic() const
{
	return( m_TopicName );
}

// Operator actions which must be performed by the main thread are caught in 
//	APGTSExtension::IsEmergencyRequest
// All other operator actions can be identified by this routine.
// INPUT *pECB: our abstraction from EXTENSION_CONTROL_BLOCK, which is ISAPI's way of 
//	packaging CGI data.   pECB should never be null.
APGTSContext::eOpAction APGTSContext::IdentifyOperatorAction(CAbstractECB *pECB)
{
	if (strcmp(pECB->GetMethod(), "GET"))
		return eNoOpAction;
	
	if (strncmp(pECB->GetQueryString(), SZ_EMERGENCY_DEF, strlen(SZ_OP_ACTION)))
		return eNoOpAction;
	
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_RELOAD_TOPIC, strlen(SZ_RELOAD_TOPIC)))
		return eReloadTopic;
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_KILL_THREAD, strlen(SZ_KILL_THREAD)))
		return eKillThread;
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_RELOAD_ALL_TOPICS, strlen(SZ_RELOAD_ALL_TOPICS)))
		return eReloadAllTopics;
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_SET_REG, strlen(SZ_SET_REG)))
		return eSetReg;

	return eNoOpAction;
}

// Identify a request to perform an operator action that does not have to be performed
//	on the main thread.
// Should be called only after we have determined this is an operator action: sends an 
//	error msg to end user if it's not.
// Based loosely on APGTSExtension::ParseEmergencyRequest
// INPUT *pECB: our abstraction from EXTENSION_CONTROL_BLOCK, which is ISAPI's way of 
//	packaging CGI data.   pECB should never be null.
// OUTPUT strArg - any argument for this operation
// Returns identified operator action.
APGTSContext::eOpAction APGTSContext::ParseOperatorAction(
	CAbstractECB *pECB, 
	CString & strArg)
{
	TCHAR *pszProblem= NULL;
	CHAR * ptr = pECB->GetQueryString();

	CHAR * ptrArg = strstr(pECB->GetQueryString(), "&");
	if(ptrArg)
	{
		// Turn the ampersand into a terminator and point past it.
		// Everything past it is an argument.
		*(ptrArg++) = '\0';		
		CCharConversion::ConvertACharToString(ptrArg, strArg) ;
	}
	else
		strArg = _T("");

	// In a sense this test is redundant (should know this before this fn is called) but
	//	this seemed like a safer way to code JM 11/2/98
	eOpAction ret = IdentifyOperatorAction(pECB);

	if ( ret == eNoOpAction) 
		pszProblem= _T("Wrong Format");
	else
	{
		switch(ret)
		{
			case eReloadTopic:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_RELOAD_TOPIC);
				break;
			case eKillThread:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_KILL_THREAD);
				break;
			case eReloadAllTopics:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_RELOAD_ALL_TOPICS);
				break;
			case eSetReg:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_SET_REG);
				break;
			default:
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""), _T(""), 
										EV_GTS_ERROR_INVALIDOPERATORACTION ); 
		}
		
// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifndef NOPWD
		CRegistryPasswords pwd;
		CString str;
		if (! pwd.KeyValidate( 
				_T("ActionAccess"), 
				CCharConversion::ConvertACharToString(ptr, str) ) )
		{
			pszProblem= _T("Bad password");
			ret = eNoOpAction;
		}
#endif // ifndef NOPWD
	}

	if (pszProblem)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								pszProblem,
								_T(""),
								EV_GTS_CANT_PROC_OP_ACTION );

		m_dwErr = EV_GTS_CANT_PROC_OP_ACTION;
	}

	return ret;
}

// Execute a request to  do one of:
// - Reload one topic
// - Kill (and restart) one pool thread
// - Reload all monitored files.
// INPUT *pECB: our abstraction from EXTENSION_CONTROL_BLOCK, which is ISAPI's way of 
//	packaging CGI data.   pECB should never be null.
// INPUT action - chooses among the three possible actions
// INPUT strArg - provides any necessary arguments for that action
// RETURNS HSE_STATUS_SUCCESS, HSE_STATUS_ERROR
void APGTSContext::ExecuteOperatorAction(
	CAbstractECB *pECB, 
	eOpAction action,
	const CString & strArg)
{
	m_strText += _T("<HTML><HEAD><TITLE>AP GTS Command</TITLE></HEAD>");
	m_strText += _T("<BODY BGCOLOR=#FFFFFF>");

	switch (action)
	{
		case eReloadTopic:
			{
				bool bAlreadyInCatalog;
				m_strText += _T("<H1>Reload Topic ");
				m_strText += strArg;
				m_strText += _T("</H1>");
				m_pConf->GetTopicShop().BuildTopic(strArg, &bAlreadyInCatalog);
				if (!bAlreadyInCatalog)
				{
					m_strText += strArg;
					m_strText += _T(" is not a known topic.  Either it is not in the current LST file")
						_T(" or the Online Troubleshooter is waiting to see the resource directory")
						_T(" &quot;settle&quot; before loading the LST file.");
				}
				break;
			}
		case eKillThread:
			m_strText += _T("<H1>Kill Thread");
			m_strText += strArg;
			m_strText += _T("</H1>");
			if (m_pConf->GetThreadPool().ReinitializeThread(_ttoi(strArg)))
				m_strText += _T("Thread killed.  System will attempt to spin a new thread.");
			else
				m_strText += _T("No such thread");
			break;
		case eReloadAllTopics:
			m_strText += _T("<H1>Reload All Topics</H1>");
			m_pConf->GetTopicShop().RebuildAll();
			break;
		case eSetReg:
			{
				CHttpQuery query;
				TCHAR szCmd[MAXBUF];
				TCHAR szVal[MAXBUF];
				CString strCmd, strVal;
				query.GetFirst(strArg, szCmd, szVal);
				CCharConversion::ConvertACharToString(szCmd, strCmd);
				CCharConversion::ConvertACharToString(szVal, strVal);
				
				m_strText += _T("<H1>Set registry value");
				m_strText += strCmd;
				m_strText += _T(" = ");
				m_strText += strVal;
				m_strText += _T("</H1>");

				CAPGTSRegConnector RegConnect( _T("") );
				bool bChanged ;
				bool bExists = RegConnect.SetOneValue(szCmd, szVal, bChanged );

				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								strCmd,
								strVal,
								bExists ? 
									EV_GTS_SET_REG_VALUE :
									EV_GTS_CANT_SET_REG_VALUE); 

				if (bChanged)
					m_strText +=  _T("Successful.");
				else if (bExists)
				{
					m_strText +=  strCmd;
					m_strText +=  _T(" already had value ");
					m_strText +=  strVal;
					m_strText +=  _T(".");
				}
				else
				{
					m_strText +=  strCmd;
					m_strText +=  _T(" Unknown.");
				}
									 

				break;
			}
		default:
			m_strText += _T("<H1>Unknown operation</H1>");
			break;
	}
	m_strText += strArg;

	m_strText += _T("</BODY></HTML>");
}

// override any partially written page with an error page.
void APGTSContext::SetError(LPCTSTR szMessage)
{
	_tcscpy(m_resptype, _T("400 Bad Request"));

	CString str(_T("<H3>Possible invalid data received</H3>\n"));
	str += szMessage;

	m_pConf->CreateErrorPage(str, m_strText);

}

void APGTSContext::SetAltHTIname( const CString& strHTIname )
{
	m_strAltHTIname= strHTIname;
}

CString APGTSContext::GetAltHTIname() const
{
	return( m_strAltHTIname );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsecb.h ===
//
// MODULE: APGTSECB.H
//
// PURPOSE: Interface of CAbstractECB class, which provides an abstraction from Win32's
//	EXTENSION_CONTROL_BLOCK.  Using this abstract class allows us to have common code for
//	the Online Troubleshooter (which actually uses an EXTENSION_CONTROL_BLOCK) and the Local
//	Troubleshooter (which needs to simulate similar capabilities).
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-04-99
//
// NOTES: 
//	1. EXTENSION_CONTROL_BLOCK is extensively documented in the VC++ documentation
//	2. It is imaginable that some of these methods are needed only in the Online Troubleshooter
//		and might be eliminated from this abstract class.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-04-99	JM		Original
//

// apgtsECB.h: interface for the CAbstractECB class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APGTSECB_H__56CCF083_A40C_11D2_9646_00C04FC22ADD__INCLUDED_)
#define AFX_APGTSECB_H__56CCF083_A40C_11D2_9646_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <httpext.h>

class CAbstractECB  
{
public:
	virtual ~CAbstractECB() {}

	// Methods corresponding to EXTENSION_CONTROL_BLOCK data members.  We must provide
	//	Get methods for all inputs from end user system and Set methods for all outputs to 
	//	end user system.  Classes which inherit from this may need Set methods for inputs 
	//	or Get methods for outputs, as well.  For example, the Local Troubleshooter will need
	//	to set the Method and Query String, since it does not actually receive these in 
	//	an EXTENSION_CONTROL_BLOCK.

    // DWORD	cbSize		IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // DWORD	dwVersion	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // HCONN	ConnID		IN, only ever of concern within class COnlineECB

	// DWORD dwHttpStatusCode					OUT
	virtual DWORD SetHttpStatusCode(DWORD dwHttpStatusCode)=0;
    
	// CHAR		lpszLogData[HSE_LOG_BUFFER_LEN]	OUT, not currently used by TS.  Would have 
	//							to add a Set method if this is ever needed

    // LPSTR	lpszMethod		IN
	virtual LPSTR GetMethod() const =0;

    // LPSTR	lpszQueryString	IN
	virtual LPSTR GetQueryString() const =0;

    // LPSTR	lpszPathInfo	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // LPSTR	lpszPathTranslated	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // DWORD	cbTotalBytes	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // DWORD	cbAvailable		IN
	virtual DWORD GetBytesAvailable() const =0;

    // LPBYTE	lpbData			IN
	virtual LPBYTE GetData() const =0;

    // LPSTR	lpszContentType	IN
	virtual LPSTR GetContentType() const =0;

	// Methods corresponding to EXTENSION_CONTROL_BLOCK methods
	// Note that EXTENSION_CONTROL_BLOCK uses pointers to functions, not actual function methods,
	//	but there doesn't seem to be any good reason for that.
    virtual BOOL GetServerVariable
	  ( /*HCONN      hConn,*/	// EXTENSION_CONTROL_BLOCK has an argument here, but for us it can 
								//	always be determined from *this
        LPCSTR       lpszVariableName,	// note, more const-ness than EXTENSION_CONTROL_BLOCK
        LPVOID      lpvBuffer,
        LPDWORD     lpdwSize ) =0;

    virtual BOOL WriteClient
	  ( /*HCONN      ConnID,*/	// EXTENSION_CONTROL_BLOCK has an argument here, but for us it can 
								//	always be determined from *this
	   LPCSTR	  Buffer,	// EXTENSION_CONTROL_BLOCK::WriteClient uses LPVOID, but it should
							//	only be legit to pass SBCS text, so we're enforcing that.
							// Also, we're adding const-ness.   
       LPDWORD    lpdwBytes
	   /* ,DWORD      dwReserved */ // EXTENSION_CONTROL_BLOCK::WriteClient reserves one more arg.
       ) =0;

    virtual BOOL ServerSupportFunction
	  ( /*HCONN      hConn,*/	// EXTENSION_CONTROL_BLOCK has an argument here, but for us it can 
								//	always be determined from *this
       DWORD      dwHSERRequest,
       LPVOID     lpvBuffer,
       LPDWORD    lpdwSize,
       LPDWORD    lpdwDataType ) =0;

	// since we don't use this we haven't bothered implementing.
    // BOOL ( WINAPI * ReadClient )
    //   ( HCONN      ConnID,
    //   LPVOID     lpvBuffer,
    //   LPDWORD    lpdwSize );

};

#endif // !defined(AFX_APGTSECB_H__56CCF083_A40C_11D2_9646_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsinf.cpp ===
//
// MODULE: APGTSINF.CPP
//
// PURPOSE: Inference Engine Interface
//  Completely implement class CInfer.  VERY IMPORTANT STUFF!
//	One of these is created for each user request
//	Some utility functions at end of file.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Many methods in this class could be const if BNTS had more appropriate use of const
// 2. Several places in this file you will see a space after %s in the format passed to 
//	CInfer::AppendMultilineNetProp() or CInfer::AppendMultilineNodeProp().  This is the 
//	upshot of some 12/98 correspondence between Microsoft and Saltmine.  Many older DSC files
//	were built with a tool that could not handle more than 255 characters in a string.
//	The DSC feil format's "Array of string" was used to build up longer strings.  Newer 
//	DSC files (and all Argon-produced DSC files) should use only the first element of this
//	array.
//	The older DSC files assumed that the separate strings would effectively be separated 
//	by white space, so we must maintain that situation.
// 3. >>> $MAINT - exception-handling strategy for push_back and other memory allocation
//	functions is really overkill.  If we run out of memory, we're screwed anyway.  Really
//	would suffice to handle try/catch just at the main function of the thread.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-21-98		JM		Major revision, deprecate IDH.
//			8-27-98		JM		Totally new method of communicating with template
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include "event.h"
#include "apgts.h"
#include "apgtsinf.h"
#include "apgtsmfc.h"
#include "apgtsassert.h"
#include "CharConv.h"
#include "maxbuf.h"
#include <algorithm>
#include <vector>
#include <map>
#include "Sniff.h"
#include "SniffController.h"
#ifdef LOCAL_TROUBLESHOOTER
 #include "SniffLocal.h"
#endif

// -------------------------------------------------------------------
// Constructor/Destructor, other initialization
// -------------------------------------------------------------------
//
// INPUT *pCtxt is a buffer for building the string to pass back over the net.
CInfer::CInfer(CSniffConnector* pSniffConnector) :
#ifdef LOCAL_TROUBLESHOOTER
	m_pSniff(new CSniffLocal(pSniffConnector, NULL)),
#else
	m_pSniff(NULL),
#endif
	m_nidProblem(nidNil),
	m_bDone(false),
	m_bRecOK (false),
	m_SniffedRecommendation(nidNil, SNIFF_FAILURE_RESULT),
	m_bUseBackEndRedirection(false),
	m_bRecycleSkippedNode(false),
	m_nidRecycled(0),
	m_bRecyclingInitialized(false),
	m_nidSelected(nidNil),
	m_bLastSniffedManually(false)
{
}

//
//
CInfer::~CInfer()
{
	delete m_pSniff;
}

// The intention is that this be called only once.
// It would be ideal if this were part of the constructor, but the CTopic * is not
//	yet available at time of construction.  
// The expectation is that this should be called before calling any other function. (Some
//	are technically OK to call, but it's smartest not to rely on that.) 
void CInfer::SetTopic(CTopic *pTopic)
{
	m_pTopic = pTopic;
	if (m_pSniff)
		m_pSniff->SetTopic(pTopic);
}

// This fn exists so APGTSContext can access *m_pSniff to tell it what the sniffing 
//	policies are.  
CSniff* CInfer::GetSniff()
{
	return m_pSniff;
}

// -------------------------------------------------------------------
// First, we set the states of nodes, based on the query string we got from the HTML form
// -------------------------------------------------------------------

// Convert IDH to NID.  Needed on some old query string formats
// "Almost vestigial", still supported in v3.2, but will be dropped in v4.0.
NID CInfer::NIDFromIDH(IDH idh) const 
{
	if (idh == m_pTopic->CNode() + idhFirst)
		return nidProblemPage;
	
	if (idh == nidService + idhFirst)
		return nidService;

	if (idh == IDH_FAIL)
		return nidFailNode;
	
	if (idh == IDH_BYE)
		return nidByeNode;

	ASSERT (idh >= idhFirst);
	return idh - idhFirst;
}

// Associate a state with a node.
// INPUT nid
// INPUT ist -	Normally, index of a state for that node. 
//	If nid == nidProblemPage, then ist is actually NID of selected problem
void CInfer::SetNodeState(NID nid, IST ist)
{
	if (nid == nidNil)
		return;

	CString strTemp;
	CString strTxt;

	if (ist == ST_WORKED) 
	{
		if (nid == nidFailNode || nid == nidSniffedAllCausesNormalNode
			|| nid == nidService || nid == nidImpossibleNode)
		{
			if (m_pTopic->HasBES())
			{
				m_bUseBackEndRedirection = true;
				CString strThrowaway;	// we don't really care about this string;
										//	we call OutputBackend strictly for the side 
										//	effect of setting m_strEncodedForm.
				OutputBackend(strThrowaway);
				return;
			}
		}

		m_bDone = true;
		AddToBasisForInference(nid, ist); // this node still needs to be present 
										  //  in m_arrBasisForInference, as it is
										  //  present in m_SniffedStates.

		// Add to the visited array to be displayed in the visible history page.  RAB-20000628.
		try
		{
			m_arrnidVisited.push_back( nid );
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}

		return;
	}

	if (ist == ST_ANY)
	{
		// We rely on the fact that only a service node offers ST_ANY 
		//	("Is there anything else I can try?")
		m_bRecycleSkippedNode = true; 
		return;
	}

	// We should never have service node go past this point (always ST_WORKED or ST_ANY).

	if (nid == nidByeNode || nid == nidFailNode || nid == nidSniffedAllCausesNormalNode)
		return;

	if (ist == ST_UNKNOWN)	
	{
		// Add it to the list of skipped nodes & visited nodes
		try
		{
			m_arrnidSkipped.push_back(nid);
			m_arrnidVisited.push_back(nid);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
		return;
	}

	if (nid == nidProblemPage) 
	{
		if (!IsProblemNode(ist))
		{
			// Totally bogus query.  Arbitrary course of action.
			m_bRecycleSkippedNode = true;
			return;
		}

		// Change this around to the way we would express it for any other node.
		nid = ist;
		ist = 1;	// Set this problem node to a state value of 1 (in fact, we never
					//	explicitly set problem nodes to state value of 0)

		m_nidProblem = nid;			// special case: here instead of in m_arrnidVisited
		AddToBasisForInference(nid, ist);
		return;
	}

	AddToBasisForInference(nid, ist);

	// Store into our list of nodes obtained from the user
	try
	{
		m_arrnidVisited.push_back(nid);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

void CInfer::AddToBasisForInference(NID nid, IST ist)
{
	try
	{
		m_BasisForInference.push_back(CNodeStatePair(nid, ist)); 
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

// Add to the list of (previously) sniffed nodes.
void CInfer::AddToSniffed(NID nid, IST ist)
{
	try
	{
		if (ist == ST_WORKED && m_pTopic->IsCauseNode(nid)) 
		{   // in case of cause node in abnormal state (which is ST_WORKED)
			//  we need to set state to "1" as if it was sniffed.
			// This situation happens during manual sniffing of cause node that worked.
			ist = 1;
		}
		m_SniffedStates.push_back(CNodeStatePair(nid, ist)); 
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

// Be careful not to call this redundantly: its call to CTopic::GetRecommendations()
//	is expensive.
void CInfer::GetRecommendations()
{
	// if we haven't previously sought a recommendation...
	if ( m_SniffedRecommendation.nid() != nidNil )
	{
		// The one and only relevant recommendation is already forced, so don't bother 
		//	getting recommendations.
		// m_SniffedRecommendation.nid() is a Cause node in its abnormal state
		m_Recommendations.empty();
		try
		{
			m_Recommendations.push_back(m_SniffedRecommendation.nid());
			m_bRecOK = true;
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}
	else
	{
		// Pass data into m_pTopic
		// Get back recomendations.
		int status = m_pTopic->GetRecommendations(m_BasisForInference, m_Recommendations);
		m_bRecOK = (status == CTopic::RS_OK);
	}
}

// returns true if nid is a problem node of this network
bool CInfer::IsProblemNode(NID nid) const
{
	// get data array of problem nodes
	vector<NID>* parrnid = NULL;
	
	m_pTopic->GetProblemArray(parrnid);

	vector<NID>::const_iterator itnidBegin = parrnid->begin();
	vector<NID>::const_iterator itnidEnd = parrnid->end();
	vector<NID>::const_iterator itnidProblem = find(itnidBegin, itnidEnd, nid);

	if (itnidProblem == itnidEnd)
		return false;
	else
		return true;
}

bool CInfer::IsInSniffedArray(NID nid) const
{
	UINT nSniffedNodes = m_SniffedStates.size();

	for (UINT i = 0; i < nSniffedNodes; i++)
	{
		if (m_SniffedStates[i].nid() == nid)
		{
			// Do not have to check for state, as m_SniffedStates will
			//  have only valid states (states, which are accepted by BNTS),
			//  no 102 or -1 states
			return true;
		}
	}

	return false;
}

// -------------------------------------------------------------------
// For writing the new page after inference: the following texts are
//	invariant for a given topic (aka network).
// -------------------------------------------------------------------

// CreateUnknownButtonText:  Reads the network property for the 
// unknown-state radio button from the network dsc file.
// Puts value in strUnknown
// This is specific to the radio button for "unknown" in the history table, 
//	that is, for a node which has previously been visited.  This should not be
//	used for the radio button for the "unknown" state of the present node.
void CInfer::CreateUnknownButtonText(CString & strUnknown) const
{
	strUnknown = m_pTopic->GetNetPropItemStr(HTK_UNKNOWN_RBTN);
	if (strUnknown.IsEmpty())
		strUnknown = SZ_UNKNOWN;
	return;
}

// AppendNextButtonText:  Reads the network property for the 
// NEXT button from the network dsc file and append it to str.
void CInfer::AppendNextButtonText(CString & str) const
{
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_NEXT_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_NEXT_BTN;

	str += strTemp;
	return;
}

// AppendNextButtonText:  Reads the network property for the 
// NEXT button from the network dsc file and append it to str.
void CInfer::AppendStartOverButtonText(CString & str) const
{
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_START_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_START_BTN;

	str += strTemp;
	return;
}

// AppendBackButtonText:  Reads the network property for the 
// BACK button from the network dsc file and append it to str.
void CInfer::AppendBackButtonText(CString & str) const
{
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_BACK_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_BACK_BTN;

	str += strTemp;
	return;
}

// AppendPPSnifferButtonText:  Reads the network property for the 
// sniffer button from the network dsc file.
// NOTE that this button is related to "expensive" sniffing only.
// Appends to str.
void CInfer::AppendPPSnifferButtonText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_SNIF_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_PP_SNIF_BTN;

	str += strTemp;
}

// AppendManualSniffButtonText:  Reads the network property for the 
// manual sniff button from the network dsc file.
// Appends to str.
void CInfer::AppendManualSniffButtonText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_TEXT_SNIFF_ONE_NODE);

	if (strTemp.IsEmpty())
		strTemp = SZ_SNIFF_ONE_NODE;

	str += strTemp;
}

// AppendHistTableSniffedText:  Reads the network property for the 
// indication in history table that a node was sniffed.
// Appends to str.
void CInfer::AppendHistTableSniffedText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_HIST_TABLE_SNIFFED_TEXT);

	if (strTemp.IsEmpty())
		strTemp = SZ_HIST_TABLE_SNIFFED_TEXT;

	str+= _T("<BR>\n");
	str += strTemp;
}

// AppendAllowSniffingText:  Reads the network property for the 
// label of the AllowSniffing checkbox from the network dsc file.
// Appends to str.
void CInfer::AppendAllowSniffingText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_ALLOW_SNIFFING_TEXT);

	if (strTemp.IsEmpty())
		strTemp = SZ_ALLOW_SNIFFING_TEXT;

	str += strTemp;
}

// AppendSniffFailedText:  Reads the network property for the 
// alert box to be used when manual sniffing fails from the network dsc file.
// Appends to str.
void CInfer::AppendSniffFailedText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_TEXT_SNIFF_ALERT_BOX);

	if (strTemp.IsEmpty())
		strTemp = SZ_SNIFF_FAILED;

	str += strTemp;
}

// Appends an HTML link but makes it look like an HTML Form Button
// useful for Start Over in Online TS, because with no idea what browser user will have, 
// we can't usefully use an onClick method (not supported in older browsers).
// Online TS runs in a "no scripting" environment.
// Pure HTML doesn't provide a means to put both a "Next" and a "Start Over" button
//	in the same HTML form.  Conversely, if Start Over btn was outside the form, pure HTML 
//	doesn't provide a means to align it with a button in the form.
// Note that x.gif does not exist: its absence creates a 1-pixel placeholder.
// >>>$MAINT We may want to change some of the rowspans to better emulate the exact size 
//	of a button; try to make it look perfect under IE
void CInfer::AppendLinkAsButton(
	CString & str, 
	const CString & strTarget, 
	const CString & strLabel) const
{
	str += _T("<!-- Begin pseudo button -->"
		"<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n"
		"<tr>\n"
		"	<td rowspan=\"6\" bgcolor=\"white\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"	<td colspan=\"3\" bgcolor=\"white\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#C0C0C0\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"3\"></td>\n"
		"	<td rowspan=\"4\" bgcolor=\"#808080\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"	<td rowspan=\"4\" bgcolor=\"#000000\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#C0C0C0\">\n");

	// >>> $MAINT might want to change the font/style in the following
	str += _T("<font face=\"Arial\" size=\"2\">&nbsp;&nbsp;&nbsp;\n"
		"	<a href=\"");
	str += strTarget;
	str += _T("\" style=\"text-decoration:none; color:black\">\n"
		"	<font color=\"black\">");
	str += strLabel;
	str += _T("</font></a>\n"
		"	&nbsp;&nbsp;&nbsp;</font></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#C0C0C0\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"3\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#808080\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td colspan=\"3\" bgcolor=\"#000000\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"</table>\n"
		"<!-- End pseudo button -->\n");
}

// -------------------------------------------------------------------
// Writing to the new HTML page.  Miscellaneous low-level pieces.
// -------------------------------------------------------------------

// If the state name is missing or is simply "<hide>", return true.
// This indicates a state that should never be overtly presented to the user as a choice.
// Typically used in an informational node, this may describe a state that can be deduced with
//	100% certainty from certain other node/state combinations.
/* static */ bool CInfer::HideState(LPCTSTR szStateName)
{
	if (szStateName && *szStateName && _tcscmp(szStateName, _T("<hide>") ) )
		return false;

	return true;
}

// write a symbolic name (based on NID) to a string sz
// INPUT nid - node ID
// OUTPUT str - the string to which we write.
// RETURNS true if successful
// NOTE that this restores the "current" node when it is finished.
//	Alternative would be side effect of setting current node (by omitting nidOld), but that
//	would work strangely on "special" nodes (e.g. Service, Fail), which aren't in BNTS.
bool CInfer::SymbolicFromNID(CString & str, NID nid) const
{
	if (nid == nidProblemPage)
    {
		str= NODE_PROBLEM_ASK;
		return true;
	}
	if (nid == nidService) 
	{
		str= NODE_SERVICE;
		return true;
	}

	if (nid == nidFailNode)
	{
		str= NODE_FAIL;
		return true;
	}
	
	if (nid == nidSniffedAllCausesNormalNode)
	{
		str= NODE_FAILALLCAUSESNORMAL;
		return true;
	}
	
	if (nid == nidImpossibleNode)
	{
		str= NODE_IMPOSSIBLE;
		return true;
	}
	
	if (nid == nidByeNode)
	{
		str= NODE_BYE;
		return true;
	}

	// if it's a "normal" node, this will fill in the name
	str= m_pTopic->GetNodeSymName(nid);

	return (!str.IsEmpty() );
}

// append an HTML radio button to str
// INPUT/OUTPUT str - the string to which we append
// INPUT szName, szValue - For <INPUT TYPE=RADIO NAME=szName VALUE=szValue> 
// INPUT szLabel - text to appear after the radio button but before a line break
/*static*/ void CInfer::AppendRadioButtonCurrentNode(
	CString &str, LPCTSTR szName, LPCTSTR szValue, LPCTSTR szLabel, bool bChecked/*= false*/)
{
	CString strTxt;

	if ( ! HideState(szLabel))
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TR>\n<TD>\n";

		strTxt.Format(_T("<INPUT TYPE=RADIO NAME=\"%s\" VALUE=\"%s\" %s> %s"), 
					  szName, szValue, bChecked ? _T("CHECKED") : _T(""), szLabel);
		str += strTxt;

		if (RUNNING_LOCAL_TS())
			str += "\n</TD>\n</TR>\n";
		else
			str += "\n<BR>\n";
	}
}

//	This is different than other radio buttons because it 
//		- has a different format for label szLabel.
//		- vanishes if bShowHistory is false and this button isn't CHECKED
//		- turns into a hidden field if bShowHistory is false and this button is CHECKED
//		- writes SNIFFED_ values as applicable...although that's not in this function: it's
//			handled in a separate call to AppendHiddenFieldSniffed()
// JM 11/12/99 previously, we special-cased hidden states here.  However, per 11/11/99 email 
//	from John Locke, the only state we ever hide in the History Table (for v3.2) is the
//	Unknown/skipped state, and that is handled elsewhere.
// INPUT/OUTPUT str - string to which we append the HTML for this button.
// INPUT nid - NID of node
// INPUT value - state 
// INPUT bSet - true ==> button is CHECKED
// INPUT szctype - short name of the state
// INPUT bShowHistory - see explanation a few lines above
void CInfer::AppendRadioButtonVisited(
	CString &str, NID nid, UINT value, bool bSet, LPCTSTR szLabel, bool bShowHistory) const
{
	CString strTxt;
	CString strSymbolic;

	SymbolicFromNID(strSymbolic, nid);

	if (bShowHistory)
		strTxt.Format(_T("<INPUT TYPE=RADIO NAME=%s VALUE=%u%s>%-16s \n"), 
			strSymbolic, value, bSet ? _T(" CHECKED") : _T(""), szLabel);
	else if (bSet)
		strTxt.Format(_T("<INPUT TYPE=HIDDEN NAME=%s VALUE=%u>\n"), 
			strSymbolic, value);

	str += strTxt;
}

// If this nid is an already sniffed node, then we append this fact as a 
//	"hidden" value in the HTML in str.
// For example, if a node with symbolic name FUBAR has been sniffed in state 1,
//	we will append "<INPUT TYPE=HIDDEN NAME=SNIFFED_FUBAR VALUE=1>\n"
// INPUT: string to have appended; node ID
// OUTPUT: string with appended hidden field if node was sniffed
// RETURN: true id string is appended
void CInfer::AppendHiddenFieldSniffed(CString &str, NID nid) const
{
	CString strSymbolic;
	UINT nSniffedNodes = m_SniffedStates.size();

	SymbolicFromNID(strSymbolic, nid);

	for (UINT i = 0; i < nSniffedNodes; i++)
	{
		if (m_SniffedStates[i].nid() == nid)
		{
			// Do not have to check for state, as m_SniffedStates will
			//  have only valid states (states, which are accepted by BNTS),
			//  no 102 or -1 states

			// In case that this is manually sniffed cause node in abnormal state
			//  (and we just re-submit previous page), we need not mention
			//  this node as sniffed.
			
			if (!(IsManuallySniffedNode(nid) &&
				  m_SniffedStates[i].state() == 1 &&
				  m_pTopic->IsCauseNode(nid))
			   )
			{
				CString strTxt;

				strTxt.Format(_T("<INPUT TYPE=HIDDEN NAME=%s%s VALUE=%u>\n"), 
							  C_SNIFFTAG, strSymbolic, m_SniffedStates[i].state());
				str += strTxt;
				return;
			}
		}
	}
}

// Appends (to str) info conveying whether Automatic Sniffing is allowed.
void CInfer::AddAllowAutomaticSniffingHiddenField(CString &str) const
{
	CString strTxt;

	strTxt.Format(_T("<INPUT TYPE=HIDDEN NAME=%s VALUE=%s>\n"), 
				  C_ALLOW_AUTOMATIC_SNIFFING_NAME, C_ALLOW_AUTOMATIC_SNIFFING_CHECKED);
	str += strTxt;
}

// Radio buttons for currently recommended node
// Each button will appear only if appropriate string property is defined 
// Accounts for multi-state or simple binary node.
// INPUT nid - identifies a node of an appropriate type
// INPUT/OUTPUT str - string to which we are appending to build HTML page we send back.
// The detailed behavior of this function was changed at John Locke's request 11/30/98 for V3.0.
// Then for v3.1, handling of H_ST_AB_TXT_STR, H_ST_NORM_TXT_STR removed 8/19/99 per request 
//	from John Locke & Alex Sloley
void CInfer::AppendCurrentRadioButtons(NID nid, CString & str)
{
	CString strSymbolic;

	SymbolicFromNID(strSymbolic, nid);

	CString strPropLongName;	// long name of property

	int nStates = m_pTopic->GetCountOfStates(nid);

	if (RUNNING_LOCAL_TS())
		str += "\n<TABLE>";

	for (IST state=0; state < nStates; state ++)
	{
		TCHAR szStateNumber[MAXBUF]; // buffer for _itot()
		CString strDisplayState = _itot( state, szStateNumber, 10 );
		if (state == 1 && m_pTopic->IsCauseNode( nid ))
			strDisplayState = SZ_ST_WORKED;

		strPropLongName = _T("");

		if (strPropLongName.IsEmpty())
			// account for multistate node
			strPropLongName = m_pTopic->GetNodePropItemStr(nid, MUL_ST_LONG_NAME_STR, state);

		// if we're not past the end of states, append a button
		if (!strPropLongName.IsEmpty())
			AppendRadioButtonCurrentNode(str, 
										 strSymbolic, 
										 strDisplayState, 
										 strPropLongName, 
										 // check state button if this state was sniffed
										 m_SniffedRecommendation.state() == state ? true : false);
	};

	// "unknown" state (e.g. "I want to skip this")
	strPropLongName = m_pTopic->GetNodePropItemStr(nid, H_ST_UKN_TXT_STR);
	if (!strPropLongName.IsEmpty())
		AppendRadioButtonCurrentNode(str, strSymbolic, SZ_ST_UNKNOWN, strPropLongName);

	if (RUNNING_LOCAL_TS())
		str += "</TABLE>\n";

	return;
}

// If we are showing the history table, place a localizable Full Name 
//	(e.g."Printouts appear garbled") of problem and a hidden-data  
//	field corresponding to this problem into str.
// Otherwise, just the hidden data field
void CInfer::CreateProblemVisitedText(CString & str, NID nidProblem, bool bShowHistory)
{
	// This code is structured in pieces as sending all of these strings to a single
	// CString::Format() results in a program exception. Did some research into this
	// behavior but did not discover anything.  RAB-981014.
	CString tmpStr;

	tmpStr.Format( _T("%s"), bShowHistory ? m_pTopic->GetNodeFullName(nidProblem) : _T("") );
	str= tmpStr;
	tmpStr.Format( _T("<INPUT TYPE=HIDDEN NAME=%s "), NODE_PROBLEM_ASK ); 
	str+= tmpStr;
	tmpStr.Format( _T("VALUE=%s>"), m_pTopic->GetNodeSymName(nidProblem) );
	str+= tmpStr;
	tmpStr.Format( _T("%s"), bShowHistory ? _T("") : _T("\n") );
	str+= tmpStr;
	str+= _T("\n");
}

// Append a NET property (for Belief Network as a whole, not for one 
//	particular node) to str.
// INPUT/OUTPUT str - string to append to
// INPUT item - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
void CInfer::AppendMultilineNetProp(CString & str, LPCTSTR szPropName, LPCTSTR szFormat)
{
	str += m_pTopic->GetMultilineNetProp(szPropName, szFormat);
}

// Like AppendMultilineNetProp, but for a NODE property item, for one particular node.
// INPUT/OUTPUT str - string to append to
// INPUT item - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
void CInfer::AppendMultilineNodeProp(CString & str, NID nid, LPCTSTR szPropName, LPCTSTR szFormat)
{
	str += m_pTopic->GetMultilineNodeProp(nid, szPropName, szFormat);
}


// JSM V3.2 Wrapper for AppendMultilineNetProp to make it easier
//  to fill in the Net properties in HTMLFragments
CString CInfer::ConvertNetProp(const CString &strNetPropName)
{
	CString strNetPropVal;
	AppendMultilineNetProp(strNetPropVal,strNetPropName,"%s");
	return strNetPropVal;
}


// If there is a pre-sniffed recommendation, remove it from the list & set m_SniffedRecommendation.
void CInfer::IdentifyPresumptiveCause()
{
	vector<NID> arrnidNoSequence;
	multimap<int, NID> mapSeqToNID;

	// Find all presumptive causes
	for (int i = 0; i < m_SniffedStates.size(); i++)
	{
		if (m_pTopic->IsCauseNode(m_SniffedStates[i].nid())  // cause node ...
			&& 
			m_SniffedStates[i].state() == 1) // ... that is sniffed in abnormal (1) state
		{
			if (IsManuallySniffedNode(m_SniffedStates[i].nid()))
			{
				// now we have manually sniffed cause node in abnormal state.
				// It means that we are re-submitting the page. We will set m_SniffedRecommendation
				//  to this node, and return.
				m_SniffedRecommendation = CNodeStatePair(m_SniffedStates[i].nid(), 1 /*cause node abnormal state*/);
				return;
			}

			NID nid = m_SniffedStates[i].nid();
			CString str = m_pTopic->GetNodePropItemStr(nid, H_NODE_CAUSE_SEQUENCE);
			try
			{
				if (str.IsEmpty())
					arrnidNoSequence.push_back(nid);
				else
				{
					mapSeqToNID.insert(pair<int, NID>(_ttoi(str), nid));
				}
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str),
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}
	}

	// We want the first in sequence according to H_NODE_CAUSE_SEQUENCE numbering.
	// If nothing has a number, we settle for the (arbitrary) first in the array of
	//	unnumbered Cause nodes.
	if (mapSeqToNID.size() > 0)
		m_SniffedRecommendation = CNodeStatePair( (mapSeqToNID.begin()->second), 1 /*cause node abnormal state*/);
	else if (arrnidNoSequence.size() > 0)
		m_SniffedRecommendation = CNodeStatePair( *(arrnidNoSequence.begin()), 1 /*cause node abnormal state*/);

	// now remove the matching nid from the incoming arrays
	if (m_SniffedRecommendation.nid() != nidNil)
	{
		for (i = 0; i < m_BasisForInference.size(); i++)
		{
			if (m_BasisForInference[i].nid() == m_SniffedRecommendation.nid())
			{
				m_BasisForInference.erase(m_BasisForInference.begin() + i);
				break;
			}
		}
		for (i = 0; i < m_SniffedStates.size(); i++)
		{
			if (m_SniffedStates[i].nid() == m_SniffedRecommendation.nid())
			{
				m_SniffedStates.erase(m_SniffedStates.begin() + i);
				break;
			}
		}
		for (i = 0; i < m_arrnidVisited.size(); i++)
		{
			if (m_arrnidVisited[i] == m_SniffedRecommendation.nid())
			{
				m_arrnidVisited.erase(m_arrnidVisited.begin() + i);
				break;
			}
		}
	}
}

// return true if every Cause node in the topic is determined to be normal;
//	this would imply that there is nothing useful this topic can do for us.
bool CInfer::AllCauseNodesNormal()
{
	// for every node in this Belief Network (but taking action only on "cause" nodes)
	// see if each of these is known to be Normal
	for(int nid = 0; nid < m_pTopic->CNode(); nid++)
	{
		if (m_pTopic->IsCauseNode(nid))
		{
			bool bFound=false;

			for (CBasisForInference::iterator p= m_SniffedStates.begin();
				p != m_SniffedStates.end();
				++p)
			{
				if (p->nid() == nid)
				{
					if (p->state() != 0)
						// found a Cause node in an abnormal state (or skipped)
						return false;

					bFound = true;
					break;
				}
			}
			if (!bFound)
				// found a Cause node for which no state is set
				return false;
		}
	}
	return true;
}

// -------------------------------------------------------------
// Writing pieces of the new HTML page.  This builds a structure to be used under HTI 
//	control to represent the recommended node and the (visible or invisible) history table.
// -------------------------------------------------------------
void CInfer::FillInHTMLFragments(CHTMLFragmentsTS &frag)
{
	vector<NID>arrnidPresumptiveCause;

	// First, a side effect: get the URL for the Online TS Start Over link / pseudo-button
	m_strStartOverLink = frag.GetStartOverLink();

	// Then on to the main business at hand.  In practice (at least as of 11/99)
	//	bIncludesHistoryTable and bIncludesHiddenHistory are mutually exclusive, 
	//	but this class doesn't need that knowledge.
	const bool bIncludesHistoryTable = frag.IncludesHistoryTable(); 
	const bool bIncludesHiddenHistory = frag.IncludesHiddenHistory();

	{
		// JSM V3.2: convert the net properties in the HTML fragment
		// The HTI template may indicate that certain net properties are to be written
		//	directly into the resulting page. We get a list of these properties and
		//	fill in a structrue in frag to contain their values.
		CString strNetPropName;
		for(;frag.IterateNetProp(strNetPropName);)
			frag.SetNetProp(strNetPropName,ConvertNetProp(strNetPropName));
	}
	{
		// JM V3.2 to handle sniffing correctly, must do this before history table: sniffing
		//	on the fly (which happens in AppendCurrentNodeText()) could add to the history.
		CString strCurrentNode;
		AppendCurrentNodeText(strCurrentNode);
		frag.SetCurrentNodeText(strCurrentNode);
	}

	CString strHiddenHistory;
	if (m_nidProblem != nidNil)
	{
		CString strProblem;
		CreateProblemVisitedText(strProblem, m_nidProblem, frag.IncludesHistoryTable());

		// OK V3.2 We use hidden field to save the value returned by the "AllowSniffing" 
		//	checkbox (on the problem page) and pass it to each subsequent page.
		// We effectively place this before the history table.
		if (m_pSniff)
			if (m_pSniff->GetAllowAutomaticSniffingPolicy())
				AddAllowAutomaticSniffingHiddenField(strProblem);

		// Added for V3.2 sniffing
		// Not lovely, but this is where we insert sniffed presumptive causes (as hidden
		//	fields).  
		// >>> $MAINT Once we integrate with a launcher, this may require 
		//	further thought: what if we sniff presumptive causes before we have an 
		//	identified problem? Where do we put those hidden fields?
		for (UINT i=0; i<m_arrnidVisited.size(); i++)
		{
			NID nid = m_arrnidVisited[i];
			int stateSet = SNIFF_FAILURE_RESULT;

			{
				UINT nSetNodes = m_SniffedStates.size();
				for (UINT ii = 0; ii < nSetNodes; ii++)
					if (m_SniffedStates[ii].nid() == nid) {
						stateSet = m_SniffedStates[ii].state();
						break;
					}
			}

			if (m_pTopic->IsCauseNode(nid) && stateSet == 1)
			{
				// This is a cause node sniffed as abnormal, to be presented eventually 
				//	as a "presumptive" cause.  All we put in the History table is hidden
				AppendStateText(strProblem, nid, 1, true, false, false, stateSet);
				try
				{
					arrnidPresumptiveCause.push_back(nid);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}

		if (bIncludesHistoryTable)
			frag.SetProblemText(strProblem);
		if (bIncludesHiddenHistory)
			strHiddenHistory = strProblem;
	}


	UINT nVisitedNodes = m_arrnidVisited.size();
	// iVisited incremented for every visited node, iHistory only for a subset:
	//	if we have a visible History table, iHistory provides an index of nodes visible
	//	to the end user.  If not, iHistory is a harmless irrelevance
	for (UINT iVisited=0, iHistory=0; iVisited<nVisitedNodes; iVisited++)
	{
		NID nid = m_arrnidVisited[iVisited];
		int nStates = m_pTopic->GetCountOfStates(nid);
		int stateSet = -1;

		if (IsSkipped(nid))
		{
			// "skipped" node.
			// instead of ST_UNKNOWN (==102), stateSet uses the number immediately 
			//	past the last valid state of this node.  Most nodes have only states 
			//	0, 1, and 102 so typically stateSet is set = 2, but a multistate 
			//	node can use a different number
			stateSet = nStates;
		}
		else
		{
			UINT nSetNodes = m_BasisForInference.size();
			for (UINT ii = 0; ii < nSetNodes; ii++)
				if (m_BasisForInference[ii].nid() == nid) {
					stateSet = m_BasisForInference[ii].state();
					break;
				}
		}

		// The following test added for V3.2 sniffing
		// Weed out cause node sniffed as abnormal, to be presented eventually 
		//	as a "presumptive" cause.  Handled above as a hidden field.
		if (find(arrnidPresumptiveCause.begin(), arrnidPresumptiveCause.end(), nid)
			!= arrnidPresumptiveCause.end())
		{
			// cause node sniffed as abnormal
		}
		else
		{
			if (bIncludesHistoryTable)
			{
				CString strVisitedNode;
				AppendVisitedNodeText(strVisitedNode, nid, true);
				frag.PushBackVisitedNodeText(strVisitedNode);
			}

			for (UINT iState=0; iState <= nStates; iState++)
			{
				if (bIncludesHistoryTable)
				{
					CString strState;

					AppendStateText(strState, nid, iState, iState == stateSet, 
									iState == nStates, true, stateSet);

					// If we are processing last state, and we need to attach
					//  hidden field for this node as sniffed one 
					//  (if it ts really sniffed)
					if (iState == nStates)
						AppendHiddenFieldSniffed(strState, nid);

					// We need not have empty entry in CHTMLFragment's array,
					//  describing history table, so by applying "numPresumptiveCauseNodesEncounered"
					//  we make this array continuous
					frag.PushBackStateText(iHistory, strState);
				}
				if (bIncludesHiddenHistory)
				{
					AppendStateText(strHiddenHistory, nid, iState, iState == stateSet, 
									iState == nStates, false, stateSet);

					// same as in case of visible history table applies.
					if (iState == nStates)
						AppendHiddenFieldSniffed(strHiddenHistory, nid);
				}
			}

			if (bIncludesHistoryTable)
			{
				// Check if we need to mark this as visibly sniffed.
				UINT nSniffedNodes = m_SniffedStates.size();
				for (UINT i = 0; i < nSniffedNodes; i++)
				{
					if (m_SniffedStates[i].nid() == nid)
					{
						// mark it visibly as sniffed
						CString strState;
						AppendHistTableSniffedText( strState );
						frag.PushBackStateText(iHistory, strState);
						break;
					}
				}
			}
			iHistory++;
		}
	}

	if (frag.IncludesHiddenHistory())
		frag.SetHiddenHistoryText(strHiddenHistory);

	frag.SetSuccessBool(m_bDone);
}

// Append the text for the current (recommended) node to str
void CInfer::AppendCurrentNodeText(CString & str)
{
	CString strSave = str;

	if (m_nidProblem == nidNil) 
		// show first page (radio-button list of possible problems)
		AppendProblemPage(str);
	else if (m_bDone && !ManuallySniffedNodeExists())
		AppendNIDPage(nidByeNode, str);
	else if ( m_SniffedRecommendation.nid() != nidNil )
		// we already have a recommendation, presumably from a sniffer
		AppendNIDPage(m_SniffedRecommendation.nid(), str);
	else 
	{
		// sniff/resniff all, as needed
		if (RUNNING_LOCAL_TS())
		{
			// Before we mess with m_BasisForInference, determine if the only node with a 
			//	state is the problem node			
			// [BC - 20010301] - Added check for size of skipped node count when setting
			// bHaveOnlyProblem here. This catches case where user selects to skip first
			// node presented, when that node is sniffed in abnormal state.
			bool bHaveOnlyProblem = (m_BasisForInference.size() == 1) &&
									(m_arrnidSkipped.size() == 0);


			if (m_pSniff)
			{
				long nExplicitlySetByUser = 0;
				CBasisForInference arrManuallySniffed; // can contain max 1 element;
													   //  used to prevent resniffing
													   //  of already sniffed node.
				// We need arrayOrderRestorer in order to make sure that when sniffed
				//	nodes are first removed from the array of visited nodes, then restored,
				//	we maintain the same sequence in which nodes were visited in the first 
				//	place.  This order is important in our caching strategy and also provides
				//	a sense of consistency for the end user.
				CArrayOrderRestorer	arrayOrderRestorer(m_arrnidVisited);

				if (ManuallySniffedNodeExists())
				{
					arrManuallySniffed.push_back(m_SniffedStates[m_SniffedStates.size()-1]);
				}
				
				// Remove all sniffed nodes from m_BasisForInference 
				m_BasisForInference -= m_SniffedStates;

				// remove m_SniffedStates from m_arrnidVisited
				m_arrnidVisited -= m_SniffedStates;
				nExplicitlySetByUser = m_arrnidVisited.size();

				if (bHaveOnlyProblem)					
				{
					// sniff all since we're in problem page
					m_pSniff->SniffAll(m_SniffedStates);
				}
				else
				{
					CBasisForInference arrSniffed;

					// resniff all except recently sniffed manually (if any)
					arrSniffed = m_SniffedStates;
					arrSniffed -= arrManuallySniffed;
					m_pSniff->Resniff(arrSniffed);
					arrSniffed += arrManuallySniffed;
					m_SniffedStates = arrSniffed;
				}

				// add updated m_SniffedStates to m_arrnidVisited
				m_arrnidVisited += m_SniffedStates;

				arrayOrderRestorer.Restore(nExplicitlySetByUser, m_arrnidVisited);

				// Add all sniffed nodes into m_BasisForInference
				m_BasisForInference += m_SniffedStates;

				if (bHaveOnlyProblem && AllCauseNodesNormal())
				{
					// We just sniffed at startup & we already know all Cause nodes
					//	are in their normal states. There is absolutely nothing this
					//	troubleshooting topic can do to help this user.
					AppendSniffAllCausesNormalPage(str);
					return;
				}
			}

			// in case that we do not have sniffed recommendation from manual sniffing
			if (m_SniffedRecommendation.nid() == nidNil)
			{
				// Did we get a presumptive cause out of that?
				IdentifyPresumptiveCause();
			}
			if ( m_SniffedRecommendation.nid() != nidNil )
			{
				AppendNIDPage(m_SniffedRecommendation.nid(), str);
				return;
			}
		}

		bool bSniffSucceeded = true;
		while (bSniffSucceeded)
		{
			IST state = -1;
			NID nidNew = nidNil;

			GetRecommendations();

			if (!m_bRecOK)
			{
				str = strSave;
				AppendImpossiblePage(str);
				return;
			}
			else if (m_Recommendations.empty())
			{
				str = strSave;
				AppendNIDPage(nidFailNode, str);
				return;
			}
			else // Have Recommendations
			{
				// Find a recommendation from list of recommendations that is
				// not in the skip list. This is normally the first node in the
				// list.
				int n = m_Recommendations.size();

				for (UINT i=0; i<n; i++) 
				{
					if (!IsSkipped(m_Recommendations[i])) 
					{
						nidNew = m_Recommendations[i];
						str = strSave;
						AppendNIDPage(nidNew, str);
						break;	// out of for loop: just one recommendation is actually 
								// reported back to user.
					}
				}

				// It is our first pass, no sniffed node pages
				//  were composed earlier in this loop
				if (nidNew == nidNil)
				{
					// We fell though if the entire list of recommendations has been skipped
					// via "ST_UNKNOWN" selection by the user.
					if (m_bRecycleSkippedNode)
						RecycleSkippedNode(); // this can affect m_bRecycleSkippedNode

					if (m_bRecycleSkippedNode)
					{
						// The user got the service node earlier and now wants to review
						// the nodes they marked "Unknown".  We already removed the first 
						// "Unknown" node from the skip list and put its NID in 
						// m_nidRecycled. Now we just do a normal display of the page 
						// for that node.
						nidNew = m_nidRecycled;
						str = strSave;
						AppendNIDPage(nidNew, str);
						return;
					}
					else if (!m_arrnidSkipped.empty())
					{
						// We've got "Unknowns", they weren't just in the service page,
						// so give 'em the service page
						str = strSave;
						AppendNIDPage(nidService, str);
						return;
					}
					else
					{
						// no unknowns.  Fail.  Believed never to arise here, but coded
						// this way for safety.
						str = strSave;
						AppendNIDPage(nidFailNode, str);
						return;
					}
				}
			}

			bSniffSucceeded = false;

			// sniffing on the fly
			if (m_pSniff)
				bSniffSucceeded = m_pSniff->SniffNode(nidNew, &state);

			if (bSniffSucceeded)
			{
				// if it's a cause node and was sniffed as abnormal
				if (m_pTopic->IsCauseNode(nidNew) && state == 1)
				{
					// Display this page as a presumptive cause.
					m_SniffedRecommendation = CNodeStatePair( nidNew, state );
					str = strSave;
					AppendNIDPage(nidNew, str);
					return;
				}
				CNodeStatePair nodestateNew(nidNew, state);
				try
				{
					m_SniffedStates.push_back(nodestateNew);
					m_BasisForInference.push_back(nodestateNew);
					m_arrnidVisited.push_back(nidNew);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
	}
}


// Write radio buttons describing what was decided by user in a previous node.  Part 
//	of "the table" (aka "the visited node table" or "table of previous responses").  
//
// Note that Cause nodes are specially handled.  On a cause node:
//	state 0 = "no, this didn't fix it"
//	state 1 = This wasn't OK, so we have a diagnosis.  In that case, we
//		wouldn't be displaying these radio buttons.
//		We don't want the user selecting that value from the history table.
//		We append this only if it's been sniffed and must be presented as a presumptive 
//		cause, and even then we always append it "hidden"
//	state 2 = "skipped"
//
// In other words, on a cause node, the only possibilities we offer to the user through 
//	a visible history table are state 0 () and "skip".  
//
// In the case where a Cause node has been sniffed abnormal, THE CALLING ROUTINE is 
//	responsible to call this only for the abnormal state.  Otherwise, call for all states.
//
// OUTPUT str - string to which we append
// INPUT nid	node of which this is a state
// INPUT state	state number; for ST_UNKNOWN, this is the count of states, not 102
// INPUT bSet	true = this is the current state of this node
// INPUT bSkipped true = this is the "skipped" state, not a normal node state known to BNTS
// INPUT bShowHistory true = we are showing a history table, false = history is stored
//		invisibly in the HTML.
void CInfer::AppendStateText(CString & str, NID nid, UINT state, bool bSet, bool bSkipped, 
							 bool bShowHistory, int nStateSet) 
{
	// Check if this selection worked.  
	// If so only display the "it worked" text in the history table.
	if (m_pTopic->IsCauseNode(nid) && nStateSet == ST_WORKED)
	{
		if (state == 1) // it is presumptive cause ...
			AppendRadioButtonVisited(	str, nid, state, true, 
										m_pTopic->GetStateName(nid, state), bShowHistory);
		return;
	}

	if (bSkipped)
	{
		CString strUnknownLongName = m_pTopic->GetNodePropItemStr(nid, H_ST_UKN_TXT_STR);
		// The following test is per 11/11/99 email from John Locke
		if (HideState(strUnknownLongName))
			return;		// totally omit Unknown from history table: Unknown cannot be
						// selected for this node.

		// Previous calls to AppendStateText have looped through the states known to BNTS; 
		//	now we handle "skipped", which is a concept BNTS lacks.
		CString strUnknown;

		CreateUnknownButtonText(strUnknown);
		AppendRadioButtonVisited(str, nid, ST_UNKNOWN, bSet, strUnknown, bShowHistory);
		return;
	}

	if (m_pTopic->IsCauseNode(nid) && state == 1) // it is presumptive cause ...
	{
		if (IsInSniffedArray(nid)) //... taken from sniffed array, but NOT current node.
		{
			// We are about to add entry for presumptive cause node.
			//  Actually, since this is sniffed node, we need to have two entries:
			//  one hidden fiels with node name and one hidden field with node name 
			//  prefixed by "SNIFFED" prefix.
			if (bSet)
			{
				// "bSet" will always set to true, as sniffed presumptive cause will never
				//  be visible.
				AppendRadioButtonVisited(str, nid, state, bSet, m_pTopic->GetStateName(nid, state), false);
				AppendHiddenFieldSniffed(str, nid);
			}
		}
		return;
	}

	AppendRadioButtonVisited(str, nid, state, bSet, m_pTopic->GetStateName(nid, state), bShowHistory);
	return;
}

// This is used to get the name of a node that has already been visited (for the
//	history table).
// INPUT nid -		node ID of desired node
// OUTPUT str - The "full name" of the node is appended to this, something like
//		"Disable IBM AntiVirus" or "Make all paths less than 66 characters"
//		If its value was sniffed, we append the appropriate string to mark it visibly
//		as sniffed (typically, just "SNIFFED").
// INPUT bShowHistory
//		If !bShowHistory, no appending: no need to show full name in a hidden table.
//		Symbolic name will be written in a hidden field.
// Note that our CString, unlike MFC's, won't throw an exception on += out of memory
// RETURNS true if node number exists
bool CInfer::AppendVisitedNodeText(CString & str, NID nid, bool bShowHistory) const
{
	if (!bShowHistory)
		return true;

	CString strTemp = m_pTopic->GetNodeFullName(nid);
	if ( !strTemp.IsEmpty() )
	{
		str += strTemp;
		return true;
	}
	else
		return false;
}

// -------------------------------------------------------------------
// Writing to the new HTML page.  Representing the recommended node.
// This is what is often called the page, although it is really only part of 
//	the body of the HTML page, along with history.
// -------------------------------------------------------------------

// AppendImpossiblePage:  Gets the body of text that is 
// displayed when the network is in an unreliable state.
void CInfer::AppendImpossiblePage(CString & str) 
{
	CString strHeader, strText;

	strHeader = m_pTopic->GetMultilineNetProp(HTK_IMPOSSIBLE_HEADER, _T("<H4> %s </H4>\n"));
	strText	  = m_pTopic->GetMultilineNetProp(HTK_IMPOSSIBLE_TEXT	, _T("%s "));

	if (!strHeader.IsEmpty() && !strText.IsEmpty())
	{
		str = strHeader + strText + _T("<BR>\n<BR>\n");
	}
	else
	{
		strHeader = m_pTopic->GetMultilineNetProp(HX_FAIL_HD_STR	, _T("<H4> %s </H4>\n"));
		strText	  = m_pTopic->GetMultilineNetProp(HX_FAIL_TXT_STR	, _T("%s "));

		if (!strHeader.IsEmpty() && !strText.IsEmpty())
		{
			str = strHeader + strText + _T("<BR>\n<BR>\n");
		}
		else
		{
			str = SZ_I_NO_RESULT_PAGE;
		}
	}

	//  Make a radio button with name = NODE_IMPOSSIBLE & value = SZ_ST_WORKED
	CString strTemp = m_pTopic->GetNetPropItemStr(HX_IMPOSSIBLE_NORM_STR);
	if (strTemp.IsEmpty()) // fall back on Fail node's property
		strTemp = m_pTopic->GetNetPropItemStr(HX_FAIL_NORM_STR);
	if (!strTemp.IsEmpty())
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TABLE>";

		AppendRadioButtonCurrentNode(str, NODE_IMPOSSIBLE, SZ_ST_WORKED, strTemp);

		if (RUNNING_LOCAL_TS())
			str += "</TABLE>\n";
	}

	str += _T("<P>");
	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);
}

// AppendSniffAllCausesNormalPage:  Gets the body of text that is displayed when sniffing 
// on startup detects that all Cause nodes are in their Normal states.
void CInfer::AppendSniffAllCausesNormalPage(CString & str) 
{
	CString strHeader, strText;

	strHeader = m_pTopic->GetMultilineNetProp(HTK_SNIFF_FAIL_HEADER, _T("<H4> %s </H4>\n"));
	strText	  = m_pTopic->GetMultilineNetProp(HTK_SNIFF_FAIL_TEXT	, _T("%s "));

	if (!strHeader.IsEmpty() && !strText.IsEmpty())
	{
		str = strHeader + strText + _T("<BR>\n<BR>\n");
	}
	else
	{
		strHeader = m_pTopic->GetMultilineNetProp(HX_FAIL_HD_STR	, _T("<H4> %s </H4>\n"));
		strText	  = m_pTopic->GetMultilineNetProp(HX_FAIL_TXT_STR	, _T("%s "));

		if (!strHeader.IsEmpty() && !strText.IsEmpty())
		{
			str = strHeader + strText + _T("<BR>\n<BR>\n");
		}
		else
		{
			str = SZ_I_NO_RESULT_PAGE;
		}
	}

	// Make a radio button with name = NODE_FAILALLCAUSESNORMAL & value = SZ_ST_WORKED
	CString strTemp = m_pTopic->GetNetPropItemStr(HX_SNIFF_FAIL_NORM);
	if (strTemp.IsEmpty()) // fall back on Fail node's property
		strTemp = m_pTopic->GetNetPropItemStr(HX_FAIL_NORM_STR);
	if (!strTemp.IsEmpty())
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TABLE>";

		AppendRadioButtonCurrentNode(str, NODE_FAILALLCAUSESNORMAL, SZ_ST_WORKED, strTemp);

		if (RUNNING_LOCAL_TS())
			str += "</TABLE>\n";
	}

	str += _T("<P>");
	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);
}

// OUTPUT str - string to which we are appending to build HTML page we send back.
// Append (to str) a group of radio buttons, one for each "problem" node in the Belief Network
void CInfer::AppendProblemPage(CString & str)
{
	CString strTemp;

	m_nidSelected = nidProblemPage;
	
	// text to precede list of problems.  Introduced 8/98 for version 3.0.
	// space after %s in next line: see note at head of file
	str += m_pTopic->GetMultilineNetProp(H_PROB_PAGE_TXT_STR, _T("%s "));

	// write problem header.  This is text written as HTML <H4>.
	strTemp.Format(_T("<H4> %s </H4>\n\n"), m_pTopic->GetNetPropItemStr(H_PROB_HD_STR));
	str += strTemp;

	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = PROBLEM -->\n");
	//str += "<BR>";
	
	if (RUNNING_LOCAL_TS())
		str += "\n<TABLE>";

	AppendProblemNodes(str);

	if (RUNNING_LOCAL_TS())
		str += "\n</TABLE>\n";
			
	if (m_pTopic->UsesSniffer())
	{
		AppendActionButtons (str, k_BtnNext|k_BtnPPSniffing);
	}
	else
	{
		AppendActionButtons (str, k_BtnNext);
	}

	return;
}

// Helper routine for AppendProblemPage
void CInfer::AppendProblemNodes(CString & str)
{
	vector<NID> arrnidNoSequence;
	multimap<int, NID> mapSeqToNID;

	// for every node in this Belief Network (but taking action only on "problem" nodes)
	// put this nid in arrnidNoSequence if it has no sequence number or mapSeqToNID if it
	// has one.
	for(int nid = 0; nid < m_pTopic->CNode(); nid++)
	{
		if (m_pTopic->IsProblemNode(nid))
		{
			CString strSpecial = m_pTopic->GetNodePropItemStr(nid, H_PROB_SPECIAL);
			// if it's not marked as a "hidden" problem, we'll want it in the problem page
			if (strSpecial.CompareNoCase(_T("hide")) != 0)
			{
				CString str = m_pTopic->GetNodePropItemStr(nid, H_NODE_PROB_SEQUENCE);
				try
				{
					if (str.IsEmpty())
						arrnidNoSequence.push_back(nid);
					else
						mapSeqToNID.insert(pair<int, NID>(_ttoi(str), nid));
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
	}

	for (multimap<int, NID>::const_iterator ppair=mapSeqToNID.begin();
		 ppair != mapSeqToNID.end();
		 ppair++)
	 {
		// Create a radio button with "ProblemAsk" as its name & this problem
		//	as its value
		AppendRadioButtonCurrentNode(
			str, 
			NODE_PROBLEM_ASK, 
			m_pTopic->GetNodeSymName(ppair->second),
			m_pTopic->GetNodePropItemStr(ppair->second, H_PROB_TXT_STR));
	 }


	for (vector<NID>::const_iterator pnid=arrnidNoSequence.begin();
		 pnid != arrnidNoSequence.end();
		 pnid++)
	{
		// Create a radio button with "ProblemAsk" as its name & this problem
		//	as its value
		AppendRadioButtonCurrentNode(
			str, 
			NODE_PROBLEM_ASK, 
			m_pTopic->GetNodeSymName(*pnid),
			m_pTopic->GetNodePropItemStr(*pnid, H_PROB_TXT_STR));
	}
}

// Append this network's "BYE" page to str
// OUTPUT str - string to append to
void CInfer::AppendByeMsg(CString & str)
{
	str += _T("<!-- &quot;BYE&quot; (success) PAGE -->\n");

	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = IDH_BYE -->\n");

	// Write this troubleshooter's "Bye" header and text
	// space after %s in next 2 lines: see note at head of file
	AppendMultilineNetProp(str, HX_BYE_HD_STR, _T("<H4> %s </H4>\n"));
	AppendMultilineNetProp(str, HX_BYE_TXT_STR, _T("%s "));
	str += _T("<P>\n");

	AppendActionButtons (str, k_BtnBack|k_BtnStartOver);

	return;
}

// Append this network's "FAIL" page to str 
// OUTPUT str - string to append to
void CInfer::AppendFailMsg(CString & str)
{
	str += _T("<!-- &quot;FAIL&quot; PAGE -->\n");

	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = IDH_FAIL -->\n");

	// Write this topic's "Fail" header and text
	// space after %s in next 2 lines: see note at head of file
	AppendMultilineNetProp(str, HX_FAIL_HD_STR, _T("<H4> %s </H4>\n"));
	AppendMultilineNetProp(str, HX_FAIL_TXT_STR, _T("%s "));
	str += _T("<BR>\n<BR>\n");
	
	// Make a radio button with name = NODE_FAIL & value = SZ_ST_WORKED
	CString strTemp = m_pTopic->GetNetPropItemStr(HX_FAIL_NORM_STR);
	if (!strTemp.IsEmpty())
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TABLE>";

		AppendRadioButtonCurrentNode(str, NODE_FAIL, SZ_ST_WORKED, strTemp);

		if (RUNNING_LOCAL_TS())
			str += "</TABLE>\n";
	}

	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);

	return;
}

// Append content of the "service" page to str (Offers 2 possibilities: seek help elsewhere 
//	or go back and try something you skipped)
// OUTPUT str - string to append to
void CInfer::AppendServiceMsg(CString & str)
{
	CString strTemp;

	str += _T("<!-- &quot;SERVICE&quot; PAGE -->\n");
	str += _T("<!-- Offers to seek help elsewhere or go back and try something you skipped -->\n");
	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = SERVICE -->\n");

	// Write this troubleshooter's "Service" header and text
	// space after %s in next 2 lines: see note at head of file
	AppendMultilineNetProp(str, HX_SER_HD_STR, _T("<H4> %s </H4>\n"));
	AppendMultilineNetProp(str, HX_SER_TXT_STR, _T("%s "));
	str += _T("<BR>\n<BR>\n");

	if (RUNNING_LOCAL_TS())
		str += "\n<TABLE>";

	// Make a radio button with name = Service & value = SZ_ST_WORKED
	// Typical text is "I will try to get help elsewhere.";
	strTemp = m_pTopic->GetNetPropItemStr(HX_SER_NORM_STR);
	if (!strTemp.IsEmpty())
		AppendRadioButtonCurrentNode(str, NODE_SERVICE, SZ_ST_WORKED, strTemp);

	// Make a radio button with name = Service & value = SZ_ST_ANY
	// Typical text is "Retry any steps that I have skipped."
	strTemp = m_pTopic->GetNetPropItemStr(HX_SER_AB_STR);
	if (!strTemp.IsEmpty())
		AppendRadioButtonCurrentNode(str, NODE_SERVICE, SZ_ST_ANY, strTemp);

	if (RUNNING_LOCAL_TS())
		str += "</TABLE>\n";

	str += _T("<P>");

	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);

	return;
}


// Depending on the value of nid, this fn can build
//	- a BYE page
//	- a FAIL page
//	- a SERVICE page
//	- a page for a normal node (fixable/observable, fixable/unobservable, unfixable, or
//		informational).
// If none of these cases apply, returns with no action taken
// INPUT nid - ID of a node
// OUTPUT str - string to append to
void CInfer::AppendNIDPage(NID nid, CString & str) 
{
	CString strTxt;

	m_nidSelected = nid;

	if (nid == nidByeNode)
		AppendByeMsg(str);
	else if (nid == nidFailNode)
		AppendFailMsg(str);
	else if (nid == nidSniffedAllCausesNormalNode)
		AppendSniffAllCausesNormalPage(str);
	else if (nid == nidService)
		AppendServiceMsg(str);
	else if (m_pTopic->IsValidNID(nid))
	{
		bool bShowManualSniffingButton = false;

		if (m_pSniff)
			if (nid != m_SniffedRecommendation.nid()) 
				// we're NOT showing sniffed node.
				bShowManualSniffingButton = m_pSniff->GetSniffController()->AllowManualSniffing(nid);

		// Write a comment in the HTML in service of automated test program
		str += _T("<!-- IDH = ");
		str += m_pTopic->GetNodeSymName(nid);
		str += _T(" -->\n");

		// Write this node's header & text
		// space after %s in next several lines: see note at head of file
		AppendMultilineNodeProp(str, nid, H_NODE_HD_STR, _T("<H4> %s </H4>\n"));
		if (bShowManualSniffingButton)
			AppendMultilineNodeProp(str, nid, H_NODE_MANUAL_SNIFF_TEXT, _T("%s "));
		if (m_SniffedRecommendation.nid() == nid)
		{
			CString tmp;
			AppendMultilineNodeProp(tmp, nid,  H_NODE_DCT_STR, _T("%s "));
			if (tmp.IsEmpty())
				AppendMultilineNodeProp(str, nid,  H_NODE_TXT_STR, _T("%s "));
			else
				str += tmp;
		}
		else
		{
			AppendMultilineNodeProp(str, nid,  H_NODE_TXT_STR, _T("%s "));
		}
		str += _T("\n<BR>\n<BR>\n");

		// Write appropriate radio buttons depending on what kind of node it is.
		if (m_pTopic->IsCauseNode(nid) || m_pTopic->IsInformationalNode(nid))
			AppendCurrentRadioButtons(nid, str);

		AppendActionButtons (
			str, 
			k_BtnNext|k_BtnBack|k_BtnStartOver|(bShowManualSniffingButton ? k_BtnManualSniffing : 0),
			nid);
	}
	// else nothing we can do with this

	return;
}


// -------------------------------------------------------------------
// BES
// -------------------------------------------------------------------

// Historically:
// Returns true if we are supposed to show the full BES page (& let the user edit the 
//	search string) vs. extracting the search string & starting the search without
//	any possible user intervention
// However, we no longer offer that option as of 981021.
bool CInfer::ShowFullBES()
{
	return false;
}

// returns true in the circumstances where we wish to show a Back End Search 
bool CInfer::TimeForBES()
{
	return (m_pTopic->HasBES() && m_bUseBackEndRedirection);
}
 
// If it is time to do a Back End Search redirection, append the "redirection" string 
//	to str and return true
// Otherwise, return false
// str should represent the header of an HTML page.
// For browsers which support redirection, this is how we overide service node (or fail node) 
//	when BES is present
bool CInfer::AppendBESRedirection(CString & str)
{
	if (m_pTopic->HasBES() && TimeForBES() && !ShowFullBES() && !m_strEncodedForm.IsEmpty()) 
	{
		str += _T("Location: ");
		str += m_strEncodedForm;
		str += _T("\r\n");
		return( true );				
	}

	return false;
}

// Append HTML representing BES to OUTPUT str and build m_strEncodedForm, 
// This is a distinct new algorithm in Ver 3.0, replacing the old "word list" approach.
void CInfer::OutputBackend(CString & str)
{
	vector<CString>arrstrSearch;

	int nNodesInBasis = m_BasisForInference.size();

	for (int i = 0; i<nNodesInBasis; i++)
	{
		NID nid = m_BasisForInference[i].nid();
		IST state = m_BasisForInference[i].state();

		CString strSearchState;

		// First account for binary nodes w/ special property names
		if (state == 0) 
			strSearchState = m_pTopic->GetNodePropItemStr(nid, H_NODE_NORM_SRCH_STR);
		else if (state == 1) 
			strSearchState = m_pTopic->GetNodePropItemStr(nid, H_NODE_AB_SRCH_STR);
		else 
			strSearchState = _T("");

		if (strSearchState.IsEmpty())
			// multistate node
			strSearchState = m_pTopic->GetNodePropItemStr(nid, MUL_ST_SRCH_STR, state);

		if (! strSearchState.IsEmpty())
		{
			try
			{
				arrstrSearch.push_back(strSearchState);
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str),
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}
	}

	// Build the full BES page
	CString strRaw;

	m_pTopic->GenerateBES(arrstrSearch,	m_strEncodedForm, strRaw);
	str += strRaw;
}


// -------------------------------------------------------------
// Logging
// -------------------------------------------------------------

  
// Return NID of page ultimately selected.  If no such page, returns nidNil.
NID CInfer::NIDSelected() const
{
	return m_nidSelected;
}

// -------------------------------------------------------------
// Effectively, a method on m_arrnidSkipped
// -------------------------------------------------------------
// INPUT nid
// RETURNS true if nid is node in the "skip list" (ST_UNKNOWN, "Try something else").
bool CInfer::IsSkipped(NID nid) const
{
	vector<NID>::const_iterator itBegin= m_arrnidSkipped.begin();
	vector<NID>::const_iterator itEnd= m_arrnidSkipped.end();

	return (find(itBegin, itEnd, nid) != itEnd);
}

// -------------------------------------------------------------
// Buttons
// -------------------------------------------------------------
// appends only <INPUT TYPE=...> clause
void CInfer::AppendNextButton(CString & str) const
{
	str += SZ_INPUT_TAG_NEXT;  // _T("<INPUT tag=next TYPE=SUBMIT VALUE=\"")
	AppendNextButtonText(str);
	str += _T("\">");
}

// For local TS, appends only <INPUT TYPE=...> clause
// For Online TS, must build a pseudo button.
void CInfer::AppendStartOverButton(CString & str) const
{
	if (RUNNING_LOCAL_TS())
	{
		str += SZ_INPUT_TAG_STARTOVER;  // _T("<INPUT tag=startover TYPE=BUTTON VALUE=\"")
		AppendStartOverButtonText(str);
		str += _T("\" onClick=\"starter()\">");
	}
	else
	{
		// Added for V3.2
		CString strLabel;		// visible label for pseudo button

		AppendStartOverButtonText(strLabel);
		
		AppendLinkAsButton(str, m_strStartOverLink, strLabel);
	}
}

// appends only <INPUT TYPE=...> clause
void CInfer::AppendBackButton(CString & str) const
{
	if (RUNNING_LOCAL_TS())
	{
		str += SZ_INPUT_TAG_BACK;  // _T("<INPUT tag=back TYPE=BUTTON VALUE=\"")
		AppendBackButtonText(str);
		str += _T("\" onClick=\"generated_previous()\">");
	}
}

// AppendManualSniffButton will generate script something like this, but this 
//	comment is not being carefully maintained, so see actual code for details.
/////////////////////////////////////////////////////////////////////////////
//	function sniffManually() {											   //
//		var stateSniffed = parent.t3.PerformSniffingJS("NodeName", "", "");//
//																		   //
//		if(stateSniffed == -1) {										   //
//			stateSniffed = parent.t3.PerformSniffingVB("NodeName", "", "");//
//		}																   //
//																		   //
//		if(stateSniffed == -1) {										   //
//			alert("Could not sniff this node");							   //
//		} else {														   //
//			if(stateSniffed > NumOfStates) {							   //
//				alert("Could not sniff this node");						   //
//			} else {													   //
//				///////////////////////////////////////////////////////	   //
//				IF IS CAUSE NODE:										   //
//				if (stateSniffed == 1)									   //
//					document.all.Sniffed_NodeName.value = 101;			   //
//				else													   //
//					document.all.Sniffed_NodeName.value = stateSniffed;	   //
//				///////////////////////////////////////////////////////	   //
//				IF IS NOT CAUSE NODE:								       //
//				document.all.Sniffed_NodeName.value = stateSniffed;		   //
//				///////////////////////////////////////////////////////	   //
//				document.all.NodeState[stateSniffed].checked = true;	   //
//				document.ButtonForm.onsubmit();							   //
//			}															   //
//		}																   //
//	}																	   //
/////////////////////////////////////////////////////////////////////////////
void CInfer::AppendManualSniffButton(CString & str, NID nid) const
{
	if (RUNNING_LOCAL_TS())
	{
		CString strNodeName;
		CString strTmp;
		SymbolicFromNID(strNodeName, nid);
		bool bIsCause = m_pTopic->IsCauseNode(nid);
		
		str += _T(
			"\n\n<script language=\"JavaScript\">\n"
			"function sniffManually() {\n"
			"    var stateSniffed = parent.t3.PerformSniffingJavaScript(\"");
		str += strNodeName;
		str += _T(
			"\", \"\", \"\");\n");

		str += _T(
			"	 if(stateSniffed == -1) {\n"
			"		 stateSniffed = parent.t3.PerformSniffingVBScript(\"");
		str += strNodeName;
		str += _T(
			"\", \"\", \"\");\n"
		    "}\n");

		str += _T(	
			"    if(stateSniffed == -1) {\n"
			"        alert(\"");
		AppendSniffFailedText(str);
		str += _T(
			"\");\n"
			"    } else {\n"
			"        if(stateSniffed >"); 

		CString strStates;
		strStates.Format(_T("%d"), m_pTopic->GetCountOfStates(nid) -1);
		str += strStates;

		str += _T(
			") {\n"
			"            alert(\"");
		AppendSniffFailedText(str);
		str += _T(
			"\");\n"
			"        } else {\n");
		if (bIsCause)
		{
			str += _T(
				"            if (stateSniffed == 1)\n"
				"			     document.all.");
			str += C_SNIFFTAG;	
			str += strNodeName;
			str += _T(".value = ");
			str += SZ_ST_WORKED;
			str += _T(";\n");
			str += _T(
				"            else\n");
		}
		str += _T(
			"            document.all.");
		str += C_SNIFFTAG;	
		str += strNodeName;
		str += _T(".value = stateSniffed;\n");

		str += _T(
			"            document.all.");
		str += C_LAST_SNIFFED_MANUALLY;	
		str += _T(".value = "); 
		str += SZ_ST_SNIFFED_MANUALLY_TRUE;
		str += _T(";\n");


		str += _T(
			"            document.all.");
		str += strNodeName;
		str += _T(	
			"[stateSniffed].checked = true;\n");

		str += _T(
			"            document.ButtonForm.onsubmit();\n");

		str += _T(
			"        }\n"
			"    }\n"
			"}\n"
			"</script>\n\n");
		
		str += _T(
			"<INPUT tag=sniff TYPE=BUTTON VALUE=\"");
		AppendManualSniffButtonText(str);
		str += _T(
			"\" onClick=\"sniffManually()\">\n");

		str += _T(
			"<INPUT type=\"HIDDEN\" name=\"");
		str += C_SNIFFTAG;
		str += strNodeName;
		str += _T("\" value=\"");
		strTmp.Format(_T("%d"), SNIFF_FAILURE_RESULT);
		str += strTmp;
		str += _T("\">\n");

		str += _T(
			"<INPUT type=\"HIDDEN\" name=\"");
		str += C_LAST_SNIFFED_MANUALLY;
		str += _T("\" value=\"");
		str += SZ_ST_SNIFFED_MANUALLY_FALSE;
		str += _T("\">\n");
	}
}

// appends only <INPUT TYPE=...> clause
void CInfer::AppendPPSnifferButton(CString & str) const
{
	str += SZ_INPUT_TAG_SNIFFER;  // _T("<INPUT tag=sniffer TYPE=BUTTON VALUE=\"")
	AppendPPSnifferButtonText(str);
	str += _T("\" onClick=\"runtest()\">");
}


void CInfer::AppendActionButtons(CString & str, ActionButtonSet btns, NID nid /*=-1*/) const
{
	// Online TS's Start Over "button" is actually a link, and will implicitly
	//	start a new line unless we do something about it.
	bool bGenerateTable = (!RUNNING_LOCAL_TS() && (btns & k_BtnStartOver));

	if (bGenerateTable)
		str += _T("<TABLE><tr><td>");

	if (btns & k_BtnNext)
	{
		AppendNextButton(str);
		str += _T("\n");
	}

	if (btns & k_BtnBack)
	{
		AppendBackButton(str);
		str += _T("\n");
	}

	if (bGenerateTable)
		str += _T("</td><td>");


	if (btns & k_BtnStartOver)
	{
		AppendStartOverButton(str);
		str += _T("\n");
	}

	if (bGenerateTable)
		str += _T("</td><td>");

	if (btns & k_BtnPPSniffing)
	{
		AppendPPSnifferButton(str);
		str += _T("\n");
	}

	if ((btns & k_BtnManualSniffing) && nid != -1)
	{
		AppendManualSniffButton(str, nid);
		str += _T("\n");
	}

	if (bGenerateTable)
		str += _T("</td></tr></TABLE>");

	str += _T("<BR><BR>");
}

// -------------------------------------------------------------
// MISCELLANY
// -------------------------------------------------------------

// RETURN true for cause (vs. informational or problem) node.
// Note that a cause may be either a fixable node or an "unfixable" node which 
//	"can be fixed with infinite effort"
/* static */ bool CInfer::IsCause (ESTDLBL lbl)
{
	return (lbl == ESTDLBL_fixobs || lbl == ESTDLBL_fixunobs || lbl == ESTDLBL_unfix);
}	


// This code can take a previously skipped node and bring it back again as a recommendation.  
// It is relevant only if the user received the service node in the previous call 
//	to the DLL and now wants to see if there is "Anything Else I Can Try".
//
// This code will remove the first node from the skip list so that it may be delivered to 
// the user again.
// 
// Of course, m_arrnidSkipped, m_arrnidVisited must be filled in before this is called.
//
void CInfer::RecycleSkippedNode()
{
	// Only should take effect once per instance of this object, because peels the first
	//	entry off of m_arrnidSkipped.  We guarantee that with the following:
	if (m_bRecyclingInitialized)
		return;

	m_bRecyclingInitialized = true;

	// Only relevant if the query asks for a previously skipped node brought back again 
	//	as a recommendation.  
	if (!m_bRecycleSkippedNode)
		return;

	// This is a safety check to bail out if there are no skipped nodes.
	// This would be a bogus query, because the Service Node should only have been
	//	offered if there were skipped recommendations to try.
	if (m_arrnidSkipped.empty())
	{
		m_bRecycleSkippedNode = false;
		return;
	}

	// OK,now down to business.

	// Get a value for m_nidRecycled from the first item skipped
	m_nidRecycled = m_arrnidSkipped.front();

	// Remove skipped item from skip table
	m_arrnidSkipped.erase(m_arrnidSkipped.begin());

	// Fix table of nodes that will be placed into the output table
	// to not include the first node skipped

	vector<NID>::const_iterator itnidBegin = m_arrnidVisited.begin();
	vector<NID>::const_iterator itnidEnd = m_arrnidVisited.end();
	vector<NID>::const_iterator itnidAnythingElse = find(itnidBegin, itnidEnd, m_nidRecycled);

	if (itnidAnythingElse != itnidEnd)
		m_arrnidVisited.erase( const_cast<vector<NID>::iterator>(itnidAnythingElse) ); 
}

bool CInfer::ManuallySniffedNodeExists() const
{
	// If last element in m_BasisForInference is sniffed,
	//  it means, that this element was set by manual sniffing
	//  function.
	if (m_BasisForInference.size() && m_SniffedStates.size())
		return m_bLastSniffedManually;
	return false;
}

bool CInfer::IsManuallySniffedNode(NID nid) const
{
	if (ManuallySniffedNodeExists())
		return nid == m_SniffedStates[m_SniffedStates.size()-1].nid();
	return false;
}

void CInfer::SetLastSniffedManually(bool set)
{
	m_bLastSniffedManually = set;
}

// -------------------------------------------------------------------
// CInfer::CArrayOrderRestorer implementation
// -------------------------------------------------------------------
//
// CInfer::CArrayOrderRestorer exists so that after re-sniffing, we can restore an array
//	of visited nodes to its original order, as saved in m_arrInitial.
//
// INPUT: nBaseLength = number of elements in fixed locations at head of array, which will 
//		never be moved (typically nodes explicitly set by user rather than sniffed).
// INPUT/OUTPUT: arrToRestore = array to restore: input dictates content of output, but 
//		(beyond nBaseLength) does not dictate the order. Order comes from m_arrInitial.
// OUTPUT: arrToRestore = array with restored order
// RETURN: true if successful
bool CInfer::CArrayOrderRestorer::Restore(long nBaseLength, vector<NID>& arrToRestore)
{
	if (nBaseLength > arrToRestore.size())
		return false;

	long i;
	vector<NID>::iterator i_base;
	vector<NID>::iterator i_additional;
	vector<NID> arrBase;
	vector<NID> arrAdditional;

	try
	{
		for (i = 0; i < nBaseLength; i++)
			arrBase.push_back(arrToRestore[i]);

		for (i = nBaseLength; i < arrToRestore.size(); i++)
			arrAdditional.push_back(arrToRestore[i]);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	arrToRestore.clear();

	for (i = 0, i_base = arrBase.begin();
	     i < m_arrInitial.size(); 
		 i++)
	{
		if (arrBase.end() != find(arrBase.begin(), arrBase.end(), m_arrInitial[i]))
		{
			if (i_base != arrBase.end())
				i_base++;
		}
		else if (arrAdditional.end() != (i_additional = find(arrAdditional.begin(), arrAdditional.end(), m_arrInitial[i])))
		{
			i_base = arrBase.insert(i_base, m_arrInitial[i]);
			i_base++;
			arrAdditional.erase(i_additional);
		}
	}

	arrToRestore = arrBase;

	try
	{
		for (i = 0; i < arrAdditional.size(); i++)
			arrToRestore.push_back(arrAdditional[i]);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
	
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtslog.h ===
//
// MODULE: APGTSLOG.H
//
// PURPOSE: User Activity Logging Utility
//	Fully implements class CHTMLLog
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/21/98		JM		Pulled into separate file
//

#ifndef _H_APGTSLOG
#define _H_APGTSLOG

#include "apgtsstr.h"


#define LOGFILEPREFACE			_T("gt")
#define MAXLOGSBEFOREFLUSH		5
#define MAXLOGSIZE				1000

class CPoolQueue;
//
//
class CHTMLLog 
{
public:
    static void SetUseLog(bool bUseLog);

public:
	CHTMLLog(const TCHAR *);
	~CHTMLLog();
	
	DWORD NewLog(LPCTSTR data);
	DWORD GetStatus();

	// Access function to enable the registry monitor to change the logging file directory.
	void SetLogDirectory( const CString &strNewLogDir );	

	// testing only
	DWORD WriteTestLog(LPCTSTR szAPIName, DWORD dwThreadID);

protected:
	DWORD FlushLogs();
	void Lock();
	void Unlock();

protected:
	static bool s_bUseHTMLLog;

protected:
	CRITICAL_SECTION m_csLogLock;			// must lock to write to log file

	CString *m_buffer[MAXLOGSBEFOREFLUSH];	// Array of separate strings to log, held here
											//  till we flush
											// Note this is our CString, not MFC - 10/97
	UINT m_bufindex;						// index into m_buffer, next slot to write to.
											// incremented after writing; when it reaches
											// MAXLOGSBEFOREFLUSH, we flush
	DWORD m_dwErr;							// Latest error. NOTE: once this is set nonzero, it 
											// can never be cleared & logging is effectively
											// disabled.
	CString m_strDirPath;			// directory in which we write log files.
};

#endif // _H_APGTSLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtslstread.cpp ===
// MODULE: APGTSLSTREAD.CPP
//
// PURPOSE: APGTS LST file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//	1. Prior to 11/13/98, it wasis assumed that for a given DSC/TSM file, any other associated 
//		filenames (BES, HTI) would not change over time.  This assumption is no longer good.
//		It had the unfortunate consequence that if there was a typographical error in an LST
//		file there was no way to fix it while the system was running.
//	2. While the Online Troubleshooter is running, it is possible to change the LST file in
//		order to add new troubleshooter topics, but it is not possible to remove troubleshooter
//		topics.  Thus, even if a topic which was listed in the old LST file is missing from the
//		new one, that is not a relevant difference.
//	3. Normal form of a line in this file: any of the following:
//		MODEM.DSC MODEM.HTI
//		MODEM.DSC MODEM.HTI MODEM.BES 
//		MODEM.DSC,MODEM.HTI,MODEM.BES 
//		MODEM.TSM,MODEM.HTI,MODEM.BES 
//	   Commas and spaces are both valid separators.  
//	   Order within a line is irrelevant, although for readability, it is best to put 
//		the DSC/TSM file first.  
//	   Extensions are mandatory.  The only way we know it's (say) a template file is 
//		the .HTI extension.
//	   DSC/TSM file is mandatory.  The others are optional, although if the HTI file is missing,
//		there had better be a HNetHTIOnline / HNetHTILocal property in this network.
//	4. If the same DSC/TSM file is listed more than once, the last appearance dominates the
//		earlier appearances.
//	5. For multilingual, each language goes in a subdirectory under the resource directory.
//		LST file needs to contain paths relative to	the resource directory, such as:
//		ES\MODEM.DSC ES\MODEM.HTI
//		DE\MODEM.DSC DE\MODEM.HTI
//		FR\MODEM.DSC FR\MODEM.HTI
//  
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0.1	12-21-98	JM		Multilingual
//

#include "stdafx.h"
#include "apgtslstread.h"
#include "sync.h"
#include <algorithm>
#include "event.h"
#include "CharConv.h"
#include "apgtsmfc.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

////////////////////////////////////////////////////////////////////////////////////
// static function(s)
////////////////////////////////////////////////////////////////////////////////////
CString FormFullPath(const CString& just_path, const CString& just_name)
{
#ifdef LOCAL_TROUBLESHOOTER
	if (CCHMFileReader::IsPathToCHMfile(just_path))
		return CCHMFileReader::FormCHMPath(just_path) + just_name;
	else
		return just_path + _T("\\") + just_name;
#else
	return just_path + _T("\\") + just_name;
#endif
}

////////////////////////////////////////////////////////////////////////////////////
// CTopicInfo
////////////////////////////////////////////////////////////////////////////////////
bool CTopicInfo::Init(CString & strResourcePath, vector<CString> &vecstrWords)
{
	bool bSomethingThere = false;

	for (vector<CString>::iterator i = vecstrWords.begin(); i != vecstrWords.end(); i++)
	{
		CString str_extension = CString(".") + CAbstractFileReader::GetJustExtension(*i);

		bSomethingThere = true;
		///////////////////////////////////////////
		// We require that all *.dsc etc		 //
		// files are in the same directory		 //
		// as lst file	(the resource directory) //
		// or (for multilingual) a subdirectory  //
		// of the resource directory.            // 
		///////////////////////////////////////////
		LPCTSTR extention = NULL;
		if (0 == _tcsicmp(str_extension, extention = APGTSLSTREAD_DSC) ||
			0 == _tcsicmp(str_extension, extention = APGTSLSTREAD_TSM)
		   ) 
		{
			m_DscFilePath = ::FormFullPath(strResourcePath, *i);
			m_DscFilePath.MakeLower();
			if (! m_NetworkName.GetLength()) 
			{
				// use name of DSC/TSM file, minus extension.
				m_NetworkName = *i;
				int len = m_NetworkName.GetLength()-(_tcslen(extention));
				m_NetworkName = m_NetworkName.Left(len);
				m_NetworkName.MakeLower();
			}
			continue;
		}
		if (0 == _tcsicmp(str_extension, APGTSLSTREAD_HTI)) 
		{
			m_HtiFilePath = ::FormFullPath(strResourcePath, *i);
			m_HtiFilePath.MakeLower();
			continue;
		}
		if (0 == _tcsicmp(str_extension, APGTSLSTREAD_BES)) 
		{
			m_BesFilePath = ::FormFullPath(strResourcePath, *i);
			m_BesFilePath.MakeLower();
			continue;
		}
#ifdef LOCAL_TROUBLESHOOTER
		if (0 == _tcsicmp(str_extension, APGTSLSTREAD_TSC)) 
		{
			m_TscFilePath = ::FormFullPath(strResourcePath, *i);
			m_TscFilePath.MakeLower();
			continue;
		}
#endif
		/////////////////////////////////////

		// Ignore anything unrecognized.
	}

	bool bRet = bSomethingThere && ! m_DscFilePath.IsEmpty();

	if (bRet)
	{
		CAbstractFileReader::GetFileTime(m_DscFilePath, CFileReader::eFileTimeCreated, m_DscFileCreated);
		
		if ( ! m_HtiFilePath.IsEmpty()) 
			CAbstractFileReader::GetFileTime(m_HtiFilePath, CFileReader::eFileTimeCreated, m_HtiFileCreated);

		if ( ! m_BesFilePath.IsEmpty()) 
			CAbstractFileReader::GetFileTime(m_BesFilePath, CFileReader::eFileTimeCreated, m_BesFileCreated);
	}

	return bRet;
}

								
////////////////////////////////////////////////////////////////////////////////////
// CAPGTSLSTReader
////////////////////////////////////////////////////////////////////////////////////
CAPGTSLSTReader::CAPGTSLSTReader(CPhysicalFileReader * pPhysicalFileReader)
			   : CINIReader(pPhysicalFileReader, _T("APGTS"))
{
}

CAPGTSLSTReader::~CAPGTSLSTReader()
{
}

long CAPGTSLSTReader::GetInfoCount()
{
	long ret = 0;
	LOCKOBJECT();
	ret = m_arrTopicInfo.size();
	UNLOCKOBJECT();
	return ret;
}

bool CAPGTSLSTReader::GetInfo(long index, CTopicInfo& out)
{
	LOCKOBJECT();
	if (index < m_arrTopicInfo.size()) 
	{
		out = m_arrTopicInfo[index];
		UNLOCKOBJECT();
		return true;
	}
	UNLOCKOBJECT();
	return false;
}

bool CAPGTSLSTReader::GetInfo(const CString& network_name, CTopicInfo& out)
{
	LOCKOBJECT();
	for (
		vector<CTopicInfo>::iterator i = m_arrTopicInfo.begin();
		i != m_arrTopicInfo.end(); 
		i++)
	{
		if (i->GetNetworkName() == network_name)
		{
			out = *i;
			UNLOCKOBJECT();
			return true;
		}
	}
	UNLOCKOBJECT();
	return false;
}

void CAPGTSLSTReader::GetInfo(CTopicInfoVector & arrOut)
{
	LOCKOBJECT();
	arrOut = m_arrTopicInfo;
	UNLOCKOBJECT();
}


// This will identify new troubleshooting networks, or changes to (say) the associated
//	HTI file, given the same DSC file.  Note that we can only detect additions of topics, 
//	not deletions. (see notes at head of this source file).
// If pOld is NULL, this is equivalent to GetInfo(what_is_new).
void CAPGTSLSTReader::GetDifference(const CAPGTSLSTReader * pOld, CTopicInfoVector & what_is_new)
{
	if (pOld)
	{
		CMultiMutexObj multiMutex;
		multiMutex.AddHandle(GetMutexHandle());
		multiMutex.AddHandle(pOld->GetMutexHandle());

		multiMutex.Lock(__FILE__, __LINE__);
		vector<CTopicInfo> old_arr = pOld->m_arrTopicInfo; // to avoid const
		for (vector<CTopicInfo>::iterator i = m_arrTopicInfo.begin(); i != m_arrTopicInfo.end(); i++)
		{
			vector<CTopicInfo>::const_iterator res = find(old_arr.begin(), old_arr.end(), *i);
			if (res == old_arr.end())
			{
				try
				{
					what_is_new.push_back( *i );
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
		multiMutex.Unlock();
	}
	else 
		GetInfo(what_is_new);
}

void CAPGTSLSTReader::Parse()
{
	CINIReader::Parse();

	// parse all INI strings into something more meaningful...
	m_arrTopicInfo.clear();
	for (vector<CString>::iterator i = m_arrLines.begin(); i != m_arrLines.end(); i++)
	{
		CTopicInfo& info = *GenerateTopicInfo();
		if (ParseString(*i, info))
		{
			// if CTopicInfo with the same Network Name is found 
			//  we assign new object to what is already in the container
			vector<CTopicInfo>::iterator res;
			for (
				res = m_arrTopicInfo.begin();
				res != m_arrTopicInfo.end(); 
				res++)
			{
				if (res->GetNetworkName() == info.GetNetworkName())
					break;
			}

			if (res != m_arrTopicInfo.end())
				*res = info;
			else
			{
				try
				{
					m_arrTopicInfo.push_back(info);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
		delete &info;
	}
}

bool CAPGTSLSTReader::ParseString(const CString& source, CTopicInfo& out)
{
	bool ret = false;
	vector<CString> words; 
	vector<TCHAR> separators;

	try
	{
		separators.push_back(_T(' '));
		separators.push_back(_T(',')); // remove possible trailing commas
		GetWords(source, words, separators);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	return out.Init(GetJustPath(), words);
}

CTopicInfo* CAPGTSLSTReader::GenerateTopicInfo()
{
	return new CTopicInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtslstread.h ===
//
// MODULE: APGTSLSTREAD.H
//
// PURPOSE: APGTS LST file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __APGTSLSTREAD_H_
#define __APGTSLSTREAD_H_

#define APGTSLSTREAD_DSC   _T(".dsc")
#define APGTSLSTREAD_HTI   _T(".hti")
#define APGTSLSTREAD_BES   _T(".bes")  
#define APGTSLSTREAD_TSM   _T(".tsm") 
#ifdef LOCAL_TROUBLESHOOTER
#define APGTSLSTREAD_TSC   _T(".tsc")
#endif

#include "iniread.h"
#include "SafeTime.h"

////////////////////////////////////////////////////////////////////////////////////
// static function(s)
////////////////////////////////////////////////////////////////////////////////////
CString FormFullPath(const CString& just_path, const CString& just_name);

////////////////////////////////////////////////////////////////////////////////////
// CTopicInfo
////////////////////////////////////////////////////////////////////////////////////
class CTopicInfo
{ // each CTopicInfo contains data about one topic (belief network & associated files).
protected:
	CString m_NetworkName;	// symbolic name of network
	CString m_DscFilePath;	// full path of DSC file
	CString m_HtiFilePath;	// full path of HTI file
	CString m_BesFilePath;	// full path of BES file
	CString m_TscFilePath;	// full path of TSC file

	time_t 	m_DscFileCreated;
	time_t 	m_HtiFileCreated;
	time_t 	m_BesFileCreated;

public:
	CTopicInfo() : m_DscFileCreated(0), m_HtiFileCreated(0), m_BesFileCreated(0) {}

public:
	virtual bool Init(CString & strResourcePath, vector<CString> & vecstrWords);

public:
	// The following 4 functions are guaranteed to return lower case strings.
	const CString & GetNetworkName() const {return m_NetworkName;} 
	const CString & GetDscFilePath() const {return m_DscFilePath;}
	const CString & GetHtiFilePath() const {return m_HtiFilePath;}
	const CString & GetBesFilePath() const {return m_BesFilePath;}
	const CString & GetTscFilePath() const {return m_TscFilePath;}

	CString GetStrDscFileCreated() 
		{return CSafeTime(m_DscFileCreated).StrLocalTime();}
	CString GetStrHtiFileCreated() 
		{return CSafeTime(m_HtiFileCreated).StrLocalTime();}
	CString GetStrBesFileCreated() 
		{return CSafeTime(m_BesFileCreated).StrLocalTime();}

	inline BOOL __stdcall operator ==(const CTopicInfo& t2) const
	{
		return m_NetworkName == t2.m_NetworkName
			&& m_DscFilePath == t2.m_DscFilePath
			&& m_HtiFilePath == t2.m_HtiFilePath
			&& m_BesFilePath == t2.m_BesFilePath
			&& m_TscFilePath == t2.m_TscFilePath
			;
	}

	// this function exists solely to keep STL happy.
	inline BOOL __stdcall operator < (const CTopicInfo& t2) const
	{
		return m_NetworkName < t2.m_NetworkName;
	}
};

typedef vector<CTopicInfo> CTopicInfoVector;

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSLSTReader
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSLSTReader : public CINIReader
{
protected:
	CTopicInfoVector m_arrTopicInfo; // Symbolic name & file name for each topic

public:
	CAPGTSLSTReader(CPhysicalFileReader * pPhysicalFileReader);
   ~CAPGTSLSTReader();

public:
	////////////////////////////////////////////////////////
	// If multiple threads may access this object, 
	//	these functions should be wrapped by    
	//  LOCKOBJECT() - UNLOCKOBJECT()  
	//  to secure consistency of container	   
	//  if used in conjunction			
	long GetInfoCount();
	bool GetInfo(long index, CTopicInfo& out);
	bool GetInfo(const CString & network_name, CTopicInfo & out);
	////////////////////////////////////////////////////////

	void GetInfo(CTopicInfoVector& arrOut);

public:
	void GetDifference(const CAPGTSLSTReader * pOld, CTopicInfoVector & what_is_new);

protected:
	virtual void Parse();
	virtual bool ParseString(const CString& source, CTopicInfo& out);
	virtual CTopicInfo* GenerateTopicInfo();
};

#endif __APGTSLSTREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtslog.cpp ===
//
// MODULE: APGTSLOG.CPP
//
// PURPOSE: User Activity Logging Utility
//	Fully implements class CHTMLLog
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
//


#include "stdafx.h"
#include "apgtslog.h"
#include "event.h"
#include "apgts.h"
#include "baseexception.h"
#include "CharConv.h"
#include <vector>

using namespace std;

bool CHTMLLog::s_bUseHTMLLog = false;// Online Troubleshooter, will promptly set this 
									 //	true in DLLMain.  For Local Troubleshooter,
									 //	we leave this false.

/*static*/ void CHTMLLog::SetUseLog(bool bUseLog)
{
	s_bUseHTMLLog = bUseLog;
}

// INPUT dirpath: directory where we write log files
// If can't allocate memory, sets some m_buffer[i] values to NULL, sets m_dwErr 
//	EV_GTS_ERROR_LOG_FILE_MEM, but still returns normally.  Consequently, there's really 
//	no way for the caller to spot a problem, except by calling CHTMLLog::GetStatus after
//	_every_ call to this function.
CHTMLLog::CHTMLLog(const TCHAR *dirpath) :
	m_bufindex(0),
	m_dwErr(0),
	m_strDirPath(dirpath)
{
	::InitializeCriticalSection( &m_csLogLock );
	
	for (UINT i=0;i<MAXLOGSBEFOREFLUSH;i++)
	{
		try
		{
			m_buffer[i] = new CString();
		}
		catch (bad_alloc&)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
			m_dwErr = EV_GTS_ERROR_LOG_FILE_MEM;
			// note that once this error is set we cannot log at all, not even using
			//  the previous positions in m_buffer
			break;
		}
	}
}

//
//
CHTMLLog::~CHTMLLog()
{
	FlushLogs();

	for (UINT i=0;i<MAXLOGSBEFOREFLUSH;i++) 
		if (m_buffer[i] != NULL)
			delete m_buffer[i];

	::DeleteCriticalSection( &m_csLogLock );
}

//
//
DWORD CHTMLLog::GetStatus()
{
	return m_dwErr;
}

//
// Write *data to log buffer, flush if max'd
DWORD CHTMLLog::NewLog(LPCTSTR data)
{
	DWORD dwErr = 0;

	if (m_dwErr)
		return m_dwErr;

    Lock();

	// copy data
	*m_buffer[m_bufindex] += data;
	m_bufindex++;
	if (m_bufindex == MAXLOGSBEFOREFLUSH) {

		// flush logs
		dwErr = FlushLogs();
		m_bufindex = 0;
	}
	Unlock();
	return dwErr;
}

// Flush to a log file.  Name of log file is based on date/time of write.
// RETURNS a (possibly preexisting) error status
// NOTE: does not reset m_bufindex.  Caller must do that.
DWORD CHTMLLog::FlushLogs()
{
	if (!s_bUseHTMLLog)
		return (0);
	
	if (m_dwErr)
		return m_dwErr;

	if (m_bufindex) {
		UINT i;
		FILE *fp;
		TCHAR filepath[300];
		SYSTEMTIME SysTime;

		// get time (used to be System Time, use local)
		GetLocalTime(&SysTime);

		_stprintf(filepath,_T("%s%s%02d%02d%02d.log"),
							(LPCTSTR)m_strDirPath,
							LOGFILEPREFACE,
							SysTime.wYear % 100,
							SysTime.wMonth,
							SysTime.wDay);

		fp = _tfopen(filepath,_T("a+"));
		if (fp) {
			for (i=0;i<m_bufindex;i++) 
			{
				// Don't totally understand why the following needs a GetBuffer (after all,
				//	it just reads the CString) but Bug#1204 arose when we tried 
				//	(const void*)(LPCTSTR)m_buffer[i] instead of m_buffer[i]->GetBuffer(0).
				//	Leave it this way: can't be bad.  JM/RAB 3/2/99
				fwrite( m_buffer[i]->GetBuffer(0), m_buffer[i]->GetLength(), 1, fp );
				m_buffer[i]->ReleaseBuffer();
				m_buffer[i]->Empty();
			}
			fclose(fp);
		}
		else
			return EV_GTS_ERROR_LOG_FILE_OPEN;
	}
	return (0);
}

//
// Access function to enable the registry monitor to change the logging file directory.
//
void CHTMLLog::SetLogDirectory( const CString &strNewLogDir )
{
    Lock();
	m_strDirPath= strNewLogDir;
	Unlock();
	return;
}

//
// for testing only
//
// initially place 0 into dwThreadID
//
DWORD CHTMLLog::WriteTestLog(LPCTSTR szAPIName, DWORD dwThreadID)
{
	TCHAR filepath[MAX_PATH];
	SYSTEMTIME SysTime;
	DWORD dwRetThreadID = GetCurrentThreadId();

	GetLocalTime(&SysTime);

	_stprintf(filepath,_T("%sAX%02d%02d%02d.log"),
							m_strDirPath,
							SysTime.wYear % 100,
							SysTime.wMonth,
							SysTime.wDay);


	Lock();

	FILE *fp = _tfopen(filepath, _T("a"));
	if (fp) 
	{
		if (!dwThreadID)
			fprintf(fp, "(Start %s,%d)", szAPIName, dwRetThreadID);
		else
		{
			if (dwThreadID == dwRetThreadID)
				fprintf(fp, "(%d End)\n", dwThreadID);
			else
				fprintf(fp, "(%d End FAIL)\n", dwThreadID);
		}
		fclose(fp);
	}

	Unlock();

	return dwRetThreadID;
}

void CHTMLLog::Lock()
{
	::EnterCriticalSection( &m_csLogLock );
}

void CHTMLLog::Unlock()
{
	::LeaveCriticalSection( &m_csLogLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsmfc.cpp ===
// apgtsmfc.cpp

// Equivalents of Global Afx MFC functions.
// Use the real MFC functions if you can. 

#include "stdafx.h"
#include "apgtsmfc.h"
#include "apgtsassert.h"
#include "CharConv.h"
#include <stdio.h>	// Needed for sprintf

extern HANDLE ghModule;


// This is not the name of any MFC Afx function
// This loads a string from the resource file.  It is here as a basis for CString::LoadString().
// INPUT nID - resource ID of a string resource?
// INPUT/OUTPUT lpszBuf - on input, points to a buffer.  On output, that buffer contains ???
// INPUT nMaxBuf - size of lpszBuf
int AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
	// convert integer value to a resource type compatible with Win32 resource-management 
	// fns. (used in place of a string containing the name of the resource.)
	// >>> Why rightshift and add 1? (Ignore in V3.0 because this is if'd out, anyway)
	LPCTSTR lpszName = MAKEINTRESOURCE((nID>>4)+1);
	HINSTANCE hInst;
	int nLen = 0;

	// Only works from the main module.
	hInst = AfxGetResourceHandle();
	if (::FindResource(hInst, lpszName, RT_STRING) != NULL)
		nLen = ::LoadString(hInst, nID, lpszBuf, nMaxBuf);
	return nLen;
}

// Return HINSTANCE handle where the default resources of the application are loaded.
HINSTANCE AfxGetResourceHandle()
{
	return (HINSTANCE) ghModule;
}


#if 0
// We've removed this because we are not using string resources.  If we revive
//	string resources, we must revive this function.

// INPUT/OUTPUT &rString-CString object (remember, not MFC CString).  On return, will 
//		contain the resultant string after the substitution is performed.
// INPUT nIDS- resource ID of template string on which the substitution will be performed.
// INPUT *lpsz1-In the MFC AfxFormatString1, a string that will replace the format 
//	characters "%1" in the template string.  In our version, will perform only a single
//	replacement & will replace '%' followed by _any_ character.
// Will be a mess if rString as pased in does not contain such an instance.
void AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1)
{
	CString str;
	str.LoadString(nIDS);
	int iInsert = str.Find('%', -1);
	rString = str.Left(iInsert);
	rString += lpsz1;
	rString += str.Right(str.GetLength() - iInsert - 2);
	return;
}
#endif

#if 0
// We've removed this because we are not using string resources.  If we revive
//	string resources, we must revive this function.

// Like AfxFormatString1, but also has an input lpsz2 to replace the format characters "%2.
// In our version, will perform only a single replacement by lpsz1 and a single replacement 
// by lpsz2, & rather than look for "%1" and "%2" will replace the first 2 instances of 
// '%' followed by _any_ character.
// Will be a mess if rString as pased in does not contain 2 such instances.
void AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1,
		LPCTSTR lpsz2)
{
	int iFirst;
	int iSecond;
	CString str;
	str.LoadString(nIDS);
	iFirst = str.Find('%', -1);
	rString = str.Left(iFirst);
	rString += lpsz1;
	iSecond = str.Find(_T('%'), iFirst);
	rString += str.Mid(iFirst + 2, iSecond - (iFirst + 2) );
	rString += lpsz2;
	rString += str.Right(str.GetLength() - iSecond - 2);
	return;
}
#endif

// Utilize this namespace for non-class related functions.
namespace APGTS_nmspace
{
	// function of convenience - has nothing to do with MFC
	bool GetServerVariable(CAbstractECB *pECB, LPCSTR var_name, CString& out)
	{
		char buf[256] = {0}; // 256 should cover all cases
		DWORD size = sizeof(buf)/sizeof(buf[0]);

		if (pECB->GetServerVariable(var_name, buf, &size)) 
		{
			out = (LPCTSTR)buf;
			return true;
		}
		return false;
	}

// >>> $MAINT - It would be preferable to use standardized encode-decoding logic rather
//				than maintaining this custom code.  RAB-19990921.
	// V3.2
	// Utility function to URL encode cookies.  
	// char, not TCHAR: cookie is always ASCII.
	void CookieEncodeURL( CString& strURL )
	{
		CString	strTemp;
		int		nURLpos;
		char	cCurByte;

		for (nURLpos= 0; nURLpos < strURL.GetLength(); nURLpos++)
		{
			cCurByte= strURL[ nURLpos ];
			if (isalnum( cCurByte ))
				strTemp+= strURL.Mid( nURLpos, 1 );
			else if (cCurByte == _T(' '))
				strTemp+= _T("+");
			else if ((cCurByte == _T('=')) || (cCurByte == _T('&')))	// Skip over name-pair delimiters.
				strTemp+= strURL.Mid( nURLpos, 1 );
			else if ((cCurByte == _T('+')) || (cCurByte == _T('%')))	// Skip over previously encoded characters.
				strTemp+= strURL.Mid( nURLpos, 1 );
			else
			{
				// Encode all other characters.
				char szBuff[5];

				sprintf( szBuff, _T("%%%02X"), (unsigned char) cCurByte );
				strTemp+= szBuff;
			}
		}
		strURL= strTemp;

		return;
	}

	// Utility function to URL decode cookies.
	// char, not TCHAR: cookie is always ASCII.
	void CookieDecodeURL( CString& strURL )
	{
		CString	strTemp;
		int		nURLpos;
		char	cCurByte;

		for (nURLpos= 0; nURLpos < strURL.GetLength(); nURLpos++)
		{
			cCurByte= strURL[ nURLpos ];
			if (cCurByte == _T('+'))
				strTemp+= _T(" ");
			else if (cCurByte == _T('%')) 
			{
				// Decode URL encoded characters.
				char szBuff[3];
				int	 nVal;

				szBuff[ 0 ]= strURL[ ++nURLpos ];
				szBuff[ 1 ]= strURL[ ++nURLpos ];
				szBuff[ 2 ]= '\0';
				sscanf( szBuff, "%02x", &nVal );
				sprintf( szBuff, "%c", nVal );
				strTemp+= szBuff;
			}
			else
				strTemp+= strURL.Mid( nURLpos, 1 );
		}
		strURL= strTemp;

		return;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsinf.h ===
//
// MODULE: APGTSINF.H
//
// PURPOSE: Inference support header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-21-98		JM		Major revision, deprecate IDH in favor of NID, use STL.
//

#if !defined(APGTSINF_H_INCLUDED)
#define APGTSINF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "propnames.h"
#include "topic.h"


using namespace std;

#define MAXBUF	256				// length of text buffers used for filenames,
								// IP adresses (this is plenty big), HTTP response ( like
								// "200 OK", again, plenty big), registry keys, 
								// and occasionally just to format an arbitrary string.

//--------------------------------------------------------------------
// Default Values for localizable text
#define SZ_UNKNOWN _T("Unknown")
#define SZ_NEXT_BTN _T("Next")
#define SZ_START_BTN _T("StartOver")
#define SZ_BACK_BTN _T("Back")
#define SZ_PP_SNIF_BTN _T("Investigate")
//#define SZ_I_NO_RESULT_PAGE _T("<HR>Not Enough Information was available to provide a useful result\n <BR>It is also possible that the information you provided is not correct, please check your entries\n <BR>Please amend your choices\n <P><INPUT TYPE=SUBMIT VALUE=\"Continue\"><BR>")
#define SZ_I_NO_RESULT_PAGE _T("<HR>This troubleshooter can't diagnose the cause of your problem based on the information you have provided.\n <BR>Either start the troubleshooter over, change your answers in the table and continue, or search for other resources.\n <P><INPUT TYPE=SUBMIT VALUE=\"Continue\"><BR>")

#define SZ_HIST_TABLE_SNIFFED_TEXT _T("INVESTIGATED")
#define SZ_ALLOW_SNIFFING_TEXT _T("I want the troubleshooter to investigate settings on this computer")
#define SZ_SNIFF_ONE_NODE _T("Investigate")
#define SZ_SNIFF_FAILED _T("The troubleshooter was unable to investigate the necessary settings.  Follow the remaining instructions on this page to complete the task manually.")

#define SZ_INPUT_TAG_NEXT		  _T("<INPUT tag=next TYPE=SUBMIT VALUE=\"")
#define SZ_INPUT_TAG_STARTOVER	  _T("<INPUT tag=startover TYPE=BUTTON VALUE=\"")
#define SZ_INPUT_TAG_BACK		  _T("<INPUT tag=back TYPE=BUTTON VALUE=\"")
#define SZ_INPUT_TAG_SNIFFER	  _T("<INPUT tag=sniffer TYPE=BUTTON VALUE=\"")

// Text forms of some special state values
#define SZ_ST_FAILED	_T("0")		// "failed" on fixable node is considered normal
// 101 - Go to "Bye" Page (User succeeded)
#define SZ_ST_WORKED	_T("101")
// 102 - Unknown (user doesn't know the correct answer here - applies to Fixable/Unfixable and 
//	Info nodes only)
#define SZ_ST_UNKNOWN	_T("102")
// 103 - "Anything Else?"  (effectively, "retry a skiped node?"
#define SZ_ST_ANY		_T("103") 
// 
#define SZ_ST_SNIFFED_MANUALLY_TRUE		_T("true") 
// 
#define SZ_ST_SNIFFED_MANUALLY_FALSE	_T("false") 


class CSniffConnector;
class CSniff;
//
class CInfer
{
	// This class is an instrument to restore m_arrInitial - like order of 
	//  elements in array, passed to its "Restore" function
	class CArrayOrderRestorer
	{
		vector<NID> m_arrInitial;
		
	public:
		CArrayOrderRestorer(const vector<NID>& initial) : m_arrInitial(initial) {}

	public:
		bool Restore(long base_length, vector<NID>& arr_to_restore);
	};
	
  public:
	CInfer(CSniffConnector* pSniffConnector);
	~CInfer();

	int INode(LPCTSTR sz) {return m_pTopic->INode(sz);};
		
	void	SetTopic(CTopic *pTopic);
	
	void	SetNodeState(NID nid, IST ist);
	void	AddToSniffed(NID nid, IST ist);

	void	IdentifyPresumptiveCause();
	void	FillInHTMLFragments(CHTMLFragmentsTS &frag);

	bool	AppendBESRedirection(CString & str);

	NID		NIDFromIDH(IDH idh) const;	
	NID		NIDSelected() const;

	CSniff* GetSniff();

	void    SetLastSniffedManually(bool);

private:
	enum ActionButtons {
		k_BtnNext = 0x01, 
		k_BtnBack = 0x02, 
		k_BtnStartOver = 0x04, 
		k_BtnPPSniffing = 0x08,		// Problem Page sniff button for expensive sniffing
									//	of multiple nodes
		k_BtnManualSniffing = 0x10,	// for manual sniffing of a single node
	};
	typedef UINT ActionButtonSet;		// should be an OR of 0 or more ActionButtons

private:
	bool	IsProblemNode(NID nid) const;
	void	AddToBasisForInference(NID nid, IST ist);
	void	GetRecommendations();
	void	RecycleSkippedNode();
	bool	AllCauseNodesNormal();
	bool    IsInSniffedArray(NID nid) const;
	bool    IsPresumptiveCause(NID nid) const;

	void	CreateUnknownButtonText(CString & strUnknown) const;
	void	AppendNextButtonText(CString & str) const;
	void	AppendBackButtonText(CString & str) const;
	void	AppendPPSnifferButtonText(CString & str) const;
	void	AppendStartOverButtonText(CString & str) const;
	void	AppendManualSniffButtonText(CString & str) const;
	void	AppendHistTableSniffedText(CString & str) const;
	void	AppendAllowSniffingText(CString & str) const;
	void	AppendSniffFailedText(CString & str) const;
	
	void	AppendActionButtons(CString & str, ActionButtonSet btns, NID nid = -1) const;
	void    AppendNextButton(CString & str) const;
	void    AppendStartOverButton(CString & str) const;
	void    AppendBackButton(CString & str) const;
	void    AppendPPSnifferButton(CString & str) const;
	void	AppendManualSniffButton(CString & str, NID nid) const;
	
	void	AppendMultilineNetProp(CString & str, LPCTSTR szPropName, LPCTSTR szFormat);
	void	AppendMultilineNodeProp(CString & str, NID nid, LPCTSTR szPropName, LPCTSTR szFormat);
	void	AppendCurrentRadioButtons(NID nid, CString & str);
	static void AppendRadioButtonCurrentNode(
				CString &str, LPCTSTR szName, LPCTSTR szValue, LPCTSTR szLabel, bool bChecked =false);
	void	AppendRadioButtonVisited(CString &str, NID nid, UINT value, bool bSet, 
				LPCTSTR szLabel, bool bShowHistory) const;
	void	CreateProblemVisitedText(CString & str, NID nidProblem, bool bShowHistory);
	bool	AppendVisitedNodeText(CString & str, NID nid, bool bShowHistory) const; 
	void	AppendStateText(CString & str, NID nid, UINT state, bool bSet, bool bSkipped, 
							bool bShowHistory, int nStateSet);
	void    AppendHiddenFieldSniffed(CString &str, NID nid) const;
	void    AddAllowAutomaticSniffingHiddenField(CString &str) const;
	void	AppendCurrentNodeText(CString & str);
	void	AppendByeMsg(CString & str);
	void	AppendFailMsg(CString & str);
	void	AppendServiceMsg(CString & str);
	void	AppendNIDPage(NID nid, CString & str);
	void	AppendImpossiblePage(CString & str);
	void	AppendSniffAllCausesNormalPage(CString & str);
	void	AppendProblemPage(CString & str);
	void	AppendProblemNodes(CString & str);
	void	AppendLinkAsButton(
				CString & str, 
				const CString & strTarget, 
				const CString & strLabel) const;

	// JSM V3.2 wrapper for AppendMultilineNetProp() used by FillInHTMLFragments()
	CString ConvertNetProp(const CString &strNetPropName);

	bool	ShowFullBES();
	bool	TimeForBES();
	void	OutputBackend(CString & str);

	static bool	HideState(LPCTSTR szStateName);
	bool	SymbolicFromNID(CString & str, NID nid) const; 
	static bool IsCause (ESTDLBL lbl);
	bool	IsSkipped(NID nid) const;

	bool    ManuallySniffedNodeExists() const;
	bool    IsManuallySniffedNode(NID nid) const;

private:

	CTopic	*m_pTopic;			// associated belief network

	CSniff  *m_pSniff;			// associated sniffing object

// History, extracted from the query from the user.
// All this is known _before_ we seek a recommendation.

	CBasisForInference m_BasisForInference;	// tie together nodes & their states; excludes
											// skipped nodes
	CBasisForInference m_SniffedStates;	// tie together successfully sniffed nodes & their states 
	vector<NID> m_arrnidSkipped;		// nodes for which the user has been unable to give
										// a yes or no answer (or, in the case of multistate,
										// any useful answer at all).
	vector<NID> m_arrnidVisited;		// node numbers of recommendations the user has visited
										// This includes skipped nodes, but excludes the selected problem
										// and excludes pseudo-nodes like the FAIL node.
	NID m_nidProblem;					// problem node indicated by user request.  
										//	set to nidNil if no problem node yet specified.
	bool	m_bDone;					// TRUE ==> we got back state ST_WORKED (better be 
										//	for the last node in the list!) so it's time to 
										//	show the BYE page

	CString m_strStartOverLink;			// For Online TS, URL of Problem page

// Recommendations
	CRecommendations m_Recommendations;  // new recommendations.  We only care about the  
							//	first recommendation not already offered and skipped.
	bool m_bRecOK;			// true ==> m_Recommendations is valid.  (Can be valid and
							//	empty if nothing to recommend).
	CNodeStatePair m_SniffedRecommendation;	// if a recommendation from a sniffer overrides normal;
							// method of getting a recommendation, here's where we store it.
							// Otherwise, nidNil.
							// Because this is always a Cause node in its abnormal state,
							// it is actually redundant (but harmless) to track state as
							// well as node ID.

// Back End Search
	bool	m_bUseBackEndRedirection;// Set true when user asks for Back End Search
	CString m_strEncodedForm;	// URL-encoded search form (like the contents of a Get-method
								//	query).  This is built as a side effect when we construct
								//	the full BES page.

// Variables related to re-offering a previously skipped node
	bool	m_bRecycleSkippedNode;	// Set TRUE if user (responding to service node) wants  
									// to revisit a previously skipped node.  May be set false
									// if we discover there is no such node to revisit.
	NID		m_nidRecycled;			// Node to use if m_bRecycleSkippedNode is TRUE
	bool	m_bRecyclingInitialized;// Protects against multiple calls to RecycleSkippedNode()

// ------------- Misc -------------

	NID		m_nidSelected;		// once we work out what node to show the user, we keep this
								//	around for logging.

	bool    m_bLastSniffedManually; // identifies that last node was sniffed manually
};

#endif // !defined(APGTSINF_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsmfc.h ===
// apgtsmfc.h

// Global Afx MFC functions.
// + WinSocks function of convenience

// Use the real MFC functions if you can - We can not. Oleg 09.01.98

#include "apgtsstr.h"
#include "apgtsECB.h"
#include "time.h"

int AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf);
HINSTANCE AfxGetResourceHandle();
#if 0
// We've removed these because we are not using string resources.  If we revive
//	string resources, we must revive these functions.
void AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1, LPCTSTR lpsz2);
#endif

namespace APGTS_nmspace
{
// functions of convenience - have nothing to do with MFC.

bool GetServerVariable(CAbstractECB *pECB, LPCSTR var_name, CString& out);

// Utility functions to URL encode and decode cookies.
void CookieEncodeURL( CString& strURL );
void CookieDecodeURL( CString& strURL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtspl.cpp ===
//
// MODULE: APGTSPL.CPP
//
// PURPOSE: Pool Queue shared variables
//	Fully implement class PoolQueue
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/21/98		JM		Working on encapsulation
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgtspl.h"
#include "event.h"
#include "apgtscls.h"
#include "CharConv.h"

//
//
CPoolQueue::CPoolQueue() :
	m_dwErr(0),
	m_cInProcess(0),
	m_timeLastAdd(0),
	m_timeLastRemove(0)
{

	::InitializeCriticalSection( &m_csQueueLock );
	
	m_hWorkSem = CreateSemaphore(NULL,
									0,
									0x7fffffff,
									NULL );
	if (m_hWorkSem == NULL)
		m_dwErr = EV_GTS_ERROR_POOL_SEMA;
}

//
//
CPoolQueue::~CPoolQueue() 
{
	if (m_hWorkSem)
		::CloseHandle(m_hWorkSem);

    while ( !m_WorkQueue.empty() ) 
	{
        delete m_WorkQueue.back();
		m_WorkQueue.pop_back();
	}    

	::DeleteCriticalSection( &m_csQueueLock );
}

void CPoolQueue::Lock()
{
    ::EnterCriticalSection( &m_csQueueLock );
}

void CPoolQueue::Unlock()
{
    ::LeaveCriticalSection( &m_csQueueLock );
}

//
//
DWORD CPoolQueue::GetStatus()
{
	return m_dwErr;
}

// put it at the tail of the queue & Signal the pool threads there is work to be done
// OK if we're already locked when this is called; OK if we're not.
void CPoolQueue::PushBack(WORK_QUEUE_ITEM * pwqi)
{
	Lock();
	// Some data passed to thread just for statistical purposes
	// Thread can pass this info back over web; we can't.
	pwqi->GTSStat.dwQueueItems = GetTotalQueueItems();
	pwqi->GTSStat.dwWorkItems = GetTotalWorkItems();

	try
	{
		m_WorkQueue.push_back(pwqi);
		time(&m_timeLastAdd);

		//  Signal the pool threads there is work to be done only if it was
		//	successfully added to the work queue.
		::ReleaseSemaphore( m_hWorkSem, 1, NULL );
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	Unlock();
}

// Get the item at the front of the queue in order to act on it.
WORK_QUEUE_ITEM * CPoolQueue::GetWorkItem()
{
	WORK_QUEUE_ITEM * pwqi;
    Lock();
    
	if ( !m_WorkQueue.empty() ) 
	{
		vector<WORK_QUEUE_ITEM *>::iterator it = m_WorkQueue.begin();
		pwqi = *it;
		m_WorkQueue.erase(it);
		time(&m_timeLastRemove);
		++m_cInProcess;
    }
    else
        pwqi = NULL;

    Unlock();
	return pwqi;
}

// When we are totally done with a work item, reduce the count of those which are
//	in process.
// Arbitrary, but acceptable, decision to track m_cInProcess in this class. JM 11/30/98
void CPoolQueue::DecrementWorkItems()
{
	Lock();
	--m_cInProcess;
	Unlock();
}

// Called by a pool thread to wait for there to be something in this queue.
DWORD CPoolQueue::WaitForWork()
{
	return ::WaitForSingleObject( m_hWorkSem, INFINITE );
}

// Arbitrary, but acceptable, decision to track m_cInProcess in this class. JM 11/30/98
DWORD CPoolQueue::GetTotalWorkItems()
{
	Lock();
	DWORD ret = m_cInProcess + GetTotalQueueItems();
	Unlock();
	return ret;
}

DWORD CPoolQueue::GetTotalQueueItems()
{
	Lock();
	DWORD ret = m_WorkQueue.size();
	Unlock();
	return ret;
}

time_t CPoolQueue::GetTimeLastAdd()
{
	Lock();
	time_t ret = m_timeLastAdd;
	Unlock();
	return ret;
}

time_t CPoolQueue::GetTimeLastRemove()
{
	Lock();
	time_t ret = m_timeLastRemove;
	Unlock();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtspl.h ===
//
// MODULE: APGTSPL.H
//
// PURPOSE: Pool Queue shared variables
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/21/98		JM		Pull out of apgts.h to separate header file.
//								Working on encapsulation
//

#ifndef _H_APGTSPL
#define _H_APGTSPL

#include <windows.h>
#include <vector>
using namespace std;

// forward references
class CDBLoadConfiguration;
class CHTMLLog;
class CAbstractECB;

//
//
typedef struct _GTS_STATISTIC	// for gathering DLL statistics
{
	DWORD dwQueueItems;
	DWORD dwWorkItems;
	DWORD dwRollover;			// unique per request while this DLL is loaded
} GTS_STATISTIC;

//
// promoting this from a struct to a class 1/4/99 JM.  However, not fully encapsulating it.
class WORK_QUEUE_ITEM
{
	WORK_QUEUE_ITEM(); // do not instantiate.  No default constructor.
public:
	HANDLE                    hImpersonationToken;	// security thread should use while
													// processing this work item
    CAbstractECB			  *pECB;				// ISAPI uses an EXTENSION_CONTROL_BLOCK
													//	to wrap CGI data.  We have further 
													//	abstracted this.
	CDBLoadConfiguration	  *pConf;				// registry, DSC files, all that stuff
	CHTMLLog				  *pLog;				// logging
	GTS_STATISTIC			  GTSStat;				// for gathering DLL statistics

	WORK_QUEUE_ITEM(
		HANDLE                    hImpersonationTokenIn,
		CAbstractECB			  *pECBIn,
		CDBLoadConfiguration	  *pConfIn,
		CHTMLLog				  *pLogIn
		) : hImpersonationToken(hImpersonationTokenIn),
			pECB(pECBIn),
			pConf(pConfIn),
			pLog(pLogIn)
		{}
 
	~WORK_QUEUE_ITEM() 
		{}
};


class CPoolQueue {
public:
	CPoolQueue();
	~CPoolQueue();

	DWORD GetStatus();
	void Lock();
	void Unlock();
	void PushBack(WORK_QUEUE_ITEM * pwqi);
	WORK_QUEUE_ITEM * GetWorkItem();
	void DecrementWorkItems();
	DWORD WaitForWork();
	DWORD GetTotalWorkItems();
	DWORD GetTotalQueueItems();
	time_t GetTimeLastAdd();
	time_t GetTimeLastRemove();
protected:
	CRITICAL_SECTION m_csQueueLock;	// must lock to add or delete from either list or to affect
									// m_cInProcess or the various time_t variables.
	HANDLE m_hWorkSem;				// NT Semaphore handle for distributing requests to threads
									// Wait on this semaphore for a work item from this queue
	DWORD m_dwErr;					// NOTE: once this is set nonzero, it can never be cleared.
	vector<WORK_QUEUE_ITEM *> m_WorkQueue;	// vector of WORK_QUEUE_ITEMs (queued up by
									// APGTSExtension::StartRequest for working threads)
	DWORD m_cInProcess;				// # of items waiting in process (being worked on, vs.
									//	still in queue). Arbitrary, but acceptable, decision 
									//	to track m_cInProcess in this class. JM 11/30/98

	time_t m_timeLastAdd;			// time last added an item to the queue
	time_t m_timeLastRemove;		// time an item was last removed from the queue
};

#endif // _H_APGTSPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsqry.cpp ===
//
// MODULE: APGTSQRY.CPP
//
// PURPOSE: Implementation file for PTS Query Parser
// Fully implements class CHttpQuery, parsing out NAME=VALUE pairs from HTTP query string
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
// 2. Caller is responsible to assure that all buffers passed in are large enough
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.1		12/17/98	JM		Major cleanup, add Push capablity
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgts.h"
#include "apgtscls.h"

//
//
CHttpQuery::CHttpQuery() :
	m_state(ST_GETDATA),
	m_nIndex(0)
{
}

//
//
CHttpQuery::~CHttpQuery()
{
}

//
// INPUT *szInput - this is the URL-encoded query string in which we are searching
// INPUT *pchName - must point to a buffer of size MAXBUF
// OUTPUT *pchName - Typically NAME of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  Leading and trailing blanks stripped.
// INPUT *pchValue - must point to a buffer of size MAXBUF
// OUTPUT *pchValue - Typically VALUE of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  Leading and trailing blanks stripped.
// RETURN - TRUE ==> more data to come
BOOL CHttpQuery::GetFirst(LPCTSTR szInput, TCHAR *pchName, TCHAR *pchValue)
{
	m_state = ST_GETDATA;
	m_strInput = szInput;
	m_nIndex = 0;
	
	BOOL status = LoopFind(pchName, pchValue);
	CleanStr(pchName);
	CleanStr(pchValue);
	return (status);
}

// Called after a call to CHttpQuery::GetFirst or to this fn has returned true
// INPUT *pchName - must point to a buffer of size MAXBUF
// OUTPUT *pchName - Typically NAME of a NAME=VALUE pair
//	Null-terminated.  Leading and trailing blanks stripped.
// INPUT *pchValue - must point to a buffer of size MAXBUF
// OUTPUT *pchValue - Typically VALUE of a NAME=VALUE pair
//	Null-terminated.  Leading and trailing blanks stripped.
// RETURN - TRUE ==> more data to come
BOOL CHttpQuery::GetNext(TCHAR *pchName, TCHAR *pchValue)
{
	BOOL status = LoopFind(pchName, pchValue);
	CleanStr(pchName);
	CleanStr(pchValue);
	return (status);
}

// put new content on the front of the unparsed portion of the query string in which we are 
//	searching.
// Typically, szPushed should consist of 1 or more NAME=VALUE pairs, each terminated by an
//	ampersand ("&").
void CHttpQuery::Push(LPCTSTR szPushed)
{
	m_state = ST_GETDATA;
	m_strInput = CString(szPushed) + m_strInput.Mid(m_nIndex);
	m_nIndex = 0;
}

//
// RETURN - TRUE ==> more data to come
// INPUT *pchName - must point to a buffer of size MAXBUF
// OUTPUT *pchName - Typically NAME of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  May have leading and/or trailing blanks
// INPUT *pchValue - must point to a buffer of size MAXBUF
// OUTPUT *pchValue - Typically VALUE of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  May have leading and/or trailing blanks
BOOL CHttpQuery::LoopFind(TCHAR *pchName, TCHAR *pchValue)
{
	*pchName = NULL;
	*pchValue = NULL;

	TCHAR ch;
	int val, oldval = 0;
	TCHAR temp[20];		// a way bigger buffer than we need
	TCHAR *pchPut;		// initially points to pchName but can change to point to pchValue

	int nLength = m_strInput.GetLength();

	if (m_nIndex >= nLength)
		return (FALSE);

	pchPut = pchName;
	
	while (m_nIndex < nLength)
	{
		ch = m_strInput[m_nIndex++]; // You might think something related to _tcsinc() 
					//	would be called for to advance m_nIndex.  You'd be wrong, 
					//	although the choice would be harmless.  
					// URL-encoding keeps us within the ASCII character set, so no double-
					//	byte issues should arise.  Besides that, the strings passed in to the
					//	command line of the troubleshooter controls are even further 
					//	constrained: for example, even in a Japanese-language topic, node
					//	names will be ASCII.
		switch(m_state) {
			case ST_GETDATA:
				if (ch == _T('&'))
					// expect another NAME=VALUE pair
					return (TRUE);
				else if (ch == _T('=')) {
					// Got a name, expect a value
					pchPut = pchValue;
					break;
				}
				else if (ch == _T('%')) 
					// expect to be followed by 2-digit hex
					m_state = ST_DECODEHEX1;	
				else if (ch == _T('+'))
					// encoded blank
					AddBuffer(_T(' '),pchPut);
				else
					AddBuffer(ch,pchPut);
				break;
			case ST_DECODEHEX1:
				// first of 2 hex digits
				temp[0] = ch;
				m_state = ST_DECODEHEX2;
				break;
			case ST_DECODEHEX2:
				// second of 2 hex digits; parse it into a hex value & affix it to *pchPut
				temp[1] = ch;
				temp[2] = 0;
				_stscanf(temp,_T("%02X"),&val);

				// reinterpret CR, LF, or CRLF as '\n'
				if (val == 0x0A) {
					if (oldval != 0x0D)
						AddBuffer(_T('\n'),pchPut);
				}
				else if (val == 0x0D)
					AddBuffer(_T('\n'),pchPut);
				else 
					AddBuffer( static_cast<TCHAR>(val), pchPut );

				oldval = val;
				m_state = ST_GETDATA;
				break;
			default:
				return (FALSE);
		}
	}
	return (TRUE);
}

//
// append ch to *tostr, with a few subtleties: see comments in body of routine
void CHttpQuery::AddBuffer( TCHAR ch, TCHAR *tostr)
{
	if (ch == _T('\t')) 
		// TAB -> 4 blanks
		PutStr(_T("    "),tostr);
	else if (ch == _T('\n'))
		// blank before newline
		PutStr(_T(" \n"),tostr);
	else if (ch == _T('<')) 
		// html: must encrypt left angle bracket.
		PutStr(_T("&lt"),tostr);
	else if (ch == _T('>'))
		// html: must encrypt right angle bracket.
		PutStr(_T("&gt"),tostr);
	else if (ch > 0x7E || ch < 0x20)
		// refuse DEL, NUL, and control characters
		return;
	else {
		TCHAR temp[2];
		temp[0] = ch;
		temp[1] = _T('\0');
		PutStr(temp,tostr);
	}
}

// append string *addtostr to string *instr up to a maximum size of MAXBUF-1
// INPUT/OUTPUT *instr
// INPUT *addtostr 
// NOTE that this fails silently if total lengths exceed MAXBUF-1 chars
void CHttpQuery::PutStr(LPCTSTR instr, TCHAR *addtostr)
{
	if ((_tcslen(instr)+_tcslen(addtostr)) >= (MAXBUF-1)) {
		// can't add it to buff
		return;
	}
	_tcscat(addtostr,instr);
}

// Acts upon INPUT/OUTPUT *str - strip any leading control characters and spaces, 
//	turn any other control characters and spaces into '\0's
/* static */ void CHttpQuery::CleanStr(TCHAR *str)
{
	TCHAR temp[MAXBUF], *ptr;
	int len;

	ptr = str;
	while (*ptr > _T('\0') && *ptr <= _T(' '))
		ptr = _tcsinc(ptr);
	_tcscpy(temp,ptr);
	if ((len = _tcslen(temp))!=0) {
		ptr = &temp[len-1];
		while (ptr > temp) {
			if (*ptr > _T('\0') && *ptr <= _T(' '))
				*ptr = _T('\0');
			else
				break;
			ptr = _tcsdec(temp, ptr);
		}
	}
	_tcscpy(str,temp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsregconnect.h ===
//
// MODULE: APGTSREGCONNECT.H
//
// PURPOSE: read - write to the registry
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-24-98
//
// NOTES: 
//	1. This file is shared by Local TS and Online TS, but implemented separately in each.
//		The relevant CPP files are OnlineRegConnect.cpp and LocalRegConnect.cpp, respectively.
//	2. If we are moving toward a COM object at some point, we will probably have to establish an
//		abstract class in lieu of CAPGTSRegConnector and have Online & Local TS's each derive their
//		own version.  Meanwhile (1/99), we share a common interface (defined in APGTSRegConnect.h)
//		but implement it differently.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __APGTSREGCONNECT_H_
#define __APGTSREGCONNECT_H_

#include "BaseException.h"
#include "Stateless.h"
#include "regutil.h"
#include "MutexOwner.h"
#include "commonregconnect.h"

// no registry parameter can be larger than this value
#define ABS_MAX_REG_PARAM_VAL		10000

class CAPGTSRegConnectorException; // find class declaration under
								   //  CAPGTSRegConnector class declaration

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector
// 	Performs connection of APGTS project to the registry,
//	that means loading data stored in the registry, 
//  creation of keys and values if not presented in the registry,
//  detecting what kind of registry - stored data has recently been changed.
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSRegConnector
{
public:
	enum ERegConnector { 	
			eIndefinite          = 0x0,
			eResourcePath        = 0x1,
			eVrootPath			 = 0x2,
			eMaxThreads			 = 0x4,
			// 0x8 is currently unassigned
			eThreadsPP			 = 0x10,
			eMaxWQItems			 = 0x20,
			eCookieLife			 = 0x40,
			eReloadDelay		 = 0x80,
			// 0x100 is currently unassigned
			eDetailedEventLogging= 0x200,
			eLogFilePath		 = 0x400,
			// only appropriate in Local Troubleshooter
			eTopicFileExtension	 = 0x800,
			// currently appropriate only in Local Troubleshooter
			eSniffAutomatic		 = 0x1000,
			eSniffManual		 = 0x2000,

			// the rest just for use in exception handling
			eProblemWithLogKey	 = 0x4000,	// problem with key to IIS area where we get log file path
			eProblemWithKey		 = 0x8000
	};

public:
	static CString & StringFromConnector(ERegConnector e, CString & str);
	static ERegConnector ConnectorFromString( const CString & str);
	static void AddBackslash(CString & str);
	static void BackslashIt(CString & str, bool bForce);
	static bool IsNumeric(ERegConnector e);
	static bool IsString(ERegConnector e);

protected:
	static bool AssignString(CString & strPersist, const CString & strNew, DWORD dwEvent);
	static bool AssignNumeric(DWORD & dwPersist, DWORD dwNew, 
					   DWORD dwEvent, DWORD dwEventDecrease =0);
	static bool ForceRangeOfNumeric(DWORD & dw, DWORD dwDefault, DWORD dwEvent, 
			DWORD dwMin=1, DWORD dwMax=ABS_MAX_REG_PARAM_VAL);

protected:
	
	struct CRegistryInfo
	{
		CString strResourcePath;		// DEF_FULLRESOURCE: resource directory 
										//	(configuration/support files)
		CString strVrootPath;		    // DEF_VROOTPATH: local web URL to the DLL

		DWORD dwMaxThreads;				// desired number of pool threads
		DWORD dwThreadsPP;				// (On Microsoft's server farm,
										//	this system runs on a 4-processor box.)
										// If dwThreadsPP * (number of processors) > dwMaxThreads,
										//	dwMaxThreads wins out as a limitation
		DWORD dwMaxWQItems;				// Maximum size of Pool Queue (number of work items
										//	not yet picked up by a pool thread)
		DWORD dwCookieLife;				// cookie life in minutes
		DWORD dwReloadDelay;			// Amount of time (in seconds) file system must settle
										//	down before we try to read from files
		DWORD dwDetailedEventLogging;	// really a boolean
		CString strLogFilePath;			// Defaults to DEF_FULLRESOURCE, but expect always to 
										// override that with the location of the IIS log.
		CString strTopicFileExtension;  // appropriate only in Local Troubleshooter

		DWORD dwSniffAutomatic;			// {1/0} control automatic sniffing
		DWORD dwSniffManual;			// {1/0} control manual sniffing

		bool  m_bIsRead;	// indicates that there has been at least one attempt to read the registry

		CRegistryInfo() {SetToDefault();}
	    void SetToDefault();
	};

	CRegistryInfo m_RegistryInfo;
	static CMutexOwner s_mx;
	CString m_strTopicName;				// This string is ignored in the Online Troubleshooter.
										// Done under the guise of binary compatibility.

public:
	CAPGTSRegConnector( const CString& strTopicName );	// strTopicName is ignored in the Online Troubleshooter.
														// Done under the guise of binary compatibility.
	~CAPGTSRegConnector();

	bool Exists(); // the root key (In Online TS, "HKEY_LOCAL_MACHINE\SOFTWARE\\ISAPITroubleShoot") exists
	bool IsRead();
	bool Read(int & maskChanged, int & maskCreated);   // pump data into m_RegistryInfo - 
					//	PLUS sets absent data in registry to default.

	DWORD GetDesiredThreadCount();
	bool GetNumericInfo(ERegConnector, DWORD&);  // returns registry data - numeric
	bool GetStringInfo(ERegConnector, CString&); // returns registry data - string
	bool SetOneValue(const CString & strName, const CString & strValue, bool &bChanged);
protected:
	void Lock();
	void Unlock();

protected:
	void ReadUpdateRegistry(int & maskChanged, int & maskCreated);
	CString ThisProgramFullKey();
	void SetNumericValue(CRegUtil &reg, ERegConnector e, DWORD dwValue);
	void SetStringValue(CRegUtil &reg, ERegConnector e, CString strValue);
	bool SetOneNumericValue(ERegConnector e, DWORD dwValue);
	bool SetOneStringValue(ERegConnector e, const CString & strValue);

private:
	void Clear();
	LPCTSTR RegSoftwareLoc();
	LPCTSTR RegThisProgram();
};

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnectorException
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSRegConnectorException : public CBaseException
{
public:
	CAPGTSRegConnector::ERegConnector  eVariable;
	CRegUtil& regUtil;
	// we are supposed to get WinErr (return of failed ::Reg function)
	//  from the regUtil variable

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CAPGTSRegConnectorException(LPCSTR source_file, 
								int line, 
								CRegUtil& reg_util, 
								CAPGTSRegConnector::ERegConnector variable =CAPGTSRegConnector::eIndefinite)
  : CBaseException(source_file, line),
    regUtil(reg_util),
	eVariable(variable)
	{}
	void Close() {regUtil.Close();}
	void Log();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtstscread.cpp ===
//
// MODULE: APGTSTSCREAD.CPP
//
// PURPOSE: TSC file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Randy Biley
// 
// ORIGINAL DATE: 01-19-1999
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		01-19-1999	RAB
//

#include "stdafx.h"
#include "apgtstscread.h"
#include "CharConv.h"
#include "event.h"


// Utilize an unnamed namespace to limit scope to this source file
namespace
{ 
const CString kstr_CacheSig=		_T("TSCACH03");
const CString kstr_MapFrom=			_T("MAPFROM ");
const CString kstr_NodeStateDelim=	_T(":");
const CString kstr_NodePairDelim=	_T(",");
const CString kstr_MapTo=			_T("MAPTO ");
const CString kstr_CacheEnd=		_T("END");
}


CAPGTSTSCReader::CAPGTSTSCReader( CPhysicalFileReader * pPhysicalFileReader, CCache *pCache )
			   : CTextFileReader( pPhysicalFileReader )
{
	m_pCache= pCache;
}

CAPGTSTSCReader::~CAPGTSTSCReader()
{
}


void CAPGTSTSCReader::Parse()
{
	long save_pos = 0;

	LOCKOBJECT();
	save_pos = GetPos();
	SetPos(0);

	try 
	{
		vector<CString> arrLines;
		

		// pump file content into array of lines.
		CString strLine;
		while (GetLine( strLine ))
			arrLines.push_back( strLine );


		// parse string-by-string.
		bool bFirstLine= true;
		for (vector<CString>::iterator iCurLine = arrLines.begin(); iCurLine < arrLines.end(); iCurLine++)
		{
			// Prepare the line for parsing.
			CString strCur= *iCurLine;
			strCur.TrimLeft();
			strCur.TrimRight();

			if (bFirstLine)
			{
				// Verify that this file has the correct signature.
				if (-1 == strCur.Find( kstr_CacheSig ))
				{
					// Unknown type of file, exit the for loop.  
					// >>>	Should there be error handling/reporting here???  RAB-19990119.
					break;
				}
				bFirstLine= false;
			}
			else if (-1 != strCur.Find( kstr_CacheEnd ))
			{
				// Located the end of file marker, exit the for loop.  
				break;
			}
			else 
			{	
				// Look for the first line of a MapFrom-MapTo pair.
				int nPos= strCur.Find( kstr_MapFrom );
				if (-1 != nPos)
				{
					CBasisForInference	BasisForInference;
					bool				bHasBasisForInference= false;

					// Move the position marker over the MapFrom key word.
					nPos+= kstr_MapFrom.GetLength();

					// Extract all of the node state pairs from the MapFrom line.
					do
					{
						CString	strNode;
						CString	strState;
						int		nNodePos;
						
						// Jump over the leading line format or the node pair delimiter.
						strCur= strCur.Mid( nPos );
						strCur.TrimLeft();
						
						// Look for the delimiter between a node-state pair.
						nNodePos= strCur.Find( kstr_NodeStateDelim );
						if (-1 != nNodePos)
						{
							// Extract the string containing the node value and 
							// then step over the node state delimiter.
							strNode= strCur.Left( nNodePos );
							strCur= strCur.Mid( nNodePos + kstr_NodeStateDelim.GetLength() );

							// Extract the string containing the state value.
							nPos= strCur.Find( kstr_NodePairDelim );
							if (-1 == nPos)
							{
								// We have found the last state value, copy the remaining string.
								strState= strCur;
							}
							else
							{
								// Extract up to the node pair delimiter and move the
								// position marker past that point.
								strState= strCur.Left( nPos );
								nPos+= kstr_NodePairDelim.GetLength();
							}

							if (strNode.GetLength() && strState.GetLength())
							{
								// It appears that we have a valid node-state pair so add
								// them to the basis for inference.
								NID nNid= atoi( strNode );
								IST nIst= atoi( strState );

								BasisForInference.push_back( CNodeStatePair( nNid, nIst )); 
								bHasBasisForInference= true;
							}
							else
							{
								// >>>	This condition should not occur, 
								//		error handling/reporting???  RAB-19990119.
								nPos= -1;
							}
						}
						else
							nPos= -1;

					} while (-1 != nPos) ;


					// Now search for recommendations if the basis for inference was okay.
					CRecommendations	Recommendations;
					bool				bHasRecommendations= false;
					if (bHasBasisForInference)
					{
						// Move to the next line to prepare for searching for a matching 
						// MapTo line.
						iCurLine++;
						if (iCurLine < arrLines.end())
						{
							// Prep the temporary string.
							strCur= *iCurLine;
							strCur.TrimLeft();
							strCur.TrimRight();

							// Look for the matching MapTo element.
							nPos= strCur.Find( kstr_MapTo );
							if (-1 != nPos)
							{
								CString strRecommend;
								
								// Extract all of the recommendations from the MapTo line.
								nPos+= kstr_MapTo.GetLength();
								do
								{
									// Jump over the leading line format or the node pair delimiter.
									strCur= strCur.Mid( nPos );
									strCur.TrimLeft();
									
									// Extract the recommendations string value.
									nPos= strCur.Find( kstr_NodePairDelim );
									if (-1 == nPos)
										strRecommend= strCur;
									else
									{
										strRecommend= strCur.Left( nPos );
										nPos+= kstr_NodePairDelim.GetLength();
									}

									if (strRecommend.GetLength())
									{
										Recommendations.push_back( atoi( strRecommend ) );
										bHasRecommendations= true;
									}
									else
									{
										// >>>	This condition should not occur, 
										//		error handling/reporting???  RAB-19990119.
										nPos= -1;
									}

								} while (-1 != nPos) ;
							}
						}
					}
				
					// We have both items so add them to the cache.
					if (bHasRecommendations && bHasBasisForInference)
						m_pCache->AddCacheItem( BasisForInference, Recommendations );
				}
			}
		}
	} 
	catch (exception& x)
	{
		SetPos(save_pos);
		UNLOCKOBJECT();

		CString str;
		// Note STL exception in event log and rethrow exception.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		throw;
	}

	SetPos(save_pos);
	UNLOCKOBJECT();

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtstscread.h ===
//
// MODULE: APGTSTSCREAD.H
//
// PURPOSE: TSC file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Randy Biley
// 
// ORIGINAL DATE: 01-19-1999
//
// NOTES: 
//	Typical TSC file content might be:
//		TSCACH03
//		MAPFROM 1:1
//		MAPTO 3,5,13,9,16
//		:
//		:
//		:
//		MAPFROM 1:1,3:0
//		MAPTO 5,13,9,16
//		END
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		01-19-1999	RAB
//

#ifndef __APGTSTSCREAD_H_
#define __APGTSTSCREAD_H_

#include "fileread.h"
#include "apgtscac.h"


class CAPGTSTSCReader : public CTextFileReader
{
private:
	CCache *m_pCache;

public:
	CAPGTSTSCReader( CPhysicalFileReader * pPhysicalFileReader, CCache *pCache );
   ~CAPGTSTSCReader();

protected:
	virtual void Parse(); 
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apiwraps.h ===
//
// MODULE: APIwraps.h
//
// PURPOSE: Encapsulate common blocks of API functionality within a class.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 9-30-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-30-98	RAB
//

#include<windows.h>

class APIwraps
{
public:
	APIwraps();
	~APIwraps();

public:
	static bool WaitAndLogIfSlow(	
		HANDLE hndl,		// Handle of object to be waited on.
		LPCSTR srcFile,		// Calling source file (__FILE__), used for logging.
							// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
		int srcLine,		// Calling source line (__LINE__), used for logging.
		DWORD TimeOutVal = 60000	// Time-out interval in milliseconds, after
									// which we log error & wait infinitely.
	);
} ;

// these must be macros, because otherwise __FILE__ and __LINE__ won't indicate the
//	calling location.
#define WAIT_INFINITE(hndl) APIwraps::WaitAndLogIfSlow(hndl, __FILE__, __LINE__)
#define WAIT_INFINITE_EX(hndl, TimeOutVal) APIwraps::WaitAndLogIfSlow(hndl, __FILE__, __LINE__, TimeOutVal)
//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apiwraps.cpp ===
//
// MODULE: APIwraps.CPP
//
// PURPOSE: Encapsulate common blocks of API functionality within a class.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 9-30-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-30-98	RAB
//

#include "stdafx.h"
#include "apiwraps.h"
#include "event.h"
#include "baseexception.h"


APIwraps::APIwraps()
{
}

APIwraps::~APIwraps()
{
}

// Function used to handle the situation where we wish to detect sluggish or stalled objects 
// and log this delay before going into an infinite wait. 
/*static*/ bool APIwraps::WaitAndLogIfSlow(	
					HANDLE hndl,		// Handle of object to be waited on.
					LPCSTR srcFile,		// Calling source file (__FILE__), used for logging.
										// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
					int srcLine,		// Calling source line (__LINE__), used for logging.
					DWORD TimeOutVal /*=60000*/	// Time-out interval in millisecond.  After
										// this we log an error, then wait infinitely
					)
{
	bool	bRetVal= false;
	DWORD	nWaitRetVal;
	CBuildSrcFileLinenoStr SrcLoc( srcFile, srcLine );

	nWaitRetVal= ::WaitForSingleObject( hndl, TimeOutVal );
	if (nWaitRetVal == WAIT_FAILED)
	{
		// very bad news, should never happen
		DWORD dwErr = ::GetLastError();
		CString strErr;
		strErr.Format(_T("%d"), dwErr);
		CBuildSrcFileLinenoStr SrcLoc3(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc3.GetSrcFileLineStr(), 
								_T("Thread wait failed."), 
								strErr, 
								EV_GTS_ERROR_STUCK_THREAD ); 
	}
	else if (nWaitRetVal == WAIT_TIMEOUT)
	{
		// Initial wait timed out, note in log, and wait infinitely.
		CBuildSrcFileLinenoStr SrcLoc1(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc1.GetSrcFileLineStr(), 
								_T("Thread wait exceeded initial timeout interval."), 
								_T(""), 
								EV_GTS_STUCK_THREAD ); 

		nWaitRetVal= ::WaitForSingleObject( hndl, INFINITE );

		// If successfully got what we were waiting for (after logging an apparent
		//	problem), log the fact that it's ultimately OK.
		if (nWaitRetVal == WAIT_OBJECT_0)
		{
			CBuildSrcFileLinenoStr SrcLoc2(__FILE__, __LINE__);
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc2.GetSrcFileLineStr(), 
									_T("Thread infinite wait succeeded."), 
									_T(""), 
									EV_GTS_STUCK_THREAD ); 
			bRetVal= true;
		}
	}
	else
	{
		// We don't really care whether it's WAIT_OBJECT_0 or WAIT_ABANDONED.
		// Either way, we got what we were waiting for
		bRetVal= true;
	}

	return( bRetVal );
}

//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsstr.cpp ===
//
// MODULE: APGTSSTR.CPP
//
// PURPOSE: implements DLL Growable string object CString 
//	(pretty much a la MFC, but avoids all that MFC overhead)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel (reworked code from Microsoft's MFC sources)
// 
// ORIGINAL DATE: 8-2-96 Roman Mach; totally re-implemented 1/15/99 Joe Mabel 
//
// NOTES: 
// 1. As of 1/99, re-implemented based on MFC's implementation.  Pared down
//	to what we use.
// 2. This file modified 5/26/01 by Davide Massarenti from MS to remove reference counting
//   from CString implementation to resolve thread safety issue discovered on dual processor
//   systems when dll compiled for WinXP by MS compiler.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-24-98		JM		Abstracted this out as a separate header.
// V3.1		1-15-99		JM		Redo based on MFC implementation
//

#include "stdafx.h"
#include <stdio.h>
#include "apgtsstr.h"
#include "apgtsmfc.h"

// Windows extensions to strings
#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
// [BC - 20010529] - change below array from int to long and add extra 0 for padding
// to avoid problems indicated by Davide Massarenti in 64-bit environments
static long rgInitData[] = { -1, 0, 0, 0, 0 };
static CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
	Init();
}

CString::CString(const CString& stringSrc)
{
// REMOVING REF COUNTING: 	  ASSERT(stringSrc.GetData()->nRefs != 0);
// REMOVING REF COUNTING: 	  if (stringSrc.GetData()->nRefs >= 0)
// REMOVING REF COUNTING: 	  {
// REMOVING REF COUNTING: 		  ASSERT(stringSrc.GetData() != afxDataNil);
// REMOVING REF COUNTING: 		  m_pchData = stringSrc.m_pchData;
// REMOVING REF COUNTING: 		  InterlockedIncrement(&GetData()->nRefs);
// REMOVING REF COUNTING: 	  }
// REMOVING REF COUNTING: 	  else
// REMOVING REF COUNTING: 	  {
		Init();
		*this = stringSrc.m_pchData;
// REMOVING REF COUNTING: 	  }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);

	// MFC had the following assertion.  I've killed it because we
	//	don't have INT_MAX.  JM 1/15/99
	//ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData =
			(CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(pData)
		{
			pData->nRefs = 1;
			pData->data()[nLen] = '\0';
			pData->nDataLength = nLen;
			pData->nAllocLength = nLen;
			m_pchData = pData->data();
		}
	}
}

void CString::Release()
{
	if (GetData() != afxDataNil)
	{
// REMOVING REF COUNTING: 		  ASSERT(GetData()->nRefs != 0);
// REMOVING REF COUNTING: 		  if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
// REMOVING REF COUNTING: 		  ASSERT(pData->nRefs != 0);
// REMOVING REF COUNTING: 		  if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CString::CopyBeforeWrite()
{
// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1)
// REMOVING REF COUNTING: 	  {
// REMOVING REF COUNTING: 		  CStringData* pData = GetData();
// REMOVING REF COUNTING: 		  Release();
// REMOVING REF COUNTING: 		  AllocBuffer(pData->nDataLength);
// REMOVING REF COUNTING: 		  memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
// REMOVING REF COUNTING: 	  }
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs <= 1);
}

void CString::AllocBeforeWrite(int nLen)
{
// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	if (nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs <= 1);
}

CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
// REMOVING REF COUNTING: 		  if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
// REMOVING REF COUNTING: 	  if (GetData()->nRefs >= 0)
		Release();
// REMOVING REF COUNTING: 	  else
// REMOVING REF COUNTING: 		  *this = &afxChNil;
	ASSERT(GetData()->nDataLength == 0);
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
	Init();
	// Unlike MFC, no implicit LoadString offered - JM 1/15/99
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
// REMOVING REF COUNTING: 	  if (m_pchData != stringSrc.m_pchData)
// REMOVING REF COUNTING: 	  {
// REMOVING REF COUNTING: 		  if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
// REMOVING REF COUNTING: 			  stringSrc.GetData()->nRefs < 0)
// REMOVING REF COUNTING: 		  {
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
// REMOVING REF COUNTING: 		  }
// REMOVING REF COUNTING: 		  else
// REMOVING REF COUNTING: 		  {
// REMOVING REF COUNTING: 			  // can just copy references around
// REMOVING REF COUNTING: 			  Release();
// REMOVING REF COUNTING: 			  ASSERT(stringSrc.GetData() != afxDataNil);
// REMOVING REF COUNTING: 			  m_pchData = stringSrc.m_pchData;
// REMOVING REF COUNTING: 			  InterlockedIncrement(&GetData()->nRefs);
// REMOVING REF COUNTING: 		  }
// REMOVING REF COUNTING: 	  }
	return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    mbstowcs(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    wcstombs(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

// we (Saltmine) have switched away from friend because VC 6/0 doesn't like it. - JM 1/15/99
// we (Saltmine) do LPCTSTR but not TCHAR - JM 1/15/99

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CString CString::operator+(const CString& string2)
{
	CString s;
	s.ConcatCopy(GetData()->nDataLength, m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CString CString::operator+(LPCTSTR lpsz)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(GetData()->nDataLength, m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	if (GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

// CString::GetBuffer() and CString::ReleaseBuffer() calls should be matched.
LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	if (nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CString::Release(pOldData);
	}
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

// CString::GetBuffer() and CString::ReleaseBuffer() calls should be matched.
void CString::ReleaseBuffer(int nNewLength /*  = -1 */)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines 

int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}

void CString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr).  Added function - RAB19991112.
int CString::Find(LPCTSTR lpszSub, int nStart) const
{
	// Suppress the following Assert from MFC - RAB19991112.
	//ASSERT(AfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return CString::FIND_FAILED;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}


/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
	#define TCHAR_ARG   int
	#define WCHAR_ARG   unsigned
	#define CHAR_ARG    int
#else
	#define TCHAR_ARG   TCHAR
	#define WCHAR_ARG   WCHAR
	#define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = lstrlen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

#ifndef _MAC
		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}
#endif
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;
#if 0
// We (Saltmine) are not currently supporting formatting of real numbers 1/15/99
			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;
#endif

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);

	// Got rid of MFC's VERIFY in next line - JM 1/15/99
	//VERIFY(_vstprintf(m_pchData, lpszFormat, argListSave) <= GetAllocLength());
	_vstprintf(m_pchData, lpszFormat, argListSave);
	
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void CString::Format(LPCTSTR lpszFormat, ...)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = static_cast<int>(lpszLast - m_pchData);
	}
}

void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - static_cast<int>(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

BOOL CString::LoadString(UINT nID)
{
    // try fixed buffer first (to avoid wasting space in the heap)
    TCHAR szTemp[256];
    int nLen = ::AfxLoadString(nID, szTemp, _countof(szTemp));
    if (_countof(szTemp) - nLen > CHAR_FUDGE)
    {
        *this = szTemp;
        return nLen > 0;
    }

    // try buffer size of 512, then larger size until entire string is retrieved
    int nSize = 256;
    do
    {
        nSize += 256;
        nLen = ::AfxLoadString(nID, GetBuffer(nSize-1), nSize);
    } while (nSize - nLen <= CHAR_FUDGE);
    ReleaseBuffer();

    return nLen > 0;
}

bool __stdcall operator ==(const CString& s1, const CString& s2)
{
	return (s1.GetLength() == s2.GetLength() && ! _tcscmp((LPCTSTR)s1, (LPCTSTR)s2) );
}

bool __stdcall operator ==(const CString& s1, LPCTSTR s2)
{
	return (! _tcscmp((LPCTSTR)s1, s2) );
}

bool __stdcall operator ==(LPCTSTR s1, const CString& s2)
{
	return (! _tcscmp(s1, (LPCTSTR)s2) );
}

bool __stdcall operator !=(const CString& s1, const CString& s2)
{
	return (s1.GetLength() != s2.GetLength() || _tcscmp((LPCTSTR)s1, (LPCTSTR)s2) );
}

bool __stdcall operator !=(const CString& s1, LPCTSTR s2)
{
	return (_tcscmp((LPCTSTR)s1, s2) ) ? true : false;
}

bool __stdcall operator !=(LPCTSTR s1, const CString& s2)
{
	return (_tcscmp(s1, (LPCTSTR)s2) ) ? true : false;
}

bool __stdcall operator < (const CString& s1, const CString& s2)
{
	return (_tcscmp((LPCTSTR)s1, (LPCTSTR)s2) <0 );
}

bool __stdcall operator < (const CString& s1, LPCTSTR s2)
{
	return (_tcscmp((LPCTSTR)s1, s2) <0 );
}

bool __stdcall operator < (LPCTSTR s1, const CString& s2)
{
	return (_tcscmp(s1, (LPCTSTR)s2) <0 );
}

CString operator+(LPCTSTR lpsz, const CString& string)
{
	return CString(lpsz) + string;
}

void CString::Init()
{ 
	m_pchData = afxDataNil->data(); 
}

CStringData* CString::GetData() const
{ 
	if(m_pchData != NULL)
		return ((CStringData*)m_pchData)-1;
	return afxDataNil;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\baseexception.cpp ===
//
// MODULE: BaseException.CPP
//
// PURPOSE: standard exception handling classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 9-24-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-24-98	RAB
//

#include "stdafx.h"
#include "BaseException.h"
#include "fileread.h"
#include "CharConv.h"


////////////////////////////////////////////////////////////////////////////////////
// CBuildSrcFileLinenoStr
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CBuildSrcFileLinenoStr::CBuildSrcFileLinenoStr(	LPCSTR srcFile, int srcLineNo )
{
	// Reduce the source file name down the name and extension if possible.
	CString str;
	 
	CString tmp= CAbstractFileReader::GetJustName( CCharConversion::ConvertACharToString(srcFile, str) );
	CString strLineNo;

	strLineNo.Format( _T("-L%d"), srcLineNo );
	m_strFileLine= tmp + strLineNo;
}

CString CBuildSrcFileLinenoStr::GetSrcFileLineStr() const 
{
	// Return string that contains the source file name and the line number.
	return m_strFileLine;
}


////////////////////////////////////////////////////////////////////////////////////
// CBaseException
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CBaseException::CBaseException(	LPCSTR srcFile, int srcLineNo )
{
	CBuildSrcFileLinenoStr str( srcFile, srcLineNo );
	m_strFileLine= str.GetSrcFileLineStr();
}

CString CBaseException::GetSrcFileLineStr() const 
{
	// Return string that contains the source file name and the line number.
	return m_strFileLine;
}


////////////////////////////////////////////////////////////////////////////////////
// CGeneralException
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CGeneralException::CGeneralException(	LPCSTR srcFile, int srcLineNo, 
										LPCTSTR strErrMsg, DWORD nErrCode )
					: CBaseException( srcFile, srcLineNo ),
					  m_strErrMsg( strErrMsg ),
					  m_nErrCode( nErrCode )
{
}

DWORD CGeneralException::GetErrorCode() const 
{
	return m_nErrCode;
}

CString CGeneralException::GetErrorMsg() const 
{
	return m_strErrMsg;
}


////////////////////////////////////////////////////////////////////////////////////
// CGenSysException
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CGenSysException::CGenSysException(	LPCSTR srcFile, int srcLineNo, 
									LPCTSTR strErrMsg, DWORD nErrCode )
					: CGeneralException( srcFile, srcLineNo, strErrMsg, nErrCode )
{
	// Format the last system error code as a string.
	m_strSystemErr.Format( _T("%lu"), ::GetLastError() );
}

CString CGenSysException::GetSystemErrStr() const 
{
	return m_strSystemErr;
}


//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\baseexception.h ===
//
// MODULE: BaseException.
//
// PURPOSE: interface for CBaseException class.	
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 9-24-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-24-98		RAB     Broke class out of stateless.h and now derive from STL exception.
//

#ifndef __BASEEXCEPTION_H_
#define __BASEEXCEPTION_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsstr.h"
#include <exception>



////////////////////////////////////////////////////////////////////////////////////
// utility class to strip out the path of a filename and append the line number.
/////////////////////////////////////////////////////////////////////////////////////
class CBuildSrcFileLinenoStr
{
public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CBuildSrcFileLinenoStr( LPCSTR source_file, int line );
	virtual ~CBuildSrcFileLinenoStr() {}
	CString GetSrcFileLineStr() const; 

private:
	CString	m_strFileLine;	// source file (__FILE__) and line number (__LINE__) of code throwing exception (__FILE__)
};


////////////////////////////////////////////////////////////////////////////////////
// basic exception class
/////////////////////////////////////////////////////////////////////////////////////
class CBaseException : public exception
{
public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CBaseException( LPCSTR source_file, int line );
	virtual ~CBaseException() {}
	CString GetSrcFileLineStr() const; 

private:
	CString	m_strFileLine;	// source file (__FILE__) and line number (__LINE__) of code throwing exception (__FILE__)
};


////////////////////////////////////////////////////////////////////////////////////
// Class to handle general exception conditions.
// Constructor takes a source file name, source file line number, and a developer-defined
// error code and error message.
class CGeneralException : public CBaseException
{
public:
	enum eErr 
	{
		eErrMemAllocFatal,
		eErrMemAllocNonFatal
	} m_eErr;

public:
	CGeneralException(	LPCSTR srcFile,		// Source file from which the exception was thrown. 
						int srcLineNo,		// Source line from which the exception was thrown.
						LPCTSTR strErrMsg,	// Developer defined error message for the exception.
						DWORD nErrCode		// Developer defined error code for the exception. 
						);;
	virtual ~CGeneralException() {}
	DWORD	GetErrorCode() const; 
	CString GetErrorMsg() const; 

private:
	CString	m_strErrMsg;	// Developer-defined exception error message.
	DWORD	m_nErrCode;		// Developer-defined exception error code.
};
////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////
// Class to handle general system call generated exception conditions.
// Constructor takes a source file name, source file line number, and a developer-defined
// error code and error message.  Automatically generates an internal string from the last
// system error code.
class CGenSysException : public CGeneralException
{
public:
	CGenSysException(	LPCSTR srcFile,	// Source file from which the exception was thrown. 
											// LPCSTR rather than LPCTSTR because __FILE__ is char[35]
						int srcLineNo,		// Source line from which the exception was thrown.
						LPCTSTR strErrMsg,	// Developer defined error message for the exception.
						DWORD nErrCode		// Developer defined error code for the exception. 
						);
	virtual ~CGenSysException() {}
	CString GetSystemErrStr() const; 

private:
	CString	m_strSystemErr;	// String generated from the last system error code.
};
////////////////////////////////////////////////////////////////////////////////////


#endif 

//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\apgtsstr.h ===
//
// MODULE: APGTSSTR.H
//
// PURPOSE: header file for DLL Growable string object CString 
//	(pretty much a la MFC, but avoids all that MFC overhead)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel Joe Mabel (reworked code from Microsoft's MFC sources)
// 
// ORIGINAL DATE: 8-2-96 Roman Mach; totally re-implemented 1/15/99 Joe Mabel 
//
// NOTES: 
// 1. As of 1/99, re-implemented based on MFC's implementation.  Pared down
//	to what we use.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-24-98		JM		Abstracted this out as a separate header.
// V3.1		1-15-99		JM		Redo based on MFC implementation
//

#ifndef __APGTSSTR_H_
#define __APGTSSTR_H_ 1

#include <windows.h>
#include <tchar.h>

#include "apgtsassert.h"

// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))


struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};


class CString {
public:

// Constructors
	CString();
	CString(LPCTSTR string);
	CString(const CString &string);
	~CString();
	
// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	bool IsEmpty() const;

	TCHAR GetAt(int nIndex) const; // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	operator LPCTSTR() const;

	// overloaded assignment
	const CString& operator=(const CString &string);
	const CString& operator=(LPCTSTR string);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator=(LPCSTR lpsz);
#else  // !_UNICODE
    const CString& operator=(LPCWSTR lpsz);
#endif // !_UNICODE

	// string concatenation
	const CString& operator+=(const CString &string);
	const CString& operator+=(LPCTSTR string);

	CString operator+(const CString& string2);
	CString operator+(LPCTSTR lpsz);

	// string comparison
	int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware

	LPTSTR GetBuffer(int);
	void Empty();

	LPTSTR GetBufferSetLength(int nNewLength);
	void ReleaseBuffer(int nNewLength = -1);

	// simple sub-string extraction
	CString Mid(int Left, int Count) const;
	CString Mid(int Left) const;
	CString Left(int amount) const;
	CString Right(int amount) const;

	// upper/lower/reverse conversion
	void MakeLower();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;
	int Find(LPCTSTR lpszSub, int nStart) const;	// Added function - RAB19991112.
	int Find(TCHAR c) const;
	int ReverseFind(TCHAR ch) const;
	enum
	{
		// Define the code returned when a find is unsuccessful.
		FIND_FAILED= -1
	} ;

	// simple formatting
	void Format( LPCTSTR lpszFormat, ... );

	// load from resource
	BOOL LoadString(UINT nID);

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nL65en);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool __stdcall operator ==(const CString& s1, const CString& s2);
bool __stdcall operator ==(const CString& s1, LPCTSTR s2);
bool __stdcall operator ==(LPCTSTR s1, const CString& s2);

bool __stdcall operator !=(const CString& s1, const CString& s2);
bool __stdcall operator !=(const CString& s1, LPCTSTR s2);
bool __stdcall operator !=(LPCTSTR s1, const CString& s2);

bool __stdcall operator < (const CString& s1, const CString& s2);
bool __stdcall operator < (const CString& s1, LPCTSTR s2);
bool __stdcall operator < (LPCTSTR s1, const CString& s2);

CString operator+(LPCTSTR lpsz, const CString& string);

/////////////////////////////////////////////////////////////
// From Afx.inl
// These were all inlines, but some of them don't seem to happily work that way

inline CString::operator LPCTSTR() const
	{ return m_pchData; }

inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }

inline bool CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }

inline TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}

#endif // __APGTSSTR_H_ 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\bn.h ===
//
// MODULE: BN.h
//
// PURPOSE: interface for the CBeliefNetwork class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-31-98
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//---------------------------------------------------------------------
// V3.0		8-31-98		JM		
//

#if !defined(AFX_TOPIC_H__4ACF2F73_40EB_11D2_95EE_00C04FC22ADD__INCLUDED_)
#define AFX_TOPIC_H__4ACF2F73_40EB_11D2_95EE_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dscread.h"
#include "apgtscac.h"
#include "counter.h"

class CBeliefNetwork : public CDSCReader  
{
	struct SNodeType
	{
		NID Nid;
		ESTDLBL Type;
		SNodeType(NID nid, ESTDLBL type) : Nid(nid), Type(type) {}
	};

protected:
	bool m_bInitialized;
	vector<NID> m_arrnidProblem;		// NIDs of problem nodes; convenience array
	vector<SNodeType> m_arrNodeTypeAll;	// NIDs of all nodes; convenience array

	CCache	m_Cache;				// cache for this topic
	CHourlyDailyCounter m_countCacheHit;
	CHourlyDailyCounter m_countCacheMiss;
	bool m_bSnifferIntegration;		// This belief network is designed to integrate with a
									// sniffer.
private:
	CBeliefNetwork();				// do not instantiate
public:
	typedef enum {RS_OK, RS_Impossible, RS_Broken} eRecStatus;
	CBeliefNetwork(LPCTSTR path);
	virtual ~CBeliefNetwork();
	int CNode();
	int INode (LPCTSTR szNodeName);
	int GetRecommendations(
	   const CBasisForInference & BasisForInference, 
	   CRecommendations & Recommendations);
	int GetProblemArray(vector<NID>* &parrnid);
	int GetNodeArrayIncludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeInclude);
	int GetNodeArrayExcludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeExclude);
	CString GetNetPropItemStr(LPCTSTR szPropName);
	CString GetNodePropItemStr(NID nid, LPCTSTR szPropName, IST state = 0);
	bool GetNetPropItemNum(LPCTSTR szPropName, double& numOut);
	bool GetNodePropItemNum(NID nid, LPCTSTR szPropName, double& numOut, IST state = 0);
	CString GetNodeSymName(NID nid);
	CString GetNodeFullName(NID nid);
	CString GetStateName(NID nid, IST state);
	CString GetMultilineNetProp(LPCTSTR szPropName, LPCTSTR szFormat);
	CString GetMultilineNodeProp(NID nid, LPCTSTR szPropName, LPCTSTR szFormat);
	int GetCountOfStates(NID nid);
	bool IsValidNID(NID nid);
	bool IsCauseNode(NID nid);
	bool IsProblemNode(NID nid);
	bool IsInformationalNode(NID nid);
	bool UsesSniffer();

protected:
	void Initialize();
	BNTS * pBNTS();
	void ResetNodes(const CBasisForInference & BasisForInference);
	bool SetNodes(const CBasisForInference & BasisForInference);
};

#endif // !defined(AFX_TOPIC_H__4ACF2F73_40EB_11D2_95EE_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\bn.cpp ===
//
// MODULE: BN.cpp
//
// PURPOSE: implementation of the CBeliefNetwork class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-31-98
//
// NOTES: 
// 1. Based on old apgtsdtg.cpp
// 2. all methods (except constructor/destructor) must LOCKOBJECT around code that uses BNTS.
//	BNTS has "state".  These functions are all written so that they make no assumptions about
//	state on entry, presenting the calling class with a stateless object.
// 3. In theory, we could have separate locking for the cache independent of locking 
//	CBeliefNetwork.  The idea would be that if you needed only the cache to get your 
//	inference, you wouldn't have to wait for access to BNTS.  
//	>>>(ignore for V3.0) This is one of our best bets if performance is not good enough.  JM 9/29/98
//
// Version	Date		By		Comments
//---------------------------------------------------------------------
// V3.0		8-31-98		JM		
//

#include "stdafx.h"
#include "propnames.h"
#include "BN.h"
#include "CharConv.h"
#include "event.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#else
#include "fileread.h"
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBeliefNetwork::CBeliefNetwork(LPCTSTR path)
	:
	CDSCReader( CPhysicalFileReader::makeReader( path ) ),
	m_bInitialized(false),
	m_bSnifferIntegration(false)
{
}

CBeliefNetwork::~CBeliefNetwork()
{
}

void CBeliefNetwork::Initialize()
{
	LOCKOBJECT();
	if (! m_bInitialized)
	{
		BNTS * pbnts = pBNTS();
		if (pbnts)
		{
			m_bSnifferIntegration = false;

			///////////////////////////////////////////////////////////////////
			// Does not matter for online TS (list is empty on initialization),
			//  but for local TS m_Cache can contain cache data read from file.
			//m_Cache.Clear();
			///////////////////////////////////////////////////////////////////

			m_arrnidProblem.clear();
			m_arrNodeTypeAll.clear();

			// loop through nodes looking for problem nodes and build local problem node array
			// also, determine if any node has a property which implies the intent of 
			//	integrating with a sniffer.
			int acnid= CNode();
			for (NID anid=0; anid < acnid; anid++) 
			{
				if (pbnts->BNodeSetCurrent(anid))
				{
					ESTDLBL albl = pbnts->ELblNode();	// type of node (information/problem/fixable etc)

					try
					{
						if (albl == ESTDLBL_problem)
							m_arrnidProblem.push_back(anid);
						m_arrNodeTypeAll.push_back(SNodeType(anid, albl));
					}
					catch (exception& x)
					{
						CString str;
						// Note STL exception in event log.
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												CCharConversion::ConvertACharToString(x.what(), str), 
												_T(""), 
												EV_GTS_STL_EXCEPTION ); 
					}


#ifdef LOCAL_TROUBLESHOOTER
					LPCTSTR psz;
					if (pbnts->BNodePropItemStr(H_NODE_DCT_STR, 0) 
					&& (psz = pbnts->SzcResult()) != NULL
					&& *psz)
					{
						// There's a non-null property which only makes sense for a sniffer 
						// integration, so we assume that's what they've got in mind.
						m_bSnifferIntegration = true;
					}
#endif
				}
			}
			m_bInitialized = true;
		}
	}
	UNLOCKOBJECT();
}

// Access the relevant BNTS
// Calling function should have a lock before calling this (although probably harmless
//	is it doesn't!)
BNTS * CBeliefNetwork::pBNTS() 
{
	if (!IsRead())
		return NULL;
	return &m_Network;
};

// clear all node states
// We can't use BNTS::Clear() because that actually throws away the model itself.
void CBeliefNetwork::ResetNodes(const CBasisForInference & BasisForInference)
{
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
	{
		int cnid = BasisForInference.size();

		// Set all node states to NIL in BNTS storage
		for (UINT i = 0; i < cnid; i++) 
		{
			pbnts->BNodeSetCurrent(BasisForInference[i].nid());
			pbnts->BNodeSet(-1, false);	// Nil value
		}
	}
	UNLOCKOBJECT();
}

// Associate states with nodes.
// INPUT BasisForInference
// Note that all states must be valid states for the nodes, not (say) ST_UNKNOWN.  
//	Caller's responsibility.
bool CBeliefNetwork::SetNodes(const CBasisForInference & BasisForInference)
{
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	bool bOK = true;
	if (pbnts)
	{
		int nNodes = BasisForInference.size();
		for (int i= 0; i<nNodes; i++)
		{
			pbnts->BNodeSetCurrent(BasisForInference[i].nid());
			if (!pbnts->BNodeSet(BasisForInference[i].state(), false))
				bOK = false;	// failed to set state.  This should never happen on valid
								// user query.
		}
	}
	UNLOCKOBJECT();
	return bOK;
}

// OUTPUT Recommendations: list of recommendations
// RETURN:
// RS_OK = SUCCESS.  Note that Recommendations can return empty if there is nothing to recommend.
// RS_Impossible = Recommendations will return empty.
// RS_Broken = Recommendations will return empty.
int CBeliefNetwork::GetRecommendations(
	   const CBasisForInference & BasisForInference, 
	   CRecommendations & Recommendations)
{
	int ret = RS_OK;

	LOCKOBJECT();
	Initialize();
	Recommendations.clear();

	// see if we've already cached a result for this state of the world
	if (m_Cache.FindCacheItem(BasisForInference, Recommendations))
	{
		// Great.  We have a cache hit & return values have been filled in.
		m_countCacheHit.Increment();
	}
	else
	{
		m_countCacheMiss.Increment();

		BNTS * pbnts = pBNTS();
		if (pbnts)
		{
			SetNodes(BasisForInference);

			if (pbnts->BImpossible())
				ret = RS_Impossible;
			else if ( ! pbnts->BGetRecommendations())
				ret = RS_Broken;
			else
			{
				try
				{
					const int cnid = pbnts->CInt(); // Recommendation count
					if (cnid > 0)
					{
						// At least one recommendation
						const int *pInt = pbnts->RgInt();
						for (int i=0; i<cnid; i++)
							Recommendations.push_back(pInt[i]);
					}

					// We've got our return values together, but before we return, cache them.
					m_Cache.AddCacheItem(BasisForInference, Recommendations);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}

			ResetNodes(BasisForInference);
		}
	}


	UNLOCKOBJECT();
	return ret;
}

// return the number of nodes in the model
int CBeliefNetwork::CNode ()
{
	int ret = 0;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
		ret = pbnts->CNode();

	UNLOCKOBJECT();
	return ret;
}

//  Return the index of a node given its symbolic name
int CBeliefNetwork::INode (LPCTSTR szNodeName)
{
	int ret = -1;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
		ret = pbnts->INode(szNodeName);

	UNLOCKOBJECT();
	return ret;
}

// OUTPUT *parrnid - refernce to array of NIDs of all problem nodes
// RETURN number of values in *parrnid
int CBeliefNetwork::GetProblemArray(vector<NID>* &parrnid)
{
	int ret = 0;
	LOCKOBJECT();
	Initialize();
	parrnid = &m_arrnidProblem;
	ret = m_arrnidProblem.size();
	UNLOCKOBJECT();
	return ret;
}

// OUTPUT arrOut - refernce to array of NIDs of all nodes, that have type listed in arrTypeInclude
// RETURN number of values in arrOut
int CBeliefNetwork::GetNodeArrayIncludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeInclude)
{
	int ret = 0;
	LOCKOBJECT();
	arrOut.clear();
	Initialize();
	for (vector<SNodeType>::iterator i = m_arrNodeTypeAll.begin(); i < m_arrNodeTypeAll.end(); i++)
	{
		for (vector<ESTDLBL>::const_iterator j = arrTypeInclude.begin(); j < arrTypeInclude.end(); j++)
			if (i->Type == *j)
				break;

		if (j != arrTypeInclude.end())
			arrOut.push_back(i->Nid);
	}
	ret = arrOut.size();
	UNLOCKOBJECT();
	return ret;
}

// OUTPUT arrOut - refernce to array of NIDs of all nodes, that do NOT have type listed in arrTypeExclude
// RETURN number of values in arrOut
int CBeliefNetwork::GetNodeArrayExcludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeExclude)
{
	int ret = 0;
	LOCKOBJECT();
	arrOut.clear();
	Initialize();
	for (vector<SNodeType>::iterator i = m_arrNodeTypeAll.begin(); i < m_arrNodeTypeAll.end(); i++)
	{
		for (vector<ESTDLBL>::const_iterator j = arrTypeExclude.begin(); j < arrTypeExclude.end(); j++)
			if (i->Type == *j)
				break;

		if (j == arrTypeExclude.end())
			arrOut.push_back(i->Nid);
	}
	ret = arrOut.size();
	UNLOCKOBJECT();
	return ret;
}

// ----------------------------------------
// simple properties
// ----------------------------------------

// return a STRING property of the net
CString CBeliefNetwork::GetNetPropItemStr(LPCTSTR szPropName)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (!pbnts)
		return CString(_T(""));

	if (pbnts->BNetPropItemStr(szPropName, 0))
		strRet = pbnts->SzcResult();
	UNLOCKOBJECT();
	return strRet;
}

// return a REAL property of the net
bool CBeliefNetwork::GetNetPropItemNum(LPCTSTR szPropName, double& numOut)
{
	bool bRet = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (!pbnts)
		return false;

	bRet = pbnts->BNetPropItemReal(szPropName, 0, numOut) ? true : false;
	UNLOCKOBJECT();
	return bRet;
}

// return a STRING property of a node or state
// For most properties, state is irrelevant, and default of 0 is the appropriate input.
// However, if there are per-state values, passing in the appropriate state number
//	will get you the appropriate value.
CString CBeliefNetwork::GetNodePropItemStr(NID nid, LPCTSTR szPropName, IST state /*= 0 */)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		if (pbnts->BNodePropItemStr(szPropName, state))
			strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}

// $MAINT - This function is not currently used in any of the troubleshooters.  RAB-19991103.
// return a REAL property of a node or state
// For most properties, state is irrelevant, and default of 0 is the appropriate input.
// However, if there are per-state values, passing in the appropriate state number
//	will get you the appropriate value.
bool CBeliefNetwork::GetNodePropItemNum(NID nid, LPCTSTR szPropName, double& numOut, IST state /*= 0*/)
{
	bool bRet = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		bRet = pbnts->BNodePropItemReal(szPropName, state, numOut) ? true : false;
	}
	UNLOCKOBJECT();
	return bRet;
}

CString CBeliefNetwork::GetNodeSymName(NID nid)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		pbnts->NodeSymName();
		strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}

CString CBeliefNetwork::GetNodeFullName(NID nid)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		pbnts->NodeFullName();
		strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}

CString CBeliefNetwork::GetStateName(NID nid, IST state)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		pbnts->NodeStateName(state);
		strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}


// ----------------------------------------
// "multiline" properties
//	these date back to when there was a 255-byte limit on STRING and longer strings
//	had to be represented by ARRAY OF STRING, later concatenated.
//	Backward compatibility still needed.
// ----------------------------------------

// Append a NET property (for Belief Network as a whole, not for one 
//	particular node) to str.
// INPUT szPropName - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
CString CBeliefNetwork::GetMultilineNetProp(LPCTSTR szPropName, LPCTSTR szFormat)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
	{
		CString strTxt;

		for (int i = 0; pbnts->BNetPropItemStr(szPropName, i); i++)
		{
			strTxt.Format( szFormat, pbnts->SzcResult());
			strRet += strTxt;
		}
	}
	UNLOCKOBJECT();
	return strRet;
}

// Like GetMultilineNetProp, but for a NODE property item, for one particular node.
// INPUT/OUTPUT str - string to append to
// INPUT item - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
CString CBeliefNetwork::GetMultilineNodeProp(NID nid, LPCTSTR szPropName, LPCTSTR szFormat)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		CString strTxt;

		for (int i = 0; pbnts->BNodePropItemStr(szPropName, i); i++)
		{
			strTxt.Format( szFormat, pbnts->SzcResult());
			strRet += strTxt;
		}
	}
	UNLOCKOBJECT();
	return strRet;
}

int CBeliefNetwork::GetCountOfStates(NID nid)
{
	int ret = 0;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
		ret = pbnts->INodeCst();
	UNLOCKOBJECT();
	return ret;
}

// returns true only for NIDs valid in the context of an abstract belief network.
// Doesn't know about troubleshooter-specific stuff like nidService.
bool CBeliefNetwork::IsValidNID(NID nid)
{
	return ( nid < CNode() );
}

bool CBeliefNetwork::IsCauseNode(NID nid)
{
	bool ret = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		ESTDLBL lbl = pbnts->ELblNode();
		ret= (lbl == ESTDLBL_fixobs || lbl == ESTDLBL_fixunobs || lbl == ESTDLBL_unfix);
	}
	UNLOCKOBJECT();
	return ret;
}

bool CBeliefNetwork::IsProblemNode(NID nid)
{
	bool ret = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		ret= (pbnts->ELblNode() == ESTDLBL_problem);
	}
	UNLOCKOBJECT();
	return ret;
}

bool CBeliefNetwork::IsInformationalNode(NID nid)
{
	bool ret = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		ret= (pbnts->ELblNode() == ESTDLBL_info);
	}
	UNLOCKOBJECT();
	return ret;
}

bool CBeliefNetwork::UsesSniffer()
{
	bool ret = false;
	LOCKOBJECT();
	Initialize();
	ret = m_bSnifferIntegration;
	UNLOCKOBJECT();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\charconv.cpp ===
//
// MODULE: CharConv.CPP
//
// PURPOSE: conversion between char & TCHAR
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 
//
// NOTES: 
// 1. ConvertWCharToString pulled out of VersionInfo.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0				    JM
//

#include "stdafx.h"
#include "CharConv.h"

// Convert Unicode ("wide character") to CString, regardless of whether this
//	program is built Unicode.  How this program is built determines the
//	underlying character type of CString.
// As a convenience, returns a refernce to strRetVal
/*static*/ CString& CCharConversion::ConvertWCharToString(LPCWSTR wsz, CString &strRetVal)
{
#ifdef UNICODE
	strRetVal = wsz;
#else
	TCHAR * pBuf;
	int bufsize = ::WideCharToMultiByte( 
						  CP_ACP, 
						  0, 	  
						  wsz, 
						  -1, 
						  NULL, 
						  0, 
						  NULL, 
						  NULL 
						 );
	pBuf = new TCHAR[bufsize];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(pBuf)
	{
		::WideCharToMultiByte( 
							  CP_ACP, 
							  0, 	  
							  wsz, 
							  -1, 
							  pBuf, 
							  bufsize, 
							  NULL, 
							  NULL 
							 );

		strRetVal = pBuf;
		delete[] pBuf;
	}

#endif
	return strRetVal;
}

// Convert char* (ASCII/ANSI, not "wide" character) to CString, regardless of whether this
//	program is built Unicode.  How this program is built determines the
//	underlying character type of CString.
// As a convenience, returns a refernce to strRetVal
/*static*/ CString& CCharConversion::ConvertACharToString(LPCSTR sz, CString &strRetVal)
{
#ifdef UNICODE
	TCHAR * pBuf;
	int bufsize = ::MultiByteToWideChar( 
						  CP_ACP, 
						  0, 	  
						  sz, 
						  -1, 
						  NULL, 
						  0
						 );
	pBuf = new TCHAR[bufsize];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(pBuf)
	{
		::MultiByteToWideChar( 
							  CP_ACP, 
							  0, 	  
							  sz, 
							  -1, 
							  pBuf, 
							  bufsize
							 );

		strRetVal = pBuf;
		delete[] pBuf;
	}

#else
	strRetVal = sz;
#endif
	return strRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\bnts.h ===
//
//	bnts.h:  Definitions for the Belief Network Troubleshooting object.
//
#ifndef _BNTS_H_
#define _BNTS_H_

//  BN system inclusions
#include "enumstd.h"		// Standard enumeration declarations for the BN system

// 'BNTS_EXPORT' should only be defined in the project that builds the DLL
#ifdef	BNTS_EXPORT
	//  We're building the DLL (exporting the class)
	#define	BNTS_RESIDENT __declspec(dllexport)
#else
	//  We're using the DLL (importing the class)
	#define	BNTS_RESIDENT __declspec(dllimport)
#endif

//  Forward declaration of internal belief network class
class MBNETDSCTS;										//  the encapsulated BN class
class GNODEMBND;										//  Discrete nodes
class LTBNPROP;											//  Property list
class ZSTR;

typedef const char * SZC;								//  simple alias
typedef char * SZ;
typedef double REAL;

////////////////////////////////////////////////////////////////////////////////////////////
//
//	class BNTS: the belief network troubleshooter
//
////////////////////////////////////////////////////////////////////////////////////////////
class BNTS_RESIDENT BNTS
{	
  public:
	//  CTOR and DTOR
	BNTS ();
	~ BNTS ();

	////////////////////////////////////////////////////////////////////
	//  Model-level queries and functions
	////////////////////////////////////////////////////////////////////
		//  Load and process a DSC-based model
	BOOL BReadModel ( SZC szcFn, SZC szcFnError = NULL );
		//  Return the number of (pre-expansion) nodes in the model
	int CNode ();
		//  Return the recommended nodes and, optionally, their values
	BOOL BGetRecommendations ();
		//  Return TRUE if the state of information is impossible
	BOOL BImpossible ();
		//  Return a property item string from the network
	BOOL BNetPropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the network
	BOOL BNetPropItemReal ( SZC szcPropType, int index, double & dbl );

	////////////////////////////////////////////////////////////////////
	//  Operations involving the "Currrent Node": call NodeSetCurrent()
	////////////////////////////////////////////////////////////////////
		//  Set the current node for other calls
	BOOL BNodeSetCurrent( int inode );
		//	Get the current node
	int INodeCurrent ();
		//  Return the index of a node given its symbolic name
	int INode ( SZC szcNodeSymName );	
		//	Return the label of the current node
	ESTDLBL ELblNode ();
		//  Return the number of discrete states in the current node
	int INodeCst ();
		//  Set the state of a node; use -1 to uninstatiate
	BOOL BNodeSet ( int istate, bool bSet = true );
		//  Return the state of a node
	int  INodeState ();
		//	Return the name of a node's state
	void NodeStateName ( int istate );
		//  Return the symbolic name of the node
	void NodeSymName ();
		//  Return the full name of the node
	void NodeFullName ();
		//  Return a property item string from the node
	BOOL BNodePropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the node
	BOOL BNodePropItemReal ( SZC szcPropType, int index, double & dbl );
		//  Return the belief for a node
	void NodeBelief ();
		//  Return true if the network is loaded and correct
	bool BValidNet () const;
		//  Return true if the current node is set
	bool BValidNode () const;
		//  Discard the model and all components
	void Clear();

	////////////////////////////////////////////////////////////////////
	//  Accessors to the function result information	
	////////////////////////////////////////////////////////////////////
	SZC SzcResult () const;					//  String answer		
	const REAL * RgReal () const;			//  Array of reals		
	const int * RgInt () const;				//  Array of Integers	
	int CReal () const;						//  Count of reals		
	int CInt () const;						//  Count of integers

  protected:
	MBNETDSCTS * _pmbnet;			//  The T/S DSC belief network
	int _inodeCurrent;				//  The current node

  protected:
	MBNETDSCTS & Mbnet();
	const MBNETDSCTS & Mbnet() const;
	GNODEMBND * Pgndd ();
	BOOL BGetPropItemStr ( LTBNPROP & ltprop, 
						   SZC szcPropType, 
						   int index, 
						   ZSTR & zstr );
	BOOL BGetPropItemReal ( LTBNPROP & ltprop, 
							SZC szcPropType, 
							int index, 
							double & dbl );
	void ClearArrays ();
	void ClearString ();
	ZSTR & ZstrResult ();
};

#endif // _BNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\charconv.h ===
// CharConv.h: interface for the CCharConversion class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHARCONV_H__067972E5_6CFE_11D2_9615_00C04FC22ADD__INCLUDED_)
#define AFX_CHARCONV_H__067972E5_6CFE_11D2_9615_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "apgtsstr.h"

class CCharConversion  
{
public:
	static CString& ConvertWCharToString(LPCWSTR wsz, CString &strRetVal);
	static CString& ConvertACharToString(LPCSTR sz, CString &strRetVal);
};

#endif // !defined(AFX_CHARCONV_H__067972E5_6CFE_11D2_9615_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\commonregconnect.h ===
//
// MODULE: CommonREGCONNECT.H
//
// PURPOSE: read - write to the registry; common declarations for Online TS and Local TS, 
//	which differ on many functions of this class
//	
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 8-24-98 in Online TS.  This file abstracted 1-19-98
//
// NOTES: 
//	1. This file should be included only in the .cpp files that instantiate CAPGTSRegConnector
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-19-98	JM		branch out version exclusively for Local TS

#ifndef _INCLUDE_COMMONREGCONNECT_H_ 
#define _INCLUDE_COMMONREGCONNECT_H_ 

// registry value names
//
#define FULLRESOURCE_STR			_T("FullPathToResource")
#define VROOTPATH_STR				_T("VrootPathToDLL")
#define MAX_THREADS_STR				_T("MaximumThreads")
#define THREADS_PER_PROCESSOR_STR	_T("ThreadsPerProcessor")
#define MAX_WORK_QUEUE_ITEMS_STR	_T("MaximumWorkQueueItems")
#define COOKIE_LIFE_IN_MINS_STR		_T("HTTPCookieExpirationInMins")
#define RELOAD_DELAY_STR			_T("RefreshDelay")
#define DETAILED_EVENT_LOGGING_STR	_T("DetailedEventLogging")
#define LOG_FILE_DIR_STR			_T("LogFileDirectory")
#define SNIFF_AUTOMATIC_STR			_T("AutomaticSniffing")
#define SNIFF_MANUAL_STR			_T("ManualSniffing")


#endif //_INCLUDE_COMMONREGCONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\chmfilereader.h ===
//
// MODULE: CHMFileReader.CPP
//
// PURPOSE: interface for CHM file reading class CCHMFileReader
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-18-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM
//

#if !defined(AFX_CHMFILEREADER_H__1A2C05D6_AEFC_11D2_9658_00C04FC22ADD__INCLUDED_)
#define AFX_CHMFILEREADER_H__1A2C05D6_AEFC_11D2_9658_00C04FC22ADD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "fileread.h"

class CFileSystem;
class CSubFileSystem;

class CCHMFileReader : public CPhysicalFileReader  
{
private:
	CString m_strCHMPath;		// full path and name of CHM
	CString m_strStreamName;	// name of stream within CHM
	CFileSystem*    m_pFileSystem;
	CSubFileSystem* m_pSubFileSystem;

private:
	CCHMFileReader();			// do not instantiate

public:
	CCHMFileReader(CString strCHMPath, CString strStreamName);
	CCHMFileReader( CString strFullCHMname );
	virtual ~CCHMFileReader();

protected:
	// only CFileReader can access these functions !!!
	virtual bool CloseHandle();  // doesn't throw exception, therefore may be used by exception class.
	virtual void Open();
	virtual void ReadData(LPTSTR * ppBuf);

public:
	// return full file path and its components
	CString GetPathName() const;
	CString GetJustPath() const {return m_strCHMPath;}
	CString GetJustName() const {return m_strStreamName;}
	CString GetJustNameWithoutExtension() const;
	CString GetJustExtension() const;
	bool    GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const;
	CString GetNameToLog() const;

	static bool IsCHMfile( const CString& strPath );	// Returns true if the first few
														// characters of the path specification
														// match a given sequence.
	static bool IsPathToCHMfile( const CString& strPath ); // returns true if this is
														   //  a full path to a CHM file
	static CString FormCHMPath( const CString strPathToCHMfile ); // forms mk:@msitstore:path::/stream
																  //  string
};

#endif // !defined(AFX_CHMFILEREADER_H__1A2C05D6_AEFC_11D2_9658_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\counter.h ===
//
// MODULE: COUNTER.H
//
// PURPOSE: interface for the counter classes: 
//		CPeriodicTotals (utility class)
//		CAbstractCounter (abstract base class).
//		CCounter (simple counter)
//		CHourlyCounter (counter with "bins" for each hour of the day)
//		CDailyCounter (counter with "bins" for day of the week)
//		CHourlyDailyCounter (counter with "bins" for each hour of the day and each day of the week)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// MODIFIED: Oleg Kalosha 10-20-98
// 
// ORIGINAL DATE: 7-20-1998
//
// NOTES: 
// 1. CPeriodicTotals might better be implemented using STL vectors.  We wrote this 
//	before we really started bringing STL into this application. JM 10/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-20-98		JM		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COUNTER_H__07B5ABBD_2005_11D2_95D0_00C04FC22ADD__INCLUDED_)
#define AFX_COUNTER_H__07B5ABBD_2005_11D2_95D0_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <time.h>
#include "apgtsstr.h"

////////////////////////////////////////////////////////////////////////////////////
// a utility class to allow the expression of a series of time periods & associated counts
////////////////////////////////////////////////////////////////////////////////////
class CPeriodicTotals
{
public:
	CPeriodicTotals(long nPeriods);
	virtual ~CPeriodicTotals();

	void Reset();
	bool SetNext(time_t time, long Count);
private:
	void ReleaseMem();
protected:
	CString & DisplayPeriod(long i, CString & str) const;
public:
	virtual CString HTMLDisplay() const = 0;
protected:
	long m_nPeriods;		// number of periods, based on initialization in constructor.
							// typically 25 (hours in a day + 1) or 8 (days in a week + 1)
	long m_nPeriodsSet;		// number of periods for which we have data filled in.
	long m_iPeriod;			// index. 0 <= m_iPeriod < m_nPeriodsSet.  Zeroed by InitEnum,
							//	incremented by GetNext or SetNext.
	time_t *m_ptime;		// points to array of times: start time of relevant time period
							//	(typically beginning of a clock hour or calendar day).
	long *m_pCount;			// points to array totals, each the total for correspondingly
							//	indexed time period
};

////////////////////////////////////////////////////////////////////////////////////
// CHourlyTotals class declaration
//	CHourlyTotals intended for displaying hourly totals
////////////////////////////////////////////////////////////////////////////////////
class CHourlyTotals : public CPeriodicTotals
{
public:
	CHourlyTotals();
	~CHourlyTotals();
	virtual CString HTMLDisplay() const;
};

////////////////////////////////////////////////////////////////////////////////////
// CDailyTotals class declaration
//	CDailyTotals intended for displaying dayly totals
////////////////////////////////////////////////////////////////////////////////////
class CDailyTotals : public CPeriodicTotals
{
public:
	CDailyTotals();
	~CDailyTotals();
	virtual CString HTMLDisplay() const;
};

////////////////////////////////////////////////////////////////////////////////////
// CCounterLocation class declaration
//  CCounterLocation is a mean to identify counter within the global counter pool
////////////////////////////////////////////////////////////////////////////////////
class CCounterLocation
{
public:
	// prefixes for scope names
	static LPCTSTR m_GlobalStr;
	static LPCTSTR m_TopicStr;
	static LPCTSTR m_ThreadStr;

	// counter IDs 
	enum EId {
			eIdGeneric,
		
			// counters that are realized
			eIdProgramContemporary,
			eIdStatusAccess,
			eIdActionAccess,
			eIdTotalAccessStart,
			eIdTotalAccessFinish,
			eIdRequestUnknown,
			eIdRequestRejected,
			eIdErrorLogged,
			
			// status information that I see as counters.
			//  Oleg 10-20-98
			eIdWorkingThread,
			eIdQueueItem,
			eIdProgressItem,

			// status information that I think can be emulated as counters
			//	Oleg 10-21-98
			eIdKnownTopic,
			eIdTopicNotTriedLoad,
			eIdTopicFailedLoad,

			// topic - bound counters
			eIdTopicLoad,
			eIdTopicLoadOK,
			eIdTopicEvent,
			eIdTopicHit,
			eIdTopicHitNewCookie,
			eIdTopicHitOldCookie,
	};

private:
	const CString m_Scope;   // scope where the counter is used (i.e. "Topic start", "Thread 1" and so on)
	EId     m_Id;			 // identifier of the counter within the scope

public:
    CCounterLocation(EId id, LPCTSTR scope =m_GlobalStr);
	virtual ~CCounterLocation();

public:
	bool operator == (const CCounterLocation& sib) {return m_Scope == sib.m_Scope && m_Id == sib.m_Id;}

public:
	CString GetScope() {return m_Scope;}
	EId     GetId()    {return m_Id;}
};

////////////////////////////////////////////////////////////////////////////////////
// CAbstractCounter class declaration
//	CAbstractCounter* are saved in counter pool
////////////////////////////////////////////////////////////////////////////////////
// >>>(probably ignore for V3.0) There has been some disagreement over whether it is 
//	appropriate for CAbstractCounter to inherit from CCounterLocation.
// JM says (10/29/98): 
//	This seems to me to be the same type of thinking as when pointers to the previous and
//	next item are made part of a class that someone intends to put in a doubly linked list.
//	They are NOT inherent to the class.  They ought instead to be part of some other class
//	that manages CAbstractCounters.
// Oleg replies (11/2/98)
//	Since all counters are elements of a global pool, we have somehow to identify them
//	 in this pool. If the way, we are identifying counters, changes (from name - id to 
//	 name1 - name2 - id for example), we change only CCounterLocation part of counter classes. 
//	I see no reasons to make CCounterLocation an instance in counter class:
//	 1. we definitely have only one CCounterLocation per counter
//	 2. in case if inheritance we do not need additional interface for accessing CCounterLocation
// JM follows this up (11/5/98): 
//	There is nothing wrong with this approach as such. There is, however, an issue of design
//	philosophy that at some point we should address.  For the most part, we follow the style
//	of STL.  Classes are normally designed with no regard to the fact that they will be 
//	contained in a collection.  Here, the counter class knows about the enumeration type 
//	used to identify counters.  This is sort of as if the values in an STL map had to know
//	about the keys mapped to those values.
//	I would have designed CCounterMgr as an "object factory", providing a means to 
//	manufacture named counters much as Win32 manufactures named synchronization primitives 
//	(e.g. a named Mutex or Semaphore).  To indicate that an event has occurred, you would 
//	increment a named counter; for status reporting, you would ask for values of that 
//	named counter.  (In theory, the "names" might either be text or numbers.  The scheme
//	would have to allow for some means of manufacturing several distinct counters for
//	each topic in the catalog.)
class CAbstractCounter : public CCounterLocation
{
protected:  // we do not get instances of this class (evermore this is an abstract class)
    CAbstractCounter(EId id =eIdGeneric, CString scope =m_GlobalStr);
	virtual ~CAbstractCounter();

public:
	virtual void Increment() = 0;
	virtual void Clear() = 0;
	virtual void Init(long count) = 0; // init counter with a number - in order to emulate
									   //  counting process
};

////////////////////////////////////////////////////////////////////////////////////
// CCounter class declaration
//  A simple counter
////////////////////////////////////////////////////////////////////////////////////
class CCounter : public CAbstractCounter
{
public:
	CCounter(EId id =eIdGeneric, CString scope =m_GlobalStr);
	~CCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long Get() const;

private:
	long m_Count;
};

////////////////////////////////////////////////////////////////////////////////////
// CHourlyCounter class declaration
//  CHourlyCounter is not supposed to be instantiated by user
////////////////////////////////////////////////////////////////////////////////////
class CHourlyCounter : public CAbstractCounter
{
	friend class CHourlyDailyCounter;
protected:
	CHourlyCounter();
public:
	~CHourlyCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long GetDayCount();
	void GetHourlies(CHourlyTotals & totals);
private:
	void SetHour();

private:
	long m_ThisHour;			// hour of the day, 0-24.  -1 means uninitialized.
	time_t m_ThisTime;			// time corresponding to START of hour.

	CCounter m_arrCount[24];		// 24 "bins", one for each hour of the day.
	long m_nThisHourYesterday;	// maintains a whole hour count for the hour 24 hours ago.

	HANDLE m_hMutex;
};

////////////////////////////////////////////////////////////////////////////////////
// CDailyCounter class declaration
//  CDailyCounter is not supposed to be instantiated by user
////////////////////////////////////////////////////////////////////////////////////
class CDailyCounter : public CAbstractCounter
{
	friend class CHourlyDailyCounter;
protected:
	CDailyCounter();
public:
	~CDailyCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long GetWeekCount();
	void GetDailies(CDailyTotals & totals);
private:
	void SetDay();

private:
	long m_ThisDay;				// day of the week, 0(Sunday)-6(Saturday).  -1 means uninitialized.
	time_t m_ThisTime;			// time corresponding to START of day.

	CCounter m_arrCount[7];		// 7 "bins", one for each day of the week.
	long m_nThisDayLastWeek;	// maintains a whole day count for the same day last week.

	HANDLE m_hMutex;
};

////////////////////////////////////////////////////////////////////////////////////
// CHourlyDailyCounter class declaration
//  CHourlyDailyCounter is an ONLY class used for counting events
////////////////////////////////////////////////////////////////////////////////////
class CHourlyDailyCounter : public CAbstractCounter
{
public:
	CHourlyDailyCounter(EId id =eIdGeneric, CString scope =m_GlobalStr);
	~CHourlyDailyCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long GetDayCount();
	void GetHourlies(CHourlyTotals & totals);
	long GetWeekCount();
	void GetDailies(CDailyTotals & totals);
	long GetTotal() const;
	time_t GetTimeFirst() const;
	time_t GetTimeLast() const;
	time_t GetTimeCleared() const;
	time_t GetTimeCreated() const;
	time_t GetTimeNow() const;    // time the object is being questioned

private:
	CHourlyCounter m_hourly;
	CDailyCounter m_daily;

	long m_Total;			// total since system startup or count cleared
	time_t m_timeFirst;		// chronologically first time count was incremented
	time_t m_timeLast;		// chronologically last time count was incremented
	time_t m_timeCleared;	// last time init'd or cleared
	time_t m_timeCreated;	// time the object was instantiated

	HANDLE m_hMutex;
};

////////////////////////////////////////////////////////////////////////////////////
// DisplayCounter classes
////////////////////////////////////////////////////////////////////////////////////
class CAbstractDisplayCounter
{
protected:
	CAbstractCounter* m_pAbstractCounter;

public:
	CAbstractDisplayCounter(CAbstractCounter* counter) : m_pAbstractCounter(counter) {}
	virtual ~CAbstractDisplayCounter() {}

public:
	virtual CString Display() = 0;
};

class CDisplayCounterTotal : public CAbstractDisplayCounter
{
public:
	CDisplayCounterTotal(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterTotal() {}

public:
	virtual CString Display();
};

class CDisplayCounterCurrentDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterCurrentDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterCurrentDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterCreateDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterCreateDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterCreateDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterFirstDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterFirstDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterFirstDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterLastDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterLastDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterLastDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterDailyHourly : public CAbstractDisplayCounter
{
protected:
	CDailyTotals*  m_pDailyTotals;
	CHourlyTotals* m_pHourlyTotals;

public:
	CDisplayCounterDailyHourly(CHourlyDailyCounter* counter,
							   CDailyTotals* daily,
							   CHourlyTotals* hourly) 
	:	CAbstractDisplayCounter(counter),
		m_pDailyTotals(daily),
		m_pHourlyTotals(hourly)
		{}
   ~CDisplayCounterDailyHourly() {}

public:
	virtual CString Display();
};

#endif // !defined(AFX_COUNTER_H__07B5ABBD_2005_11D2_95D0_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\chmfilereader.cpp ===
//
// MODULE: CHMFileReader.CPP
//
// PURPOSE: implement CHM file reading class CCHMFileReader
//
// PROJECT: for Local Troubleshooter; not needed in Online TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-18-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM
//

#include "stdafx.h"
#include "fs.h"
#include "CHMFileReader.h"

// Utilize an unnamed namespace to limit scope to this source file
namespace
{ 
const CString kstr_CHMfileExtension=_T("chm");
const CString kstr_CHMpathMarker=	_T("mk:@msitstore:");
const CString kstr_CHMstreamMarker=	_T("::/");
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCHMFileReader::CCHMFileReader(CString strCHMPath, CString strStreamName)
	: m_strCHMPath(strCHMPath),
	  m_strStreamName(strStreamName),
	  m_pFileSystem(NULL),
	  m_pSubFileSystem(NULL)
{
}

CCHMFileReader::CCHMFileReader( CString strFullCHMname )
	: m_pFileSystem(NULL),
	  m_pSubFileSystem(NULL)
{
	int nPosPathMarker, nPosStreamMarker;

	nPosPathMarker= strFullCHMname.Find( kstr_CHMpathMarker );
	nPosStreamMarker= strFullCHMname.Find( kstr_CHMstreamMarker );
	if ((nPosPathMarker == -1) || (nPosStreamMarker == -1))
	{
		// >>>	Need to think about how to handle this condition or whether we should
		//		be checking for a 'valid' CHM path outside of a constructor.  RAB-19990120.
	}
	else
	{
		// Extract the path and string names (bounds checking is handled by the CString class).
		nPosPathMarker+= kstr_CHMpathMarker.GetLength();
		m_strCHMPath= strFullCHMname.Mid( nPosPathMarker, nPosStreamMarker - nPosPathMarker ); 
		nPosStreamMarker+= kstr_CHMstreamMarker.GetLength();
		m_strStreamName= strFullCHMname.Mid( nPosStreamMarker ); 
	}
}

CCHMFileReader::~CCHMFileReader()
{
	if (m_pSubFileSystem)
		delete m_pSubFileSystem;
	if (m_pFileSystem)
		delete m_pFileSystem;
}

// doesn't throw exception, therefore may be used by exception class.
bool CCHMFileReader::CloseHandle()
{
	if (m_pSubFileSystem)
	{
		delete m_pSubFileSystem;
		m_pSubFileSystem = NULL;
	}
	if (m_pFileSystem)
	{
		m_pFileSystem->Close();
		delete m_pFileSystem;
		m_pFileSystem = NULL;
	}

	return true;
}

void CCHMFileReader::Open()
{
	try
	{
		m_pFileSystem = new CFileSystem();
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!m_pFileSystem)
		{
			throw bad_alloc();
		}
		
		m_pSubFileSystem = new CSubFileSystem(m_pFileSystem);
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!m_pSubFileSystem)
		{			
			throw bad_alloc();
		}		
	}
	catch (bad_alloc&)
	{
		CloseHandle();
		throw CFileReaderException(this, CFileReaderException::eErrOpen, __FILE__, __LINE__);
	}

	HRESULT hr;
	if (RUNNING_FREE_THREADED())
		hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED); // Initialize COM library
	if (RUNNING_APARTMENT_THREADED())
		hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); // Initialize COM library

	if (SUCCEEDED(hr))
		hr = m_pFileSystem->Init();
	
	// >>> $BUG$ potential - not sure. Oleg. 02.04.99
	// Theoretically we do not need COM library after class factory
	//  was used in m_pFileSystem->Init() in order to obtain ITStorage pointer.
	// Oleg. 02.04.99
	// MS v-amitse 07.16.2001 RAID 432425 - added check for successful initialization
	if ((RUNNING_FREE_THREADED() || RUNNING_APARTMENT_THREADED()) && SUCCEEDED(hr))
		::CoUninitialize(); // Uninitialize COM library

	if (SUCCEEDED(hr))
		hr = m_pFileSystem->Open(m_strCHMPath);

	if (SUCCEEDED(hr))
		hr = m_pSubFileSystem->OpenSub(m_strStreamName);

	if (! SUCCEEDED(hr) )
	{
		CloseHandle();
		throw CFileReaderException( this, CFileReaderException::eErrOpen, __FILE__, __LINE__ );
	}
}

void CCHMFileReader::ReadData(LPTSTR * ppBuf)
{
	if (!m_pSubFileSystem)
		throw CFileReaderException(this, CFileReaderException::eErrOpen, __FILE__, __LINE__);

	ULONG cb = m_pSubFileSystem->GetUncompressedSize();
	ULONG cbRead = 0;

	try
	{
		*ppBuf = new TCHAR [cb/sizeof(TCHAR)+1];
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!*ppBuf)
			throw bad_alloc();					
		
		memset(*ppBuf, 0, cb+sizeof(TCHAR));			
	}
	catch (bad_alloc&)
	{
		throw CFileReaderException(this, CFileReaderException::eErrAllocateToRead, __FILE__, __LINE__);
	}

	HRESULT hr = m_pSubFileSystem->ReadSub(*ppBuf, cb, &cbRead);
	if (! SUCCEEDED(hr) )
		throw CFileReaderException(this, CFileReaderException::eErrRead, __FILE__, __LINE__);
}

CString CCHMFileReader::GetPathName() const
{
	return (kstr_CHMpathMarker + m_strCHMPath + kstr_CHMstreamMarker + m_strStreamName );
}

CString CCHMFileReader::GetJustNameWithoutExtension() const
{
	return CAbstractFileReader::GetJustNameWithoutExtension(m_strStreamName);
}

CString CCHMFileReader::GetJustExtension() const
{
	return CAbstractFileReader::GetJustExtension(m_strStreamName);
}

bool CCHMFileReader::GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const
{
	return CAbstractFileReader::GetFileTime(m_strCHMPath, type, out);
}

CString CCHMFileReader::GetNameToLog() const
{
	return GetPathName();
}

// Returns true if the first few characters of the path match a given string.
/*static*/ bool CCHMFileReader::IsCHMfile( const CString& strPath )
{
	// Make a copy of the path.
	CString strTemp= strPath;

	// Check for the string that denotes the beginning of a CHM file.
	// The sequence must start in the initial byte of a left trimmed string.
	strTemp.TrimLeft();
	strTemp.MakeLower();
	if (strTemp.Find( kstr_CHMpathMarker ) == 0)
		return( true );
	else
		return( false );
}

/*static*/ bool CCHMFileReader::IsPathToCHMfile( const CString& strPath )
{
	CString strTemp = strPath;

	strTemp.TrimRight();
	strTemp.MakeLower();
	
	// New approach, test for ANY extension
	int dot_index = strTemp.ReverseFind(_T('.'));
	int back_slash_index = strTemp.ReverseFind(_T('\\'));
	int forward_slash_index = strTemp.ReverseFind(_T('/'));

	if (dot_index != -1 &&
		dot_index > back_slash_index &&
		dot_index > forward_slash_index
	   )
	{
		// Now test, if it is a real file
		WIN32_FIND_DATA find_data;
		HANDLE hFile = ::FindFirstFile(strTemp, &find_data);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			::FindClose(hFile);
			return true;
		}
	}
	
	// Old approach, test for ".chm"
	//if (CString(_T(".")) + kstr_CHMfileExtension == strTemp.Right(kstr_CHMfileExtension.GetLength() + 1))
	//	return true;
	
	return false;
}

/*static*/ CString CCHMFileReader::FormCHMPath( const CString strPathToCHMfile )
{
	return kstr_CHMpathMarker + strPathToCHMfile + kstr_CHMstreamMarker;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\countermgr.h ===
// CounterMgr.h: interface for the CCounterMgr classes.
//
// MODULE: COUNTERMGR.H
//
// PUTPOSE: Global pool of pointers to status counters
//      These pointers can be accessed through name (string, like "Topic imsetup"
//		or "Thread 1") and counted event identifier (long).
//		There is only one instance of this class in the programm.
//      Manipulation with members of this class should be thread safe.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 10-20-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-20-98	OK		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COUNTERMGR_H__14CDE7A4_6844_11D2_8C42_00C04F949D33__INCLUDED_)
#define AFX_COUNTERMGR_H__14CDE7A4_6844_11D2_8C42_00C04F949D33__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Stateless.h"
#include "Counter.h"
#include <vector>

using namespace std;

class CCounterMgr; // forward declaration
CCounterMgr* Get_g_CounterMgr(); // Singleton to obtain g_CounterMgr global variable

////////////////////////////////////////////////////////////////////////////////////
// CCounterMgr declaration
////////////////////////////////////////////////////////////////////////////////////
class CCounterMgr : public CStateless
{
	vector<CAbstractCounter*> m_arrCounterPool;

public:
	CCounterMgr() {}
	virtual ~CCounterMgr() {}

protected:
	CAbstractCounter* Exists(const CCounterLocation&) const;
	bool RemoveLocation(const CCounterLocation&);

public:
	// adds counter with unique location
	//  if counter with such location alredy exists, does nothing, returns false
	bool Add(const CAbstractCounter&);
	// adds counter with unique location
	//  if counter with such location alredy exists, it is substituted with new counter
	void AddSubstitute(const CAbstractCounter&);
	// removes this particular counter
	//  if the counter is not stored in the pool, returns false
	bool Remove(const CAbstractCounter&);
	CAbstractCounter* Get(const CCounterLocation&) const;
};

#endif // !defined(AFX_COUNTERMGR_H__14CDE7A4_6844_11D2_8C42_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\commonregconnect.cpp ===
//
// MODULE: CommonREGCONNECT.CPP
//
// PURPOSE: read - write to the registry; common code for Online TS and Local TS, which differ 
//	on many functions of this class
//	
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 8-24-98 in Online TS.  This file abstracted 1-19-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		09-10-98	JM		backslashing; access log file info
// V3.1		01-19-98	JM		branch out version exclusively for Local TS

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgtsregconnect.h"
#include "event.h"
#include "apgtsevt.h"
#include "apgtscls.h"
#include "apgts.h"
#include "apiwraps.h"

CMutexOwner CAPGTSRegConnector::s_mx(_T("APGTSRegConnector"));

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector
////////////////////////////////////////////////////////////////////////////////////
CAPGTSRegConnector::~CAPGTSRegConnector()
{
}

// When this lock is held, it locks against not just other threads locking this object,
//	but against other threads locking any objects of class CAPGTSRegConnector.
void CAPGTSRegConnector::Lock()
{
	WAIT_INFINITE( s_mx.Handle() );
}

void CAPGTSRegConnector::Unlock()
{
	::ReleaseMutex(s_mx.Handle());
}

bool CAPGTSRegConnector::IsRead()
{
	bool ret = false;
	Lock();
	ret = m_RegistryInfo.m_bIsRead;
	Unlock();
	return ret;
}

// the root key (typically "SOFTWARE\Microsoft" in Local TS or "SOFTWARE\\ISAPITroubleShoot" in Online TS) exists
bool CAPGTSRegConnector::Exists()
{
	bool ret = false;
	CRegUtil reg;
	Lock();
	if (reg.Open(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), KEY_QUERY_VALUE))
		if (reg.Open(RegThisProgram(), KEY_QUERY_VALUE))
			ret = true;
	reg.Close();
	Unlock();
	return ret;
}


/*static*/ CString & CAPGTSRegConnector::StringFromConnector(ERegConnector e, CString & str)
{
	switch (e)
	{
		case eResourcePath: str = FULLRESOURCE_STR; break;
		case eVrootPath: str = VROOTPATH_STR; break;
		case eMaxThreads: str = MAX_THREADS_STR; break;
		case eThreadsPP: str = THREADS_PER_PROCESSOR_STR; break;
		case eMaxWQItems: str = MAX_WORK_QUEUE_ITEMS_STR; break;
		case eCookieLife: str = COOKIE_LIFE_IN_MINS_STR; break;
		case eReloadDelay: str = RELOAD_DELAY_STR; break;
		case eDetailedEventLogging: str = DETAILED_EVENT_LOGGING_STR; break;
		case eLogFilePath:  str = LOG_FILE_DIR_STR; break;
		case eTopicFileExtension:  str = LOG_FILE_DIR_STR; break;
		case eSniffAutomatic:  str = SNIFF_AUTOMATIC_STR; break;
		case eSniffManual:  str = SNIFF_MANUAL_STR; break;
		default: str = _T(""); break;
	}
	return str;
}

/*static*/ CAPGTSRegConnector::ERegConnector CAPGTSRegConnector::ConnectorFromString( const CString & str)
{
	ERegConnector e = eIndefinite;

	if (str == FULLRESOURCE_STR)
		e = eResourcePath;
	else if (str == VROOTPATH_STR)
		e = eVrootPath;
	else if (str == MAX_THREADS_STR)
		e = eMaxThreads;
	else if (str == THREADS_PER_PROCESSOR_STR)
		e = eThreadsPP;
	else if (str == MAX_WORK_QUEUE_ITEMS_STR)
		e = eMaxWQItems;
	else if (str == COOKIE_LIFE_IN_MINS_STR)
		e = eCookieLife;
	else if (str == RELOAD_DELAY_STR)
		e = eReloadDelay;
	else if (str == DETAILED_EVENT_LOGGING_STR)
		e = eDetailedEventLogging;
	else if (str == LOG_FILE_DIR_STR)
		e = eLogFilePath;
	else if (str == SNIFF_AUTOMATIC_STR)
		e = eSniffAutomatic;
	else if (str == SNIFF_MANUAL_STR)
		e = eSniffManual;

	return e;
}

/*static*/ bool CAPGTSRegConnector::IsNumeric(ERegConnector e)
{
	switch (e)
	{
		case eMaxThreads: return true;
		case eThreadsPP: return true;
		case eMaxWQItems: return true;
		case eCookieLife: return true;
		case eReloadDelay: return true;
		case eDetailedEventLogging: return true;
		case eSniffAutomatic: return true;
		case eSniffManual: return true;
		default: return false;
	}
}

/*static*/ bool CAPGTSRegConnector::IsString(ERegConnector e)
{
	switch (e)
	{
		case eResourcePath: return true;
		case eVrootPath: return true;
		case eLogFilePath:  return true;
		case eTopicFileExtension:  return true;
		default: return false;
	}
}
////////////////////////////////////////////////////////
// The following 2 functions set values in the registry.  Note that they do NOT
//	maintain member values.  That must be done at a higher level.
// Like CRegUtil::SetNumericValue(), and CRegUtil::SetStringValue(),
//	these assume we already have right key open.
// These also assume we have the relevant lock.
void CAPGTSRegConnector::SetNumericValue(CRegUtil &reg, ERegConnector e, DWORD dwValue)
{
	CString str;
	if( IsNumeric(e) && reg.SetNumericValue(StringFromConnector(e, str), dwValue))
		return;

	// either inappropriate input or otherwise couldn't set value
	throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, e);
}
//
// See comments on CAPGTSRegConnector::SetNumericValue
void CAPGTSRegConnector::SetStringValue(CRegUtil &reg, ERegConnector e, CString strValue)
{
	CString str;
	if( IsString(e) && reg.SetStringValue(StringFromConnector(e, str), strValue))
		return;

	// either inappropriate input or otherwise couldn't set value
	throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, e);
}
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// The following 3 functions set values in the registry.  Note that they do NOT
//	maintain member values.  Typically, these are to be used in a CAPGTSRegConnector
//	that exists briefly for the sole purpose of setting registry values.
//
// If there is a CRegistryMonitor in existence -- whether it is this object itself
//	or a distinct object -- it will become aware of this change by monitoring
//	the registry and will behave accordingly.
//
// SetOneNumericValue() is a higher-level way to set a numeric value.
// Does not assume anything about open keys or held locks.
// Does assume value is in the usual area where APGTS stores its registry data.
bool CAPGTSRegConnector::SetOneNumericValue(ERegConnector e, DWORD dwValue)
{
	bool bRet=true;
	Lock();
	try
	{
		CRegUtil reg;
		bool was_created = false;
		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, KEY_QUERY_VALUE | KEY_WRITE))
		{
			if (reg.Create(RegThisProgram(), &was_created, KEY_READ | KEY_WRITE))
			{
				SetNumericValue(reg, e, dwValue);
			}
		}
	}
	catch(CAPGTSRegConnectorException& exception) 
	{
		exception.Log();
		exception.Close();
		bRet=false;
	}
	Unlock();
	return bRet;
}
//
// See comments on CAPGTSRegConnector::SetOneNumericValue
// SetOneStringValue() is a higher-level way to set a string value.
// Does not assume anything about open keys or held locks.
// Does assume value is in the usual area where APGTS stores its registry data.
bool CAPGTSRegConnector::SetOneStringValue(ERegConnector e, const CString & strValue)
{
	bool bRet=true;
	Lock();
	try
	{
		CRegUtil reg;
		bool was_created = false;
		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, KEY_QUERY_VALUE | KEY_WRITE))
		{
			if (reg.Create(RegThisProgram(), &was_created, KEY_READ | KEY_WRITE))
			{
				SetStringValue(reg, e, strValue);
			}
		}
	}
	catch(CAPGTSRegConnectorException& exception) 
	{
		exception.Log();
		exception.Close();
		bRet=false;
	}
	Unlock();
	return bRet;
}
//
// See comments on CAPGTSRegConnector::SetOneNumericValue.  This is the public function
// Function returns true if strName represents a value we maintain.
// bChanged returns true if the value is changed.  If the function returns false, bChanged 
//	always returns false.
bool CAPGTSRegConnector::SetOneValue(const CString & strName, const CString & strValue, bool &bChanged)
{
	ERegConnector e = ConnectorFromString(strName);
	if (IsNumeric(e))
	{
		bChanged = SetOneNumericValue(e, _ttoi(strValue));
		return true;
	}
	else if (IsString(e))
	{
		bChanged = SetOneStringValue(e, strValue);
		return true;
	}
	else
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_ERROR_INVALIDREGCONNECTOR ); 
		bChanged = false;
		return false;
	}
}

//////////////////////////////////////////////////////

// Having read a string strNew from the registry & done any massaging it gets,
//	assign this string value to the appropriate variable strPersist.
// Returns true and logs dwEvent if strPersist is changed (new value differs from old).
/*static*/ bool CAPGTSRegConnector::AssignString(CString & strPersist, const CString & strNew, DWORD dwEvent)
{
	if (!(strNew == strPersist)) 
	{
		CString str = strPersist;
		str += _T(" | ");
		str += strNew;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(SrcLoc.GetSrcFileLineStr(), 
							  SrcLoc.GetSrcFileLineStr(), 
							  str,
							  _T(""),
							  dwEvent);

		strPersist = strNew;
		return true;
	}
	return false;
}

// Having read a numeric dwNew from the registry
//	assign this value to the appropriate variable dwPersist.
// Also used a second time if we need to force the value to an acceptable number.
// Returns true and logs dwEvent if dwPersist is changed (new value differs from old).
// If dwEventDecrease is non-zero, it provides a distinct message to log if the value
//	is decreased rather than increased.
/*static*/ bool CAPGTSRegConnector::AssignNumeric(DWORD & dwPersist, DWORD dwNew, 
									   DWORD dwEvent, DWORD dwEventDecrease /* =0 */)
{
	if (dwNew != dwPersist) 
	{
		CString strOld;
		strOld.Format(_T("%d"), dwPersist );
		CString strNew;
		strNew.Format(_T("%d"), dwNew);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(SrcLoc.GetSrcFileLineStr(), 
							  SrcLoc.GetSrcFileLineStr(), 
							  strOld,
							  strNew,
							  (dwEventDecrease != 0 && dwNew < dwPersist) ?
								dwEventDecrease : dwEvent);
		dwPersist = dwNew;
		return true;
	}
	return false;
}

/*static*/ bool CAPGTSRegConnector::ForceRangeOfNumeric(
	DWORD & dw, 
	DWORD dwDefault, 
	DWORD dwEvent, 
	DWORD dwMin,	/*=1*/
	DWORD dwMax		/*=ABS_MAX_REG_PARAM_VAL*/
	)
{
	// do limited validation; 
	if (dw > dwMax || dw < dwMin)
	{
		AssignNumeric(dw, dwDefault, dwEvent);
		return true;
	}
	return false;
}

// pump data into m_RegistryInfo - PLUS sets absent data in registry to default.
// OUTPUT maskChanged  or-ed ERegConnector-based mask of elements that have been 
//						changed since last read
// OUTPUT maskCreated  or-ed ERegConnector-based mask of elements that were created 
//						in registry (because they previously didn't exist in registry)
bool CAPGTSRegConnector::Read(int & maskChanged, int & maskCreated)
{
	bool ret = true;

	Lock();
	try {
		ReadUpdateRegistry(maskChanged, maskCreated);
		m_RegistryInfo.m_bIsRead = true;
	} 
	catch(CAPGTSRegConnectorException& exception) 
	{
		exception.Log();
		exception.Close();
		ret = false;
	}
	Unlock();

	return ret;
}

void CAPGTSRegConnector::Clear()
{
	Lock();

	// Check if our registry tree exists.
	if (!Exists())
	{
		// Rebuilds our registry tree if it has been damaged or deleted.  
		CRegUtil reg;
		bool was_created = false;

		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, KEY_QUERY_VALUE | KEY_WRITE))
			reg.Create(RegThisProgram(), &was_created, KEY_READ | KEY_WRITE);
		reg.Close();
	}

	m_RegistryInfo.SetToDefault();
	Unlock();
}

bool CAPGTSRegConnector::GetNumericInfo(ERegConnector en, DWORD& out)
{
	bool ret = true;
	Lock();
	if (en == eMaxThreads)
		out = m_RegistryInfo.dwMaxThreads;
	else if (en == eThreadsPP)
		out = m_RegistryInfo.dwThreadsPP;
	else if (en == eMaxWQItems)
		out = m_RegistryInfo.dwMaxWQItems;
	else if (en == eCookieLife)
		out = m_RegistryInfo.dwCookieLife;
	else if (en == eReloadDelay)
		out = m_RegistryInfo.dwReloadDelay;
	else if (en == eDetailedEventLogging)
		out = m_RegistryInfo.dwDetailedEventLogging;
	else if (en == eSniffAutomatic)
		out = m_RegistryInfo.dwSniffAutomatic;
	else if (en == eSniffManual)
		out = m_RegistryInfo.dwSniffManual;
	else 
		ret = false;
	Unlock();
	return ret;
}

bool CAPGTSRegConnector::GetStringInfo(ERegConnector en, CString& out)
{
	bool ret = true;
	Lock();
	if (en == eResourcePath)
		out = m_RegistryInfo.strResourcePath;
	else if (en == eVrootPath)
		out = m_RegistryInfo.strVrootPath;
	else if (en == eLogFilePath)
		out = m_RegistryInfo.strLogFilePath;	
	else if (en == eTopicFileExtension)
		out = m_RegistryInfo.strTopicFileExtension;
	else 
		ret = false;
	Unlock();
	return ret;
}


//	AddBackslash appends a backslash ('\') to CStrings that do not already end in '\'.
/* static */void CAPGTSRegConnector::AddBackslash(CString & str)
{
	int len = str.GetLength();
	if (len && str.Right(1).Find('\\') >= 0)
	{
		// do nothing, already has backslash
	}
	else
		// add backslash
		str += "\\";
	return;
}

// BackslashIt replaces all frontslashes ('/') in str with backslashes ('\')
//	and (optionally) forces termination with a backslash
/* static */void CAPGTSRegConnector::BackslashIt(CString & str, bool bForce)
{
	int loc;
	while ((loc = str.Find('/')) != -1)
	{
		str = str.Left(loc) + "\\" + str.Mid(loc+1);
	}
	if (bForce)
		AddBackslash(str);
}

// APGTS key access
CString CAPGTSRegConnector::ThisProgramFullKey()
{
	CString str;
	str.Format(_T("%s\\%s"), RegSoftwareLoc(), RegThisProgram());
	return str;
}

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnectorException
////////////////////////////////////////////////////////////////////////////////////
void CAPGTSRegConnectorException::Log()
{
	CString str;
	switch (eVariable)
	{
		case CAPGTSRegConnector::eResourcePath:
		case CAPGTSRegConnector::eVrootPath:
		case CAPGTSRegConnector::eMaxThreads:
		case CAPGTSRegConnector::eThreadsPP:
		case CAPGTSRegConnector::eMaxWQItems:
		case CAPGTSRegConnector::eCookieLife:
		case CAPGTSRegConnector::eReloadDelay:
		case CAPGTSRegConnector::eDetailedEventLogging:
		case CAPGTSRegConnector::eLogFilePath:
		case CAPGTSRegConnector::eSniffAutomatic:
		case CAPGTSRegConnector::eSniffManual:
			CAPGTSRegConnector::StringFromConnector(eVariable, str); break;

		case CAPGTSRegConnector::eProblemWithKey: str = _T("Can't open reg key"); break;
		case CAPGTSRegConnector::eProblemWithLogKey: str = _T("Can't open IIS reg key"); break;

		case CAPGTSRegConnector::eIndefinite:	// falls through to default.
		default: str = _T("<Problem not specified>"); break;
	}

	CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
	CEvent::ReportWFEvent(GetSrcFileLineStr(), 
						  SrcLoc.GetSrcFileLineStr(), 
						  str,
						  _T(""),
						  TSERR_REG_READ_WRITE_PROBLEM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\countermgr.cpp ===
// CounterMgr.cpp: implementation of the CCounterMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CounterMgr.h"
#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// Using Singleton to assure initialization
CCounterMgr* Get_g_CounterMgr()
{
	static CCounterMgr g_CounterMgr;
	return &g_CounterMgr;
}

//////////////////////////////////////////////////////////////////////
// CCounterMgr class implementation
//////////////////////////////////////////////////////////////////////
CAbstractCounter* CCounterMgr::Exists(const CCounterLocation& location) const
{
	CAbstractCounter* ret = NULL;

	for (vector<CAbstractCounter*>::const_iterator i = m_arrCounterPool.begin(); i != m_arrCounterPool.end(); i++)
	{
		if ((CCounterLocation&)location == **i) {
			ret = *i;
			break;
		}
	}
	return ret;
}

bool CCounterMgr::RemoveLocation(const CCounterLocation& location)
{
	bool ret = false;
	CAbstractCounter* found = NULL;
	
	LOCKOBJECT();

	if (NULL != (found = Exists(location))) 
	{
		vector<CAbstractCounter*>::iterator i = find(m_arrCounterPool.begin(), m_arrCounterPool.end(), found);
		if (i != m_arrCounterPool.end())
		{
			m_arrCounterPool.erase(i);
			ret = true;
		}
	}

	UNLOCKOBJECT();
	return ret;
}

bool CCounterMgr::Add(const CAbstractCounter& counter)
{
	bool ret = false;
	
	LOCKOBJECT();

	if (!Exists(counter)) {
		m_arrCounterPool.push_back((CAbstractCounter*)&counter);
		ret = true;
	}

	UNLOCKOBJECT();
	return ret;
}

void CCounterMgr::AddSubstitute(const CAbstractCounter& counter)
{
	LOCKOBJECT();

	RemoveLocation(counter);
	m_arrCounterPool.push_back((CAbstractCounter*)&counter);

	UNLOCKOBJECT();
}

bool CCounterMgr::Remove(const CAbstractCounter& counter)
{
	bool ret = false;
	
	LOCKOBJECT();

	vector<CAbstractCounter*>::iterator i = find(m_arrCounterPool.begin(), m_arrCounterPool.end(), &counter);
	if (i != m_arrCounterPool.end())
	{
		m_arrCounterPool.erase(i);
		ret = true;
	}

	UNLOCKOBJECT();
	return ret;
}

CAbstractCounter* CCounterMgr::Get(const CCounterLocation& location) const
{
	CAbstractCounter* ret = NULL;
	
	LOCKOBJECT();
	ret = Exists(location);
	UNLOCKOBJECT();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\counter.cpp ===
//
// MODULE: COUNTER.CPP
//
// PURPOSE: implementation the counter classes: 
//		CPeriodicTotals (utility class)
//		CAbstractCounter (abstract base class).
//		CCounter (simple counter)
//		CHourlyCounter (counter with "bins" for each hour of the day)
//		CDailyCounter (counter with "bins" for day of the week)
//		CHourlyDailyCounter (counter with "bins" for each hour of the day and each day of the week)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 7-20-1998
//
// NOTES: 
//	1. Right as daylight savings time clicks in, there will be a few anomalies.
//		Since this defines "days" to be 24-hour periods, rather than calendar days, 
//		if you have just gone from standard time to daylight time, "previous days"
//		before the switch will begin at 11pm the night before the relevant day; 
//		if you have just gone from daylight time to standard time, "previous days"
//		before the switch will begin at 1am on the relevant day.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-20-98		JM		Original
//
//////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "event.h"
#include "SafeTime.h"
#include "Counter.h"
#include "CounterMgr.h"
#include "baseexception.h"
#include <new>
#include "CharConv.h"
#include "apiwraps.h"

const long k_secsPerHour = 3600;
const long k_secsPerDay = k_secsPerHour * 24;
const long k_secsPerWeek = k_secsPerDay * 7;

//////////////////////////////////////////////////////////////////////
// CPeriodicTotals
// Utility class, returned to provide an effective table of hourly/daily
//	counts.
//////////////////////////////////////////////////////////////////////
CPeriodicTotals::CPeriodicTotals(long nPeriods) :
	m_nPeriods(nPeriods),
	m_ptime(NULL),
	m_pCount(NULL)
{
	Reset();
}

CPeriodicTotals::~CPeriodicTotals()
{
	ReleaseMem();
}

void CPeriodicTotals::Reset()
{
	ReleaseMem();

	m_nPeriodsSet = 0;
	m_iPeriod = 0;
	m_ptime = NULL;
	m_pCount = NULL;

	try
	{
		m_ptime = new time_t[m_nPeriods];

		m_pCount = new long[m_nPeriods];
	}
	catch (bad_alloc&)
	{
		// Set the number of periods to zero, release any allocated memory, and rethrow the exception.
		m_nPeriods= 0;
		ReleaseMem();
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		throw;
	}
}

void CPeriodicTotals::ReleaseMem()
{
	delete [] m_ptime;
	delete [] m_pCount;
}


// Set the time & Count values at the current position and increment the position
bool CPeriodicTotals::SetNext(time_t time, long Count)
{
	if (m_iPeriod >= m_nPeriods)
		return false;
	
	m_ptime[m_iPeriod] = time;
	m_pCount[m_iPeriod++] = Count;
	m_nPeriodsSet++;
	
	return true;
}

// Format a time and count suitably for HTML or other text use.
// returns a reference of convenience to the same string passed in.
CString & CPeriodicTotals::DisplayPeriod(long i, CString & str) const
{
	CString strTime;
	{
		CSafeTime safe(m_ptime[i]);
		str = safe.StrLocalTime();
	}
	strTime.Format(_T(" %8.8d"), m_pCount[i]);
	str += strTime;
	return str;
}

//////////////////////////////////////////////////////////////////////
//	CHourlyTotals
//////////////////////////////////////////////////////////////////////
CHourlyTotals::CHourlyTotals() :
	CPeriodicTotals (24+1)
{
}

CHourlyTotals::~CHourlyTotals()
{
}

// This is strictly for display to operator, so hard-coding English is OK
// returns a reference of convenience to the same string passed in.
CString CHourlyTotals::HTMLDisplay() const
{
	CString str, strTemp;

	if (m_nPeriodsSet > 1)
	{
		str += _T("<TR>\n");
		str += _T("<TD ROWSPAN=\"24\" ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\">\n");
		str += _T("<B>Last 24 hours: </B>");
		str += _T("</TD>\n");
		for (int i=0; i<24 && i<m_nPeriodsSet-1 ; i++)
		{
			if (i!=0)
				str += _T("<TR>\n");
			str+= _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
			CPeriodicTotals::DisplayPeriod(i, strTemp);
			str += strTemp;
			str += _T("</TD>\n");
			str += _T("</TR>\n");
		}
	}

	if (m_nPeriodsSet >= 1)
	{
		str += _T("<TR>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\"> \n");
		str += _T("<B>Current hour:</B> ");
		str += _T("</TD>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
		CPeriodicTotals::DisplayPeriod(m_nPeriodsSet-1, strTemp);
		str += strTemp;
		str += _T("</TD>\n");
		str += _T("</TR>\n");
	}
	else
		str = _T("<BR>No hourly data.");

	return str;
}

//////////////////////////////////////////////////////////////////////
//	CDailyTotals
//////////////////////////////////////////////////////////////////////
CDailyTotals::CDailyTotals() :
	CPeriodicTotals (7+1)
{
}

CDailyTotals::~CDailyTotals()
{
}

// This is strictly for display to operator, so hard-coding English is OK
// returns a reference of convenience to the same string passed in.
CString CDailyTotals::HTMLDisplay() const
{
	CString str, strTemp;
	if (m_nPeriodsSet > 1)
	{
		str = _T("<TR>\n");
		str+= _T("<TD ROWSPAN=\"7\" ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\">\n");
		str += _T("<B>Last 7 days: </B>");
		str += _T("</TD>\n");
		for (int i=0; i<7 && i<m_nPeriodsSet-1 ; i++)
		{
			if (i!=0)
				str += _T("<TR>\n");
			str+= _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
			CPeriodicTotals::DisplayPeriod(i, strTemp);
			str += strTemp;
			str += _T("</TD>\n");
			str += _T("</TR>\n");
		}
	}

	if (m_nPeriodsSet >= 1)
	{
		str += _T("<TR>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\"> \n");
		str += _T("<B>Today: </B>");
		str += _T("</TD>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
		CPeriodicTotals::DisplayPeriod(m_nPeriodsSet-1, strTemp);
		str += strTemp;
		str += _T("</TD>\n");
		str += _T("</TR>\n");
	}
	else
		str = _T("<BR>No daily data.");

	return str;
}

//////////////////////////////////////////////////////////////////////
// CCounterLocation
//////////////////////////////////////////////////////////////////////
/*static*/ LPCTSTR CCounterLocation::m_GlobalStr = _T("Global");
/*static*/ LPCTSTR CCounterLocation::m_TopicStr  = _T("Topic ");
/*static*/ LPCTSTR CCounterLocation::m_ThreadStr = _T("Thread ");

CCounterLocation::CCounterLocation(EId id, LPCTSTR scope /*=m_GlobalStr*/)
				: m_Scope(scope),
				  m_Id(id)
{
}

CCounterLocation::~CCounterLocation()
{
}

//////////////////////////////////////////////////////////////////////
// CAbstractCounter
//////////////////////////////////////////////////////////////////////
CAbstractCounter::CAbstractCounter(EId id /*=eIdGeneric*/, CString scope /*=m_GlobalStr*/)
				: CCounterLocation(id, scope)
{
	::Get_g_CounterMgr()->AddSubstitute(*this);
}

CAbstractCounter::~CAbstractCounter()
{
	::Get_g_CounterMgr()->Remove(*this);
}

//////////////////////////////////////////////////////////////////////
// CCounter
// a simple counter
//////////////////////////////////////////////////////////////////////
CCounter::CCounter(EId id /*=eIdGeneric*/, CString scope /*=m_GlobalStr*/)
		: CAbstractCounter(id, scope)
{
	Clear();
}

CCounter::~CCounter()
{
}

void CCounter::Increment()
{
	::InterlockedIncrement( &m_Count );
}

void CCounter::Clear()
{
	::InterlockedExchange( &m_Count, 0);
}

void CCounter::Init(long count)
{
	::InterlockedExchange( &m_Count, count);
}

long CCounter::Get() const
{
	return m_Count;
}

//////////////////////////////////////////////////////////////////////
// CHourlyCounter
// This counter maintains bins to keep track of values on a per-hour basis.
//	The code that sets the values can treat this as a CAbstractCounter.
//	Additional public functions are available to report results.
//////////////////////////////////////////////////////////////////////

CHourlyCounter::CHourlyCounter() :
	m_ThisHour (-1), 
	m_ThisTime (0)
{
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Hourly"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}
	Clear();
}

CHourlyCounter::~CHourlyCounter()
{
	::CloseHandle(m_hMutex);
}

void CHourlyCounter::Increment()
{
	WAIT_INFINITE( m_hMutex );
	SetHour();
	m_arrCount[m_ThisHour].Increment();
	::ReleaseMutex(m_hMutex);
}

void CHourlyCounter::Clear()
{
	WAIT_INFINITE( m_hMutex );
	for (long i = 0; i < 24; i++)
		m_arrCount[i].Clear();
	m_nThisHourYesterday = 0;
	::ReleaseMutex(m_hMutex);
}

void CHourlyCounter::Init(long count)
{
	CHourlyCounter::Clear();
	WAIT_INFINITE( m_hMutex );
	SetHour();
	m_arrCount[m_ThisHour].Init(count);
	::ReleaseMutex(m_hMutex);
}

// return a 24-hour total prior to the present hour.
// non-const because it calls SetHour()
long CHourlyCounter::GetDayCount() 
{
	long DayCount = 0;
	WAIT_INFINITE( m_hMutex );
	SetHour();
	for (long i=0; i<24; i++)
	{
		if ( i != m_ThisHour )
			DayCount += m_arrCount[i].Get();
		DayCount += m_nThisHourYesterday;
	}
	::ReleaseMutex(m_hMutex);

	return DayCount;
}

// non-const because it calls SetHour()
void CHourlyCounter::GetHourlies(CHourlyTotals & totals)
{
	WAIT_INFINITE( m_hMutex );

	totals.Reset();

	SetHour();

	time_t time = m_ThisTime - (k_secsPerDay);

	totals.SetNext(time, m_nThisHourYesterday);

	long i;
	for (i=m_ThisHour+1; i<24; i++)
	{
		time += k_secsPerHour;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	for (i=0; i<=m_ThisHour; i++)
	{
		time += k_secsPerHour;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	::ReleaseMutex(m_hMutex);
}

// Based on the present time, shifts to the appropriate bin.
void CHourlyCounter::SetHour()
{
	time_t timeNow;
	time_t timeStartOfHour;

	WAIT_INFINITE( m_hMutex );

	time(&timeNow);
	timeStartOfHour = (timeNow / k_secsPerHour) * k_secsPerHour;

	if (timeStartOfHour > m_ThisTime)
	{
		// If we get here, hour changed.  Typically the last action was the previous
		//	hour, but the algorithm here does not require that.
		long Hour;
		{
			// minimize how long we use CSafeTime, because it means holding a mutex.
			CSafeTime safe(timeStartOfHour);
			Hour = safe.LocalTime().tm_hour;
		}

		if (timeStartOfHour - m_ThisTime > k_secsPerDay)
			Clear();
		else
		{
			m_nThisHourYesterday = m_arrCount[Hour].Get();
			if (m_ThisHour > Hour)
			{
				long i;
				for (i=m_ThisHour+1; i<24; i++)
				{
					m_arrCount[i].Clear();
				}
				for (i=0; i<=Hour; i++)
				{
					m_arrCount[i].Clear();
				}
			}
			else
			{
				for (long i=m_ThisHour+1; i<=Hour; i++)
				{
					m_arrCount[i].Clear();
				}
			}
		}
		
		m_ThisHour = Hour;
		m_ThisTime = timeStartOfHour;
	}
	::ReleaseMutex(m_hMutex);
	return;
}


//////////////////////////////////////////////////////////////////////
// CDailyCounter
// This counter maintains bins to keep track of values on a per-day basis.
//	The code that sets the values can treat this as a CAbstractCounter.
//	Additional public functions are available to report results.
//	This could share more code with CHourlyCounter, but it would be very hard to come up 
//		with appropriate variable and function names, so we are suffering dual maintenance.
//////////////////////////////////////////////////////////////////////

CDailyCounter::CDailyCounter() :
	m_ThisDay (-1), 
	m_ThisTime (0)
{
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Daily"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}
	Clear();
}

CDailyCounter::~CDailyCounter()
{
	::CloseHandle(m_hMutex);
}

void CDailyCounter::Increment()
{
	WAIT_INFINITE( m_hMutex );
	SetDay();
	m_arrCount[m_ThisDay].Increment();
	::ReleaseMutex(m_hMutex);
}

void CDailyCounter::Clear()
{
	WAIT_INFINITE( m_hMutex );
	for (long i = 0; i < 7; i++)
		m_arrCount[i].Clear();
	m_nThisDayLastWeek = 0;
	::ReleaseMutex(m_hMutex);
}

void CDailyCounter::Init(long count)
{
	CDailyCounter::Clear();
	WAIT_INFINITE( m_hMutex );
	SetDay();
	m_arrCount[m_ThisDay].Init(count);
	::ReleaseMutex(m_hMutex);
}

// return a 7-day total prior to the present day.
// non-const because it calls SetDay()
long CDailyCounter::GetWeekCount()
{
	long WeekCount = 0;
	WAIT_INFINITE( m_hMutex );
	SetDay();
	for (long i=0; i<7; i++)
	{
		if ( i != m_ThisDay )
			WeekCount += m_arrCount[i].Get();
		WeekCount += m_nThisDayLastWeek;
	}
	::ReleaseMutex(m_hMutex);

	return WeekCount;
}

// non-const because it calls SetDay()
void CDailyCounter::GetDailies(CDailyTotals & totals)
{
	WAIT_INFINITE( m_hMutex );

	totals.Reset();

	SetDay();

	time_t time = m_ThisTime - (k_secsPerWeek);

	totals.SetNext(time, m_nThisDayLastWeek);

	long i;
	for (i=m_ThisDay+1; i<7; i++)
	{
		time += k_secsPerDay;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	for (i=0; i<=m_ThisDay; i++)
	{
		time += k_secsPerDay;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	::ReleaseMutex(m_hMutex);
}

// Based on the present time, shifts to the appropriate bin.
void CDailyCounter::SetDay()
{
	time_t timeNow;
	time_t timeStartOfDay;

	WAIT_INFINITE( m_hMutex );

	time(&timeNow);

	// Want to get start of day local time.
	// Can't just set timeStartOfDay = (timeNow / k_secsPerDay) * k_secsPerDay
	// because that would be the start of the day based on GMT!
	long DayOfWeek;
	{
		// minimize how long we use CSafeTime, because it means holding a mutex.
		CSafeTime safe(timeNow);
		struct tm tmStartOfDay = safe.LocalTime();
		DayOfWeek = tmStartOfDay.tm_wday;
		tmStartOfDay.tm_sec = 0;
		tmStartOfDay.tm_min = 0;
		tmStartOfDay.tm_hour = 0;
		timeStartOfDay = mktime(&tmStartOfDay);
	}

	if (timeStartOfDay > m_ThisTime)
	{
		// If we get here, day changed.  Typically the last action was the previous
		//	hour, but the algorithm here does not require that.
		{
			// minimize how long we use CSafeTime, because it means holding a mutex.
			CSafeTime safe(timeStartOfDay);
			DayOfWeek = safe.LocalTime().tm_wday;
		}

		if (timeStartOfDay - m_ThisTime > k_secsPerWeek)
			Clear();
		else
		{
			m_nThisDayLastWeek = m_arrCount[DayOfWeek].Get();
			if (m_ThisDay > DayOfWeek)
			{
				long i;
				for (i=m_ThisDay+1; i<7; i++)
				{
					m_arrCount[i].Clear();
				}
				for (i=0; i<=DayOfWeek; i++)
				{
					m_arrCount[i].Clear();
				}
			}
			else
			{
				for (long i=m_ThisDay+1; i<=DayOfWeek; i++)
				{
					m_arrCount[i].Clear();
				}
			}
		}
		
		m_ThisDay = DayOfWeek;
		m_ThisTime = timeStartOfDay;
	}
	::ReleaseMutex(m_hMutex);
	return;
}

//////////////////////////////////////////////////////////////////////
// CHourlyDailyCounter
//////////////////////////////////////////////////////////////////////
CHourlyDailyCounter::CHourlyDailyCounter(EId id /*=eIdGeneric*/, CString scope /*=m_GlobalStr*/) 
				   : CAbstractCounter(id, scope),
					 m_Total(0), 
					 m_timeFirst(0),
					 m_timeLast(0),
					 m_timeCleared(0)
{
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("HourlyDaily"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}

	time(&m_timeCreated);
	time(&m_timeCleared);
}

CHourlyDailyCounter::~CHourlyDailyCounter()
{
	::CloseHandle(m_hMutex);
}

void CHourlyDailyCounter::Increment()
{
	WAIT_INFINITE( m_hMutex );
	m_hourly.Increment();
	m_daily.Increment();
	m_Total++;
	time(&m_timeLast);
	if (!m_timeFirst)
		m_timeFirst = m_timeLast;
	::ReleaseMutex(m_hMutex);
}

void CHourlyDailyCounter::Clear()
{
	WAIT_INFINITE( m_hMutex );
	m_hourly.Clear();
	m_daily.Clear();
	m_Total= 0;
	m_timeFirst = 0;
	m_timeLast = 0;
	time(&m_timeCleared);
	::ReleaseMutex(m_hMutex);
}

void CHourlyDailyCounter::Init(long count)
{
	CHourlyDailyCounter::Clear();
	WAIT_INFINITE( m_hMutex );
	m_hourly.Init(count);
	m_daily.Init(count);
	m_Total = count;
	time(&m_timeLast);
	if (!m_timeFirst)
		m_timeFirst = m_timeLast;
	::ReleaseMutex(m_hMutex);
}

// no need to lock here, because m_hourly does its own locking.
long CHourlyDailyCounter::GetDayCount()
{
	return m_hourly.GetDayCount();
}

// no need to lock here, because m_hourly does its own locking.
void CHourlyDailyCounter::GetHourlies(CHourlyTotals & totals)
{
	m_hourly.GetHourlies(totals);
}

// no need to lock here, because m_daily does its own locking.
long CHourlyDailyCounter::GetWeekCount()
{
	return m_daily.GetWeekCount();
}

// no need to lock here, because m_daily does its own locking.
void CHourlyDailyCounter::GetDailies(CDailyTotals & totals)
{
	m_daily.GetDailies(totals);
}

long CHourlyDailyCounter::GetTotal() const
{
	WAIT_INFINITE( m_hMutex );
	long ret = m_Total;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeFirst() const 
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeFirst;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeLast() const
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeLast;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeCleared() const
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeCleared;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeCreated() const
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeCreated;
	::ReleaseMutex(m_hMutex);
	return ret;
}

time_t CHourlyDailyCounter::GetTimeNow() const
{
	// No need to lock mutex on this call.
	time_t ret;
	time(&ret);

	return ret;
}

////////////////////////////////////////////////////////////////////////////////////
// CDisplayCounter...::Display() implementation
////////////////////////////////////////////////////////////////////////////////////
#define STATUS_INVALID_NUMBER_STR   _T("none")
#define STATUS_INVALID_TIME_STR     _T("none")

CString CDisplayCounterTotal::Display()
{
	TCHAR buf[128] = {0};
	_stprintf(buf, _T("%ld"), long(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTotal()));
	return buf;
}

CString CDisplayCounterCurrentDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeNow()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterCreateDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeCreated()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterFirstDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeFirst()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterLastDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeLast()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterDailyHourly::Display() 
{
	CString ret;

	if (m_pDailyTotals) {
		((CHourlyDailyCounter*)m_pAbstractCounter)->GetDailies(*m_pDailyTotals);
		ret += m_pDailyTotals->HTMLDisplay();
	}
	if (m_pHourlyTotals) {
		((CHourlyDailyCounter*)m_pAbstractCounter)->GetHourlies(*m_pHourlyTotals);
		ret += m_pHourlyTotals->HTMLDisplay();
	}

	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\cptshoot.h ===
#ifndef _CPTSHOOT_H_
#define _CPTSHOOT_H_

template <class T>
class CProxy_ITSHOOTCtrlEvents : public IConnectionPointImpl<T, &DIID__ITSHOOTCtrlEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	long Fire_Sniffing(BSTR strNodeName, BSTR strLaunchBasis, BSTR strAdditionalArgs)
	{
		T* pT = static_cast<T*>(this);
		VARIANT resultVariant;

		if (RUNNING_APARTMENT_THREADED())
		{
			CComVariant* pvars = new CComVariant[3];
			long result = -1;

			V_VT(&resultVariant) = VT_I4;
			resultVariant.lVal = result;
			
			pT->Lock();
			for(vector<DWORD>::iterator it = pT->m_vecCookies.begin(); it != pT->m_vecCookies.end(); it++)
			{
				IDispatch* pDispatch = NULL;
				
				pT->m_pGIT->GetInterfaceFromGlobal(*it, IID_IDispatch,
					reinterpret_cast<void**>(&pDispatch));
				
				if (pDispatch != NULL)
				{
					pvars[2] = strNodeName;
					pvars[1] = strLaunchBasis;
					pvars[0] = strAdditionalArgs;
					DISPPARAMS disp = { pvars, NULL, 3, 0 };
					HRESULT result = S_OK;
					if (SUCCEEDED(result = pDispatch->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &resultVariant, NULL, NULL)))
					{
						pDispatch->Release();
						break;
					}
					pDispatch->Release();
				}
			}
			pT->Unlock();
			delete[] pvars;
		}
		if (RUNNING_FREE_THREADED())
		{
			int nConnectionIndex;
			CComVariant* pvars = new CComVariant[3];
			int nConnections = m_vec.GetSize();
			long result = -1;

			V_VT(&resultVariant) = VT_I4;
			resultVariant.lVal = result;
			
			for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
			{					                                                                                                                                                                                                                                                                                                                                                                                                    
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
				pT->Unlock();
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
				if (pDispatch != NULL)
				{
					pvars[2] = strNodeName;
					pvars[1] = strLaunchBasis;
					pvars[0] = strAdditionalArgs;
					DISPPARAMS disp = { pvars, NULL, 3, 0 };
					HRESULT hResult;
					if (SUCCEEDED(hResult = pDispatch->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &resultVariant, NULL, NULL)))
						break;
				}
			}
			delete[] pvars;
		}
		return resultVariant.lVal;	
	}

	void Fire_Render(BSTR strPage)
	{
		T* pT = static_cast<T*>(this);

		if (RUNNING_APARTMENT_THREADED())
		{
			CComVariant* pvars = new CComVariant[1];
			pT->Lock();
			for(vector<DWORD>::iterator it = pT->m_vecCookies.begin(); it != pT->m_vecCookies.end(); it++)
			{
				IDispatch* pDispatch = NULL;
				
				pT->m_pGIT->GetInterfaceFromGlobal(*it, IID_IDispatch,
					reinterpret_cast<void**>(&pDispatch));
				
				if (pDispatch != NULL)
				{
					pvars[0] = strPage;
					DISPPARAMS disp = { pvars, NULL, 1, 0 };
					HRESULT result = S_OK;
					if (SUCCEEDED(result = pDispatch->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL)))
					{
						pDispatch->Release();
						break;
					}
					pDispatch->Release();
				}
			}
			pT->Unlock();
			delete[] pvars;
		}
		if (RUNNING_FREE_THREADED())
		{
			int nConnectionIndex;
			CComVariant* pvars = new CComVariant[1];
			int nConnections = m_vec.GetSize();
			
			for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
			{					                                                                                                                                                                                                                                                                                                                                                                                                    
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
				pT->Unlock();
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
				if (pDispatch != NULL)
				{
					pvars[0] = strPage;
					DISPPARAMS disp = { pvars, NULL, 1, 0 };
					HRESULT hResult;
					if (SUCCEEDED(hResult = pDispatch->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL)))
						break;
				}
			}
			delete[] pvars;
		}
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\cstd.h ===
#ifndef _CSTD_H_
#define _CSTD_H_

#include <windows.h>

#define PvCast(type,  TYPE) 	((TYPE) (type))
#define OFFSET(field, type) 	((ULONG) &(type).field - (ULONG) &(type))

#ifndef	VOID
typedef	void			VOID;
#endif
typedef TCHAR*			  SZ;
//typedef TCHAR*			 PSZ;
typedef const TCHAR*	 SZC;

#ifndef max
	#define max(a, b)	((a) >= (b) ? (a) : (b))
#endif

#ifndef TRUE
	#define	TRUE	1
  	#define FALSE 	0
#endif

typedef enum
{
	fFalse = 0,
	fTrue  = !fFalse
};

typedef enum
{
	bFalse = 0,
	bTrue  = !bFalse
};


//typedef char*			   PCH;
typedef int 			  BOOL;

#ifndef  _WINDOWS
typedef unsigned short	  WORD;
typedef unsigned long	 DWORD;
typedef long			  LONG;
#endif

typedef unsigned char	 UCHAR;
typedef short			 SHORT;
typedef unsigned char	  BYTE;
typedef BYTE*			    PB;
typedef unsigned short	USHORT;
typedef int 			   INT;
typedef unsigned int	  UINT;
typedef unsigned long	 ULONG;
typedef double			   DBL;
typedef double			  REAL;

typedef ULONG			   RVA; 		// Relative Virtual Address
typedef ULONG			   LFA; 		// Long File Address
typedef	INT				(*PFNCMP)(const VOID*, const VOID*);

#include "debug.h"

#define CelemArray(rgtype)		(sizeof(rgtype) / sizeof(rgtype[0]))

SZ		SzCopy(SZC);

#ifdef	_WINDOWS
/* BUGBUG: See if this still compiles
	void __cdecl perror(const char*);
	int  __cdecl printf(const char*, ...);
	int  __cdecl vprintf(const char*, va_list);
	void __cdecl exit(int);
 */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\dirmonitor.cpp ===
//
// MODULE: DirMonitor.cpp
//
// PURPOSE: Monitor changes to LST, DSC, HTI, BES files.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-17-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-17-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include <algorithm>
#include "DirMonitor.h"
#include "event.h"
#include "apiwraps.h"
#include "CharConv.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "LocalLSTReader.h"
#include "CHMFileReader.h"
#endif
#include "apgts.h"	// Need for Local-Online macros.

const DWORD k_secsDefaultReloadDelay = 40;	// In practice, this default should not matter, 
								//  because SetReloadDelay() should be called before 
								//	SetResourceDirectory().  However, 40 is a typical 
								//	reasonable value for m_secsReloadDelay.

/////////////////////////////////////////////////////////////////////
// CTopicFileTracker
/////////////////////////////////////////////////////////////////////

CTopicFileTracker::CTopicFileTracker() :
	CFileTracker()
{
}

CTopicFileTracker::~CTopicFileTracker()
{
}

void CTopicFileTracker::AddTopicInfo(const CTopicInfo & topicinfo)
{
	m_topicinfo = topicinfo;

	// set CFileTracker member variables accordingly for files that are present.
	// If they are not present i.e. empty strings then adding them here results in
	// unnecessary event log entries.
	AddFile(topicinfo.GetDscFilePath());

	CString strHTI = topicinfo.GetHtiFilePath();
	if (!strHTI.IsEmpty())
		AddFile(strHTI);

	CString strBES = topicinfo.GetBesFilePath();
	if (!strBES.IsEmpty())
		AddFile(strBES);
}

const CTopicInfo & CTopicFileTracker::GetTopicInfo() const
{
	return m_topicinfo;
}

/////////////////////////////////////////////////////////////////////
// CTemplateFileTracker
/////////////////////////////////////////////////////////////////////

CTemplateFileTracker::CTemplateFileTracker() :
	CFileTracker()
{
}

CTemplateFileTracker::~CTemplateFileTracker()
{
}

void CTemplateFileTracker::AddTemplateName( const CString& strTemplateName )
{
	m_strTemplateName= strTemplateName;
	AddFile( strTemplateName );
}

const CString& CTemplateFileTracker::GetTemplateName() const
{
	return m_strTemplateName;
}

//////////////////////////////////////////////////////////////////////
// CDirectoryMonitor::ThreadStatus
//////////////////////////////////////////////////////////////////////
/* static */ CString CDirectoryMonitor::ThreadStatusText(ThreadStatus ts)
{
	switch(ts)
	{
		case eBeforeInit:		return _T("Before Init");
		case eFail:				return _T("Fail");
		case eWaitDirPath:		return _T("Wait For Dir Path");
		case eWaitChange:		return _T("Wait for Change");
		case eWaitSettle:		return _T("Wait to Settle");
		case eRun:				return _T("Run");
		case eBeforeWaitChange: return _T("Before Wait Change");
		case eExiting:			return _T("Exiting");
		default:				return _T("");
	}
}

/////////////////////////////////////////////////////////////////////
// CDirectoryMonitor
// This class does the bulk of its work on a separate thread.
// The thread is created in the constructor by starting static function
//	CDirectoryMonitor::DirectoryMonitorTask
// That function, in turn does its work by calling private members of this class that
//	are specific to use on the DirectoryMonitorTask thread.
// When this goes out of scope, its own destructor calls ShutDown to stop the thread,
//	waits for the thread to shut.
// The following methods are available for other threads communicating with that thread:
//	CDirectoryMonitor::SetReloadDelay
//	CDirectoryMonitor::SetResourceDirectory
/////////////////////////////////////////////////////////////////////
CDirectoryMonitor::CDirectoryMonitor(CTopicShop & TopicShop, const CString& strTopicName) :
	m_strTopicName(strTopicName),
	m_TopicShop(TopicShop),
	m_pErrorTemplate(NULL),
	m_strDirPath(_T("")),		// Essential that this starts blank.  Getting a different
								//	value is how we start the DirectoryMonitorTask thread.
	m_bDirPathChanged(false),
	m_bShuttingDown(false),
	m_secsReloadDelay(k_secsDefaultReloadDelay),
	m_pTrackLst( NULL ),
	m_pTrackErrorTemplate( NULL ),
	m_pLst( NULL ),
	m_dwErr(0),
	m_ThreadStatus(eBeforeInit),
	m_time(0)
{
	enum {eHevMon, eHevShut, eThread, eOK} Progress = eHevMon;
	SetThreadStatus(eBeforeInit);

	m_hevMonitorRequested = ::CreateEvent( 
		NULL, 
		FALSE, // release one thread (the DirectoryMonitorTask) on signal
		FALSE, // initially non-signalled
		NULL);
	if (m_hevMonitorRequested)
	{
		Progress = eHevShut;
		m_hevThreadIsShut = ::CreateEvent( 
			NULL, 
			FALSE, // release one thread (this one) on signal
			FALSE, // initially non-signalled
			NULL);

		if (m_hevThreadIsShut)
		{
			Progress = eThread;
			DWORD dwThreadID;	// No need to hold onto dwThreadID in member variable.
								// All Win32 functions take the handle m_hThread instead.
								// The one reason you'd ever want to know this ID is for 
								//	debugging

			// Note that there is no corresponding ::CloseHandle(m_hThread).
			// That is because the thread goes out of existence on the implicit 
			//	::ExitThread() when DirectoryMonitorTask returns.  See documentation of
			//	::CreateThread for further details JM 10/22/98
			m_hThread = ::CreateThread( NULL, 
											0, 
											(LPTHREAD_START_ROUTINE)DirectoryMonitorTask, 
											this, 
											0, 
											&dwThreadID);

			if (m_hThread)
				Progress = eOK;
		}
	}

	if (Progress != eOK)
	{
		m_dwErr = GetLastError();
		CString str;
		str.Format(_T("%d"), m_dwErr);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								(Progress == eHevMon) ?		_T("Can't create monitor event")
								: (Progress == eHevShut) ?	_T("Can't create \"shut\" event")
								:							_T("Can't create thread"),
								str, 
								EV_GTS_ERROR_DIRMONITORTHREAD );
		SetThreadStatus(eFail);

		if (m_hevMonitorRequested)
			::CloseHandle(m_hevMonitorRequested);

		if (m_hevThreadIsShut)
			::CloseHandle(m_hevThreadIsShut);
	}	
}

CDirectoryMonitor::~CDirectoryMonitor()
{
	ShutDown();
	
	if (m_hevMonitorRequested)
		::CloseHandle(m_hevMonitorRequested);

	if (m_hevThreadIsShut)
		::CloseHandle(m_hevThreadIsShut);

	if (m_pErrorTemplate)
		delete m_pErrorTemplate;

	if (m_pTrackLst)
		delete m_pTrackLst;

	if (m_pTrackErrorTemplate)
		delete m_pTrackErrorTemplate;
}

void CDirectoryMonitor::SetThreadStatus(ThreadStatus ts)
{
	LOCKOBJECT();
	m_ThreadStatus = ts;
	time(&m_time);
	UNLOCKOBJECT();
}

DWORD CDirectoryMonitor::GetStatus(ThreadStatus &ts, DWORD & seconds) const
{
	time_t timeNow;
	LOCKOBJECT();
	ts = m_ThreadStatus;
	time(&timeNow);
	seconds = timeNow - m_time;
	UNLOCKOBJECT();
	return m_dwErr;
}

// Only for use by this class's own destructor.
void CDirectoryMonitor::ShutDown()
{
	LOCKOBJECT();
	m_bShuttingDown = true;
	if (m_hThread)
	{
		::SetEvent(m_hevMonitorRequested);
		UNLOCKOBJECT();

		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hevThreadIsShut ); 
	}
	else
		UNLOCKOBJECT();
}

// For use by the DirectoryMonitorTask thread.
// Read LST file and add any topics that are not already in previously read LST file contents
void CDirectoryMonitor::LstFileDrivesTopics()
{
	// previous LST file contents, saved for comparison.
	CAPGTSLSTReader *pLstOld = m_pLst;

	if (! m_strLstPath.IsEmpty() )
	{
		try
		{
#ifdef LOCAL_TROUBLESHOOTER
			m_pLst = new CLocalLSTReader( CPhysicalFileReader::makeReader( m_strLstPath ), m_strTopicName);
#else
			m_pLst = new CAPGTSLSTReader( dynamic_cast<CPhysicalFileReader*>(new CNormalFileReader(m_strLstPath)) );
#endif
		}
		catch (bad_alloc&)
		{
			// Restore old LST contents.
			m_pLst = pLstOld;

			// Rethrow exception, logging handled upstream.
			throw;
		}

		if (! m_pLst->Read())
		{
			// Restore old LST contents and log error.
			delete m_pLst;
			m_pLst = pLstOld;
			
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), 
									_T(""), 
									EV_GTS_ERROR_LST_FILE_READ ); 
		}
		else
		{
			CTopicInfoVector arrNewTopicInfo;
			m_pLst->GetDifference(pLstOld, arrNewTopicInfo);
			if (pLstOld)
				delete pLstOld;

			for (CTopicInfoVector::iterator itNewTopicInfo = arrNewTopicInfo.begin(); 
				itNewTopicInfo != arrNewTopicInfo.end(); 
				itNewTopicInfo++
			)
			{
				// Let the Topic Shop know about the new topic
				m_TopicShop.AddTopic(*itNewTopicInfo);

				// add it to our list of files to track for changes
				CTopicFileTracker TopicFileTracker;
				TopicFileTracker.AddTopicInfo(*itNewTopicInfo);
				LOCKOBJECT();
				try
				{
					m_arrTrackTopic.push_back(TopicFileTracker);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
				UNLOCKOBJECT();
			}
		}
	}
	// if topic shop not already open, open it
	m_TopicShop.OpenShop();	
}


// Called by the topic shop to add alternate templates to track.
void CDirectoryMonitor::AddTemplateToTrack( const CString& strTemplateName )
{
	LOCKOBJECT();
	try
	{
		CTemplateFileTracker TemplateFileTracker;
		TemplateFileTracker.AddTemplateName( strTemplateName );

		m_arrTrackTemplate.push_back( TemplateFileTracker );
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
	UNLOCKOBJECT();
}


// For use by the DirectoryMonitorTask thread.
void CDirectoryMonitor::ReadErrorTemplate()
{
	LOCKOBJECT();

	if (m_pErrorTemplate)
		delete m_pErrorTemplate;

	CString str = k_strDefaultErrorTemplateBefore; 
	str += k_strErrorTemplateKey;
	str += k_strDefaultErrorTemplateAfter;

	try
	{
		m_pErrorTemplate = new CSimpleTemplate(	CPhysicalFileReader::makeReader( m_strErrorTemplatePath ), str );
	}
	catch (bad_alloc&)
	{
		UNLOCKOBJECT();

		// Rethrow the exception.
		throw;
	}

	m_pErrorTemplate->Read();

	UNLOCKOBJECT();
}

// For use by any thread.  In this class because CDirectoryMonitor needs to own
//	ErrorTemplate, since it can change during run of system.
void CDirectoryMonitor::CreateErrorPage(const CString & strError, CString& out) const
{
	LOCKOBJECT();

	if (m_pErrorTemplate)
	{
		vector<CTemplateInfo> arrTemplateInfo;
		CTemplateInfo info(k_strErrorTemplateKey, strError);
		try
		{
			arrTemplateInfo.push_back(info);
			m_pErrorTemplate->CreatePage( arrTemplateInfo, out );
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 

			// Generate the default error page to be safe.
			out = k_strDefaultErrorTemplateBefore + strError + k_strDefaultErrorTemplateAfter;
		}
	}
	else
		out = k_strDefaultErrorTemplateBefore + strError + k_strDefaultErrorTemplateAfter;

	UNLOCKOBJECT();
}

// Must be called on DirectoryMonitorTask thread.  
// Handles all work of monitoring the directory.  Loops till shutdown.
void CDirectoryMonitor::Monitor()
{
	enum {	
#ifndef LOCAL_TROUBLESHOOTER
			eDirChange, // file in directory changed 
#endif
			eHev,		// shutdown or change what directory 
			eNumHandles	};

	// array of handles we use when waiting for multiple events.  
	// Initialize first entry to default bad value.
	HANDLE hList[eNumHandles]= { INVALID_HANDLE_VALUE }; 

	if (m_strDirPath.GetLength() == 0)
	{
		SetThreadStatus(eWaitDirPath);

		// Block this thread until notification that the directory path has been set.
		::WaitForSingleObject( m_hevMonitorRequested, INFINITE);
	}

	SetThreadStatus(eRun);

	try 
	{
		if (RUNNING_ONLINE_TS())
		{
			// The DirPathChanged flag should be set here, enforce it if not.
			ASSERT( m_bDirPathChanged );
			if (!m_bDirPathChanged)
				m_bDirPathChanged= true;
		}

		// Wait for an explicit wakeup.
		hList[eHev] = m_hevMonitorRequested;

		while (true)
		{
			LOCKOBJECT();
			if (m_bShuttingDown)
			{
				UNLOCKOBJECT();
				break;
			}

			if (m_bDirPathChanged)
			{

#ifndef LOCAL_TROUBLESHOOTER
				// Set the directory to be monitored.
				if (hList[eDirChange] != INVALID_HANDLE_VALUE) 
					::FindCloseChangeNotification( hList[eDirChange] );
				while (true)
				{
					// handle to monitor for change in the resource directory
					hList[eDirChange] = ::FindFirstChangeNotification(m_strDirPath, 
													TRUE,	// monitor subdirectories (for multilingual)
													FILE_NOTIFY_CHANGE_LAST_WRITE 
												    );

					if (hList[eDirChange] == INVALID_HANDLE_VALUE) 
					{
						// resource directoty does not exist. 
						// Track creation of directories in upper directory 
						//  - it might be resource directory
						
						bool bFail = false;
						CString strUpperDir = m_strDirPath; // directory above resource directory (m_strDirPath)

						if (   strUpperDir[strUpperDir.GetLength()-1] == _T('\\')
						    || strUpperDir[strUpperDir.GetLength()-1] == _T('/'))
						{
							strUpperDir = strUpperDir.Left(strUpperDir.GetLength() ? strUpperDir.GetLength()-1 : 0);
						}

						int slash_last = max(strUpperDir.ReverseFind(_T('\\')), 
							                 strUpperDir.ReverseFind(_T('/')));
						
						if (-1 != slash_last)
						{
							strUpperDir = strUpperDir.Left(slash_last);

							hList[eDirChange] = ::FindFirstChangeNotification(strUpperDir, 
															TRUE,	// monitor subdirectories (for multilingual)
															FILE_NOTIFY_CHANGE_DIR_NAME
															);
							if (hList[eDirChange] == INVALID_HANDLE_VALUE) 
								bFail = true;
						}
						else
							bFail = true;
						
						if (!bFail)
						{
							// We have a valid handle, exit this loop.
							SetThreadStatus(eRun);
							break;
						}
						else
						{
							// typically would mean none of resource directory or its upper 
							//  directory is valid, log this.
							CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
							CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
													SrcLoc.GetSrcFileLineStr(), 
													m_strDirPath, _T(""), 
													EV_GTS_ERROR_CANT_FILE_NOTIFY ); 

							SetThreadStatus(eWaitDirPath);

							// Block this thread until notification that the directory path 
							// has been correctly set.  Unlock the object so that the event
							// can be set.
							UNLOCKOBJECT();
							::WaitForSingleObject( m_hevMonitorRequested, INFINITE);
							LOCKOBJECT();
						}
					}
					else
					{
						// We have a valid handle, exit this loop.
						SetThreadStatus(eRun);
						break;
					}
				}
#endif
				m_bDirPathChanged = false;
				if (m_pTrackLst)
					delete m_pTrackLst;
				m_pTrackLst = new CFileTracker;
			
				if (RUNNING_ONLINE_TS())
					m_pTrackLst->AddFile(m_strLstPath);
				
				if (m_pTrackErrorTemplate)
					delete m_pTrackErrorTemplate;
				m_pTrackErrorTemplate = new CFileTracker;

				if (RUNNING_ONLINE_TS())
					m_pTrackErrorTemplate->AddFile(m_strErrorTemplatePath);

				UNLOCKOBJECT();
				ReadErrorTemplate();
				LstFileDrivesTopics();
			}
			else
			{
				UNLOCKOBJECT();

				if (m_pTrackLst && m_pTrackLst->Changed())
					LstFileDrivesTopics();

				if (m_pTrackErrorTemplate && m_pTrackErrorTemplate->Changed( false ))
					ReadErrorTemplate();
			}

			LOCKOBJECT();
			for (vector<CTopicFileTracker>::iterator itTopicFiles = m_arrTrackTopic.begin();
				itTopicFiles != m_arrTrackTopic.end();
				itTopicFiles ++
			)
			{
#ifdef LOCAL_TROUBLESHOOTER
				if (m_bDirPathChanged)
#else
				if (itTopicFiles->Changed())
#endif
					m_TopicShop.BuildTopic(itTopicFiles->GetTopicInfo().GetNetworkName());
				if (m_bShuttingDown)
					break;
			}

			if (RUNNING_ONLINE_TS())
			{
				// Check if any of the alternate template files need to be reloaded.
				for (vector<CTemplateFileTracker>::iterator itTemplateFiles = m_arrTrackTemplate.begin();
					itTemplateFiles != m_arrTrackTemplate.end();
					itTemplateFiles ++
				)
				{
					if (itTemplateFiles->Changed())
						m_TopicShop.BuildTemplate( itTemplateFiles->GetTemplateName() );
					if (m_bShuttingDown)
						break;
				}
			}

			::ResetEvent(m_hevMonitorRequested);

			SetThreadStatus(eWaitChange);
			UNLOCKOBJECT();

			DWORD dwNotifyObj = WaitForMultipleObjects (
				eNumHandles,
				hList,
				FALSE,			// only need one object, not all
				INFINITE);

			SetThreadStatus(eBeforeWaitChange);

			// Ideally we would update files here.
			// Unfortunately, we get a notification that someone has _started_ 
			//	writing to a file, not that they've finished, so we have to put in
			//	an artificial delay.
			// We must let the system "settle down".
			while (
#ifndef LOCAL_TROUBLESHOOTER
				   dwNotifyObj == WAIT_OBJECT_0+eDirChange &&
#endif
				   !m_bShuttingDown)
			{
#ifndef LOCAL_TROUBLESHOOTER
				// wait for the next change
				if (FindNextChangeNotification( hList[eDirChange] ) == FALSE) 
				{
					// 1) we don't believe this will ever occur
					// 2) After a moderate amount of research, we have no idea how 
					//	to recover from it if it does occur.
					// SO: unless we ever actually see this, we're not going to waste
					//	more time researching a recovery strategy. Just throw an exception,
					//	effectively terminating this thread.
					throw CGenSysException( __FILE__, __LINE__, m_strDirPath, 
											EV_GTS_ERROR_WAIT_NEXT_NFT );
				}
#endif
				SetThreadStatus(eWaitSettle);

				dwNotifyObj = WaitForMultipleObjects (
					eNumHandles,
					hList,
					FALSE,			// only need one object, not all
					m_secsReloadDelay * 1000);	// convert to milliseconds
			}
			if (dwNotifyObj == WAIT_FAILED)
			{
				// 1) we don't believe this will ever occur
				// 2) After a moderate amount of research, we have no idea how 
				//	to recover from it if it does occur.
				// SO: unless we ever actually see this, we're not going to waste
				//	more time researching a recovery strategy. Just throw an exception,
				//	effectively terminating this thread.
				throw CGenSysException( __FILE__, __LINE__, _T("Unexpected Return State"), 
										EV_GTS_DEBUG );
			}
			SetThreadStatus(eRun);
		}
	}
	catch (CGenSysException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), x.GetSystemErrStr(), 
								x.GetErrorCode() ); 
	}
	catch (CGeneralException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), _T("General exception"), 
								x.GetErrorCode() ); 
	}
	catch (bad_alloc&)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
	}
	catch (exception& x)
	{
		// Catch any STL exceptions thrown so that Terminate() is not called.
		CString str;
		CString	ErrStr;
	
		// Attempt to pull any system error code.
		ErrStr.Format( _T("%ld"), ::GetLastError() );

		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								ErrStr, 
								EV_GTS_GENERIC_PROBLEM ); 
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
#ifndef LOCAL_TROUBLESHOOTER
	if (hList[eDirChange] != INVALID_HANDLE_VALUE) 
		::FindCloseChangeNotification( hList[eDirChange] );
#endif
	SetThreadStatus(eExiting);
}

// For general use (not part of DirectoryMonitorTask thread)
// Typically, first call to this comes _before_ first call to SetResourceDirectory;
// This allows caller to set reload delay before triggering any action on 
//	DirectoryMonitorTask thread.
void CDirectoryMonitor::SetReloadDelay(DWORD secsReloadDelay)
{
	LOCKOBJECT();
	m_secsReloadDelay = secsReloadDelay;
	UNLOCKOBJECT();
}

// For general use (not part of DirectoryMonitorTask thread)
// Allows indicating that the resource directory has changed
// Until this is called, the DirectoryMonitorTask thread really won't do anything
void CDirectoryMonitor::SetResourceDirectory(const CString & strDirPath)
{
	LOCKOBJECT();
	if (strDirPath != m_strDirPath)
	{
		m_strDirPath = strDirPath;
		m_strLstPath = strDirPath + LSTFILENAME;
		m_strErrorTemplatePath = strDirPath + k_strErrorTemplateFileName;
		m_bDirPathChanged = true;
		::SetEvent(m_hevMonitorRequested);
	}
	UNLOCKOBJECT();
}

// Must be called on DirectoryMonitorTask thread.  
void CDirectoryMonitor::AckShutDown()
{
	LOCKOBJECT();
	::SetEvent(m_hevThreadIsShut);
	UNLOCKOBJECT();
}

//  Main routine of a thread responsible for monitoring the directory.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CDirectoryMonitor::DirectoryMonitorTask(LPVOID lpParams)
{
	reinterpret_cast<CDirectoryMonitor*>(lpParams)->Monitor();
	reinterpret_cast<CDirectoryMonitor*>(lpParams)->AckShutDown();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\dscread.h ===
//
// MODULE: DSCREAD.H
//
// PURPOSE: dsc reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-19-98
//
// NOTES: 
//	>>> TBD: must deal with case where DSC file is in a CHM. I assume we must unpack it
//	from CHM into a normal directory, then read it with BReadModel.  Exception handling scheme
//	must cope correctly with the fact that the error may be either from the CHM file or the 
//	DSC file.  Maybe use CFileReader to read from the CHM file and write the copy
//	to disk?	JM 1/7/99
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __DSCREAD_H_
#define __DSCREAD_H_

#include "BaseException.h"
#include "stateless.h"
#include "bnts.h"


////////////////////////////////////////////////////////////////////////////////////
// CDSCReaderException
////////////////////////////////////////////////////////////////////////////////////
class CDSCReader;
class CDSCReaderException : public CBaseException
{
public:
	enum eErr {
		eErrRead, 
		eErrGetDateTime,
		eErrUnpackCHM		// for Local Troubleshooter only
	} m_eErr;

protected:
	CDSCReader* m_pDSCReader;

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CDSCReaderException(CDSCReader* reader, eErr err, LPCSTR source_file, int line);
	virtual ~CDSCReaderException();

public:
	virtual void Clear();
};

////////////////////////////////////////////////////////////////////////////////////
// CDSCReader
//	This handles just the reading of BNTS.  CBN packages it up for public consumption.
////////////////////////////////////////////////////////////////////////////////////
class CPhysicalFileReader;
class CDSCReader : public CStateless
{
protected:
	CPhysicalFileReader* m_pPhysicalFileReader;
	CString m_strName;			 // network name
	CString m_strPath;			 // full path and name of dsc file
	BNTS m_Network;
	bool m_bIsRead;				 // network has been loaded
	SYSTEMTIME m_stimeLastWrite; // when the DSC file was last written to
	bool m_bDeleteFile;			// Set to true when a temporary file originating from a 
								// CHM file needs to be deleted in the destructor.

public:
	CDSCReader(CPhysicalFileReader*);
   ~CDSCReader();

public:
	bool    IsRead() const;
	bool    IsValid() const;

public:
	// These functions to be ONLY public interface.
	bool Read();
	void Clear();

#ifdef LOCAL_TROUBLESHOOTER
private:
	bool CHMfileHandler( LPCTSTR path );
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\enumstd.h ===
//
//	enumstd.h:  Standard global enumerations
//

#ifndef _ENUMSTD_H_
#define _ENUMSTD_H_

#include<windows.h>
////////////////////////////////////////////////////////////////////
//	Property flags
////////////////////////////////////////////////////////////////////
const UINT fPropString = 1;			//  Property is a string (!fPropString ==> real)
const UINT fPropArray = 2;			//	Property is an array (!fPropArray  ==> scalar)
const UINT fPropChoice = 4;			//	Property is an enumerated value
const UINT fPropStandard = 8;		//  Property is standard (stored in Registry)
const UINT fPropPersist = 16;		//  Property is persistent (stored in Registry)

////////////////////////////////////////////////////////////////////
//	Definitions to enable usage of "MS_" standard properties
////////////////////////////////////////////////////////////////////
enum ESTDPROP
{
	ESTDP_label,			//  Node troubleshooting label (choice)
	ESTDP_cost_fix,			//  Cost to fix	(real)
	ESTDP_cost_observe,		//  Cost to observe (real)
	ESTDP_category,			//  Category (string)
	ESTDP_normalState,		//  Index of troubleshooting "normal" state (int)
	ESTDP_max				//  End
};

enum ESTDLBL		//  VOI-relative node label
{
	ESTDLBL_other,
	ESTDLBL_hypo,
	ESTDLBL_info,
	ESTDLBL_problem,
	ESTDLBL_fixobs,
	ESTDLBL_fixunobs,
	ESTDLBL_unfix,
	ESTDLBL_config,
	ESTDLBL_max
};


#endif // _ENUMSTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\dscread.cpp ===
//
// MODULE: DSCREAD.CPP
//
// PURPOSE: dsc reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-19-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include "dscread.h"
#include "fileread.h"
#include "event.h"
#include "baseexception.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "CHMfileReader.h"
#endif

////////////////////////////////////////////////////////////////////////////////////
// CDSCReaderException
////////////////////////////////////////////////////////////////////////////////////
// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CDSCReaderException::CDSCReaderException(CDSCReader* reader, eErr err, LPCSTR source_file, int line)
				   : CBaseException(source_file, line),
					 m_pDSCReader(reader),
					 m_eErr(err)
{
}

CDSCReaderException::~CDSCReaderException()
{
}

void CDSCReaderException::Clear()
{
	m_pDSCReader->Clear();
}

////////////////////////////////////////////////////////////////////////////////////
// CDSCReader
//	This handles just the reading of BNTS.  CBN packages it up for public consumption.
////////////////////////////////////////////////////////////////////////////////////
CDSCReader::CDSCReader(CPhysicalFileReader* pPhysicalFileReader)
		  : CStateless(),
			m_pPhysicalFileReader(pPhysicalFileReader),
			m_strPath(pPhysicalFileReader->GetPathName()),
			m_strName(pPhysicalFileReader->GetJustName()),
			m_bIsRead(false),
			m_bDeleteFile(false)
{
	// Arbitrary default for m_stimeLastWrite
    m_stimeLastWrite.wYear = 0;
    m_stimeLastWrite.wMonth = 0;
    m_stimeLastWrite.wDayOfWeek =0;
    m_stimeLastWrite.wDay = 1;
    m_stimeLastWrite.wHour = 0;
    m_stimeLastWrite.wMinute = 0;
    m_stimeLastWrite.wSecond = 0;
    m_stimeLastWrite.wMilliseconds = 0;
}

CDSCReader::~CDSCReader()
{
	delete m_pPhysicalFileReader;
}

bool CDSCReader::IsValid() const
{
	bool ret = false;
	LOCKOBJECT();
	ret = m_Network.BValidNet() ? true : false;
	UNLOCKOBJECT();
	return ret;
}

bool CDSCReader::IsRead() const
{
	bool ret = false;
	LOCKOBJECT();
	ret = m_bIsRead;
	UNLOCKOBJECT();
	return ret;
}

bool CDSCReader::Read()
{
	bool ret = false;

#ifdef LOCAL_TROUBLESHOOTER
	CHMfileHandler( m_strPath );
#endif

	LOCKOBJECT();
	if (m_bIsRead)
		Clear();
	if (m_Network.BReadModel(m_strPath, NULL))
	{
		m_bIsRead = true;
		ret = true;
	}
	UNLOCKOBJECT();

	if (m_bDeleteFile)
		::DeleteFile( m_strPath );

	return ret;
}

void CDSCReader::Clear()
{
	LOCKOBJECT();
	m_Network.Clear();
	m_bIsRead = false;
	UNLOCKOBJECT();
}


#ifdef LOCAL_TROUBLESHOOTER
// Function called from the ctor to handle the checking and optionally writing out
// of a CHM file to a temporary file.
bool CDSCReader::CHMfileHandler( LPCTSTR path )
{
	bool bRetVal= false;

	if (CCHMFileReader::IsCHMfile( m_strPath ))
	{
		CString strContent;
		CFileReader file_reader(m_pPhysicalFileReader, false/*don't delete physical reader*/);

		// read file from inside CHM
		if (!file_reader.Read())
			return bRetVal;

		file_reader.GetContent(strContent);

		// Build the temporary file name.
		TCHAR	szTempDir[ _MAX_DIR ];
		::GetTempPath( sizeof( szTempDir ), szTempDir );
		
		CString strTmpFName= szTempDir;
		strTmpFName+= file_reader.GetJustNameWithoutExtension();
		strTmpFName+= _T(".");
		strTmpFName+= file_reader.GetJustExtension();

		// Open the temporary file and write out the contents of the CHM file.
		HANDLE hTmpFile= ::CreateFile(	strTmpFName,
										GENERIC_WRITE,
										0,	// No Sharing.
										NULL,
										CREATE_ALWAYS,
										FILE_ATTRIBUTE_TEMPORARY,
										NULL );
		if (INVALID_HANDLE_VALUE != hTmpFile)
		{
			DWORD dwBytesWritten;
			
			if (!::WriteFile( hTmpFile, (LPCTSTR)strContent, strContent.GetLength(), &dwBytesWritten, NULL))
			{
				// >>>	Need to consider what we should do in this case.
			}
			else
			{
				bRetVal= true;
			}
			::CloseHandle( hTmpFile );
		}

		if (bRetVal)
		{
			// Reassign the path to the temporary file.
			m_strPath= strTmpFName;

			// Set the delete flag to true.
			m_bDeleteFile= true;
		}
	}
	return( bRetVal );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\dirmonitor.h ===
//
// MODULE: DirMonitor.h
//
// PURPOSE: Monitor changes to LST, DSC, HTI, BES files.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-17-98
//
// NOTES: 
//	1.  It would be equally appropriate for CDirectoryMonitor to inherit from CTopicShop 
//		instead of having a member of type CDirectoryMonitor.  Really an arbitrary choice.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-17-98	JM
//

#if !defined(AFX_DIRMONITOR_H__493CF34D_4E79_11D2_95F8_00C04FC22ADD__INCLUDED_)
#define AFX_DIRMONITOR_H__493CF34D_4E79_11D2_95F8_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "TopicShop.h"
#include "FileTracker.h"

class CTopicFileTracker: public CFileTracker
{
private:
	CTopicInfo m_topicinfo;
public:
	CTopicFileTracker();
	~CTopicFileTracker();
	void AddTopicInfo(const CTopicInfo & topicinfo);
	const CTopicInfo & GetTopicInfo() const;
};

class CTemplateFileTracker: public CFileTracker
{
private:
	CString m_strTemplateName;
public:
	CTemplateFileTracker();
	~CTemplateFileTracker();
	void AddTemplateName( const CString & strTemplateName );
	const CString& GetTemplateName() const;
};

const CString k_strErrorTemplateFileName = _T("ErrorTemplate.hti");
const CString k_strDefaultErrorTemplateBefore = 
	_T("<HTML><HEAD><TITLE>AP GTS Error</TITLE></HEAD>")
	_T("<BODY BGCOLOR=#FFFFFF><H1>AP GTS reports an Error</H1>");
const CString k_strErrorTemplateKey =  _T("$Error");
const CString k_strDefaultErrorTemplateAfter = _T("</BODY></HTML>");

class CDirectoryMonitor : public CStateless
{
public:
	enum ThreadStatus{eBeforeInit, eFail, eWaitDirPath, eWaitChange, eWaitSettle, 
		eRun, eBeforeWaitChange, eExiting};
	static CString ThreadStatusText(ThreadStatus ts);
private:
	CTopicShop & m_TopicShop;				
	CSimpleTemplate * m_pErrorTemplate;		// template for reporting error messages (regardless
											//	of topic)
	CString m_strDirPath;					// Directory to monitor
	bool m_bDirPathChanged;
	CString m_strLstPath;					// LST file (always in directory m_strDirPath)
	CString m_strErrorTemplatePath;			// Error template file (always in directory m_strDirPath)
	CFileTracker * m_pTrackLst;				
	CFileTracker * m_pTrackErrorTemplate;				
	vector<CTopicFileTracker> m_arrTrackTopic;
	vector<CTemplateFileTracker> m_arrTrackTemplate;
	CAPGTSLSTReader * m_pLst;				// current LST file contents
	HANDLE m_hThread;
	HANDLE m_hevMonitorRequested;			// event to wake up DirectoryMonitorTask
											// this allows it to be wakened other than
											// by the directory change event.  Currently used
											// for shutdown or change of directory.
	HANDLE m_hevThreadIsShut;				// event just to indicate exit of DirectoryMonitorTask thread
	bool m_bShuttingDown;					// lets topic directory monitor thread know we're shutting down
	DWORD m_secsReloadDelay;				// number of second to let directory "settle down"
											// before we start to update topics.
	DWORD m_dwErr;							// status from starting the thread
	ThreadStatus m_ThreadStatus;
	time_t m_time;							// time last changed ThreadStatus.  Initialized
											// to zero ==> unknown
	CString m_strTopicName;					// This string is ignored in the Online Troubleshooter.
											// Done under the guise of binary compatibility.

public:
	CDirectoryMonitor(CTopicShop & TopicShop, const CString& strTopicName );	// strTopicName is ignored in the Online Troubleshooter.
																				// Done under the guise of binary compatibility.
	~CDirectoryMonitor();
	void SetReloadDelay(DWORD secsReloadDelay);
	void SetResourceDirectory(const CString & strDirPath);
	void CreateErrorPage(const CString & strError, CString& out) const;
	DWORD GetStatus(ThreadStatus &ts, DWORD & seconds) const;
	void AddTemplateToTrack( const CString& strTemplateName );
private:
	CDirectoryMonitor();		// do not instantiate

	void SetThreadStatus(ThreadStatus ts);

	// just for use by own destructor
	void ShutDown();

	// functions for use by the DirectoryMonitorTask thread.
	void Monitor();
	void LstFileDrivesTopics();
	void ReadErrorTemplate();
	void AckShutDown();

	// main function of the DirectoryMonitorTask thread.
	static UINT WINAPI DirectoryMonitorTask(LPVOID lpParams);
};

#endif // !defined(AFX_DIRMONITOR_H__493CF34D_4E79_11D2_95F8_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef	_DEBUG
#ifdef	__cplusplus

#include "cstd.h"

class	INI
{
  public:
	static UINT 	DtgProfileString( const TCHAR *szValue,
									  const TCHAR *szDefault,
									  TCHAR *szResult,
									  INT cbResult,
									  const TCHAR *szSection = _szSection );
	
	static UINT 	DtgProfileInt( const TCHAR *szValue,
								   INT iDefault,
								   const TCHAR *szSection = _szSection );
								
	static const TCHAR*	SzDebugSection () 		{ return _szSection  ; }
	static const TCHAR*	SzToolSection () 		{ return _szSection  ; }
	
	static BOOL 	DtgProfileTestDbgFlag(UINT fDbgFlag, BOOL fOr);
	
	static BOOL		FExitOnAssert()
	{
		return DtgProfileInt(_szAssertExit, bTrue);
	}

	static UINT		CAssertToPost()
	{
		return DtgProfileInt(_szAssertCount, 10);
	}

	static BOOL		FAssertOnLeak()
	{
		return DtgProfileInt(_szAssertMemLeak, bTrue);
	}
	
	static BOOL		FDebugFlag()
	{
		return DtgProfileInt(_szActive, bFalse);
	}

	static VOID		WriteCallocStop(UINT cAlloc);

	static UINT		CallocStopRead()
	{
		return DtgProfileInt(_szCallocStop, 0);
	}
	
  private:
	static const TCHAR*		_szName;
	static const TCHAR*		_szSection;
	static const TCHAR*		_szToolSection;
	static const TCHAR*		_szActive;
	static const TCHAR*		_szAssertExit;
	static const TCHAR*		_szAssertCount;
	static const TCHAR*		_szAssertMemLeak;
	static const TCHAR*		_szDebugFlag;
	static const TCHAR*		_szCallocStop;
};
#endif
#endif

#define Assert(cond)			AssertSz(cond, #cond)

VOID	DebugAppExit();

//  Return TRUE if the given bit(s) are on in the debug flag.
//  If 'fOr', any bit returns TRUE; if !fOr all bits must match.
//extern BOOL DtgProfileTestDbgFlag ( UINT fDbgFlag, BOOL fOr = TRUE );

//  Return just the file name from a possibly full path.
extern const char * DtgDbgReduceFileName ( const char * pszFileName ) ;

#ifdef	_DEBUG
	typedef UINT LINE;

	#define	AssertData()			static SZ	__file__ = __FILE__

	extern  VOID    PrintFileLine(SZ, UINT);
	extern  VOID	 AssertFailed(SZC szFile, LINE line, SZC szCond, BOOL bFatal);
	extern  VOID    DBVPrintf(SZ, ...);
	extern  VOID	 CheckHeap();
	extern  VOID    NYI();
	extern  VOID 	 NotReached();
	extern  BOOL    fDebug;

	#if defined(MSBN)	
		#define AssertSafeAlloc(count,typnam) \
			 AssertSzFatal((long) count * sizeof(typnam) < 65535L,\
			"Attempt to allocate > 64K in block")
		#define	DebugMSBN(x)		x
	#else
		#define AssertSafeAlloc(count, typnam)
		#define	DebugMSBN(x)
	#endif
	// Assert-with-messge macro; allows continuation skipping problem
	#define AssertSz(cond, sz)\
		if (!(cond))\
			AssertFailed(__file__, __LINE__, sz, fFalse);\
		else
		
	//  Assert-with-message macro; forces program termination
	#define AssertSzFatal(cond, sz)\
		if (!(cond))\
			AssertFailed(__file__, __LINE__, sz, fTrue);\
		else

	#define Verify(x)               Assert(x)
	#define Debug(x)				x

	#define DBPrintf(fLevel, arglist)\
		((fDebug & fLevel) ? (PrintFileLine(__FILE__, __LINE__),\
               	(DBVPrintf arglist),\
				 DBVPrintf("\r\n")) : 0)\

#else		// DEBUG

	//	Null definitions for debug-message functions
	#define AssertSafeAlloc(count, typnam)
	#define	AssertData()
	#define AssertSz(cond, sz)
	#define AssertSzFatal(cond, sz)
	#define Verify(cond)			cond
	#define Debug(x)
	#define	DebugMSBN(x)
	#define DBPrintf(x, y)
	#define	CheckHeap()
	#define	NYI()
	#define	NotReached()
	#define Trace(szFunc)
	
#endif		// _DEBUG

#endif		// _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\event.h ===
//
// MODULE: Event.h
//
// PURPOSE: Interface for class CEvent: Event Logging
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/18/98		JM		Abstracted as a class.  Previously, global.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENT_H__C3B8EE73_4F15_11D2_95F9_00C04FC22ADD__INCLUDED_)
#define AFX_EVENT_H__C3B8EE73_4F15_11D2_95F9_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsevt.h"
#include "ApgtsCounters.h"

// event name (goes under application to form a registry key)
#define REG_EVT_ITEM_STR	_T("APGTS")


class CEvent  
{
friend class CRegistryMonitor;	// just so this can set m_bLogAll
private: 
	static bool s_bUseEventLog;
	static bool s_bLogAll;
	static CAbstractCounter * const s_pcountErrors;
public:
	static void SetUseEventLog(bool bUseEventLog);
	static void ReportWFEvent(
		LPCTSTR string1,
		LPCTSTR string2,
		LPCTSTR string3,
		LPCTSTR string4,
		DWORD eventID);
};

#endif // !defined(AFX_EVENT_H__C3B8EE73_4F15_11D2_95F9_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\filechange.cpp ===
// FileChange.cpp: implementation of the CFileChange class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FileChange.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileChange::CFileChange()
{

}

CFileChange::~CFileChange()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\event.cpp ===
//
// MODULE: Event.cpp
//
// PURPOSE: Fully implements class CEvent: Event Logging
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/18/98		JM		Abstracted as a class.  Previously, global.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Event.h"

bool CEvent::s_bUseEventLog = false;// Online Troubleshooter, will promptly set this 
									//	true in DLLMain.  For Local Troubleshooter,
									//	we leave this false.
bool CEvent::s_bLogAll = true;		// can be changed by RegistryMonitor
CAbstractCounter * const CEvent::s_pcountErrors = &(g_ApgtsCounters.m_LoggedErrors);

inline WORD evtype(DWORD e) {return (1 << (3 - ((e >> 30))));}
inline WORD evcode(DWORD e) {return (WORD)(e & 0xFFFF);}


/*static*/ void CEvent::SetUseEventLog(bool bUseEventLog)
{
	s_bUseEventLog = bUseEventLog;
}

// ReportWFEvent (Based on Microsoft code)
//
// report an event to the NT event watcher
// pass 1, 2 or 3 strings
//
// no return value
// NOTE: inefficient: could RegisterEventSource in DLLMain code for DLL_PROCESS_ATTACH
//	& unregister in DLL_PROCESS_DETACH.  Then could use handle as a global.
/* static */ void CEvent::ReportWFEvent(
			LPCTSTR string1,	// if there is a throw, this is throw file & line
								// otherwise, file and line where ReportWFEvent is called
			LPCTSTR string2,	// always file and line where ReportWFEvent is called
			LPCTSTR string3,	// use may differ for different log entries
			LPCTSTR string4,	// use may differ for different log entries
			DWORD eventID) 
{
	if (!s_bUseEventLog)
		return;

	HANDLE hEvent;
	LPCTSTR pszaStrings[4];
	WORD cStrings;

	WORD type = evtype(eventID);
	WORD code = evcode(eventID);

	if (s_bLogAll 
	|| type == EVENTLOG_ERROR_TYPE
	|| type == EVENTLOG_WARNING_TYPE
	|| code == EV_GTS_PROCESS_START
	|| code == EV_GTS_PROCESS_STOP)
	{
		cStrings = 0;
		if ((pszaStrings[0] = string1) && (string1[0])) 
			cStrings = 1;
		if ((pszaStrings[1] = string2) && (string2[0])) 
			cStrings = 2;
		if ((pszaStrings[2] = string3) && (string3[0])) 
			cStrings = 3;
		if ((pszaStrings[3] = string4) && (string4[0])) 
			cStrings = 4;
		if (cStrings == 0)
			return;
		
		hEvent = ::RegisterEventSource(
						NULL,		// server name for source (NULL means this computer)
						REG_EVT_ITEM_STR);		// source name for registered handle  
		if (hEvent) 
		{
			::ReportEvent(hEvent,				// handle returned by RegisterEventSource 
						type,					// event type to log 
						0,						// event category 
						eventID,				// event identifier 
						0,						// user security identifier (optional) 
						cStrings,				// number of strings to merge with message  
						0,						// size of binary data, in bytes
						(LPCTSTR *)pszaStrings,	// array of strings to merge with message 
						NULL);		 			// address of binary data 
			::DeregisterEventSource(hEvent);
		}
		if (evtype(eventID) == EVENTLOG_ERROR_TYPE)
			s_pcountErrors->Increment();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\filechange.h ===
// FileChange.h: interface for the CFileChange class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILECHANGE_H__441362B3_4BE9_11D2_95F5_00C04FC22ADD__INCLUDED_)
#define AFX_FILECHANGE_H__441362B3_4BE9_11D2_95F5_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CFileChange  
{
public:
	CFileChange();
	virtual ~CFileChange();

};

#endif // !defined(AFX_FILECHANGE_H__441362B3_4BE9_11D2_95F5_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\fileread.cpp ===
//
// MODULE: FILEREAD.CPP
//
// PURPOSE: file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include <algorithm>
#include "fileread.h"
#include "event.h"
#include "CharConv.h"
#include "apgtsassert.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

#define STR_ALLOC_SIZE  1024
#define FORWARD_SLASH	_T('/')
#define BACK_SLASH      _T('\\')


////////////////////////////////////////////////////////////////////////////////////
// CFileReaderException
////////////////////////////////////////////////////////////////////////////////////
// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CFileReaderException::CFileReaderException(CPhysicalFileReader* reader, eErr err, LPCSTR source_file, int line)
					: CBaseException(source_file, line),
					  m_pFileReader(reader),
					  m_eErr(err)
{
}

CFileReaderException::CFileReaderException(CFileReader* reader, eErr err, LPCSTR source_file, int line)
					: CBaseException(source_file, line),
					  m_pFileReader(reader->GetPhysicalFileReader()),
					  m_eErr(err)
{
}


CFileReaderException::~CFileReaderException()
{
}

void CFileReaderException::CloseFile()
{
	if (m_eErr == eErrClose || m_eErr == eErrGetSize || m_eErr == eErrRead || m_eErr == eErrAllocateToRead)
	   m_pFileReader->CloseHandle();
}

void CFileReaderException::LogEvent() const
{
	CBuildSrcFileLinenoStr CatchLoc( __FILE__, __LINE__ );
	CString	strErr;

	// Format the error code as a string.
	switch (m_eErr)
	{
		case eErrOpen: 
				strErr= _T("Open"); 
				break;
		case eErrClose: 
				strErr= _T("Close"); 
				break;
		case eErrRead: 
				strErr= _T("Read"); 
				break;
		case eErrAllocateToRead: 
				strErr= _T("ReadAllocate"); 
				break;
		case eErrGetSize: 
				strErr= _T("GetSize"); 
				break;
		case eErrGetDateTime: 
				strErr= _T("GetDateTime"); 
				break;
		case eErrParse: 
				strErr= _T("Parse"); 
				break;
		default:
				strErr.Format( _T("Error code of %d"), m_eErr );
	}

	CEvent::ReportWFEvent(	GetSrcFileLineStr(), 
							CatchLoc.GetSrcFileLineStr(), 
							strErr, 
							m_pFileReader->GetNameToLog(), 
							EV_GTS_FILEREADER_ERROR );
}

////////////////////////////////////////////////////////////////////////////////////
// CAbstractFileReader
// This class manages a file, which is initially read into a memory buffer, then
//	copied into a stream.
// It must be further specialized to handle a file from ordinary disk storage vs. a 
//	file from a CHM
////////////////////////////////////////////////////////////////////////////////////
// we return just pure path, without <name>.<ext> and without slashes in the tail
/*static*/ CString CAbstractFileReader::GetJustPath(const CString& full_path)
{
	CString tmp = full_path;

	tmp.TrimLeft();
	tmp.TrimRight();

	int indexOfSlash = tmp.ReverseFind(BACK_SLASH);

	if (indexOfSlash == -1)
		indexOfSlash = tmp.ReverseFind(FORWARD_SLASH);

	if (indexOfSlash == -1)
		// Unable to locate the path, return an empty string.
		return _T(""); 
	else
		return tmp.Left(indexOfSlash);
}

// we return just <name>.<ext> without any path information.  If there's no slash and no dot
//	anywhere, we presume this is not a file name.
/*static*/ CString CAbstractFileReader::GetJustName(const CString& full_path)
{
	CString tmp = full_path;
	LPTSTR ptr = NULL;

	tmp.TrimLeft();
	tmp.TrimRight();

	int indexOfSlash = tmp.ReverseFind(BACK_SLASH);

	if (indexOfSlash == -1)
		indexOfSlash = tmp.ReverseFind(FORWARD_SLASH);

	if (indexOfSlash == -1)
	{
		if (tmp.Find("."))
			return tmp; // full_path is a file name
		else
			// Unable to detect a file name, return an empty string.
			return _T(""); 
	}
	else
		return tmp.Mid(indexOfSlash + 1);
}

/*static*/ CString CAbstractFileReader::GetJustNameWithoutExtension(const CString& full_path)
{
	CString tmp = GetJustName(full_path);
	int point = tmp.Find(_T('.'));

	if (-1 != point)
		return tmp.Left(point);
	return tmp;
}

/*static*/ CString CAbstractFileReader::GetJustExtension(const CString& full_path)
{
	CString tmp = GetJustName(full_path);
	int point = tmp.Find(_T('.'));

	if (-1 != point)
		return tmp.Right(tmp.GetLength() - point - 1);
	return _T("");
}

/*static*/ bool CAbstractFileReader::GetFileTime(const CString& full_path, EFileTime type, time_t& out)
{
	WIN32_FIND_DATA find_data;
	FILETIME fileTime, localTime;
    SYSTEMTIME sysTime;
    struct tm atm;
	HANDLE hLocFile;
	bool bRet= false;
	
	hLocFile= ::FindFirstFile(full_path, &find_data);
	if (INVALID_HANDLE_VALUE == hLocFile)
		return( bRet );

	if (type == eFileTimeCreated)
		fileTime = find_data.ftCreationTime;
	if (type == eFileTimeModified)
		fileTime = find_data.ftLastWriteTime;
	if (type == eFileTimeAccessed)
		fileTime = find_data.ftLastAccessTime;

    // first convert file time (UTC time) to local time
    if (::FileTimeToLocalFileTime(&fileTime, &localTime)) 
	{
	    // then convert that time to system time
		if (::FileTimeToSystemTime(&localTime, &sysTime))
		{
			if (!(sysTime.wYear < 1900))
			{
				atm.tm_sec = sysTime.wSecond;
				atm.tm_min = sysTime.wMinute;
				atm.tm_hour = sysTime.wHour;
				ASSERT(sysTime.wDay >= 1 && sysTime.wDay <= 31);
				atm.tm_mday = sysTime.wDay;
				ASSERT(sysTime.wMonth >= 1 && sysTime.wMonth <= 12);
				atm.tm_mon = sysTime.wMonth - 1; // tm_mon is 0 based
				ASSERT(sysTime.wYear >= 1900);
				atm.tm_year = sysTime.wYear - 1900; // tm_year is 1900 based
				atm.tm_isdst = -1; // automatic computation of daylight saving time
				out = mktime(&atm);
				bRet= true;
			}
		}
	}

	::FindClose( hLocFile );

	return( bRet );
}

CAbstractFileReader::CAbstractFileReader()
		   : CStateless(),
			 m_bIsValid(true),
			 m_bIsRead(false)
{
}

CAbstractFileReader::~CAbstractFileReader()
{
}

// returns true if the referenced file can be opened and closed.  
// No problem if the file is already open: it is opened with FILE_SHARE_READ access.
bool CAbstractFileReader::Exists()
{
	bool bRet= false;

	try 
	{
		LOCKOBJECT();
		Open();
		Close();
		bRet= true;
	}
	catch (CFileReaderException& exc) 
	{
		exc.CloseFile();
		exc.LogEvent();
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();

	return( bRet );
}

// go back to the file itself for data.
bool CAbstractFileReader::Read()
{
	LPTSTR pBuf= NULL;		 // if non-null, points to an allocated buffer containing
							 // an in-memory copy of this file.
	try 
	{
		LOCKOBJECT();
		Open();
		ReadData(&pBuf);
		Close();
		StreamData(&pBuf);
		Parse(); // if this parsing is OK, the parsing in all siblings is presumed to be OK
		m_bIsRead = true;
		m_bIsValid = true;
	}
	catch (CFileReaderException& exc) 
	{
		exc.CloseFile();
		m_bIsValid = false;
		try 
		{
			if (UseDefault())
			{
				Parse(); // if this parsing is OK, the parsing in all siblings is presumed to be OK
				m_bIsRead = true;		// OK, so  maybe we're lying.  Close enough to true.
				m_bIsValid = true;
			}
		}
		catch (CFileReaderException&) 
		{
			// Catch any potential exceptions from attempt to access default content.
			// This exception would be logged below so there is no need to log it here.
		}

		if (!m_bIsValid)
		{
			// Only log the event if the attempt to access default content failed.
			exc.LogEvent();
		}
	}
	catch (bad_alloc&)
	{
		// Memory allocation failure.
		m_bIsValid = false;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}

	if (pBuf)
		delete [] pBuf;

	// Given the array of catch blocks above, it is assumed that this call to unlock the
	//	object will always been called prior to exiting this function.
	UNLOCKOBJECT();

	return m_bIsValid;
}

////////////////////////////////////////////////////////////////////////////////////
// CPhysicalFileReader
////////////////////////////////////////////////////////////////////////////////////
CPhysicalFileReader::CPhysicalFileReader()
{
}

CPhysicalFileReader::~CPhysicalFileReader()
{
}

/*static*/ CPhysicalFileReader * CPhysicalFileReader::makeReader( const CString& strFileName )
{
#ifdef LOCAL_TROUBLESHOOTER
	if (CCHMFileReader::IsCHMfile( strFileName ))
		return dynamic_cast<CPhysicalFileReader*>(new CCHMFileReader( strFileName ));
	else
#endif
		return dynamic_cast<CPhysicalFileReader*>(new CNormalFileReader( strFileName ));
}

////////////////////////////////////////////////////////////////////////////////////
// CNormalFileReader
// This class manages a file from ordinary storage.
// Do not use this for files within a CHM
////////////////////////////////////////////////////////////////////////////////////
CNormalFileReader::CNormalFileReader(LPCTSTR path)
		   : m_strPath(path),
			 m_hFile(NULL)
{
}

CNormalFileReader::~CNormalFileReader()
{
}

/* virtual */ void CNormalFileReader::Open()
{
	if (INVALID_HANDLE_VALUE == 
		(m_hFile = ::CreateFile( m_strPath, 
							 GENERIC_READ, 
							 FILE_SHARE_READ, 
							 NULL,
							 OPEN_EXISTING,
							 FILE_ATTRIBUTE_NORMAL,
							 NULL )) )
	{
#ifdef _DEBUG
		DWORD err = GetLastError();
#endif
		throw CFileReaderException( this, CFileReaderException::eErrOpen, __FILE__, __LINE__ );
	}
}

// returns true on success
// doesn't throw exception, therefore may be used by exception class.
/* virtual */ bool CNormalFileReader::CloseHandle()
{
	// if it's not open, say we closed successfully.
	if (!m_hFile)
		return true;

	return ::CloseHandle(m_hFile) ? true : false;
}


/* virtual */ void CNormalFileReader::ReadData(LPTSTR * ppBuf)
{
	DWORD dwSize =0, dwRead =0;

	if (*ppBuf) 
	{
		delete [] *ppBuf;
		*ppBuf = NULL;
	}

	if (0xFFFFFFFF == (dwSize = ::GetFileSize(m_hFile, NULL)))
	{
		throw CFileReaderException(this, CFileReaderException::eErrOpen, __FILE__, __LINE__);
	}

	// Handle this memory allocation like all others in the program.
	try
	{
		*ppBuf = new TCHAR[dwSize+1];
		//[BC-03022001] - addd check for NULL ptr to satisfy MS code analysis tool.
		if(!*ppBuf)
			throw bad_alloc();
	}
	catch (bad_alloc&)
	{
		throw CFileReaderException(this, CFileReaderException::eErrAllocateToRead, __FILE__, __LINE__);
	}

	if (!::ReadFile(m_hFile, *ppBuf, dwSize, &dwRead, NULL) || dwSize != dwRead)
	{
		throw CFileReaderException(this, CFileReaderException::eErrRead, __FILE__, __LINE__);
	}
		
	(*ppBuf)[dwSize] = 0;
}

CString CNormalFileReader::GetJustPath() const
{
	return CAbstractFileReader::GetJustPath(m_strPath);
}

CString CNormalFileReader::GetJustName() const
{
	return CAbstractFileReader::GetJustName(m_strPath);
}

CString CNormalFileReader::GetJustNameWithoutExtension() const
{
	return CAbstractFileReader::GetJustNameWithoutExtension(m_strPath);
}

CString CNormalFileReader::GetJustExtension() const
{
	return CAbstractFileReader::GetJustExtension(m_strPath);
}

bool CNormalFileReader::GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const
{
	return CAbstractFileReader::GetFileTime(m_strPath, type, out);
}

// name to log on exceptions.  This implementation will be correct for the normal file system,
//	but may need to be overridden for CHM.
CString CNormalFileReader::GetNameToLog() const
{
	return GetPathName();
}

////////////////////////////////////////////////////////////////////////////////////
// CFileReader
// This class manages a file, which is initially read into a memory buffer, then
//	copied into a stream.
////////////////////////////////////////////////////////////////////////////////////

CFileReader::CFileReader(CPhysicalFileReader * pPhysicalFileReader, bool bDeletePhysicalFileReader /*=true*/)
		   : CAbstractFileReader(),
			 m_pPhysicalFileReader(pPhysicalFileReader),
			 m_bDeletePhysicalFileReader(bDeletePhysicalFileReader)
{
}

CFileReader::~CFileReader()
{
	if (m_pPhysicalFileReader)
		if (m_bDeletePhysicalFileReader)
			delete m_pPhysicalFileReader;
}

// move the data out of ppBuf (which will be deleted) to m_StreamData
/* virtual */ void CFileReader::StreamData(LPTSTR * ppBuf)
{
	m_StreamData.str(*ppBuf);
	delete [] (*ppBuf);
	*ppBuf = NULL;
}

// Placeholder.  Classes that inherit from CFileReader can define parsing to happen
//	immediately after the file is read.
/* virtual */ void CFileReader::Parse()
{
	// we have no idea how to parse here
}

// Placeholder.  Classes that inherit from CFileReader can define default file contents
//	to use if file can't be read or what is read can't be parsed.
// Should return true if there's a default to use.
/* virtual */ bool CFileReader::UseDefault()
{
	// we have no default to use here
	return false;
}

void CFileReader::Close()
{
	if (!m_pPhysicalFileReader->CloseHandle())
		throw CFileReaderException(m_pPhysicalFileReader, CFileReaderException::eErrClose, __FILE__, __LINE__);
}

// Data access in form of tstring.  returns reference to its argument as a convenience.
tstring& CFileReader::GetContent(tstring& out)
{
	out = m_StreamData.rdbuf()->str();
	return out;
}

// Data access in form of CString.  returns reference to its argument as a convenience.
CString& CFileReader::GetContent(CString& out)
{
	out = m_StreamData.rdbuf()->str().c_str();
	return out;
}

////////////////////////////////////////////////////////////////////////////////////
// CTextFileReader
// Specialize CFileReader to a text file
////////////////////////////////////////////////////////////////////////////////////
/*static*/ bool CTextFileReader::IsAmongSeparators(TCHAR separatorCandidate, const vector<TCHAR>& separator_arr)
{
	vector<TCHAR>::const_iterator res = find(separator_arr.begin(), separator_arr.end(), separatorCandidate);
	return res != separator_arr.end();
}

// OUTPUT out is a vector of "words"
// NOTE: words are strings that do not contain whitespaces
/*static*/ void CTextFileReader::GetWords(const CString& text, vector<CString>& out, const vector<TCHAR>& separator_arr)
{
	LPTSTR begin =(LPTSTR)(LPCTSTR)text, end =(LPTSTR)(LPCTSTR)text;

	while (*begin)
	{
		if (!IsAmongSeparators(*begin, separator_arr))
		{
			end = begin;
			while (*end &&
				   !IsAmongSeparators(*end, separator_arr)
				  )
				end++;
			if (end != begin)
			{
				try
				{
					TCHAR* buf= new TCHAR[end-begin+1]; 
					//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
					if(buf)
					{
						_tcsncpy(buf, begin, end-begin);
						buf[end-begin] = 0;
						out.push_back(buf);
						delete [] buf;
					}
					else
					{
						throw bad_alloc();
					}
				}
				catch (bad_alloc&)
				{
					// Memory allocation failure, log it and rethrow exception.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
					throw;
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log and rethrow exception.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
					throw;
				}
			}
			if (!*end)
				end--;
			begin = end;

		}
		begin++;
	}
}

/*static*/ long CTextFileReader::GetPos(tistream& streamData)
{
	return streamData.tellg();
}

/*static*/ bool CTextFileReader::SetPos(tistream& streamData, long pos)
{
	long eof_pos = 0;
	long old_pos = streamData.tellg();
	bool eof_state = streamData.eof();

	streamData.seekg(0, ios_base::end);
	eof_pos = streamData.tellg();

	if (pos <= eof_pos)
	{
		if (eof_state)
			streamData.clear(~ios_base::eofbit & streamData.rdstate()); // clear eof bit
		streamData.seekg(pos);
		return true;
	}
	else
	{
		streamData.seekg(old_pos);
		return false;
	}
}

// It get line of text from current position in stream until '\r' or EOF - into "str"
//  Stream is positioned to the beginning of next line or to EOF.
/*static*/ bool CTextFileReader::GetLine(tistream& streamData, CString& str)
{
	bool	bRetVal= false;
	TCHAR	buf[ STR_ALLOC_SIZE ];
	
	str= _T("");
	while (!streamData.eof())
	{
		buf[STR_ALLOC_SIZE-1] = 1; // will be NULL if buffer is completely filled up

		{	// start getline block
			long before_getline_pos = GetPos(streamData);

			streamData.getline(buf, STR_ALLOC_SIZE, _T('\r'));

			if (streamData.fail()) 
			{   // getline ran into empty line, and at this point
				//  failbit is set, and current input pointer is set to -1
				//  we are trying to recover this, since there is nothing 
				//  extraodinary to have line empty
				streamData.clear(~ios_base::failbit & streamData.rdstate());

				// Check if buffer was filled up completely.  If so, we do not want
				//	to reposition the file pointer as this is a completely valid 
				//	situation.  We will output this piece of the line and then will
				//	grab the next piece of the line only appending a newline character 
				//	once we have read in the entire line.
				if (buf[STR_ALLOC_SIZE-1] != NULL ) // buf was not filled up completely
					streamData.seekg(before_getline_pos); // we do not use SetPos, since SetPos
													  //  might clear eofbit, but in this situation
													  //  we do not want it.
			}
		}	// end getline block

		if (streamData.eof())
		{
			str += buf;
			bRetVal= true;
			break;
		}
		else 
		{	
			TCHAR element = 0;

			str += buf;

			if (streamData.peek() == _T('\n')) 
			{	// LINE FEED is next
				streamData.get(element); // just extract it from stream
				if (ios_base::eofbit & streamData.rdstate())
				{
					bRetVal= true;
					break;
				}
			}
			else
			{   // it was a standing along '\r'...
				// Check if we have a full buffer, if so do not append a newline 
				//	character as we need to grab the rest of the line before appending
				//	the newline character.
				if (buf[STR_ALLOC_SIZE-1] != NULL ) // buf was not filled up completely
					str += _T("\n");
				continue;
			}

			if (buf[STR_ALLOC_SIZE-1] != NULL ) // buf was not filled up completely
			{
				bRetVal= true;
				break;
			}
		}	
	}

	return( bRetVal );
}

// This function finds string in the stream and positions stream to the beginning 
//  of the string if found.
//  "str" should not include '\r''\n' pairs
/*static*/ bool CTextFileReader::Find(tistream& streamData, const CString& str, bool from_stream_begin /*=true*/)
{
	CString buf;
	long savePos = 0, currPos = 0;
	
	savePos = GetPos(streamData);
	if (from_stream_begin)
		SetPos(streamData, 0);

	currPos = GetPos(streamData);
	while (GetLine(streamData, buf))
	{
		long inside_pos = 0;
		if (-1 != (inside_pos = buf.Find(str)))
		{
			SetPos(streamData, currPos + inside_pos);
			return true;
		}
		currPos = GetPos(streamData);
	}
	SetPos(streamData, savePos);
	return false;
}

/*static*/ bool CTextFileReader::NextLine(tistream& streamData)
{
	CString str;
	return GetLine(streamData, str);
}

/*static*/ bool CTextFileReader::PrevLine(tistream& streamData)
{
	long savePos = 0;
	
	savePos = GetPos(streamData);
	SetAtLineBegin(streamData);
	if (GetPos(streamData) > 1)
	{
		SetPos(streamData, GetPos(streamData) - 2L); // skip '\n' and '\r'
		SetAtLineBegin(streamData);
		return true;
	}
	SetPos(streamData, savePos);
	return false;
}

// Positions stream to the beginning of current line.
//  assume that we are NEVER positioned to point to '\n' or '\r'
/*static*/ void CTextFileReader::SetAtLineBegin(tistream& streamData)
{
	while (GetPos(streamData))
	{
		SetPos(streamData, GetPos(streamData) - 1L);
		if (streamData.peek() == _T('\n'))
		{
			if (GetPos(streamData))
			{
				SetPos(streamData, GetPos(streamData) - 1L);
				if (streamData.peek() == _T('\r'))
				{
					SetPos(streamData, GetPos(streamData) + 2L);
					return;
				}
			}
		}
	}
}

CTextFileReader::CTextFileReader(CPhysicalFileReader *pPhysicalFileReader, LPCTSTR szDefaultContents /* = NULL */, bool bDeletePhysicalFileReader /*=true*/ )
			   : CFileReader(pPhysicalFileReader, bDeletePhysicalFileReader),
				 m_strDefaultContents(szDefaultContents ? szDefaultContents : _T(""))
{
}

CTextFileReader::~CTextFileReader()
{
}

long CTextFileReader::GetPos()
{
	return GetPos(m_StreamData);
}

// this function is to be used instead of seekg
//  it clears eof flag if "pos" is not the last
//  position in the file.
bool CTextFileReader::SetPos(long pos)
{
	return SetPos(m_StreamData, pos);
}

bool CTextFileReader::GetLine(CString& str)
{
	return GetLine(m_StreamData, str);
}

bool CTextFileReader::Find(const CString& str, bool from_stream_begin /*=true*/)
{
	return Find(m_StreamData, str, from_stream_begin);
}

void CTextFileReader::SetAtLineBegin()
{
	SetAtLineBegin(m_StreamData);
}

bool CTextFileReader::NextLine()
{
	return NextLine(m_StreamData);
}

bool CTextFileReader::PrevLine()
{
	return PrevLine(m_StreamData);
}

bool CTextFileReader::UseDefault()
{
	if ( ! m_strDefaultContents.IsEmpty() )
	{
		m_StreamData.str((LPCTSTR)m_strDefaultContents);
		return true;
	}
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\filetracker.h ===
//
// MODULE: FileTracker.h
//
// PURPOSE: Abstract classes in support of tracking file changes over time.
//	Interface for CFileToTrack, CFileTracker
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-15-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-15-98	JM
//

#if !defined(AFX_FILETRACKER_H__3942A069_4CB5_11D2_95F6_00C04FC22ADD__INCLUDED_)
#define AFX_FILETRACKER_H__3942A069_4CB5_11D2_95F6_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsstr.h"
#include <vector>
using namespace std;

// ideally, this would be a private class of CFileTracker, but that's incompatible with STL vector.
class CFileToTrack
{
private:
	FILETIME m_ftLastWriteTime;	// zeroed to indicate not yet read; otherwise, file time 
							//	when last checked
	CString m_strPathName;	// full pathname of file to monitor
	bool m_bFileExists;		// when we last checked for the file, did it exist
public:
	CFileToTrack();  	// do not instantiate; exists only so vector can compile

	// The only constructor you should call is:
	CFileToTrack(const CString & strPathName);

	virtual ~CFileToTrack();
	void CheckFile(bool & bFileExists, bool & bTimeChanged, const bool bLogIfMissing= true );

	// to keep vector happy
	bool operator < (const CFileToTrack & x) const {return this->m_strPathName < x.m_strPathName ;};
	bool operator == (const CFileToTrack & x) const {return this->m_strPathName == x.m_strPathName ;};
};

// abstract class. Intended as base class for distinct classes tracking LST files, DSC/BES/HTI files
//	These must provide there own overrides of TakeAction.
class CFileTracker
{
private:
	vector<CFileToTrack> m_arrFile;
public:
	CFileTracker();
	virtual ~CFileTracker();
	void AddFile(const CString & strPathName);
	bool Changed( const bool bLogIfMissing= true );

	// to keep vector happy.  Note that no two CFileTracker's will ever test equal
	//	even if their content is identical.
	bool operator < (const CFileTracker & x) const {return this < &x;};
	bool operator == (const CFileTracker & x) const {return this ==  &x;};
};

#endif // !defined(AFX_FILETRACKER_H__3942A069_4CB5_11D2_95F6_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\fileread.h ===
//
// MODULE: FILEREAD.H
//
// PURPOSE: file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.1		01-08-99	JM		improving abstraction so CHMs can be worked into this.
//

#ifndef __FILEREAD_H_
#define __FILEREAD_H_

#include "BaseException.h"
#include "stateless.h"
#include <sstream>
#include <vector>

using namespace std;

namespace std {
    typedef basic_string<TCHAR> tstring;    
    typedef basic_stringbuf<TCHAR> tstringbuf;    
    typedef basic_istream<TCHAR> tistream;    
    typedef basic_ostream<TCHAR> tostream;    
    typedef basic_iostream<TCHAR> tiostream;    
    typedef basic_istringstream<TCHAR> tistringstream;    
    typedef basic_ostringstream<TCHAR> tostringstream;    
    typedef basic_stringstream<TCHAR> tstringstream;
};

////////////////////////////////////////////////////////////////////////////////////
// CFileReaderException
////////////////////////////////////////////////////////////////////////////////////
class CPhysicalFileReader;
class CFileReader;
class CFileReaderException : public CBaseException
{
public: 
	enum eErr {eErrOpen, 
			   eErrClose, 
			   eErrRead, 
			   eErrAllocateToRead,
			   eErrGetSize,
			   eErrGetDateTime,
			   eErrParse
	} m_eErr;

protected:
	CPhysicalFileReader* m_pFileReader;

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CFileReaderException(CPhysicalFileReader* reader, eErr err, LPCSTR source_file, int line);
	CFileReaderException(CFileReader* reader, eErr err, LPCSTR source_file, int line);
	virtual ~CFileReaderException();

public:
	virtual void CloseFile();
	void LogEvent() const;			// Function used to write CFileReader exceptions to the event log.
};

////////////////////////////////////////////////////////////////////////////////////
// CAbstractFileReader
// This abstract class manages a file, which is initially read into a memory buffer, then
//	copied into a stream.
// It can be renewed from stream without reading file.
// It checks file for existance.
// This class is abstract, in that it doesn't consider whether the file is in normal
//	file storage or in a CHM. It must be specialized to handle those two cases.  Since
//	it must be specialized to one or the other, this class should never be directly instantiated.
////////////////////////////////////////////////////////////////////////////////////
class CAbstractFileReader : public CStateless
{
private:
	bool m_bIsValid;			 // file data is consistent - no errors arose during reading and parsing
	bool m_bIsRead;				 // file has been read

public:
	enum EFileTime {eFileTimeCreated, eFileTimeModified, eFileTimeAccessed};

	// static utilities
	static CString GetJustPath(const CString& full_path);
	static CString GetJustName(const CString& full_path);
	static CString GetJustNameWithoutExtension(const CString& full_path);
	static CString GetJustExtension(const CString& full_path);
	static bool GetFileTime(const CString& full_path, EFileTime type, time_t& out);

public:
	CAbstractFileReader();
   ~CAbstractFileReader();

public:
	virtual CString GetPathName() const =0;
	virtual CString GetJustPath() const =0;
	virtual CString GetJustName() const =0;
	virtual CString GetJustNameWithoutExtension() const =0;
	virtual CString GetJustExtension() const =0;
	virtual bool    GetFileTime(EFileTime type, time_t& out) const =0;

public:
	// I (Oleg) designed these functions to be the only way to perform file access.
	//	That is, you cannot call (say) Open or ReadData.
	// The locking is designed accordingly.
	// In inherited classes there might be function to access results
	//  of reading and parsing - in this case user is responsible for properly 
	//  locking the results while they are being used
	// These functions are NOT intended to be virtual and overridden!
	bool Exists();
	bool Read();
	 
	bool    IsRead() {return m_bIsRead;}
	bool    IsValid() {return m_bIsValid;}

protected:
	virtual void Open()=0;
	virtual void ReadData(LPTSTR * ppBuf) =0;
	virtual void StreamData(LPTSTR * ppBuf)=0;
	virtual void Parse()=0;
	virtual bool UseDefault()=0;
	virtual void Close()=0;  // unlike CPhysicalFileReader::Close(), this throws exception if
							 // it cannot close the file
};

////////////////////////////////////////////////////////////////////////////////////
// CPhysicalFileReader
// This is an abstract class.  Classes that provide physical access to a file should inherit 
//	from this class.  
// A pointer to this class can be used by CFileReader to get a physical instantiation of file 
//	access.  The idea is that CPhysicalFileReader will have one descendant 
//	(CNormalFileReader) to access files in normal directories and another 
//	(CCHMFileReader) to access files drawn from a CHM.
// CHMs don't arise in the Online Troubleshooter, but they do in the Local Troubleshooter.
////////////////////////////////////////////////////////////////////////////////////
class CPhysicalFileReader
{
public:
	CPhysicalFileReader();
	virtual ~CPhysicalFileReader();

	static CPhysicalFileReader * makeReader( const CString& strFileName );

protected:
	friend class CFileReader; 
	friend class CFileReaderException;
	//
	// only CFileReader class is meant to access these functions
	virtual void Open()=0;
	virtual void ReadData(LPTSTR * ppBuf) =0;
	virtual bool CloseHandle()=0;    // doesn't throw exception, therefore may be used by exception class.
	//

public:
	virtual CString GetPathName() const =0;
	virtual CString GetJustPath() const =0;
	virtual CString GetJustName() const =0;
	virtual CString GetJustNameWithoutExtension() const =0;
	virtual CString GetJustExtension() const =0;
	virtual bool    GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const =0;
	virtual CString GetNameToLog() const =0;
};

////////////////////////////////////////////////////////////////////////////////////
// CNormalFileReader
// This class manages a file from ordinary storage.
// Do not use this for files within a CHM
////////////////////////////////////////////////////////////////////////////////////
class CNormalFileReader : public CPhysicalFileReader
{
private:
	CString m_strPath;			 // full path and name
	HANDLE m_hFile;				 // handle corresponding to m_strPath (if open)

public:
	CNormalFileReader(LPCTSTR path);
   ~CNormalFileReader();

protected:
	//
	// only CFileReader class is meant to access these functions
    virtual bool CloseHandle();  // doesn't throw exception, therefore may be used by exception class.
	virtual void Open();
	virtual void ReadData(LPTSTR * ppBuf);
	//

public:
	// return full file path and its components
	CString GetPathName() const {return m_strPath;}
	CString GetJustPath() const;
	CString GetJustName() const;
	CString GetJustNameWithoutExtension() const;
	CString GetJustExtension() const;
	bool    GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const;
	CString GetNameToLog() const;
};

////////////////////////////////////////////////////////////////////////////////////
// CFileReader
// This class manages a file from ordinary storage, which is initially read into a memory buffer, then
//	copied into a stream.
// It can be renewed from stream without reading file.
// It checks file for existance.
// Do not use this for files within a CHM
////////////////////////////////////////////////////////////////////////////////////
class CFileReader : public CAbstractFileReader
{
private:
	CPhysicalFileReader *m_pPhysicalFileReader;
	bool m_bDeletePhysicalFileReader;

public:
	CFileReader(CPhysicalFileReader * pPhysicalFileReader, bool bDeletePhysicalFileReader =true); 
   ~CFileReader();

public:
	// This function exists only so that CFileReaderException can reinterpret a CFileReader as
	//	a CPhysicalFileReader
	CPhysicalFileReader * GetPhysicalFileReader() {return m_pPhysicalFileReader;}

public:
	// return full file path and its components
	CString GetPathName() const {return m_pPhysicalFileReader->GetPathName();}
	CString GetJustPath() const {return m_pPhysicalFileReader->GetJustPath();}
	CString GetJustName() const {return m_pPhysicalFileReader->GetJustName();}
	CString GetJustNameWithoutExtension() const {return m_pPhysicalFileReader->GetJustNameWithoutExtension();}
	CString GetJustExtension() const {return m_pPhysicalFileReader->GetJustExtension();}
	bool    GetFileTime(EFileTime type, time_t& out) const {return m_pPhysicalFileReader->GetFileTime(type, out);}

public:
	tstring& GetContent(tstring&); // Data access in form of tstring
	CString& GetContent(CString&); // Data access in form of CString

protected:
	virtual void Open() {m_pPhysicalFileReader->Open();}
	virtual void ReadData(LPTSTR * ppBuf) {m_pPhysicalFileReader->ReadData(ppBuf);}
	virtual void StreamData(LPTSTR * ppBuf);
	virtual void Parse(); // is empty for this class
	virtual bool UseDefault(); // is empty for this class
	virtual void Close();

protected:
	tistringstream m_StreamData;

};

////////////////////////////////////////////////////////////////////////////////////
// CTextFileReader
// Specialize CFileReader to a text file
////////////////////////////////////////////////////////////////////////////////////
class CTextFileReader : public CFileReader
{
protected:
	static bool IsAmongSeparators(TCHAR separatorCandidate, const vector<TCHAR>& separator_arr);
	CString	m_strDefaultContents; // default contents to use if there is no such file.

public:
	// static utilities
	static void GetWords(const CString& text, vector<CString>& out, const vector<TCHAR>& separators); // extract words from string

	static long GetPos(tistream&);
	static bool SetPos(tistream&, long pos);

	static bool GetLine(tistream&, CString&);
	static bool Find(tistream&, const CString&, bool from_stream_begin =true);
	static bool NextLine(tistream&);
	static bool PrevLine(tistream&);
	static void SetAtLineBegin(tistream&);

public:
	CTextFileReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL, bool bDeletePhysicalFileReader =true);
   ~CTextFileReader();

#ifdef __DEBUG_CUSTOM
	public:
#else
	protected:
#endif
	long GetPos();
	bool SetPos(long pos);

#ifdef __DEBUG_CUSTOM
	public:
#else
	protected:
#endif
	bool GetLine(CString&);
	bool Find(const CString&, bool from_stream_begin =true);
	bool NextLine();
	bool PrevLine();
	void SetAtLineBegin();

protected:
	bool UseDefault(); // Note: not virtual.  No further inheritance intended.

};

#endif __FILEREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\filetracker.cpp ===
//
// MODULE: FileTracker.cpp
//
// PURPOSE: Abstract classes in support of tracking file changes over time.
//	Completely implements CFileToTrack, CFileTracker
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-15-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-15-98	JM
//


#include "stdafx.h"
#include "event.h"
#include "FileTracker.h"
#include "Functions.h"
#include "baseexception.h"
#include "CharConv.h"


//////////////////////////////////////////////////////////////////////
// CFileToTrack
//////////////////////////////////////////////////////////////////////

CFileToTrack::CFileToTrack(const CString & strPathName) :
	m_strPathName(strPathName), 
	m_bFileExists(false)
{
	m_ftLastWriteTime.dwLowDateTime = 0;
	m_ftLastWriteTime.dwHighDateTime = 0;
}

CFileToTrack::~CFileToTrack()
{
}

void CFileToTrack::CheckFile(bool & bFileExists, bool & bTimeChanged, const bool bLogIfMissing )
{
	HANDLE hSearch;
	WIN32_FIND_DATA FindData;

	hSearch = ::FindFirstFile(m_strPathName, &FindData);

	bFileExists = (hSearch != INVALID_HANDLE_VALUE);

	// initialize bTimeChanged: we always consider coming into existence as a time change.
	bTimeChanged = bFileExists && ! m_bFileExists;
	m_bFileExists = bFileExists;

	if (bFileExists) 
	{
		::FindClose(hSearch);
		// for some reason, we can't compile
		// bTimeChanged |= (m_ftLastWriteTime != FindData.ftLastWriteTime);
		// so:
		bTimeChanged |= (0 != memcmp(&m_ftLastWriteTime, &(FindData.ftLastWriteTime), sizeof(m_ftLastWriteTime)));
		m_ftLastWriteTime = FindData.ftLastWriteTime;
	}
	else
	{
		// file disappeared or never existed, ignore for now
		m_bFileExists = false;
		bFileExists = false;

		if (bLogIfMissing)
		{
			CString strErr;
			FormatLastError(&strErr, ::GetLastError());

			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									m_strPathName,
									strErr,
									EV_GTS_ERROR_FILE_MISSING ); 
		}

		bTimeChanged = false;
	}
}

//////////////////////////////////////////////////////////////////////
// CFileTracker
//////////////////////////////////////////////////////////////////////
CFileTracker::CFileTracker()
{
}

CFileTracker::~CFileTracker()
{
}

void CFileTracker::AddFile(const CString & strPathName)
{
	try
	{
		m_arrFile.push_back(CFileToTrack(strPathName));
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

bool CFileTracker::Changed( const bool bLogIfMissing )
{
	bool bChange = false;
	bool bSomethingMissing = false;

	//
	// This try-catch block was added as a measure to handle an unexplainable problem.
	//
	// Previously this function was throwning a (...) exception in release builds but
	// not in debug builds.  Adding this try-catch block had the effect of making the
	// (...) exception in release builds disappear.  This problem was causing the 
	// directory monitor thread to die so if you change this function, please verify
	// that the directory monitor thread is still viable.
	// RAB-981112.
	try
	{
		for(vector<CFileToTrack>::iterator it = m_arrFile.begin();
		it != m_arrFile.end();
		it ++
		)
		{
			bool bFileExists;
			bool bTimeChanged;

			it->CheckFile(bFileExists, bTimeChanged, bLogIfMissing );
			bChange |= bTimeChanged;
			bSomethingMissing |= !bFileExists;
		}
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}

	return (bChange && !bSomethingMissing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\functions.h ===
//
// MODULE: FUNCTIONS.H
//
// PURPOSE:  Decodes the the variant structures.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
/// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __FUNCTIONS_H_
#define __FUNCTIONS_H_ 1

inline CString GlobFormatMessage(DWORD dwLastError)
{
	CString strMessage;
	void *lpvMessage;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 0, NULL);
	strMessage = (LPCTSTR) lpvMessage;
	LocalFree(lpvMessage);
	return strMessage;
}

inline CString DecodeVariantTypes(VARTYPE vt)
{
	CString str = _T("");
	if (VT_EMPTY == vt)
		str = _T("Empty  ");
	else if(VT_ILLEGAL == vt)
		str = _T("ILLEGAL  ");
	else if(VT_ILLEGALMASKED == vt)
		str = _T("ILLEGALMASKED  ");
	else
	{
		if (VT_VECTOR == (VT_VECTOR & vt))
			str += _T("VECTOR  ");
		if (VT_ARRAY == (VT_ARRAY & vt))
			str += _T("ARRAY  ");
		if (VT_BYREF == (VT_BYREF & vt))
			str += _T("BYREF  ");
		if (VT_RESERVED == (VT_RESERVED & vt))
			str += _T("RESERVED  ");
		if (VT_TYPEMASK == (VT_TYPEMASK & vt))
			str += _T("TYPEMASK  ");
		vt &= 0xFFF;
		if (VT_NULL == vt)
			str += _T("Null  ");
		if (VT_I2 == vt)
			str += _T("I2  ");
		if (VT_I4 == vt)
			str += _T("I4  ");
		if (VT_R4 == vt)
			str += _T("R4  ");
		if (VT_R8 == vt)
			str += _T("R8  ");
		if (VT_CY == vt)
			str += _T("CY  ");
		if (VT_DATE == vt)
			str += _T("DATE  ");
		if (VT_BSTR == vt)
			str += _T("BSTR  ");
		if (VT_DISPATCH == vt)
			str += _T("DISPATCH  ");
		if (VT_ERROR == vt)
			str += _T("ERROR  ");
		if (VT_BOOL == vt)
			str += _T("BOOL  ");
		if (VT_VARIANT == vt)
			str += _T("VARIANT  ");
		if (VT_UNKNOWN == vt)
			str += _T("UNKNOWN  ");
		if (VT_DECIMAL == vt)
			str += _T("DECIMAL  ");
		if (VT_I1 == vt)
			str += _T("I1  ");
		if (VT_UI1 == vt)
			str += _T("UI1  ");
		if (VT_UI2 == vt)
			str += _T("UI2  ");
		if (VT_UI4 == vt)
			str += _T("UI4  ");
		if (VT_I8 == vt)
			str += _T("I8  ");
		if (VT_UI8 == vt)
			str += _T("UI8  ");
		if (VT_INT == vt)
			str += _T("INT  ");
		if (VT_UINT == vt)
			str += _T("UINT  ");
		if (VT_VOID == vt)
			str += _T("VOID  ");
		if (VT_HRESULT == vt)
			str += _T("HRESULT  ");
		if (VT_PTR == vt)
			str += _T("PTR  ");
		if (VT_SAFEARRAY == vt)
			str += _T("SAFEARRAY  ");
		if (VT_CARRAY == vt)
			str += _T("CARRAY  ");
		if (VT_USERDEFINED == vt)
			str += _T("USERDEFINED  ");
		if (VT_LPSTR == vt)
			str += _T("LPSTR  ");
		if (VT_LPWSTR == vt)
			str += _T("LPWSTR  ");
		if (VT_FILETIME == vt)
			str += _T("FILETIME  ");
		if (VT_BLOB == vt)
			str += _T("BLOB  ");
		if (VT_STREAM == vt)
			str += _T("STREAM  ");
		if (VT_STORAGE == vt)
			str += _T("STORAGE  ");
		if (VT_STREAMED_OBJECT == vt)
			str += _T("STREAMED_OBJECT  ");
		if (VT_STORED_OBJECT == vt)
			str += _T("STORED_OBJECT  ");
		if (VT_BLOB_OBJECT == vt)
			str += _T("BLOB_OBJECT  ");
		if (VT_CF == vt)
			str += _T("CF  ");
		if (VT_CLSID == vt)
			str += _T("CLSID  ");
	}
	return str;
}

inline CString DecodeSafeArray(unsigned short Features)
{
/*
#define FADF_AUTO		0x0001	// Array is allocated on the stack.
#define FADF_STATIC		0x0002	// Array is statically allocated.
#define FADF_EMBEDDED	0x0004	// Array is embedded in a structure.
#define FADF_FIXEDSIZE	0x0010	// Array may not be resized or 
								// reallocated.
#define FADF_BSTR		0x0100	// An array of BSTRs.
#define FADF_UNKNOWN		0x0200	// An array of IUnknown*.
#define FADF_DISPATCH	0x0400	// An array of IDispatch*.
#define FADF_VARIANT		0x0800	// An array of VARIANTs.
#define FADF_RESERVED	0xF0E8	// Bits reserved for future use.
*/
	CString str = _T("");
	if (FADF_AUTO == (FADF_AUTO & Features))
		str += _T("Array is allocated on the stack.\n");
	if (FADF_STATIC == (FADF_STATIC & Features))
		str += _T("Array is statically allocated.\n");
	if (FADF_EMBEDDED == (FADF_EMBEDDED & Features))
		str += _T("Array is embedded in a structure.\n");
	if (FADF_FIXEDSIZE == (FADF_FIXEDSIZE & Features))
		str += _T("Array may not be resized of reallocated.\n");
	if (FADF_BSTR == (FADF_BSTR & Features))
		str += _T("An array of BSTRs.\n");
	if (FADF_UNKNOWN == (FADF_UNKNOWN & Features))
		str += _T("An array of IUnknown.\n");
	if (FADF_DISPATCH == (FADF_DISPATCH & Features))
		str += _T("An array of IDispatch.\n");
	if (FADF_VARIANT == (FADF_VARIANT & Features))
		str += _T("An array of VARIANTS.\n");
	if (FADF_RESERVED == (FADF_RESERVED & Features))
		str+= _T("Array is using all of the reserved bits.\n");
	return str; 
}

inline void FormatLastError(CString *pstr, DWORD dwLastError)
{
	void *lpvMessage;
	::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 
		0, 
		NULL);
	*pstr = (LPCTSTR) lpvMessage;
	::LocalFree(lpvMessage);	// slightly hideous, but Win32 FormatMessage uses LocalAlloc
								// in response to FORMAT_MESSAGE_ALLOCATE_BUFFER, so we
								// need to use LocalFree.
	return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\fs.cpp ===
//
// MODULE: FS.cpp
//
// PURPOSE: Implementation of classes needed in order to use CHM files.
//
// COMPANY: This file was created by Microsoft and should not be changed by Saltmine 
//	except for comments
//
// ORIGINAL DATE: 1997.
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM		This header added. Added include of apgtsstr.h since
//								we are compiling in a non-MFC environment.
//
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "stdafx.h"

// to avoid linker error related to undefined GUIDs
#include "initguid.h"
#include "fs.h"
#include "apgtsstr.h"

#pragma data_seg(".text", "CODE")

static const WCHAR txtwUncompressed[] =  L"uncompressed";

#pragma data_seg()

// returns poinder inside pszPath string that points to file name
// for example in "d:\Tshooter\http\lan.chm\lan.htm" it points
// to "lan.htm"
LPCSTR FindFilePortion(LPCSTR pszPath)
{
	int index =0;
	CString path(pszPath);

	if (-1 == (index = path.ReverseFind(_T('\\'))))
	{
		if (-1 == (index = path.ReverseFind(_T('/'))))
			index = 0;
		else
			index += sizeof(_T('/'));
	}
	else
		index += sizeof(_T('\\'));

	return pszPath + index;
}

CFileSystem::CFileSystem()
{
   m_pITStorage    = NULL;
   m_pStorage      = NULL;
   m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
  ReleaseObjPtr(m_pStorage);
  ReleaseObjPtr(m_pITStorage);
}

HRESULT CFileSystem::Init(void)
{
   if (! m_pITStorage) {
      IClassFactory* pICFITStorage;

	  HRESULT hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **) &pICFITStorage);

      if (!SUCCEEDED(hr)) 
         return hr;
      
      hr = pICFITStorage->CreateInstance(NULL, IID_ITStorage,(void **) &m_pITStorage);
      ReleaseObjPtr( pICFITStorage );

      if (!SUCCEEDED(hr)) 
         return hr;
   }
   return S_OK;
}

typedef struct tagITSControlData
{
   UINT cdwFollowing;          // Must be 6 or 13
   DWORD cdwITFS_Control;      // Must be 5
   DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
   DWORD dwVersionITS;         // Must be 1
   DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
   DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                               // which we'll cache in memory. (Default is 20)
   DWORD fFlags;               // Control bit flags (see below).
                               // Default value is fDefaultIsCompression.
   UINT  cdwControlData;       // Must be 6
   DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
   DWORD dwVersion;            // Must be 2
   DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
   DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
   DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
   DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

HRESULT CFileSystem::Create( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 13;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 4096;     // default = 8192
   itcd.cMinCacheEntries  = 10;       // default = 20
   itcd.fFlags            = 1;        // 0 == Uncompressed, 1 == Compressed.
   itcd.cdwControlData        = 6;
   itcd.dwLZXMagic            = LZX_MAGIC;
   itcd.dwVersion             = 2;
   itcd.dwMulResetBlock       = 2;    // Default = 4
   itcd.dwMulWindowSize       = 2;    // Default = 4
   itcd.dwMulSecondPartition  = 1;    // Default = 2
   itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 6;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 8192;     // default = 8192
   itcd.cMinCacheEntries  = 20;        // default = 20
   itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CFileSystem::Open(PCSTR pszPathName, DWORD dwAccess)
{
   HRESULT hr = S_OK;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgOpenStorage( (LPCWSTR) wsz, NULL, dwAccess, NULL, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return hr;
}

HRESULT CFileSystem::Compact(LPCSTR pszPathName)
{
   WCHAR wszPathName[MAX_PATH];
   //[BC-03022001] - changed 5th param to MultiByteToWideChar to number of chars from number of bytes.
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, wszPathName, sizeof(wszPathName)/sizeof(WCHAR));
   m_pITStorage->Compact(wszPathName, COMPACT_DATA_AND_PATH);

   return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr(m_pStorage);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem(CFileSystem* pFS)
{
   m_pFS = pFS;
   m_pStorage = NULL;
   m_pStream = NULL;
   m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
   if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
      ReleaseObjPtr(m_pStorage);

   ReleaseObjPtr(m_pStream);
}

HRESULT CSubFileSystem::CreateSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';

      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);

      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;
   IStorageITEx* pIStorageEx;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile(PCSTR pszPathName)
{
   m_pStorage = m_pFS->m_pStorage;
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   HRESULT hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile(PCSTR pszPathName)
{
   IStorageITEx* pIStorageEx;
   HRESULT hr;

   m_pStorage = m_pFS->m_pStorage;

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::OpenSub(PCSTR pszPathName, DWORD dwAccess)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   if ((pszFilePortion = FindFilePortion(pszPathName)) &&
         pszFilePortion > pszPathName + 2) // +2 to support / && ./
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, dwAccess, NULL, 0, &m_pStorage);

      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage ? m_pFS->m_pStorage : m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->OpenStream(wszStream, NULL, dwAccess, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

ULONG CSubFileSystem::WriteSub(const void* pData, int cb)
{
   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   ULONG cbWritten;

   HRESULT hr = m_pStream->Write(pData, cb, &cbWritten);

   if (!SUCCEEDED(hr) || (cbWritten != (ULONG)cb) )
   {
      return (ULONG) -1;
   }
   // REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
   // we don't write cb bytes.
   return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub(int cb, int iOrigin)
{
   HRESULT hr = S_OK;
   LARGE_INTEGER liCount = {0,0};
   ULARGE_INTEGER liNewPos = {0,0};

   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   liCount.LowPart = cb;
   hr = m_pStream->Seek(liCount, iOrigin, &liNewPos);
   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }

   return liNewPos.LowPart;
}

bool CSubFileSystem::GetSubPos(ULARGE_INTEGER* pliOldPos, STREAM_SEEK eDir /*=STREAM_SEEK_CUR*/)
{
   HRESULT hr = S_OK;
   LARGE_INTEGER liNull = {0,0};

   if ( !m_pStorage || !m_pStream )
      return false;

   hr = m_pStream->Seek(liNull, eDir, pliOldPos);
   if (!SUCCEEDED(hr) )
      return false;

   return true;
}

bool CSubFileSystem::SetSubPos(LARGE_INTEGER liNewPos, STREAM_SEEK eDir /*=STREAM_SEEK_SET*/)
{
   HRESULT hr = S_OK;

   if ( !m_pStorage || !m_pStream )
      return false;

   hr = m_pStream->Seek(liNewPos, eDir, NULL);
   if (!SUCCEEDED(hr) )
      return false;

   return true;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize(unsigned uSize)
{
   ULARGE_INTEGER liSize = {0,0};
   HRESULT hr;

   if ( !m_pStorage || !m_pStream )
      return E_FAIL;

   liSize.LowPart = uSize;
   hr =  m_pStream->SetSize(liSize);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return hr;
}

//
// Delete substorage.
//
HRESULT CSubFileSystem::DeleteSub()
{
    if (m_pStorage)
    {
        if (m_pStream)
        {
            // Release the stream.
            ReleaseObjPtr(m_pStream) ;
        }

        // Now delete the storage.
        WCHAR element[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szPathName, -1, (PWSTR) element, MAX_PATH);

        HRESULT hr = m_pStorage->DestroyElement(element) ;
        if (SUCCEEDED(hr))
        {
            // Get back to the constructor state.
            if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
            {
                ReleaseObjPtr(m_pStorage);
            }
            return S_OK ;
        }
    }
    return S_OK ;
}

ULONG CSubFileSystem::GetUncompressedSize(void) 
{ 
	ULARGE_INTEGER liOldPos ={0,0};
	LARGE_INTEGER liOldOff ={0,0};
	ULONG ret = -1;

	if (GetSubPos(&liOldPos))
	{
	   if (-1 != (ret = SeekSub(0, STREAM_SEEK_END)))
	   {
		   liOldOff.LowPart = liOldPos.LowPart;
		   liOldOff.HighPart = liOldPos.HighPart;
		   if (SetSubPos(liOldOff))
		   {
			   return ret;
		   }
	   }
	}
	return (ULONG) -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\fs.h ===
//
// MODULE: FS.h
//
// PURPOSE: Interface declaration needed in order to use CHM files.
//
// COMPANY: This file was created by Microsoft and should not be changed by Saltmine 
//	except for comments
//
// ORIGINAL DATE: 1997.
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM		This header added.
//
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _FS_H_
#define _FS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <unknwn.h>
#include "msitstg.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{
protected:
	bool GetSubPos(ULARGE_INTEGER*, STREAM_SEEK =STREAM_SEEK_CUR);
	bool SetSubPos(LARGE_INTEGER, STREAM_SEEK =STREAM_SEEK_SET);

public:
   CSubFileSystem(class CFileSystem* pfs);
   ~CSubFileSystem();

   HRESULT CreateSub(PCSTR pszPathName);
   HRESULT CreateUncompressedSub(PCSTR pszPathName);
   HRESULT OpenSub(PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   ULONG WriteSub(const void* pData, int cb);
   ULONG SeekSub(int cb, int iOrigin);
   HRESULT CreateSystemFile(PCSTR pszPathName);
   HRESULT CreateUncompressedSystemFile(PCSTR pszPathName);
   HRESULT SetSize(unsigned uSize);
   HRESULT DeleteSub() ;
   ULONG GetUncompressedSize(void);

   inline HRESULT ReadSub(void* pData, ULONG cb, ULONG* pcbRead) {
      return m_pStream->Read(pData, cb, pcbRead);
   }

   inline HRESULT Stat(STATSTG *pstatstg, DWORD grfStatFalg)
   {
      return m_pStream->Stat(pstatstg,grfStatFalg);
   }

   inline HRESULT CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER* pcbWritten)
   {
      return m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
   }

   inline IStream * GetStream(void)
   {
      return m_pStream;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   class CFileSystem* m_pFS;
   IStorage*          m_pStorage;
   IStream*           m_pStream;
   char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
   friend class CSubFileSystem;

public:
   CFileSystem();
   ~CFileSystem();

   HRESULT Init(void);
   HRESULT Create( PCSTR pszPathName );
   HRESULT CreateUncompressed( PCSTR pszPathName );
   HRESULT Open( PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   HRESULT Compact(LPCSTR lpszFileName);
   HRESULT Close(void);

   inline HRESULT GetPathName( LPSTR pszPathName ) { strcpy(pszPathName, m_szPathName); return S_OK; }

   inline IITStorage* GetITStorageObj(void) const
   {
      return m_pITStorage;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   IITStorage*   m_pITStorage;
   IStorage*     m_pStorage;
   char          m_szPathName[MAX_PATH];

};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\htmlfraglocal.h ===
//
// MODULE: HTMLFrag.h
//
// PURPOSE: interface for the CHTMLFragmentsLocal class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 1-19-1999
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		1-19-19		OK		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HTMLFRAGLOCAL_H__FFDF7EB3_AFBC_11D2_8C89_00C04F949D33__INCLUDED_)
#define AFX_HTMLFRAGLOCAL_H__FFDF7EB3_AFBC_11D2_8C89_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HTMLFrag.h"

#define VAR_PREVIOUS_SCRIPT		_T("Previous.script")
#define VAR_NOBACKBUTTON_INFO	_T("NoBackButton")
#define VAR_YESBACKBUTTON_INFO	_T("YesBackButton")

class CHTMLFragmentsLocal : public CHTMLFragmentsTS  
{
protected:
	static bool RemoveBackButton(CString& strCurrentNode);

public:
	CHTMLFragmentsLocal( const CString &strScriptPath, bool bIncludesHistoryTable );

public:
	// overridden virtual
	CString GetText( const FragmentIDVector & fidvec, const FragCommand fragCmd= eNotOfInterest );
};

#endif // !defined(AFX_HTMLFRAGLOCAL_H__FFDF7EB3_AFBC_11D2_8C89_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\htmlfrag.cpp ===
//
// MODULE: HTMLFrag.cpp
//
// PURPOSE: implementation of the CHTMLFragmentsTS class, which is how CInfer packages
//	up fragments of HTML to be rendered in accord with a template
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-27-1998
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-20-98		JM		Original
//
//////////////////////////////////////////////////////////////////////

#pragma warning(disable:4786)

#include "stdafx.h"
#include <algorithm>
#include "HTMLFrag.h"
#include "event.h"
#include "baseexception.h"
#include "CharConv.h"
#include "fileread.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

// V3.2 Additions.
namespace
{
	const CString kstrCond_StringCompare=		_T("StringCompare");
	const CString kstrCond_OperatorGT=		_T(".GT.");
	const CString kstrCond_OperatorGE=		_T(".GE.");
	const CString kstrCond_OperatorEQ=		_T(".EQ.");
	const CString kstrCond_OperatorNE=		_T(".NE.");
	const CString kstrCond_OperatorLE=		_T(".LE.");
	const CString kstrCond_OperatorLT=		_T(".LT.");
	const CString kstrCond_OperatorSubstring=	_T(".SubstringOf.");
}

//////////////////////////////////////////////////////////////////////
// CHTMLValue implementation
//////////////////////////////////////////////////////////////////////

bool CHTMLValue::SetValue(const CString& value)
{
	CString strOldValue = m_strValValue;
	m_strValValue = value;
	m_strValValue.TrimLeft();
	m_strValValue.TrimRight();
	if (IsValid())
		return true;
	m_strValValue = strOldValue;
	return false;
}

bool CHTMLValue::IsNumeric()
{
	for (int i = 0; i < m_strValValue.GetLength(); i++)
		if(!_ismbcdigit(m_strValValue[i]))
			return false;
	return true;
}

bool CHTMLValue::IsString()
{
	// string should be wrapped by quots
	if (m_strValValue.GetLength() >= 2 &&
		m_strValValue[0] == _T('"') &&
		m_strValValue[m_strValValue.GetLength()-1] == _T('"')
	   )
	   return true;
	return false;
}

bool CHTMLValue::IsBoolean()
{
	return 0 == _tcsicmp(_T("true"), m_strValValue) || 
		   0 == _tcsicmp(_T("false"), m_strValValue);
}

bool CHTMLValue::GetNumeric(long& out)
{
	if (IsNumeric())
	{
		out = _ttol(m_strValValue);
		return true;
	}
	return false;
}

bool CHTMLValue::GetString(CString& out)
{
	if (IsString())
	{
		out = m_strValValue.Mid(1, m_strValValue.GetLength()-2);
		return true;
	}
	return false;
}

bool CHTMLValue::GetBoolean(bool& out)
{
	if (IsBoolean())
	{
		out = (0 == _tcsicmp(_T("true"), m_strValValue)) ? true : false;
		return true;
	}
	return false;
}

bool CHTMLValue::operator == (const CHTMLValue& sib)
{
	return 0 == _tcsicmp(m_strValName, sib.m_strValName); // case insensitive
}

//////////////////////////////////////////////////////////////////////
// CHTMLFragments implementation
//////////////////////////////////////////////////////////////////////

bool CHTMLFragments::SetValue(const CString& str)
{
	int index = str.Find(_T('='));
	
	if (index == -1)
		return false;

	CString name = str.Left(index);
	name.TrimLeft();
	name.TrimRight();

	CString value= str.Right(str.GetLength() - index - 1);
	value.TrimLeft();
	value.TrimRight();

	CHTMLValue HTMLValue(name, value);
	
	HTMLValueVector::iterator found = find(m_HTMLValueVector.begin(), m_HTMLValueVector.end(), HTMLValue);
	
	if (found != m_HTMLValueVector.end())
		*found = HTMLValue;
	else
		m_HTMLValueVector.push_back(HTMLValue);

	return true;
}

CHTMLValue* CHTMLFragments::GetValue(const CString& value_name)
{
	HTMLValueVector::iterator found = find(m_HTMLValueVector.begin(), m_HTMLValueVector.end(), CHTMLValue(value_name));
	if (found != m_HTMLValueVector.end())
		return found;
	return NULL;
}

//////////////////////////////////////////////////////////////////////
// CHTMLFragmentsTS implementation
//////////////////////////////////////////////////////////////////////

CHTMLFragmentsTS::CHTMLFragmentsTS( const CString & strScriptPath, bool bIncludesHistoryTable ) :
	m_bIncludesHistoryTable(bIncludesHistoryTable),
	m_bIncludesHiddenHistory(!bIncludesHistoryTable),
	m_bSuccess(false),
	m_strYes(_T("Yes")),
    m_strScriptPath(strScriptPath)
{
}

CHTMLFragmentsTS::~CHTMLFragmentsTS()
{
}

// Obviously, a very ad hoc implementation
int CHTMLFragmentsTS::GetCount(const FragmentIDVector & fidvec) const
{
	if (fidvec.empty())
		return 0;

	if (fidvec.back().Index != -1)
		return 0;

	const CString & strVariable = fidvec[0].VarName;	// ref of convenience

	if (fidvec.size() == 1)
	{
		if (strVariable == VAR_PROBLEM_ASK)
			return 1;
		if (strVariable == VAR_RECOMMENDATIONS)
			return m_vstrVisitedNodes.size();
		if (strVariable == VAR_QUESTIONS)
			return 1;
		if (strVariable == VAR_SUCCESS)
			return m_bSuccess ? 1 : 0;
		if (strVariable == VAR_STARTFORM)
			return 1;

		return 0;
	}

	if (fidvec.size() == 2 
	&& strVariable == VAR_RECOMMENDATIONS
	&& fidvec[0].Index >= 0
	&& fidvec[0].Index < m_vvstrStatesOfVisitedNodes.size()
	&& fidvec[1].VarName == VAR_STATES)
	{
		return m_vvstrStatesOfVisitedNodes[fidvec[0].Index].size();
	}

	return 0;
}

// this function was removed from const to achieve further flexibility:
//  we might need to take some active steps in it, as for informational
//  statement we might modify current node text. Oleg. 01.05.99
CString CHTMLFragmentsTS::GetText( const FragmentIDVector & fidvec, const FragCommand fragCmd )
{
	if (fidvec.empty())
		return m_strNil;

	const CString & strVariable0 = fidvec[0].VarName;	// ref of convenience
	int i0 = fidvec[0].Index;

	if (fidvec.size() == 1)
	{
		if (strVariable0 == VAR_PROBLEM_ASK)
			return m_strProblem;

		if (strVariable0 == VAR_RECOMMENDATIONS
		&& i0 >= 0
		&& i0 < m_vstrVisitedNodes.size() )
		{
			return m_vstrVisitedNodes[i0];
		}

		if (strVariable0 == VAR_QUESTIONS)
			return m_strCurrentNode;

		if (strVariable0 == VAR_SUCCESS)
			return m_bSuccess ? m_strYes : m_strNil;

		if (strVariable0 == VAR_STARTFORM)
			return m_strStartForm;

		if (fragCmd == eResource)
		{
			// Load a server side include file.
			CString strScriptContent;
			CString strFullPath = m_strScriptPath + strVariable0;

			CFileReader fileReader(	CPhysicalFileReader::makeReader( strFullPath ) );

			if (fileReader.Read())
			{
				fileReader.GetContent(strScriptContent);
				return strScriptContent;
			}
		}

		// Check for new conditionals added in V3.2.
		CString strTemp= strVariable0.Left( kstrCond_NumericCompare.GetLength() );
		if (strTemp == kstrCond_NumericCompare)
		{
			// Evaluate the numeric expression.
			if (NumericConditionEvaluatesToTrue( strVariable0.Mid( kstrCond_NumericCompare.GetLength() )))
				return( m_strYes );
			return( m_strNil );
		}
		strTemp= strVariable0.Left( kstrCond_StringCompare.GetLength() );
		if (strTemp == kstrCond_StringCompare)
		{
			// Evaluate the string expression.
			if (StringConditionEvaluatesToTrue( strVariable0.Mid( kstrCond_StringCompare.GetLength() )))
				return( m_strYes );
			return( m_strNil );
		}

		return m_strNil;
	}


	const CString & strVariable1 = fidvec[1].VarName;	// ref of convenience
	int i1 = fidvec[1].Index;

	if (fidvec.size() == 2 
	&& strVariable0 == VAR_RECOMMENDATIONS
	&& i0 >= 0
	&& i0 < m_vvstrStatesOfVisitedNodes.size()
	&& strVariable1 == VAR_STATES
	&& i1 >= 0
	&& i1 < m_vvstrStatesOfVisitedNodes[i0].size() )
		return (m_vvstrStatesOfVisitedNodes[i0][i1]);

	// V3.2
	// The specification for the v3.2 cookies called for permitting underscores
	// in cookie names.  The HTI reader already used underscores to delimit
	// variables.  The code below detects a comparision operation that has been
	// broken up due to the presence of underscores and reassembles it.
	// RAB-19991019.
	{
		// Check for new conditionals added in V3.2.
		int nOpType= 0;
		CString strTemp= strVariable0.Left( kstrCond_NumericCompare.GetLength() );
		if (strTemp == kstrCond_NumericCompare)
			nOpType= 1;
		else
		{
			strTemp= strVariable0.Left( kstrCond_StringCompare.GetLength() );
			if (strTemp == kstrCond_StringCompare)
				nOpType= 2;
		}

		if (nOpType)
		{
			// Reassemble the comparison operation.  
			CString strCompareOp= fidvec[0].VarName;
			for (int nItem= 1; nItem < fidvec.size(); nItem++)
			{
				strCompareOp+= _T("_");	// Reinsert the delimiter that was removed during the parse.
				strCompareOp+= fidvec[ nItem ].VarName;
			}

			if (nOpType == 1)
			{
				// Evaluate the numeric expression.
				if (NumericConditionEvaluatesToTrue( strCompareOp.Mid( kstrCond_NumericCompare.GetLength() )))
					return( m_strYes );
			}
			else
			{
				// Evaluate the string expression.
				if (StringConditionEvaluatesToTrue( strCompareOp.Mid( kstrCond_StringCompare.GetLength() )))
					return( m_strYes );
			}

			return( m_strNil );
		}
	}

	return m_strNil;
}

bool CHTMLFragmentsTS::IsValidSeqOfVars(const FragmentIDVector & arrParents, const FragmentIDVector & arrChildren) const
{
	// we allow only one level of nesting
	//  that means in "forany" of $Recommendations we can have "forany" array of $States
	if (arrParents.size() == 1 && arrChildren.size() == 1)
		if (arrParents[0].VarName == VAR_RECOMMENDATIONS  && arrChildren[0].VarName == VAR_STATES)
			return true;
	return false;
}

void CHTMLFragmentsTS::SetStartForm(const CString & str)
{
	m_strStartForm = str;
}
	
void CHTMLFragmentsTS::SetProblemText(const CString & str)
{
	if (m_bIncludesHistoryTable)
		m_strProblem = str;
}
	
void CHTMLFragmentsTS::SetCurrentNodeText(const CString & str)
{
	m_strCurrentNodeSimple = str;
	RebuildCurrentNodeText();
}

void CHTMLFragmentsTS::SetHiddenHistoryText(const CString & str)
{
	if (m_bIncludesHiddenHistory)
	{
		m_strHiddenHistory = str;
		RebuildCurrentNodeText();
	}
}

// need only be called for bSuccess == true (false is default) but written more generally.
void CHTMLFragmentsTS::SetSuccessBool(bool bSuccess)
{
	m_bSuccess = bSuccess;
}
	
CString CHTMLFragmentsTS::GetCurrentNodeText()
{
	return m_strCurrentNodeSimple;
}

// must be called in order nodes were visited.  Do not call for problem node.
// return index of added node
int CHTMLFragmentsTS::PushBackVisitedNodeText(const CString & str)
{
	if (m_bIncludesHistoryTable)
	{
		try
		{
			m_vstrVisitedNodes.push_back(str);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
		return m_vstrVisitedNodes.size() - 1;
	}
	return -1;
}

// For each given iVisitedNode, must be called in order of state number, 
//	with ST_UNKNOWN last
// return index of added state
int CHTMLFragmentsTS::PushBackStateText(UINT iVisitedNode, const CString & str)
{
	if (m_bIncludesHistoryTable)
	{
		try
		{
			// Check if we need to add one or more elements to the vector of nodes.
			if (m_vvstrStatesOfVisitedNodes.size() <= iVisitedNode)
			{
				// Check if we need to add more than one element to the vector of nodes.
				if (m_vvstrStatesOfVisitedNodes.size() < iVisitedNode)
				{
					// We need to add more than one element to the vector of nodes.
					// This condition should not be occurring, so log it.
					CString tmpStrCurCnt, tmpStrReqCnt;

					tmpStrCurCnt.Format( _T("%d"), m_vvstrStatesOfVisitedNodes.size() );
					tmpStrReqCnt.Format( _T("%d"), iVisitedNode );
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											tmpStrCurCnt, tmpStrReqCnt, 
											EV_GTS_NODE_COUNT_DISCREPANCY );  


					// Add to the vector of nodes until we have placed a total of
					// iVisitedNode elements into the vector.  We are inserting empty
					// states as the first element of the vector of states for a node.
					vector<CString> vecDummy;
					vecDummy.push_back( _T("") );
					do
					{
						m_vvstrStatesOfVisitedNodes.push_back( vecDummy );
					}
					while (m_vvstrStatesOfVisitedNodes.size() < iVisitedNode);
				}

				// Add this state string as the first element of the vector of states for a node.
				vector<CString> tmpVector;
				tmpVector.push_back( str );
				m_vvstrStatesOfVisitedNodes.push_back( tmpVector );
			}
			else
			{
				// Add this state string to the vector of states for a node.
				m_vvstrStatesOfVisitedNodes[iVisitedNode].push_back(str);
			}
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""),
									EV_GTS_STL_EXCEPTION ); 
		}
		return m_vvstrStatesOfVisitedNodes[iVisitedNode].size() - 1;
	}
	return -1;
}

// call this function to find out if there is any need for a history table.
// If not, calling class can save the effort of constructing one:
//	SetProblemText(), AppendVisitedNodeText(), AppendStateText()
//	becomes no-ops, so no need to construct strings and call them
bool CHTMLFragmentsTS::IncludesHistoryTable() const
{
	return m_bIncludesHistoryTable;
}

// call this function to find out if there is any need for "hidden history"
// If not, calling class can save the effort of constructing one:
//	SetHiddenHistoryText() becomes a no-op, so no need to construct a string and call it
bool CHTMLFragmentsTS::IncludesHiddenHistory() const
{
	return m_bIncludesHiddenHistory;
}

void CHTMLFragmentsTS::RebuildCurrentNodeText()
{
	m_strCurrentNode = m_strHiddenHistory;
	m_strCurrentNode += m_strCurrentNodeSimple; 
}


// Function which parses and evaluates a numeric condition.
bool CHTMLFragmentsTS::NumericConditionEvaluatesToTrue( const CString & str )
{
	bool bRetVal= false;
	CString strScratch= RemoveOuterParenthesis( str );

	if (strScratch.GetLength())
	{
		long lLeftOperand, lRightOperand;

		// Check for all supported operators.
		if (RetNumericOperands( strScratch, kstrCond_OperatorGT, lLeftOperand, lRightOperand ))
		{
			// .GT. case.
			bRetVal= (lLeftOperand > lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorGE, lLeftOperand, lRightOperand ))
		{
			// .GE. case.
			bRetVal= (lLeftOperand >= lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorEQ, lLeftOperand, lRightOperand ))
		{
			// .EQ. case.
			bRetVal= (lLeftOperand == lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorNE, lLeftOperand, lRightOperand ))
		{
			// .NE. case.
			bRetVal= (lLeftOperand != lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorLE, lLeftOperand, lRightOperand ))
		{
			// .LE. case.
			bRetVal= (lLeftOperand <= lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorLT, lLeftOperand, lRightOperand ))
		{
			// .LT. case.
			bRetVal= (lLeftOperand < lRightOperand) ? true : false;
		}
	}

	return( bRetVal );
}


// Function which parses and evaluates a string condition.
bool CHTMLFragmentsTS::StringConditionEvaluatesToTrue( const CString & str )
{
	bool bRetVal= false;
	CString strScratch= RemoveOuterParenthesis( str );

	if (strScratch.GetLength())
	{
		CString strLeftOperand, strRightOperand;

		// Check for all supported operators.
		if (RetStringOperands( strScratch, kstrCond_OperatorEQ, strLeftOperand, strRightOperand ))
		{
			if ((strLeftOperand.GetLength() == strRightOperand.GetLength()) &&
				(_tcsicmp( strLeftOperand, strRightOperand ) == 0))
				bRetVal= true;
		}
		else if (RetStringOperands( strScratch, kstrCond_OperatorNE, strLeftOperand, strRightOperand ))
		{
			if ((strLeftOperand.GetLength() != strRightOperand.GetLength()) ||
				(_tcsicmp( strLeftOperand, strRightOperand ) != 0))
				bRetVal= true;
		}
		else if (RetStringOperands( strScratch, kstrCond_OperatorSubstring, strLeftOperand, strRightOperand ))
		{
			int nLeftLen= strLeftOperand.GetLength();
			int nRightLen= strRightOperand.GetLength();
			if ((nLeftLen) && (nRightLen) && (nLeftLen <= nRightLen))
			{
				strLeftOperand.MakeLower();
				strRightOperand.MakeLower();
				if (_tcsstr( strRightOperand, strLeftOperand ) != NULL)
					bRetVal= true;
			}
		}
	}

	return( bRetVal );
}


// Function to peel off the outer parenthesis of a condition.
CString CHTMLFragmentsTS::RemoveOuterParenthesis( const CString & str )
{
	CString strRet;
	int	nOrigLength= str.GetLength();

	if (nOrigLength > 2)
	{
		TCHAR cFirstChar= str.GetAt( 0 );
		TCHAR cLastChar= str.GetAt( nOrigLength - 1 );

		if ((cFirstChar == _T('(')) && (cLastChar == _T(')')))
			strRet= str.Mid( 1, nOrigLength - 2 );
	}
	return( strRet );
}


// Breaks out the numeric operands from a string.
bool CHTMLFragmentsTS::RetNumericOperands(	const CString & str, const CString & strOperator,
											long &lLeftOperand, long &lRightOperand )
{
	bool	bRetVal= false;
	int		nOffset= str.Find( strOperator );

	if (nOffset != -1)
	{
		CString strScratch= str.Left( nOffset - 1 );

		strScratch.TrimRight();
		strScratch.TrimLeft();
		if (strScratch.GetLength())
		{
			lLeftOperand= atol( strScratch );

			strScratch= str.Mid( nOffset + strOperator.GetLength() );
			strScratch.TrimRight();
			strScratch.TrimLeft();
			if (strScratch.GetLength())
			{
				lRightOperand= atol( strScratch );
				bRetVal= true;
			}
		}
	}

	return( bRetVal );
}


// Breaks out the string operands from a string.
bool CHTMLFragmentsTS::RetStringOperands(	const CString & str, const CString & strOperator,
											CString & strLeftOperand, CString & strRightOperand )
{
	bool	bRetVal= false;
	int		nOffset= str.Find( strOperator );

	if (nOffset != -1)
	{
		strLeftOperand= str.Left( nOffset - 1 );
		if (CleanStringOperand( strLeftOperand ))
		{
			strRightOperand= str.Mid( nOffset + strOperator.GetLength() );
			strRightOperand.TrimRight();
			strRightOperand.TrimLeft();
			if (CleanStringOperand( strRightOperand ))
				bRetVal= true;
		}
	}

	return( bRetVal );
}

// Trims an operand string and replaces embedded characters.
int CHTMLFragmentsTS::CleanStringOperand( CString& strOperand )
{
	int nRetLength= 0;
	if (!strOperand.IsEmpty())
	{
		strOperand.TrimRight();
		strOperand.TrimLeft();
		nRetLength= strOperand.GetLength();
		if (nRetLength > 2)
		{
			if ((strOperand[ 0 ] == _T('\"')) && (strOperand[ nRetLength - 1 ] == _T('\"')))
			{
				// V3.2 Remove the surrounding double quotes.
				nRetLength-= 2;
				strOperand= strOperand.Mid( 1, nRetLength );
			}

			// V3.2  Replace embedded quotes or backslashes within the string.
			for (int nOp= 0; nOp < 2; nOp++)
			{
				// Set the search and replacement strings.
				CString strSearch, strReplace;
				if (nOp)
				{
					// Replace backslashes.
					strSearch= _T("\\\\");
					strReplace= _T("\\");
				}
				else
				{
					// Replace double quotes.
					strSearch= _T("\\\"");
					strReplace= _T("\"");
				}

				// Search and replace.
				int nStart= 0, nEnd;
				while (CString::FIND_FAILED != (nStart= strOperand.Find( strSearch, nStart )))
				{
					nEnd= nStart + strSearch.GetLength();
					strOperand= strOperand.Left( nStart ) + strReplace + strOperand.Mid( nEnd );
					nStart+= strReplace.GetLength();	// Move search past the character that was just replaced.
				}
			}
		}
	}

	return( nRetLength );
}

// JSM V3.2
// called by HTIReader in parsing stage to convert network property name, given
// in  <$GTS property "propname">, to network property (value).
//
CString CHTMLFragmentsTS::GetNetProp(const CString & strNetPropName)
{
	map<CString,CString>::iterator it = m_mapstrNetProps.find(strNetPropName);

	if (it == m_mapstrNetProps.end())
		return _T("\0"); // not found
	else 
		return (*it).second;
}

// JSM V3.2
//  add a name to the internal list (map) of Net props which are needed
//   by this Fragments object
//
//    CAPGTSHTIReader finds the names of the network properties and passes
//       them in via AddNetPropName, but it doesn't know how to get the values.
//    CInfer will later get the network property names from Fragments object, call the BNTS
//       to find out the network property values, and supply the values to Fragments
//
// 
void CHTMLFragmentsTS::AddNetPropName(const CString & strNetPropName)
{
	// don't insert a NULL key!!!
	if (!strNetPropName.IsEmpty())
		m_mapstrNetProps[strNetPropName];
}

// JSM V3.2
// SetNetProp()
//
//  For a Network Property Name in our internal map, set the
//  corresponding network property (ie, fill in the map value
//   for that key.) Called by CInfer, which is the object that knows how
//   to talk to the BNTS.
//
// returns TRUE if success
//         FALSE if we've given a NetPropName which is not in the internal map
// 
BOOL CHTMLFragmentsTS::SetNetProp(CString strNetPropName, CString strNetProp)
{
	map<CString,CString>::iterator it;

	if ((it= m_mapstrNetProps.find(strNetPropName)) == m_mapstrNetProps.end())
		return false;

	m_mapstrNetProps[strNetPropName] = strNetProp;
	return true;
}

// JSM V3.2
// IterateNetProp()
//  Called to iterate through the network properties in our internal
//  map during the setting process (see above.)
//
//     Sets strNameIterator to the name of the next net prop in the map. 
//
//     calling w/ an empty (NULL) key starts the iteration.
//     calling w/ a name that's not in the map returns false.
//     calling w/ any other name returns true, unless at end of iteration
//
//   strNameIterator is not valid if this function returns false. 
// 
BOOL CHTMLFragmentsTS::IterateNetProp(CString & strNameIterator)
{
	map<CString,CString>::iterator it;

	if (strNameIterator.IsEmpty())
	{
		// request to start iteration, if possible
		if (m_mapstrNetProps.empty())
			return false; // we're at end already
		it = m_mapstrNetProps.begin();
	}
	else if ((it= m_mapstrNetProps.find(strNameIterator)) != m_mapstrNetProps.end())
	{
		// iterate:
		if (++it == m_mapstrNetProps.end())
			return false;   // arrived at end
	}
	else
	{
		// invalid key 
		return false;
	}

	strNameIterator = (*it).first;
	return true;

}

// V3.2 enhancement for the Start Over button.
void CHTMLFragmentsTS::SetStartOverLink( const CString & str )
{
	m_strStartOverLink = str;
}

// V3.2 enhancement for the Start Over button.
CString CHTMLFragmentsTS::GetStartOverLink()
{
	return m_strStartOverLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\htmlfrag.h ===
//
// MODULE: HTMLFrag.h
//
// PURPOSE: declaration of the CHTMLFragments and CHTMLFragmentsTS classes.
//	This is how CInfer packages up fragments of HTML to be rendered in accord 
//	with a template.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-27-1998
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		8-27-98		JM		Original
//
//////////////////////////////////////////////////////////////////////

#ifndef __HTMLFRAG_H_
#define __HTMLFRAG_H_

#include <vector>
using namespace std;

// JSM V3.2
#include <map>
using namespace std;


#include "apgtsstr.h"

// Predefined variable names
//  They belong to DISPLAY command 
#define VAR_PROBLEM_ASK		_T("ProblemAsk")
#define VAR_RECOMMENDATIONS	_T("Recommendations")
#define VAR_STATES			_T("States")
#define VAR_QUESTIONS		_T("Questions")
#define VAR_SUCCESS			_T("Success")
#define VAR_STARTFORM		_T("StartForm")

// V3.2 Additions.
namespace
{
	const CString kstrCond_NumericCompare=	_T("NumericCompare");
}

struct FragmentID
{
	FragmentID() : Index(-1) {};
	FragmentID(const CString & v, int i) : VarName(v), Index(i) {};
	CString VarName;	// must be a known, predefined variable name
	int	Index;			// index into array associated with this variable name 
						//	OR -1 for not relevant
	bool operator < (const FragmentID & fid) const
		{ return (VarName < fid.VarName || Index < fid.Index); };
	bool operator == (const FragmentID & fid) const
		{ return (VarName == fid.VarName || Index == fid.Index); };
};


class CHTMLValue
{
	CString m_strValName;
	CString m_strValValue;

public:
	CHTMLValue() {}
	CHTMLValue(const CString& name) : m_strValName(name) {}
	CHTMLValue(const CString& name, const CString& value) : m_strValName(name), m_strValValue(value) {}
	virtual ~CHTMLValue() {}

public:
	bool operator == (const CHTMLValue& sib);

	void SetName(const CString& name) {m_strValName = name;}
	CString GetName() {return m_strValName;}

	bool SetValue(const CString& value);

	bool GetNumeric(long&);
	bool GetString(CString&);
	bool GetBoolean(bool&);

	bool IsValid() {return IsNumeric() || IsString() || IsBoolean();}
	bool IsNumeric();
	bool IsString();
	bool IsBoolean();
};


// vectors definition
typedef vector<FragmentID> FragmentIDVector;
typedef vector<CHTMLValue> HTMLValueVector;


// Template should see only a const object of this class
class CHTMLFragments
{
	HTMLValueVector m_HTMLValueVector;

public:
	enum FragCommand { eNotOfInterest, eResource };

public:
	CHTMLFragments() {};
	virtual ~CHTMLFragments()=0 {};
	// pure virtuals
	virtual int GetCount(const FragmentIDVector & fidvec) const =0;
	virtual CString GetText(const FragmentIDVector & fidvec, const FragCommand fragCmd= eNotOfInterest ) =0;
	virtual bool IsValidSeqOfVars(const FragmentIDVector & arrParents, const FragmentIDVector & arrChildren) const =0 ;
	// value handling
	virtual bool SetValue(const CString& assignment_expression);
	virtual CHTMLValue* GetValue(const CString& value_name);
	// JSM V3.2 needed by mechanism which replaces <!GTS property "netprop">
	//   w/ the corresponding BNTS network property
	virtual CString GetNetProp(const CString & strNetPropName) = 0;

	// V3.2 enhancement for the Start Over button.
	virtual void SetStartOverLink( const CString & str ) {};		
	virtual CString GetStartOverLink() {return _T("");}
};


// Implementation specific to the predefined variables above
class CHTMLFragmentsTS : public CHTMLFragments
{
#ifdef __DEBUG_CUSTOM
	protected:
#else
	private:
#endif
	const bool m_bIncludesHistoryTable;
	const bool m_bIncludesHiddenHistory;
	CString m_strStartForm;			// The fixed, initial part of the HTML form on every
									//	page that has a form.  (The FORM tag + the topic 
									//	name in a hidden field of that form)
	CString	m_strProblem;			// problem name (for history table)
	vector<CString>	m_vstrVisitedNodes;	// name of each visited node (for history table)
#pragma warning(disable:4786)
	vector< vector<CString> > m_vvstrStatesOfVisitedNodes; // text corresponding
									// to each state of each visited node (for history table).
									// This includes radio button.
	CString	m_strCurrentNode;		// full text for current node, sometimes includes
									//	hidden history
	CString	m_strCurrentNodeSimple;	// text for current node, always excludes hidden history
	CString	m_strHiddenHistory;		// If there is to be no history table, this encodes
									//	the history in hidden fields (for an HTML form)
	CString m_strNil;
	CString m_strYes;				// constant "Yes" for m_bSuccess == true
	bool m_bSuccess;				// true only is current node is BYE (success) node.
	const CString m_strScriptPath;		// path to the resource directory, used for server side logic.

	CString m_strStartOverLink;		// V3.2 - for Online TS, contains the text for the start over 
									//	link (which is disguised as a button).  Unlike other
									//	properties, this is set by APGTSContext and gotten
									//	by CInfer, not set by CInfer and gotten by CAPGTSHTIReader

	//  V3.2  map BNTS network property name to net property (value)
	//    allows us to convert <!GTS property "netprop"> when reading the HTI file 
	map<CString,CString> m_mapstrNetProps;  
private:
	CHTMLFragmentsTS();				// Do not instantiate


public:
	CHTMLFragmentsTS( const CString & strScriptPath, bool bIncludesHistoryTable );
	~CHTMLFragmentsTS();

	// inherited methods
	int GetCount(const FragmentIDVector & fidvec) const;
	CString GetText( const FragmentIDVector & fidvec, const FragCommand fragCmd= eNotOfInterest );
	virtual bool IsValidSeqOfVars(const FragmentIDVector & arrParents, const FragmentIDVector & arrChildren) const;
	void SetStartOverLink( const CString & str );		// V3.2 enhancement for the Start Over button.
	CString GetStartOverLink();		// V3.2 enhancement for the Start Over button.

	// methods specific to this class
	void SetStartForm(const CString & str);
	void SetProblemText(const CString & str);
	void SetCurrentNodeText(const CString & str);
	void SetHiddenHistoryText(const CString & str);
	void SetSuccessBool(bool bSuccess);
	CString GetCurrentNodeText();
	int PushBackVisitedNodeText(const CString & str);
	int PushBackStateText(UINT iVisitedNode, const CString & str);
	bool IncludesHistoryTable() const;
	bool IncludesHiddenHistory() const;

	// Functions which parse and evaluate numeric and string conditionals.
	bool	NumericConditionEvaluatesToTrue( const CString & str );
	bool	StringConditionEvaluatesToTrue( const CString & str );
	CString RemoveOuterParenthesis( const CString & str );
	bool	RetNumericOperands(	const CString & str, const CString & strOperator,
								long &lLeftOperand, long &lRightOperand );
	bool	RetStringOperands(	const CString & str, const CString & strOperator,
								CString & strLeftOperand, CString & strRightOperand );
	int		CleanStringOperand( CString& strOperand );

	// 	JSM V3.2 these functions used by the mechanism which replaces
	//  <!GTS property "netprop"> w/ the corresponding BNTS network property
	//
	//    CAPGTSHTIReader finds the names of the network properties and passes
	//       them in via AddNetPropName
	//    CInfer later gets the network property names, calls the BNTS
	//       to find out the network property values, and passes the values to HTMLFragmentsTS
	//    Later, CAPGTSHTIReader queries HTMLFragmentsTS for network property values
	//       during the parsing process.
	//
	//  add the name of a network property to the internal list
	void AddNetPropName(const CString & strNetPropName);
	// returns the network property, requested by name. (returns null if not avail.)
	CString GetNetProp(const CString & strNetPropName);
	 // set the value of the network property identified by strNetPropName
	BOOL SetNetProp(CString strNetPropName, CString strNetProp);
	// iterate (by name) thru the list of net props
	BOOL IterateNetProp(CString & strNameIterator);
	// end JSM V3.2
private:
	void RebuildCurrentNodeText();
};
#endif // __HTMLFRAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\iniread.cpp ===
// MODULE: INIREAD.CPP
//
// PURPOSE: INI file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//	1. As of 1/99, needn't account for CHM file: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include "iniread.h"
#include "event.h"
#include "CharConv.h"

////////////////////////////////////////////////////////////////////////////////////
// CINIReader
////////////////////////////////////////////////////////////////////////////////////
CINIReader::CINIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR section)
          : CTextFileReader(pPhysicalFileReader),
			m_strSection(section)
{
}

CINIReader::~CINIReader()
{
}

void CINIReader::Parse()
{
	CString str;
	long save_pos = 0;
	CString section_with_brackets = CString(_T("[")) + m_strSection + _T("]");
	
	save_pos = GetPos();
	if (Find(section_with_brackets))
	{	// we have found section
		m_arrLines.clear();

		NextLine();
		try
		{
			while (GetLine(str))
			{
				str.TrimLeft();
				str.TrimRight();
				if (str.GetLength() == 0) // empty string
					continue;
				if (str[0] == _T('[')) // another section
					break;
				if (str[0] == _T(';')) // entry is commented
					continue;
				m_arrLines.push_back(str);
			}
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}
	SetPos(save_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\iniread.h ===
//
// MODULE: INIREAD.H
//
// PURPOSE: INI file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __INIREAD_H_
#define __INIREAD_H_

#include "fileread.h"

////////////////////////////////////////////////////////////////////////////////////
// CINIReader
////////////////////////////////////////////////////////////////////////////////////
class CINIReader : public CTextFileReader
{
	CString m_strSection;       // section name

protected:
	vector<CString> m_arrLines; // vector of non-commented lines

public:
	CINIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR section);
   ~CINIReader();

protected:
	virtual void Parse();
};

#endif __INIREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\launchserv_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Nov 23 13:59:17 1998
 */
/* Compiler settings for LaunchServ.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ILaunchTS = {0x131CC2A0,0x7634,0x11D1,{0x8B,0x6B,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const IID IID_ITShootATL = {0x66AC81E5,0x8926,0x11D1,{0x8B,0x7D,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const IID LIBID_LAUNCHSERVLib = {0x131CC291,0x7634,0x11D1,{0x8B,0x6B,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const CLSID CLSID_LaunchTS = {0x131CC2A1,0x7634,0x11D1,{0x8B,0x6B,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const CLSID CLSID_TShootATL = {0x66AC81E6,0x8926,0x11D1,{0x8B,0x7D,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\launchserv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Nov 23 13:59:17 1998
 */
/* Compiler settings for LaunchServ.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __LaunchServ_h__
#define __LaunchServ_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ILaunchTS_FWD_DEFINED__
#define __ILaunchTS_FWD_DEFINED__
typedef interface ILaunchTS ILaunchTS;
#endif 	/* __ILaunchTS_FWD_DEFINED__ */


#ifndef __ITShootATL_FWD_DEFINED__
#define __ITShootATL_FWD_DEFINED__
typedef interface ITShootATL ITShootATL;
#endif 	/* __ITShootATL_FWD_DEFINED__ */


#ifndef __LaunchTS_FWD_DEFINED__
#define __LaunchTS_FWD_DEFINED__

#ifdef __cplusplus
typedef class LaunchTS LaunchTS;
#else
typedef struct LaunchTS LaunchTS;
#endif /* __cplusplus */

#endif 	/* __LaunchTS_FWD_DEFINED__ */


#ifndef __TShootATL_FWD_DEFINED__
#define __TShootATL_FWD_DEFINED__

#ifdef __cplusplus
typedef class TShootATL TShootATL;
#else
typedef struct TShootATL TShootATL;
#endif /* __cplusplus */

#endif 	/* __TShootATL_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ILaunchTS_INTERFACE_DEFINED__
#define __ILaunchTS_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILaunchTS
 * at Mon Nov 23 13:59:17 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ILaunchTS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("131CC2A0-7634-11D1-8B6B-0060089BD8C4")
    ILaunchTS : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetShooterStates( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTroubleShooter( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrShooter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProblem( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProblem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNode( 
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMachine( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMachine) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPNPDevice( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGuidClass( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Test( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILaunchTSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILaunchTS __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILaunchTS __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILaunchTS __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShooterStates )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTroubleShooter )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrShooter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProblem )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProblem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNode )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMachine )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMachine);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPNPDevice )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuidClass )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceInstance )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Test )( 
            ILaunchTS __RPC_FAR * This);
        
        END_INTERFACE
    } ILaunchTSVtbl;

    interface ILaunchTS
    {
        CONST_VTBL struct ILaunchTSVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILaunchTS_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILaunchTS_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILaunchTS_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILaunchTS_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILaunchTS_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILaunchTS_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILaunchTS_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILaunchTS_GetShooterStates(This,pdwResult)	\
    (This)->lpVtbl -> GetShooterStates(This,pdwResult)

#define ILaunchTS_GetTroubleShooter(This,pbstrShooter)	\
    (This)->lpVtbl -> GetTroubleShooter(This,pbstrShooter)

#define ILaunchTS_GetProblem(This,pbstrProblem)	\
    (This)->lpVtbl -> GetProblem(This,pbstrProblem)

#define ILaunchTS_GetNode(This,iNode,pbstrNode)	\
    (This)->lpVtbl -> GetNode(This,iNode,pbstrNode)

#define ILaunchTS_GetState(This,iNode,pbstrState)	\
    (This)->lpVtbl -> GetState(This,iNode,pbstrState)

#define ILaunchTS_GetMachine(This,pbstrMachine)	\
    (This)->lpVtbl -> GetMachine(This,pbstrMachine)

#define ILaunchTS_GetPNPDevice(This,pbstr)	\
    (This)->lpVtbl -> GetPNPDevice(This,pbstr)

#define ILaunchTS_GetGuidClass(This,pbstr)	\
    (This)->lpVtbl -> GetGuidClass(This,pbstr)

#define ILaunchTS_GetDeviceInstance(This,pbstr)	\
    (This)->lpVtbl -> GetDeviceInstance(This,pbstr)

#define ILaunchTS_Test(This)	\
    (This)->lpVtbl -> Test(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetShooterStates_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ILaunchTS_GetShooterStates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetTroubleShooter_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrShooter);


void __RPC_STUB ILaunchTS_GetTroubleShooter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetProblem_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrProblem);


void __RPC_STUB ILaunchTS_GetProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetNode_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [in] */ short iNode,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrNode);


void __RPC_STUB ILaunchTS_GetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetState_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [in] */ short iNode,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrState);


void __RPC_STUB ILaunchTS_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetMachine_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMachine);


void __RPC_STUB ILaunchTS_GetMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetPNPDevice_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ILaunchTS_GetPNPDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetGuidClass_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ILaunchTS_GetGuidClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetDeviceInstance_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ILaunchTS_GetDeviceInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_Test_Proxy( 
    ILaunchTS __RPC_FAR * This);


void __RPC_STUB ILaunchTS_Test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILaunchTS_INTERFACE_DEFINED__ */


#ifndef __ITShootATL_INTERFACE_DEFINED__
#define __ITShootATL_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITShootATL
 * at Mon Nov 23 13:59:17 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ITShootATL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("66AC81E5-8926-11D1-8B7D-0060089BD8C4")
    ITShootATL : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SpecifyProblem( 
            /* [in] */ BSTR bstrNetwork,
            /* [in] */ BSTR bstrProblem,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrState,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Language( 
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MachineID( 
            /* [in] */ BSTR bstrMachineID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Test( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeviceInstanceID( 
            /* [in] */ BSTR bstrDeviceInstanceID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReInit( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchKnown( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LaunchWaitTimeOut( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LaunchWaitTimeOut( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Launch( 
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchDevice( 
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrPNPDeviceID,
            /* [in] */ BSTR bstrDeviceClassGUID,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferOnline( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PreferOnline( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITShootATLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITShootATL __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITShootATL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITShootATL __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpecifyProblem )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrNetwork,
            /* [in] */ BSTR bstrProblem,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNode )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrState,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Language )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MachineID )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrMachineID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Test )( 
            ITShootATL __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeviceInstanceID )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrDeviceInstanceID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReInit )( 
            ITShootATL __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchKnown )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LaunchWaitTimeOut )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LaunchWaitTimeOut )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Launch )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchDevice )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrPNPDeviceID,
            /* [in] */ BSTR bstrDeviceClassGUID,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreferOnline )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PreferOnline )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwStatus);
        
        END_INTERFACE
    } ITShootATLVtbl;

    interface ITShootATL
    {
        CONST_VTBL struct ITShootATLVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITShootATL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITShootATL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITShootATL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITShootATL_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITShootATL_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITShootATL_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITShootATL_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITShootATL_SpecifyProblem(This,bstrNetwork,bstrProblem,pdwResult)	\
    (This)->lpVtbl -> SpecifyProblem(This,bstrNetwork,bstrProblem,pdwResult)

#define ITShootATL_SetNode(This,bstrName,bstrState,pdwResult)	\
    (This)->lpVtbl -> SetNode(This,bstrName,bstrState,pdwResult)

#define ITShootATL_Language(This,bstrLanguage,pdwResult)	\
    (This)->lpVtbl -> Language(This,bstrLanguage,pdwResult)

#define ITShootATL_MachineID(This,bstrMachineID,pdwResult)	\
    (This)->lpVtbl -> MachineID(This,bstrMachineID,pdwResult)

#define ITShootATL_Test(This)	\
    (This)->lpVtbl -> Test(This)

#define ITShootATL_DeviceInstanceID(This,bstrDeviceInstanceID,pdwResult)	\
    (This)->lpVtbl -> DeviceInstanceID(This,bstrDeviceInstanceID,pdwResult)

#define ITShootATL_ReInit(This)	\
    (This)->lpVtbl -> ReInit(This)

#define ITShootATL_LaunchKnown(This,pdwResult)	\
    (This)->lpVtbl -> LaunchKnown(This,pdwResult)

#define ITShootATL_get_LaunchWaitTimeOut(This,pVal)	\
    (This)->lpVtbl -> get_LaunchWaitTimeOut(This,pVal)

#define ITShootATL_put_LaunchWaitTimeOut(This,newVal)	\
    (This)->lpVtbl -> put_LaunchWaitTimeOut(This,newVal)

#define ITShootATL_Launch(This,bstrCallerName,bstrCallerVersion,bstrAppProblem,bLaunch,pdwResult)	\
    (This)->lpVtbl -> Launch(This,bstrCallerName,bstrCallerVersion,bstrAppProblem,bLaunch,pdwResult)

#define ITShootATL_LaunchDevice(This,bstrCallerName,bstrCallerVersion,bstrPNPDeviceID,bstrDeviceClassGUID,bstrAppProblem,bLaunch,pdwResult)	\
    (This)->lpVtbl -> LaunchDevice(This,bstrCallerName,bstrCallerVersion,bstrPNPDeviceID,bstrDeviceClassGUID,bstrAppProblem,bLaunch,pdwResult)

#define ITShootATL_get_PreferOnline(This,pVal)	\
    (This)->lpVtbl -> get_PreferOnline(This,pVal)

#define ITShootATL_put_PreferOnline(This,newVal)	\
    (This)->lpVtbl -> put_PreferOnline(This,newVal)

#define ITShootATL_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_SpecifyProblem_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrNetwork,
    /* [in] */ BSTR bstrProblem,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_SpecifyProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_SetNode_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrState,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_Language_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrLanguage,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_MachineID_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrMachineID,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_MachineID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_Test_Proxy( 
    ITShootATL __RPC_FAR * This);


void __RPC_STUB ITShootATL_Test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_DeviceInstanceID_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrDeviceInstanceID,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_DeviceInstanceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_ReInit_Proxy( 
    ITShootATL __RPC_FAR * This);


void __RPC_STUB ITShootATL_ReInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_LaunchKnown_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_LaunchKnown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITShootATL_get_LaunchWaitTimeOut_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ITShootATL_get_LaunchWaitTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITShootATL_put_LaunchWaitTimeOut_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ITShootATL_put_LaunchWaitTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_Launch_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrCallerName,
    /* [in] */ BSTR bstrCallerVersion,
    /* [in] */ BSTR bstrAppProblem,
    /* [in] */ short bLaunch,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_Launch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_LaunchDevice_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrCallerName,
    /* [in] */ BSTR bstrCallerVersion,
    /* [in] */ BSTR bstrPNPDeviceID,
    /* [in] */ BSTR bstrDeviceClassGUID,
    /* [in] */ BSTR bstrAppProblem,
    /* [in] */ short bLaunch,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_LaunchDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITShootATL_get_PreferOnline_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB ITShootATL_get_PreferOnline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITShootATL_put_PreferOnline_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB ITShootATL_put_PreferOnline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_GetStatus_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB ITShootATL_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITShootATL_INTERFACE_DEFINED__ */



#ifndef __LAUNCHSERVLib_LIBRARY_DEFINED__
#define __LAUNCHSERVLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: LAUNCHSERVLib
 * at Mon Nov 23 13:59:17 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_LAUNCHSERVLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_LaunchTS;

class DECLSPEC_UUID("131CC2A1-7634-11D1-8B6B-0060089BD8C4")
LaunchTS;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TShootATL;

class DECLSPEC_UUID("66AC81E6-8926-11D1-8B7D-0060089BD8C4")
TShootATL;
#endif
#endif /* __LAUNCHSERVLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\htmlfraglocal.cpp ===
//
// MODULE: HTMLFrag.cpp
//
// PURPOSE: implementation of the CHTMLFragmentsLocal class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 1-19-1999
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		1-19-19		OK		Original
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "HTMLFragLocal.h"
#include "fileread.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#include "apgtsinf.h"
#include "resource.h"
#endif


/*static*/ bool CHTMLFragmentsLocal::RemoveBackButton(CString& strCurrentNode)
{
	int left = 0, right = 0;

	if (-1 != (left = strCurrentNode.Find(SZ_INPUT_TAG_BACK)))
	{
		right = left;
		while (strCurrentNode[++right] && strCurrentNode[right] != _T('>'))
			;
		if (strCurrentNode[right])
			strCurrentNode = strCurrentNode.Left(left) + strCurrentNode.Right(strCurrentNode.GetLength() - right - 1);
		else
			return false;
		return true;
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CHTMLFragmentsLocal::CHTMLFragmentsLocal( const CString & strScriptPath, bool bIncludesHistoryTable)
				   : CHTMLFragmentsTS( strScriptPath, bIncludesHistoryTable )
{
}

CString CHTMLFragmentsLocal::GetText(const FragmentIDVector & fidvec, const FragCommand fragCmd )
{
	if (!fidvec.empty())
	{
		const CString & strVariable0 = fidvec[0].VarName;	// ref of convenience
		int i0 = fidvec[0].Index;

		if (fidvec.size() == 1)
		{
			if ((fragCmd == eResource) && (strVariable0 == VAR_PREVIOUS_SCRIPT))
			{
				// Hard-coded server side include for backward compatibility.
				CString strScriptContent;
				
				strScriptContent.LoadString(IDS_PREVSCRIPT);
				return strScriptContent;
			}
			else if (strVariable0 == VAR_NOBACKBUTTON_INFO)
			{
				CString strCurrentNode = GetCurrentNodeText();
				RemoveBackButton(strCurrentNode);
				SetCurrentNodeText(strCurrentNode);
				return _T("");
			}
		}
	}
	
	return CHTMLFragmentsTS::GetText( fidvec, fragCmd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\localdirmonitor.cpp ===
// LocalDirMonitor.cpp: implementation of the CLocalDirectoryMonitor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LocalDirMonitor.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLocalDirectoryMonitor::CLocalDirectoryMonitor()
					  :	CLocalDirectoryMonitor()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\localdirmonitor.h ===
// LocalDirMonitor.h: interface for the CLocalDirectoryMonitor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOCALDIRMONITOR_H__9E418C74_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
#define AFX_LOCALDIRMONITOR_H__9E418C74_B256_11D2_8C8D_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "DirMonitor.h"

class CLocalDirectoryMonitor : public CDirectoryMonitor  
{
	CString m_strTopicName;

public:
	CLocalDirectoryMonitor();

public:
	void SetTopicName(const CString& strTopicName) {m_strTopicName = strTopicName;}
};

#endif // !defined(AFX_LOCALDIRMONITOR_H__9E418C74_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\locallstreader.h ===
//
// MODULE:	LocalLSTReader.H
//
// PURPOSE: Interface of the CLocalLSTReader class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Oleg Kalosha
// 
// ORIGINAL DATE: 01-22-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-22-99	OK		Original
//
//////////////////////////////////////////////////////////////////////


#if !defined(AFX_LOCALLSTREADER_H__9E418C73_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
#define AFX_LOCALLSTREADER_H__9E418C73_B256_11D2_8C8D_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "apgtslstread.h"


class CLocalTopicInfo : public CTopicInfo
{
	CString m_TopicFileExtension;

public:
	CLocalTopicInfo(CString ext) : CTopicInfo(), m_TopicFileExtension(ext) {}

public:
	virtual bool Init(CString & strResourcePath, vector<CString> & vecstrWords);
};


class CLocalLSTReader : public CAPGTSLSTReader  
{
	CString m_strTopicName;
	CString	m_strTopicFileExtension;

public:
	CLocalLSTReader(CPhysicalFileReader* pPhysicalFileReader, const CString& strTopicName);

protected:
	virtual void Open();
	virtual void ReadData(LPTSTR * ppBuf);
	virtual void Close();
	virtual CTopicInfo* GenerateTopicInfo();
};

#endif // !defined(AFX_LOCALLSTREADER_H__9E418C73_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\locallstreader.cpp ===
//
// MODULE:	LocalLSTReader.H
//
// PURPOSE: Implementation of the CLocalLSTReader class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Oleg Kalosha
// 
// ORIGINAL DATE: 01-22-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-22-99	OK		Original
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LocalLSTReader.h"
#include "apgts.h"
#include "apgtsregconnect.h"

//////////////////////////////////////////////////////////////////////
// CLocalTopicInfo
//////////////////////////////////////////////////////////////////////

bool CLocalTopicInfo::Init(CString & strResourcePath, vector<CString> & vecstrWords)
{
	for (vector<CString>::iterator i = vecstrWords.begin(); i != vecstrWords.end(); i++)
	{
		CString str_extension = CString(_T(".")) + CAbstractFileReader::GetJustExtension(*i);

		str_extension.MakeLower();
		if (str_extension == m_TopicFileExtension)
		{
			m_DscFilePath = ::FormFullPath(strResourcePath, *i);
			m_DscFilePath.MakeLower();
			if (! m_NetworkName.GetLength()) 
			{
				m_NetworkName = *i;
				int len = m_NetworkName.GetLength()-(m_TopicFileExtension.GetLength());
				m_NetworkName = m_NetworkName.Left(len);
				m_NetworkName.MakeLower();
			}
		}
	}

	return CTopicInfo::Init(strResourcePath, vecstrWords);
}

//////////////////////////////////////////////////////////////////////
// CLocalLSTReader
//////////////////////////////////////////////////////////////////////

CLocalLSTReader::CLocalLSTReader(CPhysicalFileReader* pPhysicalFileReader, const CString& strTopicName)
			   : CAPGTSLSTReader(pPhysicalFileReader),
			     m_strTopicName(strTopicName)
{
	CAPGTSRegConnector APGTSRegConnector(m_strTopicName);
	int stub1 =0, stub2 =0;

	if (!APGTSRegConnector.Read(stub1, stub2) ||
		!APGTSRegConnector.GetStringInfo(CAPGTSRegConnector::eTopicFileExtension, m_strTopicFileExtension))
	{
		m_strTopicFileExtension = APGTSLSTREAD_DSC;
	}
	else
	{
		m_strTopicFileExtension.MakeLower();
	}
}

void CLocalLSTReader::Open()
{
}

void CLocalLSTReader::ReadData(LPTSTR * ppBuf)
{
	CString data;

	data += CFG_HEADER;
	data += _T("\r\n");
	data += m_strTopicName + m_strTopicFileExtension;
	data += _T(",");
	data += m_strTopicName + APGTSLSTREAD_HTI;
	data += _T(",");
	data += m_strTopicName + APGTSLSTREAD_TSC;
	data += _T(",");
	data += m_strTopicName;

	*ppBuf = new TCHAR[data.GetLength() + 1];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(*ppBuf)
	{
		memcpy(*ppBuf, (LPCTSTR)data, data.GetLength());
		(*ppBuf)[data.GetLength()] = 0;
	}
}

void CLocalLSTReader::Close()
{
}

CTopicInfo* CLocalLSTReader::GenerateTopicInfo()
{
	return new CLocalTopicInfo(m_strTopicFileExtension);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\logstring.cpp ===
//
// MODULE: LogString.cpp
//
// PURPOSE: implementation of the CLogString class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 7/24/1998
//
// NOTES: 
// 1. For public "Add" methods of this class: unless otherwise noted, if called more than once, 
//		only last call is significant
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-24-98		JM		Major revision, deprecate IDH.
//

#include "stdafx.h"
#include "LogString.h"
#include "SafeTime.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLogString::CLogString()
{
	time( &m_timeStart );
	m_bLoggedError = false;
	m_dwError = 0;
	m_dwSubError = 0;
}

CLogString::~CLogString()
{
}

CString CLogString::GetStr() const
{
	CString str;
	CString strDuration;
	
	GetDurationString(strDuration);

	GetStartTimeString(str);
	str += _T(", ");
	str += m_strCookie;
	str += m_strTopic;
	str += strDuration;
	str += _T(", ");
	str += m_strStates;
	str += m_strCurNode;
	if (m_bLoggedError)
	{
		CString strError;
		strError.Format(_T(", Err=%ld(%ld)"), m_dwError, m_dwSubError);
		str +=strError;
	}
	str += _T("\n");

	return str;
}

void CLogString::AddCookie(LPCTSTR szCookie)
{
	m_strCookie = szCookie;
}

// INPUT szTopic: troubleshooter topic (a.k.a. troubleshooter symbolic name)
void CLogString::AddTopic(LPCTSTR szTopic)
{
	m_strTopic.Format(_T(" %s,"), szTopic);
}

// Must be called repeatedly for successive nodes.
// If you want to display nodes in a particular order, this must be called in that order.
void CLogString::AddNode(NID nid, IST ist)
{
	CString str;
	str.Format(_T("[%d:%d], "), nid, ist);

	m_strStates += str;
}

// Add current node (no state because we are currently visiting it)
void CLogString::AddCurrentNode(NID nid)
{
	m_strCurNode.Format(_T("Page=%d"), nid);
}

// Only logs an error if dwError != 0
// Can call with dwError == 0 to clear previous error
void CLogString::AddError(DWORD dwError/* =0 */, DWORD dwSubError/* =0 */)
{
	m_bLoggedError = dwError ? true :false;
	if (m_bLoggedError)
	{
		m_dwError = dwError;
		m_dwSubError = dwSubError;
	}
}


// OUTPUT str contains start date/time in form used in log.
void CLogString::GetStartTimeString(CString& str) const
{
	TCHAR buf[100];		// plenty big for date/time string

	{
		// minimize how long we use CSafeTime, because it means holding a mutex.
		CSafeTime safe(m_timeStart);
		_tcscpy(buf, _tasctime(&(safe.LocalTime())));
	}
	if (_tcslen(buf))
		buf[_tcslen(buf)-1] = _T('\0');// remove cr

 	str = buf;
}

// OUTPUT str contains form used in log of duration in seconds since m_timeStart.
void CLogString::GetDurationString(CString& str) const
{
	time_t timeNow;
	time( &timeNow );

	str.Format(_T(" Time=%02ds"), timeNow - m_timeStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\logstring.h ===
// LogString.h: interface for the CLogString class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGSTRING_H__1606B935_224D_11D2_95D3_00C04FC22ADD__INCLUDED_)
#define AFX_LOGSTRING_H__1606B935_224D_11D2_95D3_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsstr.h"	// for CString, which is NOT MFC CString.
#include "nodestate.h"

class CLogString
{
private:
	time_t m_timeStart;		// Time this CLogString object was created
	CString m_strCookie;
	CString m_strTopic;
	CString m_strStates;	// node/state (NID/IST) pairs
	CString m_strCurNode;	// current node
	bool m_bLoggedError;	// true ==> there was an error logged, in which case the next two
							//	variables are meaningful.
	DWORD m_dwError;
	DWORD m_dwSubError;
public:
	CLogString();
	~CLogString();

	CString GetStr() const;

	void AddCookie(LPCTSTR szCookie);
	void AddTopic(LPCTSTR szTopic);
	void AddNode(NID nid, IST ist);
	void AddCurrentNode(NID nid);
	void AddError(DWORD dwError=0, DWORD dwSubError=0);
private:
	void GetStartTimeString(CString& str) const;
	void GetDurationString(CString& str) const;
};

#endif // !defined(AFX_LOGSTRING_H__1606B935_224D_11D2_95D3_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\localregconnect.cpp ===
//
// MODULE: LOCALREGCONNECT.CPP
//
// PURPOSE: read - write to the registry; simulate this in some cases where Online TS uses
//	registry, but Local TS doesn't
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 8-24-98 in Online TS
//
// NOTES: 
//	1. This file is for Local TS only
//	2. If we are moving toward a COM object at some point, we will probably have to establish an
//		abstract class in lieu of CAPGTSRegConnector and have Online & Local TS's each derive their
//		own version.  Meanwhile (1/99), we share a common interface (defined in APGTSRegConnect.h)
//		but implement it differently.
//	3. >>> WORK IN PROGRESS !!!!  JM 1/19/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		09-10-98	JM		backslashing; access log file info
// V3.1		01-19-98	JM		branch out version exclusively for Local TS

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgtsregconnect.h"
#include "event.h"
#include "apgtsevt.h"
#include "apgtscls.h"
#include "apgts.h"
#include "apiwraps.h"
#include "CHMFileReader.h"

#define REG_LOCAL_TS_LOC		_T("SOFTWARE\\Microsoft")
LPCTSTR CAPGTSRegConnector::RegSoftwareLoc() {return REG_LOCAL_TS_LOC;}
#define REG_LOCAL_TS_PROGRAM	_T("TShoot")
LPCTSTR CAPGTSRegConnector::RegThisProgram() {return REG_LOCAL_TS_PROGRAM;}
// subordinate key, child to the above and parent to keys for individual troubleshooter topics.
#define REG_LOCAL_TS_LIST		_T("TroubleshooterList")
// where the topic-specific resource path is located ("\TroubleshooterList\Topic_name\Path"):
#define TOPICRESOURCE_STR		_T("Path")
// where the topic-specific resource path is located ("\TroubleshooterList\Topic_name\Path"):
#define TOPICFILE_EXTENSION_STR	_T("FExtension")

// registry value defaults
// Most relevant values differ from Online TS

// (Looks like old Local TS uses the same default resource path as Online TS, so we'll
//	preserve that here >>> till we work out what's right - JM 1/19/99)
#define DEF_FULLRESOURCE			_T("c:\\inetsrv\\scripts\\apgts\\resource")

#define DEF_VROOTPATH				_T("/scripts/apgts/apgts.dll")  // (irrelevant in Local TS)
#define DEF_MAX_THREADS				1				// only 1 pool thread in Local TS
#define DEF_THREADS_PER_PROCESSOR	1				// only 1 pool thread in Local TS
#define DEF_MAX_WORK_QUEUE_ITEMS	1				// only 1 work queue item at a time in Local TS
#define DEF_COOKIE_LIFE_IN_MINS		90				// (irrelevant in Local TS)
#define DEF_RELOAD_DELAY			50				// (irrelevant in Local TS)
#define DEF_DETAILED_EVENT_LOGGING	0
#define DEF_TOPICFILE_EXTENSION		_T(".dsc")
#define DEF_SNIFF_AUTOMATIC			1
#define DEF_SNIFF_MANUAL			1

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector::CRegistryInfo
////////////////////////////////////////////////////////////////////////////////////
void CAPGTSRegConnector::CRegistryInfo::SetToDefault()
{
	// Attempt to extract a default resource path based upon the DLL name.
	// It was a deliberate decision to utilize the existing global module handle. 
	strResourcePath= _T("");
	if (INVALID_HANDLE_VALUE != ghModule)
	{
		// Build the default resource path from the module name.
		DWORD len;
		TCHAR szModulePath[MAXBUF];
		CString strModulePath;

		len = ::GetModuleFileName( reinterpret_cast<HMODULE>(ghModule), szModulePath, MAXBUF - 1 );
		if (len!=0) 
		{
			szModulePath[len] = _T('\0');
			strModulePath = szModulePath;
			strResourcePath = CAbstractFileReader::GetJustPath(strModulePath);
			if (!strResourcePath.IsEmpty())
				strResourcePath += _T("\\resource\\");
		}
	}
	if (strResourcePath.IsEmpty())
		strResourcePath = DEF_FULLRESOURCE;

	strVrootPath = DEF_VROOTPATH;
	dwMaxThreads = DEF_MAX_THREADS;
	dwThreadsPP = DEF_THREADS_PER_PROCESSOR;
	dwMaxWQItems = DEF_MAX_WORK_QUEUE_ITEMS;
	dwCookieLife = DEF_COOKIE_LIFE_IN_MINS;
	dwReloadDelay = DEF_RELOAD_DELAY;
	dwDetailedEventLogging	= DEF_DETAILED_EVENT_LOGGING;
	dwSniffAutomatic = DEF_SNIFF_AUTOMATIC;
	dwSniffManual = DEF_SNIFF_MANUAL;
	strLogFilePath = DEF_FULLRESOURCE;
	strTopicFileExtension = DEF_TOPICFILE_EXTENSION;
	m_bIsRead = false;
}

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector
////////////////////////////////////////////////////////////////////////////////////
CAPGTSRegConnector::CAPGTSRegConnector(const CString& strTopicName)
				  :	m_strTopicName(strTopicName)
{
	Clear();
}

// OUTPUT maskChanged  or-ed ERegConnector-based mask of elements that have been 
//						changed since last read
// OUTPUT maskCreated  In Online TS, this is 
//						or-ed ERegConnector-based mask of elements that were created 
//						in registry (because they previously didn't exist in registry)
//						In Local TS, it always returns 0, because we don't do this.
void CAPGTSRegConnector::ReadUpdateRegistry(int & maskChanged, int & maskCreated)
{
	CRegUtil reg;
	bool was_created = false;
	CString str_tmp;
	DWORD dw_tmp = 0;

	maskChanged = 0;
	maskCreated = 0;
	try
	{
		// [BC - 20010302] - Registry access needs to be restricted to run local TShoot
		// for certain user accts, such as WinXP built in guest acct. To minimize change
		// access only restricted for local TShoot, not online.
		REGSAM samRegistryAccess= KEY_QUERY_VALUE | KEY_NOTIFY;
		if(RUNNING_ONLINE_TS())
			samRegistryAccess= KEY_QUERY_VALUE | KEY_WRITE;
		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, samRegistryAccess))
		{
			if(RUNNING_ONLINE_TS())
				samRegistryAccess= KEY_READ | KEY_WRITE;
			if (reg.Create(RegThisProgram(), &was_created, samRegistryAccess))
			{
				/////////////////////////////////////////////////////////////////////////////
				// Working in ...\TShoot root key
				reg.GetNumericValue(SNIFF_AUTOMATIC_STR, m_RegistryInfo.dwSniffAutomatic);

				/////////////////////////////////////////////////////////////////////////////
				// Working in ...\TShoot root key
				reg.GetNumericValue(SNIFF_MANUAL_STR, m_RegistryInfo.dwSniffManual);

				/////////////////////////////////////////////////////////////////////////////
				// VROOTPATH_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// MAX_THREADS_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// THREADS_PER_PROCESSOR_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// MAX_WORK_QUEUE_ITEMS_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// COOKIE_LIFE_IN_MINS_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// RELOAD_DELAY_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// DETAILED_EVENT_LOGGING_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// Now opening subkeys
				bool bFullResourceStrExists = reg.GetStringValue(FULLRESOURCE_STR, str_tmp);
				bool bTopicResourceExists = false;

				// check in troubleshooter list if topic-related resource path exists
				//  (it can be CHM file).
				if (reg.Create(REG_LOCAL_TS_LIST, &was_created, KEY_READ))
				{
					if (reg.Create(m_strTopicName, &was_created, KEY_READ))
					{
						if (reg.GetStringValue(TOPICRESOURCE_STR, str_tmp))
						{
							if (CCHMFileReader::IsPathToCHMfile(str_tmp))
								str_tmp = CCHMFileReader::FormCHMPath(str_tmp);
							else
								BackslashIt(str_tmp, true);
							
							if (AssignString(m_RegistryInfo.strResourcePath, str_tmp, 
								EV_GTS_SERVER_REG_CHG_DIR) )
							{
								maskChanged |= eResourcePath;
							}
							bTopicResourceExists = true;
						}
						
						reg.GetStringValue(TOPICFILE_EXTENSION_STR, m_RegistryInfo.strTopicFileExtension);
					}
				}

				if (bFullResourceStrExists && !bTopicResourceExists) 
				{
					BackslashIt(str_tmp, true);
					if (AssignString(m_RegistryInfo.strResourcePath, str_tmp, 
						EV_GTS_SERVER_REG_CHG_DIR) )
					{
						maskChanged |= eResourcePath;
					}
				}
			}
			else
				throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, eProblemWithKey);
		}
		else
			throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, eProblemWithKey);

		reg.Close();
		/* /////////////////////////////////////////////////////////////////////////
		///// >>> We are not using logging so far in the Local TS. Oleg. 02.01.99 //
		////////////////////////////////////////////////////////////////////////////
		// >>> The following may be irrelevant: I don't think we should ultimately be keeping
		//	such a log for Local TS. In any event, I've gotten rid of a bunch of certainly
		//	irrelevant code to read this from registry & make an entry in the event log. JM 1/19/99
		// Set the log file path arbitrarily to the current setting of the resource path
		m_RegistryInfo.strLogFilePath = m_RegistryInfo.strResourcePath;

		// Set m_RegistryInfo.strLogFilePath to the setting from the registry.
		// Note:	The code here should remain identical with the code in the catch block
		//			below (excluding the call to throw of course).
		BackslashIt( m_RegistryInfo.strLogFilePath, true);
		*/
	}
	catch (CAPGTSRegConnectorException&)
	{
		// Set m_RegistryInfo.strLogFilePath = m_RegistryInfo.strResourcePath in the
		// case where we could not get the log file path from the registry.
		BackslashIt( m_RegistryInfo.strLogFilePath, true );

		// Rethrow the exception upward to be logged.
		throw;
	}
}

// RETURN desired number of pool threads.  In Local TS, this is always 1!
DWORD CAPGTSRegConnector::GetDesiredThreadCount()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\localecb.h ===
//
// MODULE: LocalECB.H
//
// PURPOSE: Interface of CLocalECB class, which implements CAbstractECB by emulating Win32's
//	EXTENSION_CONTROL_BLOCK.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-07-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-07-99	JM		Original
//

#if !defined(_AFX_LOCAL_INCLUDED_)
#define _AFX_LOCAL_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsECB.h"
#include "TSNameValueMgr.h"
#include "apgtsstr.h"

class CRenderConnector;

class CLocalECB : public CAbstractECB, public CTSNameValueMgr 
{
	// emulating EXTENSION_CONTROL_BLOCK data members
	DWORD m_dwHttpStatusCode;		// only of relevance for debugging.
	CString& m_strWriteClient;
	HANDLE m_hEvent; // handler of event, main thread is waiting for;
					 //	 if NULL, main thread is not waiting for anything.
	CRenderConnector* m_pRenderConnector; // pointer to ATL control connector;
										  //  if NULL, write result page to m_strWriteClient,
										  //  otherwise call CRenderConnector::Render function.

public:
	CLocalECB(	const VARIANT& name, const VARIANT& value, int count, HANDLE hEvent, 
				CString* pstrWriteClient, CRenderConnector* pRenderConnector,
				bool bSetLocale, CString& strLocaleSetting );
	CLocalECB(	const CArrNameValue& arr, HANDLE hEvent, CString* pstrWriteClient, 
				CRenderConnector* pRenderConnector,
				bool bSetLocale, CString& strLocaleSetting );
	CLocalECB(CString* pstrWriteClient);
	~CLocalECB();

	// ======= inherited pure virtuals must be redefined =======
	virtual HCONN GetConnID() const;
	virtual DWORD SetHttpStatusCode(DWORD dwHttpStatusCode);
	virtual LPSTR GetMethod() const;
	virtual LPSTR GetQueryString() const;
	virtual DWORD GetBytesAvailable() const;
	virtual LPBYTE GetData() const;
	virtual LPSTR GetContentType() const;

    virtual BOOL GetServerVariable
   (  /*HCONN      hConn,*/
        LPCSTR       lpszVariableName,	// note, more const-ness than EXTENSION_CONTROL_BLOCK
        LPVOID      lpvBuffer,
        LPDWORD     lpdwSize );

    virtual BOOL WriteClient
   ( /*HCONN      ConnID,*/
	   LPCSTR	  Buffer,	// EXTENSION_CONTROL_BLOCK::WriteClient uses LPVOID, but it should
							//	only be legit to pass SBCS text, so we're enforcing that.
							// Also, we're adding const-ness.   
       LPDWORD    lpdwBytes
	   /* , DWORD      dwReserved */
       );

    virtual BOOL ServerSupportFunction
   ( /*HCONN      hConn,*/	// we always use the HCONN for this same COnlineECB
       DWORD      dwHSERRequest,
       LPVOID     lpvBuffer,
       LPDWORD    lpdwSize,
       LPDWORD    lpdwDataType );	

	// specific for CLocalECB class
public:
	const CString& GetWriteClient() const; // get data written by WriteClient()

private:
	// Specific for setting locales.
	bool	m_bSetLocale;
	CString	m_strLocaleSetting;
};

#endif // !defined(_AFX_LOCAL_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\localecb.cpp ===
//
// MODULE: LocalECB.H
//
// PURPOSE: Implementation of CLocalECB class, which implements CAbstractECB by emulating Win32's
//	EXTENSION_CONTROL_BLOCK.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-07-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-07-99	JM		Original
//

#include "stdafx.h"
#include "LocalECB.h"
#include "RenderConnector.h"
#include "locale.h"

// >>> Warning: Possible redefinition
//  should use #include "apgtscls.h"
// Oleg 01.12.99
#define CONT_TYPE_STR	"application/x-www-form-urlencoded"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLocalECB::CLocalECB(const VARIANT& name, const VARIANT& value, int count, 
					 HANDLE hEvent, CString* pstrWriteClient, 
					 CRenderConnector* pRenderConnector,
					 bool bSetLocale, CString& strLocaleSetting) 
		 : CTSNameValueMgr(name, value, count),
		   m_dwHttpStatusCode(500),
		   m_hEvent(hEvent),
		   m_strWriteClient(*pstrWriteClient),
		   m_pRenderConnector(pRenderConnector),
		   m_bSetLocale( bSetLocale ),
		   m_strLocaleSetting( strLocaleSetting )
{
}

CLocalECB::CLocalECB(const CArrNameValue& arr, HANDLE hEvent, 
					 CString* pstrWriteClient, CRenderConnector* pRenderConnector,
					 bool bSetLocale, CString& strLocaleSetting) 
		 : CTSNameValueMgr(arr),
		   m_dwHttpStatusCode(500),
		   m_hEvent(hEvent),
		   m_strWriteClient(*pstrWriteClient),
		   m_pRenderConnector(pRenderConnector),
		   m_bSetLocale( bSetLocale ),
		   m_strLocaleSetting( strLocaleSetting )
{
}

CLocalECB::CLocalECB(CString* pstrWriteClient)
		 : CTSNameValueMgr(),
		   m_dwHttpStatusCode(500),
		   m_hEvent(NULL),
		   m_strWriteClient(*pstrWriteClient),
		   m_pRenderConnector(NULL),
   		   m_bSetLocale( false )
{
}

CLocalECB::~CLocalECB()
{
}

// ConnID is irrelevant on Local TS, so we always return 0.
HCONN CLocalECB::GetConnID() const
{
	return 0;
}

DWORD CLocalECB::SetHttpStatusCode(DWORD dwHttpStatusCode)
{
	m_dwHttpStatusCode = dwHttpStatusCode;
	return m_dwHttpStatusCode;
}

// We act as if Method is always "POST"
LPSTR CLocalECB::GetMethod() const
{
	return "POST";
}

// Since we are always emulating "POST", there is no query string
LPSTR CLocalECB::GetQueryString() const
{
	return "";
}

DWORD CLocalECB::GetBytesAvailable() const
{
	return CTSNameValueMgr::GetData().GetLength();
}

LPBYTE CLocalECB::GetData() const
{
	return (LPBYTE)(LPCTSTR)CTSNameValueMgr::GetData();
}

// always say it's valid content ("application/x-www-form-urlencoded")
LPSTR CLocalECB::GetContentType() const
{
	return CONT_TYPE_STR;
}

// In Local TS, always return a null string.
BOOL CLocalECB::GetServerVariable
   ( /*HCONN      hConn,*/
    LPCSTR      lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize ) 
{
	if (CString(_T("SERVER_NAME")) == CString(lpszVariableName)) 
	{
		memset(lpvBuffer, 0, *lpdwSize);
		_tcsncpy((LPTSTR)lpvBuffer, _T("Local TS - no IP address"), *lpdwSize-2); // -2 in case og unicode
		return TRUE;
	}
	
	return FALSE;
}

BOOL CLocalECB::WriteClient
   ( /*HCONN      ConnID,*/
   LPCSTR	  Buffer,		// EXTENSION_CONTROL_BLOCK::WriteClient uses LPVOID, but it should
							//	only be legit to pass SBCS text, so we're enforcing that.
							// Also, we're adding const-ness.   Clearly, this really is const,
							//	but EXTENSION_CONTROL_BLOCK::WriteClient fails to declare it so.
   LPDWORD    lpdwBytes
   /* , DWORD      dwReserved */ 
   ) 
{
	if (*lpdwBytes <= 0) 
	{
		if (m_pRenderConnector)
			m_pRenderConnector->Render(_T(""));
		else
			m_strWriteClient = _T("");

		if (m_hEvent)
			::SetEvent(m_hEvent);

		return FALSE;
	}

	TCHAR* buf = new TCHAR[*lpdwBytes+1];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(!buf)
		return FALSE;

	memcpy(buf, Buffer, *lpdwBytes);
	buf[*lpdwBytes] = 0;

	// Set the locale if requested.
	CString strOrigLocale;
	if (m_bSetLocale)
		strOrigLocale= _tsetlocale( LC_CTYPE, m_strLocaleSetting );
	
	if (m_pRenderConnector) 
	{
		m_pRenderConnector->Render(buf);
		m_pRenderConnector->SetLocked(false);
	}
	else
		m_strWriteClient = buf;

	// Restore the locale if requested.
	if (m_bSetLocale)
		strOrigLocale= _tsetlocale( LC_CTYPE, strOrigLocale );

	if (m_hEvent)
		::SetEvent(m_hEvent);
	
	delete [] buf;
	return TRUE;
}

// The 2 imaginably germane values of dwHSERRequest are:
//	HSE_REQ_SEND_RESPONSE_HEADER:Sends a complete HTTP server response header, including the 
//		status, server version, message time, and MIME version. The ISAPI extension should 
//		append other HTTP headers such as the content type and content length, followed by 
//		an extra \r\n. This option allows the function to take only text, up to the first 
//		\0 terminator. The function with this parameter should only be called once per request.  
//	HSE_REQ_DONE_WITH_SESSION: Specifies that if the server extension holds on to the session 
//		because of extended processing requirements, the server must be notified when the 
//		session is finished so the server can close it and free its related structures. 
//		The parameters lpdwSize, and lpdwDataType are ignored. 
//		The lpvBuffer parameter may optionally point to a DWORD that contains HSE_STATUS codes. 
//		IIS recognizes HSE_STATUS_SUCCESS_WITH_KEEP_CONN for keeping the IIS connection alive 
//		if the client also requests to keep the connection alive. 
//		This parameter must be sent to the server if the HSE_IO_DISCONNECT_AFTER_SEND parameter 
//		has been included in the HSE_TF_INFO structure as part of a HSE_REQ_TRANSMIT_FILE request.
//		This parameter will explicitly close the connection. 
//  >>> Have no idea how to emulate server's behavior in case of local troubleshooter.
//   Oleg 01.13.99
BOOL CLocalECB::ServerSupportFunction
   ( /*HCONN      hConn,*/
   DWORD      dwHSERRequest,
   LPVOID     lpvBuffer,
   LPDWORD    lpdwSize,
   LPDWORD    lpdwDataType ) 
{
	return FALSE;
}

const CString& CLocalECB::GetWriteClient() const
{
	return m_strWriteClient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\maxbuf.h ===
//
// MODULE: MAXBUF.H
//
// PURPOSE: Declare buffer size macro
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-06-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-06-98	JM		get MAXBUF into a header file of its own
//

#if !defined(MAXBUF_H_INCLUDED)
#define MAXBUF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define MAXBUF	256				// length of text buffers used for filenames,
								// IP adresses (this is plenty big), HTTP response ( like
								// "200 OK", again, plenty big), registry keys, 
								// and occasionally just to format an arbitrary string.

#endif // !defined(MAXBUF_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\mutexowner.cpp ===
//
// MODULE: MutexOwner.cpp
//
// PURPOSE: strictly a utility class so we can properly construct & destruct a static mutex.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 11-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11-04-98	JM		extracted from SafeTime
//

#include "stdafx.h"
#include "MutexOwner.h"
#include "BaseException.h"
#include "Event.h"

//////////////////////////////////////////////////////////////////////
//CMutexOwner
//////////////////////////////////////////////////////////////////////

CMutexOwner::CMutexOwner(const CString & str)
{
	m_hmutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hmutex)
	{
		// Shouldn't ever happen, so we're not coming up with any elaborate strategy,
		//	but at least we log it.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								str,
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}
}

CMutexOwner::~CMutexOwner()
{
	::CloseHandle(m_hmutex);
}

HANDLE & CMutexOwner::Handle()
{
	return m_hmutex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\mutexowner.h ===
//
// MODULE: MutexOwner.h
//
// PURPOSE: strictly a utility class so we can properly construct & destruct a static mutex.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 11-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11-04-98	JM		extracted from SafeTime
//

#if !defined(AFX_MUTEXOWNER_H__7BFC10DD_741D_11D2_961D_00C04FC22ADD__INCLUDED_)
#define AFX_MUTEXOWNER_H__7BFC10DD_741D_11D2_961D_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "apgtsstr.h"

// strictly a utility class so we can properly construct & destruct a static mutex.
class CMutexOwner
{
private:
	HANDLE m_hmutex;
public:
	CMutexOwner(const CString & str);
	~CMutexOwner();
	HANDLE & Handle();
};


#endif // !defined(AFX_MUTEXOWNER_H__7BFC10DD_741D_11D2_961D_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\msitstg.h ===
//
// MODULE: MSITStg.h
//
// PURPOSE: Interface declaration for IMSITStorage
//
// COMPANY: This file was created by Microsoft and should not be changed by Saltmine 
//	except for comments
//
// ORIGINAL DATE: unknown.
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM		This header added.
//

// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\pointer.h ===
//
// MODULE: POINTER.H
//
// PURPOSE: Smart pointer that counts references, deletes object when no more references
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-8-98
//
// NOTES: 
// 1. Because these are templates, all code is in the header file.
// 2. counting_ptr is intended to be used as part of a "publishing system":
// A "publisher" creates a counting_ptr P to a heap object X.  "Clients" obtain access to X 
//	by copying P or assigning a counting_ptr to be equal to P.
// Write/copy/delete access to P should be under control of a mutex.  A single mutex may 
//	control access to multiple published objects.
// The publisher terminates the publication of *P by deleting or reassigning P. Once no client
//	is using *P, *P should go away.
// class X is expected to be an actual class.  If it is (say) an int, this will give 
//	warning C4284, because it makes no sense to use operator-> on an int.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-8-98		JM		
//

#ifndef __POINTER_H_
#define __POINTER_H_ 1

#include <windows.h>


#include <windef.h>
#include <winbase.h>

template<class X> class counting_ptr
{
private:

	template<class Y> class ref_counter
	{
	private:
		long m_RefCount;
		Y* m_px;
		~ref_counter() {};	// Force this to be on the heap.
	public:
		ref_counter(Y* px = 0) :
			m_RefCount(1),
			m_px (px)
			{}

		void AddRef() {::InterlockedIncrement(&m_RefCount);}

		void RemoveRef() 
		{
			if (::InterlockedDecrement(&m_RefCount) == 0)
			{
				delete m_px;
				delete this;
			}
		}

		Y& Ref()  const { return *m_px; }	// supports counting_ptr::operator*

		Y* DumbPointer() const { return m_px; }	// supports counting_ptr::operator->
	};

	ref_counter<X> *m_pLow;

public:
	// if px != NULL, *px MUST be on the heap (created with new).
	explicit counting_ptr(X* px=0) :
		m_pLow(new ref_counter<X>(px))
		{}

	counting_ptr(const counting_ptr<X>& sib) :
		m_pLow(sib.m_pLow) 
		{m_pLow->AddRef();}

	counting_ptr<X>& operator=(const counting_ptr<X>& sib) 
	{
		if (sib.m_pLow != m_pLow)
		{
			(sib.m_pLow)->AddRef();
			m_pLow->RemoveRef();
			m_pLow = sib.m_pLow;
		}
		return *this;
	}

	counting_ptr<X>& operator=( const X *px ) 
	{
		if (px != m_pLow->DumbPointer())
		{
			m_pLow->RemoveRef();

			// This const_cast was necessary in order to compile.
			m_pLow= new ref_counter<X>(const_cast<X *>(px));
		}
		return *this;
	}

	~counting_ptr()       { m_pLow->RemoveRef(); }

	X& operator*()  const { return m_pLow->Ref(); }

	X* operator->() const { return m_pLow->DumbPointer(); }

	X* DumbPointer() const { return m_pLow->DumbPointer(); }

	bool IsNull() const {return DumbPointer() == NULL;}
};

#endif // __POINTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\recentuse.h ===
//
// MODULE: RecentUse.h
//
// PURPOSE: To maintain a "session" this can track whether a give value (either 
//	a cookie value or an IP address) has been "recently" used
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 11-4-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11/4/98		JM		original
//

#if !defined(AFX_RECENTUSE_H__293EE757_7405_11D2_961D_00C04FC22ADD__INCLUDED_)
#define AFX_RECENTUSE_H__293EE757_7405_11D2_961D_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma warning(disable:4786)

#include <windows.h>
#include <time.h>
#include <map>
using namespace std;
#include "apgtsstr.h"

class CRecentUse  
{
private:
	typedef map<CString, time_t> TimeMap;
	DWORD m_minExpire;				// how long a value remains "recent" (in minutes)
	TimeMap m_Recent;				// for each CString we are tracking, the time 
									//  last used
public:
	CRecentUse(DWORD minExpire = 15);
	~CRecentUse();
	void Add(CString str);
	bool Validate(CString str);

private:
	bool Validate(TimeMap::iterator it);
	void Flush();
};

#endif // !defined(AFX_RECENTUSE_H__293EE757_7405_11D2_961D_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\recentuse.cpp ===
//
// MODULE: RecentUse.cpp
//
// PURPOSE: To maintain a "session" this can track whether a give value (either 
//	a cookie value or an IP address) has been "recently" used
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 11-4-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11/4/98		JM		original

#include "stdafx.h"
#include "RecentUse.h"

//////////////////////////////////////////////////////////////////////
// CRecentUse
//////////////////////////////////////////////////////////////////////

CRecentUse::CRecentUse(DWORD minExpire /* = 15 */)
{
	m_minExpire = minExpire;
}

CRecentUse::~CRecentUse()
{

}

// Start tracking a new value
// SIDE EFFECT: if there are more than 10 values being tracked, see if any of them
//	are out of date & get rid of them.  This strategy is efficient as long as m_Recent
//	never gets very big, which is the expectation in APGTS.
// Will fail silently in the very unlikely case that adding to the map throws an exception.
void CRecentUse::Add(CString str)
{
	time_t timeNow;
	time (&timeNow);
	try
	{
		m_Recent[str] = timeNow;
	}
	catch (...)
	{
	}

	// SIDE EFFECT
	if (m_Recent.size() > 10)
		Flush();
}

// If the input string value has been used within the relevant interval, return true 
//	and update the time of most recent use.
bool CRecentUse::Validate(CString str)
{
	bool bRet = false;

	TimeMap::iterator it = m_Recent.find(str);

	if ( it != m_Recent.end())
		bRet = Validate(it);

	return bRet;
}

// If the string value it->first has been used within the relevant interval, return true 
//	and update the time of most recent use (it->second).
// Before calling this, verify that it is a valid iterator, not m_Recent.end()
// SIDE EFFECT: if it->first hasn't been used within the relevant interval, remove *it
//	from m_Recent.  This side effect means that in the case of a false return, it no longer
//	will point to the same value.
bool CRecentUse::Validate(TimeMap::iterator it)
{
	bool bRet = false;

	time_t timeNow;
	time (&timeNow);

	if (timeNow - it->second < m_minExpire * 60 /* secs per min */)
	{
		bRet = true;
		it->second = timeNow;
	}
	else
		// SIDE EFFECT: it's not current, no point to keeping it around.
		m_Recent.erase(it);

	return bRet;
}

// Get rid of all elements of m_Recent that haven't been used within the relevant interval
void CRecentUse::Flush()
{
	TimeMap::iterator it = m_Recent.begin();
	while (it != m_Recent.end())
	{
		if (Validate(it))
			++it;	// on to the next
		else
			m_Recent.erase(it);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\registrymonitor.cpp ===
//
// MODULE: RegistryMonitor.cpp
//
// PURPOSE: Monitor changes to the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-16-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-16-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "RegistryMonitor.h"
#include "apgts.h"//Added 20010302 for RUNNING_LOCAL_TS macro
#include "event.h"
#include "apiwraps.h"	
#include "ThreadPool.h"
#include "apgtslog.h"	

//////////////////////////////////////////////////////////////////////
// CRegistryMonitor::ThreadStatus
//////////////////////////////////////////////////////////////////////
/* static */ CString CRegistryMonitor::ThreadStatusText(ThreadStatus ts)
{
	switch(ts)
	{
	 
		case eBeforeInit:		return _T("Before Init");
		case eInit:				return _T("Init");
		case eFail:				return _T("Fail");
		case eDefaulting:		return _T("Defaulting");
		case eWait:				return _T("Wait");
		case eRun:				return _T("Run");
		case eExiting:			return _T("Exiting");
		default:				return _T("");
	}
}

//////////////////////////////////////////////////////////////////////
// CRegistryMonitor
// This class does the bulk of its work on a separate thread.
// The thread is created in the constructor by starting static function
//	CDirectoryMonitor::RegistryMonitorTask
// That function, in turn does its work by calling private members of this class that
//	are specific to use on the RegistryMonitorTask thread.
// When this goes out of scope, its own destructor calls ShutDown to stop the thread,
//	waits for the thread to shut.
// Inherited methods from CRegistryMonitor are available to other threads.
//////////////////////////////////////////////////////////////////////

CRegistryMonitor::CRegistryMonitor(	CDirectoryMonitor & DirectoryMonitor, 
									CThreadPool * pThreadPool,
									const CString& strTopicName,
									CHTMLLog *pLog )
  : CAPGTSRegConnector( strTopicName ),
	m_DirectoryMonitor(DirectoryMonitor),
	m_bMustStartDirMonitor(true),
	m_bMustStartThreadPool(true),
	m_bShuttingDown(false),
	m_dwErr(0),
	m_ThreadStatus(eBeforeInit),
	m_time(0), 
	m_pThreadPool(pThreadPool),
	m_pLog( pLog )
{
	enum {eHevMon, eHevInit, eHevShut, eThread, eOK} Progress = eHevMon;

	SetThreadStatus(eBeforeInit);

	m_hevMonitorRequested = ::CreateEvent( 
		NULL, 
		FALSE, // release one thread (the RegistryMonitorTask) on signal
		FALSE, // initially non-signalled
		NULL);

	if (m_hevMonitorRequested)
	{
		Progress = eHevInit;
		m_hevInitialized =  ::CreateEvent( 
			NULL, 
			FALSE, // release one thread (this one) on signal
			FALSE, // initially non-signalled
			NULL);

		if (m_hevInitialized)
		{
			Progress = eHevShut;
			m_hevThreadIsShut = ::CreateEvent( 
				NULL, 
				FALSE, // release one thread (this one) on signal
				FALSE, // initially non-signalled
				NULL);

			if (m_hevThreadIsShut)
			{
				Progress = eThread;
				DWORD dwThreadID;	// No need to hold onto dwThreadID in member variable.
									// All Win32 functions take the handle m_hThread instead.
									// The one reason you'd ever want to know this ID is for 
									//	debugging

				// Note that there is no corresponding ::CloseHandle(m_hThread).
				// That is because the thread goes out of existence on the implicit 
				//	::ExitThread() when RegistryMonitorTask returns.  See documentation of
				//	::CreateThread for further details JM 10/22/98
				m_hThread = ::CreateThread( NULL, 
											0, 
											(LPTHREAD_START_ROUTINE)RegistryMonitorTask, 
											this, 
											0, 
											&dwThreadID);

				if (m_hThread)
					Progress = eOK;
			}
		}
	}

	if (m_hThread)
	{
		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hevInitialized ); 
	}
	else
	{
		m_dwErr = GetLastError();
		CString str;
		str.Format(_T("%d"), m_dwErr);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								(Progress == eHevMon) ?		_T("Can't create monitor event")
								: (Progress == eHevInit) ?	_T("Can't create \"init\" event")
								: (Progress == eHevShut) ?	_T("Can't create \"shut\" event")
								:							_T("Can't create thread"),
								str, 
								EV_GTS_ERROR_REGMONITORTHREAD );
		SetThreadStatus(eFail);

		if (m_hevMonitorRequested)
			::CloseHandle(m_hevMonitorRequested);

		if (m_hevInitialized)
			::CloseHandle(m_hevInitialized);

		if (m_hevThreadIsShut)
			::CloseHandle(m_hevThreadIsShut);
	}
}

CRegistryMonitor::~CRegistryMonitor()
{
	ShutDown();
	
	if (m_hevMonitorRequested)
		::CloseHandle(m_hevMonitorRequested);

	if (m_hevInitialized)
		::CloseHandle(m_hevInitialized);

	if (m_hevThreadIsShut)
		::CloseHandle(m_hevThreadIsShut);
}

void CRegistryMonitor::SetThreadStatus(ThreadStatus ts)
{
	Lock();
	m_ThreadStatus = ts;
	time(&m_time);
	Unlock();
}

DWORD CRegistryMonitor::GetStatus(ThreadStatus &ts, DWORD & seconds)
{
	time_t timeNow;
	Lock();
	ts = m_ThreadStatus;
	time(&timeNow);
	seconds = timeNow - m_time;
	Unlock();
	return m_dwErr;
}

// Only for use by this class's own destructor.
void CRegistryMonitor::ShutDown()
{
	Lock();
	m_bShuttingDown = true;
	if (m_hThread)
	{
		::SetEvent(m_hevMonitorRequested);
		Unlock();

		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hevThreadIsShut ); 
	}
	else
		Unlock();
}

// Must be called on RegistryMonitorTask thread.  Handles all work of monitoring the directory.
void CRegistryMonitor::Monitor()
{
	enum {eRegChange, eHev /*shutdown*/, eNumHandles};
	HANDLE	hList[eNumHandles]= { NULL };	// array of handles we can use when waiting for multiple events
	HKEY	hk= NULL;						// handle to key in registry

	DWORD dwNErr = 0;
	LONG lResult = ERROR_SUCCESS + 1;	// scratch for returns of any of several
							// calls to Win32 Registry fns.  Initialize to arbitrary value
							//  != ERROR_SUCCESS so we don't close what we haven't opened.

	SetThreadStatus(eInit);
	try
	{
		// create an event for registry notification
		hList[eRegChange] = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		if (hList[eRegChange] == NULL)
		{
			throw CGenSysException( __FILE__, __LINE__, 
									_T("Registry notification event"),
									EV_GTS_ERROR_REG_NFT_CEVT );
		}

		CString str = ThisProgramFullKey();

		// Technically, KEY_ALL_ACCESS is overkill, but this program should always
		//	run in an environment where this shoudl succeed, so we haven't bothered
		//	trying to limit to only the access we need.  At the very least, we need
		//	KEY_QUERY_VALUE | KEY_NOTIFY.
		// [BC - 20010302] - Registry access needs to be restricted to run local TShoot
		// for certain user accts, such as WinXP built in guest acct. To minimize change
		// access only restricted for local TShoot, not online.
		REGSAM samRegistryAccess= KEY_ALL_ACCESS;
		if(RUNNING_LOCAL_TS())
			samRegistryAccess= KEY_QUERY_VALUE | KEY_NOTIFY;
		lResult = RegOpenKeyEx(	HKEY_LOCAL_MACHINE, str, 0, samRegistryAccess, &hk );
		if (lResult != ERROR_SUCCESS)
		{
			CString strError;
			strError.Format(_T("%ld"),lResult);

			::SetEvent(m_hevInitialized);	// OK to ask this object for registry values;
											// of course, you'll just get defaults.

			SetThreadStatus(eDefaulting);

			throw CGeneralException(	__FILE__, __LINE__, strError,
										EV_GTS_ERROR_REG_NFT_OPKEY );
		}

		// ...and we also wait for an explicit wakeup
		hList[eHev] = m_hevMonitorRequested;

		while (true)
		{
			if (m_bShuttingDown)
				break;

			LoadChangedRegistryValues();

			::SetEvent(m_hevInitialized);	// OK to ask this object for registry values

			// set up to be informed of change
			lResult = ::RegNotifyChangeKeyValue(	hk,
												FALSE,
												REG_NOTIFY_CHANGE_LAST_SET,
												hList[eRegChange],
												TRUE);
			if (lResult != ERROR_SUCCESS) 
			{
				CString strError;
				strError.Format(_T("%ld"),lResult);

				throw CGeneralException(	__FILE__, __LINE__, strError,
											EV_GTS_ERROR_REG_NFT_SETNTF );
			}

			::ResetEvent(m_hevMonitorRequested);	// maybe we don't need to do this. JM 9/16/98

			SetThreadStatus(eWait);
			DWORD dwNotifyObj = WaitForMultipleObjects (
				eNumHandles,
				hList,
				FALSE,			// only need one object, not all
				INFINITE);
			SetThreadStatus(eRun);
		}
	}
	catch (CGenSysException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), x.GetSystemErrStr(), 
								x.GetErrorCode() ); 
	}
	catch (CGeneralException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), _T("General exception"), 
								x.GetErrorCode() ); 
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}

	if (hk != NULL)
		::RegCloseKey(hk);

	if (hList[eRegChange] != NULL) 
		::CloseHandle(hList[eRegChange]);

	SetThreadStatus(eExiting);

}

// Must be called on RegistryMonitorTask thread.  
void CRegistryMonitor::AckShutDown()
{
	Lock();
	::SetEvent(m_hevThreadIsShut);
	Unlock();
}

// get new registry values into our internal data structure.
void CRegistryMonitor::LoadChangedRegistryValues()
{
	int maskChanged;
	int maskCreated;
	
	Read(maskChanged, maskCreated);

	// It actually matters that we set reload delay before we set directory monitor path.
	//	The first time through here, the call to m_DirectoryMonitor.SetResourceDirectory
	//	actually sets loose the DirectoryMonitorTask 
	if ( (maskChanged & eReloadDelay) == eReloadDelay)
	{
		DWORD dwReloadDelay;
		GetNumericInfo(eReloadDelay, dwReloadDelay);
		m_DirectoryMonitor.SetReloadDelay(dwReloadDelay);
	}

	if ( m_bMustStartDirMonitor || (maskChanged & eResourcePath) == eResourcePath)
	{
		CString strResourcePath;
		GetStringInfo(eResourcePath, strResourcePath);
		m_DirectoryMonitor.SetResourceDirectory(strResourcePath);	// side effect: if the
								// directory monitor is not yet started, this tells it what
								// directory to monitor so it can start.
		m_bMustStartDirMonitor = false;
	}

	if ( (maskChanged & eDetailedEventLogging) == eDetailedEventLogging)
	{
		DWORD dw;			
		GetNumericInfo(eDetailedEventLogging, dw);
		CEvent::s_bLogAll =  dw ? true : false;
	}

	if ((maskChanged & eLogFilePath) == eLogFilePath)
	{
		// Notify the logging object about the new logging file path.
		CString strLogFilePath;

		GetStringInfo( eLogFilePath, strLogFilePath);
		m_pLog->SetLogDirectory( strLogFilePath );
	}

	if ( m_bMustStartThreadPool
	||	(maskChanged & eMaxThreads) == eMaxThreads
	||	(maskChanged & eThreadsPP) == eThreadsPP )
	{
		m_pThreadPool->ExpandPool(GetDesiredThreadCount());
		m_bMustStartThreadPool = false;
	}
	
	return;
}

//  Main routine of a thread responsible for monitoring the registry.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CRegistryMonitor::RegistryMonitorTask(LPVOID lpParams)
{
	reinterpret_cast<CRegistryMonitor*>(lpParams)->Monitor();
	reinterpret_cast<CRegistryMonitor*>(lpParams)->AckShutDown();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\propnames.h ===
//
// MODULE: PROPNAMES.H
//
// PURPOSE: Declare property names
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		8-31-98		JM		Extract this from apgtsinf.h
//

#if !defined(PROPNAMES_H_INCLUDED)
#define APGTSINF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//------- property types -----------
//  These are all possible properties of nodes or net

#define H_PROB_HD_STR		_T("HProbHd")
#define H_PROB_PAGE_TXT_STR	_T("HProbPageText")	// text before list of problems
#define H_PROB_TXT_STR		_T("HProbTxt")		// text of one problem (node property)
#define H_PROB_SPECIAL		_T("HProbSpecial")			// may contain "hide" to mean
														// not to be shown on problem page
#define H_NODE_HD_STR		_T("HNodeHd")
#define H_NODE_TXT_STR		_T("HNodeTxt")

#define H_NODE_DCT_STR		_T("HNodeDct")		// replacement for HNodeTxt when a 
												//	presumptive cause is sniffed.

#if 0 // removed 8/19/99 per request from John Locke & Alex Sloley
	#define H_ST_NORM_TXT_STR	_T("HStNormTxt")
	#define H_ST_AB_TXT_STR		_T("HStAbTxt")
#endif

#define H_ST_UKN_TXT_STR	_T("HStUknTxt")
#define MUL_ST_LONG_NAME_STR _T("MulStLongName")


#define HX_DOJ_HD_STR		_T("HXDOJHd")
#define HX_SER_HD_STR		_T("HXSERHd")
#define HX_SER_TXT_STR		_T("HXSERTxt")
#define HX_SER_NORM_STR		_T("HXSERNorm")
#define HX_SER_AB_STR		_T("HXSERAb")
#define HX_FAIL_HD_STR		_T("HXFAILHd")
#define HX_FAIL_TXT_STR		_T("HXFAILTxt")
#define HX_FAIL_NORM_STR	_T("HXFAILNorm")
#define HX_BYE_HD_STR		_T("HXBYEHd")
#define HX_BYE_TXT_STR		_T("HXBYETxt")
	
// Search strings get And'd together.  The first 2 are meant for binary nodes, the
//	last for multi-state.
#define H_NODE_NORM_SRCH_STR	_T("HNodeNormSrch")		
#define H_NODE_AB_SRCH_STR		_T("HNodeAbSrch")
#define MUL_ST_SRCH_STR			_T("MulStSrch")
// Net property.  If == "yes", we actually show the BES page. Otherwise just search without
//	showing the search page.
#define H_NET_SHOW_BES		_T("HNetShowBES")	// H_NET_SHOW_BES property no longer officially supported as of 981021.
// Net properties: default contents for BES & HTI.
#define H_NET_BES			_T("HNetBES")
#define H_NET_HTI_ONLINE	_T("HNetHTIOnline")
#define H_NET_HTI_LOCAL		_T("HNetHTILocal")

#define H_NET_DATE_TIME		_T("HNetDateTime")

//--------- New network properties for localization. ----------------
#define HTK_UNKNOWN_RBTN	_T("HTKUnknownRbtn")	// Network
#define	HTK_NEXT_BTN		_T("HTKNextBtn")		// Network
#define	HTK_START_BTN		_T("HTKStartBtn")		// Network
#define	HTK_BACK_BTN		_T("HTKBackBtn")		// Network
#define HTK_SNIF_BTN		_T("HTKSnifBtn")		// Network: this is label for a 
													//	sniff button on problem page for
													//	expensive sniffing.

// Network properties for Impossible Page (pseudo node when states contradict each other)
#define HTK_IMPOSSIBLE_HEADER _T("HXIMPHd")			
#define HTK_IMPOSSIBLE_TEXT	 _T("HXIMPTxt")
#define HX_IMPOSSIBLE_NORM_STR	_T("HXIMPNorm")

// Network properties for Sniff Fail Page (pseudo node when sniffing on startup shows all
//	causes are in their Normal states).  A.k.a. Sniff All Causes Normal Page, probably 
//	a better name but doesn't match the property names MS wanted.
#define HTK_SNIFF_FAIL_HEADER _T("HNetSniffFailHd")			
#define HTK_SNIFF_FAIL_TEXT	 _T("HNetSniffFailTxt")
#define HX_SNIFF_FAIL_NORM	_T("HNetSniffFailNorm")

#define H_NET_GENERATE_RESULTS_PAGE _T("HNetGenerateResultsPage")  // Defaults to true if 
					// not present.  If set false, Troubleshooter Assembler does not 
					// generate a "results" page for this topic.  This allows us to prevent 
					// custom Results pages getting overwritten

//--------- Sniffing related network and node properties. -----------
// See Sniffing Version 3.2.doc (functional spec) for more explanation
#define H_NET_SNIFF_ACTIVEX			_T("HNetSniffActiveX")	// CLSID of sniffing ActiveX
#define H_NET_SNIFF_EXTERNAL_SCRIPT _T("HNetSniffExternalScript") // Default external 
														//	script name
#define H_NET_SNIFF_LANGUAGE		_T("HNetSniffLanguage") // Language for script in 
														// "HNetSniffExternalScript":
														// "JavaScript" or "VBScript"
#define H_NET_MAY_SNIFF_MANUALLY	_T("HNetMaySniffManually")
#define H_NET_MAY_SNIFF_ON_STARTUP	_T("HNetMaySniffOnStartup")
#define H_NET_MAY_SNIFF_ON_FLY		_T("HNetMaySniffOnFly")
#define H_NET_RESNIFF_POLICY		_T("HNetResniffPolicy") // {"No"| "Explicit"| "Implicit"| "Yes"}
#define H_NET_CHECK_SNIFFING_CHECKBOX	_T("HNetCheckSniffingCheckbox") // If true, and if 
					// an AllowSniffing checkbox is present on the Problem Page, that box 
					// should have an initial state of "checked". 

#define H_NET_HIST_TABLE_SNIFFED_TEXT _T("HNetHistTableSniffedText") // Identifies sniffed 
					// nodes in any visible history table. English version: "SNIFFED"
#define H_NET_ALLOW_SNIFFING_TEXT	 _T("HNetAllowSniffingText") // Text for "AllowSniffing" 
					// checkbox. English version: "Allow automatic sniffing."
#define H_NET_TEXT_SNIFF_ONE_NODE	 _T("HNetTextSniffOneNode")	 // Text of "Sniff" button 
					// for sniffing a single node. English version "Sniff".
#define H_NET_TEXT_SNIFF_ALERT_BOX	 _T("HNetTextSniffAlertBox") // Text of alert box, 
					// displayed any time manually requested sniffing (of a single node) 
					// fails. English version "Could not sniff this node".

#define H_NODE_SNIFF_SCRIPT		_T("HNodeSniffScript")	// Script to sniff this node
#define H_NODE_MAY_SNIFF_MANUALLY	_T("HNodeMaySniffManually")
#define H_NODE_MAY_SNIFF_ON_STARTUP	_T("HNodeMaySniffOnStartup")
#define H_NODE_MAY_SNIFF_ON_FLY		_T("HNodeMaySniffOnFly")
#define H_NODE_MAY_RESNIFF			_T("HNodeMayResniff")		// Node may be resniffed
#define H_NODE_SNIFF_EXTERNAL_SCRIPT _T("HNodeSniffExternalScript") // Node-specific 
														//	external script name
#define H_NODE_SNIFF_LANGUAGE	_T("HNodeSniffLanguage") // Language for script in 
														// "HNodeSniffExternalScript":
														// "JavaScript" or "VBScript"
#define H_NODE_CAUSE_SEQUENCE 	_T("HCauseSequence")	//Provides a sequence to use if 
					// automatic sniffing on startup produces more than one sniffable Cause 
					// node as a presumptive cause
#define H_NODE_MANUAL_SNIFF_TEXT _T("HNodeManualSniffText") // text to explain the manual 
					// sniff button offered for this node.

#define H_NODE_PROB_SEQUENCE 	_T("HProbSequence")	// Provides a sequence for problems
					// on the Problem Page.

// Properties used only by TS Assembler
#define SZ_TS_TITLE _T("HXTITLETxt")
#define SZ_TS_METATAG _T("HNetMeta")
#define SZ_TS_CHARSET _T("HNetCharSet")
#define SZ_TS_DIRTAG _T("HNetDirTag")
// END Properties used only by TS Assembler

#endif // !defined(PROPNAMES_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\nodestate.cpp ===
//
// MODULE: NODESTATE.CPP
//
// PURPOSE: Implement some functions relevant to CNodeState
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10/99
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10/15/99	JM		original
//


#include "nodestate.h"
#include <algorithm>


// operator-= removes only identical node/state pairs.
// This is the appropriate behavior if lhs represents all current node states and rhs
//	represents sniffed values: if the node already deviates from a sniffed value, and
//	we are removing sniffed values, this sniffed value is irrelevant & shouldn't be
//	removed from lhs.
// this is an N-squared algorithm.  
// >>> $MAINT There might be a case for working with sorted lists and STL generic 
//	algorithms, which could reduce this to N log N
CBasisForInference& operator-=(CBasisForInference& lhs, const CBasisForInference& rhs)
{
	CBasisForInference::iterator i = lhs.begin();
	while ( i != lhs.end() )
	{
		NID inid = i->nid();
		IST istate = i->state();
		bool bMatch = false;

		for (CBasisForInference::const_iterator j = rhs.begin(); j != rhs.end(); ++j)	
		{
			if (j->nid() == inid && j->state() == istate)
			{
				bMatch = true;
				break;
			}
		}
		if (bMatch)
			i = lhs.erase(i);
		else
			++i;
	}
		
	return lhs;
}

// operator+= adds only pairs for which there is no match to any node already in lhs.
// This is the appropriate behavior if lhs represents node states obtained by means other
//	than sniffing and rhs represents re-sniffed values: if the node already has a value 
//	assigned by other means, the sniffed values are irrelevant & shouldn't be
//	added to lhs.
// this is an N-squared algorithm.  
// >>> $MAINT There might be a case for working with sorted lists and STL generic 
//	algorithms, which could reduce this to N log N
CBasisForInference& operator+=(CBasisForInference& lhs, const CBasisForInference& rhs)
{
	for (CBasisForInference::const_iterator j = rhs.begin(); j != rhs.end(); ++j)	
	{
		NID jnid = j->nid();
		bool bMatch = false;

		for (CBasisForInference::const_iterator i = lhs.begin(); i != lhs.end(); ++i)
		{
			if (i->nid() == jnid)
			{
				bMatch = true;
				break;
			}
		}
		if (!bMatch)
			lhs.push_back(*j);
	}
		
	return lhs;
}

vector<NID>& operator-=(vector<NID>& lhs, const CBasisForInference& rhs)
{
	for (long i = 0; i < rhs.size(); i++)
	{
		vector<NID>::iterator found = find(lhs.begin(), lhs.end(), rhs[i].nid());

		if (found < lhs.end())
			lhs.erase(found);
	}
	return lhs;
}

vector<NID>& operator+=(vector<NID>& lhs, const CBasisForInference& rhs)
{
	for (long i = 0; i < rhs.size(); i++)
		lhs.push_back(rhs[i].nid());

	return lhs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\nodestate.h ===
//
// MODULE: NODESTATE.H
//
// PURPOSE: Declare types and values relevant to NID (node ID) and IST (state)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-21-98		JM		Major revision, deprecate IDH in favor of NID, use STL.
//								Extract this from apgtsinf.h, apgtscac.h
//

#if !defined(NODESTATE_H_INCLUDED)
#define APGTSINF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include<windows.h>
#include <vector>
using namespace std;

typedef unsigned int	   NID;		// node ID

//  Special node values
//	Please Note: nidService and nidNil are mirrored in dtguiapi.bas, please keep in sync
const NID	nidService = 12345;
const NID	nidNil     = 12346;

// newly introduced 7/1998
const NID	nidProblemPage = 12000;
const NID	nidByeNode = 12101;
const NID	nidFailNode = 12102;
const NID	nidImpossibleNode = 12103;
const NID	nidSniffedAllCausesNormalNode = 12104;

typedef vector<NID> CRecommendations;

// The IDHs are a deprecated feature provided only for backward compatibility on
//	GET method inquiries.  Most IDHs are NID + 1000; there are also several special values.
typedef	UINT	IDH;
const IDH IDH_BYE = 101;
const IDH IDH_FAIL = 102;
const IDH idhFirst = 1000;

typedef UINT   IST;		// state number
// Special state numbers
const IST ST_WORKED	= 101;	// Go to "Bye" Page (User succeeded)
const IST ST_UNKNOWN = 102; // Unknown (user doesn't know the correct answer here - applies to 
							//	Fixable/Unfixable and Info nodes only)
const IST ST_ANY = 103;		// "Anything Else?"

class CNodeStatePair
{
private:
	NID m_nid;
	IST m_state;
public:
	CNodeStatePair();  // do not instantiate; exists only so vector can compile

	// the only constructor you should call is:
	CNodeStatePair(const NID n, const IST s) :
		m_nid(n), m_state(s)
		{};

	bool operator< (const CNodeStatePair &pair) const
	{
		return (m_nid < pair.m_nid || m_state < pair.m_state);
	}

	bool operator== (const CNodeStatePair &pair) const
	{
		return (m_nid == pair.m_nid && m_state == pair.m_state);
	}

	NID nid() const {return m_nid;}
	IST state() const {return m_state;}
};

typedef vector<CNodeStatePair> CBasisForInference;


CBasisForInference& operator-=(CBasisForInference& lhs, const CBasisForInference& rhs);
CBasisForInference& operator+=(CBasisForInference& lhs, const CBasisForInference& rhs);

vector<NID>& operator-=(vector<NID>& lhs, const CBasisForInference& rhs);
vector<NID>& operator+=(vector<NID>& lhs, const CBasisForInference& rhs);


#endif // !defined(NODESTATE_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\registrymonitor.h ===
//
// MODULE: RegistryMonitor.h
//
// PURPOSE: Monitor changes to the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-16-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-16-98	JM
//

#if !defined(AFX_REGISTRYMONITOR_H__A3CFA77B_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
#define AFX_REGISTRYMONITOR_H__A3CFA77B_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "DirMonitor.h"
#include "apgtsregconnect.h"

class CThreadPool;		// forward reference
class CHTMLLog;			// forward reference

class CRegistryMonitor : public CAPGTSRegConnector
{
public:
	enum ThreadStatus{eBeforeInit, eInit, eFail, eDefaulting, eWait, eRun, eExiting};
	static CString ThreadStatusText(ThreadStatus ts);
private:
	CDirectoryMonitor & m_DirectoryMonitor; // Need access to this because CRegistryMonitor
											// will determine what directory needs to be monitored
											// and what the criteria are for files "settling down"
	HANDLE m_hThread;
	HANDLE m_hevMonitorRequested;			// event to wake up RegistryMonitorTask
											// this allows it to be wakened other than
											// by the registry change event.  Currently used
											// only for shutdown.
	HANDLE m_hevInitialized;				// event to be set when either:
											//	(1) CRegistryMonitor values have been initialized or
											//		from registry
											//	(2) We can't get registry access, so CRegistryMonitor
											//		default values will have to do
	bool m_bMustStartDirMonitor;			// initially true, false once we've given
											//	DirMonitor info as to what directory to
											//	monitor
	bool m_bMustStartThreadPool;			// initially true, false once we've set some size for the
											//	working-thread pool
	HANDLE m_hevThreadIsShut;				// event just to indicate exit of RegistryMonitorTask thread
	bool m_bShuttingDown;					// lets registry monitor thread know we're shutting down
	DWORD m_dwErr;							// status from starting the thread
	ThreadStatus m_ThreadStatus;
	time_t m_time;							// time last changed ThreadStatus.  Initialized
											// to zero ==> unknown
	CThreadPool * m_pThreadPool;			// pointer to pool of working threads

	CString m_strTopicName;					// This string is ignored in the Online Troubleshooter.
											// Done under the guise of binary compatibility.

	CHTMLLog *m_pLog;						// pointer to the logging object so that we can
											// change the log file directory.

public:
	CRegistryMonitor(	CDirectoryMonitor & DirectoryMonitor, CThreadPool * pThreadPool,
						const CString& strTopicName,
						CHTMLLog *pLog );	// strTopicName is ignored in the Online Troubleshooter.
											// Done under the guise of binary compatibility.
	virtual ~CRegistryMonitor();

	DWORD GetStatus(ThreadStatus &ts, DWORD & seconds);

	// NOTE that this also provides many inherited CRegistryMonitor methods
private:
	CRegistryMonitor();		// do not instantiate
	void SetThreadStatus(ThreadStatus ts);

	// just for use by own destructor
	void ShutDown();

	// functions for use by the DirectoryMonitorTask thread.
	void Monitor();
	void AckShutDown();
	void LoadChangedRegistryValues();

	// main function of the RegistryMonitorTask thread.
	static UINT WINAPI RegistryMonitorTask(LPVOID lpParams);
};

#endif // !defined(AFX_REGISTRYMONITOR_H__A3CFA77B_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\registrypasswords.h ===
//
// MODULE: RegistryPasswords.h
//
// PURPOSE: Handles the storing and retrieval of encrypted passwords in the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 10-23-98
//
// NOTES:	Utilizes CryptoAPI v2.0 to store and retrieve passwords from the registry.
//
//			Here are some sample calls. 
//			{
//				// Construct a registry password object.
//				CRegistryPasswords pwd( _T("SOFTWARE\\ISAPITroubleShoot"), 
//										_T("APGTS"), _T("APGTS"), _T("Koshka8Spider") );
//				... or equivalently 	
//				CRegistryPasswords pwd( ); 
//				bool bRetVal;
//
//				pwd.WriteKey( _T("StatusAccess"), _T("2The9s") );	// Writes an encrypted password.
//				bRetVal= pwd.KeyValidate( _T("StatusAccess"), _T("2The9s1") );	// Returns false.
//				bRetVal= pwd.KeyValidate( _T("StatusAccess"), _T("2The9s") );	// Returns true.
//			}
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-23-98	RAB
//

#ifndef __REGISTRYPASSWORDS_19981023_H_
#define __REGISTRYPASSWORDS_19981023_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <wincrypt.h>
#include "apgtsstr.h"
#include "apgts.h"

#define HASH_SEED _T("Koshka8Spider")

class CRegistryPasswords
{
public:
	// Assembles all of the CryptAPI components.
	CRegistryPasswords( 
			LPCTSTR szRegSoftwareLoc=REG_SOFTWARE_LOC,	// Registry Software Key location.
			LPCTSTR szRegThisProgram=REG_THIS_PROGRAM,	// Registry Program Name.
			LPCTSTR szKeyContainer=REG_THIS_PROGRAM,	// Key Container Name.
			LPCTSTR szHashString=HASH_SEED				// Value used to seed the hash.
			);	

	// Simply calls Destroy().
	~CRegistryPasswords();	

	// Function to encrypt and then write RegValue to RegKey.
	bool WriteKey( const CString& RegKey, const CString& RegValue );

	// Function to encrypt a given key.
	bool EncryptKey( const CString& RegValue, char** ppBuf, long* plBufLen );

	// Function to retrieves and then decrypt the value stored in RegKey, 
	// compares to RegValue, returns true if equal.
	bool KeyValidate( const CString& RegKey, const CString& RegValue );


private:
	void Destroy();			// Releases all of the CryptAPI components.

	HCRYPTPROV	m_hProv;		// The handle to a CSP.
	HCRYPTHASH	m_hHash;		// The handle to a hash object.
	HCRYPTKEY	m_hKey;			// The handle to a cryptographic key.
	bool		m_bAllValid;	// A flag when set to true indicates valid handles for the
								// three objects above.
	CString		m_strRegSoftwareLoc;	// Registry location e.g. _T("SOFTWARE\\ISAPITroubleShoot")
	CString		m_strRegThisProgram;	// Registry program name e.g. _T("APGTS")
} ;

#endif
//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\regweventviewer.cpp ===
//
// MODULE: RegWEventViewer.cpp
//
// PURPOSE: Fully implements class CRegisterWithEventViewer
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/16/98		JM		pulled out of APGTSCFG.CPP
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgts.h"
#include "apgtsinf.h"
#include "event.h"
#include "maxbuf.h"
#include "RegWEventViewer.h"
#include "baseexception.h"
#include <vector>

using namespace std;


// ------------ CRegisterWithEventViewer -------------

CRegisterWithEventViewer::CRegisterWithEventViewer(HMODULE hModule)
{
	Register( hModule );
}

CRegisterWithEventViewer::~CRegisterWithEventViewer()
{
}
	
//
// This is called only by constructor
// Note that this fn makes no use of class data
//
// Register ourselves w/ event viewer so it can call us to get error strings
VOID CRegisterWithEventViewer::Register(HMODULE hModule)
{
	HKEY hk;
	DWORD dwDisposition, dwType, dwValue, dwSize;
	TCHAR szSubkey[MAXBUF];
	DWORD dwErr;

	// 1. check if registry has valid event viewer info
	// 2. if not, create it as appropriate

	// check presence of event log info...

	_stprintf(szSubkey, _T("%s\\%s"), REG_EVT_PATH, REG_EVT_ITEM_STR);

	dwErr = ::RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						szSubkey, 
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&hk, 
						&dwDisposition);
	if ( dwErr == ERROR_SUCCESS ) 
	{			
		if (dwDisposition == REG_CREATED_NEW_KEY) {
			// create entire registry layout for events
			RegisterDllPath(hk, hModule);
			RegisterEventTypes(hk);	
		}
		else {
			// (REG_OPENED_EXISTING_KEY is the only other possibility)
			// now make sure all registry elements present
			TCHAR szPath[MAXBUF];
			dwSize = sizeof (szPath) - 1;
			if (::RegQueryValueEx(hk,
								REG_EVT_MF,
								0,
								&dwType,
								(LPBYTE) szPath,
								&dwSize) != ERROR_SUCCESS) 
			{
				RegisterDllPath(hk, hModule);
			}
			dwSize = sizeof (DWORD);
			if (::RegQueryValueEx(hk,
								REG_EVT_TS,
								0,
								&dwType,
								(LPBYTE) &dwValue,
								&dwSize) != ERROR_SUCCESS) 
			{
				RegisterEventTypes(hk);
			}
		}

		::RegCloseKey(hk);
	}
	else
	{

		TCHAR szMsgBuf[MAXBUF];

		::FormatMessage( 
			FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			dwErr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			szMsgBuf,
			MAXBUF,
			NULL 
			);

		// Logging won't be pretty here, because we just failed to register with the Event
		//	Viewer, but we'll take what we can get.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Error registering with Event Viewer"),
								szMsgBuf,
								dwErr ); 

		DWORD dwDummy= MAXBUF;
		::GetUserName( szMsgBuf, &dwDummy );
		CBuildSrcFileLinenoStr SrcLoc2( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc2.GetSrcFileLineStr(), 
								SrcLoc2.GetSrcFileLineStr(), 
								_T("User shows as:"),
								szMsgBuf,
								dwErr ); 
	}
}


//
// Note that this fn makes no use of class data
// Store a path to this DLL in registry
VOID CRegisterWithEventViewer::RegisterDllPath(HKEY hk, HMODULE hModule)
{
	TCHAR szPath[MAXBUF];
	DWORD len;
	DWORD dwErr;

	if (hModule) 
	{
		if ((len = ::GetModuleFileName(hModule, szPath, MAXBUF-1))!=0) 
		{
			szPath[len] = _T('\0');
			dwErr= ::RegSetValueEx(	hk,
								REG_EVT_MF,
								0,
								REG_EXPAND_SZ,
								(LPBYTE) szPath,
								len + sizeof(TCHAR));
			if (dwErr)
			{
				// Logging won't be pretty here, because we just failed to register with the 
				//	Event Viewer, but we'll take what we can get.
				TCHAR szMsgBuf[MAXBUF];
				DWORD dwDummy= MAXBUF;

				::GetUserName( szMsgBuf, &dwDummy );
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
									_T("Error registering with Event Viewer"),
									szMsgBuf,
									dwErr ); 
			}
		}
	}
}

//
// Note that this fn makes no use of class data
// Register what type of event text queries (errors, warnings, info types) this DLL supports
VOID CRegisterWithEventViewer::RegisterEventTypes(HKEY hk)
{
	DWORD dwData;
	DWORD dwErr;

	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
				EVENTLOG_INFORMATION_TYPE; 

	dwErr= ::RegSetValueEx(hk,
						REG_EVT_TS,
						0,
						REG_DWORD,
						(LPBYTE) &dwData,
						sizeof(DWORD));
	if (dwErr)
	{
		// Logging won't be pretty here, because we just failed to register with the 
		//	Event Viewer, but we'll take what we can get.
		TCHAR szMsgBuf[MAXBUF];
		DWORD dwDummy= MAXBUF;

		::GetUserName( szMsgBuf, &dwDummy );

		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Error registering with Event Viewer"),
								szMsgBuf,
								dwErr ); 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\regutil.cpp ===
//
// MODULE: "RegUtil.cpp"
//
// PURPOSE: class CRegUtil
//	Encapsulates access to system registry.
//	This is intended as generic access to the registry, independent of any particular
//	application.
//
// PROJECT: first developed as part of Belief Network Editing Tools ("Argon")
//	Later modified to provide more extensive features as part of version 3.0 of the
//	Online Troubleshooter (APGTS)
//
// AUTHOR: Lonnie Gerrald (LDG), Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 3/25/98
//
// NOTES: 
// 1. The Create, Open, and Close functions support a model where m_hKey represents a 
//	"position" in the registry.  Successive calls to Create() or Open() migrate deeper 
//	into the registry hierarchy.  Close closes all keys encountered on the way down to 
//	the current m_hKey.
//	
//
// Version		Date		By		Comments
//--------------------------------------------------------------------
// V0.1(Argon)	3/25/98		LDG		
// V3.0			8/??/98		OK	
// V3.0			9/9/98		JM	
//
#include "stdafx.h"
#include "regutil.h"
#include "event.h"
#include "baseexception.h"
#include "CharConv.h"

//////////////////////////////////////////////////////////////////////
// CRegUtil
//////////////////////////////////////////////////////////////////////
CRegUtil::CRegUtil()
        : m_hKey(NULL),
		  m_WinError(ERROR_SUCCESS)
{
}

CRegUtil::CRegUtil(HKEY key)
        : m_hKey(key),
		  m_WinError(ERROR_SUCCESS)
{
}

CRegUtil::~CRegUtil()
{
	Close();
}


// creates the specified key. If the key already exists in the registry, the function opens it. 
// returns true on success, false otherwise.
bool CRegUtil::Create(HKEY hKeyParent, const CString& strKeyName, bool* bCreatedNew, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	HKEY hRetKey = NULL;
	DWORD dwDisposition = 0;

	m_WinError = ::RegCreateKeyEx(
		hKeyParent,
		strKeyName,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		access,
		NULL,
		&hRetKey,
		&dwDisposition
		);

	if(m_WinError == ERROR_SUCCESS)
	{
		m_hKey = hRetKey;
		*bCreatedNew = dwDisposition == REG_CREATED_NEW_KEY ? true : false;
		
		try
		{
			m_arrKeysToClose.push_back(hRetKey);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}

		return true;
	}
	return false;
}

// Unlike CRegUtil::Create, CRegUtil::Open does not create the specified key if the key does not 
// exist in the registry. Thus it can be used to test whether the key exists.
// returns true on success, false otherwise.
bool CRegUtil::Open(HKEY hKeyParent, const CString& strKeyName, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	HKEY hRetKey = NULL;

    m_WinError = ::RegOpenKeyEx( 
		hKeyParent,
		strKeyName,
		0,
		access,
		&hRetKey
		); 
  
	if(m_WinError == ERROR_SUCCESS)
	{
		m_hKey = hRetKey;
		try
		{
			m_arrKeysToClose.push_back(hRetKey);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}

		return true;
	}
	return false;
}

// creates the specified subkey of m_hKey. If the key already exists in the registry, the function opens it. 
// returns true on success, false otherwise.
bool CRegUtil::Create(const CString& strKeyName, bool* bCreatedNew, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	return Create(m_hKey, strKeyName, bCreatedNew, access);
}

// opens the specified subkey of m_hKey. 
// Unlike CRegUtil::Create, CRegUtil::Open does not create the specified key if the key does not 
// exist in the registry. Thus it can be used to test whether the key exists.
// returns true on success, false otherwise.
bool CRegUtil::Open(const CString& strKeyName, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	return Open(m_hKey, strKeyName, access);
}

// Close all keys encountered on the way down to the current m_hKey.
void CRegUtil::Close()
{
	for (vector<HKEY>::reverse_iterator i = m_arrKeysToClose.rbegin(); i != m_arrKeysToClose.rend(); i++)
		::RegCloseKey( *i );

	m_arrKeysToClose.clear();
}

bool CRegUtil::DeleteSubKey(const CString& strSubKey)
{
	// What does m_hKey point to after a successful deletion?  RAB-981116.
	m_WinError = ::RegDeleteKey(m_hKey, strSubKey);
	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::DeleteValue(const CString& strValue)
{
	m_WinError = ::RegDeleteValue(m_hKey, strValue);
	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::SetNumericValue(const CString& strValueName, DWORD dwValue)
{
	BYTE* pData = (BYTE*)&dwValue;
	m_WinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_DWORD,
		pData,
		sizeof(DWORD)
		);

	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::SetStringValue(const CString& strValueName, const CString& strValue)
{
	BYTE* pData = (BYTE*)(LPCTSTR)strValue;
	m_WinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_SZ,
		pData,
		strValue.GetLength()+sizeof(TCHAR)
		);

	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::SetBinaryValue(const CString& strValueName, char* buf, long buf_len)
{
	BYTE* pData = (BYTE*)buf;
	m_WinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_BINARY,
		pData,
		buf_len
		);

	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::GetNumericValue(const CString& strValueName, DWORD& dwValue)
{
	DWORD tmp = 0;
	BYTE* pData = (BYTE*)&tmp;
	DWORD type = 0;
	DWORD size = sizeof(DWORD);

	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (type != REG_DWORD)
		return false;

	if (m_WinError == ERROR_SUCCESS)
	{
		dwValue = tmp;
		return true;
	}
	return false;
}

bool CRegUtil::GetStringValue(const CString& strValueName, CString& strValue)
{
	BYTE* pData = NULL;
	DWORD type = 0;
	DWORD size = 0;

	// determine data size
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		NULL,
		&size
		);
	
	if (m_WinError != ERROR_SUCCESS)
		return false;

	if (type != REG_SZ && type != REG_EXPAND_SZ)
		return false;

	bool bRet = false;	// should be only one return from here down: we're about to
						// alloc pData and must make sure it's correctly cleaned up.

	try
	{
		pData = new BYTE[size];
	}
	catch (bad_alloc&)
	{
		return false;
	}

	memset(pData, 0, size);
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (m_WinError == ERROR_SUCCESS)
	{
		if (type == REG_EXPAND_SZ )
		{
			BYTE* pDataExpanded = NULL;
			DWORD dwExpandedSize;

			// first we call ExpandEnvironmentStrings just to get the length
			// casting away unsignedness
			dwExpandedSize = ::ExpandEnvironmentStrings(
				reinterpret_cast<const TCHAR *>(pData), 
				reinterpret_cast<TCHAR *>(pDataExpanded), 
				0);
			if (dwExpandedSize > 0)
			{
				try
				{
					pDataExpanded = new BYTE[dwExpandedSize];

					// then we call ExpandEnvironmentStrings again to get the expanded value
					// casting away unsignedness
					if (::ExpandEnvironmentStrings(
						reinterpret_cast<const TCHAR *>(pData), 
						reinterpret_cast<TCHAR *>(pDataExpanded), 
						dwExpandedSize)) 
					{
						strValue = (LPTSTR)pDataExpanded;
						delete [] pDataExpanded;
						bRet = true;
					}
				}
				catch (bad_alloc&)
				{
					// Note memory failure in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
				}
			}
		}
		else
		{
			strValue = (LPTSTR)pData;
			bRet = true;
		}
	}
	
	delete [] pData;
	return bRet;
}

// The second parameter should be passed in as the address of a char *.
// Note that if this returns true, *ppBuf will point to a new buffer on the heap.
//	The caller of this function is responsible for deleting that.
bool CRegUtil::GetBinaryValue(const CString& strValueName, char** ppBuf, long* pBufLen)
{
	BYTE* pData = NULL;
	DWORD type = 0;
	DWORD size = 0;

	// determine data size
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		NULL,
		&size
		);
	
	if (m_WinError != ERROR_SUCCESS || type != REG_BINARY)
		return false;

	try
	{
		// Increase the buffer size by one over what we need.  Small price to
		// pay for processing convenience elsewhere.
		pData = new BYTE[size+1];
	}
	catch (bad_alloc&)
	{
		return false;
	}

	memset(pData, 0, size);
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (m_WinError == ERROR_SUCCESS)
	{
		// Null terminate the binary string for processing convenience elsewhere.
		pData[size]= 0;
		*ppBuf = (char*)pData;
		*pBufLen = size;
		return true;
	}
	
	delete [] pData;
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\regweventviewer.h ===
//
// MODULE: RegWEventViewer.h
//
// PURPOSE: Fully implements class CRegisterWithEventViewer
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
//  --		11/21/97	JM		This class abstracted from CDBLoadConfiguration 
// V3.0		9/16/98		JM		This class pulled out of APGTSCFG.CPP

#if !defined(AFX_REGWEVENTVIEWER_H__A3CFA77C_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
#define AFX_REGWEVENTVIEWER_H__A3CFA77C_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

class CRegisterWithEventViewer
{
public:
	CRegisterWithEventViewer(HMODULE hModule);
	~CRegisterWithEventViewer();
private:
	static VOID Register(HMODULE hModule);
	static VOID RegisterDllPath(HKEY hk, HMODULE hModule);
	static VOID RegisterEventTypes(HKEY hk);
};


#endif // !defined(AFX_REGWEVENTVIEWER_H__A3CFA77C_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\renderconnector.h ===
// RenderConnector.h: interface for the CRenderConnector class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RENDERCONNECTOR_H__023A75E3_A81A_11D3_8D63_00C04F949D33__INCLUDED_)
#define AFX_RENDERCONNECTOR_H__023A75E3_A81A_11D3_8D63_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"


////////////////////////////////////////////////////////////////////////////////////
// CRenderConnector class declaration
////////////////////////////////////////////////////////////////////////////////////
class CRenderConnector  
{
	CStatelessPublic m_Stateless;
	bool m_bLocked;

public:
	CRenderConnector() : m_bLocked(false) {}
	virtual ~CRenderConnector() {}

public:
	void Render(CString strPage);
	bool GetLocked() {return m_bLocked;}
	void SetLocked(bool set) {m_bLocked = set;}

protected:
	// PURE virtual
	virtual void RenderInternal(CString strPage) =0;

};


inline void CRenderConnector::Render(CString strPage)
{
	m_Stateless.Lock(__FILE__, __LINE__);
	RenderInternal(strPage);
	m_Stateless.Unlock();
}

#endif // !defined(AFX_RENDERCONNECTOR_H__023A75E3_A81A_11D3_8D63_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\registrypasswords.cpp ===
//
// MODULE: RegistryPasswords.cpp
//
// PURPOSE: Handles the storing and retrieval of encrypted passwords in the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 10-23-98
//
// NOTES:	See RegistryPasswords.h
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-23-98	RAB
//
#include "stdafx.h"
#include "RegistryPasswords.h"
#include "BaseException.h"
#include "Event.h"
#include "regutil.h"


#ifndef CRYPT_MACHINE_KEYSET
// This flag was exposed in Windows NT 4.0 Service Pack 2.
#define CRYPT_MACHINE_KEYSET 0x00000020
// By default, keys are stored in the HKEY_CURRENT_USER portion of the registry. 
// The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags, 
// indicating that the location for the key of interest is HKEY_LOCAL_MACHINE. 
// When combined with the CRYPT_NEW_KEYSET flag, the CRYPT_MACHINE_KEYSET flag 
// is useful when access is being performed from a service or user account that 
// did not log on interactively. This combination enables access to user specific 
// keys under HKEY_LOCAL_MACHINE. 
//
// This setting is necessary in the the online troubleshooter in all 
// CryptAcquireContext() calls.
#endif


CRegistryPasswords::CRegistryPasswords( 
			LPCTSTR szRegSoftwareLoc /* =REG_SOFTWARE_LOC */,	// Registry Software Key location.
			LPCTSTR szRegThisProgram /* =REG_THIS_PROGRAM */,	// Registry Program Name.
			LPCTSTR szKeyContainer /* =REG_THIS_PROGRAM */,		// Key Container Name.
			LPCTSTR szHashString /* =HASH_SEED */				// Value used to seed the hash.
			)
	: m_hProv( NULL ), m_hHash( NULL ), m_hKey( NULL ), m_bAllValid( false )
{
	try
	{
		m_strRegSoftwareLoc= szRegSoftwareLoc;
		m_strRegThisProgram= szRegThisProgram;

		// Attempt to acquire a handle to a particular key container.
		if (::CryptAcquireContext(	&m_hProv, szKeyContainer, 
									MS_DEF_PROV,	// "Microsoft Base Cryptographic Provider v1.0"
									PROV_RSA_FULL,	// This provider type supports both digital signatures 
													// and data encryption, and is considered general purpose. 
													// The RSA public-key algorithm is used for all public-key operations. 
									CRYPT_MACHINE_KEYSET ) == FALSE)	
		{	
			// Attempt to create a particular key container and acquire handle 
			if (::CryptAcquireContext(	&m_hProv, szKeyContainer, 
										MS_DEF_PROV, 
										PROV_RSA_FULL, 
										CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET ) == FALSE)	
			{
				throw CGenSysException( __FILE__, __LINE__, _T("AcquireContext"), ::GetLastError() );
			}
		}

		// Attempt to acquire a handle to a CSP hash object.
		/*** 
		Available hashing algorithms. 
		CALG_HMACHMAC,		a keyed hash algorithm 
		CALG_MAC			Message Authentication Code
		CALG_MD2			MD2
		CALG_MD5			MD5
		CALG_SHA			US DSA Secure Hash Algorithm
		CALG_SHA1			Same as CALG_SHA
		CALG_SSL3_SHAMD5	SSL3 client authentication 
		***/
		if (::CryptCreateHash(	m_hProv, CALG_SHA, 0, NULL, &m_hHash ) == FALSE)
			throw CGenSysException( __FILE__, __LINE__, _T("CreateHash"), ::GetLastError() );

		// Hash a string.
		if (::CryptHashData(	m_hHash, (BYTE *) szHashString, _tcslen( szHashString ), 
								NULL ) == FALSE)	
		{
			throw CGenSysException( __FILE__, __LINE__, _T("HashData"), ::GetLastError() );
		}

		// Generate a cryptographic key derived from base data.
		if (::CryptDeriveKey(	m_hProv, 
								CALG_RC4, // RC4 stream encryption algorithm
								m_hHash, NULL, &m_hKey ) == FALSE)
		{
			throw CGenSysException( __FILE__, __LINE__, _T("DeriveKey"), ::GetLastError() );
		}

		// Toggle on flag to indicate that all Crypto handles have been initialized.
		m_bAllValid= true;
	}
	catch (CGenSysException& x)
	{
		// Log the error.
		LPVOID lpErrorMsgBuf;
		CString strErrorMsg;
		::FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
							NULL, x.GetErrorCode(), 
							MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
							(LPTSTR) &lpErrorMsgBuf, 0, NULL );
		strErrorMsg.Format(_T("Encryption failure: %s"), (char *) lpErrorMsgBuf);
		
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								strErrorMsg, x.GetSystemErrStr(), 
								EV_GTS_ERROR_ENCRYPTION );
		::LocalFree(lpErrorMsgBuf);
		
		// Perform any cleanup.
		Destroy();
	}
	catch (...)
	{
		// Catch any other exceptions and do nothing.
	}
}


CRegistryPasswords::~CRegistryPasswords()
{
	// Utilize function destroy to avoid potentially throwing an exception
	// within the destructor.
	Destroy();
}


bool CRegistryPasswords::WriteKey( const CString& RegKey, const CString& RegValue )
{
	bool	bRetVal= false;

	// Verify that the constructor worked properly.
	if (!m_bAllValid)
		return( bRetVal );

	// Verify that a key and a value were passed in.
	if ((!RegValue.IsEmpty()) && (!RegKey.IsEmpty()))
	{
		TCHAR	*pBuffer;
		DWORD	dwSize;
		
		if (EncryptKey( RegValue, &pBuffer, (LONG *)&dwSize ))
		{
			// Write the encrypted string to the registry.
			CRegUtil reg;
			bool was_created = false;

			if (reg.Create( HKEY_LOCAL_MACHINE, m_strRegSoftwareLoc, &was_created, KEY_QUERY_VALUE | KEY_WRITE))
			{
				if (reg.Create( m_strRegThisProgram, &was_created, KEY_READ | KEY_WRITE ))
				{
					if (reg.SetBinaryValue( RegKey, pBuffer, dwSize ))
						bRetVal= true;
				}
			}
			delete [] pBuffer;
		}
	}

	return( bRetVal );
}

// Note that if this returns true, *ppBuf will point to a new buffer on the heap.
//	The caller of this function is responsible for deleting that.
bool CRegistryPasswords::EncryptKey( const CString& RegValue, char** ppBuf, long* plBufLen )
{
	bool bRetVal= false;

	// Verify that the constructor worked properly.
	if (!m_bAllValid)
		return( bRetVal );

	if (!RegValue.IsEmpty())
	{
		BYTE* pData= NULL;
		DWORD dwSize= 0;

		// Set variable to length of data in buffer.
		dwSize= RegValue.GetLength();

		// Have API return us the required buffer size for encryption.
		if (::CryptEncrypt(	m_hKey, 0, TRUE, NULL, NULL, &dwSize, dwSize ) == FALSE)
		{
			DWORD dwErr= ::GetLastError();
			CString strCryptErr;

			strCryptErr.Format( _T("%lu"), dwErr );
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									RegValue, strCryptErr,
									EV_GTS_ERROR_ENCRYPTION );
			return( bRetVal );
		}

		// We now have a size for the output buffer, so create buffer.
		try
		{
			pData= new BYTE[ dwSize + 1 ];
			//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
			if(!pData)
				throw bad_alloc();
		}
		catch (bad_alloc&)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T("Failure to allocate"),
									_T("space to encrypt key"),
									EV_GTS_ERROR_ENCRYPTION );
			return( bRetVal );
		}
		memcpy( pData, RegValue, dwSize );
		pData[ dwSize ]= NULL;

		// Encrypt the passed in string.
		if (::CryptEncrypt(	m_hKey, 0, TRUE, NULL, (BYTE *)pData, &dwSize, dwSize + 1 ) == FALSE)
		{
			// Log failure to encrypt.  
			DWORD dwErr= ::GetLastError();
			CString strCryptErr;

			strCryptErr.Format( _T("%lu"), dwErr );
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									RegValue, strCryptErr,
									EV_GTS_ERROR_ENCRYPTION );
			delete [] pData;
		}
		else
		{
			pData[ dwSize ]= 0;
			*ppBuf= (char*)pData;
			*plBufLen = dwSize;
			bRetVal= true;
		}
	}

	return( bRetVal );
}

bool CRegistryPasswords::KeyValidate( const CString& RegKey, const CString& RegValue )
{
	bool bRetVal= false;

	// Verify that the constructor worked properly.
	if (!m_bAllValid)
		return( bRetVal );

	// Verify that a key and a value were passed in.
	if ((!RegValue.IsEmpty()) && (!RegKey.IsEmpty()))
	{
		CRegUtil reg;

		// Open up the desired key.
		if (reg.Open( HKEY_LOCAL_MACHINE, m_strRegSoftwareLoc, KEY_QUERY_VALUE ))
		{
			if (reg.Open( m_strRegThisProgram, KEY_QUERY_VALUE ))
			{
				TCHAR	*pRegEncrypted;
				DWORD	dwRegSize;
				TCHAR	*pChkEncrypted;
				DWORD	dwChkSize;
				
				// Attempt to read the current setting from the registry.
				if (reg.GetBinaryValue( RegKey, &pRegEncrypted, (LONG *)&dwRegSize )) 
				{
					// Verify that the registry key had a previous value.
					if (dwRegSize < 1)
					{
						delete [] pRegEncrypted;
						return( bRetVal );
					}


					// Encrypt the passed in value. 
					if (EncryptKey( RegValue, &pChkEncrypted, (LONG *)&dwChkSize ))
					{
						// Compare the two unencrypted strings.
						if (dwRegSize == dwChkSize)
						{
							if (!memcmp( pRegEncrypted, pChkEncrypted, dwRegSize ))
								bRetVal= true;
						}
						delete [] pChkEncrypted;
					}

					delete [] pRegEncrypted;
				}
			}
		}
	}

	return( bRetVal );
}


// This function is used to clean up from any potential exceptions thrown within the
// ctor as well as standing in for the dtor.
void CRegistryPasswords::Destroy()
{
	try
	{
		// Toggle off flag that indicates valid Crypto handles.
		m_bAllValid= false;

		if (m_hKey)
		{
			if (::CryptDestroyKey( m_hKey ) == FALSE)
				throw CGenSysException( __FILE__, __LINE__, 
										_T("Failure to destroy key"), 
										EV_GTS_PASSWORD_EXCEPTION );
			m_hKey= NULL;
		}

		if (m_hHash)
		{
			if (::CryptDestroyHash( m_hHash ) == FALSE)
				throw CGenSysException( __FILE__, __LINE__, 
										_T("Failure to destroy hash"), 
										EV_GTS_PASSWORD_EXCEPTION );
			m_hHash= NULL;
		}

		if (m_hProv)
		{
			if (::CryptReleaseContext( m_hProv, 0 ) == FALSE)
				throw CGenSysException( __FILE__, __LINE__, 
										_T("Failure to release context"), 
										EV_GTS_PASSWORD_EXCEPTION );
			m_hProv= NULL;
		}
	}
	catch (CGenSysException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), x.GetSystemErrStr(), 
								x.GetErrorCode() ); 
	}
	catch (...)
	{
		// Catch any other exceptions and do nothing.
	}

	return;
}


//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TSHOOT.rc
//
#define IDS_PROJNAME                    100
#define IDB_TSHOOTCTRL                  101
#define IDS_PREVSCRIPT                  101
#define IDR_TSHOOTCTRL                  102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\regutil.h ===
//
// MODULE: "RegUtil.h"
//
// PURPOSE: class CRegUtil
//	Encapsulates access to system registry.
//	This is intended as generic access to the registry, independent of any particular
//	application.
//
// PROJECT: first developed as part of Belief Network Editing Tools ("Argon")
//	Later modified to provide more extensive features as part of version 3.0 of the
//	Online Troubleshooter (APGTS)
//
// AUTHOR: Lonnie Gerrald (LDG), Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 3/25/98
//
// NOTES: 
// 1. 
//
// Version		Date		By		Comments
//--------------------------------------------------------------------
// V0.1(Argon)	3/25/98		LDG		
// V3.0			8/??/98		OK	
// V3.0			9/9/98		JM	

#include <vector>
#include <algorithm>
using namespace std;

#include "apgtsstr.h"

//////////////////////////////////////////////////////////////////////
// CRegUtil
//  class for accessing registry
//  NOT multithreaded!
//////////////////////////////////////////////////////////////////////
class CRegUtil
{
private:
	long m_WinError;   // windows error listed in WINERROR.H file
	HKEY m_hKey;       // current key handle
	vector<HKEY> m_arrKeysToClose; // array of keys(subkeys) opened by the object

private:
	CRegUtil(const CRegUtil&) {} // prohibit copying since it is confusing:
								 //  one object can close handlers being used by another

public:
	CRegUtil();
	explicit CRegUtil(HKEY);
    virtual ~CRegUtil();

	operator HKEY() const {return m_hKey;}
	long GetResult() const {return m_WinError;}

	// major operations
	bool Create(HKEY hKeyParent, const CString& strKeyName, bool* bCreatedNew, REGSAM access =KEY_ALL_ACCESS);
	bool Open(HKEY hKeyParent, const CString& strKeyName, REGSAM access =KEY_ALL_ACCESS);
	bool Create(const CString& strKeyName, bool* bCreatedNew, REGSAM access =KEY_ALL_ACCESS); // migrate "this" to subkey
	bool Open(const CString& strKeyName, REGSAM access =KEY_ALL_ACCESS); // migrate "this" to subkey
	void Close();

	// sub key manipulation
	bool DeleteSubKey(const CString& strSubKey);
	bool DeleteValue(const CString& strValue);

	// set value
	bool SetNumericValue(const CString& strValueName, DWORD dwValue);
	bool SetStringValue(const CString& strValueName, const CString& strValue);
	bool SetBinaryValue(const CString& strValueName, char* buf, long buf_len);
	
	// get value
	bool GetNumericValue(const CString& strValueName, DWORD& dwValue);
	bool GetStringValue(const CString& strValueName, CString& strValue);
	bool GetBinaryValue(const CString& strValueName, char** buf, long* buf_len);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\safetime.cpp ===
//
// MODULE: SafeTime.cpp
//
// PURPOSE: threadsafe wrappers for some standard time-related calls.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10-12-98
//
// NOTES: 
//	1. gmtime, mktime, and localtime all use a single statically allocated tm structure 
//	for the conversion. Each call to one of these routines destroys the result of the 
//	previous call.  Obviously, that's not threadsafe.
//	2. Right now this only deals with localtime, because we're not using the other 2 fns.
//	If we need to use gmtime or mktime, they'll need to be built analogously, using the 
//	same mutex.
//	3. _tasctime uses a single, statically allocated buffer to hold its return string. 
//	Each call to this function destroys the result of the previous call.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-12-98	JM
//

#include "stdafx.h"
#include "SafeTime.h"
#include "BaseException.h"
#include "Event.h"
#include "apiwraps.h"

CMutexOwner CSafeTime::s_mx(_T("SafeTime"));

//////////////////////////////////////////////////////////////////////
// CSafeTime
//////////////////////////////////////////////////////////////////////

CSafeTime::CSafeTime(time_t time) :
	m_time(time)
{
}

CSafeTime::~CSafeTime()
{
}

// return local time as a struct tm
struct tm CSafeTime::LocalTime()
{
	struct tm tmLocal;
	WAIT_INFINITE( s_mx.Handle() );
	tmLocal = *(localtime(&m_time));
	::ReleaseMutex(s_mx.Handle());
	return tmLocal;
}

// return GMT as a struct tm
struct tm CSafeTime::GMTime()
{
	struct tm tmLocal;
	WAIT_INFINITE( s_mx.Handle() );
	tmLocal = *(gmtime(&m_time));
	::ReleaseMutex(s_mx.Handle());
	return tmLocal;
}

CString CSafeTime::StrLocalTime(LPCTSTR invalid_time /*=_T("Invalid Date/Time")*/)
{
	CString str;
	WAIT_INFINITE( s_mx.Handle() );
	if (m_time)
		str = _tasctime(localtime(&m_time));
	else
		str = invalid_time;
	::ReleaseMutex(s_mx.Handle());
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\safetime.h ===
//
// MODULE: SafeTime.h
//
// PURPOSE: threadsafe wrappers for some standard time-related calls.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10-12-98
//
// NOTES: 
//	1. gmtime, mktime, and localtime all use a single statically allocated tm structure 
//	for the conversion. Each call to one of these routines destroys the result of the 
//	previous call.  Obviously, that's not threadsafe.
//	2. Right now this only deals with localtime, because we're not using the other 2 fns.
//	If we need to use gmtime or mktime, they'll need to be built analogously, using the 
//	same mutex.
//	3. _tasctime uses a single, statically allocated buffer to hold its return string. 
//	Each call to this function destroys the result of the previous call.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-12-98	JM
//

#if !defined(AFX_SAFETIME_H__D5040393_61E9_11D2_960C_00C04FC22ADD__INCLUDED_)
#define AFX_SAFETIME_H__D5040393_61E9_11D2_960C_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <time.h>
#include "apgtsstr.h"
#include "MutexOwner.h"

class CSafeTime
{
private:
	static CMutexOwner s_mx;
	time_t m_time;
private:
	CSafeTime();	// do not instantiate;
public:
	CSafeTime(time_t time);
	virtual ~CSafeTime();
	struct tm LocalTime();
	struct tm GMTime();
	CString StrLocalTime(LPCTSTR invalid_time =_T("Invalid Date/Time"));
};

#endif // !defined(AFX_SAFETIME_H__D5040393_61E9_11D2_960C_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sniffconnector.h ===
//
// MODULE: SNIFFCONNECTOR.H
//
// PURPOSE: sniffing connection class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which describes connection of
//         CSniff class to module(s), which are able to call sniffing
//         scripts.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFCONNECTOR_H__49F470BA_6F6A_11D3_8D39_00C04F949D33__INCLUDED_)
#define AFX_SNIFFCONNECTOR_H__49F470BA_6F6A_11D3_8D39_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"

////////////////////////////////////////////////////////////////////////////////////
// CSniffConnector
//  this class is enabling topic-related CSniff class use capabilities of programm
//  to invoke actual sniffing scripts
////////////////////////////////////////////////////////////////////////////////////
class CSniffConnector
{
	CStatelessPublic m_Stateless;

public:
	CSniffConnector() {}
	virtual ~CSniffConnector() {}

public:
	long PerformSniffing(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs);

protected:
	// PURE virtual
	virtual long PerformSniffingInternal(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs) =0;

};


inline long CSniffConnector::PerformSniffing(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs)
{
	m_Stateless.Lock(__FILE__, __LINE__);
	long ret = PerformSniffingInternal(strNodeName, strLaunchBasis, strAdditionalArgs);
	m_Stateless.Unlock();
	return ret;
}

#endif // !defined(AFX_SNIFFCONNECTOR_H__49F470BA_6F6A_11D3_8D39_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sniff.h ===
//
// MODULE: SNIFF.H
//
// PURPOSE: sniffing class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which performs sniffing
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFF_H__13D744F6_7038_11D3_8D3A_00C04F949D33__INCLUDED_)
#define AFX_SNIFF_H__13D744F6_7038_11D3_8D3A_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"
#include "nodestate.h"

#define SNIFF_FAILURE_RESULT	0xffffffff  // as this is a state, and state (IST) is unsigned int


class CSniffController;
class CSniffConnector;
class CTopic;

typedef vector<CNodeStatePair> CSniffedArr;

//////////////////////////////////////////////////////////////////////////////////////
// CSniff declaration
class CSniff : public CStateless
{
public:
	CSniff() {}
	virtual ~CSniff() {}

public:
	virtual CSniffController* GetSniffController() =0;
	virtual CSniffConnector* GetSniffConnector() =0;
	virtual CTopic* GetTopic() =0;

public:
	// we can not set CSniffController here, as CSniffController
	//  is specific for CSniff... class, inherited from CSniff
	virtual void SetSniffConnector(CSniffConnector*) =0;
	virtual void SetTopic(CTopic*) =0;

public:
	virtual bool Resniff(CSniffedArr& arrSniffed);
	virtual bool SniffAll(CSniffedArr& arrOut);
	virtual bool SniffNode(NID numNodeID, IST* pnumNodeState);

public:
	void SetAllowAutomaticSniffingPolicy(bool); 
	void SetAllowManualSniffingPolicy(bool); 
	bool GetAllowAutomaticSniffingPolicy(); 
	bool GetAllowManualSniffingPolicy(); 

protected:
	virtual bool SniffNodeInternal(NID numNodeID, IST* pnumNodeState);
};

#endif // !defined(AFX_SNIFF_H__13D744F6_7038_11D3_8D3A_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sniffcontroller.h ===
//
// MODULE: SNIFFCONTROLLER.H
//
// PURPOSE: sniff controller class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which controls sniffing on per-node base
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFCONTROLLER_H__F16A9526_7105_11D3_8D3B_00C04F949D33__INCLUDED_)
#define AFX_SNIFFCONTROLLER_H__F16A9526_7105_11D3_8D3B_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"
#include "nodestate.h"
#include "Sniff.h"

class CTopic;

////////////////////////////////////////////////////////////////////////////////////
// CSniffController
//  this class carries control information from registry and topic-specific HTI
//  file; this is ABSTRACT class.
////////////////////////////////////////////////////////////////////////////////////
class CSniffController : public CStateless
{
	friend void CSniff::SetAllowAutomaticSniffingPolicy(bool); 
	friend void CSniff::SetAllowManualSniffingPolicy(bool); 
	friend bool CSniff::GetAllowAutomaticSniffingPolicy(); 
	friend bool CSniff::GetAllowManualSniffingPolicy(); 

	bool m_bAllowAutomaticSniffingPolicy;
	bool m_bAllowManualSniffingPolicy;

public:
	CSniffController() : CStateless(),
						 m_bAllowAutomaticSniffingPolicy(false),
						 m_bAllowManualSniffingPolicy(false)
	{}

	virtual ~CSniffController() 
	{}

public:
	virtual void SetTopic(CTopic* pTopic) =0;

public:
	virtual bool AllowAutomaticOnStartSniffing(NID numNodeID) =0;
	virtual bool AllowAutomaticOnFlySniffing(NID numNodeID) =0;
	virtual bool AllowManualSniffing(NID numNodeID) =0;
	virtual bool AllowResniff(NID numNodeID) =0;

private: 
	// we NEED NOT access this functions other then from 
	//  appropriate CSniff::SetAllow...SniffingPolicy() functions
	void SetAllowAutomaticSniffingPolicy(bool); 
	void SetAllowManualSniffingPolicy(bool); 

protected:
	bool GetAllowAutomaticSniffingPolicy(); 
	bool GetAllowManualSniffingPolicy(); 
};


inline void CSniffController::SetAllowAutomaticSniffingPolicy(bool set)
{
	m_bAllowAutomaticSniffingPolicy = set;
}

inline void CSniffController::SetAllowManualSniffingPolicy(bool set)
{
	m_bAllowManualSniffingPolicy = set;
}

inline bool CSniffController::GetAllowAutomaticSniffingPolicy()
{
	return m_bAllowAutomaticSniffingPolicy;
}

inline bool CSniffController::GetAllowManualSniffingPolicy()
{
	return m_bAllowManualSniffingPolicy;
}


#endif // !defined(AFX_SNIFFCONTROLLER_H__F16A9526_7105_11D3_8D3B_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sniffcontrollerlocal.h ===
//
// MODULE: SNIFFCONTROLLERLOCAL.H
//
// PURPOSE: sniff controller class for Local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: Concrete implementation of CSniffController class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFCONTROLLERLOCAL_H__5FAF2243_8577_11D3_8D4C_00C04F949D33__INCLUDED_)
#define AFX_SNIFFCONTROLLERLOCAL_H__5FAF2243_8577_11D3_8D4C_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SniffController.h"

class CTopic;

class CSniffControllerLocal : public CSniffController  
{
	CTopic* m_pTopic;

public:
	CSniffControllerLocal(CTopic* pTopic);
   ~CSniffControllerLocal();

public:
	virtual void SetTopic(CTopic* pTopic);

public:
	virtual bool AllowAutomaticOnStartSniffing(NID numNodeID);
	virtual bool AllowAutomaticOnFlySniffing(NID numNodeID);
	virtual bool AllowManualSniffing(NID numNodeID);
	virtual bool AllowResniff(NID numNodeID);

protected:
	virtual bool IsSniffable(NID numNodeID);

private:
	bool CheckNetNodePropBool(LPCTSTR net_prop, LPCTSTR node_prop, NID node_id);
};

#endif // !defined(AFX_SNIFFCONTROLLERLOCAL_H__5FAF2243_8577_11D3_8D4C_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sniff.cpp ===
//
// MODULE: SNIFF.CPP
//
// PURPOSE: sniffing class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which performs sniffing
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include "Sniff.h"
#include "SniffConnector.h"
#include "SniffController.h"
#include "Topic.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// the problem is, that JavaScript returns 0xffffffff, but VBScript returns
//  0x0000ffff, so we define SNIFF_FAIL_MASK as 0x0000ffff and use it as mask to
//  determine if sniffing was successful. Expression 0xffffffff & SNIFF_FAIL_MASK
//  will have the same result as expression 0x0000ffff & SNIFF_FAIL_MASK.
// This define SHOULD NOT BE USED OUTSIDE THIS FILE!
#define SNIFF_FAIL_MASK		0x0000ffff

//////////////////////////////////////////////////////////////////////////////////////
// CSniff implementation

// called as public interface function when resniffing
bool CSniff::Resniff(CSniffedArr& arrSniffed)
{
	bool ret = false;
	
	LOCKOBJECT();
	
	for (CSniffedArr::iterator i = arrSniffed.begin(); i < arrSniffed.end(); i++)
	{
		IST state = SNIFF_FAILURE_RESULT;

		if (GetSniffController()->AllowResniff(i->nid()))
		{
			if (SniffNodeInternal(i->nid(), &state))
			{
				if (state != i->state())
				{
					*i = CNodeStatePair(i->nid(), state);
					ret = true;
				}
			}
			else
			{
				arrSniffed.erase(i);
				i--;
				ret = true;
			}
		}
	}

	UNLOCKOBJECT();
	return ret;
}

// called as public interface function when sniffing on start up
bool CSniff::SniffAll(CSniffedArr& arrOut)
{
	bool ret = false;
	vector<NID> arrNodes;
	vector<ESTDLBL> arrTypeExclude;

	LOCKOBJECT();

	arrTypeExclude.push_back(ESTDLBL_problem);
	arrOut.clear();

	if (GetTopic()->GetNodeArrayExcludeType(arrNodes, arrTypeExclude))
	{
		for (vector<NID>::iterator i = arrNodes.begin(); i < arrNodes.end(); i++)
		{
			if (GetSniffController()->AllowAutomaticOnStartSniffing(*i))
			{
				IST state = SNIFF_FAILURE_RESULT;
				
				if (SniffNodeInternal(*i, &state))
				{
					arrOut.push_back(CNodeStatePair(*i, state));
					ret = true;
				}
			}
		}
	}
	
	UNLOCKOBJECT();
	return ret;
}

// called as public interface function when sniffing on the fly
bool CSniff::SniffNode(NID numNodeID, IST* pnumNodeState)
{
	bool ret = false;

	LOCKOBJECT();
	
	if (GetSniffController()->AllowAutomaticOnFlySniffing(numNodeID))
		ret = SniffNodeInternal(numNodeID, pnumNodeState);
	
	UNLOCKOBJECT();
	return ret;
}

bool CSniff::SniffNodeInternal(NID numNodeID, IST* pnumNodeState)
{
	CString strNodeName;

	if (!GetTopic()->IsRead())
		return false;
	
	strNodeName = GetTopic()->GetNodeSymName(numNodeID);

	if (strNodeName.IsEmpty())
		return false;

	long res = GetSniffConnector()->PerformSniffing(strNodeName, _T(""), _T(""));

	if ((res & SNIFF_FAIL_MASK) == SNIFF_FAIL_MASK)
	{
		*pnumNodeState = SNIFF_FAILURE_RESULT;
		return false;
	}
	
	*pnumNodeState = res;
	return true;
}

void CSniff::SetAllowAutomaticSniffingPolicy(bool set)
{
	GetSniffController()->SetAllowAutomaticSniffingPolicy(set);
}

void CSniff::SetAllowManualSniffingPolicy(bool set)
{
	GetSniffController()->SetAllowManualSniffingPolicy(set);
}

bool CSniff::GetAllowAutomaticSniffingPolicy()
{
	return GetSniffController()->GetAllowAutomaticSniffingPolicy();
}

bool CSniff::GetAllowManualSniffingPolicy()
{
	return GetSniffController()->GetAllowManualSniffingPolicy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\snifflocal.h ===
//
// MODULE: SNIFFLOCAL.H
//
// PURPOSE: sniffing class for local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is concrete implementation of CSniff class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFLOCAL_H__AD9F3B66_831C_11D3_8D4B_00C04F949D33__INCLUDED_)
#define AFX_SNIFFLOCAL_H__AD9F3B66_831C_11D3_8D4B_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Sniff.h"


class CTopic;
class CSniffControllerLocal;
class CSniffConnector;

class CSniffLocal : public CSniff  
{
	CTopic* m_pTopic;
	CSniffControllerLocal* m_pSniffControllerLocal;
	CSniffConnector* m_pSniffConnector;

public:
	CSniffLocal(CSniffConnector*, CTopic*);
   ~CSniffLocal();

protected:
	virtual CSniffController* GetSniffController();
	virtual CSniffConnector* GetSniffConnector();
	virtual CTopic* GetTopic();

public:
	virtual void SetSniffConnector(CSniffConnector*);
	virtual void SetTopic(CTopic*);
};

#endif // !defined(AFX_SNIFFLOCAL_H__AD9F3B66_831C_11D3_8D4B_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sniffcontrollerlocal.cpp ===
//
// MODULE: SNIFFCONTROLLERLOCAL.CPP
//
// PURPOSE: sniff controller class for Local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: Concrete implementation of CSniffController class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#include "stdafx.h"
#include "tshoot.h"
#include "SniffControllerLocal.h"
#include "Topic.h"
#include "propnames.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// Network property values from DSC/XTS file.
#define SNIFF_LOCAL_YES			_T("yes")
#define SNIFF_LOCAL_NO			_T("no")
#define SNIFF_LOCAL_IMPLICIT	_T("implicit")
#define SNIFF_LOCAL_EXPLICIT	_T("explicit")


//////////////////////////////////////////////////////////////////////
// CSniffControllerLocal implementation
//////////////////////////////////////////////////////////////////////
CSniffControllerLocal::CSniffControllerLocal(CTopic* pTopic) 
					 : m_pTopic(pTopic)
{
}

CSniffControllerLocal::~CSniffControllerLocal() 
{
}

// This function provides us with a cheap test for existence of the sniffing property, 
//	so that (for example) we don't have to fire the sniffing event for nodes where 
//	sniffing is irrelevant.
bool CSniffControllerLocal::IsSniffable(NID numNodeID)
{
	CString str = m_pTopic->GetNodePropItemStr(numNodeID, H_NODE_SNIFF_SCRIPT);
	return !str.IsEmpty();
}

void CSniffControllerLocal::SetTopic(CTopic* pTopic)
{
	m_pTopic = pTopic;
}

bool CSniffControllerLocal::AllowAutomaticOnStartSniffing(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	return  CheckNetNodePropBool(H_NET_MAY_SNIFF_ON_STARTUP, 
			 					 H_NODE_MAY_SNIFF_ON_STARTUP, 
								 numNodeID)
			&&
			GetAllowAutomaticSniffingPolicy();		   
}

bool CSniffControllerLocal::AllowAutomaticOnFlySniffing(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	return  CheckNetNodePropBool(H_NET_MAY_SNIFF_ON_FLY, 
			 					 H_NODE_MAY_SNIFF_ON_FLY, 
								 numNodeID)
			&&
			GetAllowAutomaticSniffingPolicy();		   
}

bool CSniffControllerLocal::AllowManualSniffing(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	return  CheckNetNodePropBool(H_NET_MAY_SNIFF_MANUALLY, 
			 					 H_NODE_MAY_SNIFF_MANUALLY, 
								 numNodeID)
			&&
			GetAllowManualSniffingPolicy();		   
}

bool CSniffControllerLocal::AllowResniff(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	if (!GetAllowAutomaticSniffingPolicy())
		return false;

	CString net_resniff_policy = m_pTopic->GetNetPropItemStr(H_NET_RESNIFF_POLICY);

	net_resniff_policy.TrimLeft(); 
	net_resniff_policy.TrimRight(); 
	net_resniff_policy.MakeLower();

	if (net_resniff_policy == SNIFF_LOCAL_YES)
		return true;
	
	if (net_resniff_policy == SNIFF_LOCAL_NO)
		return false;

	// If we get this far, policy is left up to the individual node, so we need to know 
	//	the node's policy.

	CString node_resniff_policy = m_pTopic->GetNodePropItemStr(numNodeID, H_NODE_MAY_RESNIFF);

	node_resniff_policy.TrimLeft(); 
	node_resniff_policy.TrimRight(); 
	node_resniff_policy.MakeLower();

	if (net_resniff_policy == SNIFF_LOCAL_IMPLICIT)
	{
		return (node_resniff_policy != SNIFF_LOCAL_NO);
	}
	
	// default net policy is "explicit"
	return (node_resniff_policy == SNIFF_LOCAL_YES);
}

bool CSniffControllerLocal::CheckNetNodePropBool(LPCTSTR net_prop, LPCTSTR node_prop, NID node_id)
{
	CString net = m_pTopic->GetNetPropItemStr(net_prop);
	CString node = m_pTopic->GetNodePropItemStr(node_id, node_prop);

	net. TrimLeft(); net .TrimRight(); net. MakeLower();
	node.TrimLeft(); node.TrimRight(); node.MakeLower();

	// Note assumption: if property is missing, default is always yes.
	if ((net.IsEmpty() || net == SNIFF_LOCAL_YES) && (node.IsEmpty() || node == SNIFF_LOCAL_YES))
		return true;

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\snifflocal.cpp ===
//
// MODULE: SNIFFLOCAL.CPP
//
// PURPOSE: sniffing class for local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is concrete implementation of CSniff class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#include "stdafx.h"
#include "tshoot.h"
#include "SniffLocal.h"
#include "SniffControllerLocal.h"

//////////////////////////////////////////////////////////////////////
// CSniffLocal implementation
//////////////////////////////////////////////////////////////////////

CSniffLocal::CSniffLocal(CSniffConnector* pSniffConnector, CTopic* pTopic)
		   : CSniff(),
		     m_pTopic(pTopic),
			 m_pSniffConnector(pSniffConnector)
{
	m_pSniffControllerLocal = new CSniffControllerLocal(pTopic);
}

CSniffLocal::~CSniffLocal()
{
	delete m_pSniffControllerLocal;
}

CSniffController* CSniffLocal::GetSniffController()
{
	return m_pSniffControllerLocal;
}

CSniffConnector* CSniffLocal::GetSniffConnector()
{
	return m_pSniffConnector;
}

CTopic* CSniffLocal::GetTopic()
{
	return m_pTopic;
}

void CSniffLocal::SetSniffConnector(CSniffConnector* pSniffConnector)
{
	m_pSniffConnector = pSniffConnector;
}

void CSniffLocal::SetTopic(CTopic* pTopic)
{
	m_pTopic = pTopic;
	m_pSniffControllerLocal->SetTopic(pTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\stateless.h ===
//
// MODULE: Stateless.
//
// PURPOSE: interface for CStateless class.	
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: See CStateless.cpp for further information
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-9-98		JM
//

#if !defined(AFX_STATELESS_H__278584FB_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
#define AFX_STATELESS_H__278584FB_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "apgtsstr.h"

////////////////////////////////////////////////////////////////////////////////////
// CStateless
/////////////////////////////////////////////////////////////////////////////////////
class CStateless  
{
private:
	HANDLE m_hMutex;
	DWORD m_TimeOutVal;		// Time-out interval in milliseconds, after which we 
							// log error & wait infinitely when waiting for m_hMutex.
protected:
	CStateless(DWORD TimeOutVal = 60000);
	virtual ~CStateless();
	void Lock(	LPCSTR srcFile,	// Calling source file (__FILE__), used for logging.
								// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
				int srcLine		// Calling source line (__LINE__), used for logging.
				) const;
	void Unlock() const;
	HANDLE GetMutexHandle() const;	// provided only for the creation of a CMultiMutexObj.
									// >>> might be better to use private and friend than protected.
};

////////////////////////////////////////////////////////////////////////////////////
// CStatelessPublic
//  will be used when we can not inherit our class from CStateless,
//  but have to create member variable of CStatelessPublic to control
//  data access
/////////////////////////////////////////////////////////////////////////////////////
class CStatelessPublic : public CStateless
{
public:
	CStatelessPublic() : CStateless() {}
	~CStatelessPublic() {}

public:
	void Lock(	LPCSTR srcFile,
				int srcLine
				) const;
	void Unlock() const;
	HANDLE GetMutexHandle() const;
};


inline void CStatelessPublic::Lock(LPCSTR srcFile, int srcLine) const
{
	CStateless::Lock(srcFile, srcLine);
}

inline void CStatelessPublic::Unlock() const
{
	CStateless::Unlock();
}

inline HANDLE CStatelessPublic::GetMutexHandle() const
{
	return CStateless::GetMutexHandle();
}

////////////////////////////////////////////////////////////////////////////////////
// CNameStateless
/////////////////////////////////////////////////////////////////////////////////////
class CNameStateless : public CStateless
{
	CString m_strName;

public:
	CNameStateless();
	CNameStateless(const CString& str);

	void Set(const CString& str);
	CString Get() const;
};

// these must be macros, because otherwise __FILE__ and __LINE__ won't indicate the
//	calling location.  UNLOCKOBJECT is defined in case we ever need to determine if objects
//	are being unlocked and to provide a consistent look.
#define LOCKOBJECT() Lock(__FILE__, __LINE__)
#define UNLOCKOBJECT() Unlock()

#endif // !defined(AFX_STATELESS_H__278584FB_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A8F3A149_99E9_11D2_8C7E_00C04F949D33__INCLUDED_)
#define AFX_STDAFX_H__A8F3A149_99E9_11D2_8C7E_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_FREE_THREADED
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

///////////////////////////////////////////////////////////////////////////////
// Threading model of the Local Troubleshooter
#ifdef LOCAL_TROUBLESHOOTER
	#ifdef _ATL_FREE_THREADED
	#define RUNNING_FREE_THREADED()			true
	#define RUNNING_APARTMENT_THREADED()	false
	#endif
	#ifdef _ATL_APARTMENT_THREADED
	#define RUNNING_FREE_THREADED()			false
	#define RUNNING_APARTMENT_THREADED()	true
	#endif
#else
	#define RUNNING_FREE_THREADED()			false
	#define RUNNING_APARTMENT_THREADED()	false
#endif
///////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A8F3A149_99E9_11D2_8C7E_00C04F949D33__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sync.cpp ===
//
// MODULE: SYNC.CPP
//
// PURPOSE: syncronization classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include <algorithm>
#include "sync.h"
#include "event.h"
#include "baseexception.h"
#include "CharConv.h"
#include "apiwraps.h"

////////////////////////////////////////////////////////////////////////////////////
// CSyncObj
// single sync object abstract class
////////////////////////////////////////////////////////////////////////////////////
CSyncObj::CSyncObj()
{
	// we are to initialize handle in specific inherited class
}

CSyncObj::~CSyncObj()
{
	::CloseHandle(m_handle);
}

HANDLE CSyncObj::GetHandle() const
{
	return m_handle;
}

////////////////////////////////////////////////////////////////////////////////////
// 			CMutexObj															  //
// single mutex object class
// Manages a single mutex handle to facilitate waiting for the mutex.
////////////////////////////////////////////////////////////////////////////////////
CMutexObj::CMutexObj()
		 : CSyncObj()
{
	m_handle = ::CreateMutex(NULL, FALSE, NULL);
}

CMutexObj::~CMutexObj()
{
	::CloseHandle(m_handle);
}

// Smarter strategy here than an infinite wait. Wait up to 60 seconds, then log to event 
//	log and wait infinitely.  If it's logged to event log & eventually gets the mutex,
//	it logs to say it finally got the mutex.
void CMutexObj::Lock()
{
	WAIT_INFINITE(m_handle);
}

void CMutexObj::Unlock()
{
	::ReleaseMutex(m_handle);
}

////////////////////////////////////////////////////////////////////////////////////
// 				CMultiSyncObj   												  //
// multiple sync object abstract class
// Manages multiple handles (the exact type of handle will be determined by a class
//	inheriting from this) to facilitate waiting for the union of several events.
////////////////////////////////////////////////////////////////////////////////////
CMultiSyncObj::CMultiSyncObj()
{
}

CMultiSyncObj::~CMultiSyncObj()
{
}

void CMultiSyncObj::AddHandle(HANDLE handle)
{
	vector<HANDLE>::iterator i = 
		find(m_arrHandle.begin(), m_arrHandle.end(), handle);
	if (i == m_arrHandle.end())
	{
		try
		{
			m_arrHandle.push_back(handle);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}	
}

void CMultiSyncObj::RemoveHandle(HANDLE handle)
{
	vector<HANDLE>::iterator i = 
		find(m_arrHandle.begin(), m_arrHandle.end(), handle);
	if (i != m_arrHandle.end())
		m_arrHandle.erase(i);
}

void CMultiSyncObj::Clear()
{
	m_arrHandle.clear();
}

////////////////////////////////////////////////////////////////////////////////////
// 				CMultiMutexObj  												  //
// Manages multiple mutex handles to facilitate waiting for the union of several mutexes.
////////////////////////////////////////////////////////////////////////////////////
CMultiMutexObj::CMultiMutexObj()
			  : CMultiSyncObj()
{
}

CMultiMutexObj::~CMultiMutexObj()
{
}

// Deprecated use, because it provides inferior logging.
void CMultiMutexObj::Lock()
{
	Lock(__FILE__, __LINE__);
}

void CMultiMutexObj::Lock(
					LPCSTR srcFile,		// Calling source file (__FILE__), used for logging.
										// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
					int srcLine,		// Calling source line (__LINE__), used for logging.
					DWORD TimeOutVal /*=60000*/	// Time-out interval in milliseconds.  After
									// this we log an error, then wait infinitely
		)
{
	CBuildSrcFileLinenoStr SrcLoc( srcFile, srcLine );
	DWORD nWaitRetVal= ::WaitForMultipleObjects(
		m_arrHandle.size(), 
		m_arrHandle.begin(), 
		TRUE,		// wait for all objects, not just one.
		TimeOutVal);

	if (nWaitRetVal == WAIT_FAILED)
	{
		// very bad news, should never happen
		DWORD dwErr = ::GetLastError();
		CString strErr;
		strErr.Format(_T("%d"), dwErr);
		CBuildSrcFileLinenoStr SrcLoc3(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc3.GetSrcFileLineStr(), 
								_T("Thread wait failed."), 
								strErr, 
								EV_GTS_ERROR_STUCK_THREAD ); 
	}
	else if (nWaitRetVal == WAIT_TIMEOUT)
	{
		// Initial wait timed out, note in log, and wait infinitely.
		CBuildSrcFileLinenoStr SrcLoc1(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc1.GetSrcFileLineStr(), 
								_T("Thread wait exceeded initial timeout interval."), 
								_T(""), 
								EV_GTS_STUCK_THREAD ); 

		nWaitRetVal= ::WaitForMultipleObjects(
			m_arrHandle.size(), 
			m_arrHandle.begin(), 
			TRUE,		// wait for all objects, not just one.
			INFINITE);

		// If successfully got what we were waiting for (after logging an apparent
		//	problem), log the fact that it's ultimately OK.
		if (nWaitRetVal == WAIT_OBJECT_0)
		{
			CBuildSrcFileLinenoStr SrcLoc2(__FILE__, __LINE__);
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc2.GetSrcFileLineStr(), 
									_T("Thread infinite wait succeeded."), 
									_T(""), 
									EV_GTS_STUCK_THREAD ); 
		}
	}

	// Else we don't really care what else ::WaitForMultipleObjects() returns.
	// If we get here we got what we were waiting for

}

void CMultiMutexObj::Unlock()
{
	for (vector<HANDLE>::iterator i = m_arrHandle.begin(); 
			i != m_arrHandle.end(); 
			i++
	)
		::ReleaseMutex(*i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\sync.h ===
//
// MODULE: SYNC.H
//
// PURPOSE: syncronization classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __SYNC_H_
#define __SYNC_H_

#include <vector>
#include <windows.h>

using namespace std;
////////////////////////////////////////////////////////////////////////////////////
// single sync object abstract class
class CSyncObj
{
protected:
	HANDLE m_handle;

public:
	CSyncObj();
   ~CSyncObj();

public:
	virtual void Lock()   =0;
	virtual void Unlock() =0;

public:
	HANDLE GetHandle() const;
};

////////////////////////////////////////////////////////////////////////////////////
// single mutex object class
// Manages a single mutex handle to facilitate waiting for the mutex.
class CMutexObj : public CSyncObj
{
public:
	CMutexObj();
   ~CMutexObj();

public:
	virtual void Lock();
	virtual void Unlock();
};

////////////////////////////////////////////////////////////////////////////////////
// multiple sync object abstract class
// Manages multiple handles (the exact type of handle will be determined by a class
//	inheriting from this) to facilitate waiting for the union of several events.
class CMultiSyncObj
{
protected:
	vector<HANDLE> m_arrHandle;

public:
	CMultiSyncObj();
   ~CMultiSyncObj();

public:
	void   AddHandle(HANDLE);
	void   RemoveHandle(HANDLE);
	void   Clear();

public:
	virtual void Lock()   =0;
	virtual void Unlock() =0;
};

////////////////////////////////////////////////////////////////////////////////////
// multiple mutex object class
// Manages multiple mutex handles to facilitate waiting for the union of several mutexes.
class CMultiMutexObj : public CMultiSyncObj
{
public:
	CMultiMutexObj();
   ~CMultiMutexObj();

public:
	virtual void Lock();
	virtual void Lock(LPCSTR srcFile, int srcLine, DWORD TimeOutVal=60000);
	virtual void Unlock();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\stateless.cpp ===
//
// MODULE: Stateless.CPP
//
// PURPOSE: CStateless is the base for a hierarchy of classes intended for stateless operation
//	in a multithreaded environment.  The idea is that each public method in any class inheriting 
//	from CStateless should be atomic. Typically, a public method will begin with Lock() and 
//	end with Unlock().  It should represent a complete process.  
//	In general, public methods should fall into two categories.  
//	1. Determine certain irreversible statuses (e.g. whether certain things are initialized).
//	2. Perform atomic operations.  For example, it is appropriate to write a method that 
//	will take a complete set of node states and return a vector of recommendations.  
//
//	It is NOT appropriate to write methods to
//	- associate a a single node and state, this method to be called repeatedly
//	- get a vector of recommendations based on previousl established node/state associations.
//	This relies on a state to be maintained across calls, but that state may be lost due to
//	other threads using the same object.
//
//	It is legitimate, but not recommended to write the following methods:
//	- associate a uniquely identified query, a node, and a state
//	- get a vector of recommendations for a uniquely identified query, based on node/state
//		associations.
//	This last approach is not truly stateless, but at least provides sufficient information to
//	allow appropriate preservation of state without denying other threads the use of the 
//	CStateless object.
//	
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: 
//	1. Lock() and Unlock() are const methods so that (for example) a simple "get" in a 
//	class which inherits from this can be const. E.g.:
//
//		class CFoo : public CStateless
//		{
//			int i;
//		public:
//			int GetI() const
//			{
//				Lock();
//				int ret = i;
//				Unlock();
//				retrn ret;
//			}
//			...
//		};
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-9-98		JM
//

#include "stdafx.h"
#include "Stateless.h"
#include "APIWraps.h"
#include "Event.h"
#include "BaseException.h"
#include <algorithm>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////
// CStateless
/////////////////////////////////////////////////////////////////////////////////////
CStateless::CStateless(DWORD TimeOutVal /*= 60000 */)
{
	m_TimeOutVal = TimeOutVal;
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Hourly"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
		throw bad_alloc();
	}
}

CStateless::~CStateless()
{
	::CloseHandle(m_hMutex);
}

void CStateless::Lock(
						LPCSTR srcFile,	// Calling source file (__FILE__), used for logging.
										// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
						int srcLine		// Calling source line (__LINE__), used for logging.
					  ) const
{
	APIwraps::WaitAndLogIfSlow(m_hMutex, srcFile, srcLine, m_TimeOutVal);
}

void CStateless::Unlock() const
{
	::ReleaseMutex(m_hMutex);
}

// this function is needed to support multi-mutex locking.	
HANDLE CStateless::GetMutexHandle() const 
{
	return m_hMutex;
}

////////////////////////////////////////////////////////////////////////////////////
// CNameStateless
/////////////////////////////////////////////////////////////////////////////////////
CNameStateless::CNameStateless() 
			  : CStateless()
{
}

CNameStateless::CNameStateless(const CString& str) 
			  : CStateless()
{
	LOCKOBJECT(); 
	m_strName = str;
	UNLOCKOBJECT();
}

void CNameStateless::Set(const CString& str)
{
	LOCKOBJECT(); 
	m_strName = str;
	UNLOCKOBJECT();
}

CString CNameStateless::Get() const
{
	LOCKOBJECT(); 
	CString ret = _T("");
	if ( true != m_strName.IsEmpty() ) ret = m_strName;
	UNLOCKOBJECT();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\statuspages.cpp ===
//
// MODULE: STATUSPAGES.CPP
//
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 10-23-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-23-98	OK		Created by division of apgtsctx.cpp
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "time.h"
#include "apgtscls.h"
#include "apgtscfg.h"
#include "CounterMgr.h"
#include "SafeTime.h"
#include "apgtsmfc.h"

//Global Declaration.
const CString k_strTableBorderColor = _T("\"#000000\"");
const CString k_strBGColorOfTitle = _T( "\"#333366\"");
const CString k_strTextColorOfTitleOrSubTitle = _T("\"#FFFFFF\"");
const CString k_strTextColorOfName = _T("\"#CCCCC99\"");
const CString k_strTextColorOfValue = _T("\"#FFFFCC\"");
const CString k_strBGColorOfSubTitle = _T("\"#3333CC\"");

void AppendNameAndValueAsRow(CString &strAppend, CString strText, CString strVal)
{
	strAppend += _T("<TR>\n");
	if(strText != _T(""))
	{
		strAppend += _T("<TD BGCOLOR=");
		strAppend += k_strTextColorOfName;
		strAppend += _T(">");
		strAppend += _T("<B>");
		strAppend += strText;
		strAppend += _T("</B>\n");
		strAppend += _T("</TD>\n");
	}
	strAppend += _T("<TD ALIGN=\"CENTER\" BGCOLOR=");
	strAppend += k_strTextColorOfValue;
	strAppend += _T(">");
	strAppend += strVal;
	strAppend += _T("</TD>\n");
	strAppend += _T("</TR>\n");
}

// If bSubTitle is TRUE, the subtitle inside the table will be displayed in a
// lighter background to differentiate between the title(darker background)
// and the subtitle. 

void DisplayTextAsTable(CString &strDisplay, CString strText, bool bSubTitle)
{
	strDisplay += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	strDisplay += k_strTableBorderColor;
	strDisplay += _T("CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	strDisplay += _T("<TR>\n");
	strDisplay += _T("<TD COLSPAN =2 ALIGN=\"CENTER\" BGCOLOR=");
	if(bSubTitle)
		strDisplay += k_strBGColorOfTitle;
	else
		strDisplay += k_strBGColorOfSubTitle;
	strDisplay += _T(">\n");
	strDisplay += _T("<FONT SIZE=\"+1\" COLOR=");
	strDisplay += k_strTextColorOfTitleOrSubTitle;
	strDisplay += _T("<B>\n");
	strDisplay += strText;
	strDisplay += _T("</B>\n");
	strDisplay += _T("</TD>\n");
	strDisplay += _T("</TR>\n");
}

void AppendTwoNamesAndValueAsRow(CString &strAppend, CString strText1, CString strText2, CString strVal)
{
	strAppend += _T("<TR>\n");
	strAppend += _T("<TD ALIGN=\"LEFT\" BGCOLOR=");
	strAppend += k_strTextColorOfName;
	strAppend += _T(" >");
	strAppend += _T("<B>\n");
	strAppend += strText1;
	strAppend += _T("</B>\n");
	strAppend += _T("</TD>");
	strAppend += _T("<TD ALIGN=\"CENTER\" BGCOLOR=");
	strAppend += k_strTextColorOfValue;
	strAppend += _T(">\n");
	strAppend += strText2;
	strAppend += _T("</TD>\n");
	strAppend += _T("<TD ALIGN=\"CENTER\" BGCOLOR=");
	strAppend += k_strTextColorOfValue;
	strAppend += _T(">\n");
	strAppend += strVal;
	strAppend += _T("</TD>\n");
	strAppend += _T("</TR>\n");
}


// Returns true if we should show the full (rather than partial) first page.
bool APGTSContext::ShowFullFirstPage(bool bHasPwd)
{
// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifdef NOPWD
	return true;
#else
	return bHasPwd;
#endif // ifndef NOPWD
}

void APGTSContext::InsertPasswordInForm()
{
	// You can compile with the NOPWD option to suppress all password checking.
	// This is intended mainly for creating test versions with this feature suppressed.
	#ifndef NOPWD
			m_strText += _T("<INPUT TYPE=hidden NAME=\"PWD\" VALUE=\"");
			m_strText += m_strTempPwd;
			m_strText += _T("\">\n");
	#endif // ifndef NOPWD
}

void APGTSContext::BeginSelfAddressingForm()
{
	m_strText += _T("<FORM ACTION=\"");
	m_strText += _T("http://");
	m_strText += m_strLocalIPAddress;
	m_strText += m_strVRoot;
	m_strText += _T("\" METHOD=POST>\n");
}

// Append to m_strText: contents of an HTML page giving:
//	- usage statistics
//	- list of available troubleshooter topics
// Not available to the end user.
// INPUT bHasPwd - if this is false, limit the info shown on this page.
void APGTSContext::DisplayFirstPage(bool bHasPwd)
{
	CHourlyDailyCounter tmp_counter;
	DWORD dwRegistryItem =0;
	CString strRegistryItem;
	const CString strRegistryItemNotFound = _T("not found");

	CRegistryMonitor& registryMonitor = m_pConf->GetRegistryMonitor();
	CThreadPool& threadPool = m_pConf->GetThreadPool();
	CPoolQueue& poolQueue = m_pConf->GetPoolQueue();
	
	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Welcome</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T(">\n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<B>Welcome To The Generic Troubleshooter v");
	m_strText += gstrProductVersion;
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	
	m_strText += _T("</h1></center>\n");
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	// Display global counters
	CString strTmp;
	CHourlyDailyCounter* curr_counter = NULL;
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		
		strTmp=  CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);

		strTmp =  CDisplayCounterCreateDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time program started:"), strTmp);

	}

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdStatusAccess));
	if (curr_counter) 
	{		
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of status accesses to system since program was started:"), strTmp);

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent status access:"), strTmp);

	}

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdActionAccess));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of operator action accesses to system since program was started:"), strTmp);

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent operator action access:"), strTmp);

	}

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTotalAccessStart));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of total accesses to system since program was started:"), strTmp);

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent access:"), strTmp);
	}

	if (ShowFullFirstPage(bHasPwd))
	{
		curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestUnknown));
		if (curr_counter) 
		{	
			strTmp = CDisplayCounterTotal(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Number of requests to system for unknown troubleshooters topics since program was started:"), strTmp);

			strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request to system for unknown troubleshooter topic:"), strTmp);
		}

		curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestRejected));
		if (curr_counter) 
		{
			strTmp = CDisplayCounterTotal(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Number of requests system has rejected because of backlog in queue since program was started:"), strTmp);

			strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request system has rejected because of backlog in queue:"), strTmp);
		}
		
		curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdErrorLogged));
		if (curr_counter) 
		{
			strTmp = CDisplayCounterTotal(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Number of errors logged to event log since program was started:"), strTmp);
			
			strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent logged error:"), strTmp);
		}
		
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItemNotFound);
	
		
	
		////////////////////////////////////////////////////////////////////////////////////
		// Extract and display information about threads and queue
		tmp_counter.Init(threadPool.GetWorkingThreadCount());
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current number of working threads:"), strTmp);

		tmp_counter.Init(poolQueue.GetTotalQueueItems());
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current number of work items in queue:"), strTmp);

		tmp_counter.Init(poolQueue.GetTotalWorkItems());
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current number of work items either in queue or in progress:"), strTmp);
	}
	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display snapshot information about topic
	DWORD dwTotal=0, dwNoInit=0, dwFail=0;
	vector<CString> vector_placeholder;
	m_pConf->GetTopicShop().GetTopicsStatus(dwTotal, dwNoInit, dwFail, &vector_placeholder);
	tmp_counter.Init(dwTotal);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Total number of known troubleshooter topics:"), strTmp);

	if (ShowFullFirstPage(bHasPwd))
	{
		tmp_counter.Init(dwFail);
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of troubleshooter topics that we have tried and failed to load:"), strTmp);
	}
	
	m_strText += _T("</TABLE>\n");

	////////////////////////////////////////////////////////////////////////////////////
	    m_strText += _T("</ul><center>\n");
	////////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////////////
	// Display buttons to get to sibling status pages
	if (ShowFullFirstPage(bHasPwd))
	{
		BeginSelfAddressingForm();
		InsertPasswordInForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_FURTHER_GLOBAL;
		// Value here is not actually relevant; effectively used as a comment.
		m_strText += _T("\" VALUE=\"Further Global Status Page\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Further Global Status Page\">\n");
		m_strText += _T("</FORM>\n");

		BeginSelfAddressingForm();
		InsertPasswordInForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_THREAD_OVERVIEW;
		// Value here is not actually relevant; effectively used as a comment.
		m_strText += _T("\" VALUE=\"Thread Status Overview Page\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Thread Status Overview Page\">\n");
		m_strText += _T("</FORM>\n");
	}

	////////////////////////////////////////////////////////////////////////////////////
	// Display topics & links to status information for those topics
	vector<CString>arrstrTopic;
	m_pConf->GetListOfTopicNames(arrstrTopic);

	DWORD nTopics = arrstrTopic.size();
	
	for (DWORD i=0; i<nTopics; i++) 
	{
		m_strText += _T("<TABLE>");
		m_strText += _T("<TR>");
		m_strText += _T("<TD>");

		BeginSelfAddressingForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_TOPIC;
		m_strText += _T("\" VALUE=\"");
		m_strText += arrstrTopic[i];
		m_strText += _T("\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"");
		m_strText += _T("Problem Page for ");
		m_strText += arrstrTopic[i];
		m_strText += _T("\">\n");
		m_strText += _T("</FORM>\n");

		m_strText += _T("</TD>");

		if (ShowFullFirstPage(bHasPwd))
		{
			m_strText += _T("<TD>");

			BeginSelfAddressingForm();
			InsertPasswordInForm();
			m_strText += _T("<INPUT TYPE=hidden NAME=\"");
			m_strText += C_TOPIC_STATUS;
			m_strText += _T("\" VALUE=\"");
			m_strText += arrstrTopic[i];
			m_strText += _T("\">\n");
			m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"");
			m_strText += _T("Status Page for ");
			m_strText += arrstrTopic[i];
			m_strText += _T("\">\n");
			m_strText += _T("</FORM>\n");

			m_strText += _T("</TD>");
		}
		m_strText += _T("</TR>");
		m_strText += _T("</TABLE>");
	}
	if(nTopics == 0) 
	{
		m_strText += _T("<P>There are currently no troubleshooters available");
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</center>\n");
	////////////////////////////////////////////////////////////////////////////////////

	if (ShowFullFirstPage(bHasPwd))
	{
		m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
		////////////////////////////////////////////////////////////////////////////////////
		// Display registry info
		
		if (registryMonitor.GetStringInfo(CAPGTSRegConnector::eResourcePath, strRegistryItem))	
			AppendNameAndValueAsRow(m_strText, _T("Full path to resource:"), strRegistryItem);
		else
			AppendNameAndValueAsRow(m_strText, _T("Full path to resource:"), strRegistryItemNotFound);

	
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eCookieLife, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("HTTP cookie expiration in minutes:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("HTTP cookie expiration in minutes:"), strRegistryItemNotFound);
	
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxThreads, dwRegistryItem)) 
		{
			
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Maximum threads:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Maximum threads:"), strRegistryItemNotFound);
			
			
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Maximum work queue items:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Maximum work queue items :"), strRegistryItemNotFound);
		
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eReloadDelay, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Refresh delay:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Refresh delay:"), strRegistryItemNotFound);	
		
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eThreadsPP, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Threads per processor:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Threads per processor:"), strRegistryItemNotFound);	
	

		if (registryMonitor.GetStringInfo(CAPGTSRegConnector::eVrootPath, strRegistryItem)) 
				AppendNameAndValueAsRow(m_strText, _T("VRoot path to DLL:"), strRegistryItem);	
		else
			AppendNameAndValueAsRow(m_strText, _T("VRoot path to DLL:"), strRegistryItemNotFound);	
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eDetailedEventLogging, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Detailed event logging:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Detailed event logging:"), strRegistryItemNotFound);	
		
		if (registryMonitor.GetStringInfo(CAPGTSRegConnector::eLogFilePath, strRegistryItem)) 
			AppendNameAndValueAsRow(m_strText, _T("Log file directory:"), strRegistryItem);	
		else
			AppendNameAndValueAsRow(m_strText, _T("Log file directory:"), strRegistryItemNotFound);	
		
	}
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</body></html>\n");
	////////////////////////////////////////////////////////////////////////////////////
}

void APGTSContext::DisplayFurtherGlobalStatusPage()
{

	CHourlyDailyCounter tmp_counter;
	DWORD dwRegistryItem =0;
	CString strRegistryItem;
	CString strTmp;
	const CString strRegistryItemNotFound = _T("not found");
	CRegistryMonitor& registryMonitor = m_pConf->GetRegistryMonitor();
	CThreadPool& threadPool = m_pConf->GetThreadPool();
	CPoolQueue& poolQueue = m_pConf->GetPoolQueue();
	CHourlyDailyCounter* curr_counter = NULL;
	CDailyTotals daily;
	CHourlyTotals hourly;

	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Status</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T(">\n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<B>Further Global Status Page ");
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	// Display global counters

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Status Access To The System"), 1);
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdStatusAccess));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of status accesses to system since program was started:"), strTmp);		

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent status access:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of status accesses to system since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Operator Access To The System"), 1);
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdActionAccess));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of operator action accesses to system since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent operator action access:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of operator action accesses to system since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();

	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Total Access To The System"), 1);
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTotalAccessStart));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of total accesses to system since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent access:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of total accesses to system since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("Request To System For UnKnown TroubleShooter Topics"), 1);
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestUnknown));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of requests to system for unknown troubleshooters topics since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request to system for unknown troubleshooter topic:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of  requests to system for unknown troubleshooter topics since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Requests System Has Rejected"), 1);
	m_strText += _T("</TABLE>\n");

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestRejected));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of requests system has rejected because of backlog in queue since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request system has rejected because of backlog in queue:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of requests system has rejected because of backlog in queue since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("Errors Logged To Event Log"), 1);

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdErrorLogged));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of errors logged to event log since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent logged error:"), strTmp);

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of logged errors"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
	}
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Statistics About Queue, Thread and Successful/Unsuccessful Load Of Topics"), 1);
	m_strText += _T("</TABLE>\n");
	
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	
	if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
	{
		strRegistryItem.Format(_T("%d"), dwRegistryItem);
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItem);
	}
	else
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItemNotFound);
	m_strText += _T("\n");

	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display information about threads and queue

	
	tmp_counter.Init(threadPool.GetWorkingThreadCount());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of working threads:"), strTmp);

	tmp_counter.Init(poolQueue.GetTotalQueueItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items in queue :"), strTmp);
	
	tmp_counter.Init(poolQueue.GetTotalWorkItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items either in queue or in progress :"), strTmp);
	//////////////////////////////////////////////////////////////////////////////////

	strTmp = CSafeTime(poolQueue.GetTimeLastAdd()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent addition to queue :"), strTmp);
	
	strTmp = CSafeTime(poolQueue.GetTimeLastRemove()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent removal from queue :"), strTmp);
	
	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display snapshot information about topic
	DWORD dwTotal=0, dwNoInit=0, dwFail=0;
	vector<CString> vector_topics_failed;
	m_pConf->GetTopicShop().GetTopicsStatus(dwTotal, dwNoInit, dwFail, &vector_topics_failed);
	tmp_counter.Init(dwTotal);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Total number of known troubleshooter topics:"), strTmp);

	tmp_counter.Init(dwNoInit);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Number of troubleshooter topics that we have not yet tried to load:"), strTmp);

	tmp_counter.Init(dwFail);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Number of troubleshooter topics that we have tried and failed to load:"), strTmp);

	if (vector_topics_failed.size()) 
		for (vector<CString>::iterator i = vector_topics_failed.begin(); i != vector_topics_failed.end(); i++)
		{
			strTmp = *i;
			AppendNameAndValueAsRow(m_strText, _T("List of troubleshooter topics that we have tried and failed to load:"), strTmp);
		}
	else
	{
		strTmp = _T("No topics");
		AppendNameAndValueAsRow(m_strText, _T("List of troubleshooter topics that we have tried and failed to load:"), strTmp);
	}

	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display snapshot information about alternate templates
	vector<CString> vector_templates_failed;
	vector<DWORD> vector_templatescnt_failed;
	DWORD dwTemplateCnt;
	m_pConf->GetTopicShop().GetTemplatesStatus( &vector_templates_failed, &vector_templatescnt_failed );
	dwTemplateCnt= vector_templates_failed.size();
	if (dwTemplateCnt)
	{
		// Only output if there are failed loads.
		tmp_counter.Init( dwTemplateCnt );
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Total number of templates not found:"), strTmp);

		vector<DWORD>::iterator j = vector_templatescnt_failed.begin(); 
		for (vector<CString>::iterator i = vector_templates_failed.begin();
			i != vector_templates_failed.end(); i++)
		{
			strTmp = *i;
			AppendNameAndValueAsRow(m_strText, _T(""), strTmp);

			if (j != vector_templatescnt_failed.end())
			{
				// Output the counts.
				tmp_counter.Init( *j );
				strTmp = CDisplayCounterTotal(&tmp_counter).Display();
				AppendNameAndValueAsRow(m_strText, _T(": "), strTmp);
				j++;
			}
		}
	}
	m_strText += _T("</TABLE>\n");
	//////////////////////////////////////////////////////////////////////////////////
	// Link buttons
	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FIRST;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Front Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Front Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_THREAD_OVERVIEW;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("</FORM>\n");

	//////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</body></html>\n");
	//////////////////////////////////////////////////////////////////////////////////
}

void APGTSContext::DisplayThreadStatusOverviewPage()
{
	CString strTmp;
	CString strTmp2;
	CString strTmp3;
	CString strTmp4;
	CHourlyDailyCounter tmp_counter;
	DWORD dwRegistryItem =0;
	CString strRegistryItem;
	const CString strRegistryItemNotFound = _T("not found");
	CRegistryMonitor& registryMonitor = m_pConf->GetRegistryMonitor();
	CDirectoryMonitor& directoryMonitor = m_pConf->GetDirectoryMonitor();
	CTopicShop& topicShop = m_pConf->GetTopicShop();
	CThreadPool& threadPool = m_pConf->GetThreadPool();
	CPoolQueue& poolQueue = m_pConf->GetPoolQueue();
	CHourlyDailyCounter* curr_counter = NULL;
	CDailyTotals daily;
	CHourlyTotals hourly;

	////////////////////////////////////////////////////////////////////////////////////
	// Collect status information for pool threads
	vector<CPoolThreadStatus> arrPoolThreadStatus;
	for (long i = 0; i < threadPool.GetWorkingThreadCount(); i++)
	{
		CPoolThreadStatus status;
		threadPool.ThreadStatus(i, status);
		arrPoolThreadStatus.push_back(status);
	}


	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Status</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T(">\n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<B>Thread Status Overview Page ");
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	m_strText += _T("</h1></center>\n");
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	// Display global counters
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);
	}
	
	
	if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
	{
		strRegistryItem.Format(_T("%d"), dwRegistryItem);
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItem);
	}
	else
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItemNotFound);

	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display information about threads and queue
	tmp_counter.Init(threadPool.GetWorkingThreadCount());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of working threads:"), strTmp);

	tmp_counter.Init(poolQueue.GetTotalQueueItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items in queue:"), strTmp);
		
	tmp_counter.Init(poolQueue.GetTotalWorkItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items either in queue or in progress:"), strTmp);

	strTmp = CSafeTime(poolQueue.GetTimeLastAdd()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent addition to queue:"), strTmp);

	strTmp = CSafeTime(poolQueue.GetTimeLastRemove()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent removal from queue:"), strTmp);

	//////////////////////////////////////////////////////////////////////////////////
	// thread pool status information
	long more5 = 0, more10 = 0;
	vector<CPoolThreadStatus> arrPoolThreadStatusOlder5;
	// This next is slightly klugy.  Ideally, we'd get this info into arrPoolThreadStatusOlder5
	vector<DWORD> Older5ThreadNumber;
	for (i = 0; i < arrPoolThreadStatus.size(); i++)
	{
		if (arrPoolThreadStatus[i].m_bWorking) 
		{
			if (arrPoolThreadStatus[i].m_seconds > 5)
			{
				arrPoolThreadStatusOlder5.push_back(arrPoolThreadStatus[i]);
				Older5ThreadNumber.push_back(i);
				more5++;
			}
			if (arrPoolThreadStatus[i].m_seconds > 10)
				more10++;
		}
	}

	
	strTmp.Format(_T("%ld"), more5);
	AppendNameAndValueAsRow(m_strText, _T("Number of pool threads that have been working on a task for more than 5 seconds:"), strTmp);
	
	strTmp.Format(_T("%ld"), more10);
	AppendNameAndValueAsRow(m_strText, _T("Number of pool threads that have been working on a task for more than 10 seconds:"), strTmp);

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("Detailed information on each of the pool threads that has been working on a task for more than 5 seconds"), 1);

	for (i = 0; i < arrPoolThreadStatusOlder5.size(); i++)
	{
		strTmp.Format(_T("<B>Thread %d </B>"), Older5ThreadNumber[i]);
		strTmp2 = _T(" has been in \"working\" state for ");
		strTmp += strTmp2;
		strTmp3.Format(_T("%ld"), (long)arrPoolThreadStatusOlder5[i].m_seconds);
		strTmp3 += _T(" seconds");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp3);

		strTmp.Format( _T("Date/Time thread %d started:"), Older5ThreadNumber[i]);
		strTmp2 = CSafeTime(arrPoolThreadStatusOlder5[i].m_timeCreated).StrLocalTime();
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

		strTmp.Format( _T("Thread %d is working on topic:"), Older5ThreadNumber[i]);
		strTmp2 = arrPoolThreadStatusOlder5[i].m_strTopic.GetLength() 
					 ? arrPoolThreadStatusOlder5[i].m_strTopic
					 : _T("no topic");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

		
		strTmp.Format (_T("Client IP address for Thread %d:"),Older5ThreadNumber[i] );
		strTmp2 = arrPoolThreadStatusOlder5[i].m_strClientIP.GetLength() 
						? arrPoolThreadStatusOlder5[i].m_strClientIP : _T("no address");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

		
		strTmp.Format( _T(" Client browser for Thread %d:"), Older5ThreadNumber[i] );
		strTmp2 = arrPoolThreadStatusOlder5[i].m_strBrowser.GetLength() 
						? arrPoolThreadStatusOlder5[i].m_strBrowser : _T("no browser");

		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

	
		
	}
	if (!i)
		AppendNameAndValueAsRow(m_strText, _T(""), _T("No threads"));
	
	//////////////////////////////////////////////////////////////////////////////////
	// registry monitor thread status information
	CRegistryMonitor::ThreadStatus registryStatus;
	DWORD registrySeconds = 0;
	CString strRegistryStatus;
	registryMonitor.GetStatus(registryStatus, registrySeconds);
	switch(registryStatus)
	{
		case CRegistryMonitor::eBeforeInit: strRegistryStatus = _T("Before Init");
			break;
		case CRegistryMonitor::eInit: strRegistryStatus = _T("Init");
			break;
		case CRegistryMonitor::eFail: strRegistryStatus = _T("Fail");
			break;
		case CRegistryMonitor::eDefaulting: strRegistryStatus = _T("Defaulting");
			break;
		case CRegistryMonitor::eWait: strRegistryStatus = _T("Wait");
			break;
		case CRegistryMonitor::eRun: strRegistryStatus = _T("Run");
			break;
		case CRegistryMonitor::eExiting: strRegistryStatus = _T("Exiting");
			break;
	}


	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	strTmp = strRegistryStatus;
	AppendNameAndValueAsRow(m_strText, _T("Current status of Registry Monitor thread:"), strTmp);

	strTmp.Format(_T("%ld"), (long)registrySeconds);
	strTmp  += _T(" seconds\n");
	AppendNameAndValueAsRow(m_strText, _T("The thread has been in this status for "), strTmp);

	//////////////////////////////////////////////////////////////////////////////////
	// directory monitor thread status information
	CDirectoryMonitor::ThreadStatus directoryStatus;
	DWORD directorySeconds = 0;
	CString strDirectoryStatus;
	directoryMonitor.GetStatus(directoryStatus, directorySeconds);
	switch(directoryStatus)
	{
		case CDirectoryMonitor::eBeforeInit: strDirectoryStatus = _T("Before Init");
			break;
		case CDirectoryMonitor::eFail: strDirectoryStatus = _T("Fail");
			break;
		case CDirectoryMonitor::eWaitDirPath: strDirectoryStatus = _T("Wait For Dir Path");
			break;
		case CDirectoryMonitor::eWaitChange: strDirectoryStatus = _T("Wait For Change");
			break;
		case CDirectoryMonitor::eWaitSettle: strDirectoryStatus = _T("Wait To Settle");
			break;
		case CDirectoryMonitor::eRun: strDirectoryStatus = _T("Run");
			break;
		case CDirectoryMonitor::eBeforeWaitChange: strDirectoryStatus = _T("Before Wait Change");
			break;
		case CDirectoryMonitor::eExiting: strDirectoryStatus = _T("Exiting");
			break;
	}

	strTmp = strDirectoryStatus;
	AppendNameAndValueAsRow(m_strText, _T("Current status of Directory Monitor thread:"), strTmp);

	strTmp.Format(_T("%ld"), (long)directorySeconds);
	strTmp += _T(" seconds\n");
	AppendNameAndValueAsRow(m_strText, _T("The thread has been in this status for "), strTmp);

	//////////////////////////////////////////////////////////////////////////////////
	// topic builder thread status information
	CTopicShop::ThreadStatus topicshopStatus;
	DWORD topicshopSeconds = 0;
	CString strTopicshopStatus;
	topicShop.GetThreadStatus(topicshopStatus, topicshopSeconds);
	switch(topicshopStatus)
	{
		case CTopicShop::eBeforeInit: strTopicshopStatus = _T("Before Init");
			break;
		case CTopicShop::eFail: strTopicshopStatus = _T("Fail");
			break;
		case CTopicShop::eWait: strTopicshopStatus = _T("Wait");
			break;
		case CTopicShop::eRun: strTopicshopStatus = _T("Run");
			break;
		case CTopicShop::eExiting: strTopicshopStatus = _T("Exiting");
			break;
	}

	strTmp = strTopicshopStatus;
	AppendNameAndValueAsRow(m_strText, _T("Current status of TopicShop Monitor thread:"), strTmp);

	strTmp.Format(_T("%ld"), (long)topicshopSeconds);
	strTmp += _T(" seconds\n");
	AppendNameAndValueAsRow(m_strText, _T("The thread has been in this status for "), strTmp);


	//////////////////////////////////////////////////////////////////////////////////
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("State of each pool thread"), 1);

	for (i = 0; i < arrPoolThreadStatus.size(); i++)
	{
		strTmp.Format(_T("<B>Thread %d has been in "), i);
		strTmp2 = arrPoolThreadStatus[i].m_bWorking ? _T("\"working\"") : _T("\"waiting\"");
		strTmp3 = _T(" state for </B>");
		strTmp2 +=  strTmp3;
		strTmp +=  strTmp2;
		strTmp4.Format(_T("%ld"), (long)arrPoolThreadStatus[i].m_seconds);
		strTmp4 += _T(" seconds.");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp4);
	}
	if (!i)
		AppendNameAndValueAsRow(m_strText, _T(""),_T("No threads") );

	m_strText += _T("</TABLE>\n");
	//////////////////////////////////////////////////////////////////////////////////
	// Link buttons
	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FURTHER_GLOBAL;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FIRST;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Front Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Front Page\">\n");
	m_strText += _T("</FORM>\n");

	m_strText += _T("</body></html>\n");
}

///////////////////////////

void APGTSContext::DisplayTopicStatusPage(LPCTSTR topic_name)
{
	CHourlyDailyCounter tmp_counter, *curr_counter;
	CTopicShop& topicShop = m_pConf->GetTopicShop();
	CTopicInCatalog* pTopicInCatalog = topicShop.GetCatalogEntry(topic_name);
	CHourlyTotals hourly;
	CDailyTotals daily;
	CString strTmp;
	CString strTmp2;

	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Status</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T("> \n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T("> \n");
	m_strText += _T("<B>Topic Status Page for ");
	m_strText += topic_name;
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	

	if (pTopicInCatalog) 
		m_strText += _T("</h1></center>\n");
	else
	{
		m_strText += _T("No data available");
		m_strText += _T("</h1></center>\n");
		return;
	}

	CTopicInfo topicInfo = pTopicInCatalog->GetTopicInfo();
	CString strDsc = CAbstractFileReader::GetJustName(topicInfo.GetDscFilePath());
	CString strHti = CAbstractFileReader::GetJustName(topicInfo.GetHtiFilePath());
	CString strBes = CAbstractFileReader::GetJustName(topicInfo.GetBesFilePath());

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);
	}

	m_strText += _T("</TABLE>\n");

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	strTmp = CString(_T("<BR>")) + (strDsc.GetLength() ? strDsc : _T("Unknown"));
	strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrDscFileCreated();
	AppendTwoNamesAndValueAsRow(m_strText, _T("DSC file:"), strTmp, strTmp2);

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	bool bHTIinsideOfDSC= false, bBESinsideOfDSC= false;
	{
		CP_TOPIC ptrTopic;
		pTopicInCatalog->GetTopicNoWait(ptrTopic);

		CString strTmp;
		if (!ptrTopic.IsNull())
		{
			strTmp = ptrTopic->GetNetPropItemStr( H_NET_DATE_TIME );

			// Check for HTI and BES files inside the DSC.
			CString strTmpHTI= ptrTopic->GetMultilineNetProp( H_NET_HTI_ONLINE, _T("%s\r\n") );
			if (strTmpHTI.GetLength())
				bHTIinsideOfDSC= true;
			CString strTmpBES= ptrTopic->GetNetPropItemStr( H_NET_BES );
			if (strTmpBES.GetLength())
				bBESinsideOfDSC= true;
		}

		strTmp2 = strTmp.GetLength() ? strTmp : _T("Unavailable");
		AppendNameAndValueAsRow(m_strText, _T("Last revision date/time of DSC:"), strTmp2);
	}

	m_strText += _T("</TABLE>\n");

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrHtiFileCreated();
	if (strHti.GetLength())
		strTmp= _T("<BR>") + strHti;
	else if (bHTIinsideOfDSC)
	{
		// Use DSC file settings.
		strTmp = CString(_T("<BR>")) + (strDsc.GetLength() ? strDsc : _T("Unknown"));
		strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrDscFileCreated();
	}
	else
		strTmp= _T("<BR>Unknown");
	AppendTwoNamesAndValueAsRow(m_strText, _T("HTI file:"), strTmp, strTmp2);

	strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrBesFileCreated();
	if (strBes.GetLength())
		strTmp= _T("<BR>") + strBes;
	else if (bBESinsideOfDSC)
	{
		// Use DSC file settings.
		strTmp = CString(_T("<BR>")) + (strDsc.GetLength() ? strDsc : _T("Unknown"));
		strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrDscFileCreated();
	}
	else
		strTmp= _T("<BR>Unknown");
	AppendTwoNamesAndValueAsRow(m_strText, _T("BES file:"), strTmp, strTmp2);

	if (pTopicInCatalog->GetTopicInfoMayNotBeCurrent())
	{
		m_strText += _T("<TR>\n");    
        m_strText += _T("<TD COLSPAN=3 ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\" >\n");
		m_strText += _T("<BR>***BES or HTI may recently have changed, and data may not yet be updated.***");
		m_strText += _T("</TD>\n");
		m_strText += _T("</TR>\n");
	}
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicEvent, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first becoming aware of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoad, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first attempted load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoadOK, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first successful load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicEvent, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent change (detected by directory monitor) or reload request (from an operator) to this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoad, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Count of attempted loads of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoad, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent attempted load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoadOK, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Count of successful loads of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoadOK, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent successful load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first user hit on this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent hit:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Total count of hits since system startup:"), strTmp);
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of hits"), 1);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHitNewCookie, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Hits without cookie (presumably first hit by this user):"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHitOldCookie, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Hits with cookie (presumably not first hit by this user):"), strTmp);
	}
	m_strText += _T("</TABLE>\n");
	if (CTopicInCatalog::eFail != pTopicInCatalog->GetTopicStatus())
	{
		BeginSelfAddressingForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_TOPIC;
		m_strText += _T("\" VALUE=\"");
		m_strText += topic_name;
		m_strText += _T("\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"");
		m_strText += _T("Problem Page for ");
		m_strText += topic_name;
		m_strText += _T("\">\n");
		m_strText += _T("</FORM>\n");
	}

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FURTHER_GLOBAL;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_THREAD_OVERVIEW;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FIRST;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Front Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Front Page\">\n");
	m_strText += _T("</FORM>\n");
	//m_strText += _T("</TABLE>\n");


	///////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</body></html>\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\templateread.h ===
//
// MODULE: TEMPLATEREAD.H
//
// PURPOSE: template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
//	1. CTemplateReader has no public methods to apply the template.  These must be supplied
//		by classes which inherit from CTemplateReader, and these must be supplied in a
//		suitably "stateless" manner.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __TEMPLATEREAD_H_
#define __TEMPLATEREAD_H_

#include "fileread.h"

#include <map>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////
// CTemplateInfo
////////////////////////////////////////////////////////////////////////////////////
class CTemplateInfo
{
	CString m_KeyStr;			// key text which we will replace with m_SubstitutionStr
	CString m_SubstitutionStr;	// text we will use to replace m_KeyStr

public:
	CTemplateInfo();
	CTemplateInfo(const CString& key, const CString& substitution);
	virtual ~CTemplateInfo();
	
	CString& GetKeyStr() {return m_KeyStr;}
	virtual bool Apply(CString& target) const;

// comparison methods are mainly to keep STL happy.  Note that they only look at
//	m_KeyStr, not m_SubstitutionStr.
inline BOOL operator == (const CTemplateInfo& two) const
{
	return m_KeyStr == two.m_KeyStr;
}

inline BOOL operator < (const CTemplateInfo& two) const 
{
	return m_KeyStr < two.m_KeyStr;
}


};

////////////////////////////////////////////////////////////////////////////////////
// CTemplateReader
// This class reads template file and provides functionality to substitute key
//   sentences with text - do it all at once, or one-by-one.
// The object of this class can be renewed with another template - in this case
//  all substitution actions will be performed on new template.
// It can roll back "n" last substitutions
////////////////////////////////////////////////////////////////////////////////////
class CTemplateReader : public CTextFileReader
{
protected:
	tstringstream m_StreamOutput; // streamed output, fully or partly substituted template
							      //  (which resides in CFileReader::m_StreamData)
	vector<CTemplateInfo> m_arrTemplateInfo; // contains key string - template info
										     //  pairs
public:
	CTemplateReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CTemplateReader();

protected:
	void SetOutputToTemplate();
	CTemplateReader& operator << (CTemplateInfo&); // apply
	CTemplateReader& operator >> (CTemplateInfo&); // roll back application for this CTemplateInfo

	void GetOutput(CString&);

protected:
	// overrrides of inherited functions
	virtual void Parse(); // parse here is applying ALL elements of m_arrTemplateInfo
						  //  to a virgin template

};

////////////////////////////////////////////////////////////////////////////////////
// a concrete class that just provides simple string substitution
////////////////////////////////////////////////////////////////////////////////////
class CSimpleTemplate : public CTemplateReader
{
public:
	CSimpleTemplate(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CSimpleTemplate();

   void CreatePage(	const vector<CTemplateInfo> & arrTemplateInfo, 
					CString& out );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\templateread.cpp ===
//
// MODULE: TEMPLATEREAD.CPP
//
// PURPOSE: template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
//	1. CTemplateReader has no public methods to apply the template.  These must be supplied
//		by classes which inherit from CTemplateReader, and these must be supplied in a
//		suitably "stateless" manner.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include <algorithm>
#include "templateread.h"
#include "event.h"
#include "CharConv.h"

////////////////////////////////////////////////////////////////////////////////////
// CTemplateInfo
//	Manages a pair consisting of a key and a string to substitute for each occurrence of
//	that key.
////////////////////////////////////////////////////////////////////////////////////
CTemplateInfo::CTemplateInfo()
{
}

CTemplateInfo::CTemplateInfo(const CString& key, const CString& substitution)
			 : m_KeyStr(key),
			   m_SubstitutionStr(substitution)
{
}

CTemplateInfo::~CTemplateInfo()
{
}

// INPUT/OUTPUT target
//	Replace all instances of m_KeyStr in target with m_SubstitutionStr
bool CTemplateInfo::Apply(CString& target) const
{
	int start =0, end =0;
	bool bRet = false;

	while (-1 != (start = target.Find(m_KeyStr)))
	{
		end = start + m_KeyStr.GetLength();
		target = target.Left(start) + m_SubstitutionStr + target.Mid(end);
		bRet = true;
	}
	return bRet;
}

////////////////////////////////////////////////////////////////////////////////////
// CTemplateReader
////////////////////////////////////////////////////////////////////////////////////
CTemplateReader::CTemplateReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /*= NULL */)
			   : CTextFileReader(pPhysicalFileReader, szDefaultContents)
{
}

CTemplateReader::~CTemplateReader()
{
}

// For all instances of a key, substitute the appropriate value
CTemplateReader& CTemplateReader::operator << (CTemplateInfo& info)
{
	CString str;
	vector<CString> str_arr;

	LOCKOBJECT();
	SetPos(m_StreamOutput, 0);

	try
	{
		// put whole content of m_StreamOutput, line by line, into str_arr
		while (GetLine(m_StreamOutput, str))
			str_arr.push_back(str);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	vector<CString>::iterator i;
	//	Replace all instances of m_KeyStr in str_arr elements with m_SubstitutionStr
	for (i = str_arr.begin(); i < str_arr.end(); i++)
		info.Apply(*i);

	m_StreamOutput.clear();

	vector<CString>::iterator iLastElement = str_arr.end();
	iLastElement--;	

	for (i = str_arr.begin(); i < str_arr.end(); i++)
	{
		m_StreamOutput << (LPCTSTR)*i;
		if (i != iLastElement)
			m_StreamOutput << _T('\r') << _T('\n');
	}
	m_StreamOutput << ends;

	SetPos(m_StreamOutput, 0);
	UNLOCKOBJECT();
	return *this;
}

// undo substitution with this argument
// As of 11/98, not used in Online Troubleshooter, hence totally untested.
CTemplateReader& CTemplateReader::operator >> (CTemplateInfo& info)
{
	LOCKOBJECT();

	// remove this element from substitution list
	vector<CTemplateInfo>::iterator res = find(m_arrTemplateInfo.begin(), m_arrTemplateInfo.end(), info);
	if (res != m_arrTemplateInfo.end())
		m_arrTemplateInfo.erase(res);
	// perform all substitutions all over again
	Parse();
	
	UNLOCKOBJECT();
	return *this;
}

// Perform all substitutions
void CTemplateReader::Parse()
{
	SetOutputToTemplate();
	for (vector<CTemplateInfo>::iterator i = m_arrTemplateInfo.begin(); i < m_arrTemplateInfo.end(); i++)
		*this << *i;
}

void CTemplateReader::GetOutput(CString& out)
{
	out = _T(""); // clear
	LOCKOBJECT();
	out = m_StreamOutput.rdbuf()->str().c_str();
	UNLOCKOBJECT();
}

// In m_StreamData we always have pure template
// This function is discarding all changes in m_StreamOutput
//  and setting it back to template
void CTemplateReader::SetOutputToTemplate()
{
	LOCKOBJECT();
	tstring tstr;
	m_StreamOutput.str(GetContent(tstr));
	UNLOCKOBJECT();
}

////////////////////////////////////////////////////////////////////////////////////
// CSimpleTemplate
////////////////////////////////////////////////////////////////////////////////////
CSimpleTemplate::CSimpleTemplate(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /*= NULL*/) :
	CTemplateReader(pPhysicalFileReader, szDefaultContents)
{
}

CSimpleTemplate::~CSimpleTemplate()
{
}

// Given a vector of substitutions to make, perform them all (on the template) and return 
//	the resulting string.
void CSimpleTemplate::CreatePage(	const vector<CTemplateInfo> & arrTemplateInfo, 
									CString& out)
{
	LOCKOBJECT();
	m_arrTemplateInfo = arrTemplateInfo;
	Parse();
	out = m_StreamOutput.rdbuf()->str().c_str();
	UNLOCKOBJECT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\topic.h ===
//
// MODULE: TOPIC.H
//
// PURPOSE: Class CTopic brings together all of the data structures that represent a 
//			troubleshooting topic.  Most importantly, this represents the belief network,
//			but it also represents the HTI template, the data derived from the BES (back 
//			end search) file, and any other persistent data.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-09-98	JM
//

#if !defined(AFX_TOPIC_H__278584FE_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
#define AFX_TOPIC_H__278584FE_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "BN.h"
#include "apgtsbesread.h"
#include "apgtshtiread.h"

// The bulk of the methods on this class are inherited from CBeliefNetwork
class CTopic : public CBeliefNetwork
{
private:
	CAPGTSHTIReader *m_pHTI;
	CAPGTSBESReader *m_pBES;
	CString m_pathHTI;
	CString m_pathBES;
	CString m_pathTSC;
	bool m_bTopicIsValid;
	bool m_bTopicIsRead;

private:
	CTopic();	// do not instantiate
public:
	CTopic( LPCTSTR pathDSC 
		   ,LPCTSTR pathHTI 
		   ,LPCTSTR pathBES
		   ,LPCTSTR pathTSC );
	virtual ~CTopic();

	// redefined inherited methods
	bool IsRead();
	bool Read();

	// newly introduced methods
	bool HasBES();
	void GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw);
	void CreatePage(	const CHTMLFragments& fragments, 
						CString& out, 
						const map<CString,CString> & mapStrs,
						CString strHTTPcookies= _T("") );
	// JSM V3.2
	void ExtractNetProps(vector<CString> &arr_props);

	bool HasHistoryTable();
};

#endif // !defined(AFX_TOPIC_H__278584FE_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\topicshop.cpp ===
//
// MODULE: TOPICSHOP.CPP
//
// PURPOSE: Provide a means of "publishing" troubleshooter topics.  This is where a 
//	working thread goes to obtain a CTopic to use.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-10-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-10-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include <algorithm>
#include "TopicShop.h"
#include "event.h"
#include "apiwraps.h"
#include "CharConv.h"
#include "bn.h"
#include "propnames.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

//////////////////////////////////////////////////////////////////////
// CTopicInCatalog
//////////////////////////////////////////////////////////////////////

CTopicInCatalog::CTopicInCatalog(const CTopicInfo & topicinfo) :
	m_topicinfo(topicinfo),
	m_bTopicInfoMayNotBeCurrent(false),
	m_bInited(false),
	m_countLoad(CCounterLocation::eIdTopicLoad, topicinfo.GetNetworkName()),
	m_countLoadOK(CCounterLocation::eIdTopicLoadOK, topicinfo.GetNetworkName()),
	m_countEvent(CCounterLocation::eIdTopicEvent, topicinfo.GetNetworkName()),
	m_countHit(CCounterLocation::eIdTopicHit, topicinfo.GetNetworkName()),
	m_countHitNewCookie(CCounterLocation::eIdTopicHitNewCookie, topicinfo.GetNetworkName()),
	m_countHitOldCookie(CCounterLocation::eIdTopicHitOldCookie, topicinfo.GetNetworkName())
{ 

	::InitializeCriticalSection( &m_csTopicinfo);
	m_hev = ::CreateEvent( 
		NULL, 
		TRUE,  // any number of (working) threads may be released on signal
		FALSE, // initially non-signalled
		NULL);
	if (! m_hev)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_EVENT );

		// Simulate a bad alloc exception in this case.
		// This exception will be caught by the caller if the new call has been
		// properly wrapped in a try...catch() block.  Only known caller is 
		// CTopicShop::AddTopic() which handles this properly.
		throw bad_alloc();
	}

	m_countEvent.Increment();
}

CTopicInCatalog::~CTopicInCatalog()
{ 
	if (m_hev)
		::CloseHandle(m_hev);
	::DeleteCriticalSection( &m_csTopicinfo);
}

CTopicInfo CTopicInCatalog::GetTopicInfo() const
{
	
	::EnterCriticalSection(&m_csTopicinfo);
	CTopicInfo ret(m_topicinfo);
	::LeaveCriticalSection(&m_csTopicinfo);
	return ret;
}

void CTopicInCatalog::SetTopicInfo(const CTopicInfo &topicinfo)
{
	::EnterCriticalSection(&m_csTopicinfo);
	m_topicinfo = topicinfo;
	m_bTopicInfoMayNotBeCurrent = true;
	::LeaveCriticalSection(&m_csTopicinfo);
}


// Just let this object know to increment the hit count
void CTopicInCatalog::CountHit(bool bNewCookie)
{
	m_countHit.Increment();
	if (bNewCookie)
		m_countHitNewCookie.Increment();
	else
		m_countHitOldCookie.Increment();
}

// Obtain a CP_TOPIC as a pointer to the topic, if that topic is already built. 
// As long as a CP_TOPIC remains undeleted, the associated CTopic is guaranteed to 
//	remain undeleted.
// Warning: this function will return with a null topic if topic is not yet built.
//	Must test for null with CP_TOPIC::IsNull().  Can't test a smart pointer for null
//	with ==.
CP_TOPIC & CTopicInCatalog::GetTopicNoWait(CP_TOPIC &cpTopic) const
{
	cpTopic = m_cpTopic;
	return cpTopic;
}

// Obtain a CP_TOPIC as a pointer to the topic.  
// Wait as necessary for that topic to be built. 
// Warning: this function will return with a null topic if topic cannot be built.
// As long as a CP_TOPIC remains undeleted, the associated CTopic is guaranteed to 
//	remain undeleted.
// Warning: this function may have to wait for TopicInCatalog.m_cpTopic to be built.
CP_TOPIC & CTopicInCatalog::GetTopic(CP_TOPIC &cpTopic) const
{
	if (!m_bInited)
	{
		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hev ); 
	}
	return GetTopicNoWait(cpTopic);
}

// to be called by the TopicBuilderTask thread
void CTopicInCatalog::Init(const CTopic* pTopic)
{
	m_countLoad.Increment();
	if(pTopic)
	{
		m_cpTopic = pTopic;
		m_countLoadOK.Increment();
	}
	if(pTopic || m_cpTopic.IsNull())
		m_bInited = true;

	::SetEvent(m_hev);
}

// Just let this object know to increment the count of changes detected.
void CTopicInCatalog::CountChange()
{
	m_countEvent.Increment();
}

CTopicInCatalog::TopicStatus CTopicInCatalog::GetTopicStatus() const
{
	if (!m_bInited)
		return eNotInited;
	else if(m_cpTopic.IsNull())
		return eFail;
	else
		return eOK;
}

bool CTopicInCatalog::GetTopicInfoMayNotBeCurrent() const
{
	::EnterCriticalSection(&m_csTopicinfo);
	bool bRet= m_bTopicInfoMayNotBeCurrent;
	::LeaveCriticalSection(&m_csTopicinfo);
	return bRet;
}

void CTopicInCatalog::TopicInfoIsCurrent()
{
	::EnterCriticalSection(&m_csTopicinfo);
	m_bTopicInfoMayNotBeCurrent = false;
	::LeaveCriticalSection(&m_csTopicinfo);
}


//////////////////////////////////////////////////////////////////////
// CTemplateInCatalog
//////////////////////////////////////////////////////////////////////

CTemplateInCatalog::CTemplateInCatalog( const CString & strTemplate ) :
	m_strTemplate( strTemplate ),
	m_countLoad(CCounterLocation::eIdTopicLoad, strTemplate),
	m_countLoadOK(CCounterLocation::eIdTopicLoadOK, strTemplate),
	m_countEvent(CCounterLocation::eIdTopicEvent, strTemplate),
	m_countHit(CCounterLocation::eIdTopicHit, strTemplate),
	m_bInited( false )
{ 
	m_hev = ::CreateEvent( 
		NULL, 
		TRUE,  // any number of (working) threads may be released on signal
		FALSE, // initially non-signalled
		NULL);
	if (! m_hev)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_EVENT );

		// Simulate a bad alloc exception in this case.
		// This exception will be caught by the caller if the new call has been
		// properly wrapped in a try...catch() block.  
		throw bad_alloc();
	}

	m_countEvent.Increment();
}

CTemplateInCatalog::~CTemplateInCatalog()
{ 
	if (m_hev)
		::CloseHandle(m_hev);
}

const CString & CTemplateInCatalog::GetTemplateInfo() const
{
	return m_strTemplate;
}

// Just let this object know to increment the hit count
void CTemplateInCatalog::CountHit( bool bNewCookie )
{
	m_countHit.Increment();
}

// Obtain a CP_TEMPLATE as a pointer to the template, if that template is already built. 
// As long as a CP_TEMPLATE remains undeleted, the associated CAPGTSHTIReader is guaranteed to 
//	remain undeleted.
// Warning: this function will return with a null template if template is not yet built.
//	Must test for null with CP_TEMPLATE::IsNull().  Can't test a smart pointer for null
//	with ==.
CP_TEMPLATE & CTemplateInCatalog::GetTemplateNoWait( CP_TEMPLATE &cpTemplate ) const
{
	cpTemplate= m_cpTemplate;
	return cpTemplate;
}

// Obtain a CP_TEMPLATE as a pointer to the template.  
// Wait as necessary for that template to be built. 
// Warning: this function will return with a null template if template cannot be built.
// As long as a CP_TEMPLATE remains undeleted, the associated CAPGTSHTIReader is guaranteed to 
//	remain undeleted.
// Warning: this function may have to wait for TopicInCatalog.m_cpTemplate to be built.
CP_TEMPLATE & CTemplateInCatalog::GetTemplate( CP_TEMPLATE &cpTemplate ) const
{
	if (!m_bInited)
	{
		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hev ); 
	}
	return GetTemplateNoWait( cpTemplate );
}

// to be called by the TopicBuilderTask thread
void CTemplateInCatalog::Init( const CAPGTSHTIReader* pTemplate )
{
	m_countLoad.Increment();
	if (pTemplate)
	{
		m_cpTemplate= pTemplate;
		m_countLoadOK.Increment();
	}
	if (pTemplate || m_cpTemplate.IsNull())
		m_bInited = true;

	::SetEvent(m_hev);
}

// Just let this object know to increment the count of changes detected.
void CTemplateInCatalog::CountChange()
{
	m_countEvent.Increment();
}

// Just let this object know to increment the count of failures detected.
void CTemplateInCatalog::CountFailed()
{
	// The load failed so increment the count of attempted loads.
	m_countLoad.Increment();
}

CTemplateInCatalog::TemplateStatus CTemplateInCatalog::GetTemplateStatus() const
{
	if (!m_bInited)
		return eNotInited;
	else if(m_cpTemplate.IsNull())
		return eFail;
	else
		return eOK;
}

DWORD CTemplateInCatalog::CountOfFailedLoads() const
{
	return( m_countLoad.GetTotal() - m_countLoadOK.GetTotal() );
}


/////////////////////////////////////////////////////////////////////
// CTopicShop::CTopicBuildQueue
// This class does the bulk of its work on a separate thread.
// The thread is created in the constructor by starting static function
//	CTopicShop::CTopicBuildQueue::TopicBuilderTask.
// That function, in turn does its work by calling private members of this class that
//	are specific to use on the TopicBuilderTask thread.
// When this goes out of scope, its own destructor calls ShutDown to stop the thread,
//	waits for the thread to shut.
// The following method is available for other threads communicating with that thread:
//	CTopicShop::CTopicBuildQueue::RequestBuild
//////////////////////////////////////////////////////////////////////
CTopicShop::CTopicBuildQueue::CTopicBuildQueue(	CTopicCatalog & TopicCatalog, 
												CTemplateCatalog & TemplateCatalog) 
:	m_TopicCatalog (TopicCatalog),
	m_TemplateCatalog( TemplateCatalog ),
	m_eCurrentlyBuilding(eUnknown),
	m_bShuttingDown (false),
	m_dwErr(0),
	m_ThreadStatus(eBeforeInit),
	m_time(0)
{
	enum {eHevBuildReq, eHevShut, eThread, eOK} Progress = eHevBuildReq;

	SetThreadStatus(eBeforeInit);

	m_hevBuildRequested = ::CreateEvent( 
		NULL, 
		FALSE, // release one thread (the TopicBuilderTask) on signal
		FALSE, // initially non-signalled
		NULL);

	if (m_hevBuildRequested)
	{
		Progress = eHevShut;
		m_hevThreadIsShut = ::CreateEvent( 
			NULL, 
			FALSE, // release one thread (this one) on signal
			FALSE, // initially non-signalled
			NULL);

		if (m_hevThreadIsShut)
		{
			Progress = eThread;
			DWORD dwThreadID;	// No need to hold onto dwThreadID in member variable.
								// All Win32 functions take the handle m_hThread instead.
								// The one reason you'd ever want to know this ID is for 
								//	debugging

			// Note that there is no corresponding ::CloseHandle(m_hThread).
			// That is because the thread goes out of existence on the implicit 
			//	::ExitThread() when TopicBuilderTask returns.  See documentation of
			//	::CreateThread for further details JM 10/22/98
			m_hThread = ::CreateThread( NULL, 
										0, 
										(LPTHREAD_START_ROUTINE)TopicBuilderTask, 
										this, 
										0, 
										&dwThreadID);

			if (m_hThread)
				Progress = eOK;
		}
	}

	if (Progress != eOK)
	{
		m_dwErr = GetLastError();
		CString str;
		str.Format(_T("%d"), m_dwErr);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								(Progress == eHevBuildReq) ?_T("Can't create \"request build\" event")
								: (Progress == eHevShut) ?	_T("Can't create \"shut\" event")
								:							_T("Can't create thread"),
								str, 
								EV_GTS_ERROR_TOPICBUILDERTHREAD );
		SetThreadStatus(eFail);

		if (m_hevBuildRequested)
			::CloseHandle(m_hevBuildRequested);

		if (m_hevThreadIsShut)
			::CloseHandle(m_hevThreadIsShut);
	}
}

CTopicShop::CTopicBuildQueue::~CTopicBuildQueue()
{
	ShutDown();

	if (m_hevBuildRequested)
		::CloseHandle(m_hevBuildRequested);

	if (m_hevThreadIsShut)
		::CloseHandle(m_hevThreadIsShut);
}

void CTopicShop::CTopicBuildQueue::SetThreadStatus(ThreadStatus ts)
{
	LOCKOBJECT();
	m_ThreadStatus = ts;
	time(&m_time);
	UNLOCKOBJECT();
}

DWORD CTopicShop::CTopicBuildQueue::GetStatus(ThreadStatus &ts, DWORD & seconds) const
{
	time_t timeNow;
	LOCKOBJECT();
	ts = m_ThreadStatus;
	time(&timeNow);
	seconds = timeNow - m_time;
	UNLOCKOBJECT();
	return m_dwErr;
}

// report status of topics in m_TopicCatalog
// OUTPUT Total: number of topics
// OUTPUT NoInit: number of uninitialized topics (never built)
// OUTPUT Fail: number of topics we tried to build, but could never build
// INPUT parrstrFail NULL == don't care to get this output
// OUTPUT *parrstrFail: names of the topics that couldn't be built
void CTopicShop::CTopicBuildQueue::GetTopicsStatus(
	DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const
{
	LOCKOBJECT();
	Total = m_TopicCatalog.size();
	NoInit = 0;
	Fail = 0;
	if (parrstrFail)
		parrstrFail->clear();
	for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
	{
		CTopicInCatalog::TopicStatus status = it->second->GetTopicStatus();
		switch (status)
		{
			case CTopicInCatalog::eNotInited:
				++NoInit;
				break;
			case CTopicInCatalog::eFail:
				++Fail;
				if (parrstrFail)
				{
					try
					{
						parrstrFail->push_back(it->second->GetTopicInfo().GetNetworkName());
					}
					catch (exception& x)
					{
						CString str;
						// Note STL exception in event log.
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												CCharConversion::ConvertACharToString(x.what(), str), 
												_T(""), 
												EV_GTS_STL_EXCEPTION ); 
					}
				}
				break;
			default:
				break;
		}

	}
	UNLOCKOBJECT();
}

// report status of template in m_TemplateCatalog
// INPUT parrstrFail NULL == don't care to get this output
// OUTPUT *parrstrFail: names of the topics that couldn't be built
// INPUT parrcntFail NULL == don't care to get this output
// OUTPUT *parrcntFail: count of failures of the topics that couldn't be built.
//						one to one correspondence with parrstrFail.
void CTopicShop::CTopicBuildQueue::GetTemplatesStatus(
	vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const
{
	LOCKOBJECT();
	if (parrstrFail)
		parrstrFail->clear();
	if (parrcntFail)
		parrcntFail->clear();

	for (CTemplateCatalog::const_iterator it = m_TemplateCatalog.begin(); it != m_TemplateCatalog.end(); ++it)
	{
		if (it->second->GetTemplateStatus() == CTemplateInCatalog::eFail)
		{
			if (parrstrFail)
			{
				// Currently we only care about failures and their related count.
				try
				{
					parrstrFail->push_back(it->second->GetTemplateInfo());
					if (parrcntFail)
						parrcntFail->push_back( it->second->CountOfFailedLoads() );
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
	}
	UNLOCKOBJECT();
}


// For use by this class and derived classes destructors.
void CTopicShop::CTopicBuildQueue::ShutDown()
{
	LOCKOBJECT();
	if (m_bShuttingDown)
	{
		// We have already shut down the topic builder thread, simply exit.
		UNLOCKOBJECT();
		return;
	}

	m_bShuttingDown = true;
	if (m_hThread)
	{
		DWORD RetVal;

		::SetEvent(m_hevBuildRequested);
		UNLOCKOBJECT();

		// Wait for a set period, if failure then log error msg and wait infinite.
		RetVal= WAIT_INFINITE(	m_hevThreadIsShut );
	}
	else 
		UNLOCKOBJECT();
}

// For general use (not part of TopicBuilderTask thread) code.
// Ask for a topic to be built (or rebuilt).  
// INPUT strTopic - name of topic OR HTI TEMPLATE
// INPUT bPriority -  If bPriority is true, move it ahead of any topics/templates 
//	for which this has not been called with bPriority true.  At a gien priority level,
//	toics always come before templates.
// INPUT eCat - indicates whether strTopic is a topic or an HTI template
// This is an asynchronous request that will eventually be fulfilled by TopicBuilderTask thread
void CTopicShop::CTopicBuildQueue::RequestBuild(const CString &strTopic, bool bPriority,
												CatalogCategory eCat )
{
	// Verify that this is a valid category.
	if (eCat != eTopic && eCat != eTemplate)
		return;

	// Make a lower-case version of the topic name.
	CString strTopicLC = strTopic;
	strTopicLC.MakeLower();

	vector<CString> & Priority = (eCat == eTopic) ? 
										m_PriorityBuild : 
										m_PriorityBuildTemplates;
	vector<CString> & NonPriority = (eCat == eTopic) ? 
										m_NonPriorityBuild :
										m_NonPriorityBuildTemplates;

	LOCKOBJECT();

	if ((strTopicLC != m_CurrentlyBuilding) || (eCat != m_eCurrentlyBuilding))
	{
		vector<CString>::iterator it = find(Priority.begin(), Priority.end(), strTopicLC);
		if (it == Priority.end())
		{
			try
			{
				it = find(NonPriority.begin(), NonPriority.end(), strTopicLC);
				if (bPriority)
				{
					if (it != NonPriority.end())
					{
						// it's in the non-priority list.  Get it out of there.
						NonPriority.erase(it);
					}
					// Add it to the priority list
					Priority.push_back(strTopicLC);
				}
				else if (it == NonPriority.end())
				{
					// Add it to the non-priority list
					NonPriority.push_back(strTopicLC);
				}
				// else it's already listed
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str), 
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}
		// else it's already a priority, we can't do more
	}
	// else it's already building, we can't do more
	::SetEvent(m_hevBuildRequested);
	UNLOCKOBJECT();
}

// For use by the TopicBuilderTask thread.  Should only be called when nothing is 
//	currently building.  Caller is responsible to build only one at a time.
// OUTPUT strTopic - name of topic OR HTI TEMPLATE
// OUTPUT eCat - indicates whether strTopic is a topic or an HTI template
// false return indicates invalid request.  
//		non-empty string output strTopic indicates what is currently building
//		empty string output should never happen
// true return indicates valid request:  
//		non-empty string output strTopic indicates what to build
//		empty string output strTopic indicates nothing more to build
// Note that this function has the side effect of changing the _thread_ priority.
bool CTopicShop::CTopicBuildQueue::GetNextToBuild( CString &strTopic, CatalogCategory &eCat )
{
	vector<CString>::iterator it;

	LOCKOBJECT();
	bool bOK = m_CurrentlyBuilding.IsEmpty();
	if (bOK)
	{
		if (!m_PriorityBuild.empty())
		{
			// We have priority topics to build.
			it = m_PriorityBuild.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTopic;
			m_PriorityBuild.erase(it);

			// If there are more priority builds waiting behind this, boost priority
			//	above normal so we get to them ASAP.  Otherwise, normal priority.
			::SetThreadPriority(GetCurrentThread(),
				m_PriorityBuild.empty() ? THREAD_PRIORITY_NORMAL : THREAD_PRIORITY_ABOVE_NORMAL);
		}
		else if (!m_PriorityBuildTemplates.empty())
		{
			// We have priority alternate templates to build.
			it = m_PriorityBuildTemplates.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTemplate;
			m_PriorityBuildTemplates.erase(it);

			// If there are more priority builds waiting behind this, boost priority
			//	above normal so we get to them ASAP.  Otherwise, normal priority.
			::SetThreadPriority(GetCurrentThread(),
				m_PriorityBuildTemplates.empty() ? THREAD_PRIORITY_NORMAL : THREAD_PRIORITY_ABOVE_NORMAL);
		}
		else if (!m_NonPriorityBuild.empty())
		{
			// We have non-priority topics to build.
			it = m_NonPriorityBuild.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTopic;
			m_NonPriorityBuild.erase(it);

			// This is initialization, no one is in a hurry for it, 
			//	let's not burden the system unduly.
			::SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL);
		}
		else if (!m_NonPriorityBuildTemplates.empty())
		{
			// We have non-priority alternate templates to build.
			it = m_NonPriorityBuildTemplates.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTemplate;
			m_NonPriorityBuildTemplates.erase(it);

			// This is initialization, no one is in a hurry for it, 
			//	let's not burden the system unduly.
			::SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL);
		}
		else 
			::SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);
	}
	strTopic = m_CurrentlyBuilding;
	eCat= m_eCurrentlyBuilding;
	UNLOCKOBJECT();
	return bOK;
}

// Acknowledge that we have finished building the topic previously obtained with GetNextToBuild
// This should be called before GetNextToBuild is called again.
void CTopicShop::CTopicBuildQueue::BuildComplete()
{
	LOCKOBJECT();
	m_CurrentlyBuilding = _T("");
	m_eCurrentlyBuilding= eUnknown;
	UNLOCKOBJECT();
}

// For use by the TopicBuilderTask thread.
// Must be called on TopicBuilderTask thread.  Handles all work of building & publishing 
//	topics driven by the queue contents
void CTopicShop::CTopicBuildQueue::Build()
{
	CString strTopic;
	CatalogCategory eCat;

	while (true)
	{
		LOCKOBJECT();
		SetThreadStatus(eRun);
		if (m_bShuttingDown)
		{
			UNLOCKOBJECT();
			break;
		}
		GetNextToBuild( strTopic, eCat );
		if (strTopic.IsEmpty())
		{
			::ResetEvent(m_hevBuildRequested);
			UNLOCKOBJECT();
			SetThreadStatus(eWait);
			::WaitForSingleObject(m_hevBuildRequested, INFINITE);
			continue;
		}
		else 
			UNLOCKOBJECT();

		if (eCat == eTopic)
		{
			// at this point we have a topic name.  Get access to topic info.
			CTopicCatalog::const_iterator it = m_TopicCatalog.find(strTopic);
			if (it == m_TopicCatalog.end())
			{
				// Asked to initialize a topic that	doesn't have a catalog entry.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T("Asked to build"), 
										strTopic, 
										EV_GTS_UNRECOGNIZED_TOPIC ); 
			}
			else
			{
				CTopicInCatalog & TopicInCatalog = *(it->second);
				const CTopicInfo topicinfo (TopicInCatalog.GetTopicInfo());

				try
				{
					// must create this with new so we can manage it under a reference count regime
					CTopic *ptopic = new CTopic (topicinfo.GetDscFilePath()
												,topicinfo.GetHtiFilePath()
												,topicinfo.GetBesFilePath()
												,topicinfo.GetTscFilePath() );
					if (ptopic->Read())
						TopicInCatalog.Init(ptopic);
					else
					{
						// Release memory.
						delete ptopic;
						TopicInCatalog.Init(NULL);
					}

					TopicInCatalog.TopicInfoIsCurrent();
				}
				catch (bad_alloc&)
				{
					// Note memory failure in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
				}
			}
		}
		else if (eCat == eTemplate)
		{
			// Determine whether the passed in template is in the catalog.
			CTemplateCatalog::const_iterator it = m_TemplateCatalog.find(strTopic);
			if (it == m_TemplateCatalog.end())
			{
				// Asked to initialize a template that doesn't have a catalog entry.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T("Asked to build"), 
										strTopic, 
										EV_GTS_UNRECOGNIZED_TEMPLATE ); 
			}
			else
			{
				CTemplateInCatalog & TemplateInCatalog = *(it->second);
				const CString & strTemplateName = TemplateInCatalog.GetTemplateInfo();

				try
				{
					// must create this with new so we can manage it under a reference count regime
					CAPGTSHTIReader *pTemplate;

					pTemplate= new CAPGTSHTIReader( CPhysicalFileReader::makeReader( strTemplateName ) );
					if (pTemplate->Read())
						TemplateInCatalog.Init( pTemplate );
					else
					{
						// Release memory.
						delete pTemplate;
						TemplateInCatalog.Init( NULL );
					}
				}
				catch (bad_alloc&)
				{
					// Note memory failure in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
				}
			}
		}
		BuildComplete();
	}
	SetThreadStatus(eExiting);
}

// For use by the TopicBuilderTask thread.
void CTopicShop::CTopicBuildQueue::AckShutDown()
{
	LOCKOBJECT();
	::SetEvent(m_hevThreadIsShut);
	UNLOCKOBJECT();
}

//  Main routine of a thread responsible for building and publishing CTopic objects.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CTopicShop::CTopicBuildQueue::TopicBuilderTask(LPVOID lpParams)
{
	reinterpret_cast<CTopicBuildQueue*>(lpParams)->Build();
	reinterpret_cast<CTopicBuildQueue*>(lpParams)->AckShutDown();
	return 0;
}

//////////////////////////////////////////////////////////////////////
// CTopicShop::ThreadStatus
//////////////////////////////////////////////////////////////////////
/* static */ CString CTopicShop::ThreadStatusText(ThreadStatus ts)
{
	switch(ts)
	{
		case eBeforeInit:	return _T("Before Init");
		case eFail:			return _T("Fail");
		case eWait:			return _T("Wait");
		case eRun:			return _T("Run");
		case eExiting:		return _T("Exiting");
		default:			return _T("");
	}
}

//////////////////////////////////////////////////////////////////////
// CTopicShop
// The only functions which need to lock this class are those which modify TopicCatalog.
// TopicBuildQueue has its own protection.
//////////////////////////////////////////////////////////////////////

CTopicShop::CTopicShop() :
	m_TopicBuildQueue( m_TopicCatalog, m_TemplateCatalog ),
	m_hevShopIsOpen(NULL)
{
	m_hevShopIsOpen = ::CreateEvent( 
			NULL, 
			TRUE,  // any number of (working) threads may be released on signal
			FALSE, // initially non-signalled
			NULL);

	if (! m_hevShopIsOpen)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_EVENT );
		
		// Simulate a bad alloc exception in this case.
		// This constructor is only called within the ctor of CDBLoadConfiguration
		// and the allocation of that object is wrapped within a try...catch() block.
		throw bad_alloc();
	}
}

CTopicShop::~CTopicShop()
{
	// Terminate the topic builder thread prior to cleaning up the topics.
	m_TopicBuildQueue.ShutDown();

	if (m_hevShopIsOpen)
		::CloseHandle(m_hevShopIsOpen);

	// Clean up the topics.
	for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
	{
		delete it->second;
	}

	// Clean up the templates.
	for (CTemplateCatalog::const_iterator itu = m_TemplateCatalog.begin(); itu != m_TemplateCatalog.end(); ++itu)
	{
		delete itu->second;
	}
}

// Add a topic to the catalog.  It must eventually be built by TopicBuilderTask thread.
// If topic is already in list identically, no effect.
void CTopicShop::AddTopic(const CTopicInfo & topicinfo)
{
	// our keys into the catalog should be all lower case.  This code is fine, because
	// CTopicInfo::GetNetworkName() is guaranteed to return lower case.
	CString strNetworkName = topicinfo.GetNetworkName();

	LOCKOBJECT();
	CTopicCatalog::const_iterator it = m_TopicCatalog.find(strNetworkName);

	if (it == m_TopicCatalog.end())
	{
		try
		{
			m_TopicCatalog[strNetworkName] = new CTopicInCatalog(topicinfo);
		}
		catch (bad_alloc&)
		{
			// Note memory failure in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		}
	}
	else if (! (topicinfo == it->second->GetTopicInfo()))
	{
		it->second->SetTopicInfo(topicinfo);
		m_TopicBuildQueue.RequestBuild(strNetworkName, false, CTopicBuildQueue::eTopic);

	}
	UNLOCKOBJECT();
}

// Add a template to the catalog.  It must eventually be built by TopicBuilderTask thread.
// If template is already in list, no effect.
void CTopicShop::AddTemplate( const CString & strTemplateName )
{
	LOCKOBJECT();
	if (m_TemplateCatalog.find( strTemplateName ) == m_TemplateCatalog.end())
	{
		try
		{
			m_TemplateCatalog[ strTemplateName ] = new CTemplateInCatalog( strTemplateName );
		}
		catch (bad_alloc&)
		{
			// Note memory failure in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		}
	}
	UNLOCKOBJECT();
}

// if shop is not already open, open it.
void CTopicShop::OpenShop()
{
	::SetEvent(m_hevShopIsOpen);
}


// Request that a topic be built (or rebuilt)
// Typically called in response to either the system detecting a change to the topic 
//	files or from an operator saying "act as if a change has been detected".
// INPUT strTopic names the topic to build.
// if pbAlreadyInCatalog is input non-null, then *pbAlreadyInCatalog returns whether
//	the topic was already known to the system.
void CTopicShop::BuildTopic(const CString & strTopic, bool *pbAlreadyInCatalog /*= NULL*/)
{
	if (pbAlreadyInCatalog)
		*pbAlreadyInCatalog = false;	// initialize

	CTopicInCatalog * pTopic = GetCatalogEntryPtr(strTopic);
	if (pTopic)
	{
		pTopic->CountChange();
		if (pbAlreadyInCatalog)
			*pbAlreadyInCatalog = true;
	}
	m_TopicBuildQueue.RequestBuild( strTopic, false, CTopicBuildQueue::eTopic );
}

// Request that a template be built (or rebuilt)
// Typically called in response to the system detecting a change to the template files.
void CTopicShop::BuildTemplate( const CString & strTemplate )
{
	CTemplateInCatalog * pTemplate = GetTemplateCatalogEntryPtr( strTemplate );
	if (pTemplate)
		pTemplate->CountChange();
	m_TopicBuildQueue.RequestBuild( strTemplate, false, CTopicBuildQueue::eTemplate );
}


CTopicInCatalog * CTopicShop::GetCatalogEntryPtr(const CString & strTopic) const
{
	// Wait for a set period, if failure then log error msg and wait infinite.
	WAIT_INFINITE( m_hevShopIsOpen );
	CTopicCatalog::const_iterator it= m_TopicCatalog.find(strTopic);
	if (it == m_TopicCatalog.end())
		return NULL;
	else
		return it->second;
}

CTemplateInCatalog * CTopicShop::GetTemplateCatalogEntryPtr(const CString & strTemplate ) const
{
	// Wait for a set period, if failure then log error msg and wait infinite.
	WAIT_INFINITE( m_hevShopIsOpen );
	CTemplateCatalog::const_iterator it= m_TemplateCatalog.find( strTemplate );
	if (it == m_TemplateCatalog.end())
		return NULL;
	else
		return it->second;
}


// Call this function to obtain a CP_TOPIC as a pointer to the topic (identified by 
//	strTopic) that you want to operate on.  As long as the CP_TOPIC remains undeleted, 
//	the associated CTopic is guaranteed to remain undeleted.
// this function must not lock CTopicShop, because it can wait a long time.
CP_TOPIC & CTopicShop::GetTopic(const CString & strTopic, CP_TOPIC &cpTopic, bool bNewCookie)
{
	CTopicInCatalog *pTopicInCatalog = GetCatalogEntryPtr(strTopic);
	if (! pTopicInCatalog)
		cpTopic = NULL;
	else
	{
		pTopicInCatalog->CountHit(bNewCookie);
		pTopicInCatalog->GetTopicNoWait(cpTopic);
		if (cpTopic.IsNull())
		{
			m_TopicBuildQueue.RequestBuild( strTopic, true, CTopicBuildQueue::eTopic );
			pTopicInCatalog->GetTopic(cpTopic);
		}
	}

	return cpTopic;
}

// Call this function to obtain a CP_TEMPLATE as a pointer to the template (identified by 
//	strTemplate) that you want to operate on.  As long as the CP_TEMPLATE remains undeleted, 
//	the associated CAPGTSHTIReader is guaranteed to remain undeleted.
// this function must not lock CTopicShop, because it can wait a long time.
CP_TEMPLATE & CTopicShop::GetTemplate(const CString & strTemplate, CP_TEMPLATE &cpTemplate, bool bNewCookie)
{
	CTemplateInCatalog *pTemplateInCatalog = GetTemplateCatalogEntryPtr(strTemplate);
	if (! pTemplateInCatalog)
		cpTemplate = NULL;
	else
	{
		pTemplateInCatalog->CountHit(bNewCookie);
		pTemplateInCatalog->GetTemplateNoWait( cpTemplate );
		if (cpTemplate.IsNull())
		{
			m_TopicBuildQueue.RequestBuild( strTemplate, true, CTopicBuildQueue::eTemplate );
			pTemplateInCatalog->GetTemplate( cpTemplate );
		}
	}

	return cpTemplate;
}


void CTopicShop::GetListOfTopicNames(vector<CString>&arrstrTopic) const
{
	arrstrTopic.clear();

	LOCKOBJECT();

	try
	{
		for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
		{
			arrstrTopic.push_back(it->second->GetTopicInfo().GetNetworkName());
		}	
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	UNLOCKOBJECT();
}

// Rebuild all topics from source files
void CTopicShop::RebuildAll()
{
	
	LOCKOBJECT();
	for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
	{
		BuildTopic(it->second->GetTopicInfo().GetNetworkName());
	}	
	for (CTemplateCatalog::const_iterator itu = m_TemplateCatalog.begin(); itu != m_TemplateCatalog.end(); ++itu)
	{
		BuildTemplate( itu->first );
	}	
	UNLOCKOBJECT();
}

// Get status information on the topic builder thread
DWORD CTopicShop::GetThreadStatus(ThreadStatus &ts, DWORD & seconds) const
{
	return m_TopicBuildQueue.GetStatus(ts, seconds);
}

// see CTopicShop::CTopicBuildQueue::GetTopicsStatus for documentation.
void CTopicShop::GetTopicsStatus(
	DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const
{
	m_TopicBuildQueue.GetTopicsStatus(Total, NoInit, Fail, parrstrFail);
}

// see CTopicShop::CTopicBuildQueue::GetTemplatesStatus for documentation.
void CTopicShop::GetTemplatesStatus( vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const
{
	m_TopicBuildQueue.GetTemplatesStatus( parrstrFail, parrcntFail);
}

CTopicInCatalog* CTopicShop::GetCatalogEntry(const CString& strTopic) const
{
	CTopicInCatalog* ret = NULL;
	LOCKOBJECT();
	CTopicCatalog::const_iterator it = m_TopicCatalog.find(strTopic);
	if (it != m_TopicCatalog.end())
		ret = it->second;
	UNLOCKOBJECT();
	return ret;
}

bool CTopicShop::RetTemplateInCatalogStatus( const CString& strTemplate, bool& bValid ) const
{
	bool bIsPresent= false;

	bValid= false;
	LOCKOBJECT();
	CTemplateCatalog::const_iterator it = m_TemplateCatalog.find( strTemplate );
	if (it != m_TemplateCatalog.end())
	{
		CTemplateInCatalog* pTmp;

		bIsPresent= true;
		pTmp= it->second;
		switch (pTmp->GetTemplateStatus()) 
		{
			case CTemplateInCatalog::eOK:
					bValid= true;
					break;
			case CTemplateInCatalog::eFail:
					// Template has failed to load so we will not try to reload it,
					// but we need to increment the attempted load counter.
					pTmp->CountFailed();
					break;
			default: ;
		}
	}
	UNLOCKOBJECT();
	return( bIsPresent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\tshoot.cpp ===
//
// MODULE: TSHOOT.cpp
//
// PURPOSE: Implementation of DLL Exports
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12.23.98
//
// NOTES: 
//	Proxy/Stub Information
//	To build a separate proxy/stub DLL, 
//	run nmake -f TSHOOTps.mk in the project directory.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		12/23/98	OK	    

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TSHOOT.h"

#include "TSHOOT_i.c"
#include "TSHOOTCtrl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TSHOOTCtrl, CTSHOOTCtrl)
END_OBJECT_MAP()

HANDLE ghModule = INVALID_HANDLE_VALUE;
//
//
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (INVALID_HANDLE_VALUE == ghModule)
		ghModule = hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TSHOOTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\threadpool.h ===
//
// MODULE: ThreadPool.h
//
// PURPOSE: interface for classes for high level of pool thread activity
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel, based on earlier (8-2-96) work by Roman Mach
// 
// ORIGINAL DATE: 9/23/98
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/23/98		JM		better encapsulation & some chages to algorithm
//

#if !defined(AFX_THREADPOOL_H__0F43119D_5247_11D2_95FC_00C04FC22ADD__INCLUDED_)
#define AFX_THREADPOOL_H__0F43119D_5247_11D2_95FC_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <time.h>
#include "stateless.h"

class CPoolQueue;	// forward reference
class APGTSContext;	// forward reference

// Status class for pool threads, used by both the thread pool in order to handle stuck threads
// as well as by the status page for reporting on thread status.  If time permits, we should 
// convert the member variable to private and add get-set methods in order to be consistent with
// the rest of the code. 
class CPoolThreadStatus
{
public:
	time_t m_timeCreated;	// time CThreadPool::CThreadControl object was constructed
							//	If this CPoolThreadStatusobject is the return of a thread 
							//	status request, 0 here implies there is no such
							//	CThreadPool::CThreadControl object
	DWORD m_seconds;		// time elapsed since last started or finished a request.
							// That is, how long this thread has been working on a task 
							//	(or how long since it finished its last task)
							//	If task was never started - this is time since m_timeCreated
	bool m_bWorking;		// true = currently working on a request.
	bool m_bFailed;			// true = encountered a majorly unexpected situation &
							//	chose to exit.
	CString m_strTopic;		// current topic we are working on,
							//  It is not initialized in the constructor so it can be zero length
							//  Is used to transport the current topic name back to the status page.
	CString m_strBrowser;	// Current client browser.  Used to transport the browser name back to
							//	the status page.
	CString m_strClientIP;	// Current Client IP address.  Used to transport the client IP address
							//	back to the status page.

	CPoolThreadStatus() : 
		m_timeCreated(0), m_seconds(0), m_bWorking(false), m_bFailed(false) 
		{};
	bool operator <  (const CPoolThreadStatus&) const {return false;}
	bool operator == (const CPoolThreadStatus&) const {return false;}
};


class CSniffConnector;

class CThreadPool
{
	friend class CDBLoadConfiguration;
private:
	class CThreadControl
	{
	private:
		HANDLE m_hThread;		// thread handle
		HANDLE m_hevDone;		// Thread uses this event only to say, effectively, 
								//	"outta here" as it dies.
		HANDLE m_hMutex;		// protect access to m_time, m_bWorking.
		bool m_bExit;			// set true when either a normal queued-up task or an explicit 
								//	"kill" wants the thread to break out of its loop.
		CPoolQueue *m_pPoolQueue;	// point to the one and only instance of CPoolQueue
		time_t m_timeCreated;	// time this object was constructed
		time_t m_time;			// time last started or finished a request; init'd 0, but will
								//	be non-zero if thread ever used.
		bool m_bWorking;		// true = currently working on a request.
		bool m_bFailed;			// true = encountered a majorly unexpected situation &
								//	chose to exit.
		CNameStateless m_strBrowser;	// Current client browser.  
		CNameStateless m_strClientIP;	// Current Client IP address. 
		APGTSContext *m_pContext;	// pointer to context of a request.
		CSniffConnector *m_pSniffConnector; // pointer to sniff connector base class,
											//  the only purpose of storing this pointer
											//  as member variable is to pass it to 
											//  constructor of APGTSContext
	public:
		CThreadControl(CSniffConnector*);
		~CThreadControl();

		// This function may throw an exceptions of type CGeneralException.
		DWORD Initialize(CPoolQueue * pPoolQueue);

		void Kill(DWORD milliseconds);
		bool WaitForThreadToFinish(DWORD milliseconds);
		void WorkingStatus(CPoolThreadStatus & status);
		time_t GetTimeCreated() const;

	private:
		static UINT WINAPI PoolTask( LPVOID lpParams );
		bool ProcessRequest();
		void PoolTaskLoop();
		void Lock();
		void Unlock();
		bool Exit();
	};

public:
	CThreadPool(CPoolQueue * pPoolQueue, CSniffConnector * pSniffConnector);
	~CThreadPool();
	DWORD GetStatus() const;	// get any error during construction
	DWORD GetWorkingThreadCount() const;
	void ExpandPool(DWORD dwDesiredThreadCount);
	bool ReinitializeThread(DWORD i);
	void ReinitializeStuckThreads();
	bool ThreadStatus(DWORD i, CPoolThreadStatus &status);
private:
	void DestroyThreads();
private:
	DWORD m_dwErr;
	CThreadControl **m_ppThreadCtl;	// thread management
	CSniffConnector *m_pSniffConnector; // pointer to sniff connector base class,
										//  the only purpose of storing this pointer
										//  as member variable is to pass it to 
										//  constructor of CThreadControl
	DWORD m_dwWorkingThreadCount;	// threads actually created
	CPoolQueue *m_pPoolQueue;		// Keeps track of user requests queued up to be serviced 
									//	by working threads (a.k.a. "pool threads")
};

#endif // !defined(AFX_THREADPOOL_H__0F43119D_5247_11D2_95FC_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\threadpool.cpp ===
//
// MODULE: ThreadPool.CPP
//
// PURPOSE: Fully implement classes for high level of pool thread activity
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel, based on earlier (8-2-96) work by Roman Mach
// 
// ORIGINAL DATE: 9/23/98
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/23/98		JM		better encapsulation & some chages to algorithm
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "ThreadPool.h"
#include "event.h"
#include "apgtscls.h"
#include "baseexception.h"
#include "CharConv.h"
#include "apgtsMFC.h"


//////////////////////////////////////////////////////////////////////
// CThreadPool::CThreadControl
// POOL/WORKING THREAD
//////////////////////////////////////////////////////////////////////
CThreadPool::CThreadControl::CThreadControl(CSniffConnector* pSniffConnector) :
	m_hThread (NULL),
	m_hevDone (NULL),
	m_hMutex (NULL),
	m_bExit (false),
	m_pPoolQueue (NULL),
	m_timeCreated(0),
	m_time (0),
	m_bWorking (false),
	m_bFailed (false),
	m_strBrowser( _T("") ),
	m_strClientIP( _T("") ),
	m_pContext( NULL ),
	m_pSniffConnector(pSniffConnector)
{
	time(&m_timeCreated);
}

CThreadPool::CThreadControl::~CThreadControl()
{
	if (m_hThread)
		::CloseHandle(m_hThread);
	if (m_hevDone)  
		::CloseHandle(m_hevDone);
	if (m_hMutex)  
		::CloseHandle(m_hMutex);
}

// create a "pool" thread to handle user requests, one request at a time per thread
// returns error code; 0 if OK
// NOTE:	This function throws exceptions so the caller should be catching exceptions
//			rather than checking return values.
DWORD CThreadPool::CThreadControl::Initialize(CPoolQueue * pPoolQueue)
{
	DWORD dwThreadID;

	CString strErr;
	CString strErrNum;

	m_pPoolQueue = pPoolQueue;

	m_hevDone= NULL;
	m_hMutex= NULL;
	m_hThread= NULL;
	try
	{
		m_hevDone = ::CreateEvent(NULL, true /* manual reset*/, false /* init non-signaled*/, NULL);
		if (!m_hevDone) 
		{
			strErrNum.Format(_T("%d"), ::GetLastError());
			strErr = _T( "Failure creating hevDone(GetLastError=" );
			strErr += strErrNum; 
			strErr += _T( ")" );

			throw CGeneralException(	__FILE__, __LINE__, 
										strErr , 
										EV_GTS_ERROR_THREAD );
		}

		m_hMutex = ::CreateMutex(NULL, false, NULL);
		if (!m_hMutex) 
		{
			strErrNum.Format(_T("%d"), ::GetLastError());
			strErr = _T( "Failure creating hMutex (GetLastError=" );
			strErr += strErrNum; 
			strErr += _T( ")" );

			throw CGeneralException(	__FILE__, __LINE__, 
										strErr , 
										EV_GTS_ERROR_THREAD );
		}

		// create the thread 
		// Note although the destructor has a corresponding ::CloseHandle(m_hThread),
		//	it's probably not needed.  However, it should be harmless: we don't tear down
		//	this object until after the thread has exited.
		// That is because the thread goes out of existence on the implicit 
		//	::ExitThread() when PoolTask returns.  See documentation of
		//	::CreateThread for further details JM 10/22/98
		m_hThread = ::CreateThread( NULL, 
									0, 
									(LPTHREAD_START_ROUTINE)PoolTask, 
									this, 
									0, 
									&dwThreadID);

		if (!m_hThread) 
		{
			strErrNum.Format(_T("%d"), ::GetLastError());
			strErr = _T( "Failure creating hThread (GetLastError=" );
			strErr += strErrNum; 
			strErr += _T( ")" );

			throw CGeneralException(	__FILE__, __LINE__, 
										strErr , 
										EV_GTS_ERROR_THREAD );
		}
	}
	catch (CGeneralException&)
	{
		// Clean up any open handles.
		if (m_hevDone)
		{
			::CloseHandle(m_hevDone);
			m_hevDone = NULL;
		}

		if (m_hMutex)
		{
			::CloseHandle(m_hMutex);
			m_hMutex = NULL;
		}

		// Rethrow the exception.
		throw;
	}

	return 0;
}

void CThreadPool::CThreadControl::Lock()
{
	::WaitForSingleObject(m_hMutex, INFINITE);
}

void CThreadPool::CThreadControl::Unlock()
{
	::ReleaseMutex(m_hMutex);
}

time_t CThreadPool::CThreadControl::GetTimeCreated() const
{
	return m_timeCreated;
}

// OUTPUT status
void CThreadPool::CThreadControl::WorkingStatus(CPoolThreadStatus & status)
{
	Lock();
	status.m_timeCreated = m_timeCreated;
	time_t timeNow;
	status.m_bWorking = m_bWorking;
	status.m_bFailed = m_bFailed;
	time(&timeNow);
	status.m_seconds = timeNow - (m_time ? m_time : m_timeCreated);
	if (m_pContext)
		status.m_strTopic = m_pContext->RetCurrentTopic();
	status.m_strBrowser= m_strBrowser.Get();
	status.m_strClientIP= m_strClientIP.Get();
	Unlock();
}

// This should only be called as a result of an operator request to kill the thread.
// This is not the normal way to stop a thread.
// INPUT milliseconds - how long to wait for normal exit before a TerminateThread
// NOTE: Because this Kill function gets a lock, it is very important that no function
//	ever hold this lock more than briefly.
void CThreadPool::CThreadControl::Kill(DWORD milliseconds)
{
	Lock();
	m_bExit = true;
	Unlock();
	WaitForThreadToFinish(milliseconds);
}

// After a pool task thread has been signaled to finish, this is how main thread waits for it
// to finish.
// returns true if terminates OK.
bool CThreadPool::CThreadControl::WaitForThreadToFinish(DWORD milliseconds)
{
	bool bTermOK = true;
	if (m_hevDone != NULL) 
	{
		DWORD dwStatus = ::WaitForSingleObject(m_hevDone, milliseconds);

		// terminate thread as last resort if it didn't exit properly
		// this may cause memory leak, but shouldn't normally happen
		// then close thread handle
		if (dwStatus != WAIT_OBJECT_0) 
		{
			// We ignore the return of ::TerminateThread(). If we got here at all, there
			//	was a problem witht th thread terminating.  We don't care about distinguishing
			//	how severe a problem.
			::TerminateThread(m_hThread,0);
			bTermOK = false;
		}
	}
	return bTermOK;
}

// To be called on PoolTask thread
// Return true if this initiates shutdown, false otherwise.
// This is what handles healthy HTTP requests (many errors already filtered out before we
//		get here.)
bool CThreadPool::CThreadControl::ProcessRequest()
{
	WORK_QUEUE_ITEM * pwqi;
	bool bShutdown = false;
    
    pwqi = m_pPoolQueue->GetWorkItem();
    
    if ( !pwqi )
	{
		// no task.  We shouldn't have been awakened.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_NO_QUEUE_ITEM ); 
	}

	if (pwqi->pECB != NULL) 
	{

		// a normal user request

		// set privileges, etc. to those of a particular user
		if (pwqi->hImpersonationToken)
			::ImpersonateLoggedOnUser( pwqi->hImpersonationToken );


		try
		{
			CString strBrowser;
			CString strClientIP;

			// Acquire the browser and IP address for status pages.
			APGTS_nmspace::GetServerVariable( pwqi->pECB, "HTTP_USER_AGENT", strBrowser );
			APGTS_nmspace::GetServerVariable( pwqi->pECB, "REMOTE_ADDR", strClientIP );
			m_strBrowser.Set( strBrowser );
			m_strClientIP.Set( strClientIP );
		
			m_pContext = new APGTSContext(	pwqi->pECB, 
											pwqi->pConf,
											pwqi->pLog,
											&pwqi->GTSStat,
											m_pSniffConnector);

			/////////////////////////////////////////////////////////////
			//
			// mando + 09.21.01
			// PREFIX BUG #: 467364
			// PREFIX BUG TITLE: PREFIX:enduser: \nt\enduser\troubleshoot\tshoot\threadpool.cpp: CThreadPool::CThreadControl::ProcessRequest(): dereferencing NULL pointer '(this->m_pContext)'
			//
			/////////////////////////////////////////////////////////////

			if( NULL == m_pContext ) throw bad_alloc();
			/////////////////////////////////////////////////////////////

			m_pContext->ProcessQuery();
			
			// Release the context and set the point to null.
			Lock();
			delete m_pContext;
			m_pContext= NULL;
			Unlock();

			// Clear the browser and IP address as this request is over.
			m_strBrowser.Set( _T("") );
			m_strClientIP.Set( _T("") );
		}
		catch (bad_alloc&)
		{
			// A memory allocation failure occurred during processing of query, log it.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""),	_T(""), EV_GTS_CANT_ALLOC ); 
		}
		catch (...)
		{
			// Catch any other exception thrown.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), 
									EV_GTS_GEN_EXCEPTION );		
		}

		::RevertToSelf();
	
		//	Terminate HTTP request
		pwqi->pECB->ServerSupportFunction(	HSE_REQ_DONE_WITH_SESSION,
											NULL,
											NULL,
											NULL );

		::CloseHandle( pwqi->hImpersonationToken );
	}

	
	if (pwqi->pECB) 
		delete pwqi->pECB;
	else
		// exit thread if null (we're shutting down)
		bShutdown = true;
		
    delete pwqi;
	
	return bShutdown;
}

// To be called on PoolTask thread
bool CThreadPool::CThreadControl::Exit()
{
	Lock();
	bool bExit = m_bExit;
	Unlock();
	return bExit;
}


// To be called on PoolTask thread
//  Main loop of a worker thread.
void CThreadPool::CThreadControl::PoolTaskLoop()
{
    DWORD	res;
	bool	bBad = false;

    while ( !Exit() )
    {
        res = m_pPoolQueue->WaitForWork();

        if ( res == WAIT_OBJECT_0 ) 
		{
			bBad = false;

			Lock();
			m_bWorking = true;
			time(&m_time);
			Unlock();

			bool bExit = ProcessRequest();
			Lock();
			m_bExit = bExit;
			Unlock();
			m_pPoolQueue->DecrementWorkItems();

			Lock();
			m_bWorking = false;
			time(&m_time);
			Unlock();
		}
		else 
		{
			// utterly unexpected event, like a WAIT_FAILED.
			// There's no obvious way to recover from this sort of thing.  Fortunately,
			//	we've never seen it happen.  Obviously we want to log to the event log.
			// Our variable bBad is a way of deciding that if this happens twice
			//	in a row, this thread will just exit and give up totally.  , 
			// If we ever see this in a real live system, it's
			//	time to give this issue some thought.
			CString str;

			str.Format(_T("%d/%d"), res, GetLastError());
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									str,
									_T(""),
									EV_GTS_ERROR_UNEXPECTED_WT ); 

			if (bBad)
			{
				m_bFailed = true;
				break;		// out of while loop & implicitly out of thread.
			}
			else
				bBad = true;
		}
	}

	// signal shutdown code that we are finished
	::SetEvent(m_hevDone);
}

//  Main routine of a worker thread.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CThreadPool::CThreadControl::PoolTask( LPVOID lpParams )
{
	CThreadControl	* pThreadControl;

#ifdef LOCAL_TROUBLESHOOTER
	if (RUNNING_FREE_THREADED())
		::CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (RUNNING_APARTMENT_THREADED())
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif
	
	pThreadControl = (CThreadControl *)lpParams;

	pThreadControl->PoolTaskLoop();

#ifdef LOCAL_TROUBLESHOOTER
	if (RUNNING_FREE_THREADED() || RUNNING_APARTMENT_THREADED())
		::CoUninitialize();
#endif
	return 0;
}

//////////////////////////////////////////////////////////////////////
// CThreadPool
//////////////////////////////////////////////////////////////////////

CThreadPool::CThreadPool(CPoolQueue * pPoolQueue, CSniffConnector* pSniffConnector) :
	m_dwErr(0),
	m_ppThreadCtl(NULL),
	m_dwWorkingThreadCount(0),
	m_pPoolQueue(pPoolQueue),
	m_pSniffConnector(pSniffConnector)
{
}

CThreadPool::~CThreadPool()
{
	DestroyThreads();

	if (m_ppThreadCtl) 
	{
		for ( DWORD i = 0; i < m_dwWorkingThreadCount; i++ ) 
			if (m_ppThreadCtl[i])
				delete m_ppThreadCtl[i];

		delete [] m_ppThreadCtl;
	}
}

// get any error during construction
DWORD CThreadPool::GetStatus() const
{
	return m_dwErr;
}

DWORD CThreadPool::GetWorkingThreadCount() const
{
	return m_dwWorkingThreadCount;
}

//
// Call only from destructor
void CThreadPool::DestroyThreads()
{
	int BadTerm = 0;
	bool bFirst = true;
	DWORD i;

	// APGTSExtension should have already signaled the threads to quit.
	//	>>>(ignore for V3.0) Doing that in APGTSExtension is lousy encapsulation, but 
	//	so far we don't see a clean way to do this.
	// Wait for them all to terminate unless we had a problem.
	// Because this is called from the dll's process detach, we can't
	// signal on thread termination, just when threads have exited their
	// infinite while loops

	if (m_dwWorkingThreadCount && m_ppThreadCtl) 
	{
		// We will wait longer for the first thread: 10 seconds for processing to finish.
		// After that, we clip right along, since this has also been time for all the
		//	other threads to finish.
		for ( i = 0; i < m_dwWorkingThreadCount; i++ )
		{
			if ( m_ppThreadCtl[i] )
			{
				if ( ! m_ppThreadCtl[i]->WaitForThreadToFinish((bFirst) ? 20000 : 100) )
					++BadTerm;

				bFirst = false;
			}
		}

		if (BadTerm != 0) 
		{
			CString str;
			str.Format(_T("%d"), BadTerm);
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									str,
									_T(""),
									EV_GTS_USER_THRD_KILL ); 
		}
	}
}

// create the "pool" threads which handle user requests, one request at a time per thread
// if there are less than dwDesiredThreadCount existing threads, expand the thread pool
//	to that size.
// (We cannot shrink the thread pool while we are running).
void CThreadPool::ExpandPool(DWORD dwDesiredThreadCount)
{
	CString strErr;

	if (dwDesiredThreadCount > m_dwWorkingThreadCount)
	{
		CThreadControl **ppThreadCtl = NULL;
		const DWORD dwOldCount = m_dwWorkingThreadCount;
		bool	bExceptionThrown = false;		// Flag used in cleanup.

		// Attempt to allocate additional threads.
		try
		{
			// Allocate new thread block.
			ppThreadCtl = new CThreadControl* [dwDesiredThreadCount];
			//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
			if(!ppThreadCtl)
			{
				throw bad_alloc();
			}

			DWORD i;
			// Initialize before adding threads
			for (i = 0; i < dwDesiredThreadCount; i++)
				ppThreadCtl[i] = NULL;

			// Transfer any existing threads.
			for (i = 0; i < dwOldCount; i++)
				ppThreadCtl[i] = m_ppThreadCtl[i];

			// Allocate additional threads.
			for (i = dwOldCount; i < dwDesiredThreadCount; i++)
			{
				ppThreadCtl[i] = new CThreadControl(m_pSniffConnector);
				//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
				if(!ppThreadCtl[i])
				{
					throw bad_alloc();
				}

				// This function may throw exceptions of type CGeneralException.
				m_dwErr = ppThreadCtl[i]->Initialize(m_pPoolQueue);

				m_dwWorkingThreadCount++;
			}
		}
		catch (CGeneralException& x)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									x.GetErrorMsg(), _T("General exception"), 
									x.GetErrorCode() ); 
			bExceptionThrown= true;
		}
		catch (bad_alloc&)
		{	
			// Note memory failure in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
			bExceptionThrown= true;
		}

		if ((bExceptionThrown) && (dwOldCount))
		{
			// Restore previous settings.
			// Clean up any allocated memory and reset the working thread count.
			for (DWORD i = dwOldCount; i < dwDesiredThreadCount; i++)
			{
				if (ppThreadCtl[i])
					delete ppThreadCtl[i];
			}
			if (ppThreadCtl)
				delete [] ppThreadCtl;
			m_dwWorkingThreadCount= dwOldCount;
		}
		else if (ppThreadCtl)
		{
			// Move thread block to member variable.
			CThreadControl **pp = m_ppThreadCtl;
			m_ppThreadCtl = ppThreadCtl;

			// Release any previous thread block.
			if (pp)
				delete[] pp;
		}
		else
		{
			// this is a very unlikely situation, but it would mean we have no pool
			//	threads.  We don't want to terminate the program (it's possible that 
			//	we want to run in support of status queries). 
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_ERROR_NOPOOLTHREADS ); 
		}
	}
}

// input i is thread index.
bool CThreadPool::ReinitializeThread(DWORD i)
{
	if (i <m_dwWorkingThreadCount && m_ppThreadCtl && m_ppThreadCtl[i])
	{
		m_ppThreadCtl[i]->Kill(2000L); // 2 seconds to exit normally

		try
		{
			delete m_ppThreadCtl[i];
			m_ppThreadCtl[i] = new CThreadControl(m_pSniffConnector);

			// This function may throw exceptions of type CGeneralException.
			m_dwErr = m_ppThreadCtl[i]->Initialize(m_pPoolQueue);
		}
		catch (CGeneralException& x)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									x.GetErrorMsg(), _T("General exception"), 
									x.GetErrorCode() ); 

			// Initialization has failed, delete the newly allocated thread.  
			if (m_ppThreadCtl[i])
				delete m_ppThreadCtl[i];
		}
		catch (bad_alloc&)
		{
			// A memory allocation failure occurred during processing of query, log it.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 

			// Set the thread to a known state.
			m_ppThreadCtl[i]= NULL;
		}
		return true;
	}
	else
		return false;
}

// Reinitialize any threads that have been "working" more than 10 seconds on a single request
void CThreadPool::ReinitializeStuckThreads()
{	
	if (!m_ppThreadCtl) 
		return;

	for (DWORD i=0; i<m_dwWorkingThreadCount;i++)
	{
		if (m_ppThreadCtl[i])
		{
			CPoolThreadStatus status;
			m_ppThreadCtl[i]->WorkingStatus(status);
			if ( status.m_bFailed || (status.m_bWorking && status.m_seconds > 10) )
				ReinitializeThread(i);
		}
	}
}

// input i is thread index.
bool CThreadPool::ThreadStatus(DWORD i, CPoolThreadStatus &status)
{
	if (i <m_dwWorkingThreadCount && m_ppThreadCtl && m_ppThreadCtl[i])
	{
		m_ppThreadCtl[i]->WorkingStatus(status);
		return true;
	}
	else
		return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\topicshop.h ===
//
// MODULE: TOPICSHOP.H
//
// PURPOSE: Provide a means of "publishing" troubleshooter topics.  This is where a 
//	working thread goes to obtain a CTopic to use
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-10-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-10-98	JM
//

#if !defined(AFX_TOPICSHOP_H__0CEED643_48C2_11D2_95F3_00C04FC22ADD__INCLUDED_)
#define AFX_TOPICSHOP_H__0CEED643_48C2_11D2_95F3_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtslstread.h"
#include "apgtsHTIread.h"
#include "Pointer.h"
#include "Topic.h"
#include "counter.h"
#include <map>

#pragma warning(disable:4786)

#define LSTFILENAME			_T("apgts.lst")


typedef counting_ptr<CTopic> CP_TOPIC;
class CTopicInCatalog
{
public:
	enum TopicStatus {eNotInited, eFail, eOK};
private:
	CTopicInfo	m_topicinfo;	// symbolic name of topic, associated file names 
	bool m_bTopicInfoMayNotBeCurrent;	// set when we change topic info & haven't yet built.
	mutable CRITICAL_SECTION m_csTopicinfo;	// must lock to access m_topicinfo or 
								//	m_bTopicInfoMayNotBeCurrent (outside the constructor)
	bool		m_bInited;		// true if we have attempted to build m_cpTopic.
								//	Mainly, this is here so that if we have tried to build
								//	the relevant CTopic and failed, we don't waste our time
								//	trying to build it again.  If this is true and 
								//	m_cpTopic.IsNull(), then we are unable to build this
								//	troubleshooting topic.
	CP_TOPIC	m_cpTopic;		// smart (counting) pointer.  If non-null, points to a 
								//	"published" topic, which is guaranteed to persist as 
								//	long as this points to it, or as long as a CP_TOPIC
								//	copied from this pointer points to it.
	HANDLE		m_hev;			// event to trigger when this topic is (successfully or 
								//	unsuccessfully) loaded.
	CHourlyDailyCounter m_countLoad;	// track attempted loads of this topic
	CHourlyDailyCounter m_countLoadOK;	// track successful loads of this topic
	CHourlyDailyCounter m_countEvent;	// track: initial placement in catalog, file change,
								//	or operator request for change. More interesting for
								//	first & last times than total number.
	CHourlyDailyCounter m_countHit;	// track user requests for this topic...
	// ... and break them down to hits which are the first on a new cookie 
	// & those which are not
	CHourlyDailyCounter m_countHitNewCookie;
	CHourlyDailyCounter m_countHitOldCookie;

public:
	CTopicInCatalog(const CTopicInfo & topicinfo);
	~CTopicInCatalog();
	CTopicInfo GetTopicInfo() const;
	void SetTopicInfo(const CTopicInfo &topicinfo);
	void CountHit(bool bNewCookie);
	CP_TOPIC & GetTopicNoWait(CP_TOPIC& cpTopic) const;
	CP_TOPIC & GetTopic(CP_TOPIC& cpTopic) const;
	void Init(const CTopic* pTopic);
	void CountChange();
	TopicStatus GetTopicStatus() const;
	bool GetTopicInfoMayNotBeCurrent() const;
	void TopicInfoIsCurrent();
};	// EOF of class CTopicInCatalog.


// This class was created utilizing CTopicInCatalog as a model.  We might in the
// future revisit these two classes and abstract the common functionality into a 
// base class.  RAB-981030.
typedef counting_ptr<CAPGTSHTIReader> CP_TEMPLATE;
class CTemplateInCatalog
{
public:
	enum TemplateStatus {eNotInited, eFail, eOK};
private:
	CString		m_strTemplate;	// name to the template 
	bool		m_bInited;		// true if we have attempted to build m_cpTemplate.
								//	Mainly, this is here so that if we have tried to build
								//	the relevant CAPGTSHTIReader and failed, we don't waste our
								//	time trying to build it again.  If this is true and 
								//	m_cpTemplate.IsNull(), then we are unable to build this
								//	troubleshooting template.
	CP_TEMPLATE	m_cpTemplate;	// smart (counting) pointer.  If non-null, points to a 
								//	"published" template, which is guaranteed to persist as 
								//	long as this points to it, or as long as a CP_TEMPLATE
								//	copied from this pointer points to it.
	HANDLE		m_hev;			// event to trigger when this template is (successfully or 
								//	unsuccessfully) loaded.
	CHourlyDailyCounter m_countLoad;	// track attempted loads of this template
	CHourlyDailyCounter m_countLoadOK;	// track successful loads of this template
	CHourlyDailyCounter m_countEvent;	// track: initial placement in catalog, file change,
								//	or operator request for change. More interesting for
								//	first & last times than total number.
	CHourlyDailyCounter m_countHit;	// track user requests for this template...

public:
	CTemplateInCatalog( const CString & strTemplate );
	~CTemplateInCatalog();
	const CString & GetTemplateInfo() const;
	void CountHit( bool bNewCookie );
	CP_TEMPLATE & GetTemplateNoWait( CP_TEMPLATE& cpTemplate ) const;
	CP_TEMPLATE & GetTemplate( CP_TEMPLATE& cpTemplate ) const;
	void Init( const CAPGTSHTIReader* pTemplate );
	void CountChange();
	void CountFailed();
	TemplateStatus GetTemplateStatus() const;
	DWORD CountOfFailedLoads() const;
};	// EOF of class CTemplateInCatalog.


// The only functions which need to lock class CTopicShop itself are those which modify TopicCatalog.
// TopicBuildQueue has its own protection.
class CTopicShop : public CStateless
{
public:
	// although this status pertains to CTopicBuildQueue, it must be declared public at 
	//	this level, so that we can pass thread status up out of CTopicShop.
	enum ThreadStatus{eBeforeInit, eFail, eWait, eRun, eExiting};
	static CString ThreadStatusText(ThreadStatus ts);
private:
	typedef map<CString, CTopicInCatalog*> CTopicCatalog;
	typedef map<CString, CTemplateInCatalog*> CTemplateCatalog;

	// Queue of topics to build
	class CTopicBuildQueue : public CStateless
	{
	public:
		enum CatalogCategory {eUnknown, eTopic, eTemplate};
	private:
		CTopicCatalog & m_TopicCatalog;
		CTemplateCatalog & m_TemplateCatalog;
		CString m_CurrentlyBuilding;		// topic currently being built. Strictly lowercase.
											//	it is assumed/enforced that only one topic at 
											//	a time will be built.
		CatalogCategory	m_eCurrentlyBuilding;// Category type currently being built.
		
		// All strings in the next 4 vectors are strictly lowercase.
		vector<CString>m_PriorityBuild;		// build these first.  Someone's waiting for them. 
		vector<CString>m_NonPriorityBuild;
		vector<CString>m_PriorityBuildTemplates;
		vector<CString>m_NonPriorityBuildTemplates;
		
		HANDLE m_hThread;
		HANDLE m_hevBuildRequested;			// event to wake up TopicBuilderTask.
		HANDLE m_hevThreadIsShut;			// event just to indicate exit of TopicBuilderTask thread 
		bool m_bShuttingDown;				// lets topic builder thread know we're shutting down
		DWORD m_dwErr;						// status from starting the thread
		ThreadStatus m_ThreadStatus;
		time_t m_time;						// time last changed ThreadStatus.  Initialized

	public:
		CTopicBuildQueue( CTopicCatalog & TopicCatalog, CTemplateCatalog & TemplateCatalog );
		~CTopicBuildQueue();
		void RequestBuild(const CString &strTopic, bool bPriority, CatalogCategory eCat );
		DWORD GetStatus(ThreadStatus &ts, DWORD & seconds) const;
		void GetTopicsStatus(DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const;
		void GetTemplatesStatus( vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const;
		
		// Used to shutdown the topic building thread.
		void ShutDown();

	private:
		CTopicBuildQueue();  // do not instantiate
		void SetThreadStatus(ThreadStatus ts);

		// functions for use by the TopicBuilderTask thread.
		void Build();
		bool GetNextToBuild( CString &strTopic, CatalogCategory &eCat );
		void BuildComplete();
		void AckShutDown();

		// main function of the TopicBuilderTask thread.
		static UINT WINAPI TopicBuilderTask(LPVOID lpParams);
	};	// EOF of class CTopicBuildQueue.

/* class CTopicShop */
private:
	CTopicCatalog		m_TopicCatalog;
	CTemplateCatalog	m_TemplateCatalog;
	CTopicBuildQueue	m_TopicBuildQueue;
	HANDLE				m_hevShopIsOpen;	// so that threads wait till we know our list of topics

public:
	CTopicShop();
	virtual ~CTopicShop();

	void AddTopic(const CTopicInfo & topicinfo);
	void AddTemplate( const CString & strTemplateName );

	void OpenShop();

	void BuildTopic(const CString & strTopic, bool *pbAlreadyInCatalog = NULL);
	void BuildTemplate(const CString & strTemplate);
	
	CP_TOPIC & GetTopic(const CString & strTopic, CP_TOPIC & cpTopic, bool bNewCookie);
	CP_TEMPLATE & GetTemplate( const CString & strTemplate, CP_TEMPLATE & cpTemplate, bool bNewCookie);

	void GetListOfTopicNames(vector<CString>&arrstrTopic) const;
	void RebuildAll();
	DWORD GetThreadStatus(ThreadStatus &ts, DWORD & seconds) const;
	void GetTopicsStatus(DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const;
	void GetTemplatesStatus( vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const;
	CTopicInCatalog* GetCatalogEntry(const CString& strTopic) const;
	bool RetTemplateInCatalogStatus( const CString& strTemplate, bool& bValid ) const;

private:
	CTopicInCatalog * GetCatalogEntryPtr(const CString & strTopic) const;
	CTemplateInCatalog * GetTemplateCatalogEntryPtr(const CString & strTemplate) const;
};	// EOF of class CTopicShop.


#endif // !defined(AFX_TOPICSHOP_H__0CEED643_48C2_11D2_95F3_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\tshootctrl.cpp ===
//
// MODULE: TSHOOTCtrl.cpp
//
// PURPOSE: Implementation of CTSHOOTCtrl: Interface for the component
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12.23.98
//
// NOTES: 
// 
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		12/23/98	OK	    

#include "stdafx.h"
#include "TSHOOT.h"
#include "TSHOOTCtrl.h"
#include "LocalECB.h"
#include "apgts.h"
#include "apgtsinf.h"

#define APGTS_COUNTER_OWNER 1
#include "ApgtsCounters.h"

#include "apgtsinf.h"
#include "apgtspl.h"
#include "apgtscfg.h"
#include "apgtslog.h"
#include "event.h"
#include "apgtsinf.h"
#include "apgtscls.h"
#include "apgtsevt.h"
#include "VariantBuilder.h"

// Launcher integration
#include "LaunchServ.h"
#include "LaunchServ_i.c"
#include "CHMFileReader.h"

bool g_nLaunched = false;

extern HANDLE ghModule;

// Error codes for end user.  Previously we gave verbose error messages.  Microsoft
// decided 8/98 that they do not want to tell the end user about presumably internal problems.
// Hence these codes.

DWORD k_ServErrDuringInit = 1000;		// Error(s) During Initialization: m_dwErr number follows
DWORD k_ServErrLimitedRequests = 1001;	// The server has limited the number of requests
DWORD k_ServErrThreadTokenFail = 1002;	// Failed to open thread token (impersonation token)
DWORD k_ServErrShuttingDown = 1003;		// Server Shutting Down
DWORD k_ServErrOutOfMemory = 1005;		// Out of memory (probably never will occur)


// Since VC++ v5.0 does not throw exceptions upon memory failure, we force the behavior.
_PNH APGST_New_Handler( size_t )
{
	throw std::bad_alloc();
	return( 0 );
}

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl
CTSHOOTCtrl::CTSHOOTCtrl()

		   : m_bInitialized(false),
			 m_bFirstCall(true),
			 m_pThreadPool(NULL),
			 m_poolctl(NULL),
			 m_pConf(NULL),
			 m_pLog(NULL),
			 m_dwErr(0),
			 m_bShutdown(false),
			 m_dwRollover(0),
			 m_bStartedFromLauncher(false),
			 m_pVariantBuilder(NULL),
			 m_bRequestToSetLocale(false),
			 m_bCanRegisterGlobal(true)
{
	// Set a new handler that throws bad_alloc exceptions (unlike VC++ v5.0).
	m_SetNewHandlerPtr= _set_new_handler( (_PNH)APGST_New_Handler );
	// Have malloc call the _set_new_handler upon failure to allocate memory.
	m_SetNewMode= _set_new_mode( 1 );

	if (RUNNING_APARTMENT_THREADED())
	{
		CoCreateInstance(CLSID_StdGlobalInterfaceTable,
						 NULL,
						 CLSCTX_INPROC_SERVER,
						 IID_IGlobalInterfaceTable,
						 reinterpret_cast<void**>(&m_pGIT));
	}
}

CTSHOOTCtrl::~CTSHOOTCtrl()
{
	if (RUNNING_APARTMENT_THREADED())
	{
		for(vector<DWORD>::iterator it = m_vecCookies.begin(); it != m_vecCookies.end(); it++)
			m_pGIT->RevokeInterfaceFromGlobal(*it);
		m_pGIT->Release();
	}

	Destroy();
	// Restore the initial set_new_handler and set_new_mode.
	_set_new_handler( m_SetNewHandlerPtr );
	// Restore the malloc handling as it was previously.
	_set_new_mode( m_SetNewMode );
}

bool CTSHOOTCtrl::Init(HMODULE hModule)
{
	try
	{
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool after
		// all new operations in this function.

		m_poolctl= new CPoolQueue();		
		if(!m_poolctl)
			throw bad_alloc();
		if ((m_dwErr = m_poolctl->GetStatus()) != 0)
			return false;

		m_pThreadPool = new CThreadPool(m_poolctl, dynamic_cast<CSniffConnector*>(this));	
		if(!m_pThreadPool)
			throw bad_alloc();
		if ((m_dwErr = m_pThreadPool->GetStatus()) != 0)
			return false;

		// open log
		m_pLog = new CHTMLLog( DEF_LOGFILEDIRECTORY );
		if(!m_pLog)
			throw bad_alloc();
		if ((m_dwErr = m_pLog->GetStatus()) != 0)
			return false;

		m_pConf= new CDBLoadConfiguration(hModule, m_pThreadPool, m_strTopicName, m_pLog );
		if(!m_pConf)
			throw bad_alloc();
	}
	catch (bad_alloc&)
	{
		m_dwErr= EV_GTS_CANT_ALLOC;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), m_dwErr ); 
		return false;
	}

	return true;
}

void CTSHOOTCtrl::Destroy()
{
	if (m_pThreadPool)
	{
		// >>>(ignore for V3.0) The following is not great encapsulation, but as of 9/22/98 we 
		//	don't see a way	around it. StartRequest falls naturally in APGTSExtension, so 
		//	APGTSExtension ends up with responsibility to tell the pool threads to exit.
		bool bAllSuccess = true;
		// signal all working threads to quit
		DWORD dwWorkingThreadCount = m_pThreadPool->GetWorkingThreadCount();
		for (DWORD i = 0; i < dwWorkingThreadCount; i++) 
			if (StartRequest(NULL, NULL) != HSE_STATUS_PENDING)
				bAllSuccess = false;

		if (bAllSuccess == false) 
		{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""),
										_T(""),
										EV_GTS_USER_BAD_THRD_REQ ); 
		}
	}
	
	if (m_pConf)
		delete m_pConf;

	if (m_pThreadPool)
		delete m_pThreadPool;

	if (m_poolctl)
	{
		// [BC-022701] - Removed Unlock call here. Not matched with preceeding Lock() call.
		// This never caused a problem until run on Debug build of WindowsXP. In this environment
		// this Unlock call causes crash.		
		//m_poolctl->Unlock();
		
		delete m_poolctl;
	}

	if (m_pLog)
		delete m_pLog;
}

// coded on analogy with Online troubleshooter
DWORD CTSHOOTCtrl::HttpExtensionProc(CLocalECB* pECB)
{
	bool              fRet = false, bChange = false;
    DWORD			  dwRet = HSE_STATUS_PENDING;
    //HANDLE            hImpersonationToken;
	CString strTemp;

	CLocalECB *pLocalECB = pECB;

	if (m_dwErr) 
	{
		strTemp.Format(_T("<P>Error %d:%d"), k_ServErrDuringInit, m_dwErr);
        fRet = SendError( pLocalECB,
                          _T("500 Try again later"),	// 500 is from HTTP spec
                          strTemp);
		
        pLocalECB->SetHttpStatusCode(500);
		
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
	}

    //  Is the request queue (items requested by this fn to be serviced by working threads)
	//		too long?  If so, tell the user to come back later
    //
    if ( m_poolctl->GetTotalQueueItems() + 1 > m_pConf->GetMaxWQItems() )
    {
        //
        //  Send a message back to client indicating we're too busy, they
        //  should try again later.
        //
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_SERVER_BUSY ); 

        strTemp.Format(_T("<P>Error %d"), k_ServErrLimitedRequests);
		fRet = SendError( pLocalECB,
                          _T("503 Try again later"),
                          strTemp );
		
        pLocalECB->SetHttpStatusCode(503);
		
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
	}

    //
    //  Capture the current impersonation token (IIS Security) so we can impersonate this
    //  user in the other thread.  Limit permissions.
    //
    
	/*
	if ( !::OpenThreadToken(::GetCurrentThread(),
							TOKEN_QUERY | TOKEN_IMPERSONATE,
							false,            // Open in unimpersonated context
							&hImpersonationToken ))
    {
		DWORD err = ::GetLastError();

		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );

		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_THREAD_TOKEN ); 

        strTemp.Format(_T("<P>Error %d"), k_ServErrThreadTokenFail);
		fRet = SendError( pLocalECB,
                          _T("500 Try again later"),
                          strTemp );
		
        pLocalECB->SetHttpStatusCode(500);
		
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }
	*/

	dwRet = StartRequest(pLocalECB, NULL/*hImpersonationToken*/);

	return (dwRet);
}

// Thread-safe.
// NOTE TWO ROLES depending on INPUT pLocalECB.
// INPUT  pLocalECB - NULL if shutting down
//		Otherwise, EXTENSION_CONTROL_BLOCK is ISAPI's way of passing in the sort of
//		stuff you'd get from CGI.  We've abstracted from that.
// INPUT hImpersonationToken obtained via prior call to OpenThreadToken
//		Not relevant if pLocalECB == NULL
// RETURNS HSE_STATUS_SUCCESS, HSE_STATUS_ERROR, HSE_STATUS_PENDING
//	(or HSE_REQ_DONE_WITH_SESSION in single-threaded debugging version)
DWORD CTSHOOTCtrl::StartRequest(CLocalECB *pLocalECB, HANDLE hImpersonationToken)
{
    WORK_QUEUE_ITEM * pwqi;
	bool              fRet = false;
	CString strTemp;
	
    //
    //  Take the queue lock, get a queue item and put it on the queue
    //

	if (pLocalECB && m_bShutdown) 
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_CANT_PROC_REQ_SS ); 

		strTemp.Format(_T("<P>Error %d"), k_ServErrShuttingDown);
		fRet = SendError( pLocalECB,
				          _T("500 Try again later"),
				          strTemp );
			
		pLocalECB->SetHttpStatusCode(500);

		::CloseHandle( hImpersonationToken );
        
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
	}
	
    m_poolctl->Lock();

	// 9/23/98 JM got rid of a constraint here which was too tight a constraint
	//	on size of queue
	try
	{
		// bundle up pointers the worker thread will need
		pwqi = new WORK_QUEUE_ITEM (
			hImpersonationToken,
			pLocalECB,			// may be null as a signal
			m_pConf,
			m_pLog);
	}
	catch (bad_alloc&)
    {
		m_poolctl->Unlock();

		if (pLocalECB) 
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""),
									_T(""),
									EV_GTS_ERROR_WORK_ITEM ); 
			
			strTemp.Format(_T("<P>Error %d"), k_ServErrOutOfMemory);
			fRet = SendError( pLocalECB,
				              _T("500 Not enough memory"),
				              strTemp);
			
			pLocalECB->SetHttpStatusCode(500);
			::CloseHandle( hImpersonationToken );
		}
        
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }

	if (!pLocalECB)
		m_bShutdown = true;

	// Some data passed to thread just for statistical purposes
	// Thread can pass this info back over web; we can't.
	pwqi->GTSStat.dwRollover = m_dwRollover++;

	// put it at the tail of the queue & signal the pool threads there is work to be done
	m_poolctl->PushBack(pwqi);

    m_poolctl->Unlock();

    return HSE_STATUS_PENDING;
}

// Build an HTTP response in the case of an error.
//	INPUT *pszStatus short status (e.g. "503 Server too busy").
//	INPUT str - entire content of the page.
//	RETURNS true on success
// NOTE that this actually uses no member variables.
/*static*/ bool CTSHOOTCtrl::SendSimpleHtmlPage(	CLocalECB *pLocalECB,
													LPCTSTR pszStatus,
													const CString & str)
{
    BOOL fRet;
    DWORD cb;

	TCHAR pszTemp[200];		// safely large to copy pszStatus.  pLocalECB->ServerSupportFunction
							// doesn't want pszStatus in a const array

	_tcscpy(pszTemp, pszStatus);
	
    //  Send the headers
    //
    fRet = pLocalECB->ServerSupportFunction( HSE_REQ_SEND_RESPONSE_HEADER,
											 pszTemp,
											 NULL,
											 (LPDWORD) _T("Content-Type: text/html\r\n\r\n") );
    //
    //  If that succeeded, send the message
    //
    if ( fRet ) 
	{
        cb = str.GetLength();
		// (LPCTSTR) cast gives us the underlying text bytes.
		//	>>> $UNICODE Actually, this would screw up under Unicode compile, because for HTML, 
		//	this must be SBCS.  Should really be a conversion to LPCSTR, which is non-trivial
		//	in a Unicode compile. JM 1/7/99
		fRet = pLocalECB->WriteClient((LPCTSTR)str, &cb);
    }
    return fRet ? true : false;
}

// Build an HTTP response in the case of an error.
// INPUT  pLocalECB - EXTENSION_CONTROL_BLOCK is ISAPI's way of passing in the sort of
//	stuff you'd get from CGI.  We've abstracted from that.  pLocalECB should never be null.  
//	INPUT *pszStatus short status (e.g. "503 Try again later").
//	INPUT *pszMessage - typically just an error number, e.g. "1004" or
//		"1000:123"
//	RETURNS true on success
/*static*/ bool CTSHOOTCtrl::SendError( CDBLoadConfiguration *pConf, 
										CLocalECB *pLocalECB, 
										LPCTSTR pszStatus, 
										const CString & strMessage)
{
	CString str;

	pConf->CreateErrorPage(strMessage, str);

	return SendSimpleHtmlPage( pLocalECB, pszStatus, str);
}

/*static*/ bool CTSHOOTCtrl::RemoveStartOverButton(CString& strWriteClient)
{
	int left = 0, right = 0;

	if (-1 != (left = strWriteClient.Find(SZ_INPUT_TAG_STARTOVER)))
	{
		right = left;
		while (strWriteClient[++right] && strWriteClient[right] != _T('>'))
			;
		if (strWriteClient[right])
			strWriteClient = strWriteClient.Left(left) + strWriteClient.Right(strWriteClient.GetLength() - right - 1);
		else
			return false;
		return true;
	}
	return false;
}

/*static*/ bool CTSHOOTCtrl::RemoveBackButton(CString& strWriteClient)
{
	int left = 0, right = 0;

	if (-1 != (left = strWriteClient.Find(SZ_INPUT_TAG_BACK)))
	{
		right = left;
		while (strWriteClient[++right] && strWriteClient[right] != _T('>'))
			;
		if (strWriteClient[right])
			strWriteClient = strWriteClient.Left(left) + strWriteClient.Right(strWriteClient.GetLength() - right - 1);
		else
			return false;
		return true;
	}
	return false;
}

bool CTSHOOTCtrl::SendError(CLocalECB *pLocalECB,
							LPCTSTR pszStatus,
							const CString & strMessage) const
{
	return SendError(m_pConf, pLocalECB, pszStatus, strMessage);
}

bool CTSHOOTCtrl::ReadStaticPageFile(const CString& strTopicName, CString& strContent)
{
	CString strPath;

	if (!m_pConf->GetRegistryMonitor().GetStringInfo(CAPGTSRegConnector::eResourcePath, strPath))
		return false;

	CString strFullPath = strPath + strTopicName + LOCALTS_SUFFIX_RESULT + LOCALTS_EXTENSION_HTM;
	
	CFileReader fileResult(	CPhysicalFileReader::makeReader( strFullPath ) );

	if (!fileResult.Read())
		return false;
	
	strContent = _T("");
	fileResult.GetContent(strContent);
	
	return true;
}

bool CTSHOOTCtrl::ExtractLauncherData(CString& error)
{
	HRESULT hRes = S_OK;
	DWORD	dwResult = 0;
	OLECHAR *poleShooter = NULL;
	OLECHAR *poleProblem = NULL;
	OLECHAR *poleNode = NULL;
	OLECHAR *poleState = NULL;
	OLECHAR *poleMachine = NULL;
	OLECHAR *polePNPDevice = NULL;
	OLECHAR *poleGuidClass = NULL;
	OLECHAR *poleDeviceInstance = NULL;
	short i = 0;
	CNameValue name_value;
	ILaunchTS *pILaunchTS = NULL;
	CLSID clsidLaunchTS = CLSID_LaunchTS;
	IID iidLaunchTS = IID_ILaunchTS;

	// Get an interface on the launch server
	hRes = ::CoCreateInstance(clsidLaunchTS, NULL, 
			                  CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER | CLSCTX_INPROC_SERVER,
			                  iidLaunchTS, (void **) &pILaunchTS);
	if (FAILED(hRes))
	{
		error = _T("LaunchServ interface not found.");
		return false;
	}

	// Get all of the query values.
	hRes = pILaunchTS->GetShooterStates(&dwResult);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error.Format(_T("GetShooterStates Failed. %ld"), dwResult);
		pILaunchTS->Release();			
		return false;
	}

	// clear container
	m_arrNameValueFromLauncher.clear();
	
	// get tshooter name
	hRes = pILaunchTS->GetTroubleShooter(&poleShooter);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetTroubleShooter Failed.");
		pILaunchTS->Release();
		return false;
	}
	name_value.strName = C_TOPIC;
	name_value.strValue = poleShooter;
	m_arrNameValueFromLauncher.push_back(name_value);
	SysFreeString(poleShooter);

	// get problem
	hRes = pILaunchTS->GetProblem(&poleProblem);
	if (S_FALSE != hRes && !FAILED(hRes))
	{
		name_value.strName = NODE_PROBLEM_ASK;
		name_value.strValue = poleProblem;
		m_arrNameValueFromLauncher.push_back(name_value);
		SysFreeString(poleProblem);

		// get name - value pairs for nodes set by the user
		do	
		{
			hRes = pILaunchTS->GetNode(i, &poleNode);
			if (FAILED(hRes) || S_FALSE == hRes)
				break;
			name_value.strName = poleNode;
			SysFreeString(poleNode);

			hRes = pILaunchTS->GetState(i, &poleState);
			if (FAILED(hRes) || S_FALSE == hRes)
				break;
			name_value.strValue = poleState;
			SysFreeString(poleState);
			
			m_arrNameValueFromLauncher.push_back(name_value);
			i++;
		} 	
		while (true);
	}

	///////////////////////////////////////////////////////////
	// obtaining Machine, PNPDevice, GuidClass, DeviceInstance
	hRes = pILaunchTS->GetMachine(&poleMachine);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetMachine Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strMachineID = poleMachine;
	::SysFreeString(poleMachine);
	
	hRes = pILaunchTS->GetPNPDevice(&polePNPDevice);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetPNPDevice Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strPNPDeviceID = polePNPDevice;
	::SysFreeString(polePNPDevice);

	hRes = pILaunchTS->GetGuidClass(&poleGuidClass);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetGuidClass Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strGuidClass = poleGuidClass;
	::SysFreeString(poleGuidClass);
	
	hRes = pILaunchTS->GetDeviceInstance(&poleDeviceInstance);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetDeviceInstance Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strDeviceInstanceID = poleDeviceInstance;
	::SysFreeString(poleDeviceInstance);
	////////////////////////////////////////////////////////////

	pILaunchTS->Release();
	return true;
}

//
STDMETHODIMP CTSHOOTCtrl::RunQuery(VARIANT varCmds, VARIANT varVals, short size, BSTR *pbstrPage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	if (RUNNING_APARTMENT_THREADED())
	{
		if (m_bCanRegisterGlobal) 
		{
			RegisterGlobal();
			m_bCanRegisterGlobal = false;
		}
	}
	
	//!!!!!!!!!!!!! Check for size < 1 !!!!!!!!!!!!!!!!!!!!!
	if (size < 1)
	{
		*pbstrPage = T2BSTR("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> Error in RunQuery parameter: size is less one. </H4> </BODY> </HTML>");
		return S_OK;
	}

	//!!!!!!!!!! detect the way we were stated !!!!!!!!!!!!!!
	{   
		CString strStub;
		CLocalECB ECB(varCmds, varVals, 1, NULL, &strStub, NULL,														
						m_bRequestToSetLocale, m_strRequestedLocale );
		CString strFirstName = ECB.GetNameValue(0).strName;

		if (strFirstName == NODE_LIBRARY_ASK)
		{
			if (g_nLaunched)
			{
				*pbstrPage = T2BSTR("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> Error in RunQuery: launched for the second time. </H4> </BODY> </HTML>");
				return S_OK;
			}

			CString strError;
			
			m_bStartedFromLauncher = true;
			g_nLaunched = true;
			if (!ExtractLauncherData(strError))
			{
				CString strOut;
				strOut.Format(_T("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> %s. </H4> </BODY> </HTML>"), strError);
				*pbstrPage = T2BSTR(strOut);
				m_bStartedFromLauncher = false;
				return S_OK;
			}
		}
	}
	
	/////////////////////////////////////////////////////////
	// automatic variable declaration
	HANDLE event = ::CreateEvent(NULL, false, false, NULL);
	CString strWriteClient;
	CLocalECB* pECB;

	if (RUNNING_APARTMENT_THREADED())
		pECB = !m_bStartedFromLauncher ? new CLocalECB(varCmds, varVals, size, NULL, 
														&strWriteClient, 
														dynamic_cast<CRenderConnector*>(this),
														m_bRequestToSetLocale,
														m_strRequestedLocale)
									   : new CLocalECB(m_arrNameValueFromLauncher, 
														NULL, &strWriteClient, 
														dynamic_cast<CRenderConnector*>(this),
														m_bRequestToSetLocale,
														m_strRequestedLocale);

	if (RUNNING_FREE_THREADED())
		pECB = !m_bStartedFromLauncher ? new CLocalECB(varCmds, varVals, size, 
														event, &strWriteClient, NULL,
														m_bRequestToSetLocale,
														m_strRequestedLocale)
									   : new CLocalECB(m_arrNameValueFromLauncher, event, 
														&strWriteClient, NULL,
														m_bRequestToSetLocale,
														m_strRequestedLocale);

	m_bRequestToSetLocale= false;	// Deactivate locale setting after it has been passed into the ECB.
	SetLocked(true);
	
	bool bSaveFirstPage = false;
	
	/////////////////////////////////////////////////////////
	// initialize
	if (!m_bInitialized)
	{
		// extract topic name first
		if (!m_bStartedFromLauncher)
		{
			CString strStub;
			CLocalECB ECB(varCmds, varVals, 1, NULL, &strStub, NULL,
							m_bRequestToSetLocale, m_strRequestedLocale );
			m_strTopicName = ECB.GetNameValue(0).strValue;
		}
		else
			m_strTopicName = (*m_arrNameValueFromLauncher.begin()).strValue;

		if (Init((HINSTANCE)::ghModule))
		{
			m_bInitialized = true;
		}
		else
		{
			*pbstrPage = T2BSTR(_T("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> Error of initialization in RunQuery. </H4> </BODY> </HTML>"));
			m_bStartedFromLauncher = false;
			return S_OK;
		}
	}

	//////////////////////////////////////////////////////////
	// save first page when started from static page
	if (m_strFirstPage.IsEmpty() &&	!m_bStartedFromLauncher) 
	{	
		CString strStaticPage;

		if (size == 2 && 
			// RunQuery was started from static (since !m_bStartedFromLauncher) Problem Page(since size == 2)
			ReadStaticPageFile(m_strTopicName, strStaticPage)
		   )
		{
			m_strFirstPage = strStaticPage;
		}
		else
		{
			bSaveFirstPage = true;
		}
	}
	
	HttpExtensionProc(pECB);

	if (RUNNING_FREE_THREADED())
		::WaitForSingleObject(event, INFINITE);

	::CloseHandle(event);

	if (bSaveFirstPage)
		m_strFirstPage = strWriteClient;
	
	/////////////////////////////////////////////////////////
	// first RunQuery when started from Launcher
	if (m_bStartedFromLauncher && m_bFirstCall)
	{
		RemoveStartOverButton(strWriteClient);
		RemoveBackButton(strWriteClient);
	}
	/////////////////////////////////////////////////////////
	// save first page when started from Launcher
	if (m_strFirstPage.IsEmpty() && m_bStartedFromLauncher) 
		m_strFirstPage = strWriteClient;

	*pbstrPage = T2BSTR(strWriteClient);
	/*
	//////////////////////////////////////////////////////////////////////////
	// >>> $TEST
	HANDLE hFile = ::CreateFile(_T("D:\\TShooter Projects\\Troubleshooter\\Local\\http\\Test\\first_step.htm"), 
								GENERIC_WRITE, 
								0,
								NULL,			// no security attributes 
								CREATE_ALWAYS, 
								FILE_FLAG_RANDOM_ACCESS, 
								NULL			// handle to template file
  							   );
	if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD read = 0;
		::WriteFile(hFile, (LPCTSTR)strWriteClient, strWriteClient.GetLength(), &read, NULL);
	}
	///////////////////////////////////////////////////////////////////////////
	*/
	m_bStartedFromLauncher = false;
	m_bFirstCall = false;
	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::SetSniffResult(VARIANT varNodeName, VARIANT varState, BOOL *bResult)
{
	// >>> No sniffing is used. Oleg 03.26.99
	*bResult = 1;

	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::PreLoadURL(BSTR bstrRoot, BSTR *pbstrPage)
{
	USES_CONVERSION;

	// >>> This feature is not used. Oleg. 03.26.99
	*pbstrPage = A2BSTR("PreLoadURL results");

	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::Restart(BSTR *pbstrPage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	*pbstrPage = T2BSTR(m_strFirstPage);

	return S_OK;
}

// The same as Restart(...).
// Implemented for compatibility with Win98's JScript
STDMETHODIMP CTSHOOTCtrl::ProblemPage(BSTR *pbstrFirstPage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	*pbstrFirstPage = T2BSTR(m_strFirstPage);

	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::SetPair(BSTR bstrCmd, BSTR bstrVal)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;
	
	if (!m_pVariantBuilder)
		m_pVariantBuilder = new CVariantBuilder;

	// check if we've started new sequence, but
	//  array of name - value pairs is not empty
	CString type = W2T(bstrCmd);
	if (type == C_TYPE || type == C_PRELOAD || type == C_TOPIC)
	{
		if (m_pVariantBuilder->GetSize())
		{
			delete m_pVariantBuilder;
			m_pVariantBuilder = new CVariantBuilder;
		}
	}

	m_pVariantBuilder->SetPair(bstrCmd, bstrVal);
	return S_OK;
}

// The arguments are ignored.  They are just for backward compatibility to V1.0.1.2121 & its
//	successors
STDMETHODIMP CTSHOOTCtrl::RunQuery2(BSTR, BSTR, BSTR, BSTR *pbstrPage)
{
	if (GetLocked())
		return S_OK;
	
	if (m_pVariantBuilder)
	{
		RunQuery(m_pVariantBuilder->GetCommands(),
				 m_pVariantBuilder->GetValues(),
				 m_pVariantBuilder->GetSize(),
				 pbstrPage);
		delete m_pVariantBuilder;
		m_pVariantBuilder = NULL;
	}
	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::NotifyNothingChecked(BSTR bstrMessage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	CString message = W2T(bstrMessage);
	
	::MessageBox(::GetForegroundWindow(), 
				 message != _T("") ? message : _T("Please choose a button and then press Next"),
				 _T("Error"), 
				 MB_OK);

	return S_OK;
}

long CTSHOOTCtrl::PerformSniffingInternal(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs)
{
	USES_CONVERSION;
	return Fire_Sniffing(T2BSTR((LPCTSTR)strNodeName), T2BSTR((LPCTSTR)strLaunchBasis), T2BSTR((LPCTSTR)strAdditionalArgs));
}

void CTSHOOTCtrl::RenderInternal(CString strPage)
{
	USES_CONVERSION;
	Fire_Render(T2BSTR((LPCTSTR)strPage));
}

void CTSHOOTCtrl::RegisterGlobal()
{
	int nConnections = CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >::m_vec.GetSize();

	for (int nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
	{					                                                                                                                                                                                                                                                                                                                                                                                                    
		Lock();
		CComPtr<IUnknown> sp = CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >::m_vec.GetAt(nConnectionIndex);
		Unlock();
		IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
		if (pDispatch != NULL)
		{
			DWORD dwCookie;
			m_pGIT->RegisterInterfaceInGlobal(pDispatch, IID_IDispatch, &dwCookie);
			m_vecCookies.push_back(dwCookie);
		}
	}
}

STDMETHODIMP CTSHOOTCtrl::IsLocked(BOOL *pbResult)
{
	*pbResult = GetLocked() ? TRUE : FALSE;

	return S_OK;
}


// Set the locale.
// Parameter bstrNewLocale should be of the form:
//		"lang[_country[.code_page]]"
//	    | ".code_page"
//	    | ""
//	    | NULL
STDMETHODIMP CTSHOOTCtrl::setLocale2( BSTR bstrNewLocale )
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	m_strRequestedLocale= W2T( bstrNewLocale );
	m_bRequestToSetLocale= true;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\topic.cpp ===
//
// MODULE: TOPIC.CPP
//
// PURPOSE: Class CTopic brings together all of the data structures that represent a 
//			troubleshooting topic.  Most importantly, this represents the belief network,
//			but it also represents the HTI template, the data derived from the BES (back 
//			end search) file, and any other persistent data.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: 
// 1. The bulk of the methods on this class are inherited from CBeliefNetwork
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-09-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "Topic.h"
#include "propnames.h"
#include "event.h"
#include "CharConv.h"
#include "SafeTime.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#include "apgtstscread.h"
#endif
#include "apgts.h"	// Need for Local-Online macros.

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTopic::CTopic( LPCTSTR pathDSC
			   ,LPCTSTR pathHTI
			   ,LPCTSTR pathBES
			   ,LPCTSTR pathTSC ) : 
	CBeliefNetwork(pathDSC),
	m_pHTI(NULL),
	m_pBES(NULL),
	m_pathHTI(pathHTI),
	m_pathBES(pathBES),
	m_pathTSC(pathTSC),
	m_bTopicIsValid(true),
	m_bTopicIsRead(false)
{
}

CTopic::~CTopic()
{
	if (m_pHTI)
		delete m_pHTI;
	if (m_pBES)
		delete m_pBES;
}

bool CTopic::IsRead()
{
	bool ret = false;
	LOCKOBJECT();
	ret = m_bTopicIsRead;
	UNLOCKOBJECT();
	return ret;
}

bool CTopic::Read()
{
	LOCKOBJECT();
	m_bTopicIsValid = false;
	try
	{
		if (CBeliefNetwork::Read())
		{
			if (m_pHTI)
				delete m_pHTI;

			if (RUNNING_LOCAL_TS())
				m_pHTI = new CAPGTSHTIReader( CPhysicalFileReader::makeReader( m_pathHTI ), GetMultilineNetProp(H_NET_HTI_LOCAL, _T("%s\r\n")) );
			else
				m_pHTI = new CAPGTSHTIReader( new CNormalFileReader( m_pathHTI ), GetMultilineNetProp(H_NET_HTI_ONLINE, _T("%s\r\n")) );

			if (m_pHTI->Read())
			{
#ifdef LOCAL_TROUBLESHOOTER
				// it can fail reading TCS file - we don't care
				CAPGTSTSCReader( CPhysicalFileReader::makeReader( m_pathTSC ), &m_Cache ).Read();
#endif

				// at this point, we're OK, because BES is optional
				m_bTopicIsValid = true;
				
				if (m_pBES)
				{
					delete m_pBES;
					m_pBES= NULL;
				}

				CString strBESfromNet= GetMultilineNetProp( H_NET_BES, _T("%s\r\n") );
				if ((!m_pathBES.IsEmpty()) || (!strBESfromNet.IsEmpty()))
				{
					// Only allocate a BESReader for a valid filename.
					m_pBES = new CAPGTSBESReader(new CNormalFileReader(m_pathBES), strBESfromNet );
					m_pBES->Read();
				}
			}
		}
	}
	catch (bad_alloc&)
	{
		// Note memory failure in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
	}
	m_bTopicIsRead = true;
	UNLOCKOBJECT();

	return m_bTopicIsValid;
}

// should only be called in a context where we know we have a valid topic.
// Needn't lock, because m_pBES won't change once topic is read.
bool CTopic::HasBES()
{
	return (m_pBES ? true : false);
}


// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSBESReader provides its own locking
//	- m_pBES won't change once topic is read.
void CTopic::GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw)
{
	if (m_pBES)
		m_pBES->GenerateBES(arrstrIn, strEncoded, strRaw);
}

// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSHTIReader provides its own locking
//	- m_pHTI won't change once topic is read.
void CTopic::CreatePage(	const CHTMLFragments& fragments, 
							CString& out, 
							const map<CString,CString> & mapStrs,
							CString strHTTPcookies/*= _T("")*/ )
{
	if (m_pHTI)
	{
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
		time_t timeStart = 0;
		time_t timeEnd = 0;
		time(&timeStart);
#endif // SHOWPROGRESS
		m_pHTI->CreatePage(fragments, out, mapStrs, strHTTPcookies );
#ifdef SHOWPROGRESS
		time(&timeEnd);

		CString strProgress;
		CSafeTime safetimeStart(timeStart);
		CSafeTime safetimeEnd(timeEnd);
		
		strProgress = _T("\n<BR>-----------------------------");
		strProgress += _T("\n<BR>Start CTopic::CreatePage ");
		strProgress += safetimeStart.StrLocalTime();
		strProgress += _T("\n<BR>End CTopic::CreatePage ");
		strProgress += safetimeEnd.StrLocalTime();

		int i = out.Find(_T("<BODY"));
		i = out.Find(_T('>'), i);		// end of BODY tag
		if (i>=0)
		{
			out = out.Left(i+1) 
					 + strProgress 
					 + out.Mid(i+1);
		}
#endif // SHOWPROGRESS
	}
}

// JSM V3.2
// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSHTIReader provides its own locking
//	- m_pHTI won't change once topic is read.
void CTopic::ExtractNetProps(vector <CString> &arr_props)
{
	if (m_pHTI)
		m_pHTI->ExtractNetProps(arr_props);

}


// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSHTIReader provides its own locking
//	- m_pHTI won't change once topic is read.
bool CTopic::HasHistoryTable()
{
	bool ret = false;
	if (m_pHTI)
		ret = m_pHTI->HasHistoryTable();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\tshootctrl.h ===
//
// MODULE: TSHOOTCtrl.h
//
// PURPOSE: Interface for the component
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12.23.98
//
// NOTES: 
// Declaration of CTSHOOTCtrl
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		12/23/98	OK	    Windows related functionality is disabled;
//								IObjectSafetyImpl is added

#ifndef __TSHOOTCTRL_H_
#define __TSHOOTCTRL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "CPTSHOOT.h"
#include "apgtsstr.h"
#include "TSNameValueMgr.h"
#include "SniffConnector.h"
#include "RenderConnector.h"
#include <new.h>


class CDBLoadConfiguration;
class CThreadPool;
class COnlineECB;
class CPoolQueue;
class CHTMLLog;
class CLocalECB;
class CVariantBuilder;

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl
class ATL_NO_VTABLE CTSHOOTCtrl : 
	//public CComObjectRootEx<CComMultiThreadModel>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ITSHOOTCtrl, &IID_ITSHOOTCtrl, &LIBID_TSHOOTLib>,
	public CComControl<CTSHOOTCtrl>,
	public IPersistStreamInitImpl<CTSHOOTCtrl>,
	public IOleControlImpl<CTSHOOTCtrl>,
	public IOleObjectImpl<CTSHOOTCtrl>,
	public IOleInPlaceActiveObjectImpl<CTSHOOTCtrl>,
	public IViewObjectExImpl<CTSHOOTCtrl>,
	public IOleInPlaceObjectWindowlessImpl<CTSHOOTCtrl>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CTSHOOTCtrl>,
	public IPersistStorageImpl<CTSHOOTCtrl>,
	public ISpecifyPropertyPagesImpl<CTSHOOTCtrl>,
	public IQuickActivateImpl<CTSHOOTCtrl>,
	public IDataObjectImpl<CTSHOOTCtrl>,
	public IProvideClassInfo2Impl<&CLSID_TSHOOTCtrl, &DIID__ITSHOOTCtrlEvents, &LIBID_TSHOOTLib>,
	public IPropertyNotifySinkCP<CTSHOOTCtrl>,
	public CComCoClass<CTSHOOTCtrl, &CLSID_TSHOOTCtrl>,
	public CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >,
	public IObjectSafetyImpl<CTSHOOTCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public CSniffConnector,
	public CRenderConnector
{
	friend class CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >;

public:
	CTSHOOTCtrl();
	virtual ~CTSHOOTCtrl();

DECLARE_REGISTRY_RESOURCEID(IDR_TSHOOTCTRL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSHOOTCtrl)
	COM_INTERFACE_ENTRY(ITSHOOTCtrl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CTSHOOTCtrl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CTSHOOTCtrl)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
	CONNECTION_POINT_ENTRY(DIID__ITSHOOTCtrlEvents)
END_CONNECTION_POINT_MAP()

/* >>> I have commented anything related to Windows messaging
	in order to relieve the Control. Oleg. 12.23.98
BEGIN_MSG_MAP(CTSHOOTCtrl)
	CHAIN_MSG_MAP(CComControl<CTSHOOTCtrl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
*/
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_ITSHOOTCtrl,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
			if (InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	}

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ITSHOOTCtrl
public:
	STDMETHOD(NotifyNothingChecked)(/*[in]*/ BSTR bstrMessage);
	STDMETHOD(ProblemPage)(/*[out, retval]*/ BSTR * pbstrFirstPage);
	STDMETHOD(RunQuery2)(/*[in]*/ BSTR, /*[in]*/ BSTR, /*[in]*/ BSTR, /*[out, retval]*/ BSTR * pbstrPage);
	STDMETHOD(SetPair)(/*[in]*/ BSTR bstrCmd, /*[in]*/ BSTR bstrVal);
	STDMETHOD(Restart)(/*[out, retval]*/ BSTR * pbstrPage);
	STDMETHOD(PreLoadURL)(/*[in]*/ BSTR bstrRoot, /*[out, retval]*/ BSTR * pbstrPage);
	STDMETHOD(SetSniffResult)(/*[in]*/ VARIANT varNodeName, /*[in]*/ VARIANT varState, /*[out, retval]*/ BOOL * bResult);
	STDMETHOD(RunQuery)(/*[in]*/ VARIANT varCmds, /*[in]*/ VARIANT varVals, /*[in]*/ short size, /*[out, retval]*/ BSTR * pbstrPage);

/* >>> I have commented anything related to Windows messaging
	in order to relieve the Control. Oleg. 12.23.98
	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : TSHOOTCtrl");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}
*/

protected:
	static bool SendSimpleHtmlPage(CLocalECB *pLocalECB,
								   LPCTSTR pszStatus,
								   const CString& str);
	static bool SendError(CDBLoadConfiguration *pConf, 
						  CLocalECB *pLocalECB, 
						  LPCTSTR pszStatus, 
						  const CString& strMessage);

public:
	STDMETHOD(IsLocked)(/*[out, retval]*/ BOOL * pbResult);
	STDMETHOD(setLocale2)(/*[in]*/ BSTR bstrNewLocale);
	static bool RemoveStartOverButton(CString& strWriteClient);
	static bool RemoveBackButton(CString& strWriteClient);

	//static DWORD WINAPI Worker(LPVOID pParameter);

protected:
	bool Init(HMODULE hModule);
	void Destroy();

	// Launcher integration
	bool ExtractLauncherData(CString& error);
	//
	
	DWORD HttpExtensionProc(CLocalECB* pECB);
	DWORD StartRequest(CLocalECB *pLocalECB, HANDLE hImpersonationToken);
	bool SendError(CLocalECB *pLocalECB,
				   LPCTSTR pszStatus,
				   const CString & strMessage) const;
	bool ReadStaticPageFile(const CString& strTopicName, CString& strContent);

	void RegisterGlobal();

protected:
	virtual long PerformSniffingInternal(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs);
	virtual void RenderInternal(CString strPage);

protected:
	_PNH	m_SetNewHandlerPtr;	//	Used to store the initial _set_new_handler pointer.
	int		m_SetNewMode;		//	Used to store the initial _set_new_mode value which
								//	is then restored in the destructor. 

protected:	
	bool m_bInitialized;
	bool m_bFirstCall;

	CThreadPool* m_pThreadPool;		// thread management
	CPoolQueue*  m_poolctl;			// Keeps track of user requests queued up to be serviced 
									//	by working threads (a.k.a. "pool threads")
	CDBLoadConfiguration* m_pConf;	// manages loading support files
	CHTMLLog* m_pLog;				// manages user logging: what was requested by end user
	DWORD m_dwErr;					// general error status. 0 - OK.  Once set, never gets 
	bool m_bShutdown;				// Set true to say we're shutting down & can't handle 
									//  new requests.
	DWORD m_dwRollover;				// We increment this each time we make a WORK_QUEUE_ITEM so
									// we can use it there as a unique ID (unique as long as
									// this DLL stays loaded).
	CString m_strFirstPage;			// First page, saved when RunQuery is invoked 
									//  for the first time
	bool m_bStartedFromLauncher;    // true if started from the Launcher,
									//  false (from static page) by default
	CString m_strTopicName;			// topic name - only one topic for Local TS

	CArrNameValue m_arrNameValueFromLauncher; // array of name - value pairs, extracted from Launcher

	// passed from Launcher
	//  and can be used for sniffing
	CString m_strMachineID;
	CString m_strPNPDeviceID;
	CString m_strDeviceInstanceID;
	CString m_strGuidClass;

	CVariantBuilder * m_pVariantBuilder;

	CString m_strRequestedLocale;	// Used to hold the requested locale string.
									// Could be null, hence the bool variable
									// m_bRequestToSetLocale.
	bool	m_bRequestToSetLocale;	// Set to true when a request to set the locale
									// is made, set to false after the LocalECB 
									// object has been created.  Initially set to false.

	vector<DWORD> m_vecCookies;
	IGlobalInterfaceTable* m_pGIT;
	bool m_bCanRegisterGlobal;
};

#endif //__TSHOOTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\tsnamevaluemgr.cpp ===
// TSNameValueMgr.cpp: implementation of the CTSNameValueMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSNameValueMgr.h"
#include "apgtsassert.h"
#include "functions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTSNameValueMgr::CTSNameValueMgr(const VARIANT& name, const VARIANT& value, int count)
			   : m_bIsValid(true),
				 m_pvarNames(NULL),
				 m_pvarValues(NULL),
				 m_nCount(count)
{
	try {
		Initialize(name, value, count);
		FormDataFromArray();
	}
	catch (exception& /*x*/)
	{
		// catch custom exception (our custon exceptions are normally inherited from STL exception class
		m_bIsValid = false;
		/* 
		CString str;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION );
		*/
	}
}

CTSNameValueMgr::CTSNameValueMgr(const CArrNameValue& arr)
			   : m_bIsValid(true),
				 m_pvarNames(NULL),
				 m_pvarValues(NULL),
				 m_nCount(arr.size()),
				 m_arrNameValue(arr)
{
	FormDataFromArray();
}

CTSNameValueMgr::CTSNameValueMgr()
			   : m_bIsValid(true),
				 m_pvarNames(NULL),
				 m_pvarValues(NULL),
				 m_nCount(0)
{
}

CTSNameValueMgr::~CTSNameValueMgr()
{
}

void CTSNameValueMgr::Initialize(const VARIANT& varCmds, const VARIANT& varVals, int size)
{
	USES_CONVERSION;

	const VARIANT* pVarCmds;
	const VARIANT* pVarVals;

	if (VT_BYREF  == (VT_BYREF & varCmds.vt) && // ???
		VT_VARIANT == (VT_VARIANT & varCmds.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varCmds.vt))
			pVarCmds = &varCmds;
		else
			pVarCmds = varCmds.pvarVal;
	}
	else
	{
		pVarCmds = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}
	
	if (VT_BYREF  == (VT_BYREF & varVals.vt) && // ???
		VT_VARIANT == (VT_VARIANT & varVals.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varVals.vt))
			pVarVals = &varVals;
		else
			pVarVals = varVals.pvarVal;
	}
	else
	{
		pVarVals = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	if (VT_BYREF  != (VT_BYREF & pVarCmds->vt) ||
		VT_ARRAY != (VT_ARRAY & pVarCmds->vt) ||
		VT_VARIANT != (0xFFF & pVarCmds->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	if (VT_BYREF  != (VT_BYREF & pVarVals->vt) ||
		VT_ARRAY != (VT_ARRAY & pVarVals->vt) ||
		VT_VARIANT != (0xFFF & pVarVals->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	SAFEARRAY *pArrCmds = *(pVarCmds->pparray);
	SAFEARRAY *pArrVals = *(pVarVals->pparray);

	if (0 != pArrCmds->rgsabound[0].lLbound || 0 != pArrVals->rgsabound[0].lLbound)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Lower bounds are wrong.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}
	if (pArrCmds->rgsabound[0].cElements != pArrVals->rgsabound[0].cElements)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Cmds upperbound != Vals upperbound.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	m_nCount = size;
	m_pvarNames  = (VARIANT *) pArrCmds->pvData;
	m_pvarValues = (VARIANT *) pArrVals->pvData;

	if (0 != m_nCount)
	{
		if (m_pvarNames->vt != VT_BSTR || m_pvarValues->vt != VT_BSTR)
		{
			CString str;
			str.Format(_T("Wrong Cmd parameters passed from VB.  Array of unexpected type.\n\n")
				_T("Cmd Type: %s\nVal Type: %s"),
				(LPCTSTR) DecodeVariantTypes(m_pvarNames->vt),
				(LPCTSTR) DecodeVariantTypes(m_pvarValues->vt));
			ASSERT(FALSE);
			throw exception((const char*)str);
		}
	}	

	m_arrNameValue.clear();
	m_strData = _T("");
	
	// Extract the last name in order to check and remove any previous references to that name.
	// If there is only one name, there is no need to extract the name.
	CString strLastName;
	if (m_nCount > 1)
		strLastName= W2T( m_pvarNames[ m_nCount - 1 ].bstrVal );

	for (int i = 0; i < m_nCount; i++)
	{
		CString name  = W2T(m_pvarNames[i].bstrVal);
		CString value = W2T(m_pvarValues[i].bstrVal);

		if (0 == _tcsicmp(name, _T("TShootProblem")))
			name = _T("ProblemAsk");

		if (i == 0) // "value" contains network name
			value.MakeLower(); // for compatibility with Online TS, where network name 
							   //  is forced lower case

		// Check if we need to remove any previous reference to the last name.
		if ((i == (m_nCount - 1)) || (strLastName != name))
		{
			CNameValue name_value;
			name_value.strName  = name;
			name_value.strValue = value;
			m_arrNameValue.push_back(name_value);
		}
	}
}

bool CTSNameValueMgr::IsValid() const
{
	return m_bIsValid;
}

const CString& CTSNameValueMgr::GetData() const
{
	return m_strData;
}

int	CTSNameValueMgr::GetCount() const
{
	return m_nCount;
}

CNameValue CTSNameValueMgr::GetNameValue(int i) const
{
	if (i < 0 || i >= m_arrNameValue.size())
		return CNameValue();
	return m_arrNameValue[i];
}

void CTSNameValueMgr::FormDataFromArray()
{
	m_strData = _T("");

	for (CArrNameValue::iterator i = m_arrNameValue.begin(); i != m_arrNameValue.end(); i++)
	{
		m_strData += (*i).strName;
		m_strData += _T("=");
		m_strData += (*i).strValue;
		if (i != m_arrNameValue.end() - 1/*??? or decrement???*/) // it is not last pass through the loop
			m_strData += _T("&");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\variantbuilder.cpp ===
//
// MODULE: VariantBuilder.cpp
//
// PURPOSE: implementation of the CVariantBuilder class.  Allows us to construct
//	a pair of arrays for the name-value pairs to be passed to RunQuery.  This lets
//	JScript sanely use a system that was mostly designed for VB Script.
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 02.01.99
//
// NOTES: 
// Implementation of CTSHOOTCtrl
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		02.01.99	JM	    


#include "stdafx.h"
#include "VariantBuilder.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVariantBuilder::CVariantBuilder()
{
	VariantInit(&m_varCommands);
	VariantInit(&m_varValues);
	VariantInit(&m_varCommandsWrap);
	VariantInit(&m_varValuesWrap);

	V_VT(&m_varCommands) = VT_ARRAY | VT_BYREF | VT_VARIANT; 
	V_VT(&m_varValues) = VT_ARRAY | VT_BYREF | VT_VARIANT; 
	V_ARRAYREF(&m_varCommands) = &m_psafearrayCmds; 
	V_ARRAYREF(&m_varValues) = &m_psafearrayVals; 

	V_VT(&m_varCommandsWrap) = VT_BYREF | VT_VARIANT; 
	V_VT(&m_varValuesWrap) = VT_BYREF | VT_VARIANT; 

	V_VARIANTREF(&m_varCommandsWrap) = &m_varCommands;
	V_VARIANTREF(&m_varValuesWrap) = &m_varValues;

	SAFEARRAYBOUND sabCmd;
	sabCmd.cElements = k_cMaxElements;
	sabCmd.lLbound = 0;
	SAFEARRAYBOUND sabVal = sabCmd;

	// create two vectors of VARIANTs to wrap BSTRs
	m_psafearrayCmds = SafeArrayCreate( VT_VARIANT, 1, &sabCmd);
	m_psafearrayVals = SafeArrayCreate( VT_VARIANT, 1, &sabVal);

	m_cElements = 0;
}

CVariantBuilder::~CVariantBuilder()
{
	SafeArrayDestroy(m_psafearrayCmds);
	SafeArrayDestroy(m_psafearrayVals);

	VariantClear(&m_varCommands);
	VariantClear(&m_varValues);
	VariantClear(&m_varCommandsWrap);
	VariantClear(&m_varValuesWrap);
}

// effectively, add a name-value pair to the arrays.
// If the array is full (which should never happen in the real world) silently fails.
void CVariantBuilder::SetPair(BSTR bstrCmd, BSTR bstrVal)
{
	if (m_cElements < k_cMaxElements)
	{
		VariantInit(&m_pvarCmd[m_cElements]);
		VariantInit(&m_pvarVal[m_cElements]);
		V_VT(&m_pvarCmd[m_cElements]) = VT_BSTR;
		V_VT(&m_pvarVal[m_cElements]) = VT_BSTR;
		m_pvarCmd[m_cElements].bstrVal=bstrCmd;
		m_pvarVal[m_cElements].bstrVal=bstrVal;
		
		SafeArrayPutElement(m_psafearrayCmds, &m_cElements, &m_pvarCmd[m_cElements]);
		SafeArrayPutElement(m_psafearrayVals, &m_cElements, &m_pvarVal[m_cElements]);

		++m_cElements;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\versioninfo.cpp ===
//
// MODULE: VersionInfo.CPP

// PURPOSE This module reads version info from the resource file.

// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 
//
// NOTES: 
// 1. Took it from Argon Project.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0				    OK
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "VersionInfo.h"

//								
LPCWSTR FindStr(LPCWSTR wszString, LPCWSTR wszCharSet, const DWORD dwStringLen)
{
	LPCWSTR wszRetStr = NULL;
	int x;
	int SetLen;
	DWORD dwCheck = 0;
	DWORD dwCur = 0;	
	if (NULL != wszCharSet && NULL != wszString)
	{
		SetLen = wcslen(wszCharSet);
		do
		{
			for (x = 0; x < SetLen; x++)
			{
				if (wszString[dwCheck] != wszCharSet[x])									
					break;				
				dwCheck++;
			}
			if (x == SetLen)
			{
				wszRetStr = &wszString[dwCur];
				break;			
			}
			else
			{
				dwCur++;
				dwCheck = dwCur;
			}
		} while (dwCur < dwStringLen);
	}
	return wszRetStr;
}

LPCWSTR GetVersionInfo(HINSTANCE hInst, LPWSTR wszStrName)
{
	LPCWSTR pwszFileVersion;
	LPCWSTR pwszStrInfo = NULL;
	LPWSTR pwszVerInfo = NULL;
	DWORD dwDataLen = 0;
	LPCTSTR lpName = (LPTSTR)	VS_VERSION_INFO;
	HRSRC hVerInfo = FindResource(hInst, lpName, RT_VERSION);
	if (NULL != hVerInfo)
	{
		HGLOBAL hVer = LoadResource(hInst, hVerInfo);
		if (NULL != hVer)
		{
			pwszVerInfo = (LPWSTR) LockResource(hVer);
			if (NULL != pwszVerInfo)
			{
				dwDataLen = SizeofResource(hInst, hVerInfo);
				if (NULL != (pwszFileVersion = FindStr(pwszVerInfo, wszStrName, dwDataLen / sizeof(WCHAR))))
				{
					pwszStrInfo = pwszFileVersion + wcslen(pwszFileVersion);
					while (NULL == *pwszStrInfo)
						pwszStrInfo++;
				}					
			}
		}
	}
	return pwszStrInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\variantbuilder.h ===
//
// MODULE: VariantBuilder.h
//
// PURPOSE: interface for the CVariantBuilder class.  Allows us to construct
//	a pair of arrays for the name-value pairs to be passed to RunQuery.  This lets
//	JScript sanely use a system that was mostly designed for VB Script.
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 02.01.99
//
// NOTES: 
// Implementation of CTSHOOTCtrl
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		02.01.99	JM	    

#if !defined(AFX_VARIANTBUILDER_H__901D987E_BA1C_11D2_9663_00C04FC22ADD__INCLUDED_)
#define AFX_VARIANTBUILDER_H__901D987E_BA1C_11D2_9663_00C04FC22ADD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CVariantBuilder  
{
private:
	VARIANT m_varCommands;
	VARIANT m_varValues;
	VARIANT m_varCommandsWrap;
	VARIANT m_varValuesWrap;
	SAFEARRAY *m_psafearrayCmds;
	SAFEARRAY *m_psafearrayVals;
	long m_cElements;
	enum {k_cMaxElements = 100};// safely large: allows this many calls to CVariantBuilder::SetPair()
	VARIANT m_pvarCmd[k_cMaxElements];
	VARIANT m_pvarVal[k_cMaxElements];

public:
	CVariantBuilder();
	~CVariantBuilder();
	void SetPair(BSTR bstrCmd, BSTR bstrVal);

	const VARIANT& GetCommands() const {return m_varCommandsWrap;}
	const VARIANT& GetValues() const {return m_varValuesWrap;}
	long GetSize() const {return m_cElements;}

};

#endif // !defined(AFX_VARIANTBUILDER_H__901D987E_BA1C_11D2_9663_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\versioninfo.h ===
//
// MODULE: VersionInfo.h

// PURPOSE This module reads version info from the resource file.

// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 
//
// NOTES: 
// 1. Took it from Argon Project.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0				    OK

#include<windows.h>
#include "apgtsstr.h"

// FindStr: Does a strstr but works on files that have embedded null characters.
LPCWSTR FindStr(LPCWSTR wszString, LPCWSTR wszCharSet, const DWORD dwStringLen);

// GetVersionInfo:  Reads the version info.
// Input:  hInst -	The handle returned from AfxGetResourceHandle() 
//					or the handle that was passed to DllMain.
//			wszStrName - The name of the resource that is desired.
// GetVersionInfo(g_hInst, L"FileVersion")		Returns the FileVersion.
// NULL will be returned if the function fails.
LPCWSTR GetVersionInfo(HINSTANCE hInst, LPWSTR wszStrName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\troubleshoot\tshoot\tsnamevaluemgr.h ===
// TSNameValueMgr.h: interface for the CTSNameValueMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TSNAMEVALUEMGR_H__0AB724C3_AA78_11D2_8C82_00C04F949D33__INCLUDED_)
#define AFX_TSNAMEVALUEMGR_H__0AB724C3_AA78_11D2_8C82_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>
#include "apgtsstr.h"

using namespace std;

struct CNameValue;
typedef vector<CNameValue> CArrNameValue;

struct CNameValue
{
	CString strName;
	CString strValue;
};

class CTSNameValueMgr  
{
private:
	VARIANT* m_pvarNames;
	VARIANT* m_pvarValues;
	int		 m_nCount;

	bool	 m_bIsValid;
	CString	 m_strData;
	CArrNameValue m_arrNameValue;

public:
	CTSNameValueMgr(const VARIANT& name, const VARIANT& value, int count);
	CTSNameValueMgr(const CArrNameValue& arr);
	CTSNameValueMgr();
	virtual ~CTSNameValueMgr();

protected:
	void Initialize(const VARIANT& name, const VARIANT& value, int count);

public:
	bool		IsValid()  const;
	const CString& GetData() const;
	int			GetCount() const;
	CNameValue 	GetNameValue(int) const;

protected:
	void FormDataFromArray();
};

#endif // !defined(AFX_TSNAMEVALUEMGR_H__0AB724C3_AA78_11D2_8C82_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\comraise.cpp ===
//
// Throw a com_error object.  In a separate file so users can easily define
// their own to replace this one.
//

#include <comdef.h>

#pragma hdrstop

#pragma warning(disable:4290)

void __stdcall
_com_raise_error(HRESULT hr, IErrorInfo* perrinfo) throw(_com_error)
{
	throw _com_error(hr, perrinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\comdef.h ===
/***
* comdef.h - Native C++ compiler COM support - main definitions header
*
*       Copyright (C) 1996-1999 Microsoft Corporation
*       All rights reserved.
*
****/

#if !defined(_INC_COMDEF)
#define _INC_COMDEF

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef  __cplusplus
#error Native Compiler support only available in C++ compiler
#endif

#include <ole2.h>
#include <olectl.h>

#include <comutil.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4244)
#pragma warning(disable: 4290)

#pragma comment(lib, "comsupp.lib")

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")

class _com_error;

void __stdcall
        _com_raise_error(HRESULT hr, IErrorInfo* perrinfo = 0) throw(_com_error);

void __stdcall
        _com_issue_error(HRESULT) throw(_com_error);
void __stdcall
        _com_issue_errorex(HRESULT, IUnknown*, REFIID) throw(_com_error);

HRESULT __stdcall
        _com_dispatch_propget(IDispatch*, DISPID, VARTYPE, void*) throw(_com_error);
HRESULT __cdecl
        _com_dispatch_propput(IDispatch*, DISPID, VARTYPE, ...) throw(_com_error);
HRESULT __cdecl
        _com_dispatch_method(IDispatch*, DISPID, WORD, VARTYPE, void*,
                                                 const wchar_t*, ...) throw(_com_error);

HRESULT __stdcall
        _com_dispatch_raw_propget(IDispatch*, DISPID, VARTYPE, void*) throw();
HRESULT __cdecl
        _com_dispatch_raw_propput(IDispatch*, DISPID, VARTYPE, ...) throw();
HRESULT __cdecl
        _com_dispatch_raw_method(IDispatch*, DISPID, WORD, VARTYPE, void*,
                                                         const wchar_t*, ...) throw();

class _com_error {
public:
        // Constructors
        //
        _com_error(HRESULT hr,
               IErrorInfo* perrinfo = NULL,
               bool fAddRef = false) throw();
        _com_error(const _com_error& that) throw();

        // Destructor
        //
        virtual ~_com_error() throw();

        // Assignment operator
        //
        _com_error& operator=(const _com_error& that) throw();

        // Accessors
        //
        HRESULT Error() const throw();
        WORD WCode() const throw();
        IErrorInfo * ErrorInfo() const throw();

        // IErrorInfo method accessors
        //
        _bstr_t Description() const throw(_com_error);
        DWORD HelpContext() const throw();
        _bstr_t HelpFile() const throw(_com_error);
        _bstr_t Source() const throw(_com_error);
        GUID GUID() const throw();

        // FormatMessage accessors
        const TCHAR * ErrorMessage() const throw();

        // EXCEPINFO.wCode <-> HRESULT mappers
        static HRESULT WCodeToHRESULT(WORD wCode) throw();
        static WORD HRESULTToWCode(HRESULT hr) throw();

private:
        enum {
                WCODE_HRESULT_FIRST = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200),
                WCODE_HRESULT_LAST = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF+1, 0) - 1
        };
        const HRESULT                   m_hresult;
        IErrorInfo *                    m_perrinfo;
        mutable TCHAR *                 m_pszMsg;
};

inline _com_error::_com_error(HRESULT hr,
                              IErrorInfo* perrinfo,
                              bool fAddRef) throw()
        : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)
{
        if (m_perrinfo != NULL && fAddRef) {
                m_perrinfo->AddRef();
        }
}

inline _com_error::_com_error(const _com_error& that) throw()
        : m_hresult(that.m_hresult), m_perrinfo(that.m_perrinfo), m_pszMsg(NULL)
{
        if (m_perrinfo != NULL) {
                m_perrinfo->AddRef();
        }
}

inline _com_error::~_com_error() throw()
{
        if (m_perrinfo != NULL) {
                m_perrinfo->Release();
        }
        if (m_pszMsg != NULL) {
                LocalFree((HLOCAL)m_pszMsg);
        }
}

inline _com_error& _com_error::operator=(const _com_error& that) throw()
{
        if (this != &that) {
                this->_com_error::~_com_error();
                this->_com_error::_com_error(that);
        }
        return *this;
}

inline HRESULT _com_error::Error() const throw()
{
        return m_hresult;
}

inline WORD _com_error::WCode() const throw()
{
        return HRESULTToWCode(m_hresult);
}

inline IErrorInfo * _com_error::ErrorInfo() const throw()
{
        if (m_perrinfo != NULL) {
                m_perrinfo->AddRef();
        }
        return m_perrinfo;
}

inline _bstr_t _com_error::Description() const throw(_com_error)
{
        BSTR bstr = NULL;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetDescription(&bstr);
        }
        return _bstr_t(bstr, false);
}

inline DWORD _com_error::HelpContext() const throw()
{
        DWORD dwHelpContext = 0;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetHelpContext(&dwHelpContext);
        }
        return dwHelpContext;
}

inline _bstr_t _com_error::HelpFile() const throw(_com_error)
{
        BSTR bstr = NULL;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetHelpFile(&bstr);
        }
        return _bstr_t(bstr, false);
}

inline _bstr_t _com_error::Source() const throw(_com_error)
{
        BSTR bstr = NULL;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetSource(&bstr);
        }
        return _bstr_t(bstr, false);
}

inline _GUID _com_error::GUID() const throw()
{
        _GUID guid;
        memcpy(&guid, &__uuidof(NULL), sizeof(_GUID));
        if (m_perrinfo != NULL) {
                m_perrinfo->GetGUID(&guid);
        }
        return guid;
}

inline const TCHAR * _com_error::ErrorMessage() const throw()
{
        if (m_pszMsg == NULL) {
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
                                          NULL,
                                          m_hresult,
                                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                          (LPTSTR)&m_pszMsg,
                                          0,
                                          NULL );
                if (m_pszMsg != NULL) {
                        int nLen = lstrlen(m_pszMsg);
                        if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {
                                m_pszMsg[nLen - 1] = 0;
                                if (m_pszMsg[nLen - 2] == '\r') {
                                        m_pszMsg[nLen - 2] = 0;
                                }
                        }
                } else {
                        m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));
                        if (m_pszMsg != NULL) {
                                WORD wCode = WCode();
#ifdef _STRSAFE_H_INCLUDED_
                                if (wCode != 0) {
                                    StringCchPrintf(m_pszMsg, 32, TEXT("IDispatch error #%d"), wCode);
                                } else {
                                    StringCchPrintf(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);
                                }
#else
                                if (wCode != 0) {
                                        wsprintf(m_pszMsg, TEXT("IDispatch error #%d"), wCode);
                                } else {
                                        wsprintf(m_pszMsg, TEXT("Unknown error 0x%0lX"), m_hresult);
                                }
#endif
                        }
                }
        }
        return m_pszMsg;
}

inline HRESULT _com_error::WCodeToHRESULT(WORD wCode) throw()
{
        return wCode >= 0xFE00 ? WCODE_HRESULT_LAST : WCODE_HRESULT_FIRST + wCode;
}

inline WORD _com_error::HRESULTToWCode(HRESULT hr) throw()
{
        return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)
                ? WORD(hr - WCODE_HRESULT_FIRST)
                : 0;
}

#if !defined(_COM_SMARTPTR)
 #if !defined(_INC_COMIP)
  #include <comip.h>
 #endif
 #define _COM_SMARTPTR        _com_ptr_t
 #define _COM_SMARTPTR_LEVEL2 _com_IIID
#endif
#if defined(_COM_SMARTPTR)
 #if !defined(_COM_SMARTPTR_TYPEDEF)
  #if defined(_COM_SMARTPTR_LEVEL2)
   #define _COM_SMARTPTR_TYPEDEF(Interface, IID) \
    typedef _COM_SMARTPTR<_COM_SMARTPTR_LEVEL2<Interface, &IID> > \
            Interface ## Ptr
  #else
   #define _COM_SMARTPTR_TYPEDEF(Interface, IID) \
    typedef _COM_SMARTPTR<Interface, &IID> \
            Interface ## Ptr
  #endif
 #endif
#endif

#if !defined(_COM_NO_STANDARD_GUIDS_)

#ifdef _WIN64
#define     IActiveScriptParse                  IActiveScriptParse64
#define     IActiveScriptParseProcedureOld      IActiveScriptParseProcedureOld64
#define     IActiveScriptParseProcedure         IActiveScriptParseProcedure64
#define     IActiveScriptParseProcedure2        IActiveScriptParseProcedure2_64
#else
#define     IActiveScriptParse                  IActiveScriptParse32
#define     IActiveScriptParseProcedureOld      IActiveScriptParseProcedureOld32
#define     IActiveScriptParseProcedure         IActiveScriptParseProcedure32
#define     IActiveScriptParseProcedure2        IActiveScriptParseProcedure2_32
#endif

// Interfaces:

struct __declspec(uuid("0000013D-0000-0000-C000-000000000046")) IClientSecurity;
struct __declspec(uuid("0000013E-0000-0000-C000-000000000046")) IServerSecurity;
struct __declspec(uuid("00000140-0000-0000-C000-000000000046")) IClassActivator;
struct __declspec(uuid("00020d00-0000-0000-c000-000000000046")) IRichEditOle;
struct __declspec(uuid("00020d03-0000-0000-c000-000000000046")) IRichEditOleCallback;
struct __declspec(uuid("000214e1-0000-0000-c000-000000000046")) INewShortcutHookA;
struct __declspec(uuid("000214e2-0000-0000-c000-000000000046")) IShellBrowser;
struct __declspec(uuid("000214e3-0000-0000-c000-000000000046")) IShellView;
struct __declspec(uuid("000214e4-0000-0000-c000-000000000046")) IContextMenu;
struct __declspec(uuid("000214e5-0000-0000-c000-000000000046")) IShellIcon;
struct __declspec(uuid("000214e6-0000-0000-c000-000000000046")) IShellFolder;
struct __declspec(uuid("000214e8-0000-0000-c000-000000000046")) IShellExtInit;
struct __declspec(uuid("000214e9-0000-0000-c000-000000000046")) IShellPropSheetExt;
struct __declspec(uuid("000214ea-0000-0000-c000-000000000046")) IPersistFolder;
struct __declspec(uuid("000214eb-0000-0000-c000-000000000046")) IExtractIconA;
struct __declspec(uuid("000214ee-0000-0000-c000-000000000046")) IShellLinkA;
struct __declspec(uuid("000214f0-0000-0000-c000-000000000046")) IFileViewerA;
struct __declspec(uuid("000214f1-0000-0000-c000-000000000046")) ICommDlgBrowser;
struct __declspec(uuid("000214f2-0000-0000-c000-000000000046")) IEnumIDList;
struct __declspec(uuid("000214f3-0000-0000-c000-000000000046")) IFileViewerSite;
struct __declspec(uuid("000214f4-0000-0000-c000-000000000046")) IContextMenu2;
struct __declspec(uuid("000214f5-0000-0000-c000-000000000046")) IShellExecuteHookA;
struct __declspec(uuid("000214f7-0000-0000-c000-000000000046")) INewShortcutHookW;
struct __declspec(uuid("000214f8-0000-0000-c000-000000000046")) IFileViewerW;
struct __declspec(uuid("000214f9-0000-0000-c000-000000000046")) IShellLinkW;
struct __declspec(uuid("000214fa-0000-0000-c000-000000000046")) IExtractIconW;
struct __declspec(uuid("000214fb-0000-0000-c000-000000000046")) IShellExecuteHookW;
struct __declspec(uuid("00021500-0000-0000-c000-000000000046")) IQueryInfo;
struct __declspec(uuid("0002DF05-0000-0000-C000-000000000046")) IWebBrowserApp;
struct __declspec(uuid("0002E000-0000-0000-C000-000000000046")) IEnumGUID;
struct __declspec(uuid("0002E011-0000-0000-C000-000000000046")) IEnumCATEGORYINFO;
struct __declspec(uuid("0002E012-0000-0000-C000-000000000046")) ICatRegister;
struct __declspec(uuid("0002E013-0000-0000-C000-000000000046")) ICatInformation;
struct __declspec(uuid("012dd920-7b26-11d0-8ca9-00a0c92dbfe8")) IDockingWindow;
struct __declspec(uuid("3050f4e9-98b5-11cf-bb82-00aa00bdce0b")) IHTMLControlElement;
struct __declspec(uuid("085FB2C0-0DF8-11D1-8F4B-00A0C905413F")) ISubscriptionMgr;
struct __declspec(uuid("08EC3E00-50B0-11CF-960C-0080C7F4EE85")) FolderItemVerb;
struct __declspec(uuid("0c6c4200-c589-11d0-999a-00c04fd655e1")) IShellIconOverlayIdentifier;
struct __declspec(uuid("1008C4A0-7613-11CF-9AF1-0020AF6E72F4")) IChannelHook;
struct __declspec(uuid("163BB1E0-6E00-11CF-837A-48DC04C10000")) IHTMLLocation;
struct __declspec(uuid("1CFF0050-6FDD-11D0-9328-00A0C90DCAA9")) IActiveScriptParseProcedureOld32;
struct __declspec(uuid("1F8352C0-50B0-11CF-960C-0080C7F4EE85")) FolderItemVerbs;
struct __declspec(uuid("1ac3d9f0-175c-11d1-95be-00609797ea4f")) IPersistFolder2;
struct __declspec(uuid("21F57128-08C9-4638-BA12-22D15D88DC5C")) IActiveScriptParseProcedureOld64;
struct __declspec(uuid("275C23E1-3747-11D0-9FEA-00AA003F8646")) IMultiLanguage;
struct __declspec(uuid("275C23E3-3747-11D0-9FEA-00AA003F8646")) IEnumCodePage;
struct __declspec(uuid("2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8")) IDockingWindowSite;
struct __declspec(uuid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBodyElement;
struct __declspec(uuid("3050F1D9-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontElement;
struct __declspec(uuid("3050F1DA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAnchorElement;
struct __declspec(uuid("3050F1DD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLUListElement;
struct __declspec(uuid("3050F1DE-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOListElement;
struct __declspec(uuid("3050F1E0-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLIElement;
struct __declspec(uuid("3050F1F0-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBRElement;
struct __declspec(uuid("3050F1F1-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDListElement;
struct __declspec(uuid("3050F1F2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDDElement;
struct __declspec(uuid("3050F1F3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDTElement;
struct __declspec(uuid("3050F1F4-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLHRElement;
struct __declspec(uuid("3050F1F5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLParaElement;
struct __declspec(uuid("3050F1F6-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLHeaderElement;
struct __declspec(uuid("3050F1F7-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFormElement;
struct __declspec(uuid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLElement;
struct __declspec(uuid("3050F200-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDivElement;
struct __declspec(uuid("3050F202-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBaseFontElement;
struct __declspec(uuid("3050F203-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMetaElement;
struct __declspec(uuid("3050F204-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBaseElement;
struct __declspec(uuid("3050F205-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLinkElement;
struct __declspec(uuid("3050F206-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLIsIndexElement;
struct __declspec(uuid("3050F207-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLNextIdElement;
struct __declspec(uuid("3050F208-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBlockElement;
struct __declspec(uuid("3050F209-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLUnknownElement;
struct __declspec(uuid("3050F20A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLPhraseElement;
struct __declspec(uuid("3050F20C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLCommentElement;
struct __declspec(uuid("3050F20E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLListElement;
struct __declspec(uuid("3050F211-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionElement;
struct __declspec(uuid("3050F212-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDivPosition;
struct __declspec(uuid("3050F216-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDialog;
struct __declspec(uuid("3050F218-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextElement;
struct __declspec(uuid("3050F21E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTable;
struct __declspec(uuid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLElementCollection;
struct __declspec(uuid("3050F220-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTxtRange;
struct __declspec(uuid("3050F230-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextContainer;
struct __declspec(uuid("3050F23A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCol;
struct __declspec(uuid("3050F23B-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableSection;
struct __declspec(uuid("3050F23C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableRow;
struct __declspec(uuid("3050F23D-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCell;
struct __declspec(uuid("3050F240-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLImgElement;
struct __declspec(uuid("3050F244-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSelectElement;
struct __declspec(uuid("3050F24F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLObjectElement;
struct __declspec(uuid("3050F25A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSelectionObject;
struct __declspec(uuid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyle;
struct __declspec(uuid("3050F25F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLEmbedElement;
struct __declspec(uuid("3050F265-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAreaElement;
struct __declspec(uuid("3050F266-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMapElement;
struct __declspec(uuid("3050F28B-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLScriptElement;
struct __declspec(uuid("3050F29C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLControlRange;
struct __declspec(uuid("3050F2A4-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputHiddenElement;
struct __declspec(uuid("3050F2A6-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputTextElement;
struct __declspec(uuid("3050F2AA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextAreaElement;
struct __declspec(uuid("3050F2AD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputFileElement;
struct __declspec(uuid("3050F2B2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputButtonElement;
struct __declspec(uuid("3050F2B5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMarqueeElement;
struct __declspec(uuid("3050F2BB-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLButtonElement;
struct __declspec(uuid("3050F2BC-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionButtonElement;
struct __declspec(uuid("3050F2C2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputImage;
struct __declspec(uuid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheet;
struct __declspec(uuid("3050F2E5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetRulesCollection;
struct __declspec(uuid("3050F2EB-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCaption;
struct __declspec(uuid("3050F2F4-98B5-11CF-BB82-00AA00BDCE0B")) IViewFilterSite;
struct __declspec(uuid("3050F311-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameBase;
struct __declspec(uuid("3050F313-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameElement;
struct __declspec(uuid("3050F315-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLIFrameElement;
struct __declspec(uuid("3050F319-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameSetElement;
struct __declspec(uuid("3050F322-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTitleElement;
struct __declspec(uuid("3050F32A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLabelElement;
struct __declspec(uuid("3050F32D-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLEventObj;
struct __declspec(uuid("3050F357-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetRule;
struct __declspec(uuid("3050F35C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLScreen;
struct __declspec(uuid("3050F35F-98B5-11CF-BB82-00AA00BDCE0B")) ITimerService;
struct __declspec(uuid("3050F360-98B5-11CF-BB82-00AA00BDCE0B")) ITimer;
struct __declspec(uuid("3050F361-98B5-11CF-BB82-00AA00BDCE0B")) ITimerSink;
struct __declspec(uuid("3050F369-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBGsound;
struct __declspec(uuid("3050F372-98B5-11CF-BB82-00AA00BDCE0B")) IViewTransition;
struct __declspec(uuid("3050F373-98B5-11CF-BB82-00AA00BDCE0B")) IViewTransitionSite;
struct __declspec(uuid("3050F375-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleElement;
struct __declspec(uuid("3050F376-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontNamesCollection;
struct __declspec(uuid("3050F377-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontSizesCollection;
struct __declspec(uuid("3050F378-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionsHolder;
struct __declspec(uuid("3050F37E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetsCollection;
struct __declspec(uuid("3050F383-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAreasCollection;
struct __declspec(uuid("3050F38A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLNoShowElement;
struct __declspec(uuid("3050F38C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionElementFactory;
struct __declspec(uuid("3050F38E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLImageElementFactory;
struct __declspec(uuid("3050F3CF-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLRuleStyle;
struct __declspec(uuid("3050F3D5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleFontFace;
struct __declspec(uuid("3050F3E5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSpanFlow;
struct __declspec(uuid("3050F3E7-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFieldSetElement;
struct __declspec(uuid("3050F3EA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLegendElement;
struct __declspec(uuid("3050F3EC-98B5-11CF-BB82-00AA00BDCE0B")) ICSSFilter;
struct __declspec(uuid("3050F3ED-98B5-11CF-BB82-00AA00BDCE0B")) ICSSFilterSite;
struct __declspec(uuid("3050F3EE-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFiltersCollection;
struct __declspec(uuid("3050F3F0-98B5-11CF-BB82-00AA00BDCE0B")) ICustomDoc;
struct __declspec(uuid("3050F3F2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDatabinding;
struct __declspec(uuid("3050F3F3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSpanElement;
struct __declspec(uuid("3050F3FC-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMimeTypesCollection;
struct __declspec(uuid("3050F3FD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLPluginsCollection;
struct __declspec(uuid("3050F401-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOpsProfile;
struct __declspec(uuid("3050f3d7-98b5-11cf-bb82-00aa00bdce0b")) IImgCtx;
struct __declspec(uuid("332C4425-26CB-11D0-B483-00C04FD90119")) IHTMLDocument2;
struct __declspec(uuid("332C4426-26CB-11D0-B483-00C04FD90119")) IHTMLFramesCollection2;
struct __declspec(uuid("332C4427-26CB-11D0-B483-00C04FD90119")) IHTMLWindow2;
struct __declspec(uuid("359F3441-BD4A-11D0-B188-00AA0038C969")) IMLangFontLink;
struct __declspec(uuid("359F3443-BD4A-11D0-B188-00AA0038C969")) IMLangCodePages;
struct __declspec(uuid("3C374A41-BAE4-11CF-BF7D-00AA006946EE")) IUrlHistoryStg;
struct __declspec(uuid("3C374A42-BAE4-11CF-BF7D-00AA006946EE")) IEnumSTATURL;
struct __declspec(uuid("3DC39D1D-C030-11D0-B81B-00C04FC9B31F")) IEnumRfc1766;
struct __declspec(uuid("47d2657a-7b27-11d0-8ca9-00a0c92dbfe8")) IDockingWindowFrame;
struct __declspec(uuid("539698A0-CDCA-11CF-A5EB-00AA0047A063")) IActiveScriptSiteInterruptPoll;
struct __declspec(uuid("618736e0-3c3d-11cf-810c-00aa00389b71")) IAccessible;
struct __declspec(uuid("626FC520-A41E-11CF-A731-00A0C9082637")) IHTMLDocument;
struct __declspec(uuid("63CDBCB0-C1B1-11D0-9336-00A0C90DCAA9")) IBindEventHandler;
struct __declspec(uuid("68284faa-6a48-11d0-8c78-00c04fd918b4")) IInputObject;
struct __declspec(uuid("71EE5B20-FB04-11d1-B3A8-00A0C911E8B2")) IActiveScriptParseProcedure2_32;
struct __declspec(uuid("729FE2F8-1EA8-11D1-8F85-00C04FC2FBE1")) IShellUIHelper;
struct __declspec(uuid("744129E0-CBE5-11CE-8350-444553540000")) FolderItems;
struct __declspec(uuid("79EAC9C2-BAF9-11CE-8C82-00AA004BA90B")) IHlinkSite;
struct __declspec(uuid("79EAC9C3-BAF9-11CE-8C82-00AA004BA90B")) IHlink;
struct __declspec(uuid("79EAC9C4-BAF9-11CE-8C82-00AA004BA90B")) IHlinkTarget;
struct __declspec(uuid("79EAC9C5-BAF9-11CE-8C82-00AA004BA90B")) IHlinkFrame;
struct __declspec(uuid("79EAC9C6-BAF9-11CE-8C82-00AA004BA90B")) IEnumHLITEM;
struct __declspec(uuid("79EAC9C7-BAF9-11CE-8C82-00AA004BA90B")) IHlinkBrowseContext;
struct __declspec(uuid("79EAC9CB-BAF9-11CE-8C82-00AA004BA90B")) IExtensionServices;
struct __declspec(uuid("7d688a70-c613-11d0-999b-00c04fd655e1")) IShellIconOverlay;
struct __declspec(uuid("85BD8E82-0FBA-11D1-90C3-00C04FC2F568")) IChannelMgr;
struct __declspec(uuid("85CB6900-4D95-11CF-960C-0080C7F4EE85")) IShellWindows;
struct __declspec(uuid("88A05C00-F000-11CE-8350-444553540000")) IShellLinkDual;
struct __declspec(uuid("88e39e80-3578-11cf-ae69-08002b2e1262")) IShellView2;
struct __declspec(uuid("89BCB740-6119-101A-BCB7-00DD010655AF")) IFilter;
struct __declspec(uuid("91A565C1-E38F-11D0-94BF-00A0C9055CBF")) IPersistHistory;
struct __declspec(uuid("9BA05970-F6A8-11CF-A442-00A0C90A8F39")) IFolderViewOC;
struct __declspec(uuid("A3CCEDF3-2DE2-11D0-86F4-00A0C913F750")) IImageDecodeFilter;
struct __declspec(uuid("A4C65425-0F82-11D1-90C3-00C04FC2F568")) IEnumChannels;
struct __declspec(uuid("A6EF9860-C720-11D0-9337-00A0C90DCAA9")) IDispatchEx;
struct __declspec(uuid("A6EF9861-C720-11D0-9337-00A0C90DCAA9")) IDispError;
struct __declspec(uuid("A6EF9862-C720-11D0-9337-00A0C90DCAA9")) IVariantChangeType;
struct __declspec(uuid("AA5B6A80-B834-11D0-932F-00A0C90DCAA9")) IActiveScriptParseProcedure32;
struct __declspec(uuid("AFA0DC11-C313-11D0-831A-00C04FD5AE38")) IUrlHistoryStg2;
struct __declspec(uuid("B722BCC5-4E68-101B-A2BC-00AA00404770")) IOleDocument;
struct __declspec(uuid("B722BCC6-4E68-101B-A2BC-00AA00404770")) IOleDocumentView;
struct __declspec(uuid("B722BCC7-4E68-101B-A2BC-00AA00404770")) IOleDocumentSite;
struct __declspec(uuid("B722BCC8-4E68-101B-A2BC-00AA00404770")) IEnumOleDocumentViews;
struct __declspec(uuid("B722BCC9-4E68-101B-A2BC-00AA00404770")) IPrint;
struct __declspec(uuid("B722BCCA-4E68-101B-A2BC-00AA00404770")) IContinueCallback;
struct __declspec(uuid("B722BCCB-4E68-101B-A2BC-00AA00404770")) IOleCommandTarget;
struct __declspec(uuid("B8DA6310-E19B-11D0-933C-00A0C90DCAA9")) IActiveScriptStats;
struct __declspec(uuid("BAA342A0-2DED-11D0-86F4-00A0C913F750")) IImageDecodeEventSink;
struct __declspec(uuid("BB1A2AE1-A4F9-11CF-8F20-00805F2CD064")) IActiveScript;
struct __declspec(uuid("BB1A2AE2-A4F9-11CF-8F20-00805F2CD064")) IActiveScriptParse32;
struct __declspec(uuid("BC40BEC1-C493-11D0-831B-00C04FD5AE38")) IUrlHistoryNotify;
struct __declspec(uuid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A")) IDocHostUIHandler;
struct __declspec(uuid("C04D65CE-B70D-11D0-B188-00AA0038C969")) IMLangString;
struct __declspec(uuid("C04D65D0-B70D-11D0-B188-00AA0038C969")) IMLangStringWStr;
struct __declspec(uuid("C04D65D2-B70D-11D0-B188-00AA0038C969")) IMLangStringAStr;
struct __declspec(uuid("C4D244B0-D43E-11CF-893B-00AA00BDCE1A")) IDocHostShowUI;
struct __declspec(uuid("C64713B6-E029-4CC5-9200-438B72890B6A")) IActiveScriptParseProcedure64;
struct __declspec(uuid("C7EF7658-E1EE-480E-97EA-D52CB4D76D17")) IActiveScriptParse64;
struct __declspec(uuid("CA04B7E6-0D21-11D1-8CC5-00C04FC2B085")) IObjectIdentity;
struct __declspec(uuid("CB5BDC81-93C1-11CF-8F20-00805F2CD064")) IObjectSafety;
struct __declspec(uuid("D10F6761-83E9-11CF-8F20-00805F2CD064")) IActiveScriptSiteWindow;
struct __declspec(uuid("D24ACD21-BA72-11D0-B188-00AA0038C969")) IMLangStringBufW;
struct __declspec(uuid("D24ACD23-BA72-11D0-B188-00AA0038C969")) IMLangStringBufA;
struct __declspec(uuid("D30C1661-CDAF-11D0-8A3E-00C04FC9E26E")) IWebBrowser2;
struct __declspec(uuid("D66D6F98-CDAA-11D0-B822-00C04FC9B31F")) IMLangConvertCharset;
struct __declspec(uuid("D8F015C0-C278-11CE-A49E-444553540000")) IShellDispatch;
struct __declspec(uuid("D9E89500-30FA-11D0-B724-00AA006C1A01")) IMapMIMEToCLSID;
struct __declspec(uuid("DB01A1E3-A42B-11CF-8F20-00805F2CD064")) IActiveScriptSite;
struct __declspec(uuid("E0E270C0-C0BE-11D0-8FE4-00A0C90A6341")) OLEDBSimpleProvider;
struct __declspec(uuid("E0E270C1-C0BE-11D0-8FE4-00A0C90A6341")) OLEDBSimpleProviderListener;
struct __declspec(uuid("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")) IShellFolderViewDual;
struct __declspec(uuid("EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B")) IWebBrowser;
struct __declspec(uuid("EAE1BA61-A4ED-11CF-8F20-00805F2CD064")) IActiveScriptError;
struct __declspec(uuid("F5BE2EE1-BFD7-11D0-B188-00AA0038C969")) IMLangLineBreakConsole;
struct __declspec(uuid("F77459A0-BF9A-11CF-BA4E-00C04FD70816")) IMimeInfo;
struct __declspec(uuid("FAC32C80-CBE4-11CE-8350-444553540000")) FolderItem;
struct __declspec(uuid("FE7C4271-210C-448D-9F54-76DAB7047B28")) IActiveScriptParseProcedure2_64;
struct __declspec(uuid("FECEAAA2-8405-11CF-8BA1-00AA00476DA6")) IOmHistory;
struct __declspec(uuid("FECEAAA5-8405-11CF-8BA1-00AA00476DA6")) IOmNavigator;
struct __declspec(uuid("ac60f6a0-0fd9-11d0-99cb-00c04fd64497")) IURLSearchHook;
struct __declspec(uuid("bcfce0a0-ec17-11d0-8d10-00a0c90f2719")) IContextMenu3;
struct __declspec(uuid("cabb0da0-da57-11cf-9974-0020afd79762")) IUniformResourceLocatorW;
struct __declspec(uuid("eb0fe172-1a3a-11d0-89b3-00a0c90a90ac")) IDeskBand;
struct __declspec(uuid("f1db8392-7331-11d0-8c99-00a0c92dbfe8")) IInputObjectSite;
struct __declspec(uuid("f490eb00-1240-11d1-9888-006097deacf9")) IActiveDesktop;
struct __declspec(uuid("fbf23b80-e3f0-101b-8488-00aa003e56f8")) IUniformResourceLocatorA;

// CoClasses:

class __declspec(uuid("00000017-0000-0000-c000-000000000046")) StdMarshal;
class __declspec(uuid("0000001b-0000-0000-c000-000000000046")) IdentityUnmarshal;
class __declspec(uuid("0000001c-0000-0000-c000-000000000046")) InProcFreeMarshaler;
class __declspec(uuid("0000030c-0000-0000-c000-000000000046")) PSGenObject;
class __declspec(uuid("0000030d-0000-0000-c000-000000000046")) PSClientSite;
class __declspec(uuid("0000030e-0000-0000-c000-000000000046")) PSClassObject;
class __declspec(uuid("0000030f-0000-0000-c000-000000000046")) PSInPlaceActive;
class __declspec(uuid("00000310-0000-0000-c000-000000000046")) PSInPlaceFrame;
class __declspec(uuid("00000311-0000-0000-c000-000000000046")) PSDragDrop;
class __declspec(uuid("00000312-0000-0000-c000-000000000046")) PSBindCtx;
class __declspec(uuid("00000313-0000-0000-c000-000000000046")) PSEnumerators;
class __declspec(uuid("00000315-0000-0000-c000-000000000046")) Picture_Metafile;
class __declspec(uuid("00000315-0000-0000-c000-000000000046")) StaticMetafile;
class __declspec(uuid("00000316-0000-0000-c000-000000000046")) Picture_Dib;
class __declspec(uuid("00000316-0000-0000-c000-000000000046")) StaticDib;
class __declspec(uuid("00000319-0000-0000-c000-000000000046")) Picture_EnhMetafile;
class __declspec(uuid("0000031d-0000-0000-c000-000000000046")) DCOMAccessControl;
class __declspec(uuid("00021400-0000-0000-c000-000000000046")) ShellDesktop;
class __declspec(uuid("00021401-0000-0000-c000-000000000046")) ShellLink;
class __declspec(uuid("0002DF01-0000-0000-C000-000000000046")) InternetExplorer;
class __declspec(uuid("0002e005-0000-0000-c000-000000000046")) StdComponentCategoriesMgr;
class __declspec(uuid("08165ea0-e946-11cf-9c87-00aa005127ed")) WebCrawlerAgent;
class __declspec(uuid("0A89A860-D7B1-11CE-8350-444553540000")) ShellDispatchInproc;
class __declspec(uuid("0D04D285-6BEC-11CF-8B97-00AA00476DA6")) OldHTMLFormElement;
class __declspec(uuid("0be35200-8f91-11ce-9de3-00aa004bb851")) CFontPropPage;
class __declspec(uuid("0be35201-8f91-11ce-9de3-00aa004bb851")) CColorPropPage;
class __declspec(uuid("0be35202-8f91-11ce-9de3-00aa004bb851")) CPicturePropPage;
class __declspec(uuid("0be35203-8f91-11ce-9de3-00aa004bb851")) StdFont;
class __declspec(uuid("0be35204-8f91-11ce-9de3-00aa004bb851")) StdPicture;
class __declspec(uuid("11219420-1768-11D1-95BE-00609797EA4F")) ShellLinkObject;
class __declspec(uuid("163BB1E1-6E00-11CF-837A-48DC04C10000")) HTMLLocation;
class __declspec(uuid("1820FED0-473E-11D0-A96C-00C04FD705A2")) WebViewFolderContents;
class __declspec(uuid("25336920-03F9-11CF-8FD0-00AA00686F13")) HTMLDocument;
class __declspec(uuid("25336921-03f9-11cf-8fd0-00aa00686f13")) HTMLPluginDocument;
class __declspec(uuid("275C23E2-3747-11D0-9FEA-00AA003F8646")) CMultiLanguage;
class __declspec(uuid("3050F241-98B5-11CF-BB82-00AA00BDCE0B")) HTMLImg;
class __declspec(uuid("3050F245-98B5-11CF-BB82-00AA00BDCE0B")) HTMLSelectElement;
class __declspec(uuid("3050F246-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCell;
class __declspec(uuid("3050F248-98B5-11CF-BB82-00AA00BDCE0B")) HTMLAnchorElement;
class __declspec(uuid("3050F249-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDivPosition;
class __declspec(uuid("3050F24A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBody;
class __declspec(uuid("3050F24D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionElement;
class __declspec(uuid("3050F24E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLObjectElement;
class __declspec(uuid("3050F251-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFormElement;
class __declspec(uuid("3050F252-98B5-11CF-BB82-00AA00BDCE0B")) HTMLHRElement;
class __declspec(uuid("3050F25D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLEmbed;
class __declspec(uuid("3050F268-98B5-11CF-BB82-00AA00BDCE0B")) HTMLUnknownElement;
class __declspec(uuid("3050F269-98B5-11CF-BB82-00AA00BDCE0B")) HTMLUListElement;
class __declspec(uuid("3050F26A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTextElement;
class __declspec(uuid("3050F26B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTable;
class __declspec(uuid("3050F26C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCol;
class __declspec(uuid("3050F26D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableRow;
class __declspec(uuid("3050F26E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLPhraseElement;
class __declspec(uuid("3050F26F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLParaElement;
class __declspec(uuid("3050F270-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOListElement;
class __declspec(uuid("3050F271-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMapElement;
class __declspec(uuid("3050F272-98B5-11CF-BB82-00AA00BDCE0B")) HTMLListElement;
class __declspec(uuid("3050F273-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLIElement;
class __declspec(uuid("3050F275-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMetaElement;
class __declspec(uuid("3050F276-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBaseElement;
class __declspec(uuid("3050F277-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLinkElement;
class __declspec(uuid("3050F278-98B5-11CF-BB82-00AA00BDCE0B")) HTMLIsIndexElement;
class __declspec(uuid("3050F279-98B5-11CF-BB82-00AA00BDCE0B")) HTMLNextIdElement;
class __declspec(uuid("3050F27A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLHeaderElement;
class __declspec(uuid("3050F27B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFontElement;
class __declspec(uuid("3050F27C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDTElement;
class __declspec(uuid("3050F27D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDListElement;
class __declspec(uuid("3050F27E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDivElement;
class __declspec(uuid("3050F27F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDDElement;
class __declspec(uuid("3050F280-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBRElement;
class __declspec(uuid("3050F281-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBlockElement;
class __declspec(uuid("3050F282-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBaseFontElement;
class __declspec(uuid("3050F283-98B5-11CF-BB82-00AA00BDCE0B")) HTMLAreaElement;
class __declspec(uuid("3050F284-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTitleElement;
class __declspec(uuid("3050F285-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyle;
class __declspec(uuid("3050F28A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDialog;
class __declspec(uuid("3050F28C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLScriptElement;
class __declspec(uuid("3050F2AB-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputTextElement;
class __declspec(uuid("3050F2AC-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTextAreaElement;
class __declspec(uuid("3050F2AE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputFileElement;
class __declspec(uuid("3050F2B4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputButtonElement;
class __declspec(uuid("3050F2B9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMarqueeElement;
class __declspec(uuid("3050F2BE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionButtonElement;
class __declspec(uuid("3050F2C4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputImage;
class __declspec(uuid("3050F2C6-98B5-11CF-BB82-00AA00BDCE0B")) HTMLButtonElement;
class __declspec(uuid("3050F2E4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheet;
class __declspec(uuid("3050F2E9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableSection;
class __declspec(uuid("3050F2EC-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCaption;
class __declspec(uuid("3050F312-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameBase;
class __declspec(uuid("3050F314-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameElement;
class __declspec(uuid("3050F316-98B5-11CF-BB82-00AA00BDCE0B")) HTMLIFrame;
class __declspec(uuid("3050F317-98B5-11CF-BB82-00AA00BDCE0B")) HTMLCommentElement;
class __declspec(uuid("3050F31A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameSetSite;
class __declspec(uuid("3050F32B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLabelElement;
class __declspec(uuid("3050F35D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLScreen;
class __declspec(uuid("3050F370-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBGsound;
class __declspec(uuid("3050F37D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleElement;
class __declspec(uuid("3050F37F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetsCollection;
class __declspec(uuid("3050F38B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLNoShowElement;
class __declspec(uuid("3050F38D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionElementFactory;
class __declspec(uuid("3050F38F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLImageElementFactory;
class __declspec(uuid("3050F391-98B5-11CF-BB82-00AA00BDCE0B")) HTMLWindowProxy;
class __declspec(uuid("3050F3CD-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetRulesCollection;
class __declspec(uuid("3050F3CE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetRule;
class __declspec(uuid("3050F3D0-98B5-11CF-BB82-00AA00BDCE0B")) HTMLRuleStyle;
class __declspec(uuid("3050F3D4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleFontFace;
class __declspec(uuid("3050F3E6-98B5-11CF-BB82-00AA00BDCE0B")) HTMLSpanFlow;
class __declspec(uuid("3050F3E8-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFieldSetElement;
class __declspec(uuid("3050F3E9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLegendElement;
class __declspec(uuid("3050F3EF-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFiltersCollection;
class __declspec(uuid("3050F3F5-98B4-11CF-BB82-00AA00BDCE0B")) HTMLSpanElement;
class __declspec(uuid("3050F3FE-98B5-11CF-BB82-00AA00BDCE0B")) CMimeTypes;
class __declspec(uuid("3050F3FF-98B5-11CF-BB82-00AA00BDCE0B")) CPlugins;
class __declspec(uuid("3050F402-98B5-11CF-BB82-00AA00BDCE0B")) COpsProfile;
class __declspec(uuid("3050f3d9-98b5-11cf-bb82-00aa00bdce0b")) MHTMLDocument;
class __declspec(uuid("32b533bb-edae-11d0-bd5a-00aa00b92af1")) ClassInstallFilter;
class __declspec(uuid("3c374a40-bae4-11cf-bf7d-00aa006946ee")) CUrlHistory;
class __declspec(uuid("3dd53d40-7b8b-11d0-b013-00aa0059ce02")) CdlProtocol;
class __declspec(uuid("54c37cd0-d944-11d0-a9f4-006097942311")) StdEncodingFilterFac;
class __declspec(uuid("56fdf344-fd6d-11d0-958a-006097c9a090")) TaskbarList;
class __declspec(uuid("62112AA1-EBE4-11CF-A5FB-0020AFE7292D")) ShellFolderView;
class __declspec(uuid("63b51f81-c868-11d0-999c-00c04fd655e1")) CFSIconOverlayManager;
class __declspec(uuid("64AB4BB7-111E-11D1-8F79-00C04FC2FBE1")) ShellUIHelper;
class __declspec(uuid("75048700-ef1f-11d0-9888-006097deacf9")) ActiveDesktop;
class __declspec(uuid("79eac9d0-baf9-11ce-8c82-00aa004ba90b")) StdHlink;
class __declspec(uuid("79eac9d1-baf9-11ce-8c82-00aa004ba90b")) StdHlinkBrowseContext;
class __declspec(uuid("79eac9e0-baf9-11ce-8c82-00aa004ba90b")) StdURLMoniker;
class __declspec(uuid("79eac9e1-baf9-11ce-8c82-00aa004ba90b")) StdURLProtocol;
class __declspec(uuid("79eac9e2-baf9-11ce-8c82-00aa004ba90b")) HttpProtocol;
class __declspec(uuid("79eac9e3-baf9-11ce-8c82-00aa004ba90b")) FtpProtocol;
class __declspec(uuid("79eac9e4-baf9-11ce-8c82-00aa004ba90b")) GopherProtocol;
class __declspec(uuid("79eac9e5-baf9-11ce-8c82-00aa004ba90b")) HttpSProtocol;
class __declspec(uuid("79eac9e6-baf9-11ce-8c82-00aa004ba90b")) MkProtocol;
class __declspec(uuid("79eac9e7-baf9-11ce-8c82-00aa004ba90b")) FileProtocol;
class __declspec(uuid("79eac9f2-baf9-11ce-8c82-00aa004ba90b")) UrlMkBindCtx;
class __declspec(uuid("7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4")) InternetSecurityManager;
class __declspec(uuid("7b8a2d95-0ac9-11d1-896c-00c04fb6bfc4")) InternetZoneManager;
class __declspec(uuid("7d559c10-9fe9-11d0-93f7-00aa0059ce02")) CDLAgent;
class __declspec(uuid("7d688a77-c613-11d0-999b-00c04fd655e1")) OverlayIdentifier_SlowFile;
class __declspec(uuid("7ebdaae0-8120-11cf-899f-00aa00688b10")) StockFontPage;
class __declspec(uuid("7ebdaae1-8120-11cf-899f-00aa00688b10")) StockColorPage;
class __declspec(uuid("7ebdaae2-8120-11cf-899f-00aa00688b10")) StockPicturePage;
class __declspec(uuid("8856F961-340A-11D0-A96B-00C04FD705A2")) WebBrowser;
class __declspec(uuid("8f6b0360-b80d-11d0-a9b3-006097942311")) DeCompMimeFilter;
class __declspec(uuid("9BA05971-F6A8-11CF-A442-00A0C90A8F39")) ShellFolderViewOC;
class __declspec(uuid("9BA05972-F6A8-11CF-A442-00A0C90A8F39")) ShellWindows;
class __declspec(uuid("ABBE31D0-6DAE-11D0-BECA-00C04FD940BE")) SubscriptionMgr;
class __declspec(uuid("B3CDAE90-D170-11D0-802B-00C04FD75D13")) ChannelMgr;
class __declspec(uuid("C04D65CF-B70D-11D0-B188-00AA0038C969")) CMLangString;
class __declspec(uuid("D48A6EC6-6A4A-11CF-94A7-444553540000")) HTMLWindow2;
class __declspec(uuid("D48A6EC9-6A4A-11CF-94A7-444553540000")) OldHTMLDocument;
class __declspec(uuid("D66D6F99-CDAA-11D0-B822-00C04FC9B31F")) CMLangConvertCharset;
class __declspec(uuid("EAB22AC3-30C1-11CF-A7EB-0000C05BAE0B")) WebBrowser_V1;
class __declspec(uuid("FECEAAA3-8405-11CF-8BA1-00AA00476DA6")) HTMLHistory;
class __declspec(uuid("FECEAAA6-8405-11CF-8BA1-00AA00476DA6")) HTMLNavigator;
class __declspec(uuid("b15b8dc0-c7e1-11d0-8680-00aa00bdcb71")) SoftDistExt;
class __declspec(uuid("cfbfae00-17a6-11d0-99cb-00c04fd64497")) CURLSearchHook;
class __declspec(uuid("e3a8bde6-abce-11d0-bc4b-00c04fd929db")) ChannelAgent;
class __declspec(uuid("fb8f0821-0164-101b-84ed-08002b2ec713")) PersistPropset;
class __declspec(uuid("fb8f0822-0164-101b-84ed-08002b2ec713")) ConvertVBX;
class __declspec(uuid("fbf23b40-e3f0-101b-8488-00aa003e56f8")) InternetShortcut;

// Interface Smart Pointers:

_COM_SMARTPTR_TYPEDEF(FolderItem, __uuidof(FolderItem));
_COM_SMARTPTR_TYPEDEF(FolderItemVerb, __uuidof(FolderItemVerb));
_COM_SMARTPTR_TYPEDEF(FolderItemVerbs, __uuidof(FolderItemVerbs));
_COM_SMARTPTR_TYPEDEF(FolderItems, __uuidof(FolderItems));
_COM_SMARTPTR_TYPEDEF(IAccessible, __uuidof(IAccessible));
_COM_SMARTPTR_TYPEDEF(IActiveDesktop, __uuidof(IActiveDesktop));
_COM_SMARTPTR_TYPEDEF(IActiveScript, __uuidof(IActiveScript));
_COM_SMARTPTR_TYPEDEF(IActiveScriptError, __uuidof(IActiveScriptError));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParse, __uuidof(IActiveScriptParse));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedure, __uuidof(IActiveScriptParseProcedure));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedure2, __uuidof(IActiveScriptParseProcedure2));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedureOld, __uuidof(IActiveScriptParseProcedureOld));
_COM_SMARTPTR_TYPEDEF(IActiveScriptSite, __uuidof(IActiveScriptSite));
_COM_SMARTPTR_TYPEDEF(IActiveScriptSiteInterruptPoll, __uuidof(IActiveScriptSiteInterruptPoll));
_COM_SMARTPTR_TYPEDEF(IActiveScriptSiteWindow, __uuidof(IActiveScriptSiteWindow));
_COM_SMARTPTR_TYPEDEF(IActiveScriptStats, __uuidof(IActiveScriptStats));
_COM_SMARTPTR_TYPEDEF(IAdviseSink, __uuidof(IAdviseSink));
_COM_SMARTPTR_TYPEDEF(IAdviseSink2, __uuidof(IAdviseSink2));
_COM_SMARTPTR_TYPEDEF(IAdviseSinkEx, __uuidof(IAdviseSinkEx));
_COM_SMARTPTR_TYPEDEF(IAsyncManager, __uuidof(IAsyncManager));
_COM_SMARTPTR_TYPEDEF(IAuthenticate, __uuidof(IAuthenticate));
_COM_SMARTPTR_TYPEDEF(IBindCtx, __uuidof(IBindCtx));
_COM_SMARTPTR_TYPEDEF(IBindEventHandler, __uuidof(IBindEventHandler));
_COM_SMARTPTR_TYPEDEF(IBindHost, __uuidof(IBindHost));
_COM_SMARTPTR_TYPEDEF(IBindProtocol, __uuidof(IBindProtocol));
_COM_SMARTPTR_TYPEDEF(IBindStatusCallback, __uuidof(IBindStatusCallback));
_COM_SMARTPTR_TYPEDEF(IBinding, __uuidof(IBinding));
_COM_SMARTPTR_TYPEDEF(ICSSFilter, __uuidof(ICSSFilter));
_COM_SMARTPTR_TYPEDEF(ICSSFilterSite, __uuidof(ICSSFilterSite));
_COM_SMARTPTR_TYPEDEF(ICancelMethodCalls, __uuidof(ICancelMethodCalls));
_COM_SMARTPTR_TYPEDEF(ICatInformation, __uuidof(ICatInformation));
_COM_SMARTPTR_TYPEDEF(ICatRegister, __uuidof(ICatRegister));
_COM_SMARTPTR_TYPEDEF(IChannelHook, __uuidof(IChannelHook));
_COM_SMARTPTR_TYPEDEF(IChannelMgr, __uuidof(IChannelMgr));
_COM_SMARTPTR_TYPEDEF(IClassActivator, __uuidof(IClassActivator));
_COM_SMARTPTR_TYPEDEF(IClassFactory, __uuidof(IClassFactory));
_COM_SMARTPTR_TYPEDEF(IClassFactory2, __uuidof(IClassFactory2));
_COM_SMARTPTR_TYPEDEF(IClientSecurity, __uuidof(IClientSecurity));
_COM_SMARTPTR_TYPEDEF(ICodeInstall, __uuidof(ICodeInstall));
_COM_SMARTPTR_TYPEDEF(ICommDlgBrowser, __uuidof(ICommDlgBrowser));
_COM_SMARTPTR_TYPEDEF(IConnectionPoint, __uuidof(IConnectionPoint));
_COM_SMARTPTR_TYPEDEF(IConnectionPointContainer, __uuidof(IConnectionPointContainer));
_COM_SMARTPTR_TYPEDEF(IContextMenu, __uuidof(IContextMenu));
_COM_SMARTPTR_TYPEDEF(IContextMenu2, __uuidof(IContextMenu2));
_COM_SMARTPTR_TYPEDEF(IContextMenu3, __uuidof(IContextMenu3));
_COM_SMARTPTR_TYPEDEF(IContinue, __uuidof(IContinue));
_COM_SMARTPTR_TYPEDEF(IContinueCallback, __uuidof(IContinueCallback));
_COM_SMARTPTR_TYPEDEF(ICreateErrorInfo, __uuidof(ICreateErrorInfo));
_COM_SMARTPTR_TYPEDEF(ICreateTypeInfo, __uuidof(ICreateTypeInfo));
_COM_SMARTPTR_TYPEDEF(ICreateTypeInfo2, __uuidof(ICreateTypeInfo2));
_COM_SMARTPTR_TYPEDEF(ICreateTypeLib, __uuidof(ICreateTypeLib));
_COM_SMARTPTR_TYPEDEF(ICreateTypeLib2, __uuidof(ICreateTypeLib2));
_COM_SMARTPTR_TYPEDEF(ICustomDoc, __uuidof(ICustomDoc));
_COM_SMARTPTR_TYPEDEF(IDataAdviseHolder, __uuidof(IDataAdviseHolder));
_COM_SMARTPTR_TYPEDEF(IDataFilter, __uuidof(IDataFilter));
_COM_SMARTPTR_TYPEDEF(IDataObject, __uuidof(IDataObject));
_COM_SMARTPTR_TYPEDEF(IDeskBand, __uuidof(IDeskBand));
_COM_SMARTPTR_TYPEDEF(IDirectWriterLock, __uuidof(IDirectWriterLock));
_COM_SMARTPTR_TYPEDEF(IDispError, __uuidof(IDispError));
_COM_SMARTPTR_TYPEDEF(IDispatch, __uuidof(IDispatch));
_COM_SMARTPTR_TYPEDEF(IDispatchEx, __uuidof(IDispatchEx));
_COM_SMARTPTR_TYPEDEF(IDocHostShowUI, __uuidof(IDocHostShowUI));
_COM_SMARTPTR_TYPEDEF(IDocHostUIHandler, __uuidof(IDocHostUIHandler));
_COM_SMARTPTR_TYPEDEF(IDockingWindow, __uuidof(IDockingWindow));
_COM_SMARTPTR_TYPEDEF(IDockingWindowFrame, __uuidof(IDockingWindowFrame));
_COM_SMARTPTR_TYPEDEF(IDockingWindowSite, __uuidof(IDockingWindowSite));
_COM_SMARTPTR_TYPEDEF(IDropSource, __uuidof(IDropSource));
_COM_SMARTPTR_TYPEDEF(IDropTarget, __uuidof(IDropTarget));
_COM_SMARTPTR_TYPEDEF(IEncodingFilterFactory, __uuidof(IEncodingFilterFactory));
_COM_SMARTPTR_TYPEDEF(IEnumCATEGORYINFO, __uuidof(IEnumCATEGORYINFO));
_COM_SMARTPTR_TYPEDEF(IEnumChannels, __uuidof(IEnumChannels));
_COM_SMARTPTR_TYPEDEF(IEnumCodePage, __uuidof(IEnumCodePage));
_COM_SMARTPTR_TYPEDEF(IEnumConnectionPoints, __uuidof(IEnumConnectionPoints));
_COM_SMARTPTR_TYPEDEF(IEnumConnections, __uuidof(IEnumConnections));
_COM_SMARTPTR_TYPEDEF(IEnumFORMATETC, __uuidof(IEnumFORMATETC));
_COM_SMARTPTR_TYPEDEF(IEnumGUID, __uuidof(IEnumGUID));
_COM_SMARTPTR_TYPEDEF(IEnumHLITEM, __uuidof(IEnumHLITEM));
_COM_SMARTPTR_TYPEDEF(IEnumIDList, __uuidof(IEnumIDList));
_COM_SMARTPTR_TYPEDEF(IEnumMoniker, __uuidof(IEnumMoniker));
_COM_SMARTPTR_TYPEDEF(IEnumOLEVERB, __uuidof(IEnumOLEVERB));
_COM_SMARTPTR_TYPEDEF(IEnumOleDocumentViews, __uuidof(IEnumOleDocumentViews));
_COM_SMARTPTR_TYPEDEF(IEnumOleUndoUnits, __uuidof(IEnumOleUndoUnits));
_COM_SMARTPTR_TYPEDEF(IEnumRfc1766, __uuidof(IEnumRfc1766));
_COM_SMARTPTR_TYPEDEF(IEnumSTATDATA, __uuidof(IEnumSTATDATA));
_COM_SMARTPTR_TYPEDEF(IEnumSTATPROPSETSTG, __uuidof(IEnumSTATPROPSETSTG));
_COM_SMARTPTR_TYPEDEF(IEnumSTATPROPSTG, __uuidof(IEnumSTATPROPSTG));
_COM_SMARTPTR_TYPEDEF(IEnumSTATSTG, __uuidof(IEnumSTATSTG));
_COM_SMARTPTR_TYPEDEF(IEnumSTATURL, __uuidof(IEnumSTATURL));
_COM_SMARTPTR_TYPEDEF(IEnumString, __uuidof(IEnumString));
_COM_SMARTPTR_TYPEDEF(IEnumUnknown, __uuidof(IEnumUnknown));
_COM_SMARTPTR_TYPEDEF(IEnumVARIANT, __uuidof(IEnumVARIANT));
_COM_SMARTPTR_TYPEDEF(IErrorInfo, __uuidof(IErrorInfo));
_COM_SMARTPTR_TYPEDEF(IErrorLog, __uuidof(IErrorLog));
_COM_SMARTPTR_TYPEDEF(IExtensionServices, __uuidof(IExtensionServices));
_COM_SMARTPTR_TYPEDEF(IExternalConnection, __uuidof(IExternalConnection));
_COM_SMARTPTR_TYPEDEF(IExtractIconA, __uuidof(IExtractIconA));
_COM_SMARTPTR_TYPEDEF(IExtractIconW, __uuidof(IExtractIconW));
_COM_SMARTPTR_TYPEDEF(IFileViewerA, __uuidof(IFileViewerA));
_COM_SMARTPTR_TYPEDEF(IFileViewerSite, __uuidof(IFileViewerSite));
_COM_SMARTPTR_TYPEDEF(IFileViewerW, __uuidof(IFileViewerW));
_COM_SMARTPTR_TYPEDEF(IFillLockBytes, __uuidof(IFillLockBytes));
_COM_SMARTPTR_TYPEDEF(IFilter, __uuidof(IFilter));
_COM_SMARTPTR_TYPEDEF(IFolderViewOC, __uuidof(IFolderViewOC));
_COM_SMARTPTR_TYPEDEF(IFont, __uuidof(IFont));
_COM_SMARTPTR_TYPEDEF(IFontDisp, __uuidof(IFontDisp));
_COM_SMARTPTR_TYPEDEF(IFontEventsDisp, __uuidof(IFontEventsDisp));
_COM_SMARTPTR_TYPEDEF(IGlobalInterfaceTable, __uuidof(IGlobalInterfaceTable));
_COM_SMARTPTR_TYPEDEF(IHTMLAnchorElement, __uuidof(IHTMLAnchorElement));
_COM_SMARTPTR_TYPEDEF(IHTMLAreaElement, __uuidof(IHTMLAreaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLAreasCollection, __uuidof(IHTMLAreasCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLBGsound, __uuidof(IHTMLBGsound));
_COM_SMARTPTR_TYPEDEF(IHTMLBRElement, __uuidof(IHTMLBRElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBaseElement, __uuidof(IHTMLBaseElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBaseFontElement, __uuidof(IHTMLBaseFontElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBlockElement, __uuidof(IHTMLBlockElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBodyElement, __uuidof(IHTMLBodyElement));
_COM_SMARTPTR_TYPEDEF(IHTMLButtonElement, __uuidof(IHTMLButtonElement));
_COM_SMARTPTR_TYPEDEF(IHTMLCommentElement, __uuidof(IHTMLCommentElement));
_COM_SMARTPTR_TYPEDEF(IHTMLControlElement, __uuidof(IHTMLControlElement));
_COM_SMARTPTR_TYPEDEF(IHTMLControlRange, __uuidof(IHTMLControlRange));
_COM_SMARTPTR_TYPEDEF(IHTMLDDElement, __uuidof(IHTMLDDElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDListElement, __uuidof(IHTMLDListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDTElement, __uuidof(IHTMLDTElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDatabinding, __uuidof(IHTMLDatabinding));
_COM_SMARTPTR_TYPEDEF(IHTMLDialog, __uuidof(IHTMLDialog));
_COM_SMARTPTR_TYPEDEF(IHTMLDivElement, __uuidof(IHTMLDivElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDivPosition, __uuidof(IHTMLDivPosition));
_COM_SMARTPTR_TYPEDEF(IHTMLDocument, __uuidof(IHTMLDocument));
_COM_SMARTPTR_TYPEDEF(IHTMLDocument2, __uuidof(IHTMLDocument2));
_COM_SMARTPTR_TYPEDEF(IHTMLElement, __uuidof(IHTMLElement));
_COM_SMARTPTR_TYPEDEF(IHTMLElementCollection, __uuidof(IHTMLElementCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLEmbedElement, __uuidof(IHTMLEmbedElement));
_COM_SMARTPTR_TYPEDEF(IHTMLEventObj, __uuidof(IHTMLEventObj));
_COM_SMARTPTR_TYPEDEF(IHTMLFieldSetElement, __uuidof(IHTMLFieldSetElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFiltersCollection, __uuidof(IHTMLFiltersCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLFontElement, __uuidof(IHTMLFontElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFontNamesCollection, __uuidof(IHTMLFontNamesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLFontSizesCollection, __uuidof(IHTMLFontSizesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLFormElement, __uuidof(IHTMLFormElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFrameBase, __uuidof(IHTMLFrameBase));
_COM_SMARTPTR_TYPEDEF(IHTMLFrameElement, __uuidof(IHTMLFrameElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFrameSetElement, __uuidof(IHTMLFrameSetElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFramesCollection2, __uuidof(IHTMLFramesCollection2));
_COM_SMARTPTR_TYPEDEF(IHTMLHRElement, __uuidof(IHTMLHRElement));
_COM_SMARTPTR_TYPEDEF(IHTMLHeaderElement, __uuidof(IHTMLHeaderElement));
_COM_SMARTPTR_TYPEDEF(IHTMLIFrameElement, __uuidof(IHTMLIFrameElement));
_COM_SMARTPTR_TYPEDEF(IHTMLImageElementFactory, __uuidof(IHTMLImageElementFactory));
_COM_SMARTPTR_TYPEDEF(IHTMLImgElement, __uuidof(IHTMLImgElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputButtonElement, __uuidof(IHTMLInputButtonElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputFileElement, __uuidof(IHTMLInputFileElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputHiddenElement, __uuidof(IHTMLInputHiddenElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputImage, __uuidof(IHTMLInputImage));
_COM_SMARTPTR_TYPEDEF(IHTMLInputTextElement, __uuidof(IHTMLInputTextElement));
_COM_SMARTPTR_TYPEDEF(IHTMLIsIndexElement, __uuidof(IHTMLIsIndexElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLIElement, __uuidof(IHTMLLIElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLabelElement, __uuidof(IHTMLLabelElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLegendElement, __uuidof(IHTMLLegendElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLinkElement, __uuidof(IHTMLLinkElement));
_COM_SMARTPTR_TYPEDEF(IHTMLListElement, __uuidof(IHTMLListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLocation, __uuidof(IHTMLLocation));
_COM_SMARTPTR_TYPEDEF(IHTMLMapElement, __uuidof(IHTMLMapElement));
_COM_SMARTPTR_TYPEDEF(IHTMLMarqueeElement, __uuidof(IHTMLMarqueeElement));
_COM_SMARTPTR_TYPEDEF(IHTMLMetaElement, __uuidof(IHTMLMetaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLMimeTypesCollection, __uuidof(IHTMLMimeTypesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLNextIdElement, __uuidof(IHTMLNextIdElement));
_COM_SMARTPTR_TYPEDEF(IHTMLNoShowElement, __uuidof(IHTMLNoShowElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOListElement, __uuidof(IHTMLOListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLObjectElement, __uuidof(IHTMLObjectElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOpsProfile, __uuidof(IHTMLOpsProfile));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionButtonElement, __uuidof(IHTMLOptionButtonElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionElement, __uuidof(IHTMLOptionElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionElementFactory, __uuidof(IHTMLOptionElementFactory));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionsHolder, __uuidof(IHTMLOptionsHolder));
_COM_SMARTPTR_TYPEDEF(IHTMLParaElement, __uuidof(IHTMLParaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLPhraseElement, __uuidof(IHTMLPhraseElement));
_COM_SMARTPTR_TYPEDEF(IHTMLPluginsCollection, __uuidof(IHTMLPluginsCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLRuleStyle, __uuidof(IHTMLRuleStyle));
_COM_SMARTPTR_TYPEDEF(IHTMLScreen, __uuidof(IHTMLScreen));
_COM_SMARTPTR_TYPEDEF(IHTMLScriptElement, __uuidof(IHTMLScriptElement));
_COM_SMARTPTR_TYPEDEF(IHTMLSelectElement, __uuidof(IHTMLSelectElement));
_COM_SMARTPTR_TYPEDEF(IHTMLSelectionObject, __uuidof(IHTMLSelectionObject));
_COM_SMARTPTR_TYPEDEF(IHTMLSpanElement, __uuidof(IHTMLSpanElement));
_COM_SMARTPTR_TYPEDEF(IHTMLSpanFlow, __uuidof(IHTMLSpanFlow));
_COM_SMARTPTR_TYPEDEF(IHTMLStyle, __uuidof(IHTMLStyle));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleElement, __uuidof(IHTMLStyleElement));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleFontFace, __uuidof(IHTMLStyleFontFace));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheet, __uuidof(IHTMLStyleSheet));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetRule, __uuidof(IHTMLStyleSheetRule));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetRulesCollection, __uuidof(IHTMLStyleSheetRulesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetsCollection, __uuidof(IHTMLStyleSheetsCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLTable, __uuidof(IHTMLTable));
_COM_SMARTPTR_TYPEDEF(IHTMLTableCaption, __uuidof(IHTMLTableCaption));
_COM_SMARTPTR_TYPEDEF(IHTMLTableCell, __uuidof(IHTMLTableCell));
_COM_SMARTPTR_TYPEDEF(IHTMLTableCol, __uuidof(IHTMLTableCol));
_COM_SMARTPTR_TYPEDEF(IHTMLTableRow, __uuidof(IHTMLTableRow));
_COM_SMARTPTR_TYPEDEF(IHTMLTableSection, __uuidof(IHTMLTableSection));
_COM_SMARTPTR_TYPEDEF(IHTMLTextAreaElement, __uuidof(IHTMLTextAreaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLTextContainer, __uuidof(IHTMLTextContainer));
_COM_SMARTPTR_TYPEDEF(IHTMLTextElement, __uuidof(IHTMLTextElement));
_COM_SMARTPTR_TYPEDEF(IHTMLTitleElement, __uuidof(IHTMLTitleElement));
_COM_SMARTPTR_TYPEDEF(IHTMLTxtRange, __uuidof(IHTMLTxtRange));
_COM_SMARTPTR_TYPEDEF(IHTMLUListElement, __uuidof(IHTMLUListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLUnknownElement, __uuidof(IHTMLUnknownElement));
_COM_SMARTPTR_TYPEDEF(IHTMLWindow2, __uuidof(IHTMLWindow2));
_COM_SMARTPTR_TYPEDEF(IHlink, __uuidof(IHlink));
_COM_SMARTPTR_TYPEDEF(IHlinkBrowseContext, __uuidof(IHlinkBrowseContext));
_COM_SMARTPTR_TYPEDEF(IHlinkFrame, __uuidof(IHlinkFrame));
_COM_SMARTPTR_TYPEDEF(IHlinkSite, __uuidof(IHlinkSite));
_COM_SMARTPTR_TYPEDEF(IHlinkTarget, __uuidof(IHlinkTarget));
_COM_SMARTPTR_TYPEDEF(IHttpNegotiate, __uuidof(IHttpNegotiate));
_COM_SMARTPTR_TYPEDEF(IHttpSecurity, __uuidof(IHttpSecurity));
_COM_SMARTPTR_TYPEDEF(IImageDecodeEventSink, __uuidof(IImageDecodeEventSink));
_COM_SMARTPTR_TYPEDEF(IImageDecodeFilter, __uuidof(IImageDecodeFilter));
_COM_SMARTPTR_TYPEDEF(IImgCtx, __uuidof(IImgCtx));
_COM_SMARTPTR_TYPEDEF(IInputObject, __uuidof(IInputObject));
_COM_SMARTPTR_TYPEDEF(IInputObjectSite, __uuidof(IInputObjectSite));
_COM_SMARTPTR_TYPEDEF(IInternet, __uuidof(IInternet));
_COM_SMARTPTR_TYPEDEF(IInternetBindInfo, __uuidof(IInternetBindInfo));
_COM_SMARTPTR_TYPEDEF(IInternetHostSecurityManager, __uuidof(IInternetHostSecurityManager));
_COM_SMARTPTR_TYPEDEF(IInternetPriority, __uuidof(IInternetPriority));
_COM_SMARTPTR_TYPEDEF(IInternetProtocol, __uuidof(IInternetProtocol));
_COM_SMARTPTR_TYPEDEF(IInternetProtocolInfo, __uuidof(IInternetProtocolInfo));
_COM_SMARTPTR_TYPEDEF(IInternetProtocolRoot, __uuidof(IInternetProtocolRoot));
_COM_SMARTPTR_TYPEDEF(IInternetProtocolSink, __uuidof(IInternetProtocolSink));
_COM_SMARTPTR_TYPEDEF(IInternetSecurityManager, __uuidof(IInternetSecurityManager));
_COM_SMARTPTR_TYPEDEF(IInternetSecurityMgrSite, __uuidof(IInternetSecurityMgrSite));
_COM_SMARTPTR_TYPEDEF(IInternetSession, __uuidof(IInternetSession));
_COM_SMARTPTR_TYPEDEF(IInternetThreadSwitch, __uuidof(IInternetThreadSwitch));
_COM_SMARTPTR_TYPEDEF(IInternetZoneManager, __uuidof(IInternetZoneManager));
_COM_SMARTPTR_TYPEDEF(ILayoutStorage, __uuidof(ILayoutStorage));
_COM_SMARTPTR_TYPEDEF(ILockBytes, __uuidof(ILockBytes));
_COM_SMARTPTR_TYPEDEF(IMLangCodePages, __uuidof(IMLangCodePages));
_COM_SMARTPTR_TYPEDEF(IMLangConvertCharset, __uuidof(IMLangConvertCharset));
_COM_SMARTPTR_TYPEDEF(IMLangFontLink, __uuidof(IMLangFontLink));
_COM_SMARTPTR_TYPEDEF(IMLangLineBreakConsole, __uuidof(IMLangLineBreakConsole));
_COM_SMARTPTR_TYPEDEF(IMLangString, __uuidof(IMLangString));
_COM_SMARTPTR_TYPEDEF(IMLangStringAStr, __uuidof(IMLangStringAStr));
_COM_SMARTPTR_TYPEDEF(IMLangStringBufA, __uuidof(IMLangStringBufA));
_COM_SMARTPTR_TYPEDEF(IMLangStringBufW, __uuidof(IMLangStringBufW));
_COM_SMARTPTR_TYPEDEF(IMLangStringWStr, __uuidof(IMLangStringWStr));
_COM_SMARTPTR_TYPEDEF(IMalloc, __uuidof(IMalloc));
_COM_SMARTPTR_TYPEDEF(IMallocSpy, __uuidof(IMallocSpy));
_COM_SMARTPTR_TYPEDEF(IMapMIMEToCLSID, __uuidof(IMapMIMEToCLSID));
_COM_SMARTPTR_TYPEDEF(IMarshal, __uuidof(IMarshal));
_COM_SMARTPTR_TYPEDEF(IMessageFilter, __uuidof(IMessageFilter));
_COM_SMARTPTR_TYPEDEF(IMimeInfo, __uuidof(IMimeInfo));
_COM_SMARTPTR_TYPEDEF(IMoniker, __uuidof(IMoniker));
_COM_SMARTPTR_TYPEDEF(IMultiLanguage, __uuidof(IMultiLanguage));
_COM_SMARTPTR_TYPEDEF(IMultiQI, __uuidof(IMultiQI));
_COM_SMARTPTR_TYPEDEF(INewShortcutHookA, __uuidof(INewShortcutHookA));
_COM_SMARTPTR_TYPEDEF(INewShortcutHookW, __uuidof(INewShortcutHookW));
_COM_SMARTPTR_TYPEDEF(IObjectIdentity, __uuidof(IObjectIdentity));
_COM_SMARTPTR_TYPEDEF(IObjectSafety, __uuidof(IObjectSafety));
_COM_SMARTPTR_TYPEDEF(IObjectWithSite, __uuidof(IObjectWithSite));
_COM_SMARTPTR_TYPEDEF(IOleAdviseHolder, __uuidof(IOleAdviseHolder));
_COM_SMARTPTR_TYPEDEF(IOleCache, __uuidof(IOleCache));
_COM_SMARTPTR_TYPEDEF(IOleCache2, __uuidof(IOleCache2));
_COM_SMARTPTR_TYPEDEF(IOleCacheControl, __uuidof(IOleCacheControl));
_COM_SMARTPTR_TYPEDEF(IOleClientSite, __uuidof(IOleClientSite));
_COM_SMARTPTR_TYPEDEF(IOleCommandTarget, __uuidof(IOleCommandTarget));
_COM_SMARTPTR_TYPEDEF(IOleContainer, __uuidof(IOleContainer));
_COM_SMARTPTR_TYPEDEF(IOleControl, __uuidof(IOleControl));
_COM_SMARTPTR_TYPEDEF(IOleControlSite, __uuidof(IOleControlSite));
_COM_SMARTPTR_TYPEDEF(IOleDocument, __uuidof(IOleDocument));
_COM_SMARTPTR_TYPEDEF(IOleDocumentSite, __uuidof(IOleDocumentSite));
_COM_SMARTPTR_TYPEDEF(IOleDocumentView, __uuidof(IOleDocumentView));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceActiveObject, __uuidof(IOleInPlaceActiveObject));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceFrame, __uuidof(IOleInPlaceFrame));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceObject, __uuidof(IOleInPlaceObject));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceObjectWindowless, __uuidof(IOleInPlaceObjectWindowless));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSite, __uuidof(IOleInPlaceSite));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSiteEx, __uuidof(IOleInPlaceSiteEx));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSiteWindowless, __uuidof(IOleInPlaceSiteWindowless));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceUIWindow, __uuidof(IOleInPlaceUIWindow));
_COM_SMARTPTR_TYPEDEF(IOleItemContainer, __uuidof(IOleItemContainer));
_COM_SMARTPTR_TYPEDEF(IOleLink, __uuidof(IOleLink));
_COM_SMARTPTR_TYPEDEF(IOleObject, __uuidof(IOleObject));
_COM_SMARTPTR_TYPEDEF(IOleParentUndoUnit, __uuidof(IOleParentUndoUnit));
_COM_SMARTPTR_TYPEDEF(IOleUndoManager, __uuidof(IOleUndoManager));
_COM_SMARTPTR_TYPEDEF(IOleUndoUnit, __uuidof(IOleUndoUnit));
_COM_SMARTPTR_TYPEDEF(IOleWindow, __uuidof(IOleWindow));
_COM_SMARTPTR_TYPEDEF(IOmHistory, __uuidof(IOmHistory));
_COM_SMARTPTR_TYPEDEF(IOmNavigator, __uuidof(IOmNavigator));
_COM_SMARTPTR_TYPEDEF(IPSFactoryBuffer, __uuidof(IPSFactoryBuffer));
_COM_SMARTPTR_TYPEDEF(IParseDisplayName, __uuidof(IParseDisplayName));
_COM_SMARTPTR_TYPEDEF(IPerPropertyBrowsing, __uuidof(IPerPropertyBrowsing));
_COM_SMARTPTR_TYPEDEF(IPersist, __uuidof(IPersist));
_COM_SMARTPTR_TYPEDEF(IPersistFile, __uuidof(IPersistFile));
_COM_SMARTPTR_TYPEDEF(IPersistFolder, __uuidof(IPersistFolder));
_COM_SMARTPTR_TYPEDEF(IPersistFolder2, __uuidof(IPersistFolder2));
_COM_SMARTPTR_TYPEDEF(IPersistHistory, __uuidof(IPersistHistory));
_COM_SMARTPTR_TYPEDEF(IPersistMemory, __uuidof(IPersistMemory));
_COM_SMARTPTR_TYPEDEF(IPersistMoniker, __uuidof(IPersistMoniker));
_COM_SMARTPTR_TYPEDEF(IPersistPropertyBag, __uuidof(IPersistPropertyBag));
_COM_SMARTPTR_TYPEDEF(IPersistPropertyBag2, __uuidof(IPersistPropertyBag2));
_COM_SMARTPTR_TYPEDEF(IPersistStorage, __uuidof(IPersistStorage));
_COM_SMARTPTR_TYPEDEF(IPersistStream, __uuidof(IPersistStream));
_COM_SMARTPTR_TYPEDEF(IPersistStreamInit, __uuidof(IPersistStreamInit));
_COM_SMARTPTR_TYPEDEF(IPicture, __uuidof(IPicture));
_COM_SMARTPTR_TYPEDEF(IPictureDisp, __uuidof(IPictureDisp));
_COM_SMARTPTR_TYPEDEF(IPointerInactive, __uuidof(IPointerInactive));
_COM_SMARTPTR_TYPEDEF(IPrint, __uuidof(IPrint));
_COM_SMARTPTR_TYPEDEF(IProgressNotify, __uuidof(IProgressNotify));
_COM_SMARTPTR_TYPEDEF(IPropertyBag, __uuidof(IPropertyBag));
_COM_SMARTPTR_TYPEDEF(IPropertyBag2, __uuidof(IPropertyBag2));
_COM_SMARTPTR_TYPEDEF(IPropertyNotifySink, __uuidof(IPropertyNotifySink));
_COM_SMARTPTR_TYPEDEF(IPropertyPage, __uuidof(IPropertyPage));
_COM_SMARTPTR_TYPEDEF(IPropertyPage2, __uuidof(IPropertyPage2));
_COM_SMARTPTR_TYPEDEF(IPropertyPageSite, __uuidof(IPropertyPageSite));
_COM_SMARTPTR_TYPEDEF(IPropertySetStorage, __uuidof(IPropertySetStorage));
_COM_SMARTPTR_TYPEDEF(IPropertyStorage, __uuidof(IPropertyStorage));
_COM_SMARTPTR_TYPEDEF(IProvideClassInfo, __uuidof(IProvideClassInfo));
_COM_SMARTPTR_TYPEDEF(IProvideClassInfo2, __uuidof(IProvideClassInfo2));
_COM_SMARTPTR_TYPEDEF(IProvideMultipleClassInfo, __uuidof(IProvideMultipleClassInfo));
_COM_SMARTPTR_TYPEDEF(IQueryInfo, __uuidof(IQueryInfo));
_COM_SMARTPTR_TYPEDEF(IQuickActivate, __uuidof(IQuickActivate));
_COM_SMARTPTR_TYPEDEF(IROTData, __uuidof(IROTData));
_COM_SMARTPTR_TYPEDEF(IRecordInfo, __uuidof(IRecordInfo));
_COM_SMARTPTR_TYPEDEF(IRichEditOle, __uuidof(IRichEditOle));
_COM_SMARTPTR_TYPEDEF(IRichEditOleCallback, __uuidof(IRichEditOleCallback));
_COM_SMARTPTR_TYPEDEF(IRootStorage, __uuidof(IRootStorage));
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer, __uuidof(IRpcChannelBuffer));
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer2, __uuidof(IRpcChannelBuffer2));
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer3, __uuidof(IRpcChannelBuffer3));
_COM_SMARTPTR_TYPEDEF(IRpcProxyBuffer, __uuidof(IRpcProxyBuffer));
_COM_SMARTPTR_TYPEDEF(IRpcStubBuffer, __uuidof(IRpcStubBuffer));
_COM_SMARTPTR_TYPEDEF(IRunnableObject, __uuidof(IRunnableObject));
_COM_SMARTPTR_TYPEDEF(IRunningObjectTable, __uuidof(IRunningObjectTable));
_COM_SMARTPTR_TYPEDEF(ISequentialStream, __uuidof(ISequentialStream));
_COM_SMARTPTR_TYPEDEF(IServerSecurity, __uuidof(IServerSecurity));
_COM_SMARTPTR_TYPEDEF(IServiceProvider, __uuidof(IServiceProvider));
_COM_SMARTPTR_TYPEDEF(IShellBrowser, __uuidof(IShellBrowser));
_COM_SMARTPTR_TYPEDEF(IShellDispatch, __uuidof(IShellDispatch));
_COM_SMARTPTR_TYPEDEF(IShellExecuteHookA, __uuidof(IShellExecuteHookA));
_COM_SMARTPTR_TYPEDEF(IShellExecuteHookW, __uuidof(IShellExecuteHookW));
_COM_SMARTPTR_TYPEDEF(IShellExtInit, __uuidof(IShellExtInit));
_COM_SMARTPTR_TYPEDEF(IShellFolder, __uuidof(IShellFolder));
_COM_SMARTPTR_TYPEDEF(IShellFolderViewDual, __uuidof(IShellFolderViewDual));
_COM_SMARTPTR_TYPEDEF(IShellIcon, __uuidof(IShellIcon));
_COM_SMARTPTR_TYPEDEF(IShellIconOverlay, __uuidof(IShellIconOverlay));
_COM_SMARTPTR_TYPEDEF(IShellIconOverlayIdentifier, __uuidof(IShellIconOverlayIdentifier));
_COM_SMARTPTR_TYPEDEF(IShellLinkA, __uuidof(IShellLinkA));
_COM_SMARTPTR_TYPEDEF(IShellLinkDual, __uuidof(IShellLinkDual));
_COM_SMARTPTR_TYPEDEF(IShellLinkW, __uuidof(IShellLinkW));
_COM_SMARTPTR_TYPEDEF(IShellPropSheetExt, __uuidof(IShellPropSheetExt));
_COM_SMARTPTR_TYPEDEF(IShellUIHelper, __uuidof(IShellUIHelper));
_COM_SMARTPTR_TYPEDEF(IShellView, __uuidof(IShellView));
_COM_SMARTPTR_TYPEDEF(IShellView2, __uuidof(IShellView2));
_COM_SMARTPTR_TYPEDEF(IShellWindows, __uuidof(IShellWindows));
_COM_SMARTPTR_TYPEDEF(ISimpleFrameSite, __uuidof(ISimpleFrameSite));
_COM_SMARTPTR_TYPEDEF(ISoftDistExt, __uuidof(ISoftDistExt));
_COM_SMARTPTR_TYPEDEF(ISpecifyPropertyPages, __uuidof(ISpecifyPropertyPages));
_COM_SMARTPTR_TYPEDEF(IStdMarshalInfo, __uuidof(IStdMarshalInfo));
_COM_SMARTPTR_TYPEDEF(IStorage, __uuidof(IStorage));
_COM_SMARTPTR_TYPEDEF(IStream, __uuidof(IStream));
_COM_SMARTPTR_TYPEDEF(ISubscriptionMgr, __uuidof(ISubscriptionMgr));
_COM_SMARTPTR_TYPEDEF(ISupportErrorInfo, __uuidof(ISupportErrorInfo));
_COM_SMARTPTR_TYPEDEF(ISurrogate, __uuidof(ISurrogate));
_COM_SMARTPTR_TYPEDEF(ISynchronize, __uuidof(ISynchronize));
_COM_SMARTPTR_TYPEDEF(ISynchronizeEvent, __uuidof(ISynchronizeEvent));
_COM_SMARTPTR_TYPEDEF(ISynchronizeMutex, __uuidof(ISynchronizeMutex));
_COM_SMARTPTR_TYPEDEF(ITimer, __uuidof(ITimer));
_COM_SMARTPTR_TYPEDEF(ITimerService, __uuidof(ITimerService));
_COM_SMARTPTR_TYPEDEF(ITimerSink, __uuidof(ITimerSink));
_COM_SMARTPTR_TYPEDEF(ITypeChangeEvents, __uuidof(ITypeChangeEvents));
_COM_SMARTPTR_TYPEDEF(ITypeComp, __uuidof(ITypeComp));
_COM_SMARTPTR_TYPEDEF(ITypeFactory, __uuidof(ITypeFactory));
_COM_SMARTPTR_TYPEDEF(ITypeInfo, __uuidof(ITypeInfo));
_COM_SMARTPTR_TYPEDEF(ITypeInfo2, __uuidof(ITypeInfo2));
_COM_SMARTPTR_TYPEDEF(ITypeLib, __uuidof(ITypeLib));
_COM_SMARTPTR_TYPEDEF(ITypeLib2, __uuidof(ITypeLib2));
_COM_SMARTPTR_TYPEDEF(ITypeMarshal, __uuidof(ITypeMarshal));
_COM_SMARTPTR_TYPEDEF(IURLSearchHook, __uuidof(IURLSearchHook));
_COM_SMARTPTR_TYPEDEF(IUniformResourceLocatorA, __uuidof(IUniformResourceLocatorA));
_COM_SMARTPTR_TYPEDEF(IUniformResourceLocatorW, __uuidof(IUniformResourceLocatorW));
_COM_SMARTPTR_TYPEDEF(IUnknown, __uuidof(IUnknown));
_COM_SMARTPTR_TYPEDEF(IUrlHistoryNotify, __uuidof(IUrlHistoryNotify));
_COM_SMARTPTR_TYPEDEF(IUrlHistoryStg, __uuidof(IUrlHistoryStg));
_COM_SMARTPTR_TYPEDEF(IUrlHistoryStg2, __uuidof(IUrlHistoryStg2));
_COM_SMARTPTR_TYPEDEF(IUrlMon, __uuidof(IUrlMon));
_COM_SMARTPTR_TYPEDEF(IVariantChangeType, __uuidof(IVariantChangeType));
_COM_SMARTPTR_TYPEDEF(IViewFilterSite, __uuidof(IViewFilterSite));
_COM_SMARTPTR_TYPEDEF(IViewObject, __uuidof(IViewObject));
_COM_SMARTPTR_TYPEDEF(IViewObject2, __uuidof(IViewObject2));
_COM_SMARTPTR_TYPEDEF(IViewObjectEx, __uuidof(IViewObjectEx));
_COM_SMARTPTR_TYPEDEF(IViewTransition, __uuidof(IViewTransition));
_COM_SMARTPTR_TYPEDEF(IViewTransitionSite, __uuidof(IViewTransitionSite));
_COM_SMARTPTR_TYPEDEF(IWaitMultiple, __uuidof(IWaitMultiple));
_COM_SMARTPTR_TYPEDEF(IWebBrowser, __uuidof(IWebBrowser));
_COM_SMARTPTR_TYPEDEF(IWebBrowser2, __uuidof(IWebBrowser2));
_COM_SMARTPTR_TYPEDEF(IWebBrowserApp, __uuidof(IWebBrowserApp));
_COM_SMARTPTR_TYPEDEF(IWinInetHttpInfo, __uuidof(IWinInetHttpInfo));
_COM_SMARTPTR_TYPEDEF(IWinInetInfo, __uuidof(IWinInetInfo));
_COM_SMARTPTR_TYPEDEF(IWindowForBindingUI, __uuidof(IWindowForBindingUI));
_COM_SMARTPTR_TYPEDEF(IXMLDocument, __uuidof(IXMLDocument));
_COM_SMARTPTR_TYPEDEF(IXMLElement, __uuidof(IXMLElement));
_COM_SMARTPTR_TYPEDEF(IXMLElementCollection, __uuidof(IXMLElementCollection));
_COM_SMARTPTR_TYPEDEF(IXMLError, __uuidof(IXMLError));
_COM_SMARTPTR_TYPEDEF(OLEDBSimpleProvider, __uuidof(OLEDBSimpleProvider));
_COM_SMARTPTR_TYPEDEF(OLEDBSimpleProviderListener, __uuidof(OLEDBSimpleProviderListener));

#endif  /* _COM_NO_STANDARD_GUIDS_ */

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif  /* _INC_COMDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\comutil.cpp ===
//
// The definitions of functions and data declared in comutil.h
//

#include <comdef.h>

#pragma hdrstop

#include <malloc.h>

#pragma warning(disable:4290)

_variant_t vtMissing(DISP_E_PARAMNOTFOUND, VT_ERROR);

namespace _com_util {
	//
	// Convert char * to BSTR
	//
	BSTR __stdcall ConvertStringToBSTR(const char* pSrc) throw(_com_error)
	{
		if (pSrc == NULL) {
			return NULL;
		}
		else {
			int size = lstrlenA(pSrc) + 1;
            BSTR pDest = static_cast<BSTR>(::malloc(size * sizeof(wchar_t)));
            if (!pDest) {
                _com_issue_error(E_OUTOFMEMORY);
            }

			pDest[0] = '\0';

			if (::MultiByteToWideChar(CP_ACP, 0, pSrc, -1, pDest, size) == 0) {
                free(pDest);
				_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
			}

            BSTR pResult = ::SysAllocString(pDest);
            free(pDest);
            return pResult;
		}
	}

	// Convert BSTR to char *
	//
	char* __stdcall ConvertBSTRToString(BSTR pSrc) throw(_com_error)
	{
		if (pSrc == NULL) {
			return NULL;
		}
		else {
			int size = (wcslen(pSrc) + 1) * sizeof(wchar_t);
			char* pDest = ::new char[size];

			if (pDest == NULL) {
				_com_issue_error(E_OUTOFMEMORY);
			}

			pDest[0] = '\0';

			if (::WideCharToMultiByte(CP_ACP, 0, pSrc, -1, pDest, size, NULL, NULL) == 0) {
				_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
			}

			return pDest;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\comsupp.cpp ===
#include <comdef.h>

#pragma hdrstop

#include <stdarg.h>
#include <malloc.h>

#pragma intrinsic(memset)

#pragma warning(disable:4290)

/////////////////////////////////////////////////////////////////////////////

void __stdcall
_com_issue_error(HRESULT hr) throw(_com_error)
{
	_com_raise_error(hr, NULL);
}

void __stdcall
_com_issue_errorex(HRESULT hr, IUnknown* punk, REFIID riid) throw(_com_error)
{
	IErrorInfo* perrinfo = NULL;
	if (punk == NULL) {
		goto exeunt;
	}
	ISupportErrorInfo* psei;
	if (FAILED(punk->QueryInterface(__uuidof(ISupportErrorInfo),
			   (void**)&psei))) {
		goto exeunt;
	}
	HRESULT hrSupportsErrorInfo;
	hrSupportsErrorInfo = psei->InterfaceSupportsErrorInfo(riid);
	psei->Release();
	if (hrSupportsErrorInfo != S_OK) {
		goto exeunt;
	}
	if (GetErrorInfo(0, &perrinfo) != S_OK) {
		perrinfo = NULL;
	}
exeunt:
	_com_raise_error(hr, perrinfo);
}

/////////////////////////////////////////////////////////////////////////////

#define VT_OPTIONAL	0x0800

struct FLOAT_ARG  { BYTE floatBits[sizeof(float)]; };
struct DOUBLE_ARG { BYTE doubleBits[sizeof(double)]; };

/////////////////////////////////////////////////////////////////////////////

static HRESULT
_com_invoke_helper(IDispatch* pDispatch,
				   DISPID dwDispID,
				   WORD wFlags,
				   VARTYPE vtRet,
				   void* pvRet,
				   const wchar_t* pwParamInfo,
				   va_list argList,
				   IErrorInfo** pperrinfo) throw()
{
	*pperrinfo = NULL;

	if (pDispatch == NULL) {
		return E_POINTER;
	}

	DISPPARAMS dispparams;
	VARIANT* rgvarg;
	rgvarg = NULL;
	memset(&dispparams, 0, sizeof dispparams);

	// determine number of arguments
	if (pwParamInfo != NULL) {
		dispparams.cArgs = lstrlenW(pwParamInfo);
	}

	DISPID dispidNamed;
	dispidNamed = DISPID_PROPERTYPUT;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) {
		if (dispparams.cArgs <= 0) {
			return E_INVALIDARG;
		}
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &dispidNamed;
	}

	if (dispparams.cArgs != 0) {
		// allocate memory for all VARIANT parameters
		rgvarg = (VARIANT*)_alloca(dispparams.cArgs * sizeof(VARIANT));
		memset(rgvarg, 0, sizeof(VARIANT) * dispparams.cArgs);
		dispparams.rgvarg = rgvarg;

		// get ready to walk vararg list
		const wchar_t* pw = pwParamInfo;
		VARIANT* pArg;
		pArg = rgvarg + dispparams.cArgs - 1;   // params go in opposite order

		while (*pw != 0) {
			pArg->vt = *pw & ~VT_OPTIONAL; // set the variant type
			switch (pArg->vt) {
			case VT_I2:
#ifdef _MAC
				pArg->iVal = (short)va_arg(argList, int);
#else
				pArg->iVal = va_arg(argList, short);
#endif
				break;
			case VT_I4:
				pArg->lVal = va_arg(argList, long);
				break;
			case VT_R4:
				// Note: All float arguments to vararg functions are passed
				//  as doubles instead.  That's why they are passed as VT_R8
				//  instead of VT_R4.
				pArg->vt = VT_R8;
				*(DOUBLE_ARG*)&pArg->dblVal = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_R8:
				*(DOUBLE_ARG*)&pArg->dblVal = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_DATE:
				*(DOUBLE_ARG*)&pArg->date = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_CY:
				pArg->cyVal = *va_arg(argList, CY*);
				break;
			case VT_BSTR:
				pArg->bstrVal = va_arg(argList, BSTR);
				break;
			case VT_DISPATCH:
				pArg->pdispVal = va_arg(argList, LPDISPATCH);
				break;
			case VT_ERROR:
				pArg->scode = va_arg(argList, SCODE);
				break;
			case VT_BOOL:
#ifdef _MAC
				V_BOOL(pArg) = (VARIANT_BOOL)va_arg(argList, int)
									? VARIANT_TRUE : VARIANT_FALSE;
#else
				V_BOOL(pArg) = va_arg(argList, VARIANT_BOOL)
									? VARIANT_TRUE : VARIANT_FALSE;
#endif
				break;
			case VT_VARIANT:
				*pArg = *va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN:
				pArg->punkVal = va_arg(argList, LPUNKNOWN);
				break;
			case VT_DECIMAL:
				pArg->decVal = *va_arg(argList, DECIMAL*);
				pArg->vt = VT_DECIMAL;
				break;
			case VT_UI1:
#ifdef _MAC
				pArg->bVal = (BYTE)va_arg(argList, int);
#else
				pArg->bVal = va_arg(argList, BYTE);
#endif
				break;

			case VT_I2|VT_BYREF:
				pArg->piVal = va_arg(argList, short*);
				break;
			case VT_I4|VT_BYREF:
				pArg->plVal = va_arg(argList, long*);
				break;
			case VT_R4|VT_BYREF:
				pArg->pfltVal = va_arg(argList, float*);
				break;
			case VT_R8|VT_BYREF:
				pArg->pdblVal = va_arg(argList, double*);
				break;
			case VT_DATE|VT_BYREF:
				pArg->pdate = va_arg(argList, DATE*);
				break;
			case VT_CY|VT_BYREF:
				pArg->pcyVal = va_arg(argList, CY*);
				break;
			case VT_BSTR|VT_BYREF:
				pArg->pbstrVal = va_arg(argList, BSTR*);
				break;
			case VT_DISPATCH|VT_BYREF:
				pArg->ppdispVal = va_arg(argList, LPDISPATCH*);
				break;
			case VT_ERROR|VT_BYREF:
				pArg->pscode = va_arg(argList, SCODE*);
				break;
			case VT_BOOL|VT_BYREF:
				pArg->pboolVal = va_arg(argList, VARIANT_BOOL*);
				break;
			case VT_VARIANT|VT_BYREF:
				pArg->pvarVal = va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN|VT_BYREF:
				pArg->ppunkVal = va_arg(argList, LPUNKNOWN*);
				break;
			case VT_DECIMAL|VT_BYREF:
				pArg->pdecVal = va_arg(argList, DECIMAL*);
				break;
			case VT_UI1|VT_BYREF:
				pArg->pbVal = va_arg(argList, BYTE*);
				break;

			default:
				// M00REVIEW - For safearrays, should be able to type-check
				// against the base VT_* type.(?)
				if (pArg->vt & VT_ARRAY) {
					if (pArg->vt & VT_BYREF) {
						pArg->pparray = va_arg(argList, LPSAFEARRAY*);
					} else {
						pArg->parray = va_arg(argList, LPSAFEARRAY);
					}
					break;
				}
				// unknown type!
				return E_INVALIDARG;
			}

			--pArg; // get ready to fill next argument
			++pw;
		}

		// Check for missing optional unnamed args at the end of the arglist,
		// and remove them from the DISPPARAMS.  This permits calling servers
		// which modify their action depending on the actual number of args.
		// E.g. Excel95 Application.Workbooks returns a Workbooks* if called
		// with no args, a Workbook* if called with one arg - this shouldn't
		// be necessary, but Excel95 doesn't appear to check for missing
		// args indicated by VT_ERROR/DISP_E_PARAMNOTFOUND.
		pArg = rgvarg + dispparams.cNamedArgs;
		pw = pwParamInfo + dispparams.cArgs - dispparams.cNamedArgs - 1;
		unsigned int cMissingArgs = 0;

		// Count the number of missing arguments
		while (pw >= pwParamInfo) {
			// Optional args must be VARIANT or VARIANT*
			if ((*pw & ~VT_BYREF) != (VT_VARIANT|VT_OPTIONAL)) {
				break;
			}

			VARIANT* pVar;
			pVar = (*pw & VT_BYREF) ? pArg->pvarVal : pArg;
			if (V_VT(pVar) != VT_ERROR ||
				V_ERROR(pVar) != DISP_E_PARAMNOTFOUND)
			{
				break;
			}

			++cMissingArgs;
			++pArg;
			--pw;
		}

		// Move the named args up next to the remaining unnamed args and
		// adjust the DISPPARAMS struct.
		if (cMissingArgs > 0) {
			for (unsigned int c = 0; c < dispparams.cNamedArgs; ++c) {
				rgvarg[c + cMissingArgs] = rgvarg[c];
			}
			dispparams.cArgs -= cMissingArgs;
			dispparams.rgvarg += cMissingArgs;
		}
	}

	// initialize return value
	VARIANT* pvarResult;
	VARIANT vaResult;
	VariantInit(&vaResult);
	pvarResult = (vtRet != VT_EMPTY) ? &vaResult : NULL;

	// initialize EXCEPINFO struct
	EXCEPINFO excepInfo;
	memset(&excepInfo, 0, sizeof excepInfo);

	UINT nArgErr;
	nArgErr = (UINT)-1;  // initialize to invalid arg

	// make the call
	HRESULT hr = pDispatch->Invoke(dwDispID, __uuidof(NULL), 0, wFlags,
								   &dispparams, pvarResult, &excepInfo,
								   &nArgErr);

	// throw exception on failure
	if (FAILED(hr)) {
		VariantClear(&vaResult);
		if (hr != DISP_E_EXCEPTION) {
			// non-exception error code
			// M00REVIEW - Is this all?  What about looking for IErrorInfo?
			//			 - Only if IID is passed in, I'd think
			return hr;
		}

		// make sure excepInfo is filled in
		if (excepInfo.pfnDeferredFillIn != NULL) {
			excepInfo.pfnDeferredFillIn(&excepInfo);
		}

		// allocate new error info, and fill it
		ICreateErrorInfo *pcerrinfo = NULL;
		if (SUCCEEDED(CreateErrorInfo(&pcerrinfo))) {
			// Set up ErrInfo object
			// M00REVIEW - Use IID if decide to pass that in
			pcerrinfo->SetGUID(__uuidof(IDispatch));
			pcerrinfo->SetDescription(excepInfo.bstrDescription);
			pcerrinfo->SetHelpContext(excepInfo.dwHelpContext);
			pcerrinfo->SetHelpFile(excepInfo.bstrHelpFile);
			pcerrinfo->SetSource(excepInfo.bstrSource);

			if (FAILED(pcerrinfo->QueryInterface(__uuidof(IErrorInfo),
												 (void**)pperrinfo))) {
				*pperrinfo = NULL;
			}
		}

		if (excepInfo.wCode != 0) {
            hr = _com_error::WCodeToHRESULT(excepInfo.wCode);
		} else {
			hr = excepInfo.scode;
		}
		return hr;
	}

	if (vtRet != VT_EMPTY) {
		// convert return value unless already correct
		if (vtRet != VT_VARIANT && vtRet != vaResult.vt) {
			hr = VariantChangeType(&vaResult, &vaResult, 0, vtRet);
			if (FAILED(hr)) {
				VariantClear(&vaResult);
				return hr;
			}
		}

		// copy return value into return spot!
		switch (vtRet) {
		case VT_I2:
			*(short*)pvRet = vaResult.iVal;
			break;
		case VT_I4:
			*(long*)pvRet = vaResult.lVal;
			break;
		case VT_R4:
			*(FLOAT_ARG*)pvRet = *(FLOAT_ARG*)&vaResult.fltVal;
			break;
		case VT_R8:
			*(DOUBLE_ARG*)pvRet = *(DOUBLE_ARG*)&vaResult.dblVal;
			break;
		case VT_DATE:
			*(DOUBLE_ARG*)pvRet = *(DOUBLE_ARG*)&vaResult.date;
			break;
		case VT_CY:
			*(CY*)pvRet = vaResult.cyVal;
			break;
		case VT_BSTR:
			*(BSTR*)pvRet = vaResult.bstrVal;
			break;
		case VT_DISPATCH:
			*(LPDISPATCH*)pvRet = vaResult.pdispVal;
			break;
		case VT_ERROR:
			*(SCODE*)pvRet = vaResult.scode;
			break;
		case VT_BOOL:
			*(VARIANT_BOOL*)pvRet = V_BOOL(&vaResult);
			break;
		case VT_VARIANT:
			*(VARIANT*)pvRet = vaResult;
			break;
		case VT_UNKNOWN:
			*(LPUNKNOWN*)pvRet = vaResult.punkVal;
			break;
		case VT_DECIMAL:
			*(DECIMAL*)pvRet = vaResult.decVal;
			break;
		case VT_UI1:
			*(BYTE*)pvRet = vaResult.bVal;
			break;

		default:
			if ((vtRet & (VT_ARRAY|VT_BYREF)) == VT_ARRAY) {
				// M00REVIEW - type-check against the base VT_* type?
				*(LPSAFEARRAY*)pvRet = vaResult.parray;
				break;
			}
			// invalid return type!
			VariantClear(&vaResult);
			return E_INVALIDARG;
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT __cdecl
_com_dispatch_raw_method(IDispatch* pDispatch,
						 DISPID dwDispID,
						 WORD wFlags,
						 VARTYPE vtRet,
						 void* pvRet,
						 const wchar_t* pwParamInfo,
						 ...) throw()
{
	va_list argList;
	va_start(argList, pwParamInfo);

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									vtRet,
									pvRet,
									pwParamInfo,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		SetErrorInfo(0, perrinfo);
	}

	va_end(argList);
	return hr;
}

HRESULT __cdecl
_com_dispatch_method(IDispatch* pDispatch,
					 DISPID dwDispID,
					 WORD wFlags,
					 VARTYPE vtRet,
					 void* pvRet,
					 const wchar_t* pwParamInfo,
					 ...) throw(_com_error)
{
	va_list argList;
	va_start(argList, pwParamInfo);

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									vtRet,
									pvRet,
									pwParamInfo,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		_com_raise_error(hr, perrinfo);
	}

	va_end(argList);
	return hr;
}

HRESULT __stdcall
_com_dispatch_raw_propget(IDispatch* pDispatch,
						  DISPID dwDispID,
						  VARTYPE vtProp,
						  void* pvProp) throw()
{
	return _com_dispatch_raw_method(pDispatch,
									dwDispID,
									DISPATCH_PROPERTYGET,
									vtProp,
									pvProp,
									NULL);
}

HRESULT __stdcall
_com_dispatch_propget(IDispatch* pDispatch,
					  DISPID dwDispID,
					  VARTYPE vtProp,
					  void* pvProp) throw(_com_error)
{
	return _com_dispatch_method(pDispatch,
								dwDispID,
								DISPATCH_PROPERTYGET,
								vtProp,
								pvProp,
								NULL);
}

HRESULT __cdecl
_com_dispatch_raw_propput(IDispatch* pDispatch,
						  DISPID dwDispID,
						  VARTYPE vtProp,
						  ...) throw()
{
	va_list argList;
	va_start(argList, vtProp);
#ifdef _MAC
	argList -= 2;
#endif

	wchar_t rgwParams[2];
	rgwParams[0] = vtProp;
	rgwParams[1] = 0;

	WORD wFlags = (vtProp == VT_DISPATCH || vtProp == VT_UNKNOWN)
					? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT;

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									VT_EMPTY,
									NULL,
									rgwParams,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		SetErrorInfo(0, perrinfo);
	}

	va_end(argList);
	return hr;
}

HRESULT __cdecl
_com_dispatch_propput(IDispatch* pDispatch,
					  DISPID dwDispID,
					  VARTYPE vtProp,
					  ...) throw(_com_error)
{
	va_list argList;
	va_start(argList, vtProp);
#ifdef _MAC
	argList -= 2;
#endif

	wchar_t rgwParams[2];
	rgwParams[0] = vtProp;
	rgwParams[1] = 0;

	WORD wFlags = (vtProp == VT_DISPATCH || vtProp == VT_UNKNOWN)
					? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT;

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									VT_EMPTY,
									NULL,
									rgwParams,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		_com_raise_error(hr, perrinfo);
	}

	va_end(argList);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\comip.h ===
/***
* comip.h - Native C++ compiler COM support - COM interface pointers header
*
*	Copyright (C) 1996-1999 Microsoft Corporation
*	All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_COMIP)
#define _INC_COMIP

#include <ole2.h>
#include <malloc.h>

#include <comutil.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4290)

class _com_error;

void __stdcall _com_issue_error(HRESULT);
struct __declspec(uuid("00000000-0000-0000-c000-000000000046")) IUnknown;

// Provide Interface to IID association
//
template<typename _Interface, const IID* _IID /*= &__uuidof(_Interface)*/> class _com_IIID {
public:
	typedef _Interface Interface;

	static _Interface* GetInterfacePtr() throw()
	{
		return NULL;
	}

	static _Interface& GetInterface() throw()
	{
		return *GetInterfacePtr();
	}

	static const IID& GetIID() throw()
	{
		return *_IID;
	}
};

template<typename _IIID> class _com_ptr_t {
public:
	// Declare interface type so that the type may be available outside
	// the scope of this template.
	//
	typedef _IIID ThisIIID;
	typedef typename _IIID::Interface Interface;

	// When the compiler supports references in template parameters,
	// _CLSID will be changed to a reference.  To avoid conversion
	// difficulties this function should be used to obtain the
	// CLSID.
	//
	static const IID& GetIID() throw()
	{
		return ThisIIID::GetIID();
	}

	// Constructs a smart-pointer from any interface pointer.
	//
	template<typename _InterfacePtr> _com_ptr_t(const _InterfacePtr& p) throw(_com_error)
		: m_pInterface(NULL)
	{
		if (p) {
			HRESULT hr = _QueryInterface(p);

			if (FAILED(hr) && (hr != E_NOINTERFACE)) {
				_com_issue_error(hr);
			}
		}
	}

    // Make sure correct ctor is called
    //
    _com_ptr_t(LPSTR str) throw(_com_error)
		: m_pInterface(NULL)
    {
		HRESULT hr = CreateInstance(str, NULL, CLSCTX_ALL);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
    }

    // Make sure correct ctor is called
    //
    _com_ptr_t(LPWSTR str) throw(_com_error)
		: m_pInterface(NULL)
    {
		HRESULT hr = CreateInstance(str, NULL, CLSCTX_ALL);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
    }

	// Disable conversion using _com_ptr_t* specialization of
	// template<typename _InterfacePtr> _com_ptr_t(const _InterfacePtr& p)
	template<> explicit _com_ptr_t(_com_ptr_t* const & p) throw(_com_error)
	{
		if (p != NULL) {
			_com_issue_error(E_POINTER);
		}
		else {
			m_pInterface = p->m_pInterface;
			AddRef();
		}
	}

	// Default constructor.
	//
	_com_ptr_t() throw()
		: m_pInterface(NULL)
	{
	}

	// This constructor is provided to allow NULL assignment. It will issue
	// an error if any value other than null is assigned to the object.
	//
	_com_ptr_t(int null) throw(_com_error)
		: m_pInterface(NULL)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}
	}

	// Copy the pointer and AddRef().
	//
	template<> _com_ptr_t(const _com_ptr_t& cp) throw()
		: m_pInterface(cp.m_pInterface)
	{
		_AddRef();
	}

	// Saves the interface.
	//
	_com_ptr_t(Interface* pInterface) throw()
		: m_pInterface(pInterface)
	{
		_AddRef();
	}

	// Copies the pointer. If fAddRef is TRUE, the interface will
	// be AddRef()ed.
	//
	_com_ptr_t(Interface* pInterface, bool fAddRef) throw()
		: m_pInterface(pInterface)
	{
		if (fAddRef) {
			_AddRef();
		}
	}

	// Construct a pointer for a _variant_t object.
	//
	template<> _com_ptr_t(const _variant_t& varSrc) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = QueryStdInterfaces(varSrc);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Calls CoCreateClass with the provided CLSID.
	//
	explicit _com_ptr_t(const CLSID& clsid, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = CreateInstance(clsid, pOuter, dwClsContext);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	//
    explicit _com_ptr_t(LPCWSTR str, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = CreateInstance(str, pOuter, dwClsContext);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Calls CoCreateClass with the provided SBCS CLSID retrieved from
	// the string.
	//
	explicit _com_ptr_t(LPCSTR str, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = CreateInstance(str, pOuter, dwClsContext);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Queries for interface.
	//
	template<typename _InterfacePtr> _com_ptr_t& operator=(const _InterfacePtr& p) throw(_com_error)
	{
		HRESULT hr = _QueryInterface(p);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}

		return *this;
	}

	// Saves the interface.
	//
	_com_ptr_t& operator=(Interface* pInterface) throw()
	{
		if (m_pInterface != pInterface) {
			Interface* pOldInterface = m_pInterface;

			m_pInterface = pInterface;

			_AddRef();

			if (pOldInterface != NULL) {
				pOldInterface->Release();
			}
		}

		return *this;
	}

	// Copies and AddRef()'s the interface.
	//
	template<> _com_ptr_t& operator=(const _com_ptr_t& cp) throw()
	{
		return operator=(cp.m_pInterface);
	}

	// This operator is provided to permit the assignment of NULL to the class.
	// It will issue an error if any value other than NULL is assigned to it.
	//
	_com_ptr_t& operator=(int null) throw(_com_error)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}

		return operator=(reinterpret_cast<Interface*>(NULL));
	}

	// Construct a pointer for a _variant_t object.
	//
	template<> _com_ptr_t& operator=(const _variant_t& varSrc) throw(_com_error)
	{
		HRESULT hr = QueryStdInterfaces(varSrc);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}

		return *this;
	}

	// If we still have an interface then Release() it. The interface
	// may be NULL if Detach() has previously been called, or if it was
	// never set.
	//
	~_com_ptr_t() throw()
	{
		_Release();
	}

	// Saves/sets the interface without AddRef()ing. This call
	// will release any previously acquired interface.
	//
	void Attach(Interface* pInterface) throw()
	{
		_Release();
		m_pInterface = pInterface;
	}

	// Saves/sets the interface only AddRef()ing if fAddRef is TRUE.
	// This call will release any previously acquired interface.
	//
	void Attach(Interface* pInterface, bool fAddRef) throw()
	{
		_Release();
		m_pInterface = pInterface;

		if (fAddRef) {
			if (pInterface != NULL) {
				pInterface->AddRef();
			}
		}
	}

	// Simply NULL the interface pointer so that it isn't Released()'ed.
	//
	Interface* Detach() throw()
	{
		Interface* const old=m_pInterface;
		m_pInterface = NULL;
		return old;
	}

	// Return the interface. This value may be NULL.
	//
	operator Interface*() const throw()
	{
		return m_pInterface;
	}

	// Queries for the unknown and return it
	// Provides minimal level error checking before use.
	//
	operator Interface&() const throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return *m_pInterface;
	}

	// Allows an instance of this class to act as though it were the
	// actual interface. Also provides minimal error checking.
	//
	Interface& operator*() const throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return *m_pInterface;
	}

	// Returns the address of the interface pointer contained in this
	// class. This is useful when using the COM/OLE interfaces to create
	// this interface.
	//
	Interface** operator&() throw()
	{
		_Release();
		m_pInterface = NULL;
		return &m_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple error checking.
	//
	Interface* operator->() const throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return m_pInterface;
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	//
	operator bool() const throw()
	{
		return m_pInterface != NULL;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator==(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) == 0;
	}

	// Compare with other interface
	//
	template<> bool operator==(Interface* p) throw(_com_error)
	{
		return (m_pInterface == p) ? true : _CompareUnknown(p) == 0;
	}

	// Compares 2 _com_ptr_t's
	//
	template<> bool operator==(_com_ptr_t& p) throw()
	{
		return operator==(p.m_pInterface);
	}

	// For comparison to NULL
	//
	template<> bool operator==(int null) throw(_com_error)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}

		return m_pInterface == NULL;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator!=(_InterfacePtr p) throw(_com_error)
	{
		return !(operator==(p));
	}

	// Compare with other interface
	//
	template<> bool operator!=(Interface* p) throw(_com_error)
	{
		return !(operator==(p));
	}

	// Compares 2 _com_ptr_t's
	//
	template<> bool operator!=(_com_ptr_t& p) throw(_com_error)
	{
		return !(operator==(p));
	}

	// For comparison to NULL
	//
	template<> bool operator!=(int null) throw(_com_error)
	{
		return !(operator==(null));
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator<(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) < 0;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator>(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) > 0;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator<=(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) <= 0;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator>=(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) >= 0;
	}

	// Provides error-checking Release()ing of this interface.
	//
	void Release() throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		m_pInterface->Release();
		m_pInterface = NULL;
	}

	// Provides error-checking AddRef()ing of this interface.
	//
	void AddRef() throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		m_pInterface->AddRef();
	}

	// Another way to get the interface pointer without casting.
	//
	Interface* GetInterfacePtr() const throw()
	{
		return m_pInterface;
	}

	// Loads an interface for the provided CLSID.
	// Returns an HRESULT.  Any previous interface is released.
	//
	HRESULT CreateInstance(const CLSID& rclsid, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		HRESULT hr;

		_Release();

		if (dwClsContext & (CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)) {
			IUnknown* pIUnknown;

			hr = CoCreateInstance(rclsid, pOuter, dwClsContext, __uuidof(IUnknown), reinterpret_cast<void**>(&pIUnknown));

			if (FAILED(hr)) {
				return hr;
			}

			hr = OleRun(pIUnknown);

			if (SUCCEEDED(hr)) {
				hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));
			}

			pIUnknown->Release();
		}
		else {
			hr = CoCreateInstance(rclsid, pOuter, dwClsContext, GetIID(), reinterpret_cast<void**>(&m_pInterface));
		}

		return hr;
	}

	// Creates the class specified by clsidString.  clsidString may
	// contain a class id, or a prog id string.
	//
    HRESULT CreateInstance(LPCWSTR clsidString, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
    {
		if (clsidString == NULL) {
			return E_INVALIDARG;
		}

		CLSID clsid;
		HRESULT hr;

		if (clsidString[0] == '{') {
            hr = CLSIDFromString(const_cast<LPWSTR> (clsidString), &clsid);
        }
		else {
            hr = CLSIDFromProgID(const_cast<LPWSTR> (clsidString), &clsid);
        }

		if (FAILED(hr)) {
			return hr;
		}

		return CreateInstance(clsid, pOuter, dwClsContext);
	}

	// Creates the class specified by SBCS clsidString.  clsidString may
	// contain a class id, or a prog id string.
	//
	HRESULT CreateInstance(LPCSTR clsidStringA, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		if (clsidStringA == NULL) {
			return E_INVALIDARG;
		}

		int size = lstrlenA(clsidStringA) + 1;
        LPWSTR clsidStringW = static_cast<LPWSTR>(_alloca(size * 2));

		clsidStringW[0] = '\0';

		if (MultiByteToWideChar(CP_ACP, 0, clsidStringA, -1, clsidStringW, size) == 0) {
			return HRESULT_FROM_WIN32(GetLastError());
		}

		return CreateInstance(clsidStringW, pOuter, dwClsContext);
	}

	// Attach to the active object specified by rclsid.
	// Any previous interface is released.
	//
	HRESULT GetActiveObject(const CLSID& rclsid) throw()
	{
		_Release();

		IUnknown* pIUnknown;

		HRESULT hr = ::GetActiveObject(rclsid, NULL, &pIUnknown);

		if (FAILED(hr)) {
			return hr;
		}

		hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));

		if (FAILED(hr)) {
			return hr;
		}

		pIUnknown->Release();

		return hr;
	}

	// Attach to the active object specified by clsidString.
    // First convert the LPCWSTR to a CLSID.
	//
    HRESULT GetActiveObject(LPCWSTR clsidString) throw()
    {
		if (clsidString == NULL) {
			return E_INVALIDARG;
		}

		CLSID clsid;
		HRESULT hr;

		if (clsidString[0] == '{') {
            hr = CLSIDFromString(const_cast<LPWSTR> (clsidString), &clsid);
        }
		else {
            hr = CLSIDFromProgID(const_cast<LPWSTR> (clsidString), &clsid);
        }

		if (FAILED(hr)) {
			return hr;
		}

		return GetActiveObject(clsid);
	}

	// Attach to the active object specified by clsidStringA.
    // First convert the LPCSTR to a LPCWSTR.
	//
	HRESULT GetActiveObject(LPCSTR clsidStringA) throw()
	{
		if (clsidStringA == NULL) {
			return E_INVALIDARG;
		}

		int size = lstrlenA(clsidStringA) + 1;
        LPWSTR clsidStringW = static_cast<LPWSTR>(_alloca(size * 2));

		clsidStringW[0] = '\0';

		if (MultiByteToWideChar(CP_ACP, 0, clsidStringA, -1, clsidStringW, size) == 0) {
			return HRESULT_FROM_WIN32(GetLastError());
		}

		return GetActiveObject(clsidStringW);
	}

	// Performs the QI for the specified IID and returns it in p.
	// As with all QIs, the interface will be AddRef'd.
	//
	template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType*& p) throw ()
	{
		if (m_pInterface != NULL) {
			return m_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p));
		}

		return E_POINTER;
	}

	// Performs the QI for the specified IID and returns it in p.
	// As with all QIs, the interface will be AddRef'd.
	//
	template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType** p) throw()
	{
		return QueryInterface(iid, *p);
	}

private:
	// The Interface.
	//
	Interface* m_pInterface;

	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	//
	void _Release() throw()
	{
		if (m_pInterface != NULL) {
			m_pInterface->Release();
		}
	}

	// AddRefs only if the interface is not NULL
	//
	void _AddRef() throw()
	{
		if (m_pInterface != NULL) {
			m_pInterface->AddRef();
		}
	}

	// Performs a QI on pUnknown for the interface type returned
	// for this class.  The interface is stored.  If pUnknown is
	// NULL, or the QI fails, E_NOINTERFACE is returned and
	// _pInterface is set to NULL.
	//
	template<typename _InterfacePtr> HRESULT _QueryInterface(const _InterfacePtr& p) throw()
	{
		HRESULT hr;

		// Can't QI NULL
		//
		if (p) {
			// Query for this interface
			//
			Interface* pInterface;
			hr = p->QueryInterface(GetIID(), reinterpret_cast<void**>(&pInterface));

			if (FAILED(hr)) {
				// If failed initialize interface to NULL and return HRESULT.
				//
				Attach(NULL);
				return hr;
			}

			// Save the interface without AddRef()ing.
			//
			Attach(pInterface);
		}
		else {
			operator=(static_cast<Interface*>(NULL));
			hr = E_NOINTERFACE;
		}

		return hr;
	}

	// Compares the provided pointer with this by obtaining IUnknown interfaces
	// for each pointer and then returning the difference.
	//
	template<typename _InterfacePtr> int _CompareUnknown(_InterfacePtr p) throw(_com_error)
	{
		IUnknown* pu1, *pu2;

		if (m_pInterface != NULL) {
			HRESULT hr = m_pInterface->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(&pu1));

			if (FAILED(hr)) {
				_com_issue_error(hr);
			}

			pu1->Release();
		}
		else {
			pu1 = NULL;
		}

		if (p) {
			HRESULT hr = p->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(&pu2));

			if (FAILED(hr)) {
				_com_issue_error(hr);
			}

			pu2->Release();
		}
		else {
			pu2 = NULL;
		}

		return pu1 - pu2;
	}

	// Try to extract either IDispatch* or an IUnknown* from
	// the VARIANT
	//
	HRESULT QueryStdInterfaces(const _variant_t& varSrc) throw()
	{
		if (V_VT(&varSrc) == VT_DISPATCH) {
			return _QueryInterface(V_DISPATCH(&varSrc));
		}

		if (V_VT(&varSrc) == VT_UNKNOWN) {
			return _QueryInterface(V_UNKNOWN(&varSrc));
		}

		// We have something other than an IUnknown or an IDispatch.
		// Can we convert it to either one of these?
		// Try IDispatch first
		//
		VARIANT varDest;
		VariantInit(&varDest);

		HRESULT hr = VariantChangeType(&varDest, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc)), 0, VT_DISPATCH);
		if (SUCCEEDED(hr)) {
			hr = _QueryInterface(V_DISPATCH(&varSrc));
		}

		if (FAILED(hr) && (hr == E_NOINTERFACE)) {
			// That failed ... so try IUnknown
			//
			VariantInit(&varDest);
			hr = VariantChangeType(&varDest, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc)), 0, VT_UNKNOWN);
			if (SUCCEEDED(hr)) {
				hr = _QueryInterface(V_UNKNOWN(&varSrc));
			}
		}

		VariantClear(&varDest);
		return hr;
	}
};

// Reverse comparison operators for _com_ptr_t
//
template<typename _InterfaceType> bool operator==(int null, _com_ptr_t<_InterfaceType>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p == NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator==(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p == i;
}

template<typename _Interface> bool operator!=(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p != NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator!=(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p != i;
}

template<typename _Interface> bool operator<(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p > NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator<(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p > i;
}

template<typename _Interface> bool operator>(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p < NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator>(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p < i;
}

template<typename _Interface> bool operator<=(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p >= NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator<=(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p >= i;
}

template<typename _Interface> bool operator>=(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p <= NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator>=(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p <= i;
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif // _INC_COMIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wu.inc ===
#
# Windows Update project wide include
#
# Owner: PeterWi

!ifdef WUBLDTYPE
!if "$(WUBLDTYPE)" != "unicode"
BINPLACE_FLAGS = $(BINPLACE_FLAGS) -b $(WUBLDTYPE)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\makefile.inc ===
.SUFFIXES:.h

# Copy .h file from here to sdk\inc
.h{$(SDK_INC_PATH)}.h:
    attrib -r $@
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\acpitabl.h ===
/*****************************************************************************
 *
 *      (C) Copyright MICROSOFT Corp., 1996
 *
 *      Title:          ACPITABL.H --- Definitions and descriptions of the various BIOS supplied ACPI tables.
 *
 *      Version:        1.00
 *
 *      Date:           6-17-96
 *
 *      Author:         Jason Clark (jasoncl)
 *
 *------------------------------------------------------------------------------
 *
 *      Change log:
 *
 *         DATE     REV DESCRIPTION
 *      ----------- --- -----------------------------------------------------------
 *
 ****************************************************************************/

//      These map to bios provided structures, so turn on 1 byte packing

#include <pshpack1.h>

#define SPEC_VER 100

#define RSDP_SIGNATURE 0x2052545020445352       // "RSD PTR "

typedef struct  _RSDP   {       // Root System Description Table Pointer Structure

ULONGLONG       Signature;              // 8 UCHAR table signature 'RSD PTR '
UCHAR   Checksum;                       // sum of all UCHARs of structure must = 0
UCHAR   OEMID[6];                       //      String that uniquely ID's the OEM
UCHAR   Reserved[1];            // must be 0
ULONG   RsdtAddress;            // physical address of Root System Description Table

}       RSDP;

typedef RSDP    *PRSDP;

#ifndef NEC_98
#define RSDP_SEARCH_RANGE_BEGIN         0xE0000         // physical address where we begin searching for the RSDP
#else   // NEC_98
#define RSDP_SEARCH_RANGE_BEGIN         0xE8000         // physical address where we begin searching for the RSDP
#endif  // NEC_98
#define RSDP_SEARCH_RANGE_END           0xFFFFF
#define RSDP_SEARCH_RANGE_LENGTH        (RSDP_SEARCH_RANGE_END-RSDP_SEARCH_RANGE_BEGIN+1)
#define RSDP_SEARCH_INTERVAL            16      // search on 16 byte boundaries

typedef struct _DESCRIPTION_HEADER      {       // Header structure appears at the beginning of each ACPI table

ULONG   Signature;                      //      Signature used to identify the type of table
ULONG   Length;                         //      Length of entire table including the DESCRIPTION_HEADER
UCHAR   Revision;                       //      Minor version of ACPI spec to which this table conforms
UCHAR   Checksum;                       //      sum of all bytes in the entire TABLE should = 0
UCHAR   OEMID[6];                       //      String that uniquely ID's the OEM
UCHAR   OEMTableID[8];                  //      String that uniquely ID's this table (used for table patching and replacement).
ULONG   OEMRevision;                    //      OEM supplied table revision number.  Bigger number = newer table.
#if SPEC_VER > 92
UCHAR   CreatorID[4];                   //      Vendor ID of utility which created this table.
ULONG   CreatorRev;                     //      Revision of utility that created the table.
#endif

}       DESCRIPTION_HEADER;

typedef DESCRIPTION_HEADER      *PDESCRIPTION_HEADER;

// Header constants

#define ACPI_MAX_SIGNATURE       4
#define ACPI_MAX_OEM_ID          6
#define ACPI_MAX_TABLE_ID        8
#define ACPI_MAX_TABLE_STRINGS   ACPI_MAX_SIGNATURE + ACPI_MAX_OEM_ID + ACPI_MAX_TABLE_ID

#define FACS_SIGNATURE  0x53434146      // "FACS"

typedef struct _FACS    {       // Firmware ACPI Control Structure.  Note that this table does not have a header, it is pointed to by the FADT

ULONG   Signature;      //      'FACS'
ULONG   Length;         //      Length of entire firmware ACPI control structure (must be 64 bytes or larger)
ULONG   HardwareSignature;
ULONG   pFirmwareWakingVector;  // physical address of location where the OS needs to put the firmware waking vector
ULONG   GlobalLock;     // 32 bit structure used for sharing Embedded Controller
#if SPEC_VER > 92
ULONG   Flags;
UCHAR   Reserved[40];
#else
UCHAR   Reserved [44];
#endif

}       FACS;

typedef FACS    *PFACS;

// FACS.GlobalLock bit field definitions

#define         GL_PENDING_BIT          0x00
#define         GL_PENDING                      (1 << GL_PENDING_BIT)

#define         GL_OWNER_BIT            0x01
#define         GL_OWNER                        (1 << GL_OWNER_BIT)

#define GL_NON_RESERVED_BITS_MASK       (GL_PENDING+GL_OWNED)

// FACS Flags definitions

#define         FACS_S4BIOS_SUPPORTED_BIT   0   // flag indicates whether or not the BIOS will save/restore memory around S4
#define         FACS_S4BIOS_SUPPORTED       (1 << FACS_S4BIOS_SUPPORTED_BIT)


#define FADT_SIGNATURE  0x50434146      // "FACP"

typedef struct _FADT    {               // Fixed ACPI description table

DESCRIPTION_HEADER      Header;
ULONG                           facs;                           // Physical address of the Firmware ACPI Control Structure
ULONG                           dsdt;                           // Physical address of the Differentiated System Description Table
UCHAR                           int_model;                      // System's Interrupt mode, 0=Dual PIC, 1=Multiple APIC, >1 reserved
UCHAR                           reserved4;
USHORT                          sci_int_vector;         // Vector of SCI interrupt.
PUCHAR                          smi_cmd_io_port;        // Address in System I/O Space of the SMI Command port, used to enable and disable ACPI.
UCHAR                           acpi_on_value;          // Value out'd to smi_cmd_port to activate ACPI
UCHAR                           acpi_off_value;         // Value out'd to smi_cmd_port to deactivate ACPI
UCHAR                           s4bios_req;             // Value to write to SMI_CMD to enter the S4 state.
UCHAR                           reserved1;                      // Must Be 0
ULONG                           pm1a_evt_blk_io_port;   // Address in System I/O Space of the PM1a_EVT_BLK register block
ULONG                           pm1b_evt_blk_io_port;   // Address in System I/O Space of the PM1b_EVT_BLK register block
ULONG                           pm1a_ctrl_blk_io_port;  // Address in System I/O Space of the PM1a_CNT_BLK register block
ULONG                           pm1b_ctrl_blk_io_port;  // Address in System I/O Space of the PM1b_CNT_BLK register block
ULONG                           pm2_ctrl_blk_io_port;   // Address in System I/O Space of the PM2_CNT_BLK register block
ULONG                           pm_tmr_blk_io_port;             // Address in System I/O Space of the PM_TMR register block
ULONG                           gp0_blk_io_port;        //      Address in System I/O Space of the GP0 register block
ULONG                           gp1_blk_io_port;        //      Address in System I/O Space of the GP1 register block
UCHAR                           pm1_evt_len;            // number of bytes decoded for PM1_BLK (must be >= 4)
UCHAR                           pm1_ctrl_len;           // number of bytes decoded for PM1_CNT (must be >= 2)
UCHAR                           pm2_ctrl_len;           // number of bytes decoded for PM1a_CNT (must be >= 1)
UCHAR                           pm_tmr_len;                     // number of bytes decoded for PM_TMR (must be >= 4)
UCHAR                           gp0_blk_len;            // number of bytes decoded for GP0_BLK (must be multiple of 2)
UCHAR                           gp1_blk_len;            // number of bytes decoded for GP1_BLK (must be multiple of 2)
UCHAR                           gp1_base;               // index at which GP1 based events start
UCHAR                           reserved2;              // Must Be 0
USHORT                          lvl2_latency;           // Worst case latency in microseconds required to enter and leave the C2 processor state
USHORT                          lvl3_latency;           // Worst case latency in microseconds required to enter and leave the C3 processor state
USHORT                          flush_size;                     // Ignored if WBINVD flag is 1 -- indicates size of memory read to flush dirty lines from
                                                                                // any processors memory caches. A size of zero indicates this is not supported.
USHORT                          flush_stride;           // Ignored if WBINVD flag is 1 -- the memory stride width, in bytes, to perform reads to flush
                                                                                // the processor's memory caches.
UCHAR                           duty_offset;            // zero based index of where the processor's duty cycle setting is within the processor's P_CNT register.
UCHAR                           duty_width;                     // bit width of the processor's duty cycle setting value in the P_CNT register.
                                                                                // a value of zero indicates that processor duty cycle is not supported
UCHAR                           day_alarm_index;
UCHAR                           month_alarm_index;
UCHAR                           century_alarm_index;
#if SPEC_VER > 92
UCHAR                           reserved3[3];
ULONG                           flags;
#else
UCHAR                           reserved3;
ULONG                           flags;
#endif

}       FADT;

typedef FADT            *PFADT;

// definition of FADT.flags bits

// this one bit flag indicates whether or not the WBINVD instruction works properly,if this bit is not set we can not use S2, S3 states, or
// C3 on MP machines
#define         WRITEBACKINVALIDATE_WORKS_BIT           0
#define         WRITEBACKINVALIDATE_WORKS               (1 << WRITEBACKINVALIDATE_WORKS_BIT)

//  this flag indicates if wbinvd works EXCEPT that it does not invalidate the cache
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT   1
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE       (1 << WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT)

//  this flag indicates that the C1 state is supported on all processors.
#define         SYSTEM_SUPPORTS_C1_BIT                  2
#define         SYSTEM_SUPPORTS_C1                      (1 << SYSTEM_SUPPORTS_C1_BIT)

// this one bit flag indicates whether support for the C2 state is restricted to uniprocessor machines
#define         P_LVL2_UP_ONLY_BIT                      3
#define         P_LVL2_UP_ONLY                          (1 << P_LVL2_UP_ONLY_BIT)

//      this bit indicates whether the PWR button is treated as a fix feature (0) or a generic feature (1)
#define         PWR_BUTTON_GENERIC_BIT                  4
#define         PWR_BUTTON_GENERIC                      (1 << PWR_BUTTON_GENERIC_BIT)

#define         SLEEP_BUTTON_GENERIC_BIT                5
#define         SLEEP_BUTTON_GENERIC                    (1 << SLEEP_BUTTON_GENERIC_BIT)

//      this bit indicates whether the RTC wakeup status is reported in fix register space (0) or not (1)
#define         RTC_WAKE_GENERIC_BIT                    6
#define         RTC_WAKE_GENERIC                        (1 << RTC_WAKE_GENERIC_BIT)

#define         RTC_WAKE_FROM_S4_BIT                    7
#define         RTC_WAKE_FROM_S4                        (1 << RTC_WAKE_FROM_S4_BIT)

// This bit indicates whether the machine implements a 24 or 32 bit timer.
#define         TMR_VAL_EXT_BIT                         8
#define         TMR_VAL_EXT                             (1 << TMR_VAL_EXT_BIT)

// This bit indicates whether the machine supports docking
#define         DCK_CAP_BIT                             9
#define         DCK_CAP                                 (1 << DCK_CAP_BIT)

//      spec defines maximum entry/exit latency values for C2 and C3, if the FADT indicates that these values are
//      exceeded then we do not use that C state.

#define         C2_MAX_LATENCY  100
#define         C3_MAX_LATENCY  1000

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY   1
#endif

// Multiple APIC description table

typedef struct _MAPIC   {

DESCRIPTION_HEADER  Header;
ULONG               LocalAPICAddress;   // Physical Address at which each processor can access its local APIC
ULONG               Flags;
ULONG               APICTables[ANYSIZE_ARRAY];  // A list of APIC tables.

}       MAPIC;

typedef MAPIC *PMAPIC;

// Multiple APIC structure flags

#define PCAT_COMPAT_BIT 0   // indicates that the system also has a dual 8259 pic setup.
#define PCAT_COMPAT     (1 << PCAT_COMPAT_BIT)

// APIC Structure Types
#define PROCESSOR_LOCAL_APIC            0
#define IO_APIC                         1
#define ISA_VECTOR_OVERRIDE             2
#define NMI_SOURCE                      3
#define PROCESSOR_LOCAL_APIC_LENGTH     8
#define IO_APIC_LENGTH                  12
#define ISA_VECTOR_OVERRIDE_LENGTH      10
#define NMI_SOURCE_LENGTH               8

// The shared beginning info in all APIC Structures

typedef struct _APICTABLE {
   UCHAR Type;
   UCHAR Length;
} APICTABLE;

typedef APICTABLE *PAPICTABLE;

typedef struct _PROCLOCALAPIC   {

UCHAR   Type;   // should be zero to identify a ProcessorLocalAPIC structure
UCHAR   Length; // better be 8
UCHAR   ACPIProcessorID;    // ProcessorID for which this processor is listed in the ACPI processor declaration
                            // operator.
UCHAR   APICID; //  The processor's local APIC ID.
ULONG   Flags;

}       PROCLOCALAPIC;

typedef PROCLOCALAPIC *PPROCLOCALAPIC;

// Processor Local APIC Flags
#define PLAF_ENABLED_BIT    0
#define PLAF_ENABLED        (1 << PLAF_ENABLED_BIT)

typedef struct _IOAPIC  {

UCHAR   Type;
UCHAR   Length; // better be 12
UCHAR   IOAPICID;
UCHAR   Reserved;
ULONG   IOAPICAddress; // Physical address at which this IO APIC resides.
ULONG   SystemVectorBase; // system interrupt vector index for this APIC

}       IOAPIC;

typedef IOAPIC *PIOAPIC;

// Interrupt Source Override
typedef struct {
    UCHAR   Type;                           // Must be 2
    UCHAR   Length;                         // Must be 10
    UCHAR   Bus;                            // Must be 0
    UCHAR   Source;                         // BusRelative IRQ
    ULONG   GlobalSystemInterruptVector;    // Global IRQ
    USHORT  Flags;                          // Same as MPS INTI Flags
} ISA_VECTOR, *PISA_VECTOR;

// Non Maskable Source Interrupt
typedef struct {
    UCHAR   Type;                           // must be 3
    UCHAR   Length;                         // better be 8
    USHORT  Flags;                          // Same as MPS INTI Flags
    ULONG   GlobalSystemInterruptVector;    // Interrupt connected to NMI
} NMISOURCE, *PNMISOURCE;

typedef struct _SMARTBATTTABLE   {

DESCRIPTION_HEADER  Header;
ULONG   WarningEnergyLevel; // mWh at which the OEM suggests we warn the user that the battery is getting low.
ULONG   LowEnergyLevel;     // mWh at which the OEM suggests we put the machine into a sleep state.
ULONG   CriticalEnergyLevel; // mWH at which the OEM suggests we do an emergency shutdown.

}       SMARTBATTTABLE;

typedef SMARTBATTTABLE *PSMARTBATTTABLE;

#define RSDT_SIGNATURE  0x54445352      // "RSDT"

typedef struct _RSDT    {       // Root System Description Table

DESCRIPTION_HEADER      Header;
ULONG   Tables[ANYSIZE_ARRAY];          // The structure contains an n length array of physical addresses each of which point to another table.

}       RSDT;

typedef RSDT            *PRSDT;

// The below macro uses the min macro to protect against the case where we are running on machine which is compliant with
// a spec prior to .99.  If you had a .92 compliant header and one table pointer we would end of subtracting 32-36 resulting
// in a really big number and hence we would think we had lots and lots of tables...  Using the min macro we end up subtracting
// the length-length getting zero which will be harmless and cause us to fail to load (with a red screen on Win9x) which is
// the best we can do in this case.

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define NumTableEntriesFromRSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/4


#define APIC_SIGNATURE  0x43495041      // "APIC"
#define DSDT_SIGNATURE  0x54445344      // "DSDT"
#define SSDT_SIGNATURE  0x54445353      // "SSDT"
#define PSDT_SIGNATURE  0x54445350      // "PSDT"
#define SBST_SIGNATURE  0x54534253      // "SBST"

typedef struct _DSDT    {       // Differentiated System Description Table

DESCRIPTION_HEADER      Header;
UCHAR                   DiffDefBlock[ANYSIZE_ARRAY];    // this is the AML describing the base system.

}       DSDT;

typedef DSDT            *PDSDT;

//      Resume normal structure packing

#include <poppack.h>

#ifdef BOOLEAN  // hack to build ASL.exe
typedef struct {
    UCHAR   NamespaceProcID;
    UCHAR   ApicID;
    UCHAR   NtNumber;
    BOOLEAN Started;
} PROC_LOCAL_APIC, *PPROC_LOCAL_APIC;

extern PROC_LOCAL_APIC HalpProcLocalApicTable[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\vccomsupport\comutil.h ===
/***
* comutil.h - Native C++ compiler COM support - BSTR, VARIANT wrappers header
*
*	Copyright (C) 1996-1999 Microsoft Corporation
*	All rights reserved.
*
****/

#if !defined(_INC_COMUTIL)
#define _INC_COMUTIL

#if _MSC_VER > 1000
#pragma once
#endif

#include <ole2.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4290)
#pragma warning(disable:4310)

class _com_error;

void __stdcall _com_issue_error(HRESULT);

//////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t;
class _variant_t;

//////////////////////////////////////////////////////////////////////////////
//
// Error checking routines
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
	inline void CheckError(HRESULT hr) throw(_com_error)
	{
		if (FAILED(hr)) {
			_com_issue_error(hr);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Routines for handling conversions between BSTR and char*
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
	// Convert char * to BSTR
	//
	BSTR __stdcall ConvertStringToBSTR(const char* pSrc) throw(_com_error);

	// Convert BSTR to char *
	//
	char* __stdcall ConvertBSTRToString(BSTR pSrc) throw(_com_error);
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for BSTR
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t {
public:
	// Constructors
	//
	_bstr_t() throw();
	_bstr_t(const _bstr_t& s) throw();
	_bstr_t(const char* s) throw(_com_error);
	_bstr_t(const wchar_t* s) throw(_com_error);
	_bstr_t(const _variant_t& var) throw(_com_error);
	_bstr_t(BSTR bstr, bool fCopy) throw(_com_error);

	// Destructor
	//
	~_bstr_t() throw();

	// Assignment operators
	//
	_bstr_t& operator=(const _bstr_t& s) throw();
	_bstr_t& operator=(const char* s) throw(_com_error);
	_bstr_t& operator=(const wchar_t* s) throw(_com_error);
	_bstr_t& operator=(const _variant_t& var) throw(_com_error);

	// Operators
	//
	_bstr_t& operator+=(const _bstr_t& s) throw(_com_error);
	_bstr_t operator+(const _bstr_t& s) const throw(_com_error);

	// Friend operators
	//
	friend _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error);
	friend _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error);

	// Extractors
	//
	operator const wchar_t*() const throw();
	operator wchar_t*() const throw();
	operator const char*() const throw(_com_error);
	operator char*() const throw(_com_error);

	// Comparison operators
	//
	bool operator!() const throw();
	bool operator==(const _bstr_t& str) const throw();
	bool operator!=(const _bstr_t& str) const throw();
	bool operator<(const _bstr_t& str) const throw();
	bool operator>(const _bstr_t& str) const throw();
	bool operator<=(const _bstr_t& str) const throw();
	bool operator>=(const _bstr_t& str) const throw();

	// Low-level helper functions
	//
	BSTR copy() const throw(_com_error);
	unsigned int length() const throw();

	// Binary string assign
	//
	void Assign(BSTR s) throw(_com_error);

private:
	// Referenced counted wrapper
	//
	class Data_t {
	public:
		// Constructors
		//
		Data_t(const char* s) throw(_com_error);
		Data_t(const wchar_t* s) throw(_com_error);
		Data_t(BSTR bstr, bool fCopy) throw(_com_error);
		Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error);

		// Reference counting routines
		//
		unsigned long AddRef() throw();
		unsigned long Release() throw();

		// Extractors
		//
		operator const wchar_t*() const throw();
		operator const char*() const throw(_com_error);

		// Low-level helper functions
		//
		const wchar_t* GetWString() const throw();
		const char* GetString() const throw(_com_error);

		BSTR Copy() const throw(_com_error);
		void Assign(BSTR s) throw(_com_error);
		unsigned int Length() const throw();
		int Compare(const Data_t& str) const throw();

	private:
		wchar_t*		m_wstr;
		mutable char*	m_str;
		unsigned long	m_RefCount;

		// Never allow default construction
		//
		Data_t() throw();

		// Never allow copy
		//
		Data_t(const Data_t& s) throw();

		// Prevent deletes from outside. Release() must be used.
		//
		~Data_t() throw();

		void _Free() throw();
	};

private:
	// Reference counted representation
	//
	Data_t* m_Data;

private:
	// Low-level utilities
	//
	void _AddRef() throw();
	void _Free() throw();
	int _Compare(const _bstr_t& str) const throw();
};

//////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _bstr_t::_bstr_t() throw()
	: m_Data(NULL)
{
}

// Copy constructor
//
inline _bstr_t::_bstr_t(const _bstr_t& s) throw()
	: m_Data(s.m_Data)
{
	_AddRef();
}

// Construct a _bstr_t from a const char*
//
inline _bstr_t::_bstr_t(const char* s) throw(_com_error)
	: m_Data(new Data_t(s))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a _bstr_t from a const whar_t*
//
inline _bstr_t::_bstr_t(const wchar_t* s) throw(_com_error)
	: m_Data(new Data_t(s))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a _bstr_t from a BSTR.  If fCopy is FALSE, give control of
// data to the _bstr_t without making a new copy.
//
inline _bstr_t::_bstr_t(BSTR bstr, bool fCopy) throw(_com_error)
	: m_Data(new Data_t(bstr, fCopy))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Destructor
//
inline _bstr_t::~_bstr_t() throw()
{
	_Free();
}

//////////////////////////////////////////////////////////////////////////////
//
// Assignment operators
//
//////////////////////////////////////////////////////////////////////////////

// Default assign operator
//
inline _bstr_t& _bstr_t::operator=(const _bstr_t& s) throw()
{
	const_cast<_bstr_t*>(&s)->_AddRef();
	_Free();
	m_Data = s.m_Data;

	return *this;
}

// Assign a const char* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const char* s) throw(_com_error)
{
	_Free();
	m_Data = new Data_t(s);

	return *this;
}

// Assign a const wchar_t* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const wchar_t* s) throw(_com_error)
{
	_Free();
	m_Data = new Data_t(s);

	return *this;
}

//////////////////////////////////////////////////////////////////////////////
//
// Operators
//
//////////////////////////////////////////////////////////////////////////////

// Concatenate a _bstr_t onto this _bstr_t
//
inline _bstr_t& _bstr_t::operator+=(const _bstr_t& s) throw(_com_error)
{
	Data_t* newData = new Data_t(*this, s);

	_Free();
	m_Data = newData;

	return *this;
}

// Return the concatenation of this _bstr_t with another _bstr_t
//
inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const throw(_com_error)
{
	_bstr_t b = *this;
	b += s;

	return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Friend Operators
//
//////////////////////////////////////////////////////////////////////////////

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error)
{
	_bstr_t b = s1;
	b += s2;

	return b;
}

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error)
{
	_bstr_t b = s1;
	b += s2;

	return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::operator const wchar_t*() const throw()
{
	return (m_Data != NULL) ? m_Data->GetWString() : NULL;
}

// Extract a wchar_t*
//
inline _bstr_t::operator wchar_t*() const throw()
{
	return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);
}

// Extract a const char_t*
//
inline _bstr_t::operator const char*() const throw(_com_error)
{
	return (m_Data != NULL) ? m_Data->GetString() : NULL;
}

// Extract a char_t*
//
inline _bstr_t::operator char*() const throw(_com_error)
{
	return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
// Comparison operators
//
//////////////////////////////////////////////////////////////////////////////

inline bool _bstr_t::operator!() const throw()
{
	return (m_Data != NULL) ? !m_Data->GetWString() : true;
}

inline bool _bstr_t::operator==(const _bstr_t& str) const throw()
{
	return _Compare(str) == 0;
}

inline bool _bstr_t::operator!=(const _bstr_t& str) const throw()
{
	return _Compare(str) != 0;
}

inline bool _bstr_t::operator<(const _bstr_t& str) const throw()
{
	return _Compare(str) < 0;
}

inline bool _bstr_t::operator>(const _bstr_t& str) const throw()
{
	return _Compare(str) > 0;
}

inline bool _bstr_t::operator<=(const _bstr_t& str) const throw()
{
	return _Compare(str) <= 0;
}

inline bool _bstr_t::operator>=(const _bstr_t& str) const throw()
{
	return _Compare(str) >= 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// Low-level help functions
//
//////////////////////////////////////////////////////////////////////////////

// Extract a copy of the wrapped BSTR
//
inline BSTR _bstr_t::copy() const throw(_com_error)
{
	return (m_Data != NULL) ? m_Data->Copy() : NULL;
}

// Return the length of the wrapped BSTR
//
inline unsigned int _bstr_t::length() const throw()
{
	return (m_Data != NULL) ? m_Data->Length() : 0;
}

// Binary string assign
//
inline void _bstr_t::Assign(BSTR s) throw(_com_error)
{
	if (m_Data != NULL) {
		m_Data->Assign(s);
	}
	else {
		m_Data = new Data_t(s, TRUE);
		if (m_Data == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}
}

// AddRef the BSTR
//
inline void _bstr_t::_AddRef() throw()
{
	if (m_Data != NULL) {
		m_Data->AddRef();
	}
}

// Free the BSTR
//
inline void _bstr_t::_Free() throw()
{
	if (m_Data != NULL) {
		m_Data->Release();
		m_Data = NULL;
	}
}

// Compare two _bstr_t objects
//
inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
{
	if (m_Data == str.m_Data) {
		return 0;
	}

	if (m_Data == NULL) {
		return -1;
	}

	if (str.m_Data == NULL) {
		return 1;
	}

	return m_Data->Compare(*str.m_Data);
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Construct a Data_t from a const char*
//
inline _bstr_t::Data_t::Data_t(const char* s) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	m_wstr = _com_util::ConvertStringToBSTR(s);

	if (m_wstr == NULL && s != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a Data_t from a const wchar_t*
//
inline _bstr_t::Data_t::Data_t(const wchar_t* s) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	m_wstr = ::SysAllocString(s);

	if (m_wstr == NULL && s != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a Data_t from a BSTR.  If fCopy is FALSE, give control of
// data to the Data_t without doing a SysAllocStringByteLen.
//
inline _bstr_t::Data_t::Data_t(BSTR bstr, bool fCopy) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	if (fCopy && bstr != NULL) {
		m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
										 ::SysStringByteLen(bstr));

		if (m_wstr == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}
	else {
		m_wstr = bstr;
	}
}

// Construct a Data_t from the concatenation of two _bstr_t objects
//
inline _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	const unsigned int l1 = s1.length();
	const unsigned int l2 = s2.length();

	m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));

	if (m_wstr == NULL) {
		if (l1 + l2 == 0) {
			return;
		}
		_com_issue_error(E_OUTOFMEMORY);
	}

	const wchar_t* wstr1 = static_cast<const wchar_t*>(s1);

	if (wstr1 != NULL) {
		memcpy(m_wstr, wstr1, (l1 + 1) * sizeof(wchar_t));
	}

	const wchar_t* wstr2 = static_cast<const wchar_t*>(s2);

	if (wstr2 != NULL) {
		memcpy(m_wstr + l1, wstr2, (l2 + 1) * sizeof(wchar_t));
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - reference counting routines
//
//////////////////////////////////////////////////////////////////////////////

inline unsigned long _bstr_t::Data_t::AddRef() throw()
{
	InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
	return m_RefCount;
}

inline unsigned long _bstr_t::Data_t::Release() throw()
{
	ULONG cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));
    if (!cRef) {
		delete this;
	}

	return cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::Data_t::operator const wchar_t*() const throw()
{
	return m_wstr;
}

// Extract a const char_t*
//
inline _bstr_t::Data_t::operator const char*() const throw(_com_error)
{
	return GetString();
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - helper functions
//
//////////////////////////////////////////////////////////////////////////////

inline const wchar_t* _bstr_t::Data_t::GetWString() const throw()
{
	return m_wstr;
}

inline const char* _bstr_t::Data_t::GetString() const throw(_com_error)
{
	if (m_str == NULL) {
		m_str = _com_util::ConvertBSTRToString(m_wstr);

		if (m_str == NULL && m_wstr != NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return m_str;
}

// Return a copy of the wrapped BSTR
//
inline BSTR _bstr_t::Data_t::Copy() const throw(_com_error)
{
	if (m_wstr != NULL) {
		BSTR bstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(m_wstr),
											::SysStringByteLen(m_wstr));

		if (bstr == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}

		return bstr;
	}

	return NULL;
}

inline void _bstr_t::Data_t::Assign(BSTR s) throw(_com_error)
{
	_Free();
	if (s != NULL) {
		wchar_t* tmp = ::SysAllocStringByteLen(reinterpret_cast<char*>(s),
											::SysStringByteLen(s));
		if (tmp == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		} else {
            m_wstr = tmp;
        }
	}
}

// Return the length of the wrapper BSTR
//
inline unsigned int _bstr_t::Data_t::Length() const throw()
{
	return m_wstr ? ::SysStringLen(m_wstr) : 0;
}

// Compare two wrapped BSTRs
//
inline int _bstr_t::Data_t::Compare(const _bstr_t::Data_t& str) const throw()
{
	if (m_wstr == NULL) {
		return str.m_wstr ? -1 : 0;
	}

	if (str.m_wstr == NULL) {
		return 1;
	}

	const unsigned int l1 = ::SysStringLen(m_wstr);
	const unsigned int l2 = ::SysStringLen(str.m_wstr);

	unsigned int len = l1;
	if (len > l2) {
		len = l2;
	}

	BSTR bstr1 = m_wstr;
	BSTR bstr2 = str.m_wstr;

	while (len-- > 0) {
		if (*bstr1++ != *bstr2++) {
			return bstr1[-1] - bstr2[-1];
		}
	}

	return (l1 < l2) ? -1 : (l1 == l2) ? 0 : 1;
}

// Destruct this object
//
inline _bstr_t::Data_t::~Data_t() throw()
{
	_Free();
}

// Free up this object
//
inline void _bstr_t::Data_t::_Free() throw()
{
	if (m_wstr != NULL) {
		::SysFreeString(m_wstr);
	}

	if (m_str != NULL) {
		delete [] m_str;
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for VARIANT
//
//////////////////////////////////////////////////////////////////////////////

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class _variant_t
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

class _variant_t : public ::tagVARIANT {
public:
	// Constructors
	//
	_variant_t() throw();

	_variant_t(const VARIANT& varSrc) throw(_com_error);
	_variant_t(const VARIANT* pSrc) throw(_com_error);
	_variant_t(const _variant_t& varSrc) throw(_com_error);

	_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error);			// Attach VARIANT if !fCopy

	_variant_t(short sSrc, VARTYPE vtSrc = VT_I2) throw(_com_error);	// Creates a VT_I2, or a VT_BOOL
	_variant_t(long lSrc, VARTYPE vtSrc = VT_I4) throw(_com_error);		// Creates a VT_I4, a VT_ERROR, or a VT_BOOL
	_variant_t(float fltSrc) throw();									// Creates a VT_R4
	_variant_t(double dblSrc, VARTYPE vtSrc = VT_R8) throw(_com_error);	// Creates a VT_R8, or a VT_DATE
	_variant_t(const CY& cySrc) throw();								// Creates a VT_CY
	_variant_t(const _bstr_t& bstrSrc) throw(_com_error);				// Creates a VT_BSTR
	_variant_t(const wchar_t *pSrc) throw(_com_error);					// Creates a VT_BSTR
	_variant_t(const char* pSrc) throw(_com_error);						// Creates a VT_BSTR
	_variant_t(IDispatch* pSrc, bool fAddRef = true) throw();			// Creates a VT_DISPATCH
	_variant_t(bool bSrc) throw();										// Creates a VT_BOOL
	_variant_t(IUnknown* pSrc, bool fAddRef = true) throw();			// Creates a VT_UNKNOWN
	_variant_t(const DECIMAL& decSrc) throw();							// Creates a VT_DECIMAL
	_variant_t(BYTE bSrc) throw();										// Creates a VT_UI1
	_variant_t(LONGLONG llSrc) throw();									// Creates a VT_I8
	_variant_t(ULONGLONG ullSrc) throw();								// Creates a VT_UI8

	// Destructor
	//
	~_variant_t() throw(_com_error);

	// Extractors
	//
	operator short() const throw(_com_error);			// Extracts a short from a VT_I2
	operator long() const throw(_com_error);			// Extracts a long from a VT_I4
	operator float() const throw(_com_error);			// Extracts a float from a VT_R4
	operator double() const throw(_com_error);			// Extracts a double from a VT_R8
	operator CY() const throw(_com_error);				// Extracts a CY from a VT_CY
	operator _bstr_t() const throw(_com_error);			// Extracts a _bstr_t from a VT_BSTR
	operator IDispatch*() const throw(_com_error);		// Extracts a IDispatch* from a VT_DISPATCH
	operator bool() const throw(_com_error);			// Extracts a bool from a VT_BOOL
	operator IUnknown*() const throw(_com_error);		// Extracts a IUnknown* from a VT_UNKNOWN
	operator DECIMAL() const throw(_com_error);			// Extracts a DECIMAL from a VT_DECIMAL
	operator BYTE() const throw(_com_error);			// Extracts a BTYE (unsigned char) from a VT_UI1
	operator LONGLONG() const throw(_com_error);		// Extracts a LONGLONG from a VT_I8
	operator ULONGLONG() const throw(_com_error);		// Extracts a ULONGLONG from a VT_UI8
	
	// Assignment operations
	//
	_variant_t& operator=(const VARIANT& varSrc) throw(_com_error);
	_variant_t& operator=(const VARIANT* pSrc) throw(_com_error);
	_variant_t& operator=(const _variant_t& varSrc) throw(_com_error);

	_variant_t& operator=(short sSrc) throw(_com_error);				// Assign a VT_I2, or a VT_BOOL
	_variant_t& operator=(long lSrc) throw(_com_error);					// Assign a VT_I4, a VT_ERROR or a VT_BOOL
	_variant_t& operator=(float fltSrc) throw(_com_error);				// Assign a VT_R4
	_variant_t& operator=(double dblSrc) throw(_com_error);				// Assign a VT_R8, or a VT_DATE
	_variant_t& operator=(const CY& cySrc) throw(_com_error);			// Assign a VT_CY
	_variant_t& operator=(const _bstr_t& bstrSrc) throw(_com_error);	// Assign a VT_BSTR
	_variant_t& operator=(const wchar_t* pSrc) throw(_com_error);		// Assign a VT_BSTR
	_variant_t& operator=(const char* pSrc) throw(_com_error);			// Assign a VT_BSTR
	_variant_t& operator=(IDispatch* pSrc) throw(_com_error);			// Assign a VT_DISPATCH
 	_variant_t& operator=(bool bSrc) throw(_com_error);					// Assign a VT_BOOL
	_variant_t& operator=(IUnknown* pSrc) throw(_com_error);			// Assign a VT_UNKNOWN
	_variant_t& operator=(const DECIMAL& decSrc) throw(_com_error);		// Assign a VT_DECIMAL
	_variant_t& operator=(BYTE bSrc) throw(_com_error);					// Assign a VT_UI1
	_variant_t& operator=(LONGLONG llSrc) throw(_com_error);			// Assign a VT_I8
	_variant_t& operator=(ULONGLONG ullSrc) throw(_com_error);			// Assign a VT_UI8
	
	// Comparison operations
	//
	bool operator==(const VARIANT& varSrc) const throw(_com_error);
	bool operator==(const VARIANT* pSrc) const throw(_com_error);

	bool operator!=(const VARIANT& varSrc) const throw(_com_error);
	bool operator!=(const VARIANT* pSrc) const throw(_com_error);

	// Low-level operations
	//
	void Clear() throw(_com_error);

	void Attach(VARIANT& varSrc) throw(_com_error);
	VARIANT Detach() throw(_com_error);

	void ChangeType(VARTYPE vartype, const _variant_t* pSrc = NULL) throw(_com_error);

	void SetString(const char* pSrc) throw(_com_error); // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _variant_t::_variant_t() throw()
{
	::VariantInit(this);
}

// Construct a _variant_t from a const VARIANT&
//
inline _variant_t::_variant_t(const VARIANT& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a _variant_t from a const VARIANT*
//
inline _variant_t::_variant_t(const VARIANT* pSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
}

// Construct a _variant_t from a const _variant_t&
//
inline _variant_t::_variant_t(const _variant_t& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a _variant_t from a VARIANT&.  If fCopy is FALSE, give control of
// data to the _variant_t without doing a VariantCopy.
//
inline _variant_t::_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error)
{
	if (fCopy) {
		::VariantInit(this);
		_com_util::CheckError(::VariantCopy(this, &varSrc));
	} else {
		memcpy(this, &varSrc, sizeof(varSrc));
		V_VT(&varSrc) = VT_EMPTY;
	}
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline _variant_t::_variant_t(short sSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline _variant_t::_variant_t(long lSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_ERROR) {
		V_VT(this) = VT_ERROR;
		V_ERROR(this) = lSrc;
	}
	else if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}
}

// Construct a VT_R4 VARIANT from a float
//
inline _variant_t::_variant_t(float fltSrc) throw()
{
	V_VT(this) = VT_R4;
	V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline _variant_t::_variant_t(double dblSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_DATE) {
		V_VT(this) = VT_DATE;
		V_DATE(this) = dblSrc;
	}
	else {
		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}
}

// Construct a VT_CY from a CY
//
inline _variant_t::_variant_t(const CY& cySrc) throw()
{
	V_VT(this) = VT_CY;
	V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline _variant_t::_variant_t(const _bstr_t& bstrSrc) throw(_com_error)
{
    BSTR bstr = static_cast<wchar_t*>(bstrSrc);
    BSTR tmp = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                 ::SysStringByteLen(bstr));

	if (tmp == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	} else {
        V_VT(this) = VT_BSTR;
    	V_BSTR(this) = tmp;
    }
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline _variant_t::_variant_t(const wchar_t* pSrc) throw(_com_error)
{
	wchar_t*tmp = ::SysAllocString(pSrc);

	if (tmp == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	} else {
        V_VT(this) = VT_BSTR;
        V_BSTR(this) = tmp;
    }
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline _variant_t::_variant_t(const char* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline _variant_t::_variant_t(IDispatch* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_DISPATCH(this)->AddRef();
	}
}

// Construct a VT_BOOL VARIANT from a bool
//
inline _variant_t::_variant_t(bool bSrc) throw()
{
	V_VT(this) = VT_BOOL;
	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline _variant_t::_variant_t(IUnknown* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_UNKNOWN(this)->AddRef();
	}
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline _variant_t::_variant_t(const DECIMAL& decSrc) throw()
{
	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	//
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline _variant_t::_variant_t(BYTE bSrc) throw()
{
	V_VT(this) = VT_UI1;
	V_UI1(this) = bSrc;
}

// Construct a VT_I8 VARIANT from a LONGLONG
//
inline _variant_t::_variant_t(LONGLONG llSrc) throw()
{
	V_VT(this) = VT_I8;
	V_I8(this) = llSrc;
}

// Construct a VT_UI8 VARIANT from a ULONGLONG
//
inline _variant_t::_variant_t(ULONGLONG ullSrc) throw()
{
	V_VT(this) = VT_UI8;
	V_UI8(this) = ullSrc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline _variant_t::operator short() const throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		return V_I2(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I2, this);

	return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline _variant_t::operator long() const throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		return V_I4(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I4, this);

	return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline _variant_t::operator float() const throw(_com_error)
{
	if (V_VT(this) == VT_R4) {
		return V_R4(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_R4, this);

	return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline _variant_t::operator double() const throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		return V_R8(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_R8, this);

	return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline _variant_t::operator CY() const throw(_com_error)
{
	if (V_VT(this) == VT_CY) {
		return V_CY(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_CY, this);

	return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline _variant_t::operator _bstr_t() const throw(_com_error)
{
	if (V_VT(this) == VT_BSTR) {
		return V_BSTR(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, this);

	return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline _variant_t::operator IDispatch*() const throw(_com_error)
{
	if (V_VT(this) == VT_DISPATCH) {
		V_DISPATCH(this)->AddRef();
		return V_DISPATCH(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_DISPATCH, this);

	V_DISPATCH(&varDest)->AddRef();
	return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline _variant_t::operator bool() const throw(_com_error)
{
	if (V_VT(this) == VT_BOOL) {
		return V_BOOL(this) ? true : false;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BOOL, this);

	return V_BOOL(&varDest) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline _variant_t::operator IUnknown*() const throw(_com_error)
{
	if (V_VT(this) == VT_UNKNOWN) {
		V_UNKNOWN(this)->AddRef();
		return V_UNKNOWN(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UNKNOWN, this);

	V_UNKNOWN(&varDest)->AddRef();
	return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline _variant_t::operator DECIMAL() const throw(_com_error)
{
	if (V_VT(this) == VT_DECIMAL) {
		return V_DECIMAL(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_DECIMAL, this);

	return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline _variant_t::operator BYTE() const throw(_com_error)
{
	if (V_VT(this) == VT_UI1) {
		return V_UI1(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UI1, this);

	return V_UI1(&varDest);
}

// Extracts a VT_I8 into a LONGLONG
//
inline _variant_t::operator LONGLONG() const throw(_com_error)
{
	if(V_VT(this) == VT_I8) {
		return V_I8(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I8, this);

	return (V_I8(&varDest));
}

// Extracts a VT_UI8 into a ULONGLONG
//
inline _variant_t::operator ULONGLONG() const throw(_com_error)
{
	if(V_VT(this) == VT_UI8) {
		return V_UI8(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UI8, this);

	return (V_UI8(&varDest));
}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT& varSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

	return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT* pSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));

	return *this;
}

// Assign a const _variant_t& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const _variant_t& varSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

	return *this;
}

// Assign a short creating either VT_I2 VARIANT or a
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline _variant_t& _variant_t::operator=(short sSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		V_I2(this) = sSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I2
		//
		Clear();

		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}

	return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline _variant_t& _variant_t::operator=(long lSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		V_I4(this) = lSrc;
	}
	else if (V_VT(this) == VT_ERROR) {
		V_ERROR(this) = lSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I4
		//
		Clear();

		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}

	return *this;
}

// Assign a float creating a VT_R4 VARIANT
//
inline _variant_t& _variant_t::operator=(float fltSrc) throw(_com_error)
{
	if (V_VT(this) != VT_R4) {
		// Clear the VARIANT and create a VT_R4
		//
		Clear();

		V_VT(this) = VT_R4;
	}

	V_R4(this) = fltSrc;

	return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline _variant_t& _variant_t::operator=(double dblSrc) throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		V_R8(this) = dblSrc;
	}
	else if(V_VT(this) == VT_DATE) {
		V_DATE(this) = dblSrc;
	}
	else {
		// Clear the VARIANT and create a VT_R8
		//
		Clear();

		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}

	return *this;
}

// Assign a CY creating a VT_CY VARIANT
//
inline _variant_t& _variant_t::operator=(const CY& cySrc) throw(_com_error)
{
	if (V_VT(this) != VT_CY) {
		// Clear the VARIANT and create a VT_CY
		//
		Clear();

		V_VT(this) = VT_CY;
	}

	V_CY(this) = cySrc;

	return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const _bstr_t& bstrSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	if (!bstrSrc) {
        V_VT(this) = VT_BSTR;
		V_BSTR(this) = NULL;
	}
	else {
		BSTR bstr = static_cast<wchar_t*>(bstrSrc);
		wchar_t*tmp = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
											   ::SysStringByteLen(bstr));

		if (tmp == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		} else {
            V_VT(this) = VT_BSTR;
    		V_BSTR(this) = tmp;
        }
	}

	return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const wchar_t* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	if (pSrc == NULL) {
        V_VT(this) = VT_BSTR;
		V_BSTR(this) = NULL;
	}
	else {
		wchar_t*tmp = ::SysAllocString(pSrc);

		if (tmp == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		} else {
            V_VT(this) = VT_BSTR;
            V_BSTR(this) = tmp;
        }
	}

	return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const char* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}

	return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT
//
inline _variant_t& _variant_t::operator=(IDispatch* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_DISPATCH(this)->AddRef();

	return *this;
}

// Assign a bool creating a VT_BOOL VARIANT
//
inline _variant_t& _variant_t::operator=(bool bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_BOOL) {
		// Clear the VARIANT and create a VT_BOOL
		//
		Clear();

		V_VT(this) = VT_BOOL;
	}

	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);

	return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT
//
inline _variant_t& _variant_t::operator=(IUnknown* pSrc) throw(_com_error)
{
	// Clear VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_UNKNOWN(this)->AddRef();

	return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline _variant_t& _variant_t::operator=(const DECIMAL& decSrc) throw(_com_error)
{
	if (V_VT(this) != VT_DECIMAL) {
		// Clear the VARIANT
		//
		Clear();
	}

	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;

	return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline _variant_t& _variant_t::operator=(BYTE bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI1) {
		// Clear the VARIANT and create a VT_UI1
		//
		Clear();

		V_VT(this) = VT_UI1;
	}

	V_UI1(this) = bSrc;

	return *this;
}

// Assign a LONGLONG creating a VT_I8 VARIANT
//
inline _variant_t& _variant_t::operator=(LONGLONG llSrc) throw(_com_error)
{
	if (V_VT(this) != VT_I8) {
		// Clear the VARIANT and create a VT_I8
		//
		Clear();

		V_VT(this) = VT_I8;
	}

	V_I8(this) = llSrc;

	return *this;
}

// Assign a ULONGLONG creating a VT_UI8 VARIANT
//
inline _variant_t& _variant_t::operator=(ULONGLONG ullSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI8) {
		// Clear the VARIANT and create a VT_UI8
		//
		Clear();

		V_VT(this) = VT_UI8;
	}

	V_UI8(this) = ullSrc;

	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a _variant_t against a const VARIANT& for equality
//
inline bool _variant_t::operator==(const VARIANT& varSrc) const throw()
{
	return *this == &varSrc;
}

// Compare a _variant_t against a const VARIANT* for equality
//
inline bool _variant_t::operator==(const VARIANT* pSrc) const throw()
{
	if (this == pSrc) {
		return true;
	}

	//
	// Variants not equal if types don't match
	//
	if (V_VT(this) != V_VT(pSrc)) {
		return false;
	}

	//
	// Check type specific values
	//
	switch (V_VT(this)) {
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_I2:
			return V_I2(this) == V_I2(pSrc);

		case VT_I4:
			return V_I4(this) == V_I4(pSrc);

		case VT_I8:
			return V_I8(this) == V_I8(pSrc);

		case VT_R4:
			return V_R4(this) == V_R4(pSrc);

		case VT_R8:
			return V_R8(this) == V_R8(pSrc);

		case VT_CY:
			return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

		case VT_DATE:
			return V_DATE(this) == V_DATE(pSrc);

		case VT_BSTR:
			return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
					(memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

		case VT_DISPATCH:
			return V_DISPATCH(this) == V_DISPATCH(pSrc);

		case VT_ERROR:
			return V_ERROR(this) == V_ERROR(pSrc);

		case VT_BOOL:
			return V_BOOL(this) == V_BOOL(pSrc);

		case VT_UNKNOWN:
			return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

		case VT_DECIMAL:
			return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

		case VT_UI1:
			return V_UI1(this) == V_UI1(pSrc);

		default:
			_com_issue_error(E_INVALIDARG);
			// fall through
	}

	return false;
}

// Compare a _variant_t against a const VARIANT& for in-equality
//
inline bool _variant_t::operator!=(const VARIANT& varSrc) const throw()
{
	return !(*this == &varSrc);
}

// Compare a _variant_t against a const VARIANT* for in-equality
//
inline bool _variant_t::operator!=(const VARIANT* pSrc) const throw()
{
	return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the _variant_t
//
inline void _variant_t::Clear() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

inline void _variant_t::Attach(VARIANT& varSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to _variant_t
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT _variant_t::Detach() throw(_com_error)
{
	VARIANT varResult = *this;
	V_VT(this) = VT_EMPTY;

	return varResult;
}

// Change the type and contents of this _variant_t to the type vartype and
// contents of pSrc
//
inline void _variant_t::ChangeType(VARTYPE vartype, const _variant_t* pSrc) throw(_com_error)
{
	//
	// If pDest is NULL, convert type in place
	//
	if (pSrc == NULL) {
		pSrc = this;
	}

	if ((this != pSrc) || (vartype != V_VT(this))) {
		_com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
												  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
												  0, vartype));
	}
}

inline void _variant_t::SetString(const char* pSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////////////////

inline _variant_t::~_variant_t() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Mutually-dependent definitions
//
//////////////////////////////////////////////////////////////////////////////////////////

// Construct a _bstr_t from a const _variant_t&
//
inline _bstr_t::_bstr_t(const _variant_t &var) throw(_com_error)
	: m_Data(NULL)
{
	if (V_VT(&var) == VT_BSTR) {
		*this = V_BSTR(&var);
		return;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, &var);

	*this = V_BSTR(&varDest);
}

// Assign a const _variant_t& to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const _variant_t &var) throw(_com_error)
{
	if (V_VT(&var) == VT_BSTR) {
		*this = V_BSTR(&var);
		return *this;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, &var);

	*this = V_BSTR(&varDest);

	return *this;
}

extern _variant_t vtMissing;

#ifndef _USE_RAW
#define bstr_t _bstr_t
#define variant_t _variant_t
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif	// _INC_COMUTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\cdm\sources.inc ===
!include $(WINDOWS_COM)\wu.inc

!IF 0

  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

  File:   source.inc

  Description:

      IU CDM.DLL stub sources

!ENDIF

TARGETNAME=CDM
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK
DLLDEF=..\CDM.DEF
C_DEFINES=$(C_DEFINES) /D_CDM_
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
USE_STL=1
USE_STATIC_ATL=1
USE_MSVCRT=1
#BROWSER_INFO=1
#
# WUBUILD LAB will set this manually
#
# NT_SIGNCODE=1

TARGETLIBS=     \
    $(SDK_LIB_PATH)\kernel32.lib        \
    $(SDK_LIB_PATH)\user32.lib          \
    $(SDK_LIB_PATH)\advapi32.lib        \
    $(SDK_LIB_PATH)\wininet.lib         \
    $(SDK_LIB_PATH)\cabinet.lib         \
    $(SDK_LIB_PATH)\shlwapi.lib         \
    $(SDK_LIB_PATH)\uuid.lib			\
    $(SDK_LIB_PATH)\ole32.lib			\
    $(SDK_LIB_PATH)\oleaut32.lib        \
    $(SDK_LIB_PATH)\wintrust.lib        \
    $(SDK_LIB_PATH)\rasapi32.lib	    \
    $(SDK_LIB_PATH)\crypt32.lib			\
    $(SDK_LIB_PATH)\cfgmgr32.lib		\
    $(SDK_LIB_PATH)\setupapi.lib		\
	$(SDK_LIB_PATH)\version.lib			\
	$(SDK_LIB_PATH)\advpack.lib			\
	$(SDK_LIB_PATH)\shell32.lib			\
	$(WULIB)\logging\$(WUBLDTYPE)\$(O)\logging.lib	\
    $(WULIB)\util\$(WUBLDTYPE)\$(O)\util.lib		\
    $(WULIB)\detect\$(WUBLDTYPE)\$(O)\detect.lib     \
    $(WULIB)\download\$(WUBLDTYPE)\$(O)\download.lib   \
    $(WULIB)\install\$(WUBLDTYPE)\$(O)\install.lib    \
    $(WULIB)\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib    

#
# cdm.h is checked in as //depot/Lab04_N/enduser/published/inc/cdm.w and
# published to $(BASEDIR)\public\internal\enduser\inc
#
INCLUDES=$(INCLUDES);$(WINDOWS_COM)\inc;$(BASEDIR)\public\internal\enduser\inc;

SOURCES= \
	..\cdm.cpp			\
	..\cdm.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\asptlb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Mon Nov 03 15:43:09 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IReadCookie_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IReadCookie_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Count_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IReadCookie_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Key_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IReadCookie_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\diamond.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   diamond.h
//
//  Description:
//
//      IU diamond decompression library
//
//=======================================================================

#ifndef __DIAMOND_INC
#define __DIAMOND_INC

HRESULT DecompressFolderCabs(LPCTSTR pszDecompressPath);
BOOL DecompressFile(LPCTSTR pszDecompressFile, LPCTSTR pszDecompressPath);
// BOOL DecompressFileToMem(LPCTSTR pszDecompressFile, PBYTE *ppBuffer);

#endif	//__FILEUTIL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\dllite.h ===
#ifndef DLLITE_H
#define DLLITE_H

// if a new dll is added here or the values are changed, be sure to change the 
//  c_cchFilePathBuffer value below to match
const TCHAR  c_szWinHttpDll[]        = _T("winhttp.dll");
const TCHAR  c_szWinInetDll[]        = _T("wininet.dll");

// this value is comprised of the size (in TCHARS) of the largest dll above + 
//  the size of a backslash + the size of the null termiantor
const DWORD  c_cchFilePathBuffer     = (sizeof(c_szWinHttpDll) / sizeof(TCHAR)) + 1 + 1;

typedef struct tagSAUProxySettings
{
    LPWSTR  wszProxyOrig;
    LPWSTR  wszBypass;
    DWORD   dwAccessType;
    
    LPWSTR  *rgwszProxies;
    DWORD   cProxies;
    DWORD   iProxy;
} SAUProxySettings;

HRESULT DownloadFileLite(LPCTSTR pszDownloadUrl, 
                         LPCTSTR pszLocalFile,  
                         HANDLE hQuitEvent,
                         DWORD dwFlags);

HRESULT GetAUProxySettings(LPCWSTR wszUrl, SAUProxySettings *paups);
HRESULT FreeAUProxySettings(SAUProxySettings *paups);
HRESULT CleanupDownloadLib(void);

DWORD   GetAllowedDownloadTransport(DWORD dwInitialFlags);
BOOL    HandleEvents(HANDLE *phEvents, UINT nEventCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\cdm\cdm.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdm.cpp
//
//  Description:
//
//      Functions exported by CDM
//
//			CloseCDMContext
//          DetFilesDownloaded
//			DownloadGetUpdatedFiles
//			DownloadIsInternetAvailable	
//			DownloadUpdatedFiles
//			FindMatchingDriver
//			LogDriverNotFound
//			OpenCDMContext
//			OpenCDMContextEx
//			QueryDetectionFiles
//
//=======================================================================
#include <objbase.h>
#include <winbase.h>
#include <tchar.h>
#include <logging.h>
#include <iucommon.h>
#include <loadengine.h>
#include <osdet.h>
#include <iu.h>
#include <wininet.h>
#include <wusafefn.h>

static BOOL g_fCloseConnection /* FALSE */;

static HMODULE g_hEngineModule /* = NULL */;
static PFN_InternalDetFilesDownloaded			g_pfnDetFilesDownloaded /* = NULL */;
static PFN_InternalDownloadGetUpdatedFiles		g_pfnDownloadGetUpdatedFiles /* = NULL */;
static PFN_InternalDownloadUpdatedFiles			g_pfnDownloadUpdatedFiles /* = NULL */;
static PFN_InternalFindMatchingDriver			g_pfnFindMatchingDriver /* = NULL */;
static PFN_InternalLogDriverNotFound			g_pfnLogDriverNotFound /* = NULL */;
static PFN_InternalQueryDetectionFiles			g_pfnQueryDetectionFiles /* = NULL */;
static PFN_InternalSetGlobalOfflineFlag			g_pfnSetGlobalOfflineFlag /* = NULL */;
static PFN_SetOperationMode						g_pfnSetOperationMode /* = NULL */;

static HMODULE									g_hCtlModule /* = NULL */;
static long										g_lLoadEngineRefCount /* = 0 */;
static PFN_LoadIUEngine							g_pfnCtlLoadIUEngine /* = NULL */;
static PFN_UnLoadIUEngine						g_pfnCtlUnLoadIUEngine /* = NULL */;


static CRITICAL_SECTION g_cs;
BOOL g_fInitCS;

const TCHAR szOpenCDMContextFirst[] = _T("Must OpenCDMContext first!");
//
// constant for SetOperationMode() API (BUILD util won't allow building iuctl.idl from cdm dir)
//
const LONG		UPDATE_COMMAND_CANCEL				= 0x00000004;


BOOL APIENTRY DllMain(
	HINSTANCE hInstance, 
    DWORD  ul_reason_for_call, 
    LPVOID /*lpReserved*/
)
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls(hInstance);

			g_fInitCS = SafeInitializeCriticalSection(&g_cs);
			//
			// Initialize free logging
			//
			InitFreeLogging(_T("CDM"));
			LogMessage("Starting");

			if (!g_fInitCS)
			{
				LogError(E_FAIL, "InitializeCriticalSection");
				return FALSE;
			}
			break;
		case DLL_PROCESS_DETACH:
			//
			// Shutdown free logging
			//
			LogMessage("Shutting down");
			TermFreeLogging();

			if (g_fInitCS)
			{
				DeleteCriticalSection(&g_cs);
			}
			break;
    }
    return TRUE;
}

void UnLoadCtlAndEngine(void)
{
	LOG_Block("UnLoadCtlAndEngine");

	EnterCriticalSection(&g_cs);

	if (0 != g_lLoadEngineRefCount)
	{
		g_lLoadEngineRefCount--;
	}

	if (0 == g_lLoadEngineRefCount)
	{
		if(NULL != g_hEngineModule)
		{
			//
			// Call UnLoadIUEngine
			//
			g_pfnCtlUnLoadIUEngine(g_hEngineModule);
			g_hEngineModule = NULL;

			g_pfnDetFilesDownloaded = NULL;
			g_pfnDownloadGetUpdatedFiles = NULL;
			g_pfnDownloadUpdatedFiles = NULL;
			g_pfnFindMatchingDriver = NULL;
			g_pfnLogDriverNotFound = NULL;
			g_pfnQueryDetectionFiles = NULL;
			g_pfnSetGlobalOfflineFlag = NULL;
			g_pfnSetOperationMode = NULL;
		}

		if (NULL != g_hCtlModule)
		{
			//
			// Unload the iuctl.dll
			//
			FreeLibrary(g_hCtlModule);
			g_hCtlModule = NULL;
			g_pfnCtlLoadIUEngine = NULL;
			g_pfnCtlUnLoadIUEngine = NULL;
		}

		if (g_fCloseConnection)
		{
			//
			// We dialed for the user - now disconnect
			//
			if (!InternetAutodialHangup(0))
			{
				LOG_ErrorMsg(E_FAIL);
				SetLastError(E_FAIL);
			}

			g_fCloseConnection = FALSE;
		}
	}

	LeaveCriticalSection(&g_cs);
}

BOOL LoadCtlAndEngine(BOOL fConnectIfNotConnected)
{
	LOG_Block("LoadCtlAndEngine");

	BOOL fRet = FALSE;
	HRESULT hr;
	DWORD dwFlags;
    BOOL fConnected = InternetGetConnectedState(&dwFlags, 0);
	LOG_Driver(_T("fConnectIfNotConnected param is %s"), fConnectIfNotConnected ? _T("TRUE") : _T("FALSE"));
	LOG_Driver(_T("fConnected = %s, dwFlags from InternetGetConnectedState = 0x%08x"), fConnected ? _T("TRUE") : _T("FALSE"), dwFlags);

	EnterCriticalSection(&g_cs);	// start touching globals

	if (fConnectIfNotConnected)
	{
		if (!fConnected)
		{
			if ((INTERNET_CONNECTION_MODEM & dwFlags) && !(INTERNET_CONNECTION_OFFLINE & dwFlags))
			{
				//
				// If we are not already connected to the internet and 
				// the system is configured to use a modem attempt a connection.
				//
				DWORD dwErr;
				if (ERROR_SUCCESS == (dwErr = InternetAttemptConnect(0)))
				{
					LOG_Driver(_T("auto-dial succeeded"));
					//
					// The auto-dial worked, we need to disconnect later
					//
					g_fCloseConnection = TRUE;
					fConnected = TRUE;
				}
				else
				{
					//
					// Bail with error since we are required to be online
					//
					LOG_Driver(_T("auto-dial failed"));
					LOG_ErrorMsg(dwErr);
					SetLastError(dwErr);
					goto CleanUp;
				}
			}
			else
			{
				//
				// We can't connect because we aren't configured for a modem or user set IE offline mode
				//
				LOG_ErrorMsg(ERROR_GEN_FAILURE);
				SetLastError(ERROR_GEN_FAILURE);
				goto CleanUp;
			}
		}
	}

	//
	// Now that we are connected (only required if TRUE == fConnectIfNotConnected)
	//
	if (NULL != g_hEngineModule)
	{
		LOG_Driver(_T("IUEngine is already loaded"));
		//
		// Bump the ref count and return TRUE
		//
		g_lLoadEngineRefCount++;
		fRet = TRUE;
		goto CleanUp;
	}
	//
	// This extra lock on wininet.dll is required to prevent a TerminateThread call from
	// WININET!AUTO_PROXY_DLLS::FreeAutoProxyInfo during FreeLibrary of CDM.DLL.
	//
	// We don't ever free the returned handle, but will fail the call if it returns NULL
	//
	if (NULL == LoadLibraryFromSystemDir(_T("wininet.dll")))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	//
	// Load iuctl.dll and get the [Un]LoadIUEngine function pointers
	//
	if (NULL == (g_hCtlModule = LoadLibraryFromSystemDir(_T("iuctl.dll"))))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (NULL == (g_pfnCtlLoadIUEngine = (PFN_LoadIUEngine) GetProcAddress(g_hCtlModule, "LoadIUEngine")))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (NULL == (g_pfnCtlUnLoadIUEngine = (PFN_UnLoadIUEngine) GetProcAddress(g_hCtlModule, "UnLoadIUEngine")))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}
	//
	// Now we can call LoadIUEngine() 
	//
	if (NULL == (g_hEngineModule = g_pfnCtlLoadIUEngine(TRUE, !fConnected)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	g_pfnDetFilesDownloaded = (PFN_InternalDetFilesDownloaded) GetProcAddress(g_hEngineModule, "InternalDetFilesDownloaded");
	g_pfnDownloadGetUpdatedFiles = (PFN_InternalDownloadGetUpdatedFiles) GetProcAddress(g_hEngineModule, "InternalDownloadGetUpdatedFiles");
	g_pfnDownloadUpdatedFiles = (PFN_InternalDownloadUpdatedFiles) GetProcAddress(g_hEngineModule, "InternalDownloadUpdatedFiles");
	g_pfnFindMatchingDriver = (PFN_InternalFindMatchingDriver) GetProcAddress(g_hEngineModule, "InternalFindMatchingDriver");
	g_pfnLogDriverNotFound = (PFN_InternalLogDriverNotFound) GetProcAddress(g_hEngineModule, "InternalLogDriverNotFound");
	g_pfnQueryDetectionFiles = (PFN_InternalQueryDetectionFiles) GetProcAddress(g_hEngineModule, "InternalQueryDetectionFiles");
	g_pfnSetGlobalOfflineFlag = (PFN_InternalSetGlobalOfflineFlag) GetProcAddress(g_hEngineModule, "InternalSetGlobalOfflineFlag");
	g_pfnSetOperationMode = (PFN_SetOperationMode) GetProcAddress(g_hEngineModule, "EngSetOperationMode");

	if (NULL == g_pfnDetFilesDownloaded				||
		NULL == g_pfnDownloadGetUpdatedFiles		||
		NULL == g_pfnDownloadUpdatedFiles			||
		NULL == g_pfnFindMatchingDriver				||
		NULL == g_pfnLogDriverNotFound				||
		NULL == g_pfnQueryDetectionFiles			||
		NULL == g_pfnSetGlobalOfflineFlag			||
		NULL == g_pfnSetOperationMode  )
	{
		LOG_Driver(_T("GetProcAddress on IUEngine failed"));
		LOG_ErrorMsg(ERROR_CALL_NOT_IMPLEMENTED);
		SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	}
	else
	{
		fRet = TRUE;
		g_lLoadEngineRefCount++;
		// Set Global Offline Flag - checked by XML Classes to disable Validation (schemas are on the net)
		g_pfnSetGlobalOfflineFlag(!fConnected);
	}
	// goto CleanUp;

CleanUp:

	if (FALSE == fRet)
	{
		UnLoadCtlAndEngine();
	}

	LeaveCriticalSection(&g_cs);

	return fRet;
}

//This API closes the internet connection opened with the OpenCDMContext() API.
//If CDM did not open the internet connection this API simply returns. The CDM
//context handle must have been the same handle that was returned from
//the OpenCDMContext() API.
//
//This call cannot fail. If the pConnection handle is invalid this function
//simply ignores it.

VOID WINAPI CloseCDMContext (
	IN HANDLE /* hConnection */	// Obsolete handle returned by OpenCDMContext.
)
{
	LOG_Block("CloseCDMContext");

	//
	// This is the only spot we unload engine (but note exceptions in
	// DownloadGetUpdatedFiles).
	//
	// Doesn't use COM
	//
	UnLoadCtlAndEngine();
}


void WINAPI DetFilesDownloaded(
    IN  HANDLE hConnection
)
{
	LOG_Block("DetFilesDownloaded");

	HRESULT hr;
	if (g_pfnDetFilesDownloaded)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			g_pfnDetFilesDownloaded(hConnection);

			CoUninitialize();
		}
		else
		{
			LOG_ErrorMsg(hr);
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
	}
}

//Win 98 entry point
//This function allows Windows 98 to call the same entry points as NT.
//The function returns TRUE if the download succeeds and FALSE if it
//does not.

BOOL DownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,	//The win98 download info structure is
												//slightly different that the NT version
												//so this function handles conversion.
	IN OUT LPTSTR			lpDownloadPath,		//returned Download path to the downloaded
												//cab files.
	IN UINT					uSize				//size of passed in download path buffer.
)
{

	LOG_Block("DownloadGetUpdatedFiles");

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return FALSE;
	}

	//
	// Special case - we need to load  and unloadengine since historically we haven't required an
	// OpenCDMContext[Ex] call before calling this function and CloseCDMContext after.
	//
	HRESULT hr;
	BOOL fRet;
	if (LoadCtlAndEngine(TRUE))
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			fRet = g_pfnDownloadGetUpdatedFiles(pDownloadInfoWin98, lpDownloadPath, uSize);

			CoUninitialize();
		}
		else
		{
			LOG_ErrorMsg(hr);
			fRet = FALSE;
		}

		UnLoadCtlAndEngine();
		return fRet;
	}
	else
	{
		return FALSE;
	}
}

//This function determines if this client can connect to the internet.

BOOL DownloadIsInternetAvailable(void)
{
	LOG_Block("DownloadIsInternetAvailable");

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return FALSE;
	}

	//
	// We don't care about the current online state, just if we have a
	// connection configured (returned in dwFlags).
	//
	DWORD dwFlags;
	(void) InternetGetConnectedState(&dwFlags, 0);

	if (	(	(INTERNET_CONNECTION_CONFIGURED & dwFlags)	||
				(INTERNET_CONNECTION_LAN & dwFlags)			||
				(INTERNET_CONNECTION_MODEM  & dwFlags)		||
				(INTERNET_RAS_INSTALLED  & dwFlags)			||
				(INTERNET_CONNECTION_PROXY  & dwFlags)		)

			&&	!(INTERNET_CONNECTION_OFFLINE & dwFlags)
		)
	{
		LOG_Driver(_T("Returning TRUE: InternetGetConnectedState returned 0x%08x in dwFlags"), dwFlags);
		return TRUE;
	}
	else
	{
		LOG_Driver(_T("Returning FALSE: InternetGetConnectedState returned 0x%08x in dwFlags"), dwFlags);
		return FALSE;
	}
}

//This function downloads the specified CDM package. The hConnection handle must have
//been returned from the OpenCDMContext() API.
//
//This function Returns TRUE if download is successful GetLastError() will return
//the error code indicating the reason that the call failed.

BOOL WINAPI DownloadUpdatedFiles(
	IN  HANDLE        hConnection,		//Connection handle from OpenCDMContext() API.
	IN  HWND          hwnd,				//Window handle for call context
	IN  PDOWNLOADINFO pDownloadInfo,	//download information structure describing
										//package to be read from server
	OUT LPWSTR        lpDownloadPath,	//local computer directory location of the
										//downloaded files
	IN  UINT          uSize,			//size of the download path buffer. If this
										//buffer is to small to contain the complete
										//path and file name no file will be downloaded.
										//The PUINT puReguiredSize parameter can be checked
										//to determine the size of buffer necessary to
										//perform the download.
	OUT PUINT         puRequiredSize	//required lpDownloadPath buffer size. This
										//parameter is filled in with the minimum size
										//that is required to place the complete path
										//file name of the downloaded file. If this
										//parameter is NULL no size is returned.
)
{
	LOG_Block("DownloadUpdatedFiles");

	HRESULT hr;
	BOOL fRet;
	if (g_pfnDownloadUpdatedFiles)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			fRet = g_pfnDownloadUpdatedFiles(hConnection, hwnd, pDownloadInfo, lpDownloadPath, uSize, puRequiredSize);

			CoUninitialize();
			return fRet;
		}
		else
		{
			LOG_ErrorMsg(hr);
			return FALSE;
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
		return FALSE;
	}
}

BOOL WINAPI  FindMatchingDriver(
	IN  HANDLE			hConnection,
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
)
{
	LOG_Block("FindMatchingDriver");

	HRESULT hr;
	BOOL fRet;
	if (g_pfnFindMatchingDriver)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			fRet = g_pfnFindMatchingDriver(hConnection, pDownloadInfo, pWuDriverInfo);

			CoUninitialize();
			return fRet;
		}
		else
		{
			LOG_ErrorMsg(hr);
			return FALSE;
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
		return FALSE;
	}
}

// supports offline logging
// hConnection NOT used at all
// no network connection or osdet.dll needed for languauge, SKU, platform detection 
void WINAPI LogDriverNotFound(
    IN  HANDLE hConnection,
	IN LPCWSTR lpDeviceInstanceID,
	IN DWORD dwFlags
)
{
	LOG_Block("LogDriverNotFound");

	HRESULT hr;
	if (g_pfnLogDriverNotFound)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			g_pfnLogDriverNotFound(hConnection, lpDeviceInstanceID, dwFlags);

			CoUninitialize();
		}
		else
		{
			LOG_ErrorMsg(hr);
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
	}
}


HANDLE WINAPI OpenCDMContext(
    IN HWND /* hwnd */	//Window handle to use for any UI that needs to be presented (not used)
)
{
	LOG_Block("OpenCDMContext");

	return OpenCDMContextEx(TRUE);
}

HANDLE WINAPI OpenCDMContextEx(
    IN BOOL fConnectIfNotConnected
)
{
	LOG_Block("OpenCDMContextEx");

	//
	// Don't open a context if we are disabled (0 and -1 OK)
	// Other functions will fail because their g_pfnXxxxx == NULL.
	//
	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		SetLastError(ERROR_SERVICE_DISABLED);
		return NULL;
	}

	//
	// Doesn't use COM
	//
	if (LoadCtlAndEngine(fConnectIfNotConnected))
	{
		//
		// This is an obsolete function that just loads the engine (which may do autodial to connect).
		// We just return non-NULL g_lLoadEngineRefCount to keep existing clients happy, but never use it.
		//


		return LongToHandle(g_lLoadEngineRefCount);
	}
	else
	{
		return NULL;
	}
}

int WINAPI QueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
)
{
	LOG_Block("QueryDetectionFiles");

	HRESULT hr;
	int nRet;
	if (g_pfnQueryDetectionFiles)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			nRet = g_pfnQueryDetectionFiles(hConnection, pCallbackParam, pCallback);

			CoUninitialize();
			return nRet;
		}
		else
		{
			LOG_ErrorMsg(hr);
			return 0;
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
		return 0;
	}
}

//
// 502965 Windows Error Reporting bucket 2096553: Hang following NEWDEV.DLL!CancelDriverSearch
//
// Provide API to allow clients to cancel synchronous calls into CDM by calling this function
// asynchronously from a second thread.
//
HRESULT WINAPI CancelCDMOperation(void)
{
	LOG_Block("CancelCDMOperation");

	if (g_pfnSetOperationMode)
	{
		return g_pfnSetOperationMode(NULL, NULL, UPDATE_COMMAND_CANCEL);
	}
	else
	{
		LOG_ErrorMsg(E_ACCESSDENIED);
		return E_ACCESSDENIED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\freelog.h ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   FreeLog.h
//
//  Owner:  KenSh
//
//  Description:
//
//      Runtime logging for use in both checked and free builds.
//
//=======================================================================

#pragma once

#include <tchar.h>

#define DEFAULT_LOG_FILE_NAME		_T("Windows Update.log")


void InitFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName = DEFAULT_LOG_FILE_NAME);
void TermFreeLogging();

void LogMessage(LPCSTR pszFormatA, ...);
void LogError(DWORD dwError, LPCSTR pszFormatA, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\download.h ===
#ifndef DOWNLOAD_H
#define DOWNLOAD_H

#include <iuprogress.h>

#define DOWNLOAD_STATUS_OK                0
#define DOWNLOAD_STATUS_ITEMCOMPLETE      1
#define DOWNLOAD_STATUS_ERROR             2
#define DOWNLOAD_STATUS_ABORTED           3
#define DOWNLOAD_STATUS_OPERATIONCOMPLETE 4
#define DOWNLOAD_STATUS_ITEMSTART         5

//---------------------------------------------------------------------------
// 
//  type definition for the parameters needed by callback function
//
class COperationMgr;
typedef struct _DOWNLOAD_CALLBACK_DATA
{
    BSTR                bstrOperationUuid;
    HWND                hEventFiringWnd;
    IProgressListener*  pProgressListener;
    float               flProgressPercentage; // Minimum Percentage Increment for Progress 0 == all progress
    float               flLastPercentage; // percentage value of the last progress callback
    LONG                lTotalDownloadSize; // estimated total download size
    LONG                lCurrentItemSize; // estimated current item size
    LONG                lTotalDownloaded; // total bytes downloaded so far
    COperationMgr*      pOperationMgr;
} DCB_DATA, *P_DCB_DATA;


//---------------------------------------------------------------------------
// 
//  type definition for the  callback function
//
typedef BOOL (WINAPI * PFNDownloadCallback)(
                VOID*       pCallbackData,
                DWORD       dwStatus, 
                DWORD       dwBytesTotal, 
                DWORD       dwBlockSizeDownloaded,  // Bytes Downloaded Since Last Callback.
                BSTR        bstrXmlData,            // XML in bstr, used by itemstart/complete, otherwise NULL
                LONG        *lCommandRequest        // return what callback function want to do:
                                                    // PAUSE (1) or CANCEL (3)
                );

//---------------------------------------------------------------------------
//
// DownloadFile
//   Implements the core downloader for IU. This is a single purpose downloader that is very generic,
//   It does not attempt to decompress or checktrust anything it downloads.
//
//   Progress Information is given for each block downloaded through the supplied callback function.
//       Specifying a callback is optional. All callbacks are 'synchronous' and if not immediately 
//       returned will block all downloads in this object.

#define WUDF_DONTALLOWPROXY      0x00000001
#define WUDF_CHECKREQSTATUSONLY  0x00000002
#define WUDF_APPENDCACHEBREAKER  0x00000004
#define WUDF_DODOWNLOADRETRY     0x00000008
#define WUDF_SKIPCABVALIDATION   0x00000010
#define WUDF_SKIPAUTOPROXYCACHE  0x00000020
#define WUDF_PERSISTTRANSPORTDLL 0x00000040

#define WUDF_ALLOWWININETONLY    0x40000000
#define WUDF_ALLOWWINHTTPONLY    0x80000000
#define WUDF_TRANSPORTMASK       (WUDF_ALLOWWINHTTPONLY | WUDF_ALLOWWININETONLY)

HRESULT DownloadFile(
            LPCTSTR pszServerUrl,               // full http url
            LPCTSTR pszLocalPath,               // local directory to download file to
            LPCTSTR pszLocalFileName,           // optional local file name to rename the downloaded file to
            PDWORD  pdwDownloadedBytes,         // bytes downloaded for this file
            HANDLE  *hQuitEvents,               // optional events causing this function to abort
            UINT    nQuitEventCount,            // number of quit events, must be 0 if array is NULL
            PFNDownloadCallback fpnCallback,    // optional call back function
            VOID*   pCallbackData,              // parameter for call back function to use
            DWORD   dwFlags = 0
);


#include "dllite.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\iuprogress.h ===
//
// include IProgressListener interface
//
#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_
MIDL_DEFINE_GUID(IID, IID_IProgressListener,0x229F78AE,0x6618,0x4DF3,0x95,0xD2,0xFC,0x26,0xC9,0xF9,0x74,0x28);

#ifndef __IProgressListener_INTERFACE_DEFINED__
#define __IProgressListener_INTERFACE_DEFINED__

/* interface IProgressListener */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProgressListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("229F78AE-6618-4DF3-95D2-FC26C9F97428")
    IProgressListener : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnItemStart( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItem,
            /* [out] */ LONG *plCommandRequest) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bstrProgress,
            /* [out] */ LONG *plCommandRequest) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnOperationComplete( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgressListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProgressListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProgressListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProgressListener * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnItemStart )( 
            IProgressListener * This,
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItem,
            /* [out] */ LONG *plCommandRequest);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IProgressListener * This,
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bstrProgress,
            /* [out] */ LONG *plCommandRequest);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnOperationComplete )( 
            IProgressListener * This,
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems);
        
        END_INTERFACE
    } IProgressListenerVtbl;

    interface IProgressListener
    {
        CONST_VTBL struct IProgressListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgressListener_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgressListener_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgressListener_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgressListener_OnItemStart(This,bstrUuidOperation,bstrXmlItem,plCommandRequest)	\
    (This)->lpVtbl -> OnItemStart(This,bstrUuidOperation,bstrXmlItem,plCommandRequest)

#define IProgressListener_OnProgress(This,bstrUuidOperation,fItemCompleted,bstrProgress,plCommandRequest)	\
    (This)->lpVtbl -> OnProgress(This,bstrUuidOperation,fItemCompleted,bstrProgress,plCommandRequest)

#define IProgressListener_OnOperationComplete(This,bstrUuidOperation,bstrXmlItems)	\
    (This)->lpVtbl -> OnOperationComplete(This,bstrUuidOperation,bstrXmlItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressListener_OnItemStart_Proxy( 
    IProgressListener * This,
    /* [in] */ BSTR bstrUuidOperation,
    /* [in] */ BSTR bstrXmlItem,
    /* [out] */ LONG *plCommandRequest);


void __RPC_STUB IProgressListener_OnItemStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressListener_OnProgress_Proxy( 
    IProgressListener * This,
    /* [in] */ BSTR bstrUuidOperation,
    /* [in] */ VARIANT_BOOL fItemCompleted,
    /* [in] */ BSTR bstrProgress,
    /* [out] */ LONG *plCommandRequest);


void __RPC_STUB IProgressListener_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressListener_OnOperationComplete_Proxy( 
    IProgressListener * This,
    /* [in] */ BSTR bstrUuidOperation,
    /* [in] */ BSTR bstrXmlItems);


void __RPC_STUB IProgressListener_OnOperationComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProgressListener_INTERFACE_DEFINED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\iucommon.h ===
/////////////////////////////////////////////////////////////////////////////
// Defines
// 
//  2000 Microsoft Corporation. All rights reserved
//

#pragma once

#include <logging.h>	// for CleanUpXxxx that use logging
#include <tchar.h>
//
// 481561 IU: iucommon.h should use safefunc.h instead of redefining SafeRelease()
// Actually, we were first :-), but will correct conflicts in the control code rather than AU.
//
// NOTE: since these headers came from different teams, the same defines may have different
// behavior. For instance SafeRelease() in iucommon.h NULLs the pointer after release, but
// not in safefunc.h. Appropriate adjustments made in the .cpp files.
#include <safefunc.h>

const TCHAR IDENTTXT[] = _T("iuident.txt");
const CHAR	SZ_SEE_IUHIST[] = "See iuhist.xml for details:";

/**
* constant for GetManifest()
*/
const DWORD FLAG_USE_COMPRESSION = 0x00000001;

/**
* constnat for GetManifest(), Detect(), GetSystemSpec(), GetHistory()
*/
const DWORD FLAG_OFFLINE_MODE    = 0x00000002;

//
// MAX_SETUP_MULTI_SZ_SIZE is used to make sure SetupDiGetDeviceRegistryProperty
// doesn't return an unreasonably large buffer (it has been hacked).
//
// Assumptions:
//    * Multi-SZ strings will have a max of 100 strings (should be on order of 10 or less)
//    * Each string will be <= MAX_INF_STRING
//    * Don't bother accounting for NULLs (that will be swampped by overestimate on number of strings)
//
#define MAX_INF_STRING_LEN			512	// From DDK docs "General Syntax Rules for INF Files" section
#define MAX_SETUP_MULTI_SZ_SIZE		(MAX_INF_STRING_LEN * 100 * sizeof(TCHAR))
#define MAX_SETUP_MULTI_SZ_SIZE_W	(MAX_INF_STRING_LEN * 100 * sizeof(WCHAR))	// For explicit WCHAR version

//
// the following are the customized error HRESULT
//
// IU selfupdate error codes
#define IU_SELFUPDATE_NONEREQUIRED      _HRESULT_TYPEDEF_(0x00040000L)
#define IU_SELFUPDATE_USECURRENTDLL     _HRESULT_TYPEDEF_(0x00040001L)
#define IU_SELFUPDATE_USENEWDLL         _HRESULT_TYPEDEF_(0x00040002L)
#define IU_SELFUPDATE_TIMEOUT           _HRESULT_TYPEDEF_(0x80040010L)
#define IU_SELFUPDATE_FAILED            _HRESULT_TYPEDEF_(0x8004FFFFL)
// UrlAgent error codes
#define ERROR_IU_QUERYSERVER_NOT_FOUND			_HRESULT_TYPEDEF_(0x80040012L)
#define ERROR_IU_SELFUPDSERVER_NOT_FOUND		_HRESULT_TYPEDEF_(0x80040022L)

#define ARRAYSIZE(a)					(sizeof(a)/sizeof(a[0]))
#define SafeCloseInvalidHandle(h)		if (INVALID_HANDLE_VALUE != h) { CloseHandle(h); h = INVALID_HANDLE_VALUE; }
//
// Replace with SafeReleaseNULL in safefunc.h
//
// #define SafeRelease(p)					if (NULL != p) { (p)->Release(); p = NULL; }
#define SafeHeapFree(p)					if (NULL != p) { HeapFree(GetProcessHeap(), 0, p); p = NULL; }
//
// NOTE: SysFreeString() takes NULLs (just returns) so we don't have to check for NULL != p
//
#define SafeSysFreeString(p)			{SysFreeString(p); p = NULL;}

//
// Use this if the function being called does logging
//
#define CleanUpIfFailedAndSetHr(x)		{hr = x; if (FAILED(hr)) goto CleanUp;}

//
// Use this if function being called does *not* do logging
//
#define CleanUpIfFailedAndSetHrMsg(x)	{hr = x; if (FAILED(hr)) {LOG_ErrorMsg(hr); goto CleanUp;}}

//
// Use this if function being called does *not* do logging
//
#define CleanUpIfFalseAndSetHrMsg(b,x)	{if (b) {hr = x; LOG_ErrorMsg(hr); goto CleanUp;}}

//
// Use this to log Win32 errors returned from call
//
#define Win32MsgSetHrGotoCleanup(x)		{LOG_ErrorMsg(x); hr = HRESULT_FROM_WIN32(x); goto CleanUp;}

//
// Set hr = x and goto Cleanup (when you need to check HR before going to cleanup)
//
#define SetHrAndGotoCleanUp(x)				{hr = x; goto CleanUp;}

//
// Use this to log an hr msg and goto CleanUp (don't reassign hr like Failed variation)
//
#define SetHrMsgAndGotoCleanUp(x)			{hr = x; LOG_ErrorMsg(hr); goto CleanUp;}

//
// Use this to log HeapAlloc failures only using a single const string
//
#define CleanUpFailedAllocSetHrMsg(x)	{if (NULL == (x)) {hr = E_OUTOFMEMORY; LOG_ErrorMsg(hr); goto CleanUp;}}

//
// Same as CleanUpIfFailedAndSetHrMsg(), but no set hr, instead, pass in hr
//
#define CleanUpIfFailedAndMsg(hr)		{if (FAILED(hr)) {LOG_ErrorMsg(hr); goto CleanUp;}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\loadengine.h ===
#ifndef __LOADENGINE_H_
#define __LOADENGINE_H_

/////////////////////////////////////////////////////////////////////////////
// LoadIUEngine()
//
// load the engine if it's not up-to-date; perform engine's self-update here
/////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI LoadIUEngine(BOOL fSynch, BOOL fOfflineMode);


/////////////////////////////////////////////////////////////////////////////
// UnLoadIUEngine()
//
// release the engine dll if ref cnt of engine is down to zero
/////////////////////////////////////////////////////////////////////////////
void WINAPI UnLoadIUEngine(HMODULE hEngineModule);


/////////////////////////////////////////////////////////////////////////////
// CtlCancelEngineLoad()
//
// Asynchronous Callers can use this abort the LoadEngine SelfUpdate Process
//
// NOTE: CDM.DLL assumes UnLoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CtlCancelEngineLoad();

//
// Typedefs
//
typedef HMODULE (WINAPI * PFN_LoadIUEngine)(BOOL fSynch, BOOL fOfflineMode);

typedef void (WINAPI * PFN_UnLoadIUEngine)(HMODULE hEngineModule);

typedef HRESULT (WINAPI * PFN_CtlCancelEngineLoad)();

#endif //__LOADENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\fileutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   fileutil.h
//
//  Description:
//
//      IU file utility library
//
//=======================================================================

#ifndef __FILEUTIL_INC
#define __FILEUTIL_INC


// ----------------------------------------------------------------------
//
// define constant chars often used in file path processing
//
// ----------------------------------------------------------------------
#ifndef TCHAR_EOS
#define TCHAR_EOS       _T('\0')
#endif
#ifndef TCHAR_STAR
#define TCHAR_STAR      _T('*')
#endif
#ifndef TCHAR_BACKSLASH
#define TCHAR_BACKSLASH _T('\\')
#endif
#ifndef TCHAR_FWDSLASH
#define TCHAR_FWDSLASH  _T('/')
#endif
#ifndef TCHAR_COLON
#define TCHAR_COLON     _T(':')
#endif
#ifndef TCHAR_DOT
#define TCHAR_DOT       _T('.')
#endif
#ifndef TCHAR_SPACE
#define TCHAR_SPACE     _T(' ')
#endif
#ifndef TCHAR_TAB
#define TCHAR_TAB       _T('\t')
#endif




// ----------------------------------------------------------------------
//
// define constants used by path related operations.
// these constants can be found either from CRT or Shlwapi header
// files.
//
// ----------------------------------------------------------------------

#ifdef _MAX_PATH
#undef _MAX_PATH
#endif
#define _MAX_PATH		MAX_PATH

#ifdef _MAX_DRIVE
#undef _MAX_DRIVE
#endif
#define _MAX_DRIVE		3		// buffer size to take drive letter & ":"

#ifdef _MAX_DIR
#undef _MAX_DIR
#endif
#define _MAX_DIR		256		// max. length of path component

#ifdef _MAX_FNAME
#undef _MAX_FNAME
#endif
#define _MAX_FNAME		256		// max. length of file name component

#ifdef _MAX_EXT
#undef _MAX_EXT
#endif
#define _MAX_EXT		256		// max. length of extension component

#define	ARRAYSIZE(x)			(sizeof(x)/sizeof(x[0]))

//Error code for files which are not valid binaries or which do not support the machine architecture
#define BIN_E_MACHINE_MISMATCH HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH)
#define BIN_E_BAD_FORMAT  HRESULT_FROM_WIN32(ERROR_BAD_FORMAT)

// ----------------------------------------------------------------------
//
// Public function MySplitPath() - same as CRT _tsplitpath()
//		to break a path into pieces
//
//	Input: 
//		see below
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
void MySplitPath(
	LPCTSTR lpcszPath,	// original path
	LPTSTR lpszDrive,	// point to buffer to receive drive letter
	LPTSTR lpszDir,		// point to buffer to receive directory
	LPTSTR lpszFName,	// point to buffer to receive file name
	LPTSTR lpszExt		// point to buffer to receive extension
);
			

//---------------------------------------------------------------------
//  CreateNestedDirectory
//      Creates the full path of the directory (nested directories)
//---------------------------------------------------------------------
BOOL CreateNestedDirectory(LPCTSTR pszDir);


//-----------------------------------------------------------------------------------
//  GetIndustryUpdateDirectory
//		This function returns the location of the IndustryUpdate directory. All local
//		files are stored in this directory. The pszPath parameter needs to be at least
//		MAX_PATH.  
//-----------------------------------------------------------------------------------
void GetIndustryUpdateDirectory(LPTSTR pszPath);

//-----------------------------------------------------------------------------------
//  GetWindowsUpdateV3Directory - used for V3 history migration
//		This function returns the location of the WindowsUpdate(V3) directory. All V3 
//      local files are stored in this directory. The pszPath parameter needs to be 
//      at least MAX_PATH.  The directory is created if not found
//-----------------------------------------------------------------------------------
void GetWindowsUpdateV3Directory(LPTSTR pszPath);

// **********************************************************************************
// 
// File version related declarations
//
// **********************************************************************************


// ----------------------------------------------------------------------------------
// 
// define a type to hold file version data
//
// ----------------------------------------------------------------------------------
typedef struct _FILE_VERSION
{
	WORD Major;
	WORD Minor;
	WORD Build;
	WORD Ext;
} FILE_VERSION, *LPFILE_VERSION;


// ----------------------------------------------------------------------------------
//
// public function to retrieve file version
//
// ----------------------------------------------------------------------------------
BOOL GetFileVersion(LPCTSTR lpsFile, LPFILE_VERSION lpstVersion);




// ----------------------------------------------------------------------------------
//
// publif function to retrieve the creation time of a file in ISO 8601 format
//	without zone info
//
//	if buffer too small, call GetLastError();
//
// ----------------------------------------------------------------------------------
BOOL GetFileTimeStamp(
					  LPCTSTR lpsFile,		// file path
					  LPTSTR lpsTimeStamp,	// buffer to receive timestamp
					  int iBufSize			// buffer size in characters
					  );


// ----------------------------------------------------------------------------------
//
// public functions to compare file versions
//	
// return:
//		-1: if file ver of 1st parameter < file ver of 2nd parameter
//		 0: if file ver of 1st parameter = file ver of 2nd parameter
//		+1: if file ver of 1st parameter > file ver of 2nd parameter
//
// ----------------------------------------------------------------------------------
HRESULT CompareFileVersion(LPCTSTR lpsFile1, LPCTSTR lpsFile2, int *pCompareResult);
HRESULT CompareFileVersion(LPCTSTR lpsFile, FILE_VERSION stVersion, int *pCompareResult);
int CompareFileVersion(const FILE_VERSION stVersion1, const FILE_VERSION stVersion2);


// ----------------------------------------------------------------------------------
//
// public function to convert a string type functoin to FILE_VERSION type
//
// ----------------------------------------------------------------------------------
BOOL ConvertStringVerToFileVer(LPCSTR lpsVer, LPFILE_VERSION lpstVer);


// ----------------------------------------------------------------------------------
//
// publif function to convert a FILE_VERSION to a string
//
// ----------------------------------------------------------------------------------
BOOL ConvertFileVerToStringVer(
	FILE_VERSION stVer,				// version to convert
	char chDel,						// delimiter to use
	LPSTR lpsBuffer,				// buffer of string
	int ccBufSize					// size of buffer
);




// **********************************************************************************
//
// detection related, in addition to file version group
//
// **********************************************************************************

// ----------------------------------------------------------------------------------
//
// public function to check if a file exists
//
// ----------------------------------------------------------------------------------
BOOL FileExists(
	LPCTSTR lpsFile		// file with path to check
);




// ----------------------------------------------------------------------------------
//
// public function to expand the file path
//
//	Assumption: lpszFilePath points to allocated buffer of MAX_PATH.
//	if the expanded path is longer than MAX_PATH, error returned.
//
// ----------------------------------------------------------------------------------
HRESULT ExpandFilePath(
	LPCTSTR lpszFilePath,		// original string
	LPTSTR lpszDestination,		// buffer for expanded string
	UINT cChars					// number of chars that buffer can take
);



// ----------------------------------------------------------------------------------
//
// public function to find the free disk space in KB
//
// ----------------------------------------------------------------------------------
HRESULT GetFreeDiskSpace(
	TCHAR tcDriveLetter,	// drive letter
	int *piKBytes			// out result in KB if successful, 0 if fail
);

HRESULT GetFreeDiskSpace(
    LPCTSTR pszUNC,         // UNC Path
    int *piKBytes           // out result in KB if successful, 0 if fail
);



//----------------------------------------------------------------------
//
// function to validate the folder to make sure
// user has required priviledge
//
// folder will be verified exist. then required priviledge will be checked.
//
// ASSUMPTION: lpszFolder not exceeding MAX_PATH long!!!
//
//----------------------------------------------------------------------
DWORD ValidateFolder(LPTSTR lpszFolder, BOOL fCheckForWrite);


//----------------------------------------------------------------------
//
// function to get a QueryServer from the Ident File for a Given ClientName
// This also looks in the registry for the IsBeta regkey indicating Beta
// functionlality
//
//----------------------------------------------------------------------
HRESULT GetClientQueryServer(LPCTSTR pszClientName, // Client Name to get QueryServer for
                             LPTSTR pszQueryServer, // Buffer for Query Server Return
                             UINT cChars);          // Length of Buffer in Chars

//----------------------------------------------------------------------
//
// function to walk a directory and extract all cabinet files
//
//----------------------------------------------------------------------
HRESULT DecompressFolderCabs(LPCTSTR pszDecompressPath);

//----------------------------------------------------------------------
//
// wrapper function for AdvPack ExtractFiles API (forces conversion to ANSI);
//
//----------------------------------------------------------------------
BOOL IUExtractFiles(LPCTSTR pszCabFile, LPCTSTR pszDecompressFolder, LPCTSTR pszFileNames = NULL);

//Replace the file extension with a new extension
BOOL ReplaceFileExtension( LPCTSTR pszPath, LPCTSTR pszNewExt, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);
// ReplaceFileInPath
BOOL ReplaceFileInPath( LPCTSTR pszPath, LPCTSTR pszNewFile, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);

//Function to verify that the specified file is a binary
//and that it is compatible with the OS architecture
HRESULT IsBinaryCompatible(LPCTSTR lpszFile);


// file exists routine
inline BOOL fFileExists(LPCTSTR lpszFileName, BOOL *pfIsDir = NULL)
{
	DWORD dwAttribute = GetFileAttributes(lpszFileName); //GetFileAttributes do not like "\" at the end of direcotry
	if (INVALID_FILE_ATTRIBUTES != dwAttribute)
	{
		if (NULL != pfIsDir)
		{
			*pfIsDir = (FILE_ATTRIBUTE_DIRECTORY & dwAttribute);
		}
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


//Get the path to the WindowsUpdate Directory (without the backslash at the end)
BOOL GetWUDirectory(LPTSTR lpszDirPath, DWORD chCount, BOOL fGetV4Path = FALSE);


/*****************************************************************************
//Function to set ACL's on Windows Update directories, optionally creates the 
//directory if it doesnt already exists
//This function will:
// * Take ownership of the directory and it's children
// * Set all the children to inherit ACL's from parent
// * Set the specified directory to NOT inherit properties from it's parent
// * Set the required ACL's on the specified directory
// * Replace the ACL's on the children (i.e. propogate own ACL's and remove 
//   those ACL's which were explicitly set 
//
//	Input: 
//		lpszDirectory: Path to the directory to ACL, If it is NULL we use the
                       path to the WindowsUpdate directory
        fCreateAlways: Flag to indicate creation of new directory if it doesnt
                       already exist
******************************************************************************/
HRESULT CreateDirectoryAndSetACLs(LPCTSTR lpszDirectory, BOOL fCreateAlways);



// ----------------------------------------------------------------------------------
//
// File CRC API and Structure Definitions
// Note: This logic is taken from the Windows Update V3 Implemention of File CRC's.
// We use the CryptCATAdminCalcHashFromFileHandle API to calculate a CRC of the file
// and compare it to the passed in CRC_HASH.
//
// ----------------------------------------------------------------------------------

// size of the CRC hash in bytes
const int CRC_HASH_SIZE = 20;
const int CRC_HASH_STRING_LENGTH = CRC_HASH_SIZE * 2 + 1; // Double the CRC HASH SIZE (2 characters for each byte), + 1 for the NULL

// ----------------------------------------------------------------------------------
// 
// VerifyFileCRC : This function takes a File Path, calculates the hash on this file
// and compares it to the passed in Hash (pCRC).
// Returns:
// S_OK: CRC's Match
// ERROR_CRC (HRESULT_FROM_WIN32(ERROR_CRC): if the CRC's do not match
// Otherwise an HRESULT Error Code
//
// ----------------------------------------------------------------------------------
HRESULT VerifyFileCRC(LPCTSTR pszFileToVerify, LPCTSTR pszHash);

// ----------------------------------------------------------------------------------
// 
// CalculateFileCRC : This function takes a File Path, calculates a CRC from the file
// and returns it in passed in CRC_HASH pointer.
//
// ----------------------------------------------------------------------------------
HRESULT CalculateFileCRC(LPCTSTR pszFileToHash, LPTSTR pszHash, int cchBuf);

#endif	//__FILEUTIL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\install.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   install.h
//
//  Description:
//
//      Functions called to install downloaded software and drivers
//
//=======================================================================

#define ITEM_STATUS_SUCCESS						0x00000000	// The package was installed successfully.
#define ITEM_STATUS_INSTALLED_ERROR				0x00000001	// The package was Installed however there were some minor problems that did not prevent installation.
#define ITEM_STATUS_FAILED						0x00000002	// The packages was not installed.
#define ITEM_STATUS_SUCCESS_REBOOT_REQUIRED		0x00000004	// The package was installed and requires a reboot.
#define ITEM_STATUS_DOWNLOAD_COMPLETE			0x00000008  // The package was downloaded but not installed
#define ITEM_STATUS_UNINSTALL_STARTED			0x00000010	// uninstall was started 		

// 

#define COMMANDTYPE_INF                         1
#define COMMANDTYPE_ADVANCEDINF                 2
#define COMMANDTYPE_EXE                         3
#define COMMANDTYPE_MSI                         4
#define COMMANDTYPE_CUSTOM                      5

typedef struct INSTALLCOMMANDINFO
{
    int iCommandType;                           // INF, ADVANCED_INF, EXE, CUSTOM
    TCHAR szCommandLine[MAX_PATH];              // Command to Run (EXE name or INF name)
    TCHAR szCommandParameters[MAX_PATH];        // Parameters for Command (switches, etc..)
    TCHAR szInfSection[256];                    // INF Install Section if Override is needed
} INSTALLCOMMANDINFO, *PINSTALLCOMMANDINFO;


/*** InstallPrinterDriver - 
 *
 */
HRESULT InstallPrinterDriver(
	IN	LPCTSTR pszDriverName,
	IN	LPCTSTR pszLocalDir,					//Local directory where installation files are.
	IN	LPCTSTR pszArchitecture,
	OUT	DWORD* pdwStatus
	);

//This function handles installation of a Device driver package.
HRESULT InstallDriver(
	IN	LPCTSTR pszLocalDir,					// Local directory where installation files are.
	IN	LPCTSTR pszDisplayName,				// Description of package, Device Manager displays this in its install dialog.
	IN	LPCTSTR pszHardwareID,				// ID from XML matched to client hardware via GetManifest()
	OUT	DWORD* pdwStatus
	);


//This function handles installation of an Active Setup type package (INF or EXE)
HRESULT InstallSoftwareItem(
    IN  LPTSTR pszInstallSourcePath,
    IN  BOOL    fRebootRequired,
    IN  LONG    lNumberOfCommands,
    IN  PINSTALLCOMMANDINFO pCommandInfoArray,
    OUT  DWORD*  pdwStatus
    );

// this function handles installation of a Custom Installer type package
HRESULT InstallCustomInstallerItem();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\iu.h ===
// base IU header

#ifndef __IU_H_
#define __IU_H_

#include <setupapi.h>
#include <advpub.h>
#include <windows.h>
#include <wtypes.h>
#include <urllogging.h>
//
// cdm.h is checked in as //depot/Lab04_N/enduser/published/inc/cdm.w and
// published to $(BASEDIR)\public\internal\enduser\inc
//
#include <cdm.h>

/////////////////////////////////////////////////////////////////////////////
// Engine typedefs
// 
// used to delegate calls to engine (IUEngine.dll) from stub (IUCtl.dll)
// and used to support other WU clients (AU/DU)
/////////////////////////////////////////////////////////////////////////////

//
// Declare a type-safe handle to use with iuengine exports
//
DECLARE_HANDLE            (HIUENGINE);

typedef HRESULT (WINAPI * PFN_GetSystemSpec)(HIUENGINE hIUEngine,
											 BSTR		bstrXmlClasses,
                                             DWORD      dwFlags,
											 BSTR*		pbstrXmlDetectionResult);

typedef HRESULT (WINAPI * PFN_GetManifest)	(HIUENGINE hIUEngine,
											 BSTR			bstrXmlClientInfo,
											 BSTR			bstrXmlSystemSpec,
											 BSTR			bstrXmlQuery,
											 DWORD			dwFlags,
											 BSTR*			pbstrXmlCatalog);

typedef HRESULT (WINAPI * PFN_Detect)		(HIUENGINE hIUEngine,
											 BSTR		bstrXmlCatalog,
                                             DWORD      dwFlags,
											 BSTR*		pbstrXmlItems);

typedef HRESULT (WINAPI * PFN_Download)		(HIUENGINE hIUEngine,
											 BSTR		bstrXmlClientInfo,
											 BSTR		bstrXmlCatalog, 
											 BSTR		bstrDestinationFolder,
											 LONG		lMode,
											 IUnknown*	punkProgressListener,
											 HWND		hWnd,
											 BSTR*		pbstrXmlItems);

typedef HRESULT (WINAPI * PFN_DownloadAsync)(HIUENGINE hIUEngine,
											 BSTR		bstrXmlClientInfo,
											 BSTR		bstrXmlCatalog, 
											 BSTR		bstrDestinationFolder,
											 LONG		lMode,
											 IUnknown*	punkProgressListener, 
											 HWND		hWnd,
											 BSTR		bstrUuidOperation,
											 BSTR*		pbstrUuidOperation);

typedef HRESULT (WINAPI * PFN_Install)		(HIUENGINE hIUEngine,
											 BSTR       bstrXmlClientInfo,
                                             BSTR		bstrXmlCatalog, 
											 BSTR		bstrXmlDownloadedItems,
											 LONG		lMode,
											 IUnknown*	punkProgressListener, 
											 HWND		hWnd,
											 BSTR*		pbstrXmlItems);

typedef HRESULT (WINAPI * PFN_InstallAsync)	(HIUENGINE hIUEngine,
											 BSTR       bstrXmlClientInfo,
                                             BSTR		bstrXmlCatalog,
											 BSTR		bstrXmlDownloadedItems,
											 LONG		lMode,
											 IUnknown*	punkProgressListener, 
											 HWND		hWnd,
											 BSTR		bstrUuidOperation,
											 BSTR*		pbstrUuidOperation);

typedef HRESULT (WINAPI * PFN_SetOperationMode)(HIUENGINE hIUEngine,
												BSTR		bstrUuidOperation,
												LONG		lMode);

typedef HRESULT (WINAPI * PFN_GetOperationMode)(HIUENGINE hIUEngine,
												BSTR		bstrUuidOperation,
												LONG*		plMode);

typedef HRESULT (WINAPI * PFN_GetHistory)(HIUENGINE hIUEngine,
										  BSTR		bstrDateTimeFrom,
										  BSTR		bstrDateTimeTo,
										  BSTR		bstrClient,
										  BSTR		bstrPath,
										  BSTR*		pbstrLog);

typedef HRESULT (WINAPI * PFN_BrowseForFolder)(	HIUENGINE hIUEngine,
												BSTR bstrStartFolder, 
												LONG flag, 
												BSTR* pbstrFolder);

typedef HRESULT (WINAPI * PFN_RebootMachine)(HIUENGINE hIUEngine);

typedef void (WINAPI * PFN_ShutdownThreads) (void);

typedef void (WINAPI * PFN_ShutdownGlobalThreads) (void);

typedef HRESULT (WINAPI * PFN_CompleteSelfUpdateProcess)();

typedef HIUENGINE (WINAPI * PFN_CreateEngUpdateInstance)();

typedef void (WINAPI * PFN_DeleteEngUpdateInstance)(HIUENGINE hIUEngine);

typedef HRESULT (WINAPI * PFN_PingIUEngineUpdateStatus)(
											PHANDLE phQuitEvents,			// ptr to handles for cancelling the operation
											UINT nQuitEventCount,			// number of handles
											LPCTSTR ptszLiveServerUrl,
											LPCTSTR ptszCorpServerUrl,
											DWORD dwError,					// error code
											LPCTSTR ptszClientName);			// client name string

/////////////////////////////////////////////////////////////////////////////
//
// CDM typedefs
//
// used to delegate calls to engine (IUEngine.dll) from stub ([IU]cdm.dll)
/////////////////////////////////////////////////////////////////////////////

// DetFilesDownloaded
typedef void (WINAPI * PFN_InternalDetFilesDownloaded)(
    IN  HANDLE hConnection 
    );

// DownloadGetUpdatedFiles
typedef BOOL (WINAPI * PFN_InternalDownloadGetUpdatedFiles)(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
	);

// DownloadUpdatedFiles
typedef BOOL (WINAPI * PFN_InternalDownloadUpdatedFiles)(
    IN HANDLE hConnection,
    IN HWND hwnd,
    IN PDOWNLOADINFO pDownloadInfo,
    OUT LPWSTR lpDownloadPath,
    IN UINT uSize,
    OUT PUINT puRequiredSize
    );

// FindMatchingDriver
typedef BOOL (WINAPI * PFN_InternalFindMatchingDriver)(
    IN  HANDLE hConnection,
	IN  PDOWNLOADINFO pDownloadInfo,
	OUT PWUDRIVERINFO pWuDriverInfo
    );

// LogDriverNotFound
typedef void (WINAPI * PFN_InternalLogDriverNotFound)(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
    );

// QueryDetectionFiles
typedef int (WINAPI * PFN_InternalQueryDetectionFiles)(
    IN  HANDLE hConnection, 
	IN	void* pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
    );

// InternalSetGlobalOfflineFlag
typedef void (WINAPI * PFN_InternalSetGlobalOfflineFlag)(
    IN  BOOL fOfflineMode 
    );

/////////////////////////////////////////////////////////////////////////////
//
// Misc. typedefs
//
/////////////////////////////////////////////////////////////////////////////

// DeleteExpiredDownloadFolders
typedef void (WINAPI * PFN_AsyncExtraWorkUponEngineLoad)();


/////////////////////////////////////////////////////////////////////////////
// custom message ID defintions
/////////////////////////////////////////////////////////////////////////////
#define UM_EVENT_ITEMSTART				WM_USER + 1001
#define UM_EVENT_PROGRESS				WM_USER + 1002
#define UM_EVENT_COMPLETE				WM_USER + 1003
#define UM_EVENT_SELFUPDATE_COMPLETE	WM_USER + 1004

/////////////////////////////////////////////////////////////////////////////
// event data structure definition
/////////////////////////////////////////////////////////////////////////////
typedef struct _EventData
{
	BSTR			bstrUuidOperation;
	VARIANT_BOOL	fItemCompleted;
	BSTR			bstrProgress;
	LONG			lCommandRequest;
	BSTR			bstrXmlData;
	HANDLE          hevDoneWithMessage;
} EventData, *pEventData;

BOOL WUPostEventAndBlock(HWND hwnd, UINT Msg, EventData *pevtData);


#endif //__IU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\logging.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   IULogger.h: interface for the CIULogger class.
//
//  Description:
//
//      CIULogger is a class that output the program logs to 
//		a text file, in order to help debugging the program.
//
//		Programs wish to have this logging function should NOT use
//		class directly. They should only use the macro defined
//		at the end of this file.
//
//=======================================================================



#ifndef _IULOGGER_H_INCLUDED_

#include <wtypes.h>
#include <FreeLog.h>

extern const LPCTSTR pszHeapAllocFailed;

#if defined(DBG)	// full logging for checked builds

//
// Common format strings
//

class CIULogger  
{
public:
	CIULogger(char* szBlockName);
	~CIULogger();


	//
	// log with no flag, so can not be removed by excluding directives
	//
	void Log(LPCTSTR szLogFormat, ...);

	//
	// log error, can not be removed by excluding directives
	// Key word "Error: " is inserted before the log msg
	//
	void LogError(LPCTSTR szLogFormat, ...);

	//
	// similar to LogError, but try to log the system msg based
	// on the error code. If the sysmsg not avail, log 
	//	"Unknown error with error code 0x%08x"
	//
	void LogErrorMsg(DWORD dwErrCode);

	//
	// similar to LogErrorMsg but prepends with "Info" rather than "Error"
	//
	void LogInfoMsg(DWORD dwErrCode);

	//
	// log with type INTERNET, this function will do nothing
	// if the Internet exclusion directive is detected from reg
	//
	void LogInternet(LPCTSTR szLogFormat, ...);

	//
	// log with type XML, this function will do nothing
	// if the XML exclusion directive is detected from reg
	//
	void LogXML(LPCTSTR szLogFormat, ...);

	//
	// log BSTR containing valid XML. This gets around length limitations
	// of LogOutput and attempts to break lines following ">". This
	// output is sent for both fre and chk builds unless excluded from reg.
	//
	void LogXmlBSTR(BSTR bstrXML);

	//
	// log with type SOFTWARE, this function will do nothing
	// if the SOFTWARE exclusion directive is detected from reg
	//
	void LogSoftware(LPCTSTR szLogFormat, ...);

	//
	// log with type DRIVER, this function will do nothing
	// if the DRIVER exclusion directive is detected from reg
	//
	void LogDriver(LPCTSTR szLogFormat, ...);

	//
	// log with type CHECKTRUST, this function will do nothing
	// if the CHECKTRUST exclusion directive is detected from reg
	//
	void LogTrust(LPCTSTR szLogFormat, ...);

	//
	// log with type DOWNLOAD, this function will do nothing
	// if the DOWNLOAD exclusion directive is detected from reg
	//
	void LogDownload(LPCTSTR szLogFormat, ...);


	int m_LineNum;
private:

	//
	// Helper for LogErrorMsg and LogInfoMsg (which supply message to prepend)
	//
	void _LogFormattedMsg(DWORD dwErrCode, LPCTSTR pszErrorInfo);

	//
	// Overwrite <CR> and <LF> with space
	//
	void _NukeCrLf(LPTSTR pszBuffer);

	//
	// actual base logging function, returns
	// if it actually logged, or just returned
	// because directives say don't make this kind of log
	//
	void _Log(DWORD LogType, LPCTSTR pszLogFormat, va_list va);

	//
	// function to write the log to log file
	//
	void _LogOut(LPTSTR pszLog);

	//
	// functions go guard writing to file
	//
	BOOL AcquireMutex();
	void ReleaseMutex();

	//
	// structure used to remember indent steps per thread
	//
	struct _THREAD_INDENT 
	{
		DWORD	dwThreadId;
		int		iIndent;
	};

	//
	// static integer to remember the log indent steps
	//
	static _THREAD_INDENT* m_psIndent;

	//
	// size of array pointed by m_psIndent
	//
	static int m_Size;

	//
	// static handle for log file
	//
	static HANDLE m_shFile;

	//
	// bitmap for logging type
	//
	static DWORD m_sdwLogMask;
	
	//
	// indent per step
	//	
	//	1~8 - number of spaces
	//	other - one tab
	//
	static int m_siIndentStep;

	//
	// function to retrieve the indent of current thread
	//
	inline int GetIndent(void);

	//
	// function to change indention of current thread
	//
	void SetIndent(int IndentDelta);


	//
	// index of indent array
	//
	int m_Index;

	//
	// controlling vars
	//
	static bool m_fLogUsable;
	static bool m_fLogFile;
	static bool m_fLogDebugMsg;
	static HANDLE m_hMutex;
	static int m_cFailedWaits;

	//
	// current block name
	//
	char m_szBlockName[MAX_PATH];
	
	// 
	// if this log object is for whole process. If yes,
	// no indention will be handled.
	//
	bool m_fProcessLog;

	//
	// var to remember time elapsed
	//
	DWORD m_dwTickBegin;

	//
	// disable the default constructor
	//
	CIULogger() {};

	//
	// timestamp helper
	//
	void GetLogHeader(LPTSTR pszBuffer, DWORD cchBufferLen);

	//
	// read registry value helper
	//
	void ReadRegistrySettings(void);

	//
	// remember thread id of itself
	//
	DWORD m_dwThreadId;

	//
	// flush every time?
	// added by charlma 11/27/01
	// if this flag is set, then flush everytime. otherwise, don't flush in order
	// to improve logging performance.
	//
	static BOOL m_fFlushEveryTime;
};



//=======================================================================
//
//	Define the macros that should be used in the programs to utilize
//	the CIULogger class.
//
//	Note: each of the following macro will practically doing nothing
//	if the registry of supporting this logging feature does not exist
//	or values not appropriately set.
//
//=======================================================================


//
// LOG_Process, is the one you can use in global namespace. 
// The purpose of this macro is to pump up ref count of log file use so
// during the whole process this log file will keep open, therefore
// the actual logging to file feature will have minimum performance
// impact on your code.
//
// This macro is mainly designed for the scenario that you can't use LOG_Block
// inside main, such as DLL_ATTACH of DllMain() - without this, each 
// function call to a DLL will cause the log file open/close.
//
#define LOG_Process				CIULogger LogBlock(NULL);

//
// LOG_Block, is the one you should use at the beginning of each
// function or block. It declares an instance of CIULogger, log the
// the entering status, and when control goes out of the scope, the
// exit/end statement is automatically logged
//
#define LOG_Block(name)			CIULogger LogBlock(name);

//
// the following macro will always send log to log file
//
#define LOG_Out					LogBlock.Log

//
// the following macro will always send log to log file, even for Free builds
//	This should be used very sparingly to avoid bloating the DLLs
//
#define LOG_OutFree				LogBlock.Log

//
// the following macro will always send log to log file
// this should be used to log ANY error case
//
#define LOG_Error				LogBlock.m_LineNum = __LINE__; LogBlock.LogError

//
// the follwoing macro will always send log to log file
// prepended with "Error Line..."
// the log is constructed based on passed in error code
// if system msg is not available for this error code,
// a generic error log "Unknown Error 0x%08x" is written.
//
#define LOG_ErrorMsg			LogBlock.m_LineNum = __LINE__; LogBlock.LogErrorMsg

//
// the follwoing macro will always send log to log file
// prepended with "Info Line..."
// the log is constructed based on passed in error code
// if system msg is not available for this error code,
// a generic error log "Unknown Info 0x%08x" is written.
//
#define LOG_InfoMsg				LogBlock.m_LineNum = __LINE__; LogBlock.LogInfoMsg

//
// this is used to log anything related to Internet, such as 
// WinInet info.
//
#define LOG_Internet			LogBlock.LogInternet

//
// this should be used to log anything directly related to XML 
// operation details
//
#define LOG_XML					LogBlock.LogXML

//
// this should be used to log BSTRs containing valid XML 
//
#define LOG_XmlBSTR				LogBlock.LogXmlBSTR

//
// this should be used to log anything related to device drivers
//
#define LOG_Driver				LogBlock.LogDriver

//
// this should be used to log anything related to software, e.g.,
// detection/installation
//
#define LOG_Software			LogBlock.LogSoftware


//
// this should be used to log anything related to check trust
//
#define LOG_Trust				LogBlock.LogTrust


//
// this should be used to log anything related to download processing
//
#define LOG_Download            LogBlock.LogDownload

//
//
//
#else
//
// Remove all debug style logging for release builds
// using the compiler __noop intrinsic
//
#define LOG_Process				__noop
#define LOG_Block				__noop
#define LOG_Error				__noop
#define LOG_ErrorMsg			__noop
#define LOG_InfoMsg				__noop
#define LOG_OutFree				__noop
#define LOG_XmlBSTR				__noop

#define LOG_Out					__noop
#define LOG_Internet			__noop
#define LOG_XML					__noop
#define LOG_Driver				__noop
#define LOG_Software			__noop
#define LOG_Trust				__noop
#define LOG_Download			__noop
#endif // defined(DBG)

//
// explanation of registry settings for log feature
//
// The registry settings control how the logging feature works.
// 
// All log related settings are under key 
//	\\HKLM\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate\IUControlLogging
//
// All values are DWORD except "Logging File"
//
//	Value "Logging File" - specify the absolute file path, e.g., c:\iuctl.log
//			the actual log file name in this case is "c:\iuctl_xxxx.log", 
//			where xxxx is a decimal number represents process id.
//
//	Value "Logging DebugMsg" - indicate if log should be put onto debug window.
//			true if vlaue is 1, false for other values. this output and log file
//			output control by these 2 values independently.
//
//	Value "LogIndentStep" - indicates how many space chars to use for each
//			indent. If 0 or negative value, then tab char is used.
//
//	Value "LogExcludeBlock" - do not output block enter/exit if it's 1
//
//	Value "LogExcludeXML" - do not output logs you logged with LOG_XML if it's 1
//
//	Value "LogExcludeXmlBSTR" - do not output logs you logged with LOG_XmlBSTR if 1
//
//	Value "LogExcludeInternet" - do not output logs you logged with LOG_Internet if 1
//
//	Value "LogExcludeDriver" - do not output logs you logged with LOG_Driver if 1
//
//	Value "LogExcludeSoftware - do not output logs you logged with LOG_Software if 1
//
//	Value "LogExcludeTrust" - do not output logs you logged with LOG_Trust if 1
//

#define _IULOGGER_H_INCLUDED_
#endif // #ifndef _IULOGGER_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\mistsafe.h ===
//=======================================================================
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:    MISTSafe.h
//
//  Creator: PeterWi
//
//  Purpose: Definitions related to safe functions.
//
//=======================================================================

#pragma once
#define STRSAFE_NO_DEPRECATE

#include <strsafe.h>

// Flag you should add to your String* functions to safe fill behind
// the complete buffer in chk builds to help locate buffer problems.
// e.g. StringCchCopyEx(szDest, cchDest, szSrc, &pszDestEnd, &cchRemaining, MISTSAFE_STRING_FLAGS);

#ifdef DBG
#define MISTSAFE_STRING_FLAGS   STRSAFE_FILL_BEHIND_NULL
#else
#define MISTSAFE_STRING_FLAGS   STRSAFE_IGNORE_NULLS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\memutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   MemUtil.h
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      IU memory utility library
//
//=======================================================================

#ifndef __MEM_UTIL_HEADER__


#include <ole2.h>

//
// declare a class that handles the heap memory smartly, free itself.
// you should not use this class directly. Use the macros defined
// below this class instead.
//
class CSmartHeapMem
{
public:

	//
	// constructor/destructor
	//
	CSmartHeapMem();
	~CSmartHeapMem();

	LPVOID Alloc(
			size_t nBytes, 
			DWORD dwFlags = HEAP_ZERO_MEMORY
	);


	LPVOID ReAlloc(
			LPVOID lpMem, 
			size_t nBytes, 
			DWORD dwFlags = HEAP_ZERO_MEMORY
	);
	
	size_t Size(
			LPVOID lpMem
	);

	void FreeAllocatedMem(
			LPVOID lpMem
	);

private:
	
	HANDLE	m_Heap;
	LPVOID* m_lppMems;
	size_t	m_ArraySize;
	int		GetUnusedArraySlot();
	inline int FindIndex(LPVOID pMem);
};



// *******************************************************************************
//
//		MACROs to utlize class CSmartHeapMem to provide you a "smart pointer"
//		type of memory management based on Heap memory.
//
//		Restriction: 
//			HEAP_GENERATE_EXCEPTIONS and HEAP_NO_SERIALIZE flags are ignored
//
// *******************************************************************************

//
// similar to ATL USES_CONVERSION, this macro declares
// that within this block you want to use CSmartHeapMem feature
//
#define USES_MY_MEMORY			CSmartHeapMem mem;

//
// allocate a pc of memory, e.g.:
//		LPTSTR t = (LPTSTR) MemAlloc(30*sizeof(TCHAR));
//
#define MemAlloc				mem.Alloc

//
// re-allocate a pc of memory, e.g.:
//		t = (LPTSTR) MemReAlloc(t, MemSize(t) * 2, HEAP_REALLOC_IN_PLACE_ONLY);
//
#define MemReAlloc				mem.ReAlloc

//
// macro to return the memory size allocated:
//		size_t nBytes = MemSize(t);
//
#define MemSize					mem.Size

//
// macro to free a pc of memory allocated by MemAlloc or MemReAlloc, e.g.:
//		MemFree(t);
// You only need to do this when you want to re-use this pointer to 
// call MemAlloc() repeatedly, such as, in a loop. In normal cases, 
// memory allocated by these two macros will be freed automatically
// when control goes out of the current scope.
//
#define MemFree					mem.FreeAllocatedMem


#define SafeMemFree(p) if (NULL != p) { MemFree(p); p = NULL; }



// *******************************************************************************
//
//	Duplicate USES_CONVERSION, but remove dependency on 
//	CRT memory function_alloca()
//
// *******************************************************************************



#define USES_IU_CONVERSION			int _convert = 0; \
									_convert; UINT _acp = CP_ACP; _acp; \
									USES_MY_MEMORY; \
									LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa

//
// NTRAID#NTBUG9-260079-2001/03/08-waltw PREFIX: Dereferencing NULL lpw.
// NTRAID#NTBUG9-260080-2001/03/08-waltw PREFIX: Dereferencing NULL lpw.
//
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	//
	if (lpw)
	{
		lpw[0] = '\0';
		MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	}
	return lpw;
}

//
// NTRAID#NTBUG9-260083-2001/03/08-waltw PREFIX: Dereferencing NULL lpa.
//
inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	//
	if (lpa)
	{
		lpa[0] = '\0';
		WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	}
	return lpa;
}

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	return AtlA2WHelper(lpw, lpa, nChars, CP_ACP);
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}


#ifdef _CONVERSION_USES_THREAD_LOCALE
	#ifdef ATLA2WHELPER
		#undef ATLA2WHELPER
		#undef ATLW2AHELPER
	#endif
	#define ATLA2WHELPER AtlA2WHelper
	#define ATLW2AHELPER AtlW2AHelper
#else
	#ifndef ATLA2WHELPER
		#define ATLA2WHELPER AtlA2WHelper
		#define ATLW2AHELPER AtlW2AHelper
	#endif
#endif


#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			AtlA2WHelper((LPWSTR)MemAlloc(_convert*2), _lpa, _convert, CP_ACP)))

#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			AtlW2AHelper((LPSTR)MemAlloc(_convert), _lpw, _convert, CP_ACP)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))



#ifdef OLE2ANSI
	inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
	inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
	#define W2OLE W2A
	#define OLE2W A2W
	inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
	inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
	#define W2COLE W2CA
	#define OLE2CW A2CW
#else
	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA
#endif


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif
#define OLE2T    W2T
#define OLE2CT   W2CT
#define T2OLE    T2W
#define T2COLE   T2CW


inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
	USES_IU_CONVERSION;
	BSTR str = NULL;
	int nConvertedLen = MultiByteToWideChar(_acp, 0, lp,
		nLen, NULL, NULL)-1;
	str = ::SysAllocStringLen(NULL, nConvertedLen);
	if (str != NULL)
	{
		MultiByteToWideChar(_acp, 0, lp, -1,
			str, nConvertedLen);
	}
	return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {USES_IU_CONVERSION; return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return ::SysAllocString(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {USES_IU_CONVERSION; return ::SysAllocString(W2COLE(lp));}
#else
	inline BSTR T2BSTR(LPCTSTR lp) {USES_IU_CONVERSION; return A2WBSTR(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {USES_IU_CONVERSION; return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#endif



// *******************************************************************************
//
//	Other memory related functions
//
// *******************************************************************************


//
// implemenation of CRT memcpy() function
//
LPVOID MyMemCpy(LPVOID dest, const LPVOID src, size_t nBytes);

//
// allocate heap mem and copy
//
LPVOID HeapAllocCopy(LPVOID src, size_t nBytes);



#define __MEM_UTIL_HEADER__
#endif //__MEM_UTIL_HEADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\regutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RegUtil.h
//	Author:	Charles Ma, 10/20/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      IU registry utility library
//
//=======================================================================


#ifndef __REG_UTIL_H_ENCLUDED__



// ----------------------------------------------------------------------
//
// define the enum used for version status checking
//
// ----------------------------------------------------------------------
enum _VER_STATUS {
    DETX_LOWER              = -2,
	DETX_LOWER_OR_EQUAL	    = -1,
	DETX_SAME	            =  0,
	DETX_HIGHER_OR_EQUAL    = +1,
	DETX_HIGHER             = +2
};



// ----------------------------------------------------------------------
//
// public function to tell is a reg key exists
//
// ----------------------------------------------------------------------
BOOL RegKeyExists(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName		// optional value name
);


// ----------------------------------------------------------------------
//
// public function to tell is a reg value in reg matches given value
//
// ----------------------------------------------------------------------
BOOL RegKeyValueMatch(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsValue		// value value
);


// ----------------------------------------------------------------------
//
// public function to tell if a reg key has a string type value
// that contains given string
//
// ----------------------------------------------------------------------
BOOL RegKeySubstring(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsSubString	// substring to see if contained in value
);


// ----------------------------------------------------------------------
//
// public function to tell if a reg key has a version to compare
// and the compare results
//
// ----------------------------------------------------------------------
BOOL RegKeyVersion(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsVersion,		// version in string to compare
	_VER_STATUS CompareVerb	// how to compair
);



// ----------------------------------------------------------------------------------
//
// public function to find out the file path based on reg
//	assumption: 
//		lpsFilePath points to a buffer at least MAX_PATH long.
//
// ----------------------------------------------------------------------------------
BOOL GetFilePathFromReg(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR	lpsValName,		// optional value name
	LPCTSTR	lpsRelativePath,// optional additonal relative path to add to path in reg
	LPCTSTR	lpsFileName,	// optional file name to append to path
	LPTSTR	lpsFilePath
);


#define __REG_UTIL_H_ENCLUDED__
#endif //__REG_UTIL_H_ENCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\safefile.h ===
//
// SafeFile.h
//
//		Functions to help prevent opening unsafe files.
//
// History:
//
//		2002-03-18  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#pragma once


//
// You can override these allocators in your stdafx.h if necessary
//
#ifndef SafeFileMalloc
#define SafeFileMalloc malloc
#endif
#ifndef SafeFileFree
#define SafeFileFree(p) ((p) ? free(p) : NULL) // allow null to avoid confusion w/ "safe" in name
#endif


//
// "Safe file flags", used by various public API's.
//
// Note that they don't overlap, to avoid errors where one function's
// flags are passed to another function by accident.
//

// SafeCreateFile flags
//
#define SCF_ALLOW_NETWORK_DRIVE    0x00000001  // file can be on a network drive
#define SCF_ALLOW_REMOVABLE_DRIVE  0x00000002  // file can be on a removable drive (incl. CD-ROM & others)
#define SCF_ALLOW_ALTERNATE_STREAM 0x00000004  // allow filename to refer to alternate stream such as ":foo:$DATA"

// SafePathCombine flags
//
#define SPC_FILE_MUST_EXIST        0x00000010  // return an error if path or file doesn't exist
#define SPC_ALLOW_ALTERNATE_STREAM 0x00000020  // allow filename to refer to alternate stream such as ":foo:$DATA"

// SafeFileCheckForReparsePoint flags
//
#define SRP_FILE_MUST_EXIST        0x00000100  // return an error if path or file doesn't exist

// SafeDeleteFolderAndContents flags
//
#define SDF_ALLOW_NETWORK_DRIVE    0x00001000  // ok to delete files on a network drive
#define SDF_DELETE_READONLY_FILES  0x00002000  // delete files even if read-only
#define SDF_CONTINUE_IF_ERROR      0x00004000  // keep deleting files even if one fails


//
// Public function declarations. See SafeFile.cpp for detailed descriptions.
//

BOOL WINAPI IsFullPathName
	(
		IN LPCTSTR pszFileName,                    // full or relative path to a file
		OUT OPTIONAL BOOL* pfUNC = NULL,           // TRUE path is UNC (int incl mapped drive)
		OUT OPTIONAL BOOL* pfExtendedSyntax = NULL // TRUE if path is \\?\ syntax
	);

HRESULT WINAPI GetReparsePointType
	(
		IN LPCTSTR pszFileName,           // full path to folder to check
		OUT DWORD* pdwReparsePointType    // set to reparse point type, or 0 if none
	);

HRESULT WINAPI SafeFileCheckForReparsePoint
	(
		IN LPCTSTR pszFileName,           // full path of a file
		IN int     nFirstUntrustedOffset, // char offset of first path component to check
		IN DWORD   dwSafeFlags            // zero or more SRP_* flags
	);

HRESULT WINAPI SafePathCombine
	(
		OUT LPTSTR  pszBuf,               // buffer where combined path will be stored
		IN  int     cchBuf,               // size of output buffer, in TCHARs
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	);

HRESULT WINAPI SafePathCombineAlloc
	(
		OUT LPTSTR* ppszResult,           // ptr to newly alloc'd buffer stored here
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	);

HRESULT WINAPI SafeCreateFile
	(
		OUT HANDLE* phFileResult,       // receives handle to opened file, or INVALID_HANDLE_VALUE
		IN DWORD dwSafeFlags,           // zero or more SCF_* flags
		IN LPCTSTR pszFileName,         // same as CreateFile
		IN DWORD dwDesiredAccess,       // same as CreateFile
		IN DWORD dwShareMode,           // same as CreateFile
		IN LPSECURITY_ATTRIBUTES lpSecurityAttributes, // same as CreateFile
		IN DWORD dwCreationDisposition, // same as CreateFile
		IN DWORD dwFlagsAndAttributes,  // same as CreateFile + (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)
		IN HANDLE hTemplateFile         // same as CreateFile
	);

HRESULT WINAPI SafeRemoveFileAttributes
	(
		IN LPCTSTR pszFileName,    // full path to file whose attributes we will change
		IN DWORD   dwCurAttrib,    // current attributes of the file
		IN DWORD   dwRemoveAttrib  // attribute bits to remove
	);

HRESULT WINAPI SafeDeleteFolderAndContents
	(
		IN LPCTSTR pszFolderToDelete,  // full path of folder to delete
		IN DWORD   dwSafeFlags         // zero or more SDF_* flags
	);


//
// Limited ansi/unicode support
//

#ifdef UNICODE
#define IsFullPathNameW                IsFullPathName
#define GetReparsePointTypeW           GetReparsePointType
#define SafeFileCheckForReparsePointW  SafeFileCheckForReparsePoint
#define SafePathCombineW               SafePathCombine
#define SafePathCombineAllocW          SafePathCombineAlloc
#define SafeCreateFileW                SafeCreateFile
#define SafeRemoveFileAttributesW      SafeRemoveFileAttributes
#define SafeDeleteFolderAndContentsW   SafeDeleteFolderAndContents
#else // !UNICODE
#define IsFullPathNameA                IsFullPathName
#define GetReparsePointTypeA           GetReparsePointType
#define SafeFileCheckForReparsePointA  SafeFileCheckForReparsePoint
#define SafePathCombineA               SafePathCombine
#define SafePathCombineAllocA          SafePathCombineAlloc
#define SafeCreateFileA                SafeCreateFile
#define SafeRemoveFileAttributesA      SafeRemoveFileAttributes
#define SafeDeleteFolderAndContentsA   SafeDeleteFolderAndContents
#endif // !UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\safefunc.h ===
#pragma once

#include <objbase.h>

#define SafeRelease(p)          if (NULL != p) { (p)->Release(); }
#define SafeReleaseNULL(p)      if (NULL != p) { (p)->Release(); (p) = NULL; }
#define SafeFree(p)             if (NULL != p) { free(p); }
#define SafeFreeNULL(p)         if (NULL != p) { free(p); (p) = NULL; }
#define SafeDelete(p)           if (NULL != p) { delete (p); }
#define SafeDeleteNULL(p)       if (NULL != p) { delete (p); (p) = NULL; }
#define SafeLocalFree(p)        if (NULL != p) { LocalFree(p); }
#define SafeLocalFreeNULL(p)    if (NULL != p) { LocalFree(p); (p) = NULL; }

inline void SafeCloseHandle(HANDLE h)
{
    if ( NULL != h )
    {
        CloseHandle(h);
    }
}

inline void SafeCloseHandleNULL(HANDLE & h)
{
    if ( NULL != h )
    {
        CloseHandle(h);
        h = NULL;
    }
}

inline void SafeCloseFileHandle(HANDLE h)
{
    if ( INVALID_HANDLE_VALUE != h )
    {
        CloseHandle(h);
    }
}

inline void SafeCloseFileHandleInvalidate(HANDLE & h)
{
    if ( INVALID_HANDLE_VALUE != h )
    {
        CloseHandle(h);
        h = INVALID_HANDLE_VALUE;
    }
}

inline void SafeFreeBSTR(BSTR bstr)
{
    SysFreeString(bstr);	// SysFreeString takes no action if bstr == NULL
}

inline void SafeFreeBSTRNULL(BSTR &bstr)
{
	SysFreeString(bstr);
	bstr = NULL;
}

inline int WUCompareString(LPCTSTR lpString1, LPCTSTR lpString2)
{
    return CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 0, lpString1, -1, lpString2, -1);
}

inline int WUCompareStringI(LPCTSTR lpString1, LPCTSTR lpString2)
{
    return CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, lpString1, -1, lpString2, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\osdet.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   osdet.h
//
//  Description:
//
//      IU Platform and language detection
//
//=======================================================================

#ifndef __IU_OSDET_INC__
#define __IU_OSDET_INC__

#include <oleauto.h>
#include <wininet.h> // for INTERNET_MAX_URL_LENGTH

extern HINSTANCE g_hinst;

	typedef struct _IU_DRIVEINFO
	{
		//
		// Drive strings are of the form "C:\" so will always be 4 TCHARs (including NULL)
		//
		TCHAR szDriveStr[4];
		INT		iKBytes;
	} IU_DRIVEINFO, * PIU_DRIVEINFO, ** PPIU_DRIVEINFO;

	// NOTE: The callee is responsible for allocating all BSTRs, and the caller
	// is responsible for freeing all BSTRs (both use SysAllocXxx calls).
	typedef struct _IU_PLATFORM_INFO 
	{
		OSVERSIONINFOEX osVersionInfoEx;	// if osVersionInfoEx.dwOSVersionInfoSize == sizeof(OSVERSIONINFO)
											// then only first six (OSVERSIONINFO) members are valid.

		BOOL	fIsAdministrator;			// Applies only to NT platforms (always FALSE on Win9x)
		
		BSTR	bstrOEMManufacturer;

		BSTR	bstrOEMModel;

		BSTR	bstrOEMSupportURL;			// Only if oeminf.ini exists on machine
	} IU_PLATFORM_INFO, *PIU_PLATFORM_INFO;


	typedef struct _OEMINFO
	{
		DWORD  dwMask;
		TCHAR  szWbemOem[65];
		TCHAR  szWbemProduct[65];
		TCHAR  szAcpiOem[65];
		TCHAR  szAcpiProduct[65];
		TCHAR  szSmbOem[65];
		TCHAR  szSmbProduct[65];
		DWORD  dwPnpOemId;
		TCHAR  szIniOem[256];
		TCHAR  szIniOemSupportUrl[INTERNET_MAX_URL_LENGTH];
	} OEMINFO, * POEMINFO;

	#define OEMINFO_WBEM_PRESENT	0x0001
	#define OEMINFO_ACPI_PRESENT	0x0002
	#define OEMINFO_SMB_PRESENT		0x0004
	#define OEMINFO_PNP_PRESENT		0x0008
	#define OEMINFO_INI_PRESENT		0x0010


	HRESULT WINAPI DetectClientIUPlatform(PIU_PLATFORM_INFO pIuPlatformInfo);

	LANGID WINAPI GetSystemLangID(void);

	LANGID WINAPI GetUserLangID(void);

	HRESULT GetOemBstrs(BSTR& bstrManufacturer, BSTR& bstrModel, BSTR& bstrSupportURL);

	HRESULT GetLocalFixedDriveInfo(DWORD* pdwNumDrives, PPIU_DRIVEINFO ppDriveInfo);

	BOOL IsAdministrator(void);

	//
	// tell whether the current logon is member of admins or power users
	//
	#define IU_SECURITY_MASK_ADMINS			0x00000001
	#define IU_SECURITY_MAST_POWERUSERS		0x00000002
	DWORD GetLogonGroupInfo(void);

	int IsWindowsUpdateDisabled(void);

	int IsWindowsUpdateUserAccessDisabled(void);

	int IsAutoUpdateEnabled(void);

	//
	// Return platform and locale strings for use with iuident.txt files.
	//
	LPTSTR GetIdentPlatformString(LPTSTR pszPlatformBuff, DWORD dwcBuffLen);

	LPTSTR GetIdentLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen);

	LPTSTR LookupLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen, BOOL fIsUser);

    BOOL LookupLocaleStringFromLCID(LCID lcid, LPTSTR pszISOCode, DWORD cchISOCode);

#endif	// __IU_OSDET_INC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\redirectutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RedirectUtil.h
//	Author:	Charles Ma, 9/19/2001
//
//	Revision History:
//
//
//
//  Description:
//
//      Helper function(s) for handling server redirect
//		Can be shared by IU control and other Windows Update components
//
//=======================================================================


#pragma once

//-----------------------------------------------------------------------
// 
// DownloadCab() 
//	download a cab file of specific name from a base web address.  The
//  file will be saved locally, with file trust verified and extracted to
//  a specific folder.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszCabName - the file name of the cab file (eg. iuident.cab)
//		ptszBaseUrl - the base web address to download the cab file
//		ptszExtractDir - the local dir to save the cab file and those extracted from it
//		dwFlags - the set of flags to be passed to DownloadFileLite()
//		fExtractFiles (default as TRUE) - extract files
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadCab(
			HANDLE hQuitEvent,
			LPCTSTR ptszCabName,
			LPCTSTR ptszBaseUrl,
			LPCTSTR ptszExtractDir,
			DWORD dwFlags = 0,
			BOOL fExtractFiles = TRUE);


//-----------------------------------------------------------------------
// 
// DownloadIUIdent() 
//	download iuident.cab from a specific location, if provided.
//	Otherwise get it from where the WUServer registry value points to.
//  Either case, it will handle ident redirection.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszBaseUrl - the initial base URL for iuident.cab, must be no bigger than
//					  (INTERNET_MAX_URL_LENGTH) TCHARs.  Otherwise use
//					  WUServer entry from policy.  If entry not found,
//					  use "http://windowsupdate.microsoft.com/v4"
//		ptszFileCacheDir - the local base path to store the iuident.cab and
//						   the files extracted from it
//		dwFlags - the set of flags used by DownloadCab()
//
//		fIdentFromPolicy - tell if this is corpwu use. It has these impacts:
//					TRUE:	(1) no iuident.txt timestamp validation will be done by
//							comparing the newly downloaded cab and existing one.
//							(2) if download fail and ident cab exist and valid,
//							we will verify trust and extract iuident to use.
//					FALSE:	will validate newly downloaded cab against existing one
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadIUIdent(
			HANDLE hQuitEvent,
			LPCTSTR ptszBaseUrl,
			LPTSTR ptszFileCacheDir,
			DWORD dwFlags = 0,
			BOOL fIdentFromPolicy = TRUE);


//-----------------------------------------------------------------------
// 
// GetRedirectServerUrl() 
//	Search the [redirect] section of the given init file for the base
//  server URL corresponding to the OS version.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		lpszNewUrl - point to a buffer to receive redirect server url, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no redirect server url defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		Section name: [redirect]
//		Its entries should be defined according to GetINIValueByOSVer().
// 
//-----------------------------------------------------------------------

HRESULT GetRedirectServerUrl(
			LPCTSTR pcszInitFile, // path of file name.
			LPTSTR lpszNewUrl,	// points to a buffer to receive new server url 
			int nBufSize		// size of buffer, in chars
);


//-----------------------------------------------------------------------
// 
// GetINIValueByOSVer() 
//	Search the specified section of the given init file for
//  the value corresponding to the version of the OS.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		pcszSection - section name which the key is under
//		lpszValue - point to a buffer to receive the entry value, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no value defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		this section contains zero or more entries, each entry has format:
//		<beginVersionRange>-<endVersionRange>=<redirect server url>
//		where:
//			<beginVersionRange> ::= <VersionRangeBound>
//			<endVersionRange> ::= <VersionRangeBound>
//			<VersionRangeBound> ::= EMPTY | Major[.Minor[.Build[.ServicePackMajor[.ServicePackMinor]]]]
//			<redirect server url>=http://blahblah....
//		an empty version range bound means boundless.
//		a missing version component at end of a version data string means default value 0.
//		(e.g., 5.2 = 5.2.0.0.0)
// 
//-----------------------------------------------------------------------

HRESULT GetINIValueByOSVer(
			LPCTSTR pcszInitFile, // path of file name.
			LPCTSTR pcszSection, // section name
			LPTSTR lpszValue,	// points to a buffer to receive new server url 
			int nBufSize);		// size of buffer, in chars
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\safereg.h ===
//
// SafeReg.h
//
//		Functions to ensure strings read from the registry are null-terminated.
//
// History:
//
//		2002-03-20  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#pragma once


#define REG_E_MORE_DATA    HRESULT_FROM_WIN32(ERROR_MORE_DATA)

// Override these if you need a custom allocator for the safe reg functions
#ifndef SafeRegMalloc
#define SafeRegMalloc  malloc
#define SafeRegFree(p) ((p) ? free(p) : NULL)
#endif

HRESULT WINAPI SafeRegQueryStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize, // S_OK: chars written, excluding trailing null
		                                 // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz = NULL // TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize, // S_OK: bytes written, excluding trailing null
		                                // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz = NULL // TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize // S_OK: chars written, excluding final trailing null
		                                // REG_E_MORE_DATA: required size, including nulls
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize // S_OK: bytes written, excluding final trailing null
		                               // REG_E_MORE_DATA: required size, including nulls
	);

HRESULT WINAPI SafeRegQueryStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize,     // chars written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz = NULL //TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcbValueSize, // bytes written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz = NULL // TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize // chars written, excluding final trailing null
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize // chars written, excluding final trailing null
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\schemakeys.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   SchemaKeys.h
//
//	Author:	Charles Ma
//			2000.12.4
//
//  Description:
//
//      header file to declare all schema keys
//
//=======================================================================


#pragma once

#include <windows.h>
#include <ole2.h>
#include <tchar.h>

class CSchemaKeys
{
public:

	CSchemaKeys();
	~CSchemaKeys();

	BSTR		SCHEMA_KEY_XML_NAMESPACE;	// = L"xmlns";
	BSTR		SCHEMA_KEY_XML;				// = L"xml";
	BSTR		SCHEMA_KEY_SYSTEMINFO;		// = L"systemInfo";
	BSTR		SCHEMA_KEY_COMPUTERSYSTEM;	// = L"computerSystem";
	BSTR		SCHEMA_KEY_MANUFACTURER;	// = L"manufacturer";
	BSTR		SCHEMA_KEY_MODEL;			// = L"model";
	BSTR		SCHEMA_KEY_SUPPORTSITE;		// = L"supportSite";
	BSTR		SCHEMA_KEY_ADMINISTRATOR;	// = L"administrator";
	BSTR		SCHEMA_KEY_WU_DISABLED;		// = L"windowsUpdateDisabled";
	BSTR		SCHEMA_KEY_AU_ENABLED;		// = L"autoUpdateEnabled";
	BSTR		SCHEMA_KEY_DRIVESPACE;		// = L"driveSpace";
	BSTR		SCHEMA_KEY_DRIVE;			// = L"drive";
	BSTR		SCHEMA_KEY_KBYTES;			// = L"kbytes";
	BSTR		SCHEMA_KEY_REGKEYS;			// = L"regKeys";
	BSTR		SCHEMA_KEY_REG_HKLM;		// = L"HKEY_LOCAL_MACHINE";
	BSTR		SCHEMA_KEY_REG_SW;			// = L"SOFTWARE";

	BSTR		SCHEMA_KEY_NAME;			// = L"name";
	BSTR		SCHEMA_KEY_COMSERVER;		// = L"comserverID";
	BSTR		SCHEMA_KEY_KEY;				// = L"key";
	BSTR		SCHEMA_KEY_ENTRY;			// = L"entry";
	BSTR		SCHEMA_KEY_VALUE;			// = L"value";
	BSTR		SCHEMA_KEY_VERSION;			// = L"version";
	BSTR		SCHEMA_KEY_VERSIONSTATUS;	// = L"versionStatus";
	BSTR		SCHEMA_KEY_FILEPATH;		// = L"filePath";
	BSTR		SCHEMA_KEY_TIMESTAMP;		// = L"timestamp";
	BSTR		SCHEMA_KEY_GUID;			// = L"guid";

	BSTR		SCHEMA_KEY_CATALOG_PROVIDER;// = L"catalog/provider"
	BSTR		SCHEMA_KEY_ITEMS;			// = L"items"
	BSTR		SCHEMA_KEY_ITEM_SEARCH;		// = L"catalog/provider/item"
	BSTR		SCHEMA_KEY_ITEM;			// = L"item"
	BSTR		SCHEMA_KEY_ITEM_ITEMSTATUS;	// = L"items/itemStatus";
	BSTR		SCHEMA_KEY_ITEMSTATUS;		// = L"itemStatus";
	BSTR		SCHEMA_KEY_DETECTION;		// = L"detection"
    BSTR        SCHEMA_KEY_INSTALLATION;    // = L"installation";
    BSTR        SCHEMA_KEY_INSTALLSTATUS;   // = L"installStatus";
    BSTR		SCHEMA_KEY_INSTALLERTYPE;	// = L"installerType";
	BSTR		SCHEMA_KEY_EXCLUSIVE;		// = L"exclusive";
    BSTR		SCHEMA_KEY_NEEDSREBOOT;		// = L"needsReboot";
    BSTR		SCHEMA_KEY_COMMAND;			// = L"command";
    BSTR		SCHEMA_KEY_SWITCHES;		// = L"switches";
    BSTR		SCHEMA_KEY_COMMANDTYPE;		// = L"commandType";
    BSTR		SCHEMA_KEY_INFINSTALL;		// = L"infInstallSection";
	BSTR		SCHEMA_KEY_CODEBASE;		// = L"codeBase";
	BSTR        SCHEMA_KEY_CRC;				// = L"crc";
	BSTR		SCHEMA_KEY_PATCHAVAILABLE;	// = L"patchAvailable";
	BSTR		SCHEMA_KEY_SIZE;			// = L"size";
	BSTR		SCHEMA_KEY_DOWNLOADPATH;	// = L"downloadPath";
	BSTR		SCHEMA_KEY_DOWNLOADSTATUS;	// = L"downloadStatus";
    BSTR        SCHEMA_KEY_DEPENDENCIES;    // = L"dependencies";
    BSTR        SCHEMA_KEY_DESCRIPTION;     // = L"description";
	BSTR		SCHEMA_KEY_HREF;			// = L"href"
   // NSOY - Fix build break BSTR        SCHEMA_KEY_CRC;             // = L"crc"; 
	BSTR		SCHEMA_KEY_IDENTITY;		// = L"identity";
	BSTR		SCHEMA_KEY_PUBLISHERNAME;	// = L"publisherName";
	BSTR		SCHEMA_KEY_LANGUAGE;		// = L"language"
	BSTR		SCHEMA_KEY_PLATFORM;		// = L"platform"
	BSTR		SCHEMA_KEY_PROCESSORARCHITECTURE; // = L"processorArchitecture"
	BSTR		SCHEMA_KEY_SUITE;			// = L"suite"
	BSTR		SCHEMA_KEY_PRODUCTTYPE;		// = L"productType"
	BSTR		SCHEMA_KEY_LOCALE;			// = L"locale";
	BSTR		SCHEMA_KEY_CONTEXT;			// = L"context";
	BSTR		SCHEMA_KEY_MAJOR;			// = L"major"
	BSTR		SCHEMA_KEY_MINOR;			// = L"minor"
	BSTR		SCHEMA_KEY_BUILD;			// = L"build"
	BSTR		SCHEMA_KEY_SERVICEPACKMAJOR;// = L"servicePackMajor"
	BSTR		SCHEMA_KEY_SERVICEPACKMINOR;// = L"servicePackMinor"
    BSTR        SCHEMA_KEY_COMPATIBLEHARDWARE; // = L"compatibleHardware"
    BSTR        SCHEMA_KEY_DEVICES;         // = L"devices"
    BSTR        SCHEMA_KEY_DEVICE;          // = L"device"
    BSTR        SCHEMA_KEY_PRINTERINFO;     // = L"printerInfo"
    BSTR        SCHEMA_KEY_CDM_PINFO;		// = L"device/printerInfo"
    BSTR        SCHEMA_KEY_DRIVERNAME;      // = L"driverName"
    BSTR        SCHEMA_KEY_HWID;            // = L"hwid"
	BSTR		SCHEMA_KEY_CDM_HWIDPATH;	// = L"device/hwid"
    BSTR        SCHEMA_KEY_DESCRIPTIONTEXT; // = L"descriptionText"
    BSTR        SCHEMA_KEY_TITLE;           // = L"title"
    BSTR        SCHEMA_KEY_ITEMID;			// = L"itemID";
    BSTR        SCHEMA_KEY_HIDDEN;			// = L"hidden";
    BSTR        SCHEMA_KEY_ISPRINTER;       // = L"isPrinter"
    BSTR        SCHEMA_KEY_DEVICEINSTANCE;       // = L"deviceInstance"
    BSTR        SCHEMA_KEY_DRIVERPROVIDER;	// = L"driverProvider"
    BSTR        SCHEMA_KEY_MFGNAME;			// = L"mfgName"
    BSTR        SCHEMA_KEY_DRIVERVER;		// = L"driverVer"
    BSTR        SCHEMA_KEY_RANK;			// = L"rank"
	BSTR		SCHEMA_KEY_READMORE;		// = L"description/descriptionText/details"
	BSTR		SCHEMA_KEY_ERRORCODE;		// = L"errorCode";

    BSTR        SCHEMA_KEY_CATALOGSTATUS;   // = L"catalogStatus";
    BSTR        SCHEMA_KEY_PID;             // = L"pid";

	BSTR		SCHEMA_KEY_DETECTRESULT;	// = L"detectResult"
	BSTR		SCHEMA_KEY_INSTALLED;		// = L"installed"
	BSTR		SCHEMA_KEY_UPTODATE;		// = L"upToDate"
	BSTR		SCHEMA_KEY_NEWERVERSION;	// = L"newerVersion";
	BSTR		SCHEMA_KEY_EXCLUDED;		// = L"excluded"
	BSTR		SCHEMA_KEY_FORCE;			// = L"force"

	BSTR		SCHEMA_KEY_VERSTATUS_HI;	// = L"HIGHER";
	BSTR		SCHEMA_KEY_VERSTATUS_HE;	// = L"HIGHER_OR_SAME";
	BSTR		SCHEMA_KEY_VERSTATUS_EQ;	// = L"SAME";
	BSTR		SCHEMA_KEY_VERSTATUS_LE;	// = L"LOWER_OR_SAME";
	BSTR		SCHEMA_KEY_VERSTATUS_LO;	// = L"LOWER";

	BSTR		SCHEMA_KEY_FILE;			// = L"path";
	BSTR		SCHEMA_KEY_REGKEY;			// = L"regKey";
	BSTR		SCHEMA_KEY_PATH;			// = L"path";
	BSTR		SCHEMA_KEY_STATUS_COMPLETE;	// = L"COMPLETE";
	BSTR		SCHEMA_KEY_STATUS_FAILED;	// = L"FAILED";

	BSTR		SCHEMA_KEY_CLIENT;			// = L"client";
	BSTR		SCHEMA_KEY_CLIENTINFO;		// = L"clientInfo";
	BSTR		SCHEMA_KEY_CLIENTNAME;		// = L"clientName"; attr of clientInfo tag

	LPCTSTR		SCHEMA_KEY_REGKEYEXISTS;	// = _T("regKeyExists");
	LPCTSTR		SCHEMA_KEY_REGKEYVALUE;		// = _T("regKeyValue");
	LPCTSTR		SCHEMA_KEY_REGKEYSUBSTR;	// = _T("regKeySubstring");
	LPCTSTR		SCHEMA_KEY_REGKEYVERSION;	// = _T("regKeyVersion");
	LPCTSTR		SCHEMA_KEY_FILEVERSION;		// = _T("fileVersion");
	LPCTSTR		SCHEMA_KEY_FILEEXISTS;		// = _T("fileExists");
	LPCTSTR		SCHEMA_KEY_AND;				// = _T("and");
	LPCTSTR		SCHEMA_KEY_OR; 				// = _T("or");
	LPCTSTR		SCHEMA_KEY_NOT;	 			// = _T("not");
};


extern CSchemaKeys *g_pGlobalSchemaKeys;
//
// Safe return of schema key from global object pointer
//
#define	RETURN_SCHEMA_KEY( key ) (NULL == g_pGlobalSchemaKeys ? NULL : g_pGlobalSchemaKeys->##key)

#define			KEY_XML_NAMESPACE		RETURN_SCHEMA_KEY(SCHEMA_KEY_XML_NAMESPACE)
#define			KEY_XML					RETURN_SCHEMA_KEY(SCHEMA_KEY_XML)
#define			KEY_SYSTEMINFO			RETURN_SCHEMA_KEY(SCHEMA_KEY_SYSTEMINFO)
#define			KEY_COMPUTERSYSTEM		RETURN_SCHEMA_KEY(SCHEMA_KEY_COMPUTERSYSTEM)
#define			KEY_SUPPORTSITE			RETURN_SCHEMA_KEY(SCHEMA_KEY_SUPPORTSITE)
#define			KEY_ADMINISTRATOR		RETURN_SCHEMA_KEY(SCHEMA_KEY_ADMINISTRATOR)
#define			KEY_WU_DISABLED			RETURN_SCHEMA_KEY(SCHEMA_KEY_WU_DISABLED)
#define			KEY_AU_ENABLED			RETURN_SCHEMA_KEY(SCHEMA_KEY_AU_ENABLED)
#define			KEY_DRIVESPACE			RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVESPACE)
#define			KEY_DRIVE				RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVE)
#define			KEY_KBYTES				RETURN_SCHEMA_KEY(SCHEMA_KEY_KBYTES)
#define			KEY_REGKEYS				RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYS)
#define			KEY_REG_HKLM			RETURN_SCHEMA_KEY(SCHEMA_KEY_REG_HKLM)
#define			KEY_REG_SW				RETURN_SCHEMA_KEY(SCHEMA_KEY_REG_SW)

#define 		KEY_NAME				RETURN_SCHEMA_KEY(SCHEMA_KEY_NAME)				
#define 		KEY_COMSERVER			RETURN_SCHEMA_KEY(SCHEMA_KEY_COMSERVER)
#define 		KEY_KEY					RETURN_SCHEMA_KEY(SCHEMA_KEY_KEY)					
#define 		KEY_ENTRY				RETURN_SCHEMA_KEY(SCHEMA_KEY_ENTRY)				
#define 		KEY_VALUE				RETURN_SCHEMA_KEY(SCHEMA_KEY_VALUE)				
#define 		KEY_VERSION				RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSION)				
#define 		KEY_VERSIONSTATUS		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSIONSTATUS)
#define 		KEY_FILEPATH			RETURN_SCHEMA_KEY(SCHEMA_KEY_FILEPATH)	
#define 		KEY_TIMESTAMP			RETURN_SCHEMA_KEY(SCHEMA_KEY_TIMESTAMP)
#define 		KEY_GUID				RETURN_SCHEMA_KEY(SCHEMA_KEY_GUID)

#define			KEY_CATALOG_PROVIDER	RETURN_SCHEMA_KEY(SCHEMA_KEY_CATALOG_PROVIDER)
#define			KEY_ITEMS				RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEMS)
#define			KEY_ITEM_SEARCH			RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEM_SEARCH)
#define			KEY_ITEM				RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEM)
#define			KEY_ITEM_ITEMSTATUS		RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEM_ITEMSTATUS)
#define			KEY_ITEMSTATUS			RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEMSTATUS)
#define			KEY_DETECTION			RETURN_SCHEMA_KEY(SCHEMA_KEY_DETECTION)
#define         KEY_INSTALLATION        RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLATION)
#define         KEY_INSTALLSTATUS       RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLSTATUS)
#define         KEY_INSTALLERTYPE       RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLERTYPE)
#define         KEY_EXCLUSIVE			RETURN_SCHEMA_KEY(SCHEMA_KEY_EXCLUSIVE)
#define         KEY_NEEDSREBOOT			RETURN_SCHEMA_KEY(SCHEMA_KEY_NEEDSREBOOT)
#define         KEY_COMMAND				RETURN_SCHEMA_KEY(SCHEMA_KEY_COMMAND)
#define         KEY_SWITCHES			RETURN_SCHEMA_KEY(SCHEMA_KEY_SWITCHES)
#define         KEY_COMMANDTYPE			RETURN_SCHEMA_KEY(SCHEMA_KEY_COMMANDTYPE)
#define         KEY_INFINSTALL			RETURN_SCHEMA_KEY(SCHEMA_KEY_INFINSTALL)
#define         KEY_CODEBASE			RETURN_SCHEMA_KEY(SCHEMA_KEY_CODEBASE)
#define         KEY_CRC                 RETURN_SCHEMA_KEY(SCHEMA_KEY_CRC)
#define         KEY_PATCHAVAILABLE		RETURN_SCHEMA_KEY(SCHEMA_KEY_PATCHAVAILABLE)
#define         KEY_SIZE				RETURN_SCHEMA_KEY(SCHEMA_KEY_SIZE)
#define         KEY_DOWNLOADPATH		RETURN_SCHEMA_KEY(SCHEMA_KEY_DOWNLOADPATH)
#define         KEY_DOWNLOADSTATUS		RETURN_SCHEMA_KEY(SCHEMA_KEY_DOWNLOADSTATUS)
#define         KEY_DEPENDENCIES        RETURN_SCHEMA_KEY(SCHEMA_KEY_DEPENDENCIES)
#define         KEY_DESCRIPTION         RETURN_SCHEMA_KEY(SCHEMA_KEY_DESCRIPTION)
#define			KEY_HREF				RETURN_SCHEMA_KEY(SCHEMA_KEY_HREF)
#define			KEY_LANGUAGE			RETURN_SCHEMA_KEY(SCHEMA_KEY_LANGUAGE)

#define			KEY_PLATFORM			RETURN_SCHEMA_KEY(SCHEMA_KEY_PLATFORM)
#define			KEY_PROCESSORARCHITECTURE RETURN_SCHEMA_KEY(SCHEMA_KEY_PROCESSORARCHITECTURE)
#define			KEY_SUITE				RETURN_SCHEMA_KEY(SCHEMA_KEY_SUITE)
#define			KEY_PRODUCTTYPE			RETURN_SCHEMA_KEY(SCHEMA_KEY_PRODUCTTYPE)
#define			KEY_LOCALE				RETURN_SCHEMA_KEY(SCHEMA_KEY_LOCALE)
#define			KEY_CONTEXT				RETURN_SCHEMA_KEY(SCHEMA_KEY_CONTEXT)
#define			KEY_MAJOR				RETURN_SCHEMA_KEY(SCHEMA_KEY_MAJOR)
#define			KEY_MINOR				RETURN_SCHEMA_KEY(SCHEMA_KEY_MINOR)
#define			KEY_BUILD				RETURN_SCHEMA_KEY(SCHEMA_KEY_BUILD)
#define			KEY_SERVICEPACKMAJOR	RETURN_SCHEMA_KEY(SCHEMA_KEY_SERVICEPACKMAJOR)
#define			KEY_SERVICEPACKMINOR	RETURN_SCHEMA_KEY(SCHEMA_KEY_SERVICEPACKMINOR)
#define			KEY_COMPATIBLEHARDWARE  RETURN_SCHEMA_KEY(SCHEMA_KEY_COMPATIBLEHARDWARE)
#define			KEY_DEVICES             RETURN_SCHEMA_KEY(SCHEMA_KEY_DEVICES)
#define			KEY_DEVICE              RETURN_SCHEMA_KEY(SCHEMA_KEY_DEVICE)
#define         KEY_PRINTERINFO         RETURN_SCHEMA_KEY(SCHEMA_KEY_PRINTERINFO)
#define         KEY_CDM_PINFO	        RETURN_SCHEMA_KEY(SCHEMA_KEY_CDM_PINFO)
#define         KEY_DRIVERNAME          RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVERNAME)
#define			KEY_HWID                RETURN_SCHEMA_KEY(SCHEMA_KEY_HWID)
#define			KEY_CDM_HWIDPATH        RETURN_SCHEMA_KEY(SCHEMA_KEY_CDM_HWIDPATH)
#define			KEY_DESCRIPTIONTEXT     RETURN_SCHEMA_KEY(SCHEMA_KEY_DESCRIPTIONTEXT)
#define			KEY_TITLE               RETURN_SCHEMA_KEY(SCHEMA_KEY_TITLE)
#define			KEY_ITEMID				RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEMID)
#define			KEY_HIDDEN				RETURN_SCHEMA_KEY(SCHEMA_KEY_HIDDEN)
#define			KEY_ISPRINTER           RETURN_SCHEMA_KEY(SCHEMA_KEY_ISPRINTER)
#define			KEY_DEVICEINSTANCE      RETURN_SCHEMA_KEY(SCHEMA_KEY_DEVICEINSTANCE)
#define			KEY_DRIVERPROVIDER		RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVERPROVIDER)
#define			KEY_MFGNAME				RETURN_SCHEMA_KEY(SCHEMA_KEY_MFGNAME)
#define			KEY_DRIVERVER			RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVERVER)
#define			KEY_RANK				RETURN_SCHEMA_KEY(SCHEMA_KEY_RANK)
#define			KEY_READMORE			RETURN_SCHEMA_KEY(SCHEMA_KEY_READMORE)
#define			KEY_ERRORCODE			RETURN_SCHEMA_KEY(SCHEMA_KEY_ERRORCODE)

#define         KEY_CATALOGSTATUS       RETURN_SCHEMA_KEY(SCHEMA_KEY_CATALOGSTATUS)
#define         KEY_PID                 RETURN_SCHEMA_KEY(SCHEMA_KEY_PID)

#define			KEY_DETECTRESULT		RETURN_SCHEMA_KEY(SCHEMA_KEY_DETECTRESULT)
#define			KEY_INSTALLED			RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLED)
#define			KEY_UPTODATE			RETURN_SCHEMA_KEY(SCHEMA_KEY_UPTODATE)
#define			KEY_NEWERVERSION		RETURN_SCHEMA_KEY(SCHEMA_KEY_NEWERVERSION)
#define			KEY_EXCLUDED			RETURN_SCHEMA_KEY(SCHEMA_KEY_EXCLUDED)
#define			KEY_FORCE				RETURN_SCHEMA_KEY(SCHEMA_KEY_FORCE)

#define 		KEY_VERSTATUS_HI		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_HI)		
#define 		KEY_VERSTATUS_HE		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_HE)		
#define 		KEY_VERSTATUS_EQ		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_EQ)		
#define 		KEY_VERSTATUS_LE		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_LE)		
#define 		KEY_VERSTATUS_LO		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_LO)		

#define 		KEY_IDENTITY			RETURN_SCHEMA_KEY(SCHEMA_KEY_IDENTITY)			
#define 		KEY_PUBLISHERNAME		RETURN_SCHEMA_KEY(SCHEMA_KEY_PUBLISHERNAME)		
#define 		KEY_FILE				RETURN_SCHEMA_KEY(SCHEMA_KEY_FILE)				
#define 		KEY_REGKEY				RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEY)
#define 		KEY_PATH				RETURN_SCHEMA_KEY(SCHEMA_KEY_PATH)	
#define 		KEY_STATUS_COMPLETE		RETURN_SCHEMA_KEY(SCHEMA_KEY_STATUS_COMPLETE)
#define 		KEY_STATUS_FAILED		RETURN_SCHEMA_KEY(SCHEMA_KEY_STATUS_FAILED)

#define			KEY_CLIENT				RETURN_SCHEMA_KEY(SCHEMA_KEY_CLIENT)
#define			KEY_CLIENTINFO			RETURN_SCHEMA_KEY(SCHEMA_KEY_CLIENTINFO)
#define			KEY_CLIENTNAME			RETURN_SCHEMA_KEY(SCHEMA_KEY_CLIENTNAME)

#define			KEY_MANUFACTURER		RETURN_SCHEMA_KEY(SCHEMA_KEY_MANUFACTURER)
#define			KEY_MODEL				RETURN_SCHEMA_KEY(SCHEMA_KEY_MODEL)



#define 		KEY_REGKEYEXISTS		RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYEXISTS)
#define 		KEY_REGKEYVALUE			RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYVALUE)
#define 		KEY_REGKEYSUBSTR		RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYSUBSTR)
#define 		KEY_REGKEYVERSION		RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYVERSION)
#define 		KEY_FILEVERSION			RETURN_SCHEMA_KEY(SCHEMA_KEY_FILEVERSION)
#define 		KEY_FILEEXISTS			RETURN_SCHEMA_KEY(SCHEMA_KEY_FILEEXISTS)
#define 		KEY_AND					RETURN_SCHEMA_KEY(SCHEMA_KEY_AND)
#define 		KEY_OR 					RETURN_SCHEMA_KEY(SCHEMA_KEY_OR)
#define 		KEY_NOT 				RETURN_SCHEMA_KEY(SCHEMA_KEY_NOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\timeutil.h ===
#pragma once
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <limits.h>
#include <mistsafe.h>

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

const TCHAR EOS = _T('\0');
const WCHAR WEOS = L'\0';
const int NanoSec100PerSec = 10000000;      // number of 100 nanoseconds per second

////////////////////////////////////////////////////////////////////////////
//
// Function  TimeDiff(tm1, tm2)
//          helper function to find the difference (in seconds) of 2 system times
//
// Input:   2 SYSTEMTIME structures
// Output:  None
// Return:  seconds of difference
//              > 0 if tm2 is later than tm1
//              = 0 if tm2 and tm1 are the same
//              < 0 if tm2 is earlier than tm1
//
// On error the function returns 0 even if the two times are not equal
//
// Comment: If the number of seconds goes beyond INT_MAX (that is 
//          more than 24,855 days, INT_MAX is returned.
//          If the number of seconds goes beyond INT_MIN (a negative value,
//          means 24,855 days ago), INT_MIN is returned.
//
////////////////////////////////////////////////////////////////////////////
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2);


////////////////////////////////////////////////////////////////////////////
//
// Function  TimeAddSeconds(SYSTEMTIME, int, SYSTEMTIME* )
//          helper function to calculate time by adding n seconds to 
//          the given time.
//
// Input:   a SYSTEMTIME as base time, an int as seconds to add to the base time
// Output:  new time
// Return:  HRESULT
//
////////////////////////////////////////////////////////////////////////////
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew);


//Function to convert a string buffer to system time
HRESULT String2SystemTime(LPCTSTR pszDateTime, SYSTEMTIME *ptm);

//Function to convert a system time structure to a string buffer
HRESULT SystemTime2String(SYSTEMTIME & tm, LPTSTR pszDateTime, size_t cSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\stringutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   fileutil.h
//
//  Description:
//
//      IU string utility library, providing functions available
//		only in CRT or SHLWAPI
//
//=======================================================================


#ifndef __STRINGUTIL_H_INCLUDED__

#include <ole2.h>
#include <shlwapi.h>
// ----------------------------------------------------------------------
//
// Public function StrChr() - same as shlwapi StrChr()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChr(LPCTSTR lpStart, const TCHAR wMatch);


// ----------------------------------------------------------------------
//
// Public function StrChrI() - same as shlwapi StrChrI()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case INsensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChrI(LPCTSTR lpStart, const TCHAR wMatch);

// ----------------------------------------------------------------------
//
// Public function StrRChr() - same as shlwapi StrRChr()
//		Searches a string for the last occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//      lpEnd - Address of the end of the string (NOT included in the search)
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrRChr(LPCTSTR lpStart, LPCTSTR lpEnd, const TCHAR wMatch);


// ----------------------------------------------------------------------
//
//	Private helper function to compare the contents of 
//	two BSTRs
//
// ----------------------------------------------------------------------
inline int CompareBSTRs(BSTR bstr1, BSTR bstr2)
{
	if (NULL == bstr1)
	{
		if (NULL == bstr2)
		{
			// Consider them equal
			return 0;
		}
		else
		{
			// Consider bstr1 < bstr2
			return -1;
		}
	}
	else if (NULL == bstr2)
	{
		// bstr1 isn't NULL (already checked) so consider bstr1 > bstr 2
		return 1;
	}
	//
	// Neither bstr is NULL, so we'll do a SHLWAPI compare of the first
	// string in each BSTR
	//
	LPWSTR p1 = (LPWSTR)((LPOLESTR) bstr1);
	LPWSTR p2 = (LPWSTR)((LPOLESTR) bstr2);
	return StrCmpIW(p1, p2);
};

inline BOOL CompareBSTRsEqual(BSTR bstr1, BSTR bstr2)
{
	return (CompareBSTRs(bstr1, bstr2) == 0);
};



// ----------------------------------------------------------------------
//
//	Convert a long number content in bstr into long
//	if error, 0 returned.
//
// ----------------------------------------------------------------------
LONG MyBSTR2L(BSTR bstrLongNumber);
#define MyBSTR2UL(bstrULongNumber)  (ULONG) MyBSTR2L(bstrULongNumber)

// ----------------------------------------------------------------------
//
//	Convert a a long number into bstr
//
// ----------------------------------------------------------------------
BSTR MyL2BSTR(LONG lNumber);
BSTR MyUL2BSTR(ULONG ulNumber);


// ----------------------------------------------------------------------
//
// Compare a binary buffer with a string, where data in the string
// has format:
//
//		<String>	::= <Number> [<Space><String>]
//		<Space>		::= TCHAR(' ')
//		<Number>	::= 0x<HexValue>|x<HexValue><Decimal>
//		<Decimal>	::= +<DecimalValue>|-<DecimalValue>
//		<DecimalValue> ::= <DecimalDigit>|<DecimalDigit><DecimalValue>
//		<DecimalDegit> ::= 0|1|2|3|4|5|6|7|8|9
//		<HexValue>	::= <HexDigit>|<HexDigit><HexDigit>
//		<HexDigit>	::= <DecimalDigit>|A|B|C|D|E|F
//
//	example of strings that this function recognize:
//		"12 0 45 0x1F"
//
//	Return: similar to lstrcmp() API, each byte is compared
//			as unsigned short
//			if binary > string, +1
//			if binary = string, 0
//			if binary < string, -1
//
// Note: if a number in string is bigger than a byte can handle,
// or not a valid number this funciton treats it as 0x0 when comparing.
//
// ----------------------------------------------------------------------
int CmpBinaryToString(
		LPBYTE pBinaryBuffer,		// buffer to contain binary data
		UINT nBinarySize,			// number of bytes this binary has data
		LPCTSTR pstrValue			// string contains data to compare
);

/*
 * FUNCTION:		int atoh(char *ptr)
 * 
 * PURPOSE:			This function converts an hexadecimal string into it's decimal value.
 * 
 * PARAMETERS:
 *
 *		char *ptr:	pointer to string to be converted
 * 
 * RETURNS:			The converted value.
 * 
 * COMMENTS:		Like atoi this function ends the conversion on the first innvalid
 *					hex digit.
 * 
 */
int atoh(LPCSTR ptr);

#define __STRINGUTIL_H_INCLUDED__
#endif // __STRINGUTIL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\smbios.h ===
/*** smbios.h - SMBIOS spec
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _SMBIOS_H
#define _SMBIOS_H

#include <pshpack1.h>

#define SMBIOS_SEARCH_RANGE_BEGIN		0xF0000         // physical address where we begin searching for the RSDP
#define SMBIOS_SEARCH_RANGE_END         0xFFFFF
#define SMBIOS_SEARCH_RANGE_LENGTH      ((ULONG)(SMBIOS_SEARCH_RANGE_END-SMBIOS_SEARCH_RANGE_BEGIN+1))
#define SMBIOS_SEARCH_INTERVAL          16      // search on 16 byte boundaries

#define PNP_SIGNATURE					0x506E5024  // "$PnP"
#define SM_SIGNATURE					0x5F4D535F	// "_SM_"

#define SMBIOS_BIOS_INFO_TABLE			0
#define SMBIOS_SYSTEM_INFO_TABLE		1

typedef struct _PNPBIOSINIT
{
	DWORD		dwSignature;
	BYTE		bRevision;
	BYTE		bLength;
	WORD		wControl;
	BYTE		bChecksum;
	DWORD		dwEventNotify;
	WORD		wRealOffset;
	WORD		wRealSegment;
	WORD		wProtectedOffset;
	DWORD		dwProtectedSegment;
	DWORD		dwOEMID;
	WORD		wRealDataSegment;
	DWORD		dwProtectedDataSegment;
} PNPBIOSINIT, * PPNPBIOSINIT;

typedef struct _SMBIOSENTRY
{
	DWORD		dwSignature;
	BYTE		bChecksum;
	BYTE		bLength;
	BYTE		bMajorVersion;
	BYTE		bMinorVersion;
	WORD		wMaxStructSize;
	BYTE		bRevision;
	BYTE		abFormatedArea[5];
	BYTE		abOldSignature[5];	// _DMI_
	BYTE		bOldChecksum;
	WORD		wStructTableLength;
	DWORD		dwStructTableAddress;
	WORD		wNumberOfStructs;
	BYTE		bBCDRevision;
} SMBIOSENTRY, * PSMBIOSENTRY;

typedef struct _SMBIOSHEADER
{
	BYTE		bType;
	BYTE		bLength;
	WORD		wHandle;
} SMBIOSHEADER, * PSMBIOSHEADER;

typedef struct _SMBIOSSYSINFO
{
	BYTE		bType;
	BYTE		bLength;
	WORD		wHandle;
	BYTE		bManufacturer;
	BYTE		bProductName;
	BYTE		bVersion;
	BYTE		bSerialNumber;
	BYTE		abUUID[16];
	BYTE		bWakeUpType;
} SMBIOSSYSINFO, * PSMBIOSSYSINFO;

#endif  //_SMBIOS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\trust.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//     	No portion of this source code may be reproduced
//     	without express written permission of Microsoft Corporation.
//
//     	This source code is proprietary and confidential.
//
//	SYSTEM:		Industry Update
//
//	CLASS:		N/A
//	MODULE:		TRUST.LIB
//	FILE:		TRUST.H
//
/////////////////////////////////////////////////////////////////////
//
//	DESC:	this header file declares functions used to make cabs 
//			signed by certain providers trusted.
//
//	AUTHOR:	Charles Ma, converted from WU CDMLIB
//	DATE:	10/4/2000
//
/////////////////////////////////////////////////////////////////////
//
//	Revision History:
//
//	Date        Author    Description
//	~~~~        ~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//	2002-01-18  KenSh     Added revocation check param to VerifyFileTrust
//
/////////////////////////////////////////////////////////////////////
//

#pragma once


//
// define the number of bytes needed to store a SHA1 hashing value
// of the public key
//
const UINT HASH_VAL_SIZE = 20;		

//
// define structure used to pass in the hash values to the following
// function in order to detect if one of the hash matches the
// public key of the leaf cert of a file.
//
typedef struct _HASH_STRUCT {
	UINT uiCount;
	PBYTE pCerts;
} CERT_HASH_ARRAY, *pCERT_HASH_ARRAY;


/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFileTrust()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			pbSha1HashVae - a pointer to a 20 byte long buffer, containing
//							the signature SHA1 hashing value that should
//							be used to check this file, or NULL for checking
//							known Microsoft cert.
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, or
//						 (2) properly signed with a non-MS cert
//          fCheckRevocation - whether the certificat revocation list (CRL) is
//                             checked to see whether any of the certs in the chain
//                             have been revoked. Never prompts the user to initiate
//                             a dial-up connection. Default = FALSE.
//
// Return:	HRESULT - S_OK the file is signed with a valid cert
//					  or error code.
//					  If the file is signed correctly but cert is not
//					  a known Microsoft cert, or it's SHA1 hash does not match
//					  the one passed in, then CERT_UNTRUSTED_ROOT is returned.
//
// Good Cert: Here is the deifnition of a good cert, in addition to the fact
//			  that the signature must be valid and not expired.
//				(1) The signature was signed with a cert that has 
//					"Microsoft Root Authority" as root, or
//				(2) Parameter pbSha1HashVal is not NULL, and the file's SHA1
//					hashing value of signature matches this value, or
//				(3) The signature was signed with one of the following known
//					Microsoft cert's (they are not rooted to MS) and 
//					pbSha1HashVal is NULL.
//					* Microsoft Corporation
//					* Microsoft Corporation MSN
//					* MSNBC Interactive News LLC
//					* Microsoft Corporation MSN (Europe)
//					* Microsoft Corporation (Europe)
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFileTrust(
						IN LPCTSTR			szFileName, 
						IN pCERT_HASH_ARRAY	pHashArray,
						BOOL				fShowBadUI,
						BOOL                fCheckRevocation = FALSE
						);


/////////////////////////////////////////////////////////////////////////////
// 
// Public Function ReadWUPolicyShowTrustUI()
//
// Input:	void
//
// Return:	BOOL - FALSE means ShowTrustUI regkey is not present, or is set to 0
//                     TRUE means ShowTrustUI regkey is present and is set to 1
//
//
/////////////////////////////////////////////////////////////////////////////
BOOL ReadWUPolicyShowTrustUI();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\schemamisc.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   schemaMisc.h
//
//	Author:	Charles Ma
//			2000.12.4
//
//  Description:
//
//      header file of helper functions for IU schemas
//
//=======================================================================


#pragma once

#include <msxml.h>

//
// max length of platform when being converted into string
// this is an artificial number that we think enough to
// take any MS platform data.
//
extern const UINT MAX_PLATFORM_STR_LEN;			// = 1024

//
// private flags used by functions to retrieve string data
//
extern const DWORD SKIP_SUITES;					//= 0x1;
extern const DWORD SKIP_SERVICEPACK_VER;		//= 0x2;



/////////////////////////////////////////////////////////////////////////////
//
// Helper function DoesNodeHaveName()
//
//	find out the the current node has a matching name
//
//	Input:
//			a node
//
//	Return:
//			TRUE/FALSE
//
/////////////////////////////////////////////////////////////////////////////
BOOL DoesNodeHaveName(
	IXMLDOMNode* pNode, 
	BSTR bstrTagName
);



//----------------------------------------------------------------------
//
// Helper function FindNode()
//	retrieve the named child node
//
//	Input:
//		an IXMLDomNode and a bstr name
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------

BOOL
FindNode(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	IXMLDOMNode** ppFoundNode
);



//----------------------------------------------------------------------
//
// Helper function FindNodeValue()
//	retrieve the text data from a named child of the current node, 
//
//	Input:
//		an IXMLDomNode
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------
BOOL
FindNodeValue(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	BSTR* pbstrValue);


/////////////////////////////////////////////////////////////////////////////
// ReportParseError()
//
// Report parsing error information
/////////////////////////////////////////////////////////////////////////////
HRESULT ReportParseError(IXMLDOMParseError *pXMLError);

/////////////////////////////////////////////////////////////////////////////
// ValidateDoc()
//
// Validate the xml doc against the schema
/////////////////////////////////////////////////////////////////////////////
HRESULT ValidateDoc(IXMLDOMDocument* pDoc);

/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode);

/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode);

/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMNode* pParentNode, BSTR bstrName);

/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMDocument* pDoc, BSTR bstrName);

/////////////////////////////////////////////////////////////////////////////
// CreateDOMNode()
//
// Create an xml node of the given type
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNode* CreateDOMNode(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI = NULL);

/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// In various flavors.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT* piAttr);
HRESULT GetAttributeBOOL(IXMLDOMNode* pNode, BSTR bstrName, BOOL* pfAttr);
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, LONG* piAttr);
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR* pbstrAttr);

/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (integer) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT iAttr);

/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (BSTR) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR bstrAttr);

/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (VARIANT) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, VARIANT vAttr);

/////////////////////////////////////////////////////////////////////////////
// GetText()
//
// Get text (BSTR) from the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT GetText(IXMLDOMNode* pNode, BSTR* pbstrText);

/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (integer) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, INT iValue);

/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (BSTR) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, BSTR bstrValue);

/////////////////////////////////////////////////////////////////////////////
// InsertNode()
//
// Insert a child node to the parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT InsertNode(IXMLDOMNode* pParentNode, IXMLDOMNode* pChildNode, IXMLDOMNode* pChildNodeRef = NULL);

/////////////////////////////////////////////////////////////////////////////
// CopyNode()
//
// Create an xml node as a copy of the given node;
// this is different from cloneNode() as it copies node across xml document
/////////////////////////////////////////////////////////////////////////////
HRESULT CopyNode(IXMLDOMNode* pNodeSrc, IXMLDOMDocument* pDocDes, IXMLDOMNode** ppNodeDes);

/////////////////////////////////////////////////////////////////////////////
// AreNodesEqual()
//
// Return TRUE if two nodes are identical, return FALSE if they're different.
/////////////////////////////////////////////////////////////////////////////
BOOL AreNodesEqual(IXMLDOMNode* pNode1, IXMLDOMNode* pNode2);

/////////////////////////////////////////////////////////////////////////////
// LoadXMLDoc()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadXMLDoc(BSTR bstrXml, IXMLDOMDocument** ppDoc, BOOL fOffline = TRUE);

/////////////////////////////////////////////////////////////////////////////
// LoadDocument()
//
// Load an XML Document from the specified file
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocument(BSTR bstrFilePath, IXMLDOMDocument** ppDoc, BOOL fOffline = TRUE);

/////////////////////////////////////////////////////////////////////////////
// SaveDocument()
//
// Save an XML Document to the specified location
/////////////////////////////////////////////////////////////////////////////
HRESULT SaveDocument(IXMLDOMDocument* pDoc, BSTR bstrFilePath);

//----------------------------------------------------------------------
//
// public function Get3IdentiStrFromIdentNode()
//	retrieve the name, publisherName and GUID from an identity node 
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT
Get3IdentiStrFromIdentNode(
	IXMLDOMNode* pIdentityNode, 
	BSTR* pbstrName, 
	BSTR* pbstrPublisherName, 
	BSTR* pbstrGUID
);


//----------------------------------------------------------------------
//
// public function UtilGetUniqIdentityStr()
//	retrieve the unique string that make this <identity> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetUniqIdentityStr(
	IXMLDOMNode* pIdentityNode, 
	BSTR* pbstrUniqIdentifierString, 
	DWORD dwFlag);


//----------------------------------------------------------------------
//
// public function UtilGetPlatformStr()
//	retrieve the unique string that make this <platform> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetPlatformStr(
	IXMLDOMNode* pNodePlatform, 
	BSTR* pbstrPlatform, 
	DWORD dwFlag);
    

//----------------------------------------------------------------------
//
// public function UtilGetVersionStr()
//	retrieve the data from this <version> in string format
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetVersionStr(
	IXMLDOMNode* pVersionNode, 
	LPTSTR pszVersion, 
	DWORD dwFlag);
	


/////////////////////////////////////////////////////////////////////////////
// MakeUniqNameString()
//
// This is a utility function to construct the identity name string 
// based on name|publiser|GUID and the rule to make this name string.
//
// This function defines the logic about what components can be used
// to define the uniqueness of an item based on the 3 parts of data from
// GetIdentity().
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MakeUniqNameString(
					BSTR bstrName,
					BSTR bstrPublisher,
					BSTR bstrGUID,
					BSTR* pbstrUniqIdentifierString);


//-----------------------------------------------------------------------
//
// function GetFullFilePathFromFilePathNode()
//
//	retrieve the full qualified file path from a filePath node
//	the path retrieved is expanded.
//
// Input:
//		a filePath XMLDom node
//		a pointer to a buffer to receive path, assumes MAX_PATH long.
//
// Return:
//		HRESULT
//
//		
//-----------------------------------------------------------------------

HRESULT GetFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			LPTSTR lpszFilePath
);

HRESULT GetBstrFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			BSTR* pbstrFilePath
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\urllogging.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	URLLogging.h
//
//  Description:
//
//		URL logging utility class
//		This class helps you construct the server ping URL and
//		then send the ping to the designed server.
//
//		The default base URL is defined in IUIdent, under section [IUPingServer]
//		and entry is "ServerUrl".
//
//		This class implements single-thread version only. So it is suitable
//		to call it at operation level, i.e., create a separate object
//		for each operation in a single thread.
//
//		The ping string send to the ping server has the following format:
//			/wutrack.bin
//			?U=<user>
//			&C=<client>
//			&A=<activity>
//			&I=<item>
//			&D=<device>
//			&P=<platform>
//			&L=<language>
//			&S=<status>
//			&E=<error>
//			&M=<message>
//			&X=<proxy>
//		where
//			<user>		a static 128-bit value that unique-ifies each copy
//						of Windows installed.  The class will automatically
//						reuse one previously assigned to the running OS; or
//						will generate one if it does not exist.
//			<client>	a string that identifies the entity that performed
//						activity <activity>.  Here are the possible values
//						and their meanings:
//							"iu"			IU control
//							"au"			Automatic Updates
//							"du"			Dynamic Update
//							"CDM"			Code Download Manager
//							"IU_SITE"		IU Consumer site
//							"IU_Corp"		IU Catalog site
//			<activity>	a letter that identifies the activity performed.
//						Here are the possible values and their meanings:
//							"n"				IU control initization
//							"d"				detection
//							"s"				self-update
//							"w"				download
//							"i"				installation
//			<item>		a string that identifies an update item.
//			<device>	a string that identifies either a device's PNPID when
//						device driver not found during detection; or a
//						PNPID/CompatID used by item <item> for activity
//						<activity> if the item is a device driver.
//			<platform>	a string that identifies the platform of the running
//						OS and processor architecture.  The class will
//						compute this value for the pingback.
//			<language>	a string that identifies the language of the OS
//						binaries.  The class will compute this value for the
//						pingback.
//			<status>	a letter that specifies the status that activity
//						<activity> reached.  Here are the possible values and
//						 their meanings:
//							"s"				succeeded
//							"r"				succeeded (reboot required)
//							"f"				failed
//							"c"				cancelled by user
//							"d"				declined by user
//							"n"				no items
//							"p"				pending
//			<error>		a 32-bit error code in hex (w/o "0x" as prefix).
//			<message>	a string that provides additional information for the
//						status <status>.
//			<proxy>		a 32-bit random value in hex for overriding proxy
//						caching.  This class will compute this value for
//						each pingback.
//
//=======================================================================

#pragma once

typedef CHAR URLLOGPROGRESS;
typedef CHAR URLLOGDESTINATION;
typedef TCHAR URLLOGACTIVITY;
typedef TCHAR URLLOGSTATUS;

#define URLLOGPROGRESS_ToBeSent		((CHAR)  0)
#define URLLOGPROGRESS_Sent			((CHAR) -1)

#define URLLOGDESTINATION_DEFAULT	((CHAR) '?')
#define URLLOGDESTINATION_LIVE		((CHAR) 'l')
#define URLLOGDESTINATION_CORPWU	((CHAR) 'c')

#define URLLOGACTIVITY_Initialization	((URLLOGACTIVITY) L'n')
#define URLLOGACTIVITY_Detection		((URLLOGACTIVITY) L'd')
#define URLLOGACTIVITY_SelfUpdate		((URLLOGACTIVITY) L's')
#define URLLOGACTIVITY_Download			((URLLOGACTIVITY) L'w')
#define URLLOGACTIVITY_Installation		((URLLOGACTIVITY) L'i')

#define URLLOGSTATUS_Success	((URLLOGSTATUS) L's')
#define URLLOGSTATUS_Reboot		((URLLOGSTATUS) L'r')
#define URLLOGSTATUS_Failed		((URLLOGSTATUS) L'f')
#define URLLOGSTATUS_Cancelled	((URLLOGSTATUS) L'c')
#define URLLOGSTATUS_Declined	((URLLOGSTATUS) L'd')
#define URLLOGSTATUS_NoItems	((URLLOGSTATUS) L'n')
#define URLLOGSTATUS_Pending	((URLLOGSTATUS) L'p')

typedef struct tagURLENTRYHEADER
{
	URLLOGPROGRESS progress;	// Whether this entry has been sent
	URLLOGDESTINATION destination;
	WORD wRequestSize;		// in WCHARs
	WORD wServerUrlLen;	// in WCHARs
} ULENTRYHEADER, PULENTRYHEADER;

class CUrlLog
{
public:
	CUrlLog(void);
	CUrlLog(
		LPCTSTR	ptszClientName,
		LPCTSTR	ptszLiveServerUrl,	// from iuident
		LPCTSTR ptszCorpServerUrl);	// from Federated WU domain policy

	~CUrlLog(void);

	BOOL SetDefaultClientName(LPCTSTR ptszClientName);

	inline BOOL SetLiveServerUrl(LPCTSTR ptszLiveServerUrl)
	{
		return SetServerUrl(ptszLiveServerUrl, m_ptszLiveServerUrl);
	}

	inline BOOL SetCorpServerUrl(LPCTSTR ptszCorpServerUrl)
	{
		return SetServerUrl(ptszCorpServerUrl, m_ptszCorpServerUrl);
	}

	HRESULT Ping(
				BOOL fOnline,					// online or offline ping
				URLLOGDESTINATION destination,	// live or corp WU ping server
				PHANDLE phQuitEvents,			// ptr to handles for cancelling the operation
				UINT nQuitEventCount,			// number of handles
				URLLOGACTIVITY activity,		// activity code
				URLLOGSTATUS status,			// status code
				DWORD dwError = 0x0,			// error code
				LPCTSTR ptszItemID = NULL,		// uniquely identify an item
				LPCTSTR ptszDeviceID = NULL,	// PNPID or CompatID
				LPCTSTR tszMessage = NULL,		// additional info
				LPCTSTR ptszClientName = NULL);	// client name string

	// Send all pending (offline) ping requests to server
	HRESULT Flush(PHANDLE phQuitEvents, UINT nQuitEventCount);

protected:
	LPTSTR m_ptszLiveServerUrl;
	LPTSTR m_ptszCorpServerUrl;

private:
	TCHAR	m_tszLogFile[MAX_PATH];
//	TCHAR	m_tszTmpLogFile[MAX_PATH];
	TCHAR	m_tszDefaultClientName[64];
	TCHAR	m_tszPlatform[8+1+8+1+8+1+8+1+4+1+4+1+4 + 1];
	TCHAR	m_tszLanguage[8+1+8 + 1];	// according to RFC1766
	TCHAR	m_tszPingID[sizeof(UUID) * 2 + 1];
	BOOL	m_fPingIdInit;

	// Common init routine
	void Init(void);

	// Set URL for live or corp WU ping server
	BOOL SetServerUrl(LPCTSTR ptszUrl, LPTSTR & ptszServerUrl);

	// Obtain file names for offline ping
	inline void GetLogFileName(void);

	// Obtain the existing ping ID from the registry, or generate one if not available.
	inline HRESULT LookupPingID(void);

	// Obtain platfrom info for ping
	inline void LookupPlatform(void);

	// Obtain system language info for ping
	inline void LookupSystemLanguage(void);

	// Construct a URL used to ping server
	inline HRESULT MakePingUrl(
				LPTSTR ptszUrl,			// buffer to receive result
				int cChars,				// the number of chars this buffer can take, including ending null
				LPCTSTR ptszBaseUrl,	// server URL
				LPCTSTR ptszClientName,	// which client called
				URLLOGACTIVITY activity,
				LPCTSTR	ptszItemID,
				LPCTSTR ptszDeviceID,
				URLLOGSTATUS status,
				DWORD dwError,			// result of download. SUCCESS if S_OK or ERROR_SUCCESS
				LPCTSTR ptszMessage);

	// Ping server to report status
	HRESULT PingStatus(URLLOGDESTINATION destination, LPCTSTR ptszUrl, PHANDLE phQuitEvents, UINT nQuitEventCount) const;

	// Read a ping entry from the given file handle
	inline HRESULT ReadEntry(HANDLE hFile, ULENTRYHEADER & ulentryheader, LPWSTR pwszBuffer, DWORD dwBufferSize) const;

	// Save a ping entry into the log file
	inline HRESULT SaveEntry(ULENTRYHEADER & ulentryheader, LPCWSTR pwszString) const;
};



// Escape unsafe chars in a TCHAR string
BOOL EscapeString(
		LPCTSTR ptszUnescaped,
		LPTSTR ptszBuffer,
		DWORD dwCharsInBuffer);



// ----------------------------------------------------------------------------------
// IsConnected()
//          detect if there is a connection currently that can be used to
//          connect to Windows Update site.
//          If yes, we activate the shedule DLL
//
// Input :  ptszUrl - Url containing host name to check for connection
//			fLive - whether the destination is the live site
// Output:  None
// Return:  TRUE if we are connected and we can reach the web site.
//          FALSE if we cannot reach the site or we are not connected.
// ----------------------------------------------------------------------------------

BOOL IsConnected(LPCTSTR ptszUrl, BOOL fLive);



// ----------------------------------------------------------------------------------
// MakeUUID()
//			create a UUID that is not linked to MAC address of a NIC, if any, on the
//			system.
//
// Input :	pUuid - ptr to the UUID structure to hold the returning value.
// ----------------------------------------------------------------------------------
void MakeUUID(UUID* pUuid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\urlagent.h ===
//***********************************************************************************
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	UrlAgent.h
//
//  Description:
//
//		This class encapsulates the logic about where to get the right logic
//		for various purposes, including the case of running WU in corporate 
//		environments.
//
//		An object based on this class should be created first, then call
//		GetOriginalIdentServer() function to get where to download ident,
//		then download ident, then call PopulateData() function to read
//		all URL related data.
// 
//
//  Created by: 
//		Charles Ma
//
//	Date Creatd:
//		Oct 19, 2001
//
//***********************************************************************************

#pragma once


class CUrlAgent
{
public:
	
	//
	// constructor/destructor
	//
	CUrlAgent();
	virtual ~CUrlAgent();


	//
	// when instantiated, the object is not populated, 
	// until PopulateData() is called.
	//
	inline BOOL HasBeenPopulated(void) {return m_fPopulated;}

	//
	// this function should be called after you downloaded ident, and get
	// a fresh copy of ident text file from the cab, after verifying cab was
	// signed properly.
	//
	// this function reads data from ident and registry
	//
	HRESULT PopulateData(void);

	//
	// the following are access function to obtain URL's
	//

	//
	// get the original ident server. 
	// *** this API should be called before PopulateData() is called ***
	// *** this API should be called to retrieve the base URL where you download ident ***
	//
	HRESULT GetOriginalIdentServer(
				LPTSTR lpsBuffer, 
				int nBufferSize,
				BOOL* pfInternalServer = NULL);

	//
	// get the ping/status server
	// *** this API should be called after PopulateData() is called ***
	//
	HRESULT GetLivePingServer(
				LPTSTR lpsBuffer, 
				int nBufferSize);

	// *** this API can be called before PopulateData() is called ***
	HRESULT GetCorpPingServer(
				LPTSTR lpsBuffer, 
				int nBufferSize);

	//
	// get the query server. this is per client based
	// *** this API should be called after PopulateData() is called ***
	//
	HRESULT GetQueryServer(
				LPCTSTR lpsClientName, 
				LPTSTR lpsBuffer, 
				int nBufferSize,
				BOOL* pfInternalServer = NULL);
	
	//
	// tell if a particular client is controlled by policy in corporate
	// returns: 
	//			S_OK = TRUE
	//			S_FALSE = FALSE
	//			other = error, so don't know
	//
	HRESULT IsClientSpecifiedByPolicy(
				LPCTSTR lpsClientName
				);
	//
	// when client isn't available, is IU controlled by policy in corporate?
	// returns: 
	//			S_OK = TRUE
	//			S_FALSE = FALSE
	//			other = error, so don't know
	//
	HRESULT IsIdentFromPolicy();

private:

	typedef struct _ServerPerClient {
				LPTSTR	pszClientName;	
				LPTSTR	pszQueryServer;
				BOOL	fInternalServer;
	} ServerPerClient, *PServerPerClient;

	BOOL				m_fPopulated;			// whether this object has been populated
	LPTSTR				m_pszWUServer;			// WU server defined in policy, if any
	LPTSTR				m_pszInternetPingUrl;	// ping server
	LPTSTR				m_pszIntranetPingUrl;
	
	PServerPerClient	m_ArrayUrls;
	int					m_nArrayUrlCount;		// how many we data slot we used
	int					m_nArraySize;			// current size of this array

	//
	// private functions
	//
	void DesertData(void);

	//
	// helper function
	// 
	LPTSTR RetrieveIdentStrAlloc(
						LPCTSTR pSection,
						LPCTSTR pEntry,
						LPDWORD lpdwSizeAllocated,
						LPCTSTR lpszIdentFile);
	
	//
	// helper function
	// if there is no empty slot, double the size of url array
	//
	HRESULT ExpandArrayIfNeeded(void);

protected:
	
	HANDLE				m_hProcHeap;
	BOOL				m_fIdentFromPolicy;		// tell if original ident url based on policy setup
	LPTSTR				m_pszOrigIdentUrl;		// this one should always have it, no matter population
	int					m_nOrigIdentUrlBufSize;	// in tchar count
	BOOL				m_fIsBetaMode;
};


class CIUUrlAgent : public CUrlAgent
{
public:
	//
	// constructor/destructor
	//
	CIUUrlAgent();
	~CIUUrlAgent();

	// call base class PopulateData() and then populate self-update url
	HRESULT PopulateData(void);

	//
	// get the self-update server. 
	// *** this API should be called after PopulateData() is called ***
	//
	HRESULT GetSelfUpdateServer(
				LPTSTR lpsBuffer, 
				int nBufferSize,
				BOOL* pfInternalServer = NULL);

private:
	LPTSTR				m_pszSelfUpdateUrl;		// self-update server
	BOOL				m_fIUPopulated;			// whether this object has been populated

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\waitutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   WaitUtil.h
//
//  Description:
//
//      IU wait message utility library, providing thin wrapper of wait
//		message loop
//
//=======================================================================


#ifndef __WAITUTIL_H_INCLUDED__

#include <windows.h>


/////////////////////////////////////////////////////////////////////////////
// Helper function WaitAndPumpMessages()
/////////////////////////////////////////////////////////////////////////////
DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask);

/////////////////////////////////////////////////////////////////////////////
// Helper function MyMsgWaitForMultipleObjects()
// to process messages while waiting for an object
///////////////////////////////////////////////////////////////////////////////
DWORD MyMsgWaitForMultipleObjects(DWORD nCount, LPHANDLE pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);

#define __WAITUTIL_H_INCLUDED__
#endif // __WAITUTIL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\wubldnum.h ===
#define VER_PRODUCTBUILD_QFE /* WU */ 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\wubios.h ===
/*** wubios.h - WindowsUpdate BIOS Scanning VxD Public Definitions
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _WUBIOS_H
#define _WUBIOS_H

//Type definitions
/*XLATOFF*/
#include "acpitabl.h"
#include "smbios.h"
typedef struct _ACPITABINFO
{
    DWORD dwTabSig;
    DWORD dwPhyAddr;
    DESCRIPTION_HEADER dh;
} ACPITABINFO, *PACPITABINFO;
/*XLATON*/

/*** Constants
 */

//W32 Device IO Control Code
#define WUBIOCTL_GET_VERSION			1
#define WUBIOCTL_GET_ACPI_TABINFO		2
#define WUBIOCTL_GET_ACPI_TABLE			3
#define WUBIOCTL_GET_SMB_STRUCTSIZE		4
#define WUBIOCTL_GET_SMB_STRUCT			5
#define WUBIOCTL_GET_PNP_OEMID			6

//Miscellaneous Constants
#define WUBIOS_MAJOR_VER		0x01
#define WUBIOS_MINOR_VER		0x00

#define WUBIOS_VERSION			((WUBIOS_MAJOR_VER << 8) | WUBIOS_MINOR_VER)


#endif  //ifndef _ACPITAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\wuverp.h ===
//
// The purpose of this include file is to change the minor version number for
// Windows Update components from 1 (Whistler) to 4.
//
#include <windows.h>
#include <ntverp.h>

// Override ntverp.h
// Minor version 4 is Windows Update specific, Whistler is minor version 1.
#undef VER_PRODUCTMINORVERSION
#define VER_PRODUCTMINORVERSION     4

#undef VER_PRODUCTVERSION_STRING   
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#undef VER_PRODUCTVERSION          
#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define WU_VER_FILEDESCRIPTION_STR(component) "Windows Update " component
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\wuiutest.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   wuiutest.h
//
//  Description:
//
//      Defines used for test builds.
//
//		NOTE:	To add test features to a build define the following
//				in your build environment before building (can be any
//				combination of chk, fre, ANSI, or Unicode):
//
//				set USER_C_FLAGS=$(USER_C_FLAGS) /D__WUIUTEST=1
//
//=======================================================================

#ifndef __IU_WUIUTEST_INC__
#define __IU_WUIUTEST_INC__

#ifdef __WUIUTEST

#include <tchar.h>
//
// Reg key containing values used by builds compiled with __WUIUTEST defined
//
const TCHAR REGKEY_WUIUTEST[]				= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuiutest");
//
// Allow CDM to download drivers even if DriverVer is equal (but not less-than) installed driver
//
const TCHAR REGVAL_ALLOW_EQUAL_DRIVERVER[]	= _T("AllowEqualDriverVer");
//
// Override OS or USER LANGID
//
const TCHAR REGVAL_OS_LANGID[]				= _T("OsLangID");
const TCHAR REGVAL_USER_LANGID[]			= _T("UserLangID");
//
// Override DetectClientIUPlatform OSVERSIONINFO params
//
const TCHAR REGVAL_MAJORVER[]				= _T("OsVerMajorVersion");
const TCHAR REGVAL_MINORVER[]				= _T("OsVerMinorVersion");
const TCHAR REGVAL_BLDNUMBER[]				= _T("OsVerBuildNumber");
const TCHAR REGVAL_PLATFORMID[]				= _T("OsVerPlatformID");
const TCHAR REGVAL_SZCSDVER[]				= _T("OsVerSzCSDVersion");
//
// Override DEFAULT_EXPIRED_SECONDS time for deleting downloaded folders
//
const TCHAR REGVAL_DEFAULT_EXPIRED_SECONDS[]	=_T("DownloadExpireSeconds");

#endif //__WUIUTEST

#endif	// __IU_WUIUTEST_INC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\wusafefn.h ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    wusafefn.h

Abstract:
    definitions for WU safe functions

******************************************************************************/

#pragma once

#include "SafeFile.h"  // file operations (SafeCreateFile, etc.)
#include "SafeReg.h"   // registry operations (SafeRegQueryStringValueCch, etc.)

// path manipulation
HRESULT PathCchCombineA(LPSTR  szPath, DWORD cchPathBuff, LPCSTR  szPrefix, LPCSTR  szSuffix);
HRESULT PathCchCombineW(LPWSTR szPath, DWORD cchPathBuff, LPCWSTR szPrefix, LPCWSTR szSuffix);
HRESULT PathCchAppendA(LPSTR  szPath, DWORD cchPathBuff, LPCSTR  szNew);
HRESULT PathCchAppendW(LPWSTR szPath, DWORD cchPathBuff, LPCWSTR szNew);
HRESULT PathCchAddBackslashA(LPSTR  szPath, DWORD cchPathBuff);
HRESULT PathCchAddBackslashW(LPWSTR szPath, DWORD cchPathBuff);
HRESULT PathCchCanonicalizeA(LPSTR  pszDest, DWORD cchDest, LPCSTR  pszSrc);
HRESULT PathCchCanonicalizeW(LPWSTR pszDest, DWORD cchDest, LPCWSTR pszSrc);
HRESULT PathCchAddExtensionA(LPSTR  pszPath, DWORD cchPath, LPCSTR  pszExt);
HRESULT PathCchAddExtensionW(LPWSTR pszPath, DWORD cchPath, LPCWSTR pszExt);
HRESULT PathCchRenameExtensionA(LPSTR  pszPath, DWORD cchPath, LPCSTR  pszExt);
HRESULT PathCchRenameExtensionW(LPWSTR pszPath, DWORD cchPath, LPCWSTR pszExt);

#if defined(UNICODE) || defined(_UNICODE)
#define PathCchCombine PathCchCombineW
#define PathCchAppend PathCchAppendW
#define PathCchAddBackslash PathCchAddBackslashW
#define PathCchCanonicalize PathCchCanonicalizeW
#define PathCchAddExtension PathCchAddExtensionW
#define PathCchRenameExtension PathCchRenameExtensionW
#else
#define PathCchCombine PathCchCombineA
#define PathCchAppend  PathCchAppendA
#define PathCchAddBackslash PathCchAddBackslashA
#define PathCchCanonicalize PathCchCanonicalizeA
#define PathCchAddExtension PathCchAddExtensionA
#define PathCchRenameExtension PathCchRenameExtensionA
#endif


// Load library
HMODULE WINAPI LoadLibraryFromSystemDir(LPCTSTR szModule);


// Critical sections

// Spin count passed to InitializeCriticalSectionAndSpinCount
#define DEFAULT_CS_SPIN_COUNT 0x80000FA0

BOOL WINAPI WUInitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpcs, DWORD dwSpinCount);

inline BOOL WINAPI SafeInitializeCriticalSection(LPCRITICAL_SECTION lpcs)
{
	return WUInitializeCriticalSectionAndSpinCount(lpcs, DEFAULT_CS_SPIN_COUNT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\inc\wutestkeys.h ===
#pragma once
#include "timeutil.h"
/***********************************************************************************************************
// This API returns true if a WU Test authorization file exists.
// The api looks for the input file name (lpszFileName) in the WindowsUpdate directory
// The test file has to have the same name as the cab file and should end with the '.txt' extension.
// Moreover it has to be an ascii file. The cab file has to be signed with a valid MS cert.
// This function will delete the extracted text file
************************************************************************************************************/
BOOL WUAllowTestKeys(LPCTSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\detection.cpp ===
// Detection.cpp : Implementation of CDetection
#include "stdafx.h"
#include "IUCtl.h"
#include "Detection.h"

/////////////////////////////////////////////////////////////////////////////
// CDetection


STDMETHODIMP CDetection::Detect(BSTR bstrXML, DWORD *pdwDetectionResult)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\evtmsgwnd.cpp ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//	File: EvtMsgWnd.cpp: implementation of the CEventMsgWindow class.
//
//	Created by: Charles Ma
//				6/18/1999
//
//=======================================================================
#include "stdafx.h"
#include "EvtMsgWnd.h"
#include "Update.h"
#include <logging.h>
#include <atlwin.cpp>


/////////////////////////////////////////////////////////////////////////////
// CEventMsgWindow

/////////////////////////////////////////////////////////////////////////////
// override method
//
// we need to create a popup window - a control can not create
// a top-level child window
//
/////////////////////////////////////////////////////////////////////////////
void CEventMsgWindow::Create()
{
	if (NULL == m_pControl)
		return;

	//
	// make the window size 1 pixel 
	//
	RECT rcPos;
	rcPos.left = 0;
	rcPos.top = 0;
	rcPos.bottom = 1;
	rcPos.right = 1;

	//
	// call base class method, with WS_POPUP style
	//
	m_hWnd = CWindowImpl<CEventMsgWindow>::Create(NULL, rcPos, _T("EventWindow"), WS_POPUP);
}


/////////////////////////////////////////////////////////////////////////////
// destroy the window
/////////////////////////////////////////////////////////////////////////////
void CEventMsgWindow::Destroy()
{
	if (NULL != m_hWnd)
	{
		m_hWnd = NULL;
		CWindowImpl<CEventMsgWindow>::DestroyWindow();
	}
}


/////////////////////////////////////////////////////////////////////////////
// message handlers
/////////////////////////////////////////////////////////////////////////////
LRESULT CEventMsgWindow::OnFireEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
#if defined(DBG)
	USES_CONVERSION;
	LOG_Block("OnFireEvent()");
	LOG_Out(_T("Msg=%d"), uMsg);
#endif
	
	//
	// if control is not passed in, we can not fire the event. return E_FAIL
	//
	pEventData pEvtData = NULL;

	if (NULL == m_pControl)
	{
		return E_FAIL;
	}

	switch (uMsg)
	{
	case UM_EVENT_ITEMSTART:
		//
		// this item is about to get downloaded
		//
		pEvtData = (pEventData)lParam;
		if (pEvtData)
		{
			//
			// about to start an item download/install
			//
	#if defined(DBG)
			LOG_Out(_T("About to fire event OnItemStart(%s, <item>, %ld)"),
						OLE2T(pEvtData->bstrUuidOperation),
						pEvtData->lCommandRequest);
			LOG_XmlBSTR(pEvtData->bstrXmlData);
	#endif
			m_pControl->Fire_OnItemStart(pEvtData->bstrUuidOperation, 
										 pEvtData->bstrXmlData,		// this is actually BSTR of an item
										 &pEvtData->lCommandRequest);

	        if (pEvtData->hevDoneWithMessage != NULL)
	            SetEvent(pEvtData->hevDoneWithMessage);
		}
		break;

	case UM_EVENT_PROGRESS:
		//
		// dopwnlaod or install progress
		//
		pEvtData = (pEventData)lParam;
#if defined(DBG)
		LOG_Out(_T("About to fire event OnProgress(%s, %d, %s, %ld)"),
					OLE2T(pEvtData->bstrUuidOperation),
					pEvtData->fItemCompleted,
					OLE2T(pEvtData->bstrProgress),
					pEvtData->lCommandRequest);
#endif
		if (pEvtData)
		{
			m_pControl->Fire_OnProgress(pEvtData->bstrUuidOperation,
										pEvtData->fItemCompleted,
										pEvtData->bstrProgress,
										&pEvtData->lCommandRequest);

	        if (pEvtData->hevDoneWithMessage != NULL)
	            SetEvent(pEvtData->hevDoneWithMessage);
		}
		break;
	case UM_EVENT_COMPLETE:
		//
		// download or install operation complete
		//
		pEvtData = (pEventData)lParam;
#if defined(DBG)
		LOG_Out(_T("About to fire event OnOperationComplete(%s, result)"),
					OLE2T(pEvtData->bstrUuidOperation));
		LOG_XmlBSTR(pEvtData->bstrXmlData);
#endif
		if (pEvtData)
		{
			m_pControl->Fire_OnOperationComplete(pEvtData->bstrUuidOperation, pEvtData->bstrXmlData);
 	        if (pEvtData->hevDoneWithMessage != NULL)
	            SetEvent(pEvtData->hevDoneWithMessage);
		}
		break;
	case UM_EVENT_SELFUPDATE_COMPLETE:
		//
		// the lParam should be the error code
		//
#if defined(DBG)
		LOG_Out(_T("About to fire event OnSelfUpdateComplete(%ld)"), (LONG)lParam);
#endif
		m_pControl->Fire_OnSelfUpdateComplete((LONG)lParam);
		break;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\detection.h ===
//==========================================================================
//
// Copyright (c) 1998-2000 Microsoft Corporation. 
// All Rights Reserved.
//
// File: Detection.h : 
//		 Declaration of the CDetection class
//		 CDetection declares COM interface IDetection
//
// IDetection is a class defined here without any implementation.
// It defines the template that the content provider should
// implement if they want to provide detection features beyong
// the current detection mechanism defined in the catalog schema.
//
//==========================================================================

#ifndef __DETECTION_H_
#define __DETECTION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDetection
class ATL_NO_VTABLE CDetection : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDetection, &CLSID_Detection>,
	public IDispatchImpl<IDetection, &IID_IDetection, &LIBID_IUCTLLib>
{
public:
	CDetection()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DETECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDetection)
	COM_INTERFACE_ENTRY(IDetection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDetection
public:

	STDMETHOD(Detect)(
			/*[in]*/ BSTR bstrXML,				/* detection portion of manifest where
												 * the COM server is called */
			/*[out]*/ DWORD *pdwDetectionResult /* the result of detection, see below
												 * for interpretations */
	);

	/**

	//
	// deckare the constants used to manipulate the result of Detect() method
	//

	//
	// First group, used in <expression> tag, to tell the detection result. This result
	// should combined with other expression(s) at the same level
	//
	const DWORD     IUDET_BOOL              = 0x00000001;	// mask 
	const DWORD     IUDET_FALSE             = 0x00000000;	// expression detect FALSE 
	const DWORD     IUDET_TRUE              = 0x00000001;	// expression detect TRUE 
	const DWORD     IUDET_NULL              = 0x00000002;	// expression detect data missing

	//
	// Second group, used in <detection> tag, to tell the detection result. This result
	// should overwrite the rest of <expression>, if any
	//
	const DWORD     IUDET_INSTALLED			= 0x00000010;	// mask for <installed> result
	const DWORD     IUDET_INSTALLED_NULL	= 0x00000020;	// <installed> missing 
	const DWORD     IUDET_UPTODATE			= 0x00000040;	// mask for <upToDate> result 
	const DWORD     IUDET_UPTODATE_NULL		= 0x00000080;	// <upToDate> missing 
	const DWORD     IUDET_NEWERVERSION		= 0x00000100;	// mask for <newerVersion> result 
	const DWORD     IUDET_NEWERVERSION_NULL	= 0x00000200;	// <newerVersion> missing
	const DWORD     IUDET_EXCLUDED			= 0x00000400;	// mask for <excluded> result
	const DWORD     IUDET_EXCLUDED_NULL		= 0x00000800;	// <excluded> missing
	const DWORD     IUDET_FORCE				= 0x00001000;	// mask for <force> result 
	const DWORD     IUDET_FORCE_NULL		= 0x00002000;	// <force> missing
	const DWORD		IUDET_COMPUTER			= 0x00004000;	// mask for <computerSystem> result
	const DWORD		IUDET_COMPUTER_NULL		= 0x00008000;	// <computerSystem> missing

	**/
};

#endif //__DETECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\evtmsgwnd.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//	File: EvtMsgWnd.h: interface for the CEventMsgWindow class.
//
//	Description:
//		This window class is used to handle all event firing
//		messages posted during downloading/installation.
//
//		all custom message IDs are defined in this file too,
//		as well as the structure to pass event data
//		
//	Created by: Charles Ma
//				6/18/1999
//
//=======================================================================

#ifndef __EVTMSGWND_H_
#define __EVTMSGWND_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <shellapi.h>
#include <atlwin.h>
#include <iu.h>

/////////////////////////////////////////////////////////////////////////////
// class forward declaration
/////////////////////////////////////////////////////////////////////////////
class CUpdate;



/////////////////////////////////////////////////////////////////////////////
// CEventMsgWindow
class CEventMsgWindow :	public CWindowImpl<CEventMsgWindow>
{
public:

	/////////////////////////////////////////////////////////////////////////////
	// Construction/Destruction
	/////////////////////////////////////////////////////////////////////////////
	CEventMsgWindow(CUpdate* pControl) : m_pControl(pControl), m_hWnd(NULL)
	{
	}

	virtual ~CEventMsgWindow()
	{
	};

	/////////////////////////////////////////////////////////////////////////////
	// override method
	//
	// we need to create a popup window - a control can not create
	// a top-level child window
	//
	/////////////////////////////////////////////////////////////////////////////
	void Create();

	/////////////////////////////////////////////////////////////////////////////
	// destroy the window
	/////////////////////////////////////////////////////////////////////////////
	void Destroy();

	/////////////////////////////////////////////////////////////////////////////
	// get evt window handler
	/////////////////////////////////////////////////////////////////////////////
	HWND GetEvtHWnd() { return m_hWnd; };

	/////////////////////////////////////////////////////////////////////////////
	// message maps define all messages we handled in this class
	/////////////////////////////////////////////////////////////////////////////
	BEGIN_MSG_MAP(CEventMsgWindow)
		MESSAGE_HANDLER(UM_EVENT_ITEMSTART,				OnFireEvent)
		MESSAGE_HANDLER(UM_EVENT_PROGRESS,				OnFireEvent)
		MESSAGE_HANDLER(UM_EVENT_COMPLETE,				OnFireEvent)
		MESSAGE_HANDLER(UM_EVENT_SELFUPDATE_COMPLETE,	OnFireEvent)
	END_MSG_MAP()

	/////////////////////////////////////////////////////////////////////////////
	// message handlers
	/////////////////////////////////////////////////////////////////////////////
	LRESULT OnFireEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
	//
	// disable the default constructor
	//
	CEventMsgWindow() {};

	HWND		m_hWnd;
	CUpdate*	m_pControl;
};

#endif //__EVTMSGWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\iuctl.cpp ===
// IUCtl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f IUCtlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "IUCtl.h"

#include "IUCtl_i.c"
#include "Update.h"
#include "ProgressListener.h"
#include "Detection.h"
#include "UpdateCompleteListener.h"
#include <UrlAgent.h>
#include <FreeLog.h>
#include <wusafefn.h>

CComModule _Module;

HANDLE g_hEngineLoadQuit;

CIUUrlAgent *g_pIUUrlAgent;
CRITICAL_SECTION g_csUrlAgent;	// used to serialize access to CIUUrlAgent::Populate()
BOOL g_fInitCS;


//extern "C" const CLSID CLSID_Update2 = {0x32BF9AC1,0xB122,0x4fed,{0xB3,0xC7,0x2D,0xA5,0x20,0xDF,0x2B,0x4E}};

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Update, CUpdate)
//OBJECT_ENTRY(CLSID_Update2, CUpdate)
OBJECT_ENTRY(CLSID_ProgressListener, CProgressListener)
OBJECT_ENTRY(CLSID_Detection, CDetection)
OBJECT_ENTRY(CLSID_UpdateCompleteListener, CUpdateCompleteListener)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		//
		// create a global CIUUrlAgent object
		//
		g_pIUUrlAgent = new CIUUrlAgent;
		if (NULL == g_pIUUrlAgent)
		{
			return FALSE;
		}

		_Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

		g_fInitCS = SafeInitializeCriticalSection(&g_csUrlAgent);

		//
		// Initialize free logging
		//
		InitFreeLogging(_T("IUCTL"));
		LogMessage("Starting");

        g_hEngineLoadQuit = CreateEvent(NULL, TRUE, FALSE, NULL);

		if (!g_fInitCS || NULL == g_hEngineLoadQuit)
		{
			LogError(E_FAIL, "InitializeCriticalSection or CreateEvent");
			return FALSE;
		}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		if (g_fInitCS)
		{
			DeleteCriticalSection(&g_csUrlAgent);
		}
		
		//
		// Shutdown free logging
		//
		LogMessage("Shutting down");
		TermFreeLogging();

        if (NULL != g_hEngineLoadQuit)
        {
            CloseHandle(g_hEngineLoadQuit);
        }

		if (NULL != g_pIUUrlAgent)
		{
			delete g_pIUUrlAgent;
		}

        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(&CLSID_Update);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\iuctlcp.h ===
#ifndef _IUCTLCP_H_
#define _IUCTLCP_H_

#include <assert.h>
#define QuitIfNull(ptr)			if (NULL == ptr) return	// TO DO: add logging if quit

template <class T>
class CProxyIUpdateEvents : public IConnectionPointImpl<T, &DIID_IUpdateEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:

	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnItemStart()
	//
	// fire event to notify that this item is about to be downloaded.
	// and (in VB) plCommandRequest can be set to pause or cancel the
	// whole download/install operation
	//
	// Input:
    // bstrUuidOperation - the operation identification guid
    // bstrXmlItem - item XML node in BSTR 
	// Output:
    // plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnItemStart(BSTR			bstrUuidOperation,
						 BSTR			bstrXmlItem,
						 LONG*			plCommandRequest)
	{
		VARIANTARG* pvars = new VARIANTARG[3];
		QuitIfNull(pvars);

		for (int i = 0; i < 3; i++)
		{
			VariantInit(&pvars[i]);
		}

		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[2].vt = VT_BSTR;
				pvars[2].bstrVal = bstrUuidOperation;
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal = bstrXmlItem;
				pvars[0].vt = VT_I4 | VT_BYREF;
				pvars[0].byref = plCommandRequest;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}



	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnProgress()
	//
    // Notify the listener that a portion of the files has finished operation
	// (e.g downloaded or installed). Enables monitoring of progress.
	// Input:
    // bstrUuidOperation - the operation identification guid
    // fItemCompleted - TRUE if the current item has completed the operation
    // nPercentComplete - total percentage of operation completed
	// Output:
    // plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnProgress(BSTR			bstrUuidOperation,
						 VARIANT_BOOL	fItemCompleted,
						 BSTR			bstrProgress,
						 LONG*			plCommandRequest)
	{
		VARIANTARG* pvars = new VARIANTARG[4];
		QuitIfNull(pvars);

		for (int i = 0; i < 4; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[3].vt = VT_BSTR;
				pvars[3].bstrVal = bstrUuidOperation;
				pvars[2].vt = VT_BOOL;
				pvars[2].boolVal = fItemCompleted;
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal = bstrProgress;
				pvars[0].vt = VT_I4 | VT_BYREF;
				pvars[0].byref = plCommandRequest;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	
	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnOperationComplete()
	//
	// Notify the listener when the operation is complete.
	// Input:
	// bstrUuidOperation - the operation identification guid
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnOperationComplete(BSTR	bstrUuidOperation, BSTR bstrXmlItems)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		QuitIfNull(pvars);

		VariantInit(&pvars[0]);
		VariantInit(&pvars[1]);

		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal = bstrUuidOperation;
				pvars[0].vt = VT_BSTR;
				pvars[0].bstrVal = bstrXmlItems;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnSelfUpdateComplete()
	//
	// Notify the listener when the operation is complete.
	// Input:
	// bstrUuidOperation - the operation identification guid
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnSelfUpdateComplete(LONG lErrorCode)
	{
		VARIANTARG var;

		VariantInit(&var);

		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				var.vt = VT_I4;
				var.lVal = lErrorCode;
				DISPPARAMS disp = { &var, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
	}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\progresslistener.cpp ===
// ProgressListener.cpp : Implementation of CProgressListener
#include "stdafx.h"
#include "IUCtl.h"
#include "ProgressListener.h"

/////////////////////////////////////////////////////////////////////////////
// CProgressListener


/////////////////////////////////////////////////////////////////////////////
// OnItemStart()
//
// fire event to notify that this item is about to be downloaded.
// and (in VB) plCommandRequest can be set to pause or cancel the
// whole download/install operation
//
// Input:
// bstrUuidOperation - the operation identification guid
// bstrXmlItem - item XML node in BSTR 
// Output:
// plCommandRequest - a command to pass from the listener to the owner of the event,
//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProgressListener::OnItemStart(BSTR			bstrUuidOperation,
										   BSTR				bstrXmlItem,
										   LONG*			plCommandRequest)
{
	// TODO: Add your implementation code here

    return E_NOTIMPL;
}




/////////////////////////////////////////////////////////////////////////////
// OnProgress()
//
// Notify the listener that a portion of the files has finished operation
// (e.g downloaded or installed). Enables monitoring of progress.
// Input:
// bstrUuidOperation - the operation identification guid
// fItemCompleted - TRUE if the current item has completed the operation
// nPercentComplete - total percentage of operation completed
// Output:
// plCommandRequest - a command to pass from the listener to the owner of the event,
//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProgressListener::OnProgress(BSTR				bstrUuidOperation,
										   VARIANT_BOOL		fItemCompleted,
										   BSTR				bstrProgress,
										   LONG*			plCommandRequest)
{
	// TODO: Add your implementation code here

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// OnOperationComplete()
//
// Notify the listener when the operation is complete.
// Input:
// bstrUuidOperation - the operation identification guid
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProgressListener::OnOperationComplete(BSTR bstrUuidOperation, BSTR bstrXmlItems)
{
	// TODO: Add your implementation code here

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\iudl.h ===
#ifndef IUDL_H
#define IUDL_H

#include <dllite.h>

HRESULT IUDownloadFile(LPCTSTR pszDownloadUrl, 
                       LPCTSTR pszLocalFile,  
                       BOOL fDecompress, 
                       BOOL fCheckTrust, 
                       DWORD dwFlags = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\progresslistener.h ===
// ProgressListener.h : Declaration of the CProgressListener

#ifndef __PROGRESSLISTENER_H_
#define __PROGRESSLISTENER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CProgressListener
class ATL_NO_VTABLE CProgressListener : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CProgressListener, &CLSID_ProgressListener>,
	public IProgressListener
{
public:
	CProgressListener()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROGRESSLISTENER)
DECLARE_NOT_AGGREGATABLE(CProgressListener)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProgressListener)
	COM_INTERFACE_ENTRY(IProgressListener)
END_COM_MAP()

// IProgressListener
public:

	/////////////////////////////////////////////////////////////////////////////
	// OnItemStart()
	//
	// fire event to notify that this item is about to be downloaded.
	// and (in VB) plCommandRequest can be set to pause or cancel the
	// whole download/install operation
	//
	// Input:
	// bstrUuidOperation - the operation identification guid
	// bstrXmlItem - item XML node in BSTR 
	// Output:
	// plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	//
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(OnItemStart)(BSTR	bstrUuidOperation,
						   BSTR	bstrXmlItem,
						   LONG* plCommandRequest);
		
	
	/////////////////////////////////////////////////////////////////////////////
	// OnProgress()
	//
    // Notify the listener that a portion of the files has finished operation
	// (e.g downloaded or installed). Enables monitoring of progress.
	// Input:
    // bstrUuidOperation - the operation identification guid
    // fItemCompleted - TRUE if the current item has completed the operation
    // nPercentComplete - total percentage of operation completed
	// Output:
    // plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(OnProgress)(BSTR			bstrUuidOperation,
						  VARIANT_BOOL	fItemCompleted,
						  BSTR			bstraProgress,
						  LONG*			plCommandRequest);

	/////////////////////////////////////////////////////////////////////////////
	// OnOperationComplete()
	//
	// Notify the listener when the operation is complete.
	// Input:
	// bstrUuidOperation - the operation identification guid
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(OnOperationComplete)(BSTR	bstrUuidOperation, BSTR bstrXmlItems);
};

#endif //__PROGRESSLISTENER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\loadengine.cpp ===
#include "stdafx.h"
#include "iudl.h"
#include "selfupd.h"
#include "loadengine.h"
#include "update.h"
#include <iucommon.h>
#include <logging.h>
#include <shlwapi.h>
#include <fileutil.h>
#include <iu.h>
#include <trust.h>
#include <UrlAgent.h>
#include "wusafefn.h"

extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;


/////////////////////////////////////////////////////////////////////////////
// LoadIUEngine()
//
// load the engine if it's not up-to-date; perform engine's self-update here
//
// NOTE: CDM.DLL assumes LoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
/////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI LoadIUEngine(BOOL fSynch,  BOOL fOfflineMode)
{
    LOG_Block("LoadIUEngine()");
    HRESULT hr = E_FAIL;
	HMODULE hEngineModule = NULL;

	TCHAR szEnginePath[MAX_PATH + 1];
	TCHAR szEngineNewPath[MAX_PATH + 1];
	int cch = 0;
	int iVerCheck = 0;

	if (!fSynch)
	{
		//
		// this version does not accept async load engine
		//
		LOG_ErrorMsg(E_INVALIDARG);
		return NULL;
	}

	LPTSTR ptszLivePingServerUrl = NULL;
	LPTSTR ptszCorpPingServerUrl = NULL;

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED(g_pIUUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
			SafeHeapFree(ptszCorpPingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}

    // clear the quit event in case this gets called after a previous quit attempt.
    ResetEvent(g_hEngineLoadQuit);

    // This is the first load of the engine for this instance, check for selfupdate first.
    // First step is to check for an updated iuident.cab and download it.

	if (!fOfflineMode)
	{		
		//
		// download iuident and populate g_pIUUrlAgent
		//
		CleanUpIfFailedAndMsg(DownloadIUIdent_PopulateData());

		//
		// get live ping server url
		//
		ptszLivePingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		CleanUpFailedAllocSetHrMsg(ptszLivePingServerUrl);

		if (FAILED(g_pIUUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get live ping server URL"));
			SafeHeapFree(ptszLivePingServerUrl);
		}

		//
		// Now do the self update check
		// for the current implementation, fSync must be TRUE!
		//
		hr = SelfUpdateCheck(fSynch, TRUE, NULL, NULL, NULL);

		if (IU_SELFUPDATE_FAILED == hr)
		{
			LOG_Error(_T("SelfUpdate Failed, using current Engine DLL"));
		}
	}

    if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
    {
        LOG_ErrorMsg(E_ABORT);
        goto CleanUp;
    }

    // try loading iuenginenew.dll first

	//
	// first, contrsuct file path form sys dir
	//
	cch = GetSystemDirectory(szEnginePath, ARRAYSIZE(szEnginePath));
    CleanUpIfFalseAndSetHrMsg(cch == 0 || cch >= ARRAYSIZE(szEnginePath), HRESULT_FROM_WIN32(GetLastError()));

	(void) StringCchCopy(szEngineNewPath, ARRAYSIZE(szEngineNewPath), szEnginePath);

	hr = PathCchAppend(szEnginePath, ARRAYSIZE(szEnginePath), ENGINEDLL);
	CleanUpIfFailedAndMsg(hr);

	hr = PathCchAppend(szEngineNewPath, ARRAYSIZE(szEngineNewPath), ENGINENEWDLL);
	CleanUpIfFailedAndMsg(hr);

	//
	// try to verify trust of engine new
	//
	if (FileExists(szEngineNewPath) && 
		S_OK == VerifyFileTrust(szEngineNewPath, NULL, ReadWUPolicyShowTrustUI()) &&
		SUCCEEDED(CompareFileVersion(szEnginePath, szEngineNewPath, &iVerCheck)) &&
		iVerCheck < 0)
	{
		hEngineModule = LoadLibraryFromSystemDir(ENGINENEWDLL);
		if (NULL != hEngineModule)
		{
			LOG_Internet(_T("IUCtl Using IUENGINENEW.DLL"));
		}
	}
    if (NULL == hEngineModule)
    {
        LOG_Internet(_T("IUCtl Using IUENGINE.DLL"));
        hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));
    }
	//
	// If load engine succeeded, start misc worker threads
	//
	if (NULL != hEngineModule)
	{
		PFN_AsyncExtraWorkUponEngineLoad pfnAsyncExtraWorkUponEngineLoad = 
			(PFN_AsyncExtraWorkUponEngineLoad) GetProcAddress(hEngineModule, "AsyncExtraWorkUponEngineLoad");

		if (NULL != pfnAsyncExtraWorkUponEngineLoad)
		{
			pfnAsyncExtraWorkUponEngineLoad();
		}
		hr = S_OK;
	}

CleanUp:
	PingEngineUpdate(
					hEngineModule,
					&g_hEngineLoadQuit,
					1,
					ptszLivePingServerUrl,
					ptszCorpPingServerUrl,
					hr);

	SafeHeapFree(ptszLivePingServerUrl);
	SafeHeapFree(ptszCorpPingServerUrl);
    return hEngineModule;
}


/////////////////////////////////////////////////////////////////////////////
// UnLoadIUEngine()
//
// release the engine dll if ref cnt of engine is down to zero
//
// NOTE: CDM.DLL assumes UnLoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
//
// NOTE: DeleteEngUpdateInstance must be called before calling this function
//       for any callers EXCEPT CDM (which uses the ShutdownThreads export as
//       a hack to delete the global CDM instance of the CEngUpdate class
//       if it was created by calling SetGlobalOfflineFlag.
/////////////////////////////////////////////////////////////////////////////
void WINAPI UnLoadIUEngine(HMODULE hEngineModule)
{
    LOG_Block("UnLoadIUEngine()");
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szEngineDllPath[MAX_PATH+1];
    TCHAR szEngineNewDllPath[MAX_PATH+1];
	int iVerCheck = 0;

	//
	// the engine might have some outstanding threads working, 
	// so we need to let the engine shut down these threads gracefully
	//
	PFN_ShutdownThreads pfnShutdownThreads = (PFN_ShutdownThreads) GetProcAddress(hEngineModule, "ShutdownThreads");
	if (NULL != pfnShutdownThreads)
	{
		pfnShutdownThreads();
	}


    FreeLibrary(hEngineModule);

	GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));

	
    PathCchCombine(szEngineNewDllPath,ARRAYSIZE(szEngineNewDllPath), szSystemDir, ENGINENEWDLL);
	


    HKEY hkey = NULL;
    DWORD dwStatus = 0;
    DWORD dwSize = sizeof(dwStatus);
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkey))
    {
        RegQueryValueEx(hkey, REGVAL_SELFUPDATESTATUS, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
    }
    if (FileExists(szEngineNewDllPath) && 
		S_OK == VerifyFileTrust(szEngineNewDllPath, NULL, ReadWUPolicyShowTrustUI()) &&
		SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
    {
        // an iuenginenew.dll exists, try replacing the engine.dll This will fail if this is
        // not the last process using the engine. This is not a problem, when that process
        // finishes it will rename the DLL.
		//
		// the check we do before we rename the file:
		//	1. enginenew exists
		//	2. enginenew signed by Microsoft cert
		//	3. enginenew has higher version then iuengine.dll
		//
        PathCchCombine(szEngineDllPath,ARRAYSIZE(szEngineDllPath),szSystemDir, ENGINEDLL);

        if (SUCCEEDED(CompareFileVersion(szEngineDllPath, szEngineNewDllPath, &iVerCheck)) &&
			iVerCheck < 0 &&
			TRUE == MoveFileEx(szEngineNewDllPath, szEngineDllPath, MOVEFILE_REPLACE_EXISTING))
        {
            // Rename was Successful.. reset RegKey Information about SelfUpdate Status
            // Because the rename was successful we know no other processes are interacting
            // It should be safe to set the reg key.
            dwStatus = 0;
            RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
        }
    }
    else if (SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
    {
		// registry indicates rename required, but enginenew DLL does not exist. Reset registry
		dwStatus = 0;
		RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CtlCancelEngineLoad()
//
// Asynchronous Callers can use this abort the LoadEngine SelfUpdate Process
//
// NOTE: CDM.DLL assumes UnLoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CtlCancelEngineLoad()
{
    if (NULL != g_hEngineLoadQuit)
    {
        SetEvent(g_hEngineLoadQuit);
    }
    else
    {
        // no event was available
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\iudl.cpp ===
#include "stdafx.h"
#include <iucommon.h>
#include <trust.h>
#include <logging.h>
#include <fileutil.h>
#include "iudl.h"
#include <download.h>
#include <UrlAgent.h>

extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;

HRESULT IUDownloadFile(LPCTSTR pszDownloadUrl, 
                       LPCTSTR pszLocalFile,  
                       BOOL fDecompress, 
                       BOOL fCheckTrust, 
                       DWORD dwFlags)
{
    LOG_Block("IUDownloadFile()");

    HRESULT hr = S_OK;

	if (FAILED(hr = g_pIUUrlAgent->IsIdentFromPolicy()))
	{
		goto done;
	}

	if (S_FALSE == hr)
	{
		hr = S_OK;
	}
	else // S_OK
	{
		dwFlags |= WUDF_DONTALLOWPROXY;
		LOG_Internet(_T("WUDF_DONTALLOWPROXY set"));
	}

    // do the download
    hr = DownloadFileLite(pszDownloadUrl, pszLocalFile, g_hEngineLoadQuit, dwFlags);
    if (FAILED(hr))
        goto done;

	// check for decompress requested
	if (fCheckTrust)
	{
		if (FAILED(hr = VerifyFileTrust(pszLocalFile, NULL, ReadWUPolicyShowTrustUI())))
		{
            LOG_ErrorMsg(hr);
            
            // The file was not trusted.. delete it.
            DeleteFile(pszLocalFile);
            goto done;
		}
	}

	if (fDecompress)
	{
		TCHAR *pszLocalDir = NULL;
        DWORD cchNeed = _tcslen(pszLocalFile) + 1;

        __try { pszLocalDir = (LPTSTR)_alloca(cchNeed * sizeof(TCHAR)); }
        __except(EXCEPTION_EXECUTE_HANDLER) { pszLocalDir = NULL; }
        if (pszLocalDir == NULL)
        {
            LOG_ErrorMsg(ERROR_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto done;
        }
		
		hr=StringCchCopyEx(pszLocalDir,cchNeed,pszLocalFile,NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
		    LOG_ErrorMsg(hr);
			goto done;
		}

		PathRemoveFileSpec(pszLocalDir);
        IUExtractFiles(pszLocalFile, pszLocalDir);
	}

done:
    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IUCtl.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPDATE                      101
#define IDR_UPDATE2                     102
#define IDR_PROGRESSLISTENER            103
#define IDR_UPDATECOMPLETELISTENER		104
#define IDR_DETECTION                   105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\selfupd.cpp ===
#include "stdafx.h"
#include "iudl.h"
#include "selfupd.h"
#include <iucommon.h>
#include <osdet.h>
#include <logging.h>
#include <shlwapi.h>
#include <fileutil.h>
#include <iu.h>
#include "update.h"
#include <WaitUtil.h>
#include <UrlAgent.h>
#include <RedirectUtil.h>
#include "wusafefn.h"

inline DWORD StartSelfUpdateProcess(HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener);
DWORD WINAPI MonitorUpdateCompleteProc(LPVOID lpv);

const TCHAR IDENTCAB[] = _T("iuident.cab");
const CHAR SZ_SELF_UPDATE_CHECK[] = "Checking to see if new version of Windows Update software available";
extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;
extern CRITICAL_SECTION g_csUrlAgent;

typedef struct _MONITOR_DATA {
	HANDLE hProcess;
	HANDLE evtControlQuit;
	CUpdate* pUpdateComClass;
	IUnknown* punkCallback;
} MONITOR_DATA, *PMONITOR_DATA;



//
// include declaration for interface IUpdateCompleteListener
//
#ifndef __IUpdateCompleteListener_INTERFACE_DEFINED__
#define __IUpdateCompleteListener_INTERFACE_DEFINED__

/* interface IUpdateCompleteListener */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IUpdateCompleteListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C06B895-E4C8-48eb-9E03-15A53B43B6CA")
    IUpdateCompleteListener : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnComplete( 
            /* [in] */ LONG lErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateCompleteListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateCompleteListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateCompleteListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateCompleteListener * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnComplete )( 
            IUpdateCompleteListener * This,
            /* [in] */ LONG lErrorCode);
        
        END_INTERFACE
    } IUpdateCompleteListenerVtbl;

    interface IUpdateCompleteListener
    {
        CONST_VTBL struct IUpdateCompleteListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateCompleteListener_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUpdateCompleteListener_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUpdateCompleteListener_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUpdateCompleteListener_OnComplete(This,lErrorCode)	\
    (This)->lpVtbl -> OnComplete(This,lErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUpdateCompleteListener_OnComplete_Proxy( 
    IUpdateCompleteListener * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IUpdateCompleteListener_OnComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUpdateCompleteListener_INTERFACE_DEFINED__ */




/////////////////////////////////////////////////////////////////////////////
// SelfUpdateCheck()
//
// Determines if a SelfUpdate is needed, or if a SelfUpdate is already in process.
// If one is already in process this will immediately return. If one is needed
// it either perform the selfupdate (synchronous), or launch a rundll32.exe process 
// and have it call the BeginSelfUpdate() entrypoint to start the selfupdate (asynchronous)
//
// Return S_FALSE is asked not to update engine but this func found engine
// needs to be updated.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT SelfUpdateCheck(BOOL fSynch, BOOL fStartUpdate, HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener)
{
    LOG_Block("SelfUpdateCheck()");
    HRESULT hr = S_OK;
    int iRet = 0;
    DWORD dwRet;
    DWORD dwWaitResult;
    DWORD dwStatus = 0;
    DWORD dwSize = 0;
    BOOL fSelfUpdateAvailable = FALSE;
    BOOL fAsyncSelfUpdateStarted = FALSE;
	BOOL fBetaSelfUpdate = FALSE;
    TCHAR szEngineClientVersion[64];
    TCHAR szEngineServerVersion[64];
    char  szAnsiEngineServerVersion[64];
    TCHAR szIUDir[MAX_PATH];
    TCHAR szIdentFile[MAX_PATH];
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szEngineDllPath[MAX_PATH+1];
    FILE_VERSION fvClientEngine, fvServerEngine;
    HANDLE hDownloadEvent = NULL;
    HANDLE hDownloadEventSync = NULL;
    HANDLE hMutex = NULL;
    HKEY hkey = NULL;
    MSG msg;
    DWORD dwTickStart, dwTickCurrent, dwTickEnd;
	HANDLE aHandles[2];

	if (!fSynch && fStartUpdate && NULL == pUpdateComClass)
	{
		//
		// if to do asynchronized update but the COM class pointer not passed in, then
		// even we succeed we can not pump up the init state of that class so that COM object
		// will still not usable.
		//
		hr = E_INVALIDARG;
		goto CleanUp;
	}


    // The synchronization between multiple processes running the IU control and doing the selfupdate
    // process is reasonably complex. We do this by using two synchronization objects. A named Mutex which protects 
    // the 'selfupdate checking' process, and a named Event that protects against orphaned selfupdate processes caused
    // by reboots during a selfupdate.
    hDownloadEvent = CreateEvent(NULL, TRUE, TRUE, IU_EVENT_SELFUPDATE_IN_PROGRESS);
    if (NULL == hDownloadEvent)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    hDownloadEventSync = CreateEvent(NULL, TRUE, FALSE, IU_EVENT_SELFUPDATE_EVENT_SYNC);
    if (NULL == hDownloadEventSync)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(hr);
        goto CleanUp;
    }

    // First check to see if a selfupdate is already in process.. This is done by
    // checking a regkey for the current selfupdate state. We use a Mutex to synchronize
    // reading/writing to the registry key to ensure that only one process is attempting 
    // the selfupdate. We don't care whether we had to create the mutex, or whether it was
    // already created, so as long as it succeeds, we'll use it.
    hMutex = CreateMutex(NULL, FALSE, IU_MUTEX_SELFUPDATE_REGCHECK);
    if (NULL == hMutex)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    // We're ready to start the selfupdate check process. We'll request the mutex. This helper function
    // does a while loop checking every second (1000ms) for a timeout to elapse (calculated with GetTickCount()),
    // or for the object to be satisfied. This function should either return a timeout result, a WAIT_OBJECT_0
	// for the index 0 object, or else we got the event/mutex we were waiting for.
	aHandles[0] = g_hEngineLoadQuit;	// index 0
	aHandles[1] = hMutex;

    dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/ 30000, QS_ALLINPUT);

    if (WAIT_TIMEOUT == dwWaitResult)
    {
        LOG_ErrorMsg(IU_SELFUPDATE_TIMEOUT);
        hr = IU_SELFUPDATE_TIMEOUT;
        goto CleanUp;
    }

	if (WAIT_OBJECT_0 == dwWaitResult)
	{
		hr = E_ABORT;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

    if (ERROR_REQUEST_ABORTED == dwWaitResult) // this indicates we processed a QUIT message while waiting.
    {
        // not an error
        goto CleanUp;
    }

    dwRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, _T(""), REG_OPTION_NON_VOLATILE, 
        KEY_READ | KEY_WRITE, NULL, &hkey, &dwStatus);
    if (ERROR_SUCCESS != dwRet)
    {
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    // if the previous call to RegCreateKeyEx indicated it 'created' the key then we need to set the default
    // status to 0.
    if (REG_CREATED_NEW_KEY == dwStatus)
    {
        dwStatus = SELFUPDATE_NONE;
        dwRet = RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
    }
    else
    {
		// Check for Beta IU SelfUpdate Handling Requested
		dwStatus = 0;
		dwSize = sizeof(dwStatus);
		dwRet = RegQueryValueEx(hkey, REGVAL_BETASELFUPDATE, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
		if (1 == dwStatus)
		{
			fBetaSelfUpdate = TRUE;
		}

        dwStatus = SELFUPDATE_NONE;
        dwSize = sizeof(dwStatus);
        dwRet = RegQueryValueEx(hkey, REGVAL_SELFUPDATESTATUS, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
    }

    // check the result of the QueryValue/SetValue call - 
    if (ERROR_SUCCESS != dwRet && 2 != dwRet)
    {
		//
		// if dwRet == 2, it's the case that IUControl key exist, but SelfUpdate value not exist,
		// 
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
    {
        LOG_ErrorMsg(E_ABORT);
        hr = E_ABORT;
        goto CleanUp;
    }

    switch (dwStatus)
    {
    case SELFUPDATE_NONE:
        {
            // First find out the version of the Engine on the server.
            GetIndustryUpdateDirectory(szIUDir);

            hr=PathCchCombine(szIdentFile,ARRAYSIZE(szIdentFile),szIUDir,IDENTTXT);

			if(FAILED(hr))
			{
				LOG_ErrorMsg(hr);
				goto CleanUp;
			}

            GetPrivateProfileString(fBetaSelfUpdate ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
									IDENT_VERSION, 
									_T(""), 
									szEngineServerVersion, 
									ARRAYSIZE(szEngineServerVersion), 
									szIdentFile);
            if ('\0' == szEngineServerVersion[0])
            {
                // no selfupdate available, no server version information
                hr = S_OK;
                goto CleanUp;
            }

            GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));
            hr=PathCchCombine(szEngineDllPath,ARRAYSIZE(szEngineDllPath),szSystemDir, ENGINEDLL);
			if(FAILED(hr))
			{
				LOG_ErrorMsg(hr);
				goto CleanUp;
			}


            if (GetFileVersion(szEngineDllPath, &fvClientEngine))
            {
                // T2A requires Structured Exception Handling (because it uses alloca which can throw, so we avoid it and 
                // do it the simple way.
#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, szEngineServerVersion, -1, szAnsiEngineServerVersion, 
                    sizeof(szAnsiEngineServerVersion), NULL, NULL);
                if (!ConvertStringVerToFileVer(szAnsiEngineServerVersion, &fvServerEngine))
#else
                if (!ConvertStringVerToFileVer(szEngineServerVersion, &fvServerEngine))
#endif
                {
                    LOG_ErrorMsg(IU_SELFUPDATE_FAILED);
                    hr = IU_SELFUPDATE_FAILED;
                    goto CleanUp;
                }
                iRet = CompareFileVersion(fvClientEngine, fvServerEngine);
                if (iRet == 0)
                {
                    // IUEngine Versions are the same
                    fSelfUpdateAvailable = FALSE;
                }
                else if (iRet > 0)
                {
                    LOG_Internet(_T("Version of IUEngine on Client is NEWER than IUEngine on Server"));
                    fSelfUpdateAvailable = FALSE;
                }
                else
                {
                    // IUEngine Version on the Server is newer
                    LOG_Internet(_T("New Version (%s) of IUEngine on Server Found."), szEngineServerVersion);
#if defined(UNICODE) || defined(_UNICODE)
					LogMessage("IUEngine on Server is newer version (%ls)", szEngineServerVersion);
#else
					LogMessage("IUEngine on Server is newer version (%s)", szEngineServerVersion);
#endif
                    fSelfUpdateAvailable = TRUE;
                }
            }
            else
            {
                // no version information found on local file, probably should do a selfupdate anyway.
                LOG_Internet(_T("No Version Information On Local IUEngine, SelfUpdating to Server Version"));
                fSelfUpdateAvailable = TRUE;
            }

            if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
            {
                LOG_ErrorMsg(E_ABORT);
                hr = E_ABORT;
                goto CleanUp;
            }

            if (fSelfUpdateAvailable)
            {
				if (fStartUpdate)
				{
					dwStatus = SELFUPDATE_IN_PROGRESS;	

                    dwRet = RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
					RegCloseKey(hkey); // done with the reg key now.
					hkey = NULL;

					// The default state of the DownloadEvent is Signaled (TRUE). If a Process is 'actually' working on the
					// SelfUpdate Process this Event Needs to be Reset to FALSE. Any time a client determines that a selfupdate
					// 'should' be in progress (from the regkey status) it should check the Event state, if it is signaled (TRUE)
					// then there was probably a reboot during the selfupdate, it should restart the selfupdate process itself.
					ResetEvent(hDownloadEvent); // mark that this Process will Perform the SelfUpdate by Resetting the Download Event
					ReleaseMutex(hMutex); // we are now done with the selfupdate check, both the event and the registry values are set
										  // properly.
					CloseHandle(hMutex);
					hMutex = NULL;
					if (fSynch)
					{
						hr = BeginSelfUpdate();
						if (FAILED(hr))
						{
							LOG_Error(_T("BeginSelfUpdate Failed"));
							goto CleanUp;
						}
					}
					else
					{
						fAsyncSelfUpdateStarted = TRUE;
						// launch SelfUpdate Asynchronously.
						dwRet = StartSelfUpdateProcess(evtQuit, pUpdateComClass, punkUpdateCompleteListener); // inline function
						if (ERROR_SUCCESS != dwRet)
						{
							LOG_ErrorMsg(dwRet);
							hr = HRESULT_FROM_WIN32(dwRet);
							goto CleanUp;
						}
					}
				}
				else
				{
					//
					// in case we are asked to check update info only,
					// we signal back the result as S_FALSE for
					// engine update avail
					//
					hr = S_FALSE;
				}
            }
			else
			{
				//
				// somehow, no update needed. must be other process finished it.
				//
				if (fStartUpdate)
				{
					hr = IU_SELFUPDATE_USENEWDLL;
					goto CleanUp;
				}
			}

            break;
        }
    case SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED:
        {
            // As selfupdate has already been completed, but we're waiting to be able to rename the DLL.
            // In this case we'll tell the co