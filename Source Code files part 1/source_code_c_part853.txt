ID(SCID_DRM_PlayExpires                    , PSGUID_DRM                            , PIDDRSI_PLAYEXPIRES);
DEFINE_SCID(SCID_AUDIO_Duration                     , PSGUID_AUDIO                          , PIDASI_TIMELENGTH);       //100ns units, not milliseconds. VT_UI8, not VT_UI4
DEFINE_SCID(SCID_AUDIO_Bitrate                      , PSGUID_AUDIO                          , PIDASI_AVG_DATA_RATE);    // bits per second
DEFINE_SCID(SCID_AUDIO_SampleRate                   , PSGUID_AUDIO                          , PIDASI_SAMPLE_RATE);      // samples per second
DEFINE_SCID(SCID_AUDIO_SampleSize                   , PSGUID_AUDIO                          , PIDASI_SAMPLE_SIZE);      // bits per sample
DEFINE_SCID(SCID_AUDIO_ChannelCount                 , PSGUID_AUDIO                          , PIDASI_CHANNEL_COUNT);    // 1 (mono), 2(stero)
DEFINE_SCID(SCID_AUDIO_Format                       , PSGUID_AUDIO                          , PIDASI_FORMAT);
DEFINE_SCID(SCID_VIDEO_Bitrate                      , PSGUID_VIDEO                          , PIDVSI_DATA_RATE);        // bits per second
DEFINE_SCID(SCID_VIDEO_FrameRate                    , PSGUID_VIDEO                          , PIDVSI_FRAME_RATE);       // frames per 1000s
DEFINE_SCID(SCID_VIDEO_SampleSize                   , PSGUID_VIDEO                          , PIDVSI_SAMPLE_SIZE);      // bits
DEFINE_SCID(SCID_VIDEO_Compression                  , PSGUID_VIDEO                          , PIDVSI_COMPRESSION);
DEFINE_SCID(SCID_VIDEO_StreamName                   , PSGUID_VIDEO                          , PIDVSI_STREAM_NAME);
DEFINE_SCID(SCID_FileType                           , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_FILETYPE);
DEFINE_SCID(SCID_ImageCX                            , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_CX);
DEFINE_SCID(SCID_ImageCY                            , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_CY);
DEFINE_SCID(SCID_ResolutionX                        , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_RESOLUTIONX);
DEFINE_SCID(SCID_ResolutionY                        , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_RESOLUTIONY);
DEFINE_SCID(SCID_BitDepth                           , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_BITDEPTH);
DEFINE_SCID(SCID_Colorspace                         , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_COLORSPACE);
DEFINE_SCID(SCID_Compression                        , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_COMPRESSION);
DEFINE_SCID(SCID_Transparency                       , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_TRANSPARENCY);
DEFINE_SCID(SCID_GammaValue                         , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_GAMMAVALUE);
DEFINE_SCID(SCID_FrameCount                         , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_FRAMECOUNT);
DEFINE_SCID(SCID_ImageDimensions                    , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_DIMENSIONS);
DEFINE_SCID(SCID_CameraModel                        , PSGUID_IMAGEPROPERTIES                , PropertyTagEquipModel); 
DEFINE_SCID(SCID_TagCopyright                       , PSGUID_IMAGEPROPERTIES                , PropertyTagCopyright);
DEFINE_SCID(SCID_TagSoftwareUsed                    , PSGUID_IMAGEPROPERTIES                , PropertyTagSoftwareUsed);
DEFINE_SCID(SCID_WhenTaken                          , PSGUID_IMAGEPROPERTIES                , PropertyTagExifDTOrig);
DEFINE_SCID(SCID_Flash                              , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFlash);
DEFINE_SCID(SCID_ColorSpace                         , PSGUID_IMAGEPROPERTIES                , PropertyTagExifColorSpace);
DEFINE_SCID(SCID_ShutterSpeed                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifShutterSpeed);
DEFINE_SCID(SCID_Aperture                           , PSGUID_IMAGEPROPERTIES                , PropertyTagExifAperture);
DEFINE_SCID(SCID_SubjectDist                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifSubjectDist);
DEFINE_SCID(SCID_FocalLength                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFocalLength);
DEFINE_SCID(SCID_FNumber                            , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFNumber);
DEFINE_SCID(SCID_ExposureTime                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifExposureTime);
DEFINE_SCID(SCID_FlashEnergy                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFlashEnergy);
DEFINE_SCID(SCID_ISOSpeed                           , PSGUID_IMAGEPROPERTIES                , PropertyTagExifISOSpeed);
DEFINE_SCID(SCID_MeteringMode                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifMeteringMode);
DEFINE_SCID(SCID_LightSource                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifLightSource);
DEFINE_SCID(SCID_ExposureProg                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifExposureProg);
DEFINE_SCID(SCID_ExposureBias                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifExposureBias);
DEFINE_SCID(SCID_FaxEndTime                         , PSGUID_IMAGEPROPERTIES                , TIFFTAG_FAX_END_TIME);
DEFINE_SCID(SCID_FaxSenderName                      , PSGUID_IMAGEPROPERTIES                , TIFFTAG_SENDER_NAME);
DEFINE_SCID(SCID_FaxTSID                            , PSGUID_IMAGEPROPERTIES                , TIFFTAG_TSID);
DEFINE_SCID(SCID_FaxCallerId                        , PSGUID_IMAGEPROPERTIES                , TIFFTAG_CALLERID);
DEFINE_SCID(SCID_FaxRecipName                       , PSGUID_IMAGEPROPERTIES                , TIFFTAG_RECIP_NAME);
DEFINE_SCID(SCID_FaxRecipNumber                     , PSGUID_IMAGEPROPERTIES                , TIFFTAG_RECIP_NUMBER);
DEFINE_SCID(SCID_FaxCSID                            , PSGUID_IMAGEPROPERTIES                , TIFFTAG_CSID);
DEFINE_SCID(SCID_FaxRouting                         , PSGUID_IMAGEPROPERTIES                , TIFFTAG_ROUTING);
DEFINE_SCID(SCID_TagEquipMake                       , PSGUID_IMAGEPROPERTIES                , PropertyTagEquipMake);
DEFINE_SCID(SCID_Media_SequenceNumber               , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_SEQUENCE_NO);
DEFINE_SCID(SCID_Media_Owner                        , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_OWNER);
DEFINE_SCID(SCID_Media_Editor                       , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_EDITOR);
DEFINE_SCID(SCID_Media_Supplier                     , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_SUPPLIER);
DEFINE_SCID(SCID_Media_Source                       , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_SOURCE);
DEFINE_SCID(SCID_Media_Copyright                    , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_COPYRIGHT);
DEFINE_SCID(SCID_Media_Project                      , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_PROJECT);
DEFINE_SCID(SCID_Media_Status                       , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_STATUS);
DEFINE_SCID(SCID_Media_Production                   , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_PRODUCTION);
DEFINE_SCID(SCID_CSC_STATUS                         , PSGUID_SHARE                          , PID_SHARE_CSC_STATUS);
DEFINE_SCID(SCID_LINKTARGET                         , PSGUID_LINK                           , PID_LINK_TARGET);
DEFINE_SCID(SCID_ATTRIBUTES_DESCRIPTION             , PSGUID_PRV_STORAGE                    , PID_PRV_STG_ATTRIBUTES_DESCRIPTION);

typedef struct
{
    LPCWSTR pwszName;
    const SHCOLUMNID *pscid;
    UINT idDisplayName;
    UINT idMnemonicName;
    UINT idHelp;        // IDH_ values
} PROPUI_INFO;

#define PROPUI_ENTRY_NORES(name, scid)                           {L ## name, &scid, 0, 0, 0},
#define PROPUI_ENTRY(name, scid, idDisplayName, idMnemonicName, idHelp)  {L ## name, &scid, idDisplayName, idMnemonicName, idHelp},

const PROPUI_INFO c_rgPropUIInfo[] =
{
    PROPUI_ENTRY("Name"                 , SCID_NAME                     , IDS_NAME_COL              , IDS_MNEMONIC_NAME_COL             , 10114)
    PROPUI_ENTRY("Type"                 , SCID_TYPE                     , IDS_TYPE_COL              , IDS_MNEMONIC_TYPE_COL             , 10015)
    PROPUI_ENTRY("Size"                 , SCID_SIZE                     , IDS_SIZE_COL              , IDS_MNEMONIC_SIZE_COL             , 10115)
    PROPUI_ENTRY("Write"                , SCID_WRITETIME                , IDS_MODIFIED_COL          , IDS_MNEMONIC_MODIFIED_COL         , 10016)
    PROPUI_ENTRY("Attributes"           , SCID_ATTRIBUTES               , IDS_ATTRIB_COL            , IDS_MNEMONIC_ATTRIB_COL           , 10019)
    PROPUI_ENTRY("AttributesDescription", SCID_ATTRIBUTES_DESCRIPTION   , IDS_ATTRIB_COL            , IDS_MNEMONIC_ATTRIB_COL           , 10019)
    PROPUI_ENTRY("Owner"                , SCID_OWNER                    , IDS_EXCOL_OWNER           , IDS_MNEMONIC_EXCOL_OWNER          , 10021)
    PROPUI_ENTRY("Create"               , SCID_CREATETIME               , IDS_EXCOL_CREATE          , IDS_MNEMONIC_EXCOL_CREATE         , 10017)
    PROPUI_ENTRY("Access"               , SCID_ACCESSTIME               , IDS_EXCOL_ACCESSTIME      , IDS_MNEMONIC_EXCOL_ACCESSTIME     , 10018)
    PROPUI_ENTRY("DocCreatedTm"         , SCID_DocCreated               , IDS_EXCOL_CREATE          , IDS_MNEMONIC_EXCOL_CREATE         , 10068)
    PROPUI_ENTRY("DocTitle"             , SCID_Title                    , IDS_EXCOL_TITLE           , IDS_MNEMONIC_EXCOL_TITLE          , 10023)
    PROPUI_ENTRY("DocSubject"           , SCID_Subject                  , IDS_EXCOL_SUBJECT         , IDS_MNEMONIC_EXCOL_SUBJECT        , 10024)
    PROPUI_ENTRY("DocAuthor"            , SCID_Author                   , IDS_EXCOL_AUTHOR          , IDS_MNEMONIC_EXCOL_AUTHOR         , 10022)
    PROPUI_ENTRY("DocLastAuthor"        , SCID_LastAuthor               , IDS_EXCOL_LASTAUTHOR      , IDS_MNEMONIC_EXCOL_LASTAUTHOR     , 20010)
    PROPUI_ENTRY("DocRevNumber"         , SCID_RevNumber                , IDS_EXCOL_REVNUMBER       , IDS_MNEMONIC_EXCOL_REVNUMBER      , 20011)
    PROPUI_ENTRY("DocAppName"           , SCID_AppName                  , IDS_EXCOL_APPNAME         , IDS_MNEMONIC_EXCOL_APPNAME        , 20012)
    PROPUI_ENTRY("DocPageCount"         , SCID_PageCount                , IDS_EXCOL_PAGECOUNT       , IDS_MNEMONIC_EXCOL_PAGECOUNT      , 10026)
    PROPUI_ENTRY("DocComments"          , SCID_Comment                  , IDS_EXCOL_COMMENT         , IDS_MNEMONIC_EXCOL_COMMENT        , 10020)
    PROPUI_ENTRY("Copyright"            , SCID_Copyright                , IDS_EXCOL_COPYRIGHT       , IDS_MNEMONIC_EXCOL_COPYRIGHT      , 10027)
    PROPUI_ENTRY("DocCategory"          , SCID_Category                 , IDS_EXCOL_CATEGORY        , IDS_MNEMONIC_EXCOL_CATEGORY       , 10025)
    PROPUI_ENTRY("DocKeywords"          , SCID_Keywords                 , IDS_EXCOL_KEYWORDS        , IDS_MNEMONIC_EXCOL_KEYWORDS       , 20013)
    PROPUI_ENTRY("Rating"               , SCID_Rating                   , IDS_EXCOL_RATING          , IDS_MNEMONIC_EXCOL_RATING         , 20014)
    PROPUI_ENTRY("DocTemplate"          , SCID_Template                 , IDS_EXCOL_TEMPLATEPROP    , IDS_MNEMONIC_EXCOL_TEMPLATE       , 20015)
    PROPUI_ENTRY("DocWordCount"         , SCID_WordCount                , IDS_EXCOL_WORDCOUNT       , IDS_MNEMONIC_EXCOL_WORDCOUNT      , 20016)
    PROPUI_ENTRY("DocCharCount"         , SCID_CharCount                , IDS_EXCOL_CHARCOUNT       , IDS_MNEMONIC_EXCOL_CHARCOUNT      , 20017)
    PROPUI_ENTRY("DocLastSavedTm"       , SCID_LastSaveDTM              , IDS_EXCOL_LASTSAVEDTM     , IDS_MNEMONIC_EXCOL_LASTSAVEDTM    , 20018)
    PROPUI_ENTRY("DocLastPrinted"       , SCID_LastPrinted              , IDS_EXCOL_LASTPRINTED     , IDS_MNEMONIC_EXCOL_LASTPRINTED    , 20019)
    PROPUI_ENTRY("DocEditTime"          , SCID_EditTime                 , IDS_EXCOL_EDITTIME        , IDS_MNEMONIC_EXCOL_EDITTIME       , 20020)
    PROPUI_ENTRY("DocByteCount"         , SCID_ByteCount                , IDS_EXCOL_BYTECOUNT       , IDS_MNEMONIC_EXCOL_BYTECOUNT      , 20021)
    PROPUI_ENTRY("DocLineCount"         , SCID_LineCount                , IDS_EXCOL_LINECOUNT       , IDS_MNEMONIC_EXCOL_LINECOUNT      , 20022)
    PROPUI_ENTRY("DocParaCount"         , SCID_ParagraphCount           , IDS_EXCOL_PARCOUNT        , IDS_MNEMONIC_EXCOL_PARCOUNT       , 20023)
    PROPUI_ENTRY("DocSlideCount"        , SCID_SlideCount               , IDS_EXCOL_SLIDECOUNT      , IDS_MNEMONIC_EXCOL_SLIDECOUNT     , 20024)
    PROPUI_ENTRY("DocNoteCount"         , SCID_NoteCount                , IDS_EXCOL_NOTECOUNT       , IDS_MNEMONIC_EXCOL_NOTECOUNT      , 20025)
    PROPUI_ENTRY("DocHiddenCount"       , SCID_HiddenCount              , IDS_EXCOL_HIDDENCOUNT     , IDS_MNEMONIC_EXCOL_HIDDENCOUNT    , 20026)
    PROPUI_ENTRY("MMClipCount"          , SCID_MMClipCount              , IDS_EXCOL_MMCLIPCOUNT     , IDS_MNEMONIC_EXCOL_MMCLIPCOUNT    , 20027)
    PROPUI_ENTRY("Scale"                , SCID_Scale                    , IDS_EXCOL_SCALE           , IDS_MNEMONIC_EXCOL_SCALE          , 20028)
    PROPUI_ENTRY("LinksUpToDate"        , SCID_LinksDirty               , IDS_EXCOL_LINKSDIRTY      , IDS_MNEMONIC_EXCOL_LINKSDIRTY     , 20029)
    PROPUI_ENTRY("CameraModel"          , SCID_CameraModel              , IDS_EXCOL_CAMERAMODEL     , IDS_MNEMONIC_EXCOL_CAMERAMODEL    , 10037)
    PROPUI_ENTRY("Copyright"            , SCID_TagCopyright             , IDS_EXCOL_COPYRIGHT       , IDS_MNEMONIC_EXCOL_COPYRIGHT      , 20030)
    PROPUI_ENTRY("Software"             , SCID_TagSoftwareUsed          , IDS_EXCOL_SOFTWARE        , IDS_MNEMONIC_EXCOL_SOFTWARE       , 20031)
    PROPUI_ENTRY("WhenTaken"            , SCID_WhenTaken                , IDS_EXCOL_WHENTAKEN       , IDS_MNEMONIC_EXCOL_WHENTAKEN      , 10038)
    PROPUI_ENTRY("FileType"             , SCID_FileType                 , IDS_EXCOL_FILETYPE        , IDS_MNEMONIC_EXCOL_FILETYPE       , 20032)
    PROPUI_ENTRY("ImageX"               , SCID_ImageCX                  , IDS_EXCOL_IMAGECX         , IDS_MNEMONIC_EXCOL_IMAGECX        , 20033)
    PROPUI_ENTRY("ImageY"               , SCID_ImageCY                  , IDS_EXCOL_IMAGECY         , IDS_MNEMONIC_EXCOL_IMAGECY        , 20034)
    PROPUI_ENTRY("ResolutionX"          , SCID_ResolutionX              , IDS_EXCOL_RESOLUTIONX     , IDS_MNEMONIC_EXCOL_RESOLUTIONX    , 20035)
    PROPUI_ENTRY("ResolutionY"          , SCID_ResolutionY              , IDS_EXCOL_RESOLUTIONY     , IDS_MNEMONIC_EXCOL_RESOLUTIONY    , 20036)
    PROPUI_ENTRY("BitDepth"             , SCID_BitDepth                 , IDS_EXCOL_BITDEPTH        , IDS_MNEMONIC_EXCOL_BITDEPTH       , 20037)
    PROPUI_ENTRY("ColorSpace"           , SCID_ColorSpace               , IDS_EXCOL_COLORSPACE      , IDS_MNEMONIC_EXCOL_COLORSPACE     , 20038)
    PROPUI_ENTRY("ColorSpace"           , SCID_Colorspace               , IDS_EXCOL_COLORSPACE      , IDS_MNEMONIC_EXCOL_COLORSPACE     , 20038)
    PROPUI_ENTRY("Compression"          , SCID_Compression              , IDS_EXCOL_ACOMPRESSION    , IDS_MNEMONIC_EXCOL_ACOMPRESSION   , 20039)
    PROPUI_ENTRY("Transparency"         , SCID_Transparency             , IDS_EXCOL_TRANSPARENCY    , IDS_MNEMONIC_EXCOL_TRANSPARENCY   , 20040)
    PROPUI_ENTRY("Gamma"                , SCID_GammaValue               , IDS_EXCOL_GAMMAVALUE      , IDS_MNEMONIC_EXCOL_GAMMAVALUE     , 20041)
    PROPUI_ENTRY("FrameCount"           , SCID_FrameCount               , IDS_EXCOL_FRAMECOUNT      , IDS_MNEMONIC_EXCOL_FRAMECOUNT     , 10046)
    PROPUI_ENTRY("Dimensions"           , SCID_ImageDimensions          , IDS_EXCOL_DIMENSIONS      , IDS_MNEMONIC_EXCOL_DIMENSIONS     , 10059)
    PROPUI_ENTRY("Flash"                , SCID_Flash                    , IDS_EXCOL_FLASH           , IDS_MNEMONIC_EXCOL_FLASH          , 20042)
    PROPUI_ENTRY("ShutterSpeed"         , SCID_ShutterSpeed             , IDS_EXCOL_SHUTTERSPEED    , IDS_NMEMONIC_EXCOL_SHUTTERSPEED   , 20043)
    PROPUI_ENTRY("Aperture"             , SCID_Aperture                 , IDS_EXCOL_APERTURE        , IDS_NMEMONIC_EXCOL_APERTURE       , 20044)
    PROPUI_ENTRY("Distance"             , SCID_SubjectDist              , IDS_EXCOL_DISTANCE        , IDS_NMEMONIC_EXCOL_DISTANCE       , 20046)
    PROPUI_ENTRY("FocalLength"          , SCID_FocalLength              , IDS_EXCOL_FOCALLENGTH     , IDS_MNEMONIC_EXCOL_FOCALLENGTH    , 20047)
    PROPUI_ENTRY("FNumber"              , SCID_FNumber                  , IDS_EXCOL_FNUMBER         , IDS_MNEMONIC_EXCOL_FNUMBER        , 20049)
    PROPUI_ENTRY("ExposureTime"         , SCID_ExposureTime             , IDS_EXCOL_EXPOSURETIME    , IDS_MNEMONIC_EXCOL_EXPOSURETIME   , 20049)
    PROPUI_ENTRY("FlashEnergy"          , SCID_FlashEnergy              ,IDS_EXCOL_FLASHENERGY      , IDS_MNEMONIC_EXCOL_FLASHENERGY    , 20080)
    PROPUI_ENTRY("ISOSpeed"             , SCID_ISOSpeed                 ,IDS_EXCOL_ISOSPEED         , IDS_MNEMONIC_EXCOL_ISOSPEED       , 20081)
    PROPUI_ENTRY("MeteringMode"         , SCID_MeteringMode             ,IDS_EXCOL_METERINGMODE     , IDS_MNEMONIC_EXCOL_METERINGMODE   , 20082)
    PROPUI_ENTRY("LightSource"          , SCID_LightSource              ,IDS_EXCOL_LIGHTSOURCE      , IDS_MNEMONIC_EXCOL_LIGHTSOURCE    , 20083)
    PROPUI_ENTRY("ExposureProg"         , SCID_ExposureProg             ,IDS_EXCOL_EXPOSUREPROG     , IDS_MNEMONIC_EXCOL_EXPOSUREPROG   , 20084)
    PROPUI_ENTRY("ExposureBias"         , SCID_ExposureBias             ,IDS_EXCOL_EXPOSUREBIAS     , IDS_MNEMONIC_EXCOL_EXPOSUREBIAS   , 20085)
    PROPUI_ENTRY("Artist"               , SCID_MUSIC_Artist             , IDS_EXCOL_ARTIST          , IDS_MNEMONIC_EXCOL_ARTIST         , 10028)
    PROPUI_ENTRY("Album"                , SCID_MUSIC_Album              , IDS_EXCOL_ALBUM           , IDS_MNEMONIC_EXCOL_ALBUM          , 10029)
    PROPUI_ENTRY("Year"                 , SCID_MUSIC_Year               , IDS_EXCOL_YEAR            , IDS_MNEMONIC_EXCOL_YEAR           , 10030)
    PROPUI_ENTRY("Track"                , SCID_MUSIC_Track              , IDS_EXCOL_TRACK           , IDS_MNEMONIC_EXCOL_TRACK          , 10031)
    PROPUI_ENTRY("Duration"             , SCID_AUDIO_Duration           , IDS_EXCOL_DURATION        , IDS_MNEMONIC_EXCOL_DURATION       , 10032)
    PROPUI_ENTRY("Bitrate"              , SCID_AUDIO_Bitrate            , IDS_EXCOL_BITRATE         , IDS_MNEMONIC_EXCOL_BITRATE        , 10033)
    PROPUI_ENTRY("Sample Rate"          , SCID_AUDIO_SampleRate         , IDS_EXCOL_SAMPLERATE      , IDS_MNEMONIC_EXCOL_SAMPLERATE     , 20050)
    PROPUI_ENTRY("Audio Sample Size"    , SCID_AUDIO_SampleSize         , IDS_EXCOL_ASAMPLESIZE     , IDS_MNEMONIC_EXCOL_ASAMPLESIZE    , 10041)
    PROPUI_ENTRY("Channels"             , SCID_AUDIO_ChannelCount       , IDS_EXCOL_CHANNELS        , IDS_MNEMONIC_EXCOL_CHANNELS       , 10047)
    PROPUI_ENTRY("Audio Format"         , SCID_AUDIO_Format             , IDS_EXCOL_FORMAT          , IDS_MNEMONIC_EXCOL_FORMAT         , 10039)  
    PROPUI_ENTRY("Data Rate"            , SCID_VIDEO_Bitrate            , IDS_EXCOL_DATARATE        , IDS_MNEMONIC_EXCOL_DATARATE       , 20050)
    PROPUI_ENTRY("Frame Rate"           , SCID_VIDEO_FrameRate          , IDS_EXCOL_FRAMERATE       , IDS_MNEMONIC_EXCOL_FRAMERATE      , 10045)
    PROPUI_ENTRY("Video Sample Size"    , SCID_VIDEO_SampleSize         , IDS_EXCOL_VSAMPLESIZE     , IDS_MNEMONIC_EXCOL_VSAMPLESIZE    , 10044)
    PROPUI_ENTRY("Compression"          , SCID_VIDEO_Compression        , IDS_EXCOL_VCOMPRESSION    , IDS_MNEMONIC_EXCOL_VCOMPRESSION   , 10043)
    PROPUI_ENTRY("Stream Name"          , SCID_VIDEO_StreamName         , IDS_EXCOL_STREAMNAME      , IDS_MNEMONIC_EXCOL_STREAMNAME     , 20051)
    PROPUI_ENTRY("Genre"                , SCID_MUSIC_Genre              , IDS_EXCOL_GENRE           , IDS_MNEMONIC_EXCOL_GENRE          , 20052)
    PROPUI_ENTRY("Lyrics"               , SCID_MUSIC_Lyrics             , IDS_EXCOL_LYRICS          , IDS_EXCOL_LYRICS                  , 0)
    PROPUI_ENTRY("Protected"            , SCID_DRM_Protected            , IDS_EXCOL_PROTECTED       , IDS_MNEMONIC_EXCOL_PROTECTED      , 20074)
    PROPUI_ENTRY("DRM Description"      , SCID_DRM_Description          , IDS_EXCOL_DRMDESCRIPTION  , IDS_MNEMONIC_EXCOL_DRMDESCRIPTION , 20075)
    PROPUI_ENTRY("Play Count"           , SCID_DRM_PlayCount            , IDS_EXCOL_PLAYCOUNT       , IDS_MNEMONIC_EXCOL_PLAYCOUNT      , 20076)
    PROPUI_ENTRY("Play Starts"          , SCID_DRM_PlayStarts           , IDS_EXCOL_PLAYSTARTS      , IDS_MNEMONIC_EXCOL_PLAYSTARTS     , 20077)
    PROPUI_ENTRY("Play Expires"         , SCID_DRM_PlayExpires          , IDS_EXCOL_PLAYEXPIRES     , IDS_MNEMONIC_EXCOL_PLAYEXPIRES    , 20078)
    PROPUI_ENTRY("FaxTime"              , SCID_FaxEndTime               , IDS_EXCOL_FAXENDTIME      , IDS_MNEMONIC_EXCOL_FAXENDTIME     , 20053)
    PROPUI_ENTRY("FaxSenderName"        , SCID_FaxSenderName            , IDS_EXCOL_FAXSENDERNAME   , IDS_MNEMONIC_EXCOL_FAXSENDERNAME  , 20054)
    PROPUI_ENTRY("FaxTSID"              , SCID_FaxTSID                  , IDS_EXCOL_FAXTSID         , IDS_MNEMONIC_EXCOL_FAXTSID        , 20055)
    PROPUI_ENTRY("FaxCallerID"          , SCID_FaxCallerId              , IDS_EXCOL_FAXCALLERID     , IDS_MNEMONIC_EXCOL_FAXCALLERID    , 20056)
    PROPUI_ENTRY("FaxRecipientName"     , SCID_FaxRecipName             , IDS_EXCOL_FAXRECIPNAME    , IDS_MNEMONIC_EXCOL_FAXRECIPNAME   , 20057)
    PROPUI_ENTRY("FaxRecipientNumber"   , SCID_FaxRecipNumber           , IDS_EXCOL_FAXRECIPNUMBER  , IDS_MNEMONIC_EXCOL_FAXRECIPNUMBER , 20058)
    PROPUI_ENTRY("FaxCSID"              , SCID_FaxCSID                  , IDS_EXCOL_FAXCSID         , IDS_MNEMONIC_EXCOL_FAXCSID        , 20059)
    PROPUI_ENTRY("FaxRouting"           , SCID_FaxRouting               , IDS_EXCOL_FAXROUTING      , IDS_MNEMONIC_EXCOL_FAXROUTING     , 20060)
    PROPUI_ENTRY("EquipMake"            , SCID_TagEquipMake             , IDS_EXCOL_TAGEQUIPMAKE    , IDS_MNEMONIC_EXCOL_TAGEQUIPMAKE   , 20061)
    PROPUI_ENTRY("SequenceNo"           , SCID_Media_SequenceNumber     , IDS_EXCOL_SEQUENCENUMBER  , IDS_MNEMONIC_EXCOL_SEQUENCENUMBER , 20062)
    PROPUI_ENTRY("Owner"                , SCID_Media_Owner              , IDS_EXCOL_OWNER           , IDS_MNEMONIC_EXCOL_OWNER          , 20063)
    PROPUI_ENTRY("Editor"               , SCID_Media_Editor             , IDS_EXCOL_EDITOR          , IDS_MNEMONIC_EXCOL_EDITOR         , 20064)
    PROPUI_ENTRY("Supplier"             , SCID_Media_Supplier           , IDS_EXCOL_SUPPLIER        , IDS_MNEMONIC_EXCOL_SUPPLIER       , 20065)
    PROPUI_ENTRY("Source"               , SCID_Media_Source             , IDS_EXCOL_SOURCE          , IDS_MNEMONIC_EXCOL_SOURCE         , 20066)
    PROPUI_ENTRY("Copyright"            , SCID_Media_Copyright          , IDS_EXCOL_COPYRIGHT       , IDS_MNEMONIC_EXCOL_COPYRIGHT      , 20067)
    PROPUI_ENTRY("Project"              , SCID_Media_Project            , IDS_EXCOL_PROJECT         , IDS_MNEMONIC_EXCOL_PROJECT        , 20068)
    PROPUI_ENTRY("Status"               , SCID_Media_Status             , IDS_EXCOL_STATUS          , IDS_MNEMONIC_EXCOL_STATUS         , 20069)
    PROPUI_ENTRY("Production"           , SCID_Media_Production         , IDS_EXCOL_PRODUCTION      , IDS_MNEMONIC_EXCOL_PRODUCTION     , 20070)
    PROPUI_ENTRY("Company"              , SCID_CompanyName              , IDS_VN_COMPANYNAME        , IDS_MNEMONIC_VN_COMPANYNAME       , 10034)
    PROPUI_ENTRY("Manager"              , SCID_Manager                  , IDS_EXCOL_MANAGER         , IDS_MNEMONIC_EXCOL_MANAGER        , 20071)
    PROPUI_ENTRY("PresentationTarget"   , SCID_PresFormat               , IDS_EXCOL_PRESFORMAT      , IDS_MNEMONIC_EXCOL_PRESFORMAT     , 20072)
    PROPUI_ENTRY("FileDescription"      , SCID_FileDescription          , IDS_VN_FILEDESCRIPTION    , IDS_MNEMONIC_VN_FILEDESCRIPTION   , 10056)
    PROPUI_ENTRY("FileVersion"          , SCID_FileVersion              , IDS_VN_FILEVERSION        , IDS_MNEMONIC_VN_FILEVERSION       , 10057)
    PROPUI_ENTRY("ProductName"          , SCID_ProductName              , IDS_VN_PRODUCTNAME        , IDS_MNEMONIC_VN_PRODUCTNAME       , 10035)
    PROPUI_ENTRY("ProductVersion"       , SCID_ProductVersion           , IDS_VN_PRODUCTVERSION     , IDS_MNEMONIC_VN_PRODUCTVERSION    , 10036)
    PROPUI_ENTRY("DeletedFrom"          , SCID_DELETEDFROM              , IDS_DELETEDFROM_COL       , IDS_MNEMONIC_DELETEDFROM_COL      , 10048)
    PROPUI_ENTRY("DateDeleted"          , SCID_DATEDELETED              , IDS_DATEDELETED_COL       , IDS_MNEMONIC_DATEDELETED_COL      , 10049)
    PROPUI_ENTRY("SyncCopyIn"           , SCID_SYNCCOPYIN               , IDS_SYNCCOPYIN_COL        , IDS_MNEMONIC_SYNCCOPYIN_COL       , 10060)
    PROPUI_ENTRY("Status"               , SCID_STATUS                   , IDS_STATUS_COL            , IDS_MNEMONIC_STATUS_COL           , 0)    //  do we need help for this? What is it? 
    PROPUI_ENTRY("FreeSpace"            , SCID_FREESPACE                , IDS_DRIVES_FREE           , IDS_MNEMONIC_DRIVES_FREE          , 10051)
    PROPUI_ENTRY("Capacity"             , SCID_CAPACITY                 , IDS_DRIVES_CAPACITY       , IDS_MNEMONIC_DRIVES_CAPACITY      , 10050)
    PROPUI_ENTRY("FileSystem"           , SCID_FILESYSTEM               , IDS_DRIVES_FILESYSTEM     , IDS_MNEMONIC_DRIVES_FILESYSTEM    , 10062)
    PROPUI_ENTRY(""                     , SCID_PRN_QUEUESIZE            , IDS_PSD_QUEUESIZE         , IDS_MNEMONIC_PSD_QUEUESIZE        , 10063)
    PROPUI_ENTRY(""                     , SCID_PRN_LOCATION             , IDS_PSD_LOCATION          , IDS_MNEMONIC_PSD_LOCATION         , 10064)
    PROPUI_ENTRY(""                     , SCID_PRN_MODEL                , IDS_PSD_MODEL             , IDS_MNEMONIC_PSD_MODEL            , 10066)
    PROPUI_ENTRY(""                     , SCID_PRN_STATUS               , IDS_PRQ_STATUS            , IDS_MNEMONIC_PRQ_STATUS           , 10065)
    PROPUI_ENTRY("Directory"            , SCID_DIRECTORY                , IDS_PATH_COL              , IDS_MNEMONIC_PATH_COL             , 10053)
    PROPUI_ENTRY("Rank"                 , SCID_RANK                     , IDS_RANK_COL              , IDS_MNEMONIC_RANK_COL             , 10054)
    PROPUI_ENTRY(""                     , SCID_WHICHFOLDER              , IDS_WHICHFOLDER_COL       , IDS_MNEMONIC_WHICHFOLDER_COL      , 10067)
    PROPUI_ENTRY("CSCStatus"            , SCID_CSC_STATUS               , IDS_CSC_STATUS            , IDS_MNEMONIC_CSC_STATUS           , 20073)
    PROPUI_ENTRY_NORES("LinkTarget"     , SCID_LINKTARGET)
};

//  String resource mapping block
struct STRING_MAP
{
    ULONG uVal;
    UINT  idStr;
};

static const STRING_MAP g_cLightSourceStrings[] =
{
    { 1, IDS_PROPERTYUI_IMAGE_DAYLIGHT},
    { 2, IDS_PROPERTYUI_IMAGE_FLOURESCENT},
    { 3, IDS_PROPERTYUI_IMAGE_TUNGSTEN},
    {17, IDS_PROPERTYUI_IMAGE_STANDARDA},
    {18, IDS_PROPERTYUI_IMAGE_STANDARDB},
    {19, IDS_PROPERTYUI_IMAGE_STANDARDC},
    {20, IDS_PROPERTYUI_IMAGE_D55},
    {21, IDS_PROPERTYUI_IMAGE_D65},
    {22, IDS_PROPERTYUI_IMAGE_D75},
    { 0, IDS_PROPERTYUI_IMAGE_UNKNOWN}, // Last entry is default
};

static const STRING_MAP g_cExposureProgStrings[] =
{
    {1, IDS_PROPERTYUI_IMAGE_MANUAL},
    {2, IDS_PROPERTYUI_IMAGE_NORMAL},
    {3, IDS_PROPERTYUI_IMAGE_APERTUREPRI},
    {4, IDS_PROPERTYUI_IMAGE_SHUTTERPRI},
    {5, IDS_PROPERTYUI_IMAGE_CREATIVE},
    {6, IDS_PROPERTYUI_IMAGE_ACTION},
    {7, IDS_PROPERTYUI_IMAGE_PORTRAIT},
    {8, IDS_PROPERTYUI_IMAGE_LANDSCAPE},
    {0, IDS_PROPERTYUI_IMAGE_UNKNOWN}, // Last entry is default
};

static const STRING_MAP g_cMeteringModeStrings[] =
{
    {1, IDS_PROPERTYUI_IMAGE_AVERAGE},
    {2, IDS_PROPERTYUI_IMAGE_CWA},
    {3, IDS_PROPERTYUI_IMAGE_SPOT},
    {4, IDS_PROPERTYUI_IMAGE_MULTISPOT},
    {5, IDS_PROPERTYUI_IMAGE_PATTERN},
    {6, IDS_PROPERTYUI_IMAGE_PARTIAL},
    {0, IDS_PROPERTYUI_IMAGE_UNKNOWN}, // Last entry is default
};

static const STRING_MAP g_cFlashStrings[] = 
{
    {0, IDS_PROPERTYUI_IMAGE_NOFLASH},
    {1, IDS_PROPERTYUI_IMAGE_FLASHFIRED},
    {5, IDS_PROPERTYUI_IMAGE_NOSTROBERETURN},
    {7, IDS_PROPERTYUI_IMAGE_STROBERETURN},
    {0, 0},
};

static const STRING_MAP g_cColorStrings[] = 
{
    {1, IDS_PROPERTYUI_IMAGE_SRGB},
    {0xffff, IDS_PROPERTYUI_IMAGE_UNCALIBRATED},
    {0,0},
};

static const STRING_MAP g_cMediaStatus[] =
{
    { PIDMSI_STATUS_NORMAL       , IDS_STATUSVAL_NORMAL     },
    { PIDMSI_STATUS_NEW          , IDS_STATUSVAL_NEW        },
    { PIDMSI_STATUS_PRELIM       , IDS_STATUSVAL_PRELIM     },
    { PIDMSI_STATUS_DRAFT        , IDS_STATUSVAL_DRAFT      },
    { PIDMSI_STATUS_EDIT         , IDS_STATUSVAL_EDIT       },
    { PIDMSI_STATUS_INPROGRESS   , IDS_STATUSVAL_INPROGRESS },
    { PIDMSI_STATUS_REVIEW       , IDS_STATUSVAL_REVIEW     },
    { PIDMSI_STATUS_PROOF        , IDS_STATUSVAL_PROOF      },
    { PIDMSI_STATUS_FINAL        , IDS_STATUSVAL_FINAL      },
    { PIDMSI_STATUS_OTHER        , IDS_STATUSVAL_OTHER      },
    { 0,0 }
};

STDAPI SCIDCannonicalName(SHCOLUMNID *pscid, LPTSTR pszName, int cch)
{
    HRESULT hr = E_FAIL;

    pszName[0] = 0;
    for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
    {
        if (IsEqualSCID(*pscid, *c_rgPropUIInfo[i].pscid))
        {
            SHUnicodeToTChar(c_rgPropUIInfo[i].pwszName, pszName, cch);
            hr = S_OK;
            break;
        }
    }

    return hr;
}

LPCTSTR TrimLeadingWhiteSpaces(LPCTSTR pszString)
{
    LPCTSTR psz = pszString;
    while (psz && ((*psz == TEXT(' ')) || (*psz == TEXT('\n')) || (*psz == TEXT('\t'))))
    {
        psz++;
    }
    return psz;
}

STDAPI_(BOOL) ParseSCIDString(LPCTSTR pszString, SHCOLUMNID *pscid, UINT *pidRes)
{
    BOOL bRet = FALSE;

    if (GUIDFromString(pszString, &pscid->fmtid))
    {
        // GUIDSTR_MAX includes space for the terminating NULL
        LPCTSTR pszPid = &pszString[GUIDSTR_MAX - 1];
        // Skip past any leading white space
        pszPid = TrimLeadingWhiteSpaces(pszPid);
        pscid->pid = StrToInt(pszPid);
        bRet = TRUE;
        if (pidRes)
            *pidRes = 0;
    }
    else
    {
        WCHAR szName[64];
        SHTCharToUnicode(pszString, szName, ARRAYSIZE(szName));

        for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
        {
            if (StrCmpIW(szName, c_rgPropUIInfo[i].pwszName) == 0)
            {
                *pscid = *c_rgPropUIInfo[i].pscid;
                if (pidRes)
                    *pidRes = c_rgPropUIInfo[i].idDisplayName;
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

//
// Function converts a SCID into a string.
// The string format is "{scid.fmtid} scid.pid" (There is a space in between)
// So for example, SCID_Category will yield the following string - 
// "{d5cdd502-2e9c-101b-9397-08002b2cf9ae} 2"
//
// See ParseSCIDString() above for the the complimentary function.
// Also see CFolderItem::ExtendedProperty() in sdflditm.cpp if you are curious 
// as to where is ParseSCIDString() used and see CtrlFldr.cpp and RegFldr.cpp for
// usage of StringFromSCID().
//
STDAPI_(int) StringFromSCID(const SHCOLUMNID *pscid, LPTSTR psz, UINT cch)
{
    TCHAR ach[GUIDSTR_MAX];
    
    if (0 != SHStringFromGUID(pscid->fmtid, ach, ARRAYSIZE(ach)))
    {
        return wnsprintf(psz, cch, TEXT("%s %d"), ach, pscid->pid);                
    }
    
    *psz = 0;
    return 0;
}

STDAPI MapColumnToSCIDImpl(const COLUMN_INFO* pcol, UINT nCols, UINT iColumn, SHCOLUMNID* pscid)
{
    HRESULT hr;

    if (iColumn < nCols)
    {
        *pscid = *pcol[iColumn].pscid;
        hr = S_OK;
    }
    else
    {
        ZeroMemory(pscid, sizeof(*pscid));
        hr = E_INVALIDARG;
    }
    return hr;
}

STDAPI_(int) FindSCID(const COLUMN_INFO* pcol, UINT nCols, const SHCOLUMNID* pscid)
{
    for (UINT i = 0; i < nCols; i++)
    {
        if (IsEqualSCID(*pscid, *pcol[i].pscid))
            return (int)i;
    }
    return -1;
}

STDAPI GetDetailsOfInfo(const COLUMN_INFO* pcol_data, UINT nCols, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;
    if (iColumn < nCols)
    {
        pdi->fmt = pcol_data[iColumn].fmt;
        pdi->cxChar = pcol_data[iColumn].cChars;
        hr = ResToStrRet(pcol_data[iColumn].idTitle, &pdi->str);
    }
    else
    {
        hr = E_NOTIMPL;     // we don't support his column
    }
    return hr;
}

// dead export
STDAPI SHStgOpenStorageW(LPCWSTR pwszPath, DWORD grfMode, DWORD grfAttr, DWORD grfFileAttr, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

// dead export
STDAPI SHStgOpenStorageA(LPCSTR pwszPath, DWORD grfMode, DWORD grfAttr, DWORD grfFileAttr, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

const PROPSPEC  codepage_spec = { PRSPEC_PROPID, PID_CODEPAGE } ;

// Retrieves the codepage value from an existing property set storage.

STDAPI SHPropStgReadCP(IPropertyStorage* ppss, UINT* puCodePage)
{
    *puCodePage = 0;    // CP_ACP == 0, assume failure here

    PROPVARIANT varCP;
    if (S_OK == ppss->ReadMultiple(1, &codepage_spec, &varCP))
    {
        if (VT_I2 == varCP.vt)
        {
            *puCodePage = (UINT)MAKELONG(varCP.iVal, 0);
        }
    }
    return (0 == *puCodePage) ? E_FAIL : S_OK;
}

// Modifies the property set codepage on a new property set storage.
// 
// Note: this function will fail if the property set already 
// contains properties.
STDAPI SHPropStgWriteCP(IPropertyStorage* ppss, IN UINT uCodePage)
{
    PROPVARIANT varCP;
    varCP.iVal = (SHORT)uCodePage;
    varCP.vt   = VT_I2;

    return ppss->WriteMultiple(1, &codepage_spec, &varCP, PID_CODEPAGE);
}

// IPropertySetStorage::Open/Create wrapper.
// The wrap properly retrieves/assigns the set's codepage value.

STDAPI SHPropStgCreate(
    IPropertySetStorage* psstg, // Address of IPropertySetStorage vtable
    REFFMTID    fmtid,          // property set ID
    CLSID*      pclsid,         // class ID associated with the set. This can be NULL
    DWORD       grfFlags,       // PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                                // PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT
    DWORD       grfMode,        // STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
    DWORD       dwDisposition,  // OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, CREATE_ALWAYS
    OUT         IPropertyStorage** ppstg,  // Address to receive requested vtable
    OUT UINT*   puCodePage)    // Optional address to receive the code page ID for the set.
{
    ASSERT(psstg);
    ASSERT(ppstg);

    if (puCodePage)
        *puCodePage = 0;

    *ppstg = NULL;
    
    // Check legacy sets.  These MUST be flagged ANSI
    if (IsEqualGUID(fmtid, FMTID_SummaryInformation) || 
        IsEqualGUID(fmtid, FMTID_DocSummaryInformation) ||
        IsEqualGUID(fmtid, FMTID_UserDefinedProperties))
    {
        grfFlags |= PROPSETFLAG_ANSI;     // these legacy sets MUST be ansi.
    }

    // Attempt opening the set
    HRESULT hr = psstg->Open(fmtid, grfMode, ppstg);
    if (SUCCEEDED(hr))  // opened the set
    {
        // If a new set was requested, fail.
        if (CREATE_NEW == dwDisposition)
        {
            (*ppstg)->Release();
            *ppstg = NULL;
            return STG_E_FILEALREADYEXISTS;
        }

        // If the request was to overwrite any existing set, delete the current one.
        if (CREATE_ALWAYS == dwDisposition)
        {
            (*ppstg)->Release();
            *ppstg = NULL;
            
            if (FAILED((hr = psstg->Delete(fmtid))))
                return hr;

            hr = STG_E_FILENOTFOUND; // falls through to create
        }
    }
    else  // failed to open the set
    {   
        // if an existing set is requested, fail
        if (OPEN_EXISTING == dwDisposition)
            return hr;
    }
    
    if (STG_E_FILENOTFOUND == hr) // set doesn't exist, so create it.
    {
        hr = psstg->Create(fmtid, pclsid, grfFlags, grfMode, ppstg);
    }

    // If we haven't assigned a codepage, then read it from PID_CODEPAGE.
    if (SUCCEEDED(hr) && puCodePage)
    {
        ASSERT(*ppstg);
        SHPropStgReadCP(*ppstg, puCodePage);
    }

    return hr;
}

STDAPI_(BOOL) _IsAnsiPropertySet(REFFMTID fmtid);
STDAPI_(BOOL) _DoesStringRoundTripCPW(UINT uCodePage, LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut);
STDAPI        _DoLegacyPropertiesRoundTrip(REFFMTID fmtid, UINT uCodePage, ULONG cvar, PROPVARIANT rgvar[]);
STDAPI        _UniversalizeSet(IPropertyStorage* pstg, IN OUT UINT* puCodePage, PROPID propidNameFirst);

STDAPI _LegacyPropertiesToUnicode(REFFMTID fmtid, UINT uCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[]);
STDAPI _LegacyPropertiesToAnsi(REFFMTID fmtid, UINT uCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[]);
    
// IPropertyStorage::ReadMultiple wrap
//
// The wrap ensures ANSI/UNICODE translations are handled properly for
// legacy property sets.
STDAPI SHPropStgReadMultiple(
    IPropertyStorage* pps,        // address of IPropertyStorage vtable.
    UINT              uCodePage,  // Code page value retrieved from SHCreatePropertySet
    ULONG             cpspec,     // Count of properties being read
    PROPSPEC const    rgpspec[],  // Array of the properties to be read
    PROPVARIANT       rgvar[])    // Array of PROPVARIANTs containing the 
                                  // property values on return
{
    // read the requested properties
    HRESULT hr = pps->ReadMultiple(cpspec, rgpspec, rgvar);
    if (S_OK == hr)
    {
        HRESULT hrTmp = S_OK;
        
        // grab the set's ANSI codepage if not provided.
        if (0 == uCodePage)
        {
            hrTmp = SHPropStgReadCP(pps, &uCodePage);
        }
        
        if (SUCCEEDED(hrTmp))
        {
            STATPROPSETSTG stat;
            if (SUCCEEDED(pps->Stat(&stat)))
            {
                hr = _LegacyPropertiesToUnicode(stat.fmtid, uCodePage, cpspec, rgpspec, rgvar);
            }
        }
    }
    return hr;
}

// IPropertyStorage::WriteMultiple wrap
//
// The wrap ensures ANSI/UNICODE translations are handled properly for
// legacy property sets.

STDAPI SHPropStgWriteMultiple(
    IPropertyStorage* pps,             // address of IPropertyStorage vtable.
    UINT*             puCodePage,      // code page retrieved from SHCreatePropertySet.
    ULONG             cpspec,          // The number of properties being set
    PROPSPEC const    rgpspec[],       // Property specifiers
    PROPVARIANT       rgvar[],         // Array of PROPVARIANT values
    PROPID            propidNameFirst) // Minimum value for property identifiers 
                                       // when they must be allocated
{ 
    UINT uCodePage = 0;
    if (!puCodePage)
        puCodePage = &uCodePage;

    ASSERT(propidNameFirst >= PID_FIRST_USABLE); // you're walking on OLE PIDs.

    STATPROPSETSTG stat;
    HRESULT hr = pps->Stat(&stat); // need the FMTID
    if (SUCCEEDED(hr))
    {
        // read in the codepage if it isn't provided.
        if (0 == *puCodePage)
        {
            hr = SHPropStgReadCP(pps, puCodePage);
        }

        if (SUCCEEDED(hr) )
        {
            // test for round-trippability
            hr = _DoLegacyPropertiesRoundTrip(stat.fmtid, *puCodePage, cpspec, rgvar);
            if (SUCCEEDED(hr))
            {
                if (S_FALSE == hr)
                {
                    hr = _UniversalizeSet(pps, puCodePage, propidNameFirst);
                }

                if (SUCCEEDED(hr))
                {
                    // convert legacy properties back to ansi
                    hr = _LegacyPropertiesToAnsi(stat.fmtid, *puCodePage, cpspec, rgpspec, rgvar);
                    if (SUCCEEDED(hr))
                    {
                        // write em.
                        hr = pps->WriteMultiple(cpspec, rgpspec, rgvar, propidNameFirst);

                        if (FAILED(hr))
                            _LegacyPropertiesToUnicode(stat.fmtid, *puCodePage, cpspec, rgpspec, rgvar);
                    }
                }
            }
        }
    }
    return hr;
}

// Helper: converts LPWSTR to LPSTR using the indicated codepage and returns 
// TRUE if the LPSTR can be converted back to LPWSTR without unacceptible data loss
STDAPI_(BOOL) _DoesStringRoundTripCPW(UINT uCodePage, LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut)
{
    BOOL fRet = FALSE;

    // if we're being asked to roundtrip UTF8, don't bother test, it'll work.
    if (CP_UTF8 == uCodePage)
    {
        SHUnicodeToAnsiCP(uCodePage, pwszIn, pszOut, cchOut);
        fRet = TRUE;
    }
    else
    {
        WCHAR   wszTemp[MAX_PATH];
        LPWSTR  pwszTemp = wszTemp;
        UINT    cchTemp = ARRAYSIZE(wszTemp);

        // We better have enough room for the buffer.
        if (ARRAYSIZE(wszTemp) < cchOut)
        {
            pwszTemp = (LPWSTR)LocalAlloc(LPTR, cchOut*sizeof(WCHAR));
            cchTemp = cchOut;
        }
        if (pwszTemp)
        {
            SHUnicodeToAnsiCP(uCodePage, pwszIn, pszOut, cchOut);
            SHAnsiToUnicodeCP(uCodePage, pszOut, pwszTemp, cchTemp);
            fRet = StrCmpW(pwszIn, pwszTemp) == 0;     // are they the same?

            if (pwszTemp != wszTemp)
            {
                LocalFree(pwszTemp);
            }
        }
    }
    return fRet;
}

// Helper: determines whether the specified string properties of the indicate property set
// can round-trip to ansi and back.  
// Returns S_OK if all strings can round-trip, S_FALSE if not all strings can round trip,
// or an error code.
STDAPI _DoLegacyPropertiesRoundTrip(
    REFFMTID       fmtid, 
    UINT           uCodePage, 
    ULONG          cvar, 
    PROPVARIANT    rgvar[])
{
    ASSERT(uCodePage);

    HRESULT hr = S_OK; // assume all strings round-trip.

    if (uCodePage != CP_UTF8 && uCodePage != CP_WINUNICODE && _IsAnsiPropertySet(fmtid))
    {
        ASSERT (uCodePage != CP_WINUNICODE); 
            // either the set's creator is whacked, or this is simply an invalid arg.

        for (ULONG i = 0; i < cvar && S_OK == hr ; i++)
        {
            if (rgvar[i].vt == VT_LPWSTR && rgvar[i].pwszVal && *rgvar[i].pwszVal)
            {
                LPSTR pszVal;
                // make plenty of room for UTF-8 conversions.  each WCHAR
                // can turn into as many as three ANSI chars
                int   cb = MAX_UTF8_CHAR_SIZE * (lstrlenW(rgvar[i].pwszVal) + 1);
                if ((pszVal = new CHAR[cb]) != NULL)
                {
                    // Test round-trip to ANSI and back.
                    if (!_DoesStringRoundTripCPW(uCodePage, rgvar[i].pwszVal, pszVal, cb))
                    {
                        hr = S_FALSE;
                    }
                    delete [] pszVal;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

// Helper: Reports whether the specified FMTID is a legacy ANSI property set.

STDAPI_(BOOL) _IsAnsiPropertySet(REFFMTID fmtid)
{
    const FMTID* _ansi_propertysets[] = 
    {
        &FMTID_SummaryInformation,
        &FMTID_DocSummaryInformation,
        &FMTID_UserDefinedProperties,
    };

    for (int i = 0; i < ARRAYSIZE(_ansi_propertysets); i++)
    {
        if (IsEqualGUID(fmtid, *_ansi_propertysets[i]))
            return TRUE;
    }
    return FALSE;
}

// Determine whether the property is a legacy ANSI property, and if so,
// compute a conversion type for the property.

typedef struct {
    PROPID      propid;
    VARTYPE     vt;
    VARTYPE     vtConvert;
} ANSIPROPDEF;

// (public) ansi SummaryInformation properties
const ANSIPROPDEF si_lpstr_pids[] =
{ 
    { PIDSI_TITLE,      VT_LPSTR,   VT_LPWSTR },
    { PIDSI_SUBJECT,    VT_LPSTR,   VT_LPWSTR },
    { PIDSI_AUTHOR,     VT_LPSTR,   VT_LPWSTR },
    { PIDSI_KEYWORDS,   VT_LPSTR,   VT_LPWSTR },
    { PIDSI_COMMENTS,   VT_LPSTR,   VT_LPWSTR },
    { PIDSI_TEMPLATE,   VT_LPSTR,   VT_LPWSTR },
    { PIDSI_LASTAUTHOR, VT_LPSTR,   VT_LPWSTR },
    { PIDSI_REVNUMBER,  VT_LPSTR,   VT_LPWSTR },
    { PIDSI_APPNAME,    VT_LPSTR,   VT_LPWSTR },
};

// (public) ansi DocSummaryInformation properties
const ANSIPROPDEF dsi_lpstr_pids[] =
{ 
    { PIDDSI_CATEGORY,  VT_LPSTR,           VT_LPWSTR },
    { PIDDSI_PRESFORMAT,VT_LPSTR,           VT_LPWSTR },
    { PIDDSI_DOCPARTS,  VT_LPSTR|VT_VECTOR, VT_LPWSTR|VT_VECTOR },
    { PIDDSI_MANAGER,   VT_LPSTR,           VT_LPWSTR },
    { PIDDSI_COMPANY,   VT_LPSTR,           VT_LPWSTR },
};

STDAPI_(BOOL) SHIsLegacyAnsiProperty(REFFMTID fmtid, PROPID propid, IN OUT OPTIONAL VARTYPE* pvt)
{
    const ANSIPROPDEF* rgapd = NULL;
    UINT capd  = 0;

    if (IsEqualGUID(fmtid, FMTID_SummaryInformation))
    {
        rgapd = si_lpstr_pids;
        capd  = ARRAYSIZE(si_lpstr_pids);
    }
    else if (IsEqualGUID(fmtid, FMTID_DocSummaryInformation))
    {
        rgapd = dsi_lpstr_pids;
        capd  = ARRAYSIZE(dsi_lpstr_pids);
    }
    else if (IsEqualGUID(fmtid, FMTID_UserDefinedProperties))
    {
        // Note: User defined properties are, by defintion, not defined
        // by the system.  We simply will convert any VT_LPSTR values to VT_LPWSTR.
        if (pvt)
        {
            if ((*pvt) & VT_LPSTR) // forward conversion?
            {
                (*pvt) &= ~VT_LPSTR;
                (*pvt) |= VT_LPWSTR;
                return TRUE;
            }
            else if ((*pvt) & VT_LPWSTR) // reverse conversion?
            {
                (*pvt) &= ~VT_LPWSTR;
                (*pvt) |= VT_LPSTR;
                return TRUE;
            }
        }
    }

    if (rgapd) // search among pre-defined property ids:
    {
        for (UINT i = 0; i < capd; i++)
        {
            if (propid == rgapd[i].propid)
            {
                if (pvt)
                {
                    if (*pvt == rgapd[i].vtConvert) // reverse conversion?
                        *pvt = rgapd[i].vt;
                    else // forward conversion?
                        *pvt = rgapd[i].vtConvert; 
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

// Helper: Properly converts a block of legacy ansi properties read from a 
// prop storage to unicode 

STDAPI _LegacyPropertiesToUnicode(
    REFFMTID       fmtid, 
    UINT           uCodePage, 
    ULONG          cpspec, 
    PROPSPEC const rgpspec[],
    PROPVARIANT    rgvar[])
{
    ASSERT(uCodePage);
    
    HRESULT hr = S_OK;
    if (_IsAnsiPropertySet(fmtid) && (uCodePage != CP_WINUNICODE))
    {
        for (ULONG i = 0; i < cpspec; i++)
        {
            if (VT_LPSTR == rgvar[i].vt)
            {
                // convert in-place to VT_LPWSTR.
                if (rgvar[i].pszVal)
                {
                    LPWSTR  pwszVal;
                    int     cch  = lstrlenA(rgvar[i].pszVal) + 1;
                    
                    if (NULL == (pwszVal = (LPWSTR)CoTaskMemAlloc(CbFromCchW(cch))))
                    {
                        hr = E_OUTOFMEMORY;
                        // reverse what we've already done
                        if (i > 0)
                            _LegacyPropertiesToAnsi(fmtid, uCodePage, i, rgpspec, rgvar);
                        break ;
                    }
                    
                    if (*rgvar[i].pszVal) // non-empty
                    {
                        // if we can't convert using the set's codepage, fall back on CP_UTF8
                        if (!MultiByteToWideChar(uCodePage, 0, rgvar[i].pszVal, -1, pwszVal, cch))
                            SHAnsiToUnicodeCP(CP_UTF8, rgvar[i].pszVal, pwszVal, cch);
                    }
                    else // empty string; why bother converting?
                        *pwszVal = 0;

                    CoTaskMemFree(rgvar[i].pszVal);

                    // assign propvalue.
                    rgvar[i].pwszVal = pwszVal;
                }
                rgvar[i].vt = VT_LPWSTR;
            }
        }
    }
    return hr;
}

// Helper: Properly converts a block of legacy ansi properties from unicode to 
// ansi in preparation for writing back to the storage stream.

STDAPI _LegacyPropertiesToAnsi(
    REFFMTID       fmtid, 
    UINT           uCodePage, 
    ULONG          cpspec, 
    PROPSPEC const rgpspec[],
    PROPVARIANT    rgvar[])
{
    ASSERT(uCodePage);
    
    HRESULT hr = S_OK;
    if (_IsAnsiPropertySet(fmtid) && (uCodePage != CP_WINUNICODE))
    {
        for (ULONG i = 0; i < cpspec; i++)
        {
            if (rgvar[i].vt == VT_LPWSTR)
            {
                // Revert back to ANSI in place
                if (rgvar[i].pwszVal)
                {
                    LPSTR pszVal;
                    // make plenty of room for UTF-8 conversions.  each WCHAR
                    // can turn into as many as three ANSI chars
                    int   cb = MAX_UTF8_CHAR_SIZE * (lstrlenW(rgvar[i].pwszVal) + 1);
                    if (NULL == (pszVal = (LPSTR)CoTaskMemAlloc(cb)))
                    {
                        hr = E_OUTOFMEMORY;
                        if (i > 0) // try to reverse what we've done.
                            _LegacyPropertiesToUnicode(fmtid, uCodePage, i, rgpspec, rgvar);
                        break;
                    }

                    if (*rgvar[i].pwszVal)
                    {
                        // Test round-trip to ANSI and back.  If fails, fall back on CP_UTF8.
                        if (!_DoesStringRoundTripCPW(uCodePage, rgvar[i].pwszVal, pszVal, cb))
                            SHUnicodeToAnsiCP(CP_UTF8, rgvar[i].pwszVal, pszVal, cb);
                    }
                    else
                        *pszVal = 0;

                    CoTaskMemFree(rgvar[i].pwszVal);
                    rgvar[i].pszVal = pszVal;
                }
                rgvar[i].vt = VT_LPSTR;
            }
        }
    }
    return hr;
}

// Helper: Converts the specified ansi string to a universal code page.

STDAPI _UniversalizeAnsiString(IN OUT LPSTR* ppszSrc, IN UINT uCodePage)
{
    ASSERT(ppszSrc);
    ASSERT(uCodePage != CP_UTF8);

    if (!(*ppszSrc))    // NULL string
        return S_FALSE;

    if (!(*ppszSrc)[0]) // empty string; nothing to do.
        return S_OK;
    
    HRESULT hr = E_FAIL;
    LPSTR   pszDest = NULL;
    WCHAR   wszVal[MAX_PATH];
    LPWSTR  pwszVal = wszVal;
    *wszVal = 0;
    
    UINT cch = lstrlenA(*ppszSrc) + 1;
    if (cch > ARRAYSIZE(wszVal))
        pwszVal = new WCHAR[cch];

    if (pwszVal != NULL)
    {
        // convert to Unicode using original codepage
        if (SHAnsiToUnicodeCP(uCodePage, *ppszSrc, pwszVal, cch))
        {
            int cb = MAX_UTF8_CHAR_SIZE * cch;
            if ((pszDest = (LPSTR)CoTaskMemAlloc(cb)) != NULL)
            {
                // convert to ANSI using UTF_8
                if (SHUnicodeToAnsiCP(CP_UTF8, pwszVal, pszDest, cb))
                {
                    CoTaskMemFree(*ppszSrc);
                    *ppszSrc = pszDest;
                    hr = S_OK;
                }
                else
                {
                    CoTaskMemFree(pszDest);
                    hr = E_FAIL;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        
        if (pwszVal != wszVal)
            delete [] pwszVal;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

// Helper: Ensures that any ansi strings in the specified property
// are converted to a universal code page.

STDAPI _UniversalizeProperty(IN OUT PROPVARIANT* pvar, UINT uCodePage)
{
    ASSERT(uCodePage != CP_UTF8);

    HRESULT hr = S_OK;

    if (VT_LPSTR == pvar->vt)
    {
        hr = _UniversalizeAnsiString(&pvar->pszVal, uCodePage);
    }
    else if ((VT_LPSTR | VT_VECTOR) == pvar->vt)
    {
        for (ULONG i = 0; i < pvar->calpstr.cElems; i++)
        {
            HRESULT hrElem = _UniversalizeAnsiString(&pvar->calpstr.pElems[i], uCodePage);
            if (FAILED(hrElem))
                hr = hrElem;
        }
    }
    return hr;
}

// Helper: counts properties in the indicated property set.
ULONG _CountProperties(IEnumSTATPROPSTG* pEnum)
{
    ULONG cRet = 0;

    pEnum->Reset();

    STATPROPSTG stat[20] = {0};
    HRESULT hr;
    do
    {
        ULONG cFetched;
        hr = pEnum->Next(ARRAYSIZE(stat), stat, &cFetched);
        if (SUCCEEDED(hr))
            cRet += cFetched;
    
    }  while (S_OK == hr);

    pEnum->Reset();
    return cRet;
}

// Helper: Ensures that all ansi properties in the indicate set are converted to a 
// universal code page.

STDAPI _UniversalizeSet(IPropertyStorage* pstg, IN OUT UINT* puCodePage, PROPID propidNameFirst)
{
    UINT uCP = *puCodePage;

    if (CP_UTF8 == uCP)
        return S_OK;

    // Enumerate property values
    IEnumSTATPROPSTG* pEnum;
    HRESULT hr = pstg->Enum(&pEnum);
    if (SUCCEEDED(hr))
    {
        ULONG cProps = _CountProperties(pEnum);
        if (cProps > 0)
        {
            STATPROPSTG* rgstat = NULL;
            PROPSPEC*    rgpspec = NULL;
            PROPVARIANT* rgvar  = NULL;

            if ((rgstat  = new STATPROPSTG[cProps]) != NULL &&
                (rgpspec = new PROPSPEC[cProps]) != NULL &&
                (rgvar   = new PROPVARIANT[cProps]) != NULL)
            {
                ULONG        cFetched = 0;
                ZeroMemory(rgstat, cProps * sizeof(*rgstat));

                hr = pEnum->Next(cProps, rgstat, &cFetched);
                
                if (SUCCEEDED(hr) && cFetched > 0)
                {
                    for (ULONG i = 0; i < cFetched; i++)
                    {
                        rgpspec[i].ulKind = PRSPEC_PROPID;
                        rgpspec[i].propid = rgstat[i].propid;
                    }
                    ZeroMemory(rgvar, sizeof(rgvar));

                    // Read properties
                    hr = pstg->ReadMultiple(cFetched, rgpspec, rgvar);
                    if (S_OK == hr)
                    {
                        BOOL bConversionError = FALSE;

                        // Convert properties
                        for (i = 0; i < cFetched; i++)
                        {
                            hr = _UniversalizeProperty(rgvar + i, uCP);
                            if (FAILED(hr))
                            {
                                bConversionError = TRUE;
                                break;
                            }
                        }

                        // Delete set, write out converted values and update PID_CODEPAGE
                        if (!bConversionError)
                        {
                            hr = pstg->DeleteMultiple(cFetched, rgpspec);
                            if (SUCCEEDED(hr))
                            {
                                hr = SHPropStgWriteCP(pstg, CP_UTF8);
                                if (SUCCEEDED(hr))
                                {
                                    *puCodePage = CP_UTF8;     
                                    hr = pstg->WriteMultiple(cFetched, rgpspec, rgvar, propidNameFirst);
                                }
                            }
                        }

                        for (i = 0; i < cFetched; i++)
                            PropVariantClear(rgvar + i);
                    }
                }
            }

            if (rgstat)  delete [] rgstat;
            if (rgpspec) delete [] rgpspec;
            if (rgvar)   delete [] rgvar;
        }
        else if (0 == cProps) // no properties: brand-new, empty set.
        {
            hr = SHPropStgWriteCP(pstg, CP_UTF8);
            if (SUCCEEDED(hr))
            {
                *puCodePage = CP_UTF8;     
            }
        }

        pEnum->Release();
    }

    return hr;
}

// A PROPVARIANT can hold a few more types than a VARIANT can.  We convert the types that are
// only supported by a PROPVARIANT into equivalent VARIANT types.
HRESULT PropVariantToVariant(const PROPVARIANT *pPropVar, VARIANT *pVar)
{
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pPropVar && pVar);

    // if pVar isn't empty, this will properly free before overwriting it
    VariantClear(pVar);

    switch (pPropVar->vt)
    {
    case VT_LPSTR: 
        pVar->bstrVal = SysAllocStringA(pPropVar->pszVal);
        if (pVar->bstrVal)
        {
            pVar->vt = VT_BSTR;
            hr = S_OK;
        }
        break;

    case VT_LPWSTR:
        pVar->bstrVal = SysAllocString(pPropVar->pwszVal);
        if (pVar->bstrVal)
        {
            pVar->vt = VT_BSTR;
            hr = S_OK;
        }
        break;

    case VT_FILETIME:
    {
        SYSTEMTIME st;
        if (FileTimeToSystemTime(&pPropVar->filetime, &st) &&
            SystemTimeToVariantTime(&st, &pVar->date)) // delay load...
        {
            pVar->vt = VT_DATE;
            hr = S_OK;
        }
        break;
    }

    case VT_CLSID:
        if (pVar->bstrVal = SysAllocStringLen(NULL, GUIDSTR_MAX))
        {
            if (SUCCEEDED(SHStringFromGUIDW(*pPropVar->puuid, pVar->bstrVal, GUIDSTR_MAX)))
            {
                pVar->vt = VT_BSTR;
                hr = S_OK;
            }
            else
            {
                SysFreeString(pVar->bstrVal);
                pVar->bstrVal = NULL;
            }
        }
        break;

    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_BLOB_OBJECT:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_CF:
        ASSERT(0); // leave the output cleared
        break;

    case VT_UI4:
        pVar->vt = VT_I4;
        pVar->lVal = (INT)pPropVar->ulVal;
        hr = S_OK;
        break;

    default:
        hr = VariantCopy(pVar, (VARIANT *)pPropVar);
        break;
    }

    return hr;
}


class CPropertyUI : public IPropertyUI
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPropertyUI
    STDMETHODIMP ParsePropertyName(LPCWSTR pwszProperties, FMTID *pfmtid, PROPID *ppid, ULONG *pchEaten);
    STDMETHODIMP GetCannonicalName(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetDisplayName(REFFMTID fmtid, PROPID pid, PROPERTYUI_NAME_FLAGS flags, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetPropertyDescription(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetDefaultWidth(REFFMTID fmtid, PROPID pid, ULONG *pcxChars);
    STDMETHODIMP GetFlags(REFFMTID fmtid, PROPID pid, PROPERTYUI_FLAGS *pdwFlags);
    STDMETHODIMP FormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pvar, 
                                  PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetHelpInfo(REFFMTID fmtid, PROPID pid, LPWSTR pwszHelpFile, DWORD cch, UINT *puHelpID);

    CPropertyUI();

private:
    ~CPropertyUI();

    long _cRef;
};

const PROPUI_INFO *_FindInfoByFMTIDPID(REFFMTID fmtid, PROPID pid);

CPropertyUI::CPropertyUI() : _cRef(1)
{
    DllAddRef();
}

CPropertyUI::~CPropertyUI()
{
    DllRelease();
}

HRESULT CPropertyUI::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CPropertyUI, IPropertyUI),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CPropertyUI::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPropertyUI::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

const PROPUI_INFO *_FindInfoByFMTIDPID(REFFMTID fmtid, PROPID pid)
{
    const PROPUI_INFO *pinfo = NULL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
    {
        if ((pid == c_rgPropUIInfo[i].pscid->pid) && 
            (fmtid == c_rgPropUIInfo[i].pscid->fmtid))
        {
            pinfo = &c_rgPropUIInfo[i];
            break;
        }
    }
    return pinfo;
}

HRESULT _NextProp(LPCWSTR pwszProperties, ULONG *pchEaten, LPWSTR pwszProp, UINT cchProp)
{
    HRESULT hr = E_FAIL;
    ULONG ulStrLen = lstrlenW(pwszProperties);

    *pwszProp = L'\0';
    if (*pchEaten < ulStrLen)
    {
        LPCWSTR pwszStart = pwszProperties + (*pchEaten);
        LPCWSTR pwszSemi = StrChrW(pwszStart, L';');
        if (pwszSemi)
        {
            // make sure its well formed (no dbl slashes)
            if (pwszSemi > pwszStart)
            {
                // Make sure we don't overrun the prop buffer size
                ULONG ulPropLen = (ULONG)(pwszSemi - pwszStart) + 1; // includes L'\0'
                if (ulPropLen > cchProp)
                {
                    ulPropLen = cchProp;
                }
                
                StrCpyNW(pwszProp, pwszStart, ulPropLen);
                // Make sure that there is another segment to return
                if (!*(pwszSemi + 1))
                {
                    pwszSemi = NULL;
                }
                hr = S_OK;
            }
            else
            {
                pwszSemi = NULL;
                hr = E_INVALIDARG;    // bad input
            }
        }
        else
        {
            // No semi-colon; so copy till the end
            StrCpyNW(pwszProp, pwszStart, cchProp);
            hr = S_OK;       
        }

        // Set *pchEaten
        if (pwszSemi)
        {
            *pchEaten = (int)(pwszSemi - pwszProperties) + 1; // Skip ;
        }
        else
        {
            *pchEaten = ulStrLen;
        }
    }
    else
    {
        hr = S_FALSE;     // done with loop
    }
    return hr;
}

#define PROP_PREFIX         TEXT("prop:")
#define PROP_PREFIX_LEN     (ARRAYSIZE(PROP_PREFIX) - 1)

// [in/out] *pchEaten   used to sequence through the property names

STDMETHODIMP CPropertyUI::ParsePropertyName(LPCWSTR pwszProperties, FMTID *pfmtid, PROPID *ppid, ULONG *pchEaten)
{
    // Nobody should call us without a reason
    ASSERT(pfmtid && ppid);
    
    HRESULT hr = E_FAIL;
    WCHAR wszProp[MAX_PATH];
    SHCOLUMNID scid;

    // If pwszProperties starts with prop:, skip it
    if ((*pchEaten == 0)
            && (StrCmpNIW(pwszProperties, PROP_PREFIX, PROP_PREFIX_LEN) == 0))
    {
        *pchEaten += PROP_PREFIX_LEN;
    }
    
    if ((_NextProp(pwszProperties, pchEaten, wszProp, ARRAYSIZE(wszProp)) == S_OK)
            && ParseSCIDString(wszProp, &scid, NULL))
    {
        *pfmtid = scid.fmtid;
        *ppid = scid.pid;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetCannonicalName(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    *pwszText = NULL;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        hr = S_OK;
        StrCpyNW(pwszText, pinfo->pwszName, cchText);
    }
    else if (SHStringFromGUIDW(fmtid, pwszText, cchText))
    {
        WCHAR wszPid[20];   // Pid's can't be longer than 20 chars
        wnsprintfW(wszPid, ARRAYSIZE(wszPid), L"%lu", pid);
        StrCatBuffW(pwszText, wszPid, cchText);
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetDisplayName(REFFMTID fmtid, PROPID pid, PROPERTYUI_NAME_FLAGS flags, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    *pwszText = NULL;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        UINT uID;

        if (flags & PUIFNF_MNEMONIC)
        {
            // Name with mnemonic requested.
            if (pinfo->idMnemonicName)
            {
                // Name with mnemonic defined for scid.
                uID = pinfo->idMnemonicName;
                hr = S_OK;
            }
            else
            {
                // Name with mnemonic NOT defined for scid -- use name without mnemonic as fallback.
                uID = pinfo->idDisplayName;
                hr = S_FALSE;
            }
        }
        else
        {
            // Name without mnemonic requested.
            uID = pinfo->idDisplayName;
            hr = S_OK;
        }

        LoadStringW(HINST_THISDLL, uID, pwszText, cchText);
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetPropertyDescription(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    *pwszText = NULL;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        *pwszText = 0;
        // LoadStringW(HINST_THISDLL, pinfo->idPropertyDescription, pwszText, cchText);
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetDefaultWidth(REFFMTID fmtid, PROPID pid, ULONG *pcxChars)
{
    HRESULT hr = E_FAIL;
    *pcxChars = 0;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        *pcxChars = 20;     // pinfo->nWidth;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetFlags(REFFMTID fmtid, PROPID pid, PROPERTYUI_FLAGS *pdwFlags)
{
    HRESULT hr = E_FAIL;
    *pdwFlags = PUIF_DEFAULT;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        *pdwFlags = PUIF_DEFAULT; // pinfo->dwFlags;
        hr = S_OK;
    }
    return hr;
}

HRESULT _LookupStringFromLong(const STRING_MAP *pMap, ULONG ulVal, LPWSTR pszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    while (pMap->idStr && pMap->uVal != ulVal)
    {
        pMap++;
    }
    if (pMap->idStr)
    {
        LoadString(HINST_THISDLL, pMap->idStr, pszText, cchText);
        hr = S_OK;
    }
    return hr;
}

// expose this method as an API as this is very commonly needed

STDAPI SHFormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, 
                          PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = S_OK;
    *pwszText = 0;

    TCHAR szBuffer[MAX_PATH];

    // Property-specific:
    if (CompareSCIDFMTIDPID(fmtid, pid, SCID_SIZE) ||
        CompareSCIDFMTIDPID(fmtid, pid, SCID_CAPACITY) ||
        CompareSCIDFMTIDPID(fmtid, pid, SCID_FREESPACE))
    {
        ASSERT(pPropVar->vt == VT_UI8);
        StrFormatByteSizeW(pPropVar->uhVal.QuadPart, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_Duration))
    {
        if (pPropVar->vt == VT_EMPTY)
        {
            StrCpyN(pwszText, L"", cchText);
        }
        else
        {
            ASSERT(pPropVar->vt == VT_UI8);
            FILETIME ft = {pPropVar->uhVal.LowPart, pPropVar->uhVal.HighPart};
            SYSTEMTIME st;
            FileTimeToSystemTime(&ft, &st);

            GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, 
                &st, NULL, pwszText, cchText);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_Bitrate) || CompareSCIDFMTIDPID(fmtid, pid, SCID_VIDEO_Bitrate))
    {
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_MUSIC_BITRATE, szBuffer, ARRAYSIZE(szBuffer));
        ASSERT(pPropVar->vt == VT_UI4 || pPropVar->vt == VT_I4)
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal / 1000);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_DRM_Protected)
           ||CompareSCIDFMTIDPID(fmtid, pid, SCID_Scale))
    {
        ASSERT(pPropVar->vt == VT_BOOL);
        UINT uID = (pPropVar->boolVal) ? IDS_PROPERTYUI_YES : IDS_PROPERTYUI_NO;
        LoadString(HINST_THISDLL, uID, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_SampleSize) || CompareSCIDFMTIDPID(fmtid, pid, SCID_VIDEO_SampleSize))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_AV_SAMPLESIZE, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_SampleRate))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_AUDIO_SAMPLERATE, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal / 1000); // 1000: Hz -> kHz
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_ChannelCount))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        switch (pPropVar->ulVal)
        {
        case 1:
            LoadString(HINST_THISDLL, IDS_PROPERTYUI_AUDIO_CHANNELCOUNT1, pwszText, cchText);
            break;
        case 2:
            LoadString(HINST_THISDLL, IDS_PROPERTYUI_AUDIO_CHANNELCOUNT2, pwszText, cchText);
            break;
        default:
            wnsprintf(pwszText, cchText, L"%u", pPropVar->ulVal);

        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_VIDEO_FrameRate))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_VIDEO_FRAMERATE, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal/1000); // 1000 -> convert to frames/second
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ImageCX) || CompareSCIDFMTIDPID(fmtid, pid, SCID_ImageCY))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_PIXELS, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_Flash))             
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cFlashStrings,pPropVar->uiVal,pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ColorSpace))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cColorStrings,pPropVar->uiVal,pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_Media_Status))
    {
        hr = _LookupStringFromLong(g_cMediaStatus, pPropVar->ulVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_MeteringMode))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cMeteringModeStrings, pPropVar->uiVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_LightSource))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cLightSourceStrings, pPropVar->uiVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ExposureProg))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cExposureProgStrings, pPropVar->uiVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ISOSpeed))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_ISO, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ShutterSpeed))
    {
        ASSERT(pPropVar->vt == VT_R8);

        // ShutterSpeed is stored as an APEX value Tv = -log2(Et)
        // we want to display the exposure time so we calculate it as follows
        // Et = 2^(-Tv) then if the value is less than 0.5 then take the inverse
        // so we can represent like 1/250
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vTv = {0};
        hr = PropVariantToVariant(pPropVar, &vTv);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};
            VARIANT vTemp3 = {0};

            hr = VarNeg(&vTv, &vTemp);
            if (SUCCEEDED(hr))
            {
                V_VT(&vTemp2) = VT_R8;
                V_R8(&vTemp2) = 2;

                hr = VarPow(&vTemp2, &vTemp, &vTemp3);
                if (SUCCEEDED(hr))
                {
                    if (V_R8(&vTemp3) > 0.5)
                    {
                        hr = VarRound(&vTemp3, 2, &vTemp);
                        if (SUCCEEDED(hr))
                        {
                            hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                            if (SUCCEEDED(hr))
                            {
                                LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC, szBuffer, ARRAYSIZE(szBuffer));
                                wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                            }
                        }
                    }
                    else
                    {
                        V_VT(&vTemp) = VT_R8;
                        V_R8(&vTemp) = 1;

                        hr = VarDiv(&vTemp, &vTemp3, &vTemp2);
                        if (SUCCEEDED(hr))
                        {
                            hr = VarRound(&vTemp2, 0, &vTemp);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                                if (SUCCEEDED(hr))
                                {
                                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC_FRAC, szBuffer, ARRAYSIZE(szBuffer));
                                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                                }
                            }
                        }
                    }
                }
            }

            VariantClear(&vTv);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
            VariantClear(&vTemp3);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ExposureTime))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // ExposureTime is store as a R8 value if the value is less 
        // than 0.5 then take the inverse so we can represent like 1/250
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vEt = {0};
        hr = PropVariantToVariant(pPropVar, &vEt);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};

            if (V_R8(&vEt) > 0.5)
            {
                hr = VarRound(&vEt, 2, &vTemp);
                if (SUCCEEDED(hr))
                {
                    hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                    if (SUCCEEDED(hr))
                    {
                        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC, szBuffer, ARRAYSIZE(szBuffer));
                        wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                    }
                }
            }
            else
            {
                V_VT(&vTemp) = VT_R8;
                V_R8(&vTemp) = 1;

                hr = VarDiv(&vTemp, &vEt, &vTemp2);
                if (SUCCEEDED(hr))
                {
                    hr = VarRound(&vTemp2, 0, &vTemp);
                    if (SUCCEEDED(hr))
                    {
                        hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                        if (SUCCEEDED(hr))
                        {
                            LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC_FRAC, szBuffer, ARRAYSIZE(szBuffer));
                            wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                        }
                    }
                }
            }

            VariantClear(&vEt);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_Aperture))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Aperture is stored as an APEX value Av = 2*log2(Fn)
        // we want to display the F-number so we calculate it as follows
        // Fn = 2^(Av/2)
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vAv = {0};
        hr = PropVariantToVariant(pPropVar, &vAv);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};
            VARIANT vTemp3 = {0};

            V_VT(&vTemp) = VT_R8;
            V_R8(&vTemp) = 2;

            hr = VarDiv(&vAv, &vTemp, &vTemp2);
            if (SUCCEEDED(hr))
            {
                hr = VarPow(&vTemp, &vTemp2, &vTemp3);
                if (SUCCEEDED(hr))
                {
                    hr = VarRound(&vTemp3, 1, &vTemp);
                    if (SUCCEEDED(hr))
                    {
                        hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                        if (SUCCEEDED(hr))
                        {
                            LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_F, szBuffer, ARRAYSIZE(szBuffer));
                            wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                        }
                    }
                }
            }

            VariantClear(&vAv);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
            VariantClear(&vTemp3);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_FNumber))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Fn is stored as a R8 value that needs to be rounded
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vFn = {0};
        hr = PropVariantToVariant(pPropVar, &vFn);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};

            V_VT(&vTemp) = VT_R8;
            V_R8(&vTemp) = 2;

            hr = VarRound(&vFn, 1, &vTemp);
            if (SUCCEEDED(hr))
            {
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_F, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                }
            }

            VariantClear(&vFn);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_SubjectDist))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Distance is store as a R8 value in meters if the value is less 
        // than 1 then multiple by 1000 to convert to mm
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vD = {0};
        hr = PropVariantToVariant(pPropVar, &vD);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};

            if (V_R8(&vD) >= 1.0)
            {
                hr = VarRound(&vD, 1, &vTemp);
                if (SUCCEEDED(hr))
                {
                    hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                    if (SUCCEEDED(hr))
                    {
                        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_M, szBuffer, ARRAYSIZE(szBuffer));
                        wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                    }
                }
            }
            else
            {
                V_VT(&vTemp) = VT_R8;
                V_R8(&vTemp) = 1000;

                hr = VarMul(&vTemp, &vD, &vTemp2);
                if (SUCCEEDED(hr))
                {
                    hr = VarRound(&vTemp2, 0, &vTemp);
                    if (SUCCEEDED(hr))
                    {
                        hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                        if (SUCCEEDED(hr))
                        {
                            LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_MM, szBuffer, ARRAYSIZE(szBuffer));
                            wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                        }
                    }
                }
            }

            VariantClear(&vD);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_FocalLength))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Focal Length is store as a R8 value in mm
        // so round it and display it
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vLen = {0};
        hr = PropVariantToVariant(pPropVar, &vLen);
        if (SUCCEEDED(hr))
        {
             VARIANT vTemp = {0};

            hr = VarRound(&vLen, 0, &vTemp);
            if (SUCCEEDED(hr))
            {
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_MM, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                }
            }

            VariantClear(&vLen);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_FlashEnergy))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Flash Energy is store as a R8 value in bcps
        // so round it and display it
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vBCPS = {0};
        hr = PropVariantToVariant(pPropVar, &vBCPS);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};

            hr = VarRound(&vBCPS, 0, &vTemp);
            if (SUCCEEDED(hr))
            {
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_BCPS, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                }
            }

            VariantClear(&vBCPS);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ExposureBias))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // ExposureBias is store as a R8 value in steps
        // so round it to the nearest tenth and display 
        // it with a + or minus
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vBias = {0};
        hr = PropVariantToVariant(pPropVar, &vBias);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};

            hr = VarRound(&vBias, 1, &vTemp);
            if (SUCCEEDED(hr))
            {
                TCHAR* pszSign;
                if (V_R8(&vBias) > 0)
                    pszSign = L"+";
                else
                    pszSign = L"";
                
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_STEP, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, pszSign, szFloatBuffer);
                }
            }

            VariantClear(&vBias);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ResolutionX) || CompareSCIDFMTIDPID(fmtid, pid, SCID_ResolutionY))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_DPI, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if ((pPropVar->vt == VT_DATE) || (pPropVar->vt == VT_FILETIME))
    {
        FILETIME ft;
        if (pPropVar->vt == VT_DATE)
        {
            WORD wDosDate, wDosTime;
            if (VariantTimeToDosDateTime(pPropVar->date, &wDosDate, &wDosTime) && wDosDate)
            {
                DosDateTimeToFileTime(wDosDate, wDosTime, &ft);
                hr = S_OK;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            ft = pPropVar->filetime;
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = FDTF_DEFAULT;
            if (flags & PUIFFDF_RIGHTTOLEFT)
            {
                dwFlags |= FDTF_RTLDATE;
            }
            if (flags & PUIFFDF_SHORTFORMAT)
            {
                dwFlags |= FDTF_SHORTDATE;
            }
            if (flags & PUIFFDF_NOTIME)
            {
                dwFlags |= FDTF_LONGDATE;
            }
            if (flags & PUIFFDF_FRIENDLYDATE)
            {
                dwFlags |= (FDTF_RELATIVE | FDTF_LONGDATE);
            }
            
            SHFormatDateTime(&ft, &dwFlags, pwszText, cchText);
        }
    }
    else
    {
        VARIANT var = {0};
        hr = PropVariantToVariant(pPropVar, &var);
        if (SUCCEEDED(hr))
        {
            hr = VariantToStr(&var, pwszText, cchText) ? S_OK : E_OUTOFMEMORY;
            VariantClear(&var);
        }
    }
    return hr;
}

STDMETHODIMP CPropertyUI::FormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, 
                                           PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText)
{
    return SHFormatForDisplay(fmtid, pid, pPropVar, flags, pwszText, cchText);
}

STDMETHODIMP CPropertyUI::GetHelpInfo(REFFMTID fmtid, PROPID pid, LPWSTR pwszHelpFile, DWORD cch, UINT *puHelpID)
{
    HRESULT hr = E_INVALIDARG;  // assume failure
    if (pwszHelpFile && puHelpID)
    {
        *pwszHelpFile = 0;
        *puHelpID = 0;

        const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
        if (pinfo)
        {
            *puHelpID = pinfo->idHelp;
            StrCpyN(pwszHelpFile, L"filefold.hlp", cch);
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);  // close approximation
        }
    }
    return hr;
}

STDAPI CPropertyUI_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CPropertyUI *ppui = new CPropertyUI();
    if (ppui)
    {
        hr = ppui->QueryInterface(riid, ppv);
        ppui->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#if 0
  // this table defines the CI names for properties that we don't yet have CPropertyUI support for

  // Storage Propset
  { 0, L"ClassId",         {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_CLASSID },  36, TRUE,  TRUE, DBTYPE_GUID              },
  { 0, L"FileIndex",       {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_FILEINDEX },   8, TRUE,  TRUE, DBTYPE_UI8               },
  { 0, L"USN",             {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_LASTCHANGEUSN },   8, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"Filename",        {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_NAME }, 15, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"Path",            {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_PATH }, 50, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"Attrib",          {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_ATTRIBUTES },  7, TRUE,  TRUE, DBTYPE_UI4               },

  { 0, L"AllocSize",       {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)18 }, 11, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"Contents",        {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)19 },  0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Query Propset
  { 0, L"RankVector",      {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)2 }, 20, TRUE, TRUE, DBTYPE_UI4|DBTYPE_VECTOR },
  { 0, L"Rank",            {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)3 },  7, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"HitCount",        {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)4 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"WorkId",          {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)5 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"All",             {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)6 },  0, FALSE,TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"VPath",           {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)9 }, 50, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // standard document
  { 0, L"DocSecurity",     {PSGUID_SUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_DOC_SECURITY }, 10, TRUE, TRUE, DBTYPE_I4                },

  // who invented these?
  { 0, L"DocPresentationTarget",  {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)3 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DocPartTitles",   {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)13 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_VECTOR },
  { 0, L"DocManager",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)14 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DocCompany",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)15 }, 10, TRUE, 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prop.h ===
EXTERN_C const SHCOLUMNID SCID_Author;
EXTERN_C const SHCOLUMNID SCID_Title;
EXTERN_C const SHCOLUMNID SCID_Subject;
EXTERN_C const SHCOLUMNID SCID_Category;
EXTERN_C const SHCOLUMNID SCID_Copyright;
EXTERN_C const SHCOLUMNID SCID_CompanyName;
EXTERN_C const SHCOLUMNID SCID_PageCount;
EXTERN_C const SHCOLUMNID SCID_Comment;
EXTERN_C const SHCOLUMNID SCID_DocCreated;
EXTERN_C const SHCOLUMNID SCID_TYPE;
EXTERN_C const SHCOLUMNID SCID_WRITETIME;
EXTERN_C const SHCOLUMNID SCID_CREATETIME;
EXTERN_C const SHCOLUMNID SCID_ACCESSTIME;
EXTERN_C const SHCOLUMNID SCID_OWNER;
EXTERN_C const SHCOLUMNID SCID_NAME;
EXTERN_C const SHCOLUMNID SCID_DELETEDFROM;
EXTERN_C const SHCOLUMNID SCID_DATEDELETED;
EXTERN_C const SHCOLUMNID SCID_SIZE;
EXTERN_C const SHCOLUMNID SCID_SYNCCOPYIN;
EXTERN_C const SHCOLUMNID SCID_STATUS;
EXTERN_C const SHCOLUMNID SCID_DIRECTORY;
EXTERN_C const SHCOLUMNID SCID_RANK;
EXTERN_C const SHCOLUMNID SCID_FREESPACE;
EXTERN_C const SHCOLUMNID SCID_CAPACITY;
EXTERN_C const SHCOLUMNID SCID_FILESYSTEM;
EXTERN_C const SHCOLUMNID SCID_CSC_STATUS;
EXTERN_C const SHCOLUMNID SCID_LINKTARGET;
EXTERN_C const SHCOLUMNID SCID_LASTVISITED;
EXTERN_C const SHCOLUMNID SCID_LASTMODIFIED;
EXTERN_C const SHCOLUMNID SCID_VISITCOUNT;
EXTERN_C const SHCOLUMNID SCID_ATTRIBUTES;
EXTERN_C const SHCOLUMNID SCID_ATTRIBUTES_DESCRIPTION;
EXTERN_C const SHCOLUMNID SCID_LOCATION;
EXTERN_C const SHCOLUMNID SCID_FINDDATA;
EXTERN_C const SHCOLUMNID SCID_NETRESOURCE;
EXTERN_C const SHCOLUMNID SCID_DESCRIPTIONID;
EXTERN_C const SHCOLUMNID SCID_WHICHFOLDER;
EXTERN_C const SHCOLUMNID SCID_NETWORKLOCATION;
EXTERN_C const SHCOLUMNID SCID_COMPUTERNAME;
EXTERN_C const SHCOLUMNID SCID_DetailsProperties;
EXTERN_C const SHCOLUMNID SCID_FolderIntroText;
EXTERN_C const SHCOLUMNID SCID_CONTROLPANELCATEGORY;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Artist;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Album;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Year;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Track;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Genre;
EXTERN_C const SHCOLUMNID SCID_AUDIO_Duration;
EXTERN_C const SHCOLUMNID SCID_AUDIO_Bitrate;
EXTERN_C const SHCOLUMNID SCID_ImageCX;
EXTERN_C const SHCOLUMNID SCID_ImageCY;
EXTERN_C const SHCOLUMNID SCID_ImageDimensions;
EXTERN_C const SHCOLUMNID SCID_CameraModel;
EXTERN_C const SHCOLUMNID SCID_WhenTaken;
EXTERN_C const SHCOLUMNID SCID_Flash;
EXTERN_C const SHCOLUMNID SCID_ColorSpace;
EXTERN_C const SHCOLUMNID SCID_DRM_Protected;

// Printer Folder column identifier defs...
EXTERN_C const SHCOLUMNID SCID_PRN_QUEUESIZE;
EXTERN_C const SHCOLUMNID SCID_PRN_STATUS;
EXTERN_C const SHCOLUMNID SCID_PRN_LOCATION;
EXTERN_C const SHCOLUMNID SCID_PRN_MODEL;

//  Win32 PE (exe, dll) Version Information column identifier defs...
EXTERN_C const SHCOLUMNID SCID_FileDescription;
EXTERN_C const SHCOLUMNID SCID_FileVersion;
EXTERN_C const SHCOLUMNID SCID_InternalName;
EXTERN_C const SHCOLUMNID SCID_OriginalFileName;
EXTERN_C const SHCOLUMNID SCID_ProductName;
EXTERN_C const SHCOLUMNID SCID_ProductVersion;

typedef struct {
    const SHCOLUMNID *pscid;
    VARTYPE vt;             // Note that the type of a given FMTID/PID pair is a known, fixed value
    DWORD fmt;              // listview format (LVCFMT_LEFT, usually)
    UINT cChars;            // count of chars (default col width)
    DWORD csFlags;          // SHCOLSTATE flags
    UINT idTitle;           // string id for title
    UINT idDescription;     // add these, make defview display them too!
} COLUMN_INFO;

#define DEFINE_COL_ENTRY(scid, vt, fmt, cChars, shcs, ids) \
    { &scid, vt, fmt, cChars, shcs, ids, 0 }

#define DEFINE_COL_STR_ENTRY(scid, cChars, ids) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT, ids, 0 }

#define DEFINE_COL_STR_MENU_ENTRY(scid, cChars, ids) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_STR, ids, 0 }

#define DEFINE_COL_STR_DLG_ENTRY(scid, cChars, ids) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_STR | SHCOLSTATE_SECONDARYUI, ids, 0 }

#define DEFINE_COL_STR_HIDDEN_ENTRY(scid) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN, 0, 0 }

#define DEFINE_COL_DATE_ENTRY(scid, ids) \
    { &scid, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_ONBYDEFAULT, ids, 0 }

#define DEFINE_COL_DATE_HIDDEN_ENTRY(scid) \
    { &scid, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_HIDDEN, 0, 0 }

#define DEFINE_COL_INT_ENTRY(scid, cChars, ids) \
    { &scid, VT_I4, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_INT | SHCOLSTATE_ONBYDEFAULT, ids, 0 }

#define DEFINE_COL_INT_DLG_ENTRY(scid, cChars, ids) \
    { &scid, VT_I4, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_INT | SHCOLSTATE_SECONDARYUI, ids, 0 }

#define DEFINE_COL_INT_HIDDEN_ENTRY(scid) \
    { &scid, VT_I4, LVCFMT_LEFT, 5, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN, 0, 0 }

#define DEFINE_COL_SIZE_ENTRY(scid, ids) \
    DEFINE_COL_ENTRY(scid, VT_UI8, LVCFMT_RIGHT, 16, SHCOLSTATE_TYPE_INT | SHCOLSTATE_ONBYDEFAULT, ids)


STDAPI GetDetailsOfInfo(const COLUMN_INFO* pcol_data, UINT nCols, UINT iColumn, SHELLDETAILS *pdi);
STDAPI_(int) FindSCID(const COLUMN_INFO* pcol_data, UINT nCols, const SHCOLUMNID* pscid);
STDAPI MapColumnToSCIDImpl(const COLUMN_INFO* pcol_data, UINT nCols, UINT iColumn, SHCOLUMNID* pscid);
STDAPI_(BOOL) ParseSCIDString(LPCTSTR pszString, SHCOLUMNID *pscid, UINT *pidRes);
STDAPI SCIDCannonicalName(SHCOLUMNID *pscid, LPTSTR pszName, int cch);
HRESULT PropVariantToVariant(const PROPVARIANT *pPropVar, VARIANT *pVar);

#define CompareSCIDFMTIDPID(fmtid, pid, scid)   ((pid == (scid).pid) && IsEqualIID(fmtid, (scid).fmtid))
#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

//
// Constants used while converting a SCID to a string
//
#define SCID_PIDSTR_MAX     10   // will take care of any long integer value  
#define SCIDSTR_MAX         (GUIDSTR_MAX + 1 + SCID_PIDSTR_MAX)

STDAPI_(int) StringFromSCID(const SHCOLUMNID *pscid, LPTSTR lpsz, UINT cch);

STDAPI SHFormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, 
                          PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\proxynt.c ===
#include "shellprv.h"
#pragma  hdrstop

#ifdef _X86_

STDAPI PIF_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    STGMEDIUM medium;
    FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    HRESULT hr = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);
    if (SUCCEEDED(hr))
    {
        HDROP hdrop = (HDROP)GlobalLock(medium.hGlobal);
        if (hdrop)
        {
            PifMgrDLL_Init();       // Initialize pif stuff

            PifPropGetPages(hdrop, pfnAddPage, lParam);
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prshtcpp.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "prshtcpp.h"
#include "propsht.h"
#include "treewkcb.h"   // for CBaseTreeWalkerCB class
#include "ftascstr.h"   // for CFTAssocStore
#include "ftcmmn.h"     // for MAX_APPFRIENDLYNAME
#include "ascstr.h"     // for IAssocInfo class

//
// Folder attribute tree waker class
//
class CFolderAttribTreeWalker : public CBaseTreeWalkerCB
{
public:
    // constructor
    CFolderAttribTreeWalker(FILEPROPSHEETPAGE* pfpsp);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

protected:
    FILEPROPSHEETPAGE *_pfpsp;
};


CFolderAttribTreeWalker::CFolderAttribTreeWalker(FILEPROPSHEETPAGE* pfpsp): _pfpsp(pfpsp)
{
}


HRESULT CFolderAttribTreeWalker::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW* pwfd)
{
    HWND hwndParent = NULL;
    TCHAR szFileName[MAX_PATH];
    ULARGE_INTEGER ulSizeOnDisk;
    BOOL bSomethingChanged;

    // check to see if the user hit cancel on the progress dlg
    if (HasUserCanceledAttributeProgressDlg(_pfpsp))
    {
        return E_FAIL;
    }

    if (_pfpsp->pProgressDlg)
    {
        // if we have a progress hwnd, try to use it
        // this will fail if the progress dialog hasent been displayed yet.
        IUnknown_GetWindow(_pfpsp->pProgressDlg, &hwndParent);
    }

    if (!hwndParent)
    {
        // if we dont have a progress hwnd, use the property page hwnd
        hwndParent = GetParent(_pfpsp->hDlg);
    }

    // thunk the pwszFile string
    SHUnicodeToTChar(pwszFile, szFileName, ARRAYSIZE(szFileName));

    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        // (reinerf) - in the directory case, we set the size to zero since the
        // FolderSize() function dosen't add in the sizes of directories, and we need
        // the sizes to match when doing progress calcuations.
        _pfpsp->fd.nFileSizeLow = 0;
        _pfpsp->fd.nFileSizeHigh = 0;
    }
    else
    {
        // if compression is supported, we check to see if the file is sparse or compressed
        if (_pfpsp->pfci->fIsCompressionAvailable && (pwfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)))
        {
            ulSizeOnDisk.LowPart = SHGetCompressedFileSize(szFileName, &ulSizeOnDisk.HighPart);
        }
        else
        {
            // the file isint comrpessed so just round to the cluster size
            ulSizeOnDisk.LowPart = pwfd->nFileSizeLow;
            ulSizeOnDisk.HighPart = pwfd->nFileSizeHigh;
            ulSizeOnDisk.QuadPart = ROUND_TO_CLUSTER(ulSizeOnDisk.QuadPart, ptws->dwClusterSize);
        }

        // we set this so the progress dialog knows how much to update the progress slider
        _pfpsp->fd.nFileSizeLow = ulSizeOnDisk.LowPart;
        _pfpsp->fd.nFileSizeHigh = ulSizeOnDisk.HighPart;
    }

    if (!ApplyFileAttributes(szFileName, _pfpsp, hwndParent, &bSomethingChanged))
    {
        // the user hit cancel, so stop
        return E_FAIL;
    }

    return S_OK;
}
 
HRESULT CFolderAttribTreeWalker::EnterFolder(LPCWSTR pwszDir, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW* pwfd)
{
    return FoundFile(pwszDir, ptws, pwfd);
}

STDAPI_(BOOL) ApplyRecursiveFolderAttribs(LPCTSTR pszDir, FILEPROPSHEETPAGE* pfpsp)
{
    HRESULT hrInit = SHCoInitialize();

    HRESULT hr = E_FAIL;
    CFolderAttribTreeWalker* pfatw = new CFolderAttribTreeWalker(pfpsp);
    if (pfatw)
    {
        IShellTreeWalker *pstw;
        hr = CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &pstw));
        if (SUCCEEDED(hr))
        {
            hr = pstw->WalkTree(WT_NOTIFYFOLDERENTER, pszDir, NULL, 0, SAFECAST(pfatw, IShellTreeWalkerCallBack*));
            pstw->Release();
        }
        pfatw->Release();
    }
    SHCoUninitialize(hrInit);

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//
// Checks the progress dialog to see if the user has hit cancel
//
STDAPI_(BOOL) HasUserCanceledAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp)
{
    BOOL fReturn = FALSE;

    if (pfpsp && pfpsp->pProgressDlg)
    {
        fReturn = pfpsp->pProgressDlg->HasUserCancelled();
    }

    return fReturn;
}


//
// Creates the CProgressDialog object used by the attribs dlg
//
STDAPI_(BOOL) CreateAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp)
{
    WCHAR wzBuffer[MAX_PATH];

    ASSERT(pfpsp->pfci->fMultipleFiles || pfpsp->fRecursive);
    
    // create the progress dialog as a modal window
    pfpsp->pProgressDlg = CProgressDialog_CreateInstance(IDS_APPLYINGATTRIBS, IDA_APPLYATTRIBS, HINST_THISDLL);

    if (!pfpsp->pProgressDlg)
    {
        // couldn't create a progress dialog, so bail
        return FALSE;
    }

    // set the static string "Applying Attrbiutes to:"
    LoadStringW(HINST_THISDLL, IDS_APPLYINGATTRIBSTO, wzBuffer, ARRAYSIZE(wzBuffer));
    pfpsp->pProgressDlg->SetLine(1, wzBuffer, FALSE, NULL);

    pfpsp->pProgressDlg->StartProgressDialog(GetParent(pfpsp->hDlg), NULL, (PROGDLG_MODAL | PROGDLG_AUTOTIME), NULL);
    return TRUE;
}


//
// Delets the CProgressDialog object used by the attribs dlg
//
STDAPI_(BOOL) DestroyAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp)
{
    if (!pfpsp->pProgressDlg)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    pfpsp->pProgressDlg->StopProgressDialog();
    pfpsp->pProgressDlg->Release();
    pfpsp->pProgressDlg = NULL;

    // reset NumberOfBytesDone so we are back to zero if the user tries something else,
    // we will start over at zero
    pfpsp->ulNumberOfBytesDone.QuadPart = 0;
    pfpsp->cItemsDone = 0;
    
    return TRUE;
}


//
// Sets the current file we are applying attribs for in the progress dlg
//
STDAPI SetProgressDlgPath(FILEPROPSHEETPAGE* pfpsp, LPCTSTR pszPath, BOOL fCompactPath)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pfpsp->pProgressDlg);
    if (pfpsp && pfpsp->pProgressDlg)
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
        hr = pfpsp->pProgressDlg->SetLine(2, wzPath, fCompactPath, NULL);
    }

    return hr;
}


//
// Updates the progress bar in the dlg
//
STDAPI UpdateProgressBar(FILEPROPSHEETPAGE* pfpsp)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pfpsp->pProgressDlg);
    if (pfpsp && pfpsp->pProgressDlg)
    {
        pfpsp->cItemsDone++;
    
        // if we are not changing compression or encryption, then
        // do progress based on the number of items we are applying to.
        if (pfpsp->asCurrent.fCompress == pfpsp->asInitial.fCompress &&
            pfpsp->asCurrent.fEncrypt == pfpsp->asInitial.fEncrypt)
        {
            if (pfpsp->fRecursive)
            {
                //progress is based on number of items done out of total items in all folders
                hr = pfpsp->pProgressDlg->SetProgress(pfpsp->cItemsDone, pfpsp->pfci->cFiles + pfpsp->pfci->cFolders);
            }
            else
            {
                //progress is based on number of items done out of total selected items
                hr = pfpsp->pProgressDlg->SetProgress(pfpsp->cItemsDone, HIDA_GetCount(pfpsp->pfci->hida));
            }
        }
        else
        {
            // since we are either encrypting or compressing, we do progress based on the sizes of the files
            hr = pfpsp->pProgressDlg->SetProgress64(pfpsp->ulNumberOfBytesDone.QuadPart, pfpsp->pfci->ulTotalNumberOfBytes.QuadPart);
        }
    }

    return hr;
}


// we dynamically size the text depeneding on whether or not the small icon is visible and
// if the "Change..." button is visible
void SizeOpensWithTextBox(FILEPROPSHEETPAGE* pfpsp, BOOL bIsSmallIconVisible, BOOL bIsOpensWithEnabled)
{
    RECT rcArray[3]; // array of three rects: the IDD_TYPEICON rect, the IDC_CHANGEFILETYPE rect, and the IDD_OPENSWITH rect
    RECT* prcSmallIcon = &rcArray[0];
    RECT* prcChangeButton = &rcArray[1];
    RECT* prcText = &rcArray[2];
    BOOL  bFailed = FALSE;

    GetWindowRect(GetDlgItem(pfpsp->hDlg, IDD_TYPEICON), &rcArray[0]);
    GetWindowRect(GetDlgItem(pfpsp->hDlg, IDC_CHANGEFILETYPE), &rcArray[1]);
    GetWindowRect(GetDlgItem(pfpsp->hDlg, IDD_OPENSWITH), &rcArray[2]);

    // map the rects into dlg coordiates
    // MapWindowPoints is mirroring aware only when you pass one rect. let's loop.
    for (int i =0; i < ARRAYSIZE(rcArray); i++ )
    {
        if(!(MapWindowPoints(NULL, pfpsp->hDlg, (LPPOINT)(&rcArray[i]), 2)))
        {
            bFailed = TRUE;
            break;
        }
    }
    if (!bFailed)
    {
        RECT rcTemp = {0,0,4,0}; // we need to find out how many pixels are in 4 DLU's worth of witdth

        MapDialogRect(pfpsp->hDlg, &rcTemp);

        if (bIsSmallIconVisible)
        {
            prcText->left = prcSmallIcon->right + rcTemp.right; // spacing between controls is 4 DLU's
        }
        else
        {
            prcText->left = prcSmallIcon->left;
        }

        if (bIsOpensWithEnabled)
        {
            prcText->right = prcChangeButton->left - rcTemp.right; // spacing between controls is 4 DLU's
        }
        else
        {
            prcText->right = prcChangeButton->right;
        }

        SetWindowPos(GetDlgItem(pfpsp->hDlg, IDD_OPENSWITH),
                     HWND_BOTTOM,
                     prcText->left,
                     prcText->top,
                     (prcText->right - prcText->left),
                     (prcText->bottom - prcText->top),
                     SWP_NOZORDER);
    }
}

// this function sets the "Opens With:" / "Description:" text based on whether or not 
// we are allowed to change the assocation, and enables / disables the "Opens With..." button
void SetDescriptionAndOpensWithBtn(FILEPROPSHEETPAGE* pfpsp, BOOL fAllowModifyOpenWith)
{
    TCHAR szOpensWithText[MAX_PATH];

    LoadString(HINST_THISDLL, fAllowModifyOpenWith ? IDS_OPENSWITH : IDS_DESCRIPTION, szOpensWithText, ARRAYSIZE(szOpensWithText));
    SetDlgItemText(pfpsp->hDlg, IDD_OPENSWITH_TXT, szOpensWithText);
    
    // enable/disable the "Change..." button accordingly
    EnableAndShowWindow(GetDlgItem(pfpsp->hDlg, IDC_CHANGEFILETYPE), fAllowModifyOpenWith);
}

// set the Friendly Name text (eg the text to the right of the "Opens With:" / "Description:" field
void SetFriendlyNameText(LPTSTR pszPath, FILEPROPSHEETPAGE* pfpsp, IAssocInfo* pai, BOOL bIsSmallIconVisible)
{
    TCHAR szAppFriendlyName[MAX_PATH];
    DWORD cchFriendlyName = ARRAYSIZE(szAppFriendlyName);
    szAppFriendlyName[0] = TEXT('\0');

    if (pai)
    {
        if (FAILED(pai->GetString(AISTR_APPFRIENDLY, szAppFriendlyName, &cchFriendlyName)))
        {
            // if we failed, it could mean that this app is not associated yet. in this
            // case we just use "Unknown Applicaion"
            LoadString(HINST_THISDLL, IDS_UNKNOWNAPPLICATION, szAppFriendlyName, ARRAYSIZE(szAppFriendlyName));
        }
    }
    else
    {
        UINT cchBuff = (UINT)cchFriendlyName;

        // get the friendly name from the file itself
        if (!pszPath || !pszPath[0] || !GetFileDescription(pszPath, szAppFriendlyName, &cchBuff))
        {
            // use the short name as it appears in the "rename" edit box if something above didnt work
            // (ok to truncate since this is for display purpose only)
            StringCchCopy(szAppFriendlyName, ARRAYSIZE(szAppFriendlyName), pfpsp->szInitialName);
        }
    }

    ASSERT(szAppFriendlyName[0]);

    SetDlgItemTextWithToolTip(pfpsp->hDlg, IDD_OPENSWITH, szAppFriendlyName, &pfpsp->hwndTip);


    // size and position the text properly depending on wether the small icon is visible and
    // the state of the "Change..." button
    SizeOpensWithTextBox(pfpsp, bIsSmallIconVisible, IsWindowEnabled(GetDlgItem(pfpsp->hDlg, IDC_CHANGEFILETYPE)));
}

// sets the small icon in the description field
//
// return value:  TRUE  - a small icon is visible
//                FALSE - small icon was not set
//
BOOL SetSmallIcon(FILEPROPSHEETPAGE* pfpsp, IAssocInfo* pai, BOOL fAllowModifyOpenWith)
{
    HICON hIcon = NULL;
    HICON hIconOld = NULL;
    int iIcon;
    BOOL bShowSmallIcon;
    
    // only setup the small icon of the associated app if we have the "Change..." button 
    // and we were able to get the friendly name.
    if (fAllowModifyOpenWith && pai && SUCCEEDED(pai->GetDWORD(AIDWORD_APPSMALLICON, (DWORD*)&iIcon)))
    {
        HIMAGELIST hIL = NULL;

        Shell_GetImageLists(NULL, &hIL);
        if (hIL)
        {
            hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIcon);
        }
    }

    // we will show the small icon if we got one and if we are allowed to modify the opens with
    bShowSmallIcon = (hIcon != NULL);

    hIconOld = (HICON)SendDlgItemMessage(pfpsp->hDlg, IDD_TYPEICON, STM_SETICON, (WPARAM)hIcon, 0);

    if (hIconOld)
        DestroyIcon(hIconOld);

    // enable/disable the IDD_TYPEICON icon accordingly
    EnableAndShowWindow(GetDlgItem(pfpsp->hDlg, IDD_TYPEICON), bShowSmallIcon);

    return bShowSmallIcon;
}

//
// We use this to set the text for the associated application and other goodies
//
STDAPI UpdateOpensWithInfo(FILEPROPSHEETPAGE* pfpsp)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    IAssocStore* pas = NULL;
    IAssocInfo* pai = NULL;
    BOOL fAllowChangeAssoc = TRUE;
    BOOL fAllowModifyOpenWith = TRUE;
    BOOL fIsLink = FALSE;
    BOOL bShowSmallIcon;
    
    szPath[0] = TEXT('\0');

    // We need to check to see if this is a link. If so, then we need to get the information for
    // the link target
    if (pfpsp->fIsLink)
    {
        if (S_OK != GetPathFromLinkFile(pfpsp->szPath, szPath, ARRAYSIZE(szPath)))
        {
            // we failed for some strange reason, perhaps its a darwin link,
            // we just treat the file as if it were not a link. And we do not let
            // the user change the association
            fAllowModifyOpenWith = FALSE;
            pfpsp->fIsLink = FALSE;
        }
        else
        {
            // if the link target didn't change, we dont need to update anything
            if (pfpsp->szLinkTarget[0] && lstrcmpi(pfpsp->szLinkTarget, szPath) == 0)
            {
                return S_FALSE;
            }
        }
    }
    else
    {
        // just use the path of the file since it is not a link. pass null-on-failure so we don't display
        // information for the wrong file type if the path is > MAX_PATH.
        StringCchCopyEx(szPath, ARRAYSIZE(szPath), pfpsp->szPath, NULL, NULL, STRSAFE_NULL_ON_FAILURE);
    }

    // if we haven't initialized the AssocStore, do so now
    pas = (IAssocStore*)pfpsp->pAssocStore;
    if (!pas)
    {
        pas = new CFTAssocStore();
        pfpsp->pAssocStore = (void *)pas;
    }

    if (!pfpsp->pAssocStore)
    {
        // if we couldn't make an AssocStore, so bail
        return E_OUTOFMEMORY;
    }

    LPTSTR pszExt = PathFindExtension(szPath);
    if (PathIsExe(szPath) || !szPath[0] || *pszExt == TEXT('\0'))
    {
        // this file is an .exe (or .com, .bat, etc) or GetPathFromLinkFile returned a 
        // null path (eg link to a special folder) or the file has no extension (eg 'c:\foo.',
        // or 'c:\'), then we dont want the user to be able to change the association since 
        // there isint one.
        fAllowModifyOpenWith = FALSE;
    }

    if (fAllowModifyOpenWith)
    {
        // get the AssocInfo for this file, based on its extension
        hr = pas->GetAssocInfo(pszExt, AIINIT_EXT, &pai);

#ifdef DEBUG
        if (FAILED(hr))
        {
            ASSERT(pai == NULL);
        }
#endif
    }

    if (SHRestricted(REST_NOFILEASSOCIATE))
    {
        // we are not allowed to change file assocoations, so remove the opens with button
        fAllowModifyOpenWith = FALSE;
    }

    SetDescriptionAndOpensWithBtn(pfpsp, fAllowModifyOpenWith);
    bShowSmallIcon = SetSmallIcon(pfpsp, pai, fAllowModifyOpenWith);
    SetFriendlyNameText(szPath, pfpsp, pai, bShowSmallIcon);

    if (pai)
    {
        pai->Release();
    }

    // save off the link target so we only update the stuff above when the target changes.
    if (pfpsp->fIsLink)
    {
        // use null-on-failure so if it is too big we will fail the lstrcmpi call above and always update
        StringCchCopyEx(pfpsp->szLinkTarget, ARRAYSIZE(pfpsp->szLinkTarget), szPath, NULL, NULL, STRSAFE_NULL_ON_FAILURE);
    }
    else
    {
        // its not a link so reset the link target to the empty string
        pfpsp->szLinkTarget[0] = TEXT('\0');
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\propsht.h ===
#ifndef _MULPRSHT_H
#define _MULPRSHT_H

#include "idlcomm.h" // for HIDA
#include "ids.h"

// we recycle this string from the printer stringtable in shell32.rc
#define IDS_UNKNOWNERROR IDS_PRTPROP_UNKNOWNERROR

#define IDT_SIZE 1

// file attribute state
typedef struct 
{
    DWORD   fReadOnly;      // each dword is one of BST_CHECKED, BST_UNCHECKED, or BST_INDETERMINATE 
    DWORD   fHidden;
    DWORD   fArchive;     
    DWORD   fIndex;
    DWORD   fCompress;
    DWORD   fEncrypt;
    DWORD   fRecordingEnabled;
} ATTRIBUTESTATE;

typedef struct _FILEPROPSHEETPAGE FILEPROPSHEETPAGE;

// FOLDERCONTENTSINFO includes members which are referenced across UI Thread and Size Thread.
typedef struct {
    LONG            _cRef;
    BOOL            fIsSizeThreadAlive;
    HWND            hDlg;
    BOOL            bContinue;      // tell thread to stop or mark as done
    ULONGLONG       cbSize;         // total size of all files in folder
    ULONGLONG       cbActualSize;   // total size on disk, taking into account compression and cluster slop
    DWORD           dwClusterSize;  // the size of a cluster
    int             cFiles;         // # files in folder
    int             cFolders;       // # folders in folder
    TCHAR           szPath[MAX_PATH];
    WIN32_FIND_DATA fd;             // for thread stack savings
    HIDA            hida;
    BOOL            fMultipleFiles;             // are there multiple files?
    BOOL            fIsCompressionAvailable;    // is comrpession supported on the volume?
    ULARGE_INTEGER  ulTotalNumberOfBytes;       // total # of bytes to apply attributes to (for progress dlg)
} FOLDERCONTENTSINFO;

typedef struct _FILEPROPSHEETPAGE
{
    PROPSHEETPAGE       psp;
    BOOL                fMountedDrive;              // Are we dealing with a mounted drive or not?
    BOOL                fIsLink;                    // Is this a .lnk file?

    //the following fields are used by both the structures
    HWND                hDlg;
    TCHAR               szPath[MAX_PATH];           // full path to the file (single file case)
    LPITEMIDLIST        pidl;                       // pidl for the item == NULL if not initialized
    TCHAR               szLinkTarget[MAX_PATH];     // full path of link target (if the file is a .lnk)
    ATTRIBUTESTATE      asInitial;                  // initial file attribute state
    ATTRIBUTESTATE      asCurrent;                  // current file attribute state
    BOOL                fIsEncryptionAvailable;     // is encryption supported on the volume?
    BOOL                fIsIndexAvailable;          // is conten indexing supported in the filesystem?

    //This is used only by the single file dialog proc
    LPVOID              pAssocStore;                // pointer to the Association Store, we use it to query type info
    IProgressDialog*    pProgressDlg;               // pointer to the IProgressDialog object
    ULARGE_INTEGER      ulNumberOfBytesDone;        // # of bytes that we have already applied attribs to (for progress dlg)    
    FOLDERCONTENTSINFO* pfci;                       // the background size thread fills this structure with size info
    WIN32_FIND_DATA     fd;                         // info about the file we are currently applying attribs to
    HWND                hwndTip;                    // window handle for location tooltip
    HDPA                hdpaBadFiles;               // this dpa holds the names of the files that we dont want to apply attribs to

    TCHAR               szInitialName[MAX_PATH];    // the original "short" name we display in the edit box

    BOOL                fWMInitFinshed;             // are we finished processing the WM_INITDIALOG message (needed for rename)
    BOOL                fRecursive;                 // should we recurse into subdirs when applying attributes?
    BOOL                fIsDirectory;               // is this file a directory (in multiple files case: are any of the files a directory?)
    BOOL                fIsExe;                     // if this is an .exe, we ask if they want to support user logon
    BOOL                fRename;                    // has the user renamed the file/folder?
    BOOL                fIgnoreAllErrors;           // has the user hit "ignore all" to the error message?
    BOOL                fShowExtension;             // are we showing the real extension for this file in the name editbox?
    BOOL                fFolderShortcut;

    int                 cItemsDone;                 // Number of items we have already applied attribs to (for progress dlg)
    BOOL                fDisableRename;             // Should the name edit box be disabled?

    //The following is used only by the mounted drv dialog proc
    int                 iDrive;                     // Drive id of the mounted drive if there is one
    TCHAR               szFileSys[48];              // file system name.
    BOOL                fCanRename;                 // is the name a valid name for renaming?

    // Folder shortcut specific stuff.
    LPITEMIDLIST        pidlTarget;
    BOOL                fValidateEdit;
} FILEPROPSHEETPAGE;

typedef struct 
{
    PROPSHEETPAGE   psp;

    HWND            hDlg;

    //szDrive will contain the mountpoint (e.g. c:\ or c:\folder\folder2\)
    TCHAR           szDrive[MAX_PATH];
    int             iDrive;

    _int64          qwTot;
    _int64          qwFree;

    DWORD           dwPieShadowHgt;

    ULARGE_INTEGER  ulTotalNumberOfBytes;       // total # of bytes to apply attributes to (for progress dlg)
    ATTRIBUTESTATE  asInitial;                  // initial attribute state
    ATTRIBUTESTATE  asCurrent;                  // current attribute state

    BOOL            fIsCompressionAvailable;    // is file-based compression available on this volume (NTFS?)
    BOOL            fIsIndexAvailable;   // is content indexing available on this volume?
    BOOL            fRecursive;                 // should we recurse into subdirs when applying attributes?
    BOOL            fMountedDrive;              // is the proppage invoked from mounted point proppage
} DRIVEPROPSHEETPAGE;

typedef struct 
{
    LPCTSTR pszPath;
    DWORD dwLastError;
} ATTRIBUTEERROR;

STDAPI_(BOOL) ApplyFileAttributes(LPCTSTR pszPath, FILEPROPSHEETPAGE* pfpsp, HWND hWndParent, BOOL* pbSomethingChanged);
STDAPI_(BOOL) ApplySingleFileAttributes(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL_PTR) CALLBACK RecursivePromptDlgProc(HWND hDlgRecurse, UINT uMessage, WPARAM wParam, LPARAM lParam);
STDAPI_(void) SetDateTimeText(HWND hdlg, int id, const FILETIME *pftUTC);
STDAPI_(void)SetDateTimeTextEx(HWND hdlg, int id, const FILETIME *pftUTC, DWORD dwFlags);
STDAPI_(DWORD) GetVolumeFlags(LPCTSTR pszPath, OUT OPTIONAL LPTSTR pszFileSys, int cchFileSys);
STDAPI_(void) SetInitialFileAttribs(FILEPROPSHEETPAGE* pfpsp, DWORD dwFlags, DWORD dwMask);
BOOL_PTR CALLBACK AdvancedFileAttribsDlgProc(HWND hDlgAttribs, UINT uMessage, WPARAM wParam, LPARAM lParam);
STDAPI_(void) SetDlgItemTextWithToolTip(HWND hDlg, UINT id, LPCTSTR pszText, HWND *phwndTT);

STDAPI_(FOLDERCONTENTSINFO*) Create_FolderContentsInfo();
STDAPI_(LONG) AddRef_FolderContentsInfo(FOLDERCONTENTSINFO *pfci);
STDAPI_(LONG) Release_FolderContentsInfo(FOLDERCONTENTSINFO *pfci);
STDAPI InitCommonPrsht(FILEPROPSHEETPAGE *pfpsp);

STDAPI FolderSize(LPCTSTR pszDir, FOLDERCONTENTSINFO * pfci);

#endif // _MULPRSHT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prshtcpp.h ===
#ifndef _PRSHTCPP_INC
#define _PRSHTCPP_INC

#include "propsht.h"

// attrib treewalkcb
STDAPI_(BOOL) ApplyRecursiveFolderAttribs(LPCTSTR pszDir, FILEPROPSHEETPAGE* pfpsp);

// progress dlg
STDAPI_(BOOL) CreateAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) DestroyAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI SetProgressDlgPath(FILEPROPSHEETPAGE* pfpsp, LPCTSTR pszPath, BOOL fCompactPath);
STDAPI UpdateProgressBar(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) HasUserCanceledAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(HWND) GetProgressWindow(FILEPROPSHEETPAGE* pfpsp);

// assoc store stuff
STDAPI UpdateOpensWithInfo(FILEPROPSHEETPAGE* pfpsp);

#endif // _PRSHTCPP_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\psdocurd.c ===
// PSeuDO CURrentDirectory module (psdocurd.c)
//
// This was swiped from cmd.exe sources to use the environment to emulate
// per process per drive current directory stuff.
//
// This uses the special '=A:=' environment strings to remember the
// current directories.
//
// Since the library is a DLL, all globals are process based.
//
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

#define SUCCESS FALSE
#define FAILURE TRUE
#define GD_DEFAULT 0

WCHAR CurDrvDirW[MAX_PATH] = L"";

#define DBL_BSLASH(sz) \
    (*(WCHAR *)(sz) == CHAR_BSLASH) && \
(*(WCHAR *)((sz)+1) == CHAR_BSLASH)

INT
SheSetEnvVarW(
              WCHAR *varname,
              WCHAR *varvalue
              )
{
    if (!wcslen(varvalue)) {
        varvalue = NULL; // null to remove from env
    }
    return (!SetEnvironmentVariable(varname, varvalue));
}

WCHAR *
SheGetEnvVarW(
              WCHAR *varname)
{
    static WCHAR GetEnvVarBuffer[ 1024 ];
    
    if (GetEnvironmentVariableW(varname, GetEnvVarBuffer, 1024)) {
        return(GetEnvVarBuffer);
    } else {
        return(NULL);
    }
}

INT
SheGetPathOffsetW(
                  LPWSTR lpszDir)
{
    // sanity
    if (!lpszDir || !*lpszDir) {
        return(-1);
    }
    
    if ((*(lpszDir+1) == WCHAR_COLON) &&
        ((*(lpszDir+2) == WCHAR_BSLASH) ||
        (*(lpszDir+2) == WCHAR_SLASH) ||
        (*(lpszDir+2) == WCHAR_NULL)) ) {
        
        return(2);
        
    } else if (DBL_BSLASH(lpszDir)) {
        
        // Deviceless, assume LanMan Provided UNC names (i.e. DBL_BSLASH above)
        
        INT cchServerShareLen = -1;
        DWORD dwSlashesSeen = 0;
        
        // There are exactly 4 b-slashes from here
        
        while (dwSlashesSeen != 4) {
            cchServerShareLen++;
            
            if (!*lpszDir) {
                if (dwSlashesSeen == 3) {
                    return(cchServerShareLen);
                } else {
                    return(-1);
                }
            }
            
            if ((*lpszDir == CHAR_BSLASH) || (*lpszDir == CHAR_SLASH)) {
                dwSlashesSeen++;
            }
            
            lpszDir++;
        }
        
        return(cchServerShareLen);
        
    } else {
        
        // unrecognized format
        return(-1);
    }
}

INT
SheGetDirW(
           INT  iDrive,             // 0 = default, 1=A....
           WCHAR *str
           )
{
    WCHAR        denvname[ 4 ];
    WCHAR        *denvvalue;
    WCHAR        *strT = str;
    
    if (iDrive-- == GD_DEFAULT) {
        GetCurrentDirectoryW(MAX_PATH, str); // pray that str is at least MAX_PATH
        return(SUCCESS);
    }
    
    denvname[ 0 ] = WCHAR_EQUAL;
    denvname[ 1 ] = (WCHAR)(WCHAR_CAP_A + (WCHAR)iDrive);
    denvname[ 2 ] = WCHAR_COLON;
    denvname[ 3 ] = WCHAR_NULL;
    
    denvvalue = SheGetEnvVarW( denvname );
    if (!denvvalue) {
        *str++ = (WCHAR)(WCHAR_CAP_A + (WCHAR)iDrive);
        *str++ = WCHAR_COLON;
        *str++ = WCHAR_BSLASH;
        *str   = WCHAR_NULL;
    }
    else {
        
        if (FAILED(StringCchCopy(str, MAX_PATH, denvvalue)))
        {
            return FAILURE;
        }
    }
    
    // there is a subtle difference between getcurrentdirectory() of DOS and the
    // equivalent SheGetDir() of NT. On dos, getcurrentdirectory() accesses the
    // floppy drives while in NT SheGetDir() returns the values that are set in
    // the environment variables. So we hit the disk on NT too, by calling
    // GetFileAttributes. We return SUCCESS or FAILURE based on the return value
    // of GetFileAttributes.
    
    if (GetFileAttributesW(strT) == (DWORD)0xffffffff)
        return(FAILURE);
    else
        return(SUCCESS);
}

// Should be BOOL, but possible mips breakage
INT
SheGetDirA(
           INT iDrive,             // 0 = default, 1=A....
           CHAR *szDirA)
{
    WCHAR szDirW[MAX_PATH];
    BOOL fDefCharUsed;
    
    INT nRet;
    
    if (!szDirA) {
        return(FAILURE);
    }
    
    nRet = SheGetDirW(iDrive, szDirW);
    if (SUCCESS == nRet)
    {
        WideCharToMultiByte(CP_ACP, 0, szDirW, -1, (LPSTR)szDirA,
                            MAX_PATH, NULL, &fDefCharUsed);
    }
    
    return(nRet);
}

INT
SheChangeDirW(
              WCHAR *newdir
              )
{
    WCHAR       denvname[ 4 ];
    WCHAR       newpath[ MAX_PATH ];
    WCHAR       denvvalue[ MAX_PATH ];
    WCHAR       c, *s;
    DWORD       attr;
    
    GetCurrentDirectoryW( MAX_PATH, denvvalue );
    c = (WCHAR)(DWORD_PTR)CharUpperW((LPTSTR)(DWORD_PTR)denvvalue[0]);
    
    denvname[0] = WCHAR_EQUAL;
    if (IsCharAlphaW(*newdir) && newdir[1] == WCHAR_COLON) {
        denvname[1] = (WCHAR)(DWORD_PTR)CharUpperW((LPTSTR)(DWORD_PTR)*newdir);
        newdir += 2;
    } else {
        denvname[ 1 ] = c;
    }
    denvname[ 2 ] = WCHAR_COLON;
    denvname[ 3 ] = WCHAR_NULL;
    
    if ((*newdir == WCHAR_BSLASH) || (*newdir == WCHAR_SLASH)) {
        newpath[ 0 ] = denvname[ 1 ];
        newpath[ 1 ] = denvname[ 2 ];
        if (FAILED(StringCchCopy( &newpath[ 2 ], ARRAYSIZE(newpath) - 2, newdir)))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
    } else {
        if (NULL != (s = SheGetEnvVarW( denvname ))) 
        {
            if (FAILED(StringCchCopy(newpath, ARRAYSIZE(newpath), s)))
            {
                return ERROR_BUFFER_OVERFLOW;
            }
        } 
        else 
        {
            newpath[ 0 ] = denvname[ 1 ];
            newpath[ 1 ] = denvname[ 2 ];
            newpath[ 2 ] = WCHAR_NULL;
        }
        s = newpath + wcslen( newpath );
        *s++ = WCHAR_BSLASH;
        if (FAILED(StringCchCopy(s, ARRAYSIZE(newpath) - (s - newpath), newdir)))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
    }
    
    if (!GetFullPathNameW(newpath, MAX_PATH, denvvalue, &s )) {
        return( ERROR_ACCESS_DENIED );
    }
    
    attr = GetFileAttributesW( denvvalue );
    if (attr == -1 || !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
        return( ERROR_ACCESS_DENIED );
    }
    
    if (SheSetEnvVarW(denvname,denvvalue)) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    SetCurrentDirectoryW( denvvalue );
    
    // this seems wrong... SheGetDir(GD_DEFAULT, CurDrvDirW) ;
    if (FAILED(StringCchCopy(CurDrvDirW, ARRAYSIZE(CurDrvDirW), denvvalue))) // this seems right to me.
    {
        return (ERROR_BUFFER_OVERFLOW);
    }
    
    return(SUCCESS) ;
}

INT
SheChangeDirA(
              CHAR *szNewDirA
              )
{
    INT iRet;
    WCHAR szNewDirW[MAX_PATH];
    
    if (szNewDirA &&
        MultiByteToWideChar(CP_ACP, 0, (LPSTR)szNewDirA, -1, szNewDirW, MAX_PATH))
    {
        iRet = SheChangeDirW(szNewDirW);
    }
    else 
    {
        iRet = FAILURE;
    }
    return iRet;
}

INT
SheChangeDirExW(
                WCHAR *newdir)
{
    WCHAR wcEnvName[MAX_PATH];
    WCHAR wcNewPath[MAX_PATH];
    WCHAR wcEnvValue[MAX_PATH];
    
    DWORD cchPathOffset;
    
    WCHAR *s;
    DWORD attr;
    BOOL bUsedEnv = FALSE;
    
    if (newdir && *newdir &&
        ((cchPathOffset = SheGetPathOffsetW(newdir)) != 0xFFFFFFFF)) {
        WCHAR wc = newdir[cchPathOffset];
        
        newdir[cchPathOffset] = WCHAR_NULL;
        if (FAILED(StringCchCopy(&wcEnvName[1], 
                                 ARRAYSIZE(wcEnvName) - 1,
                                 newdir)))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
        
        newdir[cchPathOffset] = wc;
        newdir += cchPathOffset;
        
    } else {
        
        GetCurrentDirectoryW(MAX_PATH, wcEnvValue);
        
        if (FAILED(StringCchCopy(&wcEnvName[1], 
                                 ARRAYSIZE(wcEnvName) - 1,
                                 wcEnvValue)))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
    }
    
    wcEnvName[0] = WCHAR_EQUAL;
    if ((cchPathOffset = SheGetPathOffsetW(&wcEnvName[1])) != 0xFFFFFFFF) {
        
        // add one since the first character is "="
        wcEnvName[cchPathOffset + 1] = WCHAR_NULL;
    }
    
    //
    // If return value is 2, then we are a drive letter like A:
    // We need to uppercase the drive letter here, since the environ
    // vars are usually set as uppercase.
    //
    if (cchPathOffset == 2) {
        
        wcEnvName[1] = (WCHAR)(DWORD_PTR)CharUpper((LPWSTR)(DWORD_PTR) wcEnvName[1]);
    }
    
    if (newdir && *newdir &&
        ((*newdir == WCHAR_BSLASH) || (*newdir == WCHAR_SLASH))) {
        
        if (FAILED(StringCchCopy(wcNewPath, 
                                 ARRAYSIZE(wcNewPath),
                                 &wcEnvName[1])))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
        if (FAILED(StringCchCat(wcNewPath, 
                                ARRAYSIZE(wcNewPath),
                                newdir)))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
        
    } else {
        LPWSTR lpszEnvName;
        
        if (NULL != (lpszEnvName = SheGetEnvVarW(wcEnvName))) {
            
            if (FAILED(StringCchCopy(wcNewPath, 
                                     ARRAYSIZE(wcNewPath),
                                     lpszEnvName)))
            {
                return ERROR_BUFFER_OVERFLOW;
            }
            bUsedEnv = TRUE;
            
        } else {
            if (FAILED(StringCchCopy(wcNewPath, 
                                     ARRAYSIZE(wcNewPath),
                                     &wcEnvName[1])))
            {
                return ERROR_BUFFER_OVERFLOW;
            }
        }
        
        if (newdir && *newdir) 
        {
            if (!PathAppend(wcNewPath, newdir))
            {
                return ERROR_BUFFER_OVERFLOW;
            }
        }
    }
    
    if (!GetFullPathNameW(wcNewPath, MAX_PATH, wcEnvValue, &s)) {
        return( ERROR_ACCESS_DENIED );
    }
    
    attr = GetFileAttributesW(wcEnvValue);
    
    if ((attr == 0xFFFFFFFF ||
        ((attr & FILE_ATTRIBUTE_DIRECTORY) &&
        !SetCurrentDirectoryW(wcEnvValue)))
        && bUsedEnv ) 
    {
        if (FAILED(StringCchCopy(wcEnvValue, ARRAYSIZE(wcEnvValue), &wcEnvName[1])) ||
            FAILED(StringCchCat(wcEnvValue, ARRAYSIZE(wcEnvValue), TEXT("\\"))))
        {
            return ERROR_BUFFER_OVERFLOW;
        }
            
        attr = GetFileAttributesW(wcEnvValue);
        
    }
    
    if (attr == 0xFFFFFFFF || !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
        
        return(ERROR_ACCESS_DENIED);
    }
    
    if (!SetCurrentDirectoryW(wcEnvValue)) {
        return( ERROR_ACCESS_DENIED );
    }
    
    // It's ok if this fails
    SheSetEnvVarW(wcEnvName, wcEnvValue);
    
    // this seems right to me.
    if (FAILED(StringCchCopy(CurDrvDirW, ARRAYSIZE(CurDrvDirW), wcEnvValue)))
    {
        return ERROR_BUFFER_OVERFLOW;
    }
        
    return(SUCCESS) ;
}

INT
SheChangeDirExA(
                CHAR *szNewDirA
                )
{
    INT iRet;
    WCHAR szNewDirW[MAX_PATH];
    
    if (szNewDirA &&
        MultiByteToWideChar(CP_ACP, 0, (LPSTR)szNewDirA, -1, szNewDirW, MAX_PATH))
    {
        iRet = SheChangeDirExW(szNewDirW);
    }
    else
    {
        iRet = FAILURE;
    }
    return iRet;
}

INT
SheGetCurDrive()
{
    if (!CurDrvDirW[0]) {
        SheGetDirW(GD_DEFAULT, CurDrvDirW) ;
    }
    return(CurDrvDirW[0] - WCHAR_CAP_A);
}


INT
SheSetCurDrive(
               INT iDrive
               )
{
    WCHAR chT[MAX_PATH];
    
    if (CurDrvDirW[0] != (WCHAR)(WCHAR_CAP_A + iDrive)) {
        SheGetDirW(iDrive + 1, chT);
        return(SheChangeDirW(chT));
    }
    return(SUCCESS);
}

INT
SheFullPathA(
             CHAR *fname,
             DWORD sizpath,
             CHAR *buf)
{
    DWORD rc = SUCCESS;         /* prime with good rc */
    DWORD buflen;               /* buffer length      */
    CHAR *filepart;
    
    if (*fname == CHAR_NULL) {
        SheGetDirA(GD_DEFAULT, buf);
        buf += 2;                           /* Inc past drivespec      */
        buflen = strlen(buf);             /* Is curdir root only?    */
        if (buflen >= MAX_PATH-3) {  /* If too big then stop    */
            rc = FAILURE;
        } else if (buflen != 1) {              /* if not root then append */
            *(buf+buflen++) = CHAR_BSLASH;      /* ...a pathchar and...    */
            *(buf+buflen) = CHAR_NULL ;              /* ...a null CHAR...       */
        }                                 /*                         */
    } else {
        if ((strlen(fname) == 2) &&
            (*(fname + 1) == CHAR_COLON)
            // && (!is_dbcsleadchar(*fname))
            ) {
            SheGetDirA((CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)*fname) - CHAR_CAP_A, buf);                 /* Get curdrvdir           */
            if ((buflen = strlen(buf)) > 3) {
                *(buf+buflen++) = CHAR_BSLASH;      /* ...a pathchar and...    */
                *(buf+buflen) = CHAR_NULL ;          /* ...a null CHAR...           */
            }
        } else {
            if (!GetFullPathNameA( fname, sizpath, buf, &filepart )) {
                rc = FAILURE;
            }
        }
    }
    return(rc);
}

INT
SheFullPathW(
             WCHAR *fname,
             DWORD sizpath,
             WCHAR *buf)
{
    DWORD rc = SUCCESS;         /* prime with good rc */
    DWORD buflen;               /* buffer length      */
    WCHAR *filepart;
    
    if (*fname == WCHAR_NULL) {
        SheGetDirW(GD_DEFAULT, buf);
        buf += 2;                           /* Inc past drivespec      */
        buflen = wcslen(buf);             /* Is curdir root only?    */
        if (buflen >= MAX_PATH-3) {  /* If too big then stop    */
            rc = FAILURE;
        } else if (buflen != 1) {              /* if not root then append */
            *(buf+buflen++) = WCHAR_BSLASH;      /* ...a pathchar and...    */
            *(buf+buflen) = WCHAR_NULL ;              /* ...a null CHAR...       */
        }                                 /*                         */
    } else {
        if ((wcslen(fname) == 2) &&
            (*(fname + 1) == WCHAR_COLON)
            // && (!is_dbcsleadchar(*fname))
            ) {
            SheGetDirW((WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)*fname) - WCHAR_CAP_A, buf);                 /* Get curdrvdir           */
            if ((buflen = wcslen(buf)) > 3) {
                *(buf+buflen++) = WCHAR_BSLASH;      /* ...a pathchar and...    */
                *(buf+buflen) = WCHAR_NULL ;          /* ...a null CHAR...           */
            }
        } else {
            if (!GetFullPathNameW( fname, sizpath, buf, &filepart )) {
                rc = FAILURE;
            }
        }
    }
    return(rc);
}



BOOL
SheGetDirExW(
             LPWSTR lpszCurDisk,
             LPDWORD lpcchCurDir,
             LPWSTR lpszCurDir)
{
    WCHAR wcEnvName[MAX_PATH];
    LPWSTR lpszEnvValue;
    INT cchPathOffset;
    
    // if lpszCurDisk NULL, do default
    if (!lpszCurDisk) {
        DWORD dwRet = GetCurrentDirectoryW(*lpcchCurDir, lpszCurDir);
        
        if (dwRet) {
            *lpcchCurDir = dwRet;
            return(TRUE);
        } else {
            return(FALSE);
        }
        
    }
    
    cchPathOffset = SheGetPathOffsetW(lpszCurDisk);
    
    if (cchPathOffset != 0xFFFFFFFF) {
        WCHAR wc = *(lpszCurDisk + cchPathOffset);
        
        *(lpszCurDisk + cchPathOffset) = WCHAR_NULL;
        if (FAILED(StringCchCopy(&wcEnvName[1], ARRAYSIZE(wcEnvName) - 1, lpszCurDisk)))
        {
            return FALSE;
        }
        wcEnvName[0] = WCHAR_EQUAL;
        
        *(lpszCurDisk + cchPathOffset) = wc;
        
        if (NULL != (lpszEnvValue = SheGetEnvVarW(wcEnvName))) 
        {
            if (FAILED(StringCchCopy(lpszCurDir, *lpcchCurDir, lpszEnvValue)))
            {
                *lpcchCurDir = lstrlen(lpszEnvValue) + 1;
                return FALSE;
            }
            else
            {
                return TRUE;
            }
        }
        
        if (FAILED(StringCchCopy(lpszCurDir, *lpcchCurDir, lpszCurDisk)))
        {
            return FALSE;
        }
        
        *(lpszCurDir + cchPathOffset) = WCHAR_BSLASH;
        *(lpszCurDir + cchPathOffset + 1) = WCHAR_NULL;
        
        return(TRUE);
        
    } else {
        
        // parsing error
        return(FALSE);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\rdrag.c ===
#include "shellprv.h"
#pragma  hdrstop

UINT _StringListLenW(PCWSTR pszList)
{
    //  this is a double NULL terminated list
    //  we want to make sure that we get the size 
    //  including the NULL term
    PCWSTR pszLast = pszList;
    while (*pszLast || (*(pszLast + 1)))
    {
        pszLast++;
    }
    ASSERT(!pszLast[0] && !pszLast[1]);
    // add 2 for the double term
    return (UINT)(pszLast - pszList) + 2;
}

UINT _StringListLenA(PCSTR pszList)
{
    //  this is a double NULL terminated list
    //  we want to make sure that we get the size 
    //  including the NULL term
    PCSTR pszLast = pszList;
    while (*pszLast || (*(pszLast + 1)))
    {
        pszLast++;
    }
    ASSERT(!pszLast[0] && !pszLast[1]);
    // add 2 for the double term
    return (UINT)(pszLast - pszList) + 2;
}

// warning: this will fail given a UNICODE hDrop on an ANSI build and
// the DRAGINFO is esentially a TCHAR struct with no A/W versions exported
//
// in:
//      hDrop   drop handle
//
// out:
//      a bunch of info about the hdrop
//      (mostly the pointer to the double NULL file name list in TCHAR format)
//
// returns:
//      TRUE    the DRAGINFO struct was filled in
//      FALSE   the hDrop was bad
//

STDAPI_(BOOL) DragQueryInfo(HDROP hDrop, DRAGINFO *pdi)
{
    if (hDrop && (pdi->uSize == sizeof(DRAGINFO))) 
    {
        LPDROPFILES lpdfx = (LPDROPFILES)GlobalLock((HGLOBAL)hDrop);
        
        pdi->lpFileList = NULL;
        
        if (lpdfx)
        {
            LPTSTR lpOldFileList;
            if (LOWORD(lpdfx->pFiles) == sizeof(DROPFILES16))
            {
                //
                // This is Win31-stye HDROP
                //
                LPDROPFILES16 pdf16 = (LPDROPFILES16)lpdfx;
                pdi->pt.x  = pdf16->pt.x;
                pdi->pt.y  = pdf16->pt.y;
                pdi->fNC   = pdf16->fNC;
                pdi->grfKeyState = 0;
                lpOldFileList = (LPTSTR)((LPBYTE)pdf16 + pdf16->pFiles);
            }
            else
            {
                //
                // This is a new (NT-compatible) HDROP.
                //
                pdi->pt.x  = lpdfx->pt.x;
                pdi->pt.y  = lpdfx->pt.y;
                pdi->fNC   = lpdfx->fNC;
                pdi->grfKeyState = 0;
                lpOldFileList = (LPTSTR)((LPBYTE)lpdfx + lpdfx->pFiles);
                
                // there could be other data in there, but all
                // the HDROPs we build should be this size
                ASSERT(lpdfx->pFiles == sizeof(DROPFILES));
            }
            
            {
                BOOL fIsAnsi = ((LOWORD(lpdfx->pFiles) == sizeof(DROPFILES16)) || lpdfx->fWide == FALSE);
                if (!fIsAnsi)
                {
                    UINT   cchListW = _StringListLenW(lpOldFileList);
                    LPTSTR pszListW = (LPTSTR) SHAlloc(CbFromCchW(cchListW));
                    if (pszListW)
                    {
                        // Copy strings to new buffer and set LPDROPINFO filelist
                        // pointer to point to this new buffer
                        
                        CopyMemory(pszListW, lpOldFileList, CbFromCchW(cchListW));
                        pdi->lpFileList = pszListW;
                    }
                }
                else
                {
                    PCSTR pszListA = (LPSTR)lpOldFileList;
                    UINT   cchListA = _StringListLenA(pszListA);
                    UINT cchListW = MultiByteToWideChar(CP_ACP, 0, pszListA, cchListA, NULL, 0);
                    if (cchListW)
                    {
                        PWSTR pszListW = (LPWSTR) SHAlloc(CbFromCchW(cchListW));
                        if (pszListW)
                        {
                            //  reuse cchListA for debug purposes
                            cchListA = MultiByteToWideChar(CP_ACP, 0, pszListA, cchListA, pszListW, cchListW);
                            ASSERT(cchListA == cchListW);
                            pdi->lpFileList = pszListW;
                        }
                    }
                            
                }
            }
            
            GlobalUnlock((HGLOBAL)hDrop);
            
            return pdi->lpFileList != NULL;
        }
    }
    return FALSE;
}

// 3.1 API

STDAPI_(BOOL) DragQueryPoint(HDROP hDrop, POINT *ppt)
{
    BOOL fRet = FALSE;
    LPDROPFILES lpdfs = (LPDROPFILES)GlobalLock((HGLOBAL)hDrop);
    if (lpdfs)
    {
        if (LOWORD(lpdfs->pFiles) == sizeof(DROPFILES16))
        {
            //
            // This is Win31-stye HDROP
            //
            LPDROPFILES16 pdf16 = (LPDROPFILES16)lpdfs;
            ppt->x = pdf16->pt.x;
            ppt->y = pdf16->pt.y;
            fRet = !pdf16->fNC;
        }
        else
        {
            //
            // This is a new (NT-compatible) HDROP
            //
            ppt->x = (UINT)lpdfs->pt.x;
            ppt->y = (UINT)lpdfs->pt.y;
            fRet = !lpdfs->fNC;

            // there could be other data in there, but all
            // the HDROPs we build should be this size
            ASSERT(lpdfs->pFiles == sizeof(DROPFILES));
        }
        GlobalUnlock((HGLOBAL)hDrop);
    }

    return fRet;
}

//
// Unfortunately we need it split out this way because WOW needs to
// able to call a function named DragQueryFileAorW (so it can shorten them)
//
STDAPI_(UINT) DragQueryFileAorW(HDROP hDrop, UINT iFile, void *lpFile, UINT cb, BOOL fNeedAnsi, BOOL fShorten)
{
    UINT i;
    LPDROPFILESTRUCT lpdfs = (LPDROPFILESTRUCT)GlobalLock(hDrop);
    if (lpdfs)
    {
        // see if it is the new format
        BOOL fWide = LOWORD(lpdfs->pFiles) == sizeof(DROPFILES) && lpdfs->fWide;
        if (fWide)
        {
            LPWSTR lpList;
            WCHAR szPath[MAX_PATH];

            //
            // UNICODE HDROP
            //

            lpList = (LPWSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

            // find either the number of files or the start of the file
            // we're looking for
            //
            for (i = 0; (iFile == (UINT)-1 || i != iFile) && *lpList; i++)
            {
                while (*lpList++)
                    ;
            }

            if (iFile == (UINT)-1)
                goto Exit;


            iFile = i = lstrlenW(lpList);
            if (fShorten && iFile < MAX_PATH)
            {
                StringCchCopy(szPath, ARRAYSIZE(szPath), lpList);
                SheShortenPathW(szPath, TRUE);
                lpList = szPath;
                iFile = i = lstrlenW(lpList);
            }

            if (fNeedAnsi)
            {
                // Do not assume that a count of characters == a count of bytes
                i = WideCharToMultiByte(CP_ACP, 0, lpList, -1, NULL, 0, NULL, NULL);
                iFile = i ? --i : i;
            }

            if (!i || !cb || !lpFile)
                goto Exit;

            if (fNeedAnsi) 
            {
                SHUnicodeToAnsi(lpList, (LPSTR)lpFile, cb);
            } 
            else 
            {
                cb--;
                if (cb < i)
                    i = cb;
                lstrcpynW((LPWSTR)lpFile, lpList, i + 1);
            }
        }
        else
        {
            LPSTR lpList;
            CHAR szPath[MAX_PATH];

            //
            // This is Win31-style HDROP or an ANSI NT Style HDROP
            //
            lpList = (LPSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

            // find either the number of files or the start of the file
            // we're looking for
            //
            for (i = 0; (iFile == (UINT)-1 || i != iFile) && *lpList; i++)
            {
                while (*lpList++)
                    ;
            }

            if (iFile == (UINT)-1)
                goto Exit;

            iFile = i = lstrlenA(lpList);
            if (fShorten && iFile < MAX_PATH)
            {
                StringCchCopyA(szPath, ARRAYSIZE(szPath), lpList);
                SheShortenPathA(szPath, TRUE);
                lpList = szPath;
                iFile = i = lstrlenA(lpList);
            }

            if (!fNeedAnsi)
            {
                i = MultiByteToWideChar(CP_ACP, 0, lpList, -1, NULL, 0);
                iFile = i ? --i : i;
            }

            if (!i || !cb || !lpFile)
                goto Exit;

            if (fNeedAnsi) 
            {
                cb--;
                if (cb < i)
                    i = cb;
    
                lstrcpynA((LPSTR)lpFile, lpList, i + 1);
            } 
            else 
            {
                SHAnsiToUnicode(lpList, (LPWSTR)lpFile, cb);
            }
        }
    }

    i = iFile;

Exit:
    GlobalUnlock(hDrop);

    return i;
}

STDAPI_(UINT) DragQueryFileW(HDROP hDrop, UINT wFile, LPWSTR lpFile, UINT cb)
{
   return DragQueryFileAorW(hDrop, wFile, lpFile, cb, FALSE, FALSE);
}

STDAPI_(UINT) DragQueryFileA(HDROP hDrop, UINT wFile, LPSTR lpFile, UINT cb)
{
   return DragQueryFileAorW(hDrop, wFile, lpFile, cb, TRUE, FALSE);
}

STDAPI_(void) DragFinish(HDROP hDrop)
{
    GlobalFree((HGLOBAL)hDrop);
}

STDAPI_(void) DragAcceptFiles(HWND hwnd, BOOL fAccept)
{
    long exstyle = GetWindowLong(hwnd, GWL_EXSTYLE);
    if (fAccept)
        exstyle |= WS_EX_ACCEPTFILES;
    else
        exstyle &= (~WS_EX_ACCEPTFILES);
    SetWindowLong(hwnd, GWL_EXSTYLE, exstyle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\psxa.c ===
//
// PropSheetExtArray implementation, use for control panel applets to extend their pages
//
// Manipulates a group of property sheet extension objects (see PSXA.H)
//
#include "shellprv.h"
#pragma  hdrstop

// header for an array of IShellPropSheetExt interface pointers

typedef struct
{
    UINT count, alloc;
    IShellPropSheetExt *interfaces[ 0 ];
} PSXA;


// used to forward LPFNADDPROPSHEETPAGE calls with added error checking

typedef struct
{
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM lparam;
    UINT count;
    BOOL allowmulti;
    BOOL alreadycalled;
} _PSXACALLINFO;


// forwards an LPFNADDPROPSHEETPAGE call with added error checking

BOOL CALLBACK _PsxaCallOwner(HPROPSHEETPAGE hpage, LPARAM lparam)
{
    _PSXACALLINFO *callinfo = (_PSXACALLINFO *)lparam;
    if (callinfo)
    {
        if (!callinfo->allowmulti && callinfo->alreadycalled)
            return FALSE;

        if (callinfo->pfn(hpage, callinfo->lparam))
        {
            callinfo->alreadycalled = TRUE;
            callinfo->count++;
            return TRUE;
        }
    }
    return FALSE;
}

// creates an instance of the property sheet extension referred to by szCLSID
// initializes it via the IShellExtInit (if IShellExtInit is supported)

BOOL InitPropSheetExt(IShellPropSheetExt **ppspx, LPCTSTR pszCLSID, HKEY hKey, IDataObject *pDataObj)
{
    if (SUCCEEDED(SHExtCoCreateInstance(pszCLSID, NULL, NULL, &IID_IShellPropSheetExt, ppspx)))
    {
        IShellExtInit *psxi;

        if (SUCCEEDED((*ppspx)->lpVtbl->QueryInterface(*ppspx, &IID_IShellExtInit, &psxi)))
        {
            if (FAILED(psxi->lpVtbl->Initialize(psxi, NULL, pDataObj, hKey)))
            {
                (*ppspx)->lpVtbl->Release(*ppspx);
                *ppspx = NULL;
            }

            psxi->lpVtbl->Release(psxi);
        }
    }

    return BOOLFROMPTR(*ppspx);
}


// uses hKey and pszSubKey to find property sheet handlers in the registry
// loads up to max_iface IShellPropSheetExt interfaces (so I'm lazy...)
// returns a handle (pointer) to a newly allocated PSXA

HPSXA SHCreatePropSheetExtArrayEx(HKEY hKey, LPCTSTR pszLocation, UINT max_iface, IDataObject *pDataObj)
{
    BOOL success = FALSE;

    PSXA *psxa = LocalAlloc(LPTR, sizeof(*psxa) + sizeof(IShellPropSheetExt *) * max_iface);
    if (psxa)
    {
        IShellPropSheetExt **spsx = psxa->interfaces;
        HKEY hkLocation;
        UINT i;

        psxa->count = 0;
        psxa->alloc = max_iface;

        for (i = 0; i < psxa->alloc; i++, spsx++)
            *spsx = NULL;

        if (ERROR_SUCCESS == RegOpenKeyEx(hKey, pszLocation, 0, KEY_QUERY_VALUE, &hkLocation))
        {
            HKEY hkHandlers;

            if (ERROR_SUCCESS == RegOpenKeyEx(hkLocation, STRREG_SHEX_PROPSHEET, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hkHandlers))
            {
                TCHAR szChild[64]; // yes, this is totally arbitrary...

                // fill until there's no room or no more subkeys to get
                for (i = 0;
                    (psxa->count < psxa->alloc) &&
                    (RegEnumKey(hkHandlers, (int)i, szChild,
                    ARRAYSIZE(szChild)) == ERROR_SUCCESS);
                    i++)
                {
                    TCHAR szCLSID[ MAX_PATH ];
                    DWORD cbCLSID = sizeof(szCLSID);

                    if (SHRegGetValue(hkHandlers, szChild, NULL, SRRF_RT_REG_SZ, NULL, szCLSID,
                        &cbCLSID) == ERROR_SUCCESS)
                    {
                        if (InitPropSheetExt(&psxa->interfaces[ psxa->count ],
                            szCLSID, hKey, pDataObj))
                        {
                            psxa->count++;
                        }
                    }
                }

                RegCloseKey(hkHandlers);
                success = TRUE;
            }

            RegCloseKey(hkLocation);
        }
    }

    if (!success && psxa)
    {
        SHDestroyPropSheetExtArray((HPSXA)psxa);
        psxa = NULL;
    }

    return (HPSXA)psxa;
}

HPSXA SHCreatePropSheetExtArray(HKEY hKey, LPCTSTR pszLocation, UINT max_iface)
{
    return SHCreatePropSheetExtArrayEx(hKey, pszLocation, max_iface, NULL);
}

// releases interfaces in a PSXA and frees the memory it occupies

void SHDestroyPropSheetExtArray(HPSXA hpsxa)
{
    PSXA *psxa = (PSXA *)hpsxa;
    IShellPropSheetExt **spsx = psxa->interfaces;
    UINT i;

    // release the interfaces
    for (i = 0; i < psxa->count; i++, spsx++)
        (*spsx)->lpVtbl->Release(*spsx);

    LocalFree(psxa);
}


// asks each interface in a PSXA to add pages for a proprty sheet
// returns the number of pages actually added

UINT SHAddFromPropSheetExtArray(HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    PSXA *psxa = (PSXA *)hpsxa;
    IShellPropSheetExt **spsx = psxa->interfaces;
    _PSXACALLINFO callinfo = { lpfnAddPage, lParam, 0, TRUE, FALSE };
    UINT i;

    for (i = 0; i < psxa->count; i++, spsx++)
        (*spsx)->lpVtbl->AddPages(*spsx, _PsxaCallOwner, (LPARAM)&callinfo);

    return callinfo.count;
}


// asks each interface in a PSXA to replace a page in a prop sheet
// each interface is only allowed to add up to one replacement
// returns the total number of replacements added

UINT SHReplaceFromPropSheetExtArray(HPSXA hpsxa, UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    PSXA *psxa = (PSXA *)hpsxa;
    IShellPropSheetExt **spsx = psxa->interfaces;
    _PSXACALLINFO callinfo = { lpfnReplaceWith, lParam, 0, FALSE, FALSE };
    UINT i;

    for (i = 0; i < psxa->count; i++, spsx++)
    {
        // reset the call flag so that each provider gets a chance
        callinfo.alreadycalled = FALSE;

        if ((*spsx)->lpVtbl->ReplacePage)
            (*spsx)->lpVtbl->ReplacePage(*spsx, uPageID, _PsxaCallOwner, (LPARAM)&callinfo);
    }

    return callinfo.count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prtprop.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "printer.h"

// PRINTUI.DLL calls this export to load shell exts registered for this printer

STDAPI_(void) Printer_AddPrinterPropPages(LPCTSTR pszPrinterName, LPPROPSHEETHEADER lpsh)
{
    // Add hooked pages if they exist in the registry
    HKEY hkeyBaseProgID = NULL;
    RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szPrinters, 0, KEY_QUERY_VALUE, &hkeyBaseProgID);
    if (hkeyBaseProgID)
    {
        // we need an IDataObject
        LPITEMIDLIST pidl;
        HRESULT hr = ParsePrinterNameEx(pszPrinterName, &pidl, TRUE, 0, 0);
        if (SUCCEEDED(hr))
        {
            IDataObject *pdtobj;
            hr = SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                // add the hooked pages
                HDCA hdca = DCA_Create();
                if (hdca)
                {
                    DCA_AddItemsFromKey(hdca, hkeyBaseProgID, STRREG_SHEX_PROPSHEET);
                    DCA_AppendClassSheetInfo(hdca, hkeyBaseProgID, lpsh, pdtobj);
                    DCA_Destroy(hdca);
                }
                pdtobj->lpVtbl->Release(pdtobj);
            }
            ILFree(pidl);
        }
        RegCloseKey(hkeyBaseProgID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\recdocs.h ===
#ifndef _RECDOCS_H_
#define _RECDOCS_H_

STDAPI CreateRecentMRUList(IMruDataList **ppmru);
STDAPI RecentDocs_Enum(IMruDataList *pmru, int iItem, LPITEMIDLIST *ppidl);
STDAPI_(void) AddToRecentDocs( LPCITEMIDLIST pidl, LPCTSTR lpszPath );
STDAPI CTaskAddDoc_Create(HANDLE hMem, DWORD dwProcId, IRunnableTask **pptask);
STDAPI RecentDocs_GetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName, DWORD cchName);

#define MAXRECENTDOCS 15

#endif  //  _RECDOCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\recclean.cpp ===
#include "shellprv.h"
#include "emptyvc.h"
#include "recclean.h"
#include "ids.h"

STDAPI CRecycleBinCleaner_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;

    CRecycleBinCleaner *p = new CRecycleBinCleaner();
    if (!p)
        return E_OUTOFMEMORY;

    HRESULT hres = p->QueryInterface(riid, ppvOut);
    p->Release();
    return hres;
}

CRecycleBinCleaner::CRecycleBinCleaner() : m_cRef(1)
{
   // start ref at one
}

CRecycleBinCleaner::~CRecycleBinCleaner()
{
   // cleanup - nothing yet
}

/*----------------------------------------------------------
QueryInterface handler for CRecycleBinCleaner
*/

STDMETHODIMP CRecycleBinCleaner::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache2))
    {
        *ppvObj = SAFECAST(this, IEmptyVolumeCache2 *);
    }
    else if (IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        *ppvObj = SAFECAST(this, IEmptyVolumeCache *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
   
    return NOERROR;
}


STDMETHODIMP_(ULONG) CRecycleBinCleaner::AddRef()
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CRecycleBinCleaner::Release()
{
    m_cRef--;
    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CRecycleBinCleaner::InitializeEx(
    HKEY hkRegKey,
    LPCWSTR pcwszVolume,
    LPCWSTR pcwszKeyName,
    LPWSTR *ppwszDisplayName,
    LPWSTR *ppwszDescription,
    LPWSTR *ppwszBtnText,
    DWORD *pdwFlags
    )
{
    TCHAR szTmp[128];
    int iLen;

    iLen = 1 + LoadString( g_hinst, IDS_RECCLEAN_BTNTEXT, szTmp, ARRAYSIZE(szTmp));
    if (iLen == 1) // and hence LoadString returned 0 (error)
        return E_FAIL;

    *ppwszBtnText = (LPWSTR)CoTaskMemAlloc( iLen * sizeof(WCHAR) );
    if ( !*ppwszBtnText )
        return E_OUTOFMEMORY;
    SHTCharToUnicode(szTmp, *ppwszBtnText, iLen);

    return Initialize(hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags);
}

STDMETHODIMP CRecycleBinCleaner::Initialize(HKEY hRegKey, LPCWSTR pszVolume,
                      LPWSTR  *ppwszName, LPWSTR *ppwszDesc, DWORD *pdwFlags)
{
    TCHAR szTmpName[256], szTmpDesc[512];
    int iNameLen, iDescLen;

    if(!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags = EVCF_HASSETTINGS;

    iNameLen = 1 + LoadString( g_hinst, IDS_RECCLEAN_NAMETEXT, szTmpName, ARRAYSIZE(szTmpName));
    iDescLen = 1 + LoadString( g_hinst, IDS_RECCLEAN_DESCTEXT, szTmpDesc, ARRAYSIZE(szTmpDesc));
    if ( (iNameLen == 1) || (iDescLen == 1) ) // meaning LoadString returned 0 (error)
        return E_FAIL;

    *ppwszName = (LPWSTR)CoTaskMemAlloc( iNameLen*sizeof(WCHAR) );
    *ppwszDesc = (LPWSTR)CoTaskMemAlloc( iDescLen*sizeof(WCHAR) );
    if ( !*ppwszName || !*ppwszDesc )
        return E_OUTOFMEMORY;

    SHTCharToUnicode(szTmpName, *ppwszName, iNameLen);
    SHTCharToUnicode(szTmpDesc, *ppwszDesc, iDescLen);

    StringCchCopy(m_szVolume,  ARRAYSIZE(m_szVolume), pszVolume);
    
    return S_OK;
}


STDMETHODIMP CRecycleBinCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
   SHQUERYRBINFO qinfo;

   if(!pdwSpaceUsed)
       return E_INVALIDARG;

   qinfo.cbSize = sizeof(SHQUERYRBINFO);
   if(SUCCEEDED(SHQueryRecycleBinW(m_szVolume, &qinfo)))
   {
      *pdwSpaceUsed = qinfo.i64Size;
   }
   else
   {
      *pdwSpaceUsed = 0;
   }
   
   // call back to be nice
   if(picb)
       picb->ScanProgress(*pdwSpaceUsed, EVCCBF_LASTNOTIFICATION, NULL);

   return S_OK;
}

STDMETHODIMP CRecycleBinCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    SHQUERYRBINFO qinfo;

    if (picb)
    {
        qinfo.cbSize = sizeof(SHQUERYRBINFO);
        SHQueryRecycleBinW(m_szVolume, &qinfo);
    }

    // we ignore dwSpaceToFree and clean everything
    SHEmptyRecycleBin(NULL, m_szVolume, SHERB_NOCONFIRMATION | SHERB_NOPROGRESSUI | SHERB_NOSOUND);
   
    // call back to be nice
    if (picb)
    {
        picb->PurgeProgress(qinfo.i64Size, qinfo.i64Size, EVCCBF_LASTNOTIFICATION, NULL); 
    }

    return S_OK;
}

STDMETHODIMP CRecycleBinCleaner::ShowProperties(HWND hwnd)
{
    LPITEMIDLIST pidlBitBuck = SHCloneSpecialIDList(hwnd, CSIDL_BITBUCKET, TRUE);
    if (pidlBitBuck) 
    {
        SHELLEXECUTEINFO ei;
        FillExecInfo(ei, hwnd, c_szOpen, szNULL, NULL, szNULL, SW_NORMAL);
        ei.fMask |= SEE_MASK_IDLIST;
        ei.lpIDList = pidlBitBuck;

        ShellExecuteEx(&ei);
        ILFree(pidlBitBuck);
    }
    return S_OK;
}

STDMETHODIMP CRecycleBinCleaner::Deactivate(LPDWORD pdwFlags)
{
    // whatever, nothing to deactivate
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\recclean.h ===
class CRecycleBinCleaner : public IEmptyVolumeCache2
{
   public:
      CRecycleBinCleaner();
      ~CRecycleBinCleaner();
       
      // IUnknown methods
    
      STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);

      // IEmptyVolumeCache
      STDMETHODIMP Initialize(HKEY hRegKey, LPCWSTR pszVolume, 
                      LPWSTR  *ppszDisplayName, LPWSTR  *ppszDescription,
                      DWORD *pdwFlags);
                                
      STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb);
                                
      STDMETHODIMP Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb);
                               
                                
      STDMETHODIMP ShowProperties(HWND hwnd);
                                
      STDMETHODIMP Deactivate(DWORD *pdwFlags);

      // IEmptyVolumeCache2
      STDMETHODIMP InitializeEx(HKEY hkRegKey, LPCWSTR pcwszVolume,
                                LPCWSTR pcwszKeyName,
                                LPWSTR *ppwszDisplayName, LPWSTR *ppwszDescription,
                                LPWSTR *ppwszBtnText,
                                DWORD *pdwFlags);

   private:
      ULONG m_cRef;
      WCHAR m_szVolume[5];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\reglist.c ===
// History:
//   5-30-94 KurtE      Created.
#include "shellprv.h"
#pragma  hdrstop

//#define PARANOID_VALIDATE_UPDATE

// Define our global states here.  Note: we will do it per process
typedef struct _RLPI    // Registry List Process Info
{
    HDPA    hdpaRLList;             // The dpa of items
    BOOL    fCSInitialized;         // Have we initialized the CS in this process
    BOOL    fListValid;             // Is the list up to date and valid
    CRITICAL_SECTION csRLList;      // The critical section for the process
} RLPI;


RLPI g_rlpi = {NULL, FALSE, FALSE};

// Simple DPA compare function make sure we don't have elsewhere...

int CALLBACK _CompareStrings(LPVOID sz1, LPVOID sz2, LPARAM lparam)
{
    return lstrcmpi((LPTSTR)sz1, (LPTSTR)sz2);
}

void RLEnterCritical()
{
    if (!g_rlpi.fCSInitialized)
    {
        // Do this under the global critical section.
        ENTERCRITICAL;
        if (!g_rlpi.fCSInitialized)
        {
            g_rlpi.fCSInitialized = TRUE;
            InitializeCriticalSection(&g_rlpi.csRLList);
        }
        LEAVECRITICAL;
    }
    EnterCriticalSection(&g_rlpi.csRLList);
}

void RLLeaveCritical()
{
    LeaveCriticalSection(&g_rlpi.csRLList);
}


// Enumerate through the registry looking for paths that
//  we may wish to track.  The current ones that we look for

STDAPI_(BOOL) RLEnumRegistry(HDPA hdpa, PRLCALLBACK pfnrlcb, LPCTSTR pszSource, LPCTSTR pszDest)
{
    HKEY hkeyRoot;

    // First look in the App Paths section
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyRoot))
    {
	    int iRootName;
	    TCHAR szRootName[80];
        for (iRootName = 0; 
             RegEnumKey(hkeyRoot, iRootName, szRootName, ARRAYSIZE(szRootName)) == ERROR_SUCCESS; 
             iRootName++)
        {
            // Now see if the app has a qualifid path here.
	    HKEY hkeySecond;
	    TCHAR szPath[MAX_PATH];
	    long cbValue = sizeof(szPath);
            if (SHRegGetValue(hkeyRoot, szRootName, NULL, SRRF_RT_REG_SZ, NULL, szPath, &cbValue) == ERROR_SUCCESS)
            {
                PathUnquoteSpaces(szPath);
                pfnrlcb(hdpa, hkeyRoot, szRootName, NULL, szPath, pszSource, pszDest);
            }

            // Now try to enum this key  for Path Value.
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, szRootName, 0, KEY_QUERY_VALUE, &hkeySecond))
            {
                cbValue = sizeof(szPath);

                if (SHQueryValueEx(hkeySecond, TEXT("PATH"), NULL, NULL, szPath, &cbValue) == ERROR_SUCCESS)
                {
                    // this is a ";" separated list
                    LPTSTR psz = StrChr(szPath, TEXT(';'));
                    if (psz)
                        *psz = 0;
                    PathUnquoteSpaces(szPath);
                    pfnrlcb(hdpa, hkeySecond, NULL, TEXT("PATH"), szPath, pszSource, pszDest);
                }

                RegCloseKey(hkeySecond);
            }
        }
        RegCloseKey(hkeyRoot);
    }
    return TRUE;
}

// This is the call back called to build the list of paths.

BOOL CALLBACK _RLBuildListCallBack(HDPA hdpa, HKEY hkey, LPCTSTR pszKey,
        LPCTSTR pszValueName, LPTSTR pszValue, LPCTSTR pszSource, LPCTSTR pszDest)
{
    int iIndex;

    // Also don't add any relative paths.
    if (PathIsRelative(pszValue) || (lstrlen(pszValue) < 3))
        return TRUE;

    // Don't try UNC names as this can get expensive...
    if (PathIsUNC(pszValue))
        return TRUE;

    // If it is already in our list, we can simply return now..
    if (DPA_Search(hdpa, pszValue, 0, _CompareStrings, 0, DPAS_SORTED) != -1)
        return TRUE;

    // If it is in our old list then
    if (g_rlpi.hdpaRLList && ((iIndex = DPA_Search(g_rlpi.hdpaRLList, pszValue, 0,
            _CompareStrings, 0, DPAS_SORTED)) != -1))
    {
        // Found the item in the old list.
        TraceMsg(TF_REG, "_RLBuildListCallBack: Add from old list %s", pszValue);

        DPA_InsertPtr(hdpa,
                    DPA_Search(hdpa, pszValue, 0,
                    _CompareStrings, 0,
                    DPAS_SORTED|DPAS_INSERTBEFORE),
                    (LPTSTR)DPA_FastGetPtr(g_rlpi.hdpaRLList, iIndex));
        // now remove it from the old list
        DPA_DeletePtr(g_rlpi.hdpaRLList, iIndex);
    }
    else
    {
        // Not in either list.
        // Now see if we can convert the short name to a long name

        TCHAR szLongName[MAX_PATH];
        int cchName;
        int cchLongName;
        LPTSTR psz;

        if (!GetLongPathName(pszValue, szLongName, ARRAYSIZE(szLongName)))
            szLongName[0] = 0;

        if (lstrcmpi(szLongName, pszValue) == 0)
            szLongName[0] = 0;   // Don't need both strings.

        cchName = lstrlen(pszValue);
        cchLongName =lstrlen(szLongName);

        psz = (LPTSTR)LocalAlloc(LPTR,
                (cchName + 1 + cchLongName + 1) * sizeof(TCHAR));
        if (psz)
        {
            HRESULT hr;
            BOOL fOk;

            TraceMsg(TF_REG, "_RLBuildListCallBack: Add %s", pszValue);

            hr = StringCchCopy(psz, cchName + 1, pszValue);
            if (FAILED(hr))
            {
                fOk = FALSE;
            }
            hr = StringCchCopy(psz + cchName + 1, cchLongName + 1, szLongName);
            if (FAILED(hr))
            {
                fOk = FALSE;
            }

            if (fOk)
            {
                return DPA_InsertPtr(hdpa,
                        DPA_Search(hdpa, pszValue, 0,
                        _CompareStrings, 0,
                        DPAS_SORTED|DPAS_INSERTBEFORE),
                        psz);
            }
        }
    }
    return TRUE;
}

// This function will build the list of items that we
//      will look through to see if the user may have changed the path of
//      of one of the programs that is registered in the registry.
//

BOOL WINAPI RLBuildListOfPaths()
{
    BOOL fRet = FALSE;
    HDPA hdpa;

    DEBUG_CODE( DWORD   dwStart = GetCurrentTime(); )

    RLEnterCritical();

    hdpa = DPA_Create(0);
    if (!hdpa)
        goto Error;


    // And initialize the list
    fRet = RLEnumRegistry(hdpa, _RLBuildListCallBack, NULL, NULL);


    // If we had on old list destroy it now.

    if (g_rlpi.hdpaRLList)
    {
        // Walk through all of the items in the list and
        // delete all of the strings.
        int i;
        for (i = DPA_GetPtrCount(g_rlpi.hdpaRLList)-1; i >= 0; i--)
            LocalFree((HLOCAL)DPA_FastGetPtr(g_rlpi.hdpaRLList, i));
        DPA_Destroy(g_rlpi.hdpaRLList);
    }

    g_rlpi.hdpaRLList = hdpa;
    g_rlpi.fListValid = TRUE;     // Say that we are valid...

    DEBUG_CODE( TraceMsg(TF_REG, "RLBuildListOfPaths time: %ld", GetCurrentTime()-dwStart); )

Error:

    RLLeaveCritical();
    return fRet;
}

// this function does any cleanup necessary for when a process
//      is no longer going to use the Registry list.

void WINAPI RLTerminate()
{
    int i;

    if (!g_rlpi.hdpaRLList)
        return;

    RLEnterCritical();

    // Re-check under critical section in case somebody else destroyed
    // it while we were waiting
    if (g_rlpi.hdpaRLList)
    {
        // Walk through all of the items in the list and
        // delete all of the strings.
        for (i = DPA_GetPtrCount(g_rlpi.hdpaRLList)-1; i >= 0; i--)
            LocalFree((HLOCAL)DPA_FastGetPtr(g_rlpi.hdpaRLList, i));

        DPA_Destroy(g_rlpi.hdpaRLList);
        g_rlpi.hdpaRLList = NULL;
    }
    RLLeaveCritical();
}

// This function returns TRUE if the path that is passed
// in is contained in one or more of the paths that we extracted from
// the registry.

int WINAPI RLIsPathInList(LPCTSTR pszPath)
{
    int i = -1;
    RLEnterCritical();

    if (!g_rlpi.hdpaRLList || !g_rlpi.fListValid)
        RLBuildListOfPaths();

    if (g_rlpi.hdpaRLList)
    {
        int cchPath = lstrlen(pszPath);

        for (i = DPA_GetPtrCount(g_rlpi.hdpaRLList) - 1; i >= 0; i--)
        {
            LPTSTR psz = DPA_FastGetPtr(g_rlpi.hdpaRLList, i);
            if (PathCommonPrefix(pszPath, psz, NULL) == cchPath)
                break;

            // See if a long file name to check.
            psz += lstrlen(psz) + 1;
            if (*psz && (PathCommonPrefix(pszPath, psz, NULL) == cchPath))
                break;
        }
    }

    RLLeaveCritical();

    return i;   // -1 if none, >= 0 index
}

// This is the call back called to build the list of of paths.
//
BOOL CALLBACK _RLRenameCallBack(HDPA hdpa, HKEY hkey, LPCTSTR pszKey,
        LPCTSTR pszValueName, LPTSTR pszValue, LPCTSTR pszSource, LPCTSTR pszDest)
{
    int cbMatch = PathCommonPrefix(pszValue, pszSource, NULL);
    if (cbMatch == lstrlen(pszSource))
    {
        TCHAR szPath[MAX_PATH+64];   // Add some slop just in case...
        // Found a match, lets try to rebuild the new line
        StringCchCopy(szPath, ARRAYSIZE(szPath), pszDest);
        StringCchCat(szPath, ARRAYSIZE(szPath), pszValue + cbMatch);

        if (pszValueName)
            RegSetValueEx(hkey, pszValueName, 0, REG_SZ, (BYTE *)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
        else
            RegSetValue(hkey, pszKey, REG_SZ, szPath, lstrlen(szPath));
    }

    // Make sure that we have not allready added
    // this path to our list.
    if (DPA_Search(hdpa, pszValue, 0, _CompareStrings, 0, DPAS_SORTED) == -1)
    {
        // One to Add!
        LPTSTR psz = StrDup(pszValue);
        if (psz)
        {
            return DPA_InsertPtr(hdpa,
                    DPA_Search(hdpa, pszValue, 0,
                    _CompareStrings, 0,
                    DPAS_SORTED | DPAS_INSERTBEFORE), psz);
        }
    }
    return TRUE;
}

// This function handles the cases when we are notified of
// a change to the file system and then we need to see if there are
// any changes that we need to make to the regisry to handle the changes.

int WINAPI RLFSChanged(LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra)
{
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH+8];     // For slop like Quotes...
    int iIndex;
    LPTSTR psz;
    int iRet = -1;
    int i;

    // First see if the operation is something we are interested in.
    if ((lEvent & (SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER)) == 0)
        return -1; // Nope

    if (!SHGetPathFromIDList(pidl, szSrc))
    {
        // must be a rename of a non-filesys object (such as a printer!)
        return -1;
    }

    SHGetPathFromIDList(pidlExtra, szDest);

    // If either are roots we really can not rename them...
    if (PathIsRoot(szSrc) || PathIsRoot(szDest))
        return -1;

    // ignore if coming from bitbucket or going to ...
    // check bitbucket first.  that's a cheap call
    if ((lEvent & SHCNE_RENAMEITEM) &&
        (IsFileInBitBucket(szSrc) || IsFileInBitBucket(szDest)))
        return -1;

    RLEnterCritical();
    // Now see if the source file is in our list of paths
    iIndex = RLIsPathInList(szSrc);
    if (iIndex != -1)
    {
        // Now make sure we are working with the short name
        // Note we may only be a subpiece of this item.
        // Count how many fields there are in the szSrc Now;
        for (i = 0, psz = szSrc; psz; i++)
        {
            psz = StrChr(psz + 1, TEXT('\\'));
        }
        StringCchCopy(szSrc, ARRAYSIZE(szSrc), (LPTSTR)DPA_FastGetPtr(g_rlpi.hdpaRLList, iIndex));

        // Now truncate off stuff that is not from us Go one more then we countd
        // above and if we have a non null value cut it off there.
        for (psz = szSrc; i > 0; i--)
        {
            psz = StrChr(psz+1, TEXT('\\'));
        }
        if (psz)
            *psz = 0;

        // verify that this is a fully qulified path and that it exists
        // before we go and muck with the registry.
        if (!PathIsRelative(szDest) && PathFileExistsAndAttributes(szDest, NULL) && (lstrlen(szDest) >= 3))
        {
            // Yes, so now lets reenum and try to update the paths...
            PathGetShortPath(szDest);        // Convert to a short name...
            RLEnumRegistry(g_rlpi.hdpaRLList, _RLRenameCallBack, szSrc, szDest);

            // We changed something so mark it to be rebuilt
            g_rlpi.fListValid = FALSE;     // Force it to rebuild.
            iRet = 1;
        }
    }
    RLLeaveCritical();

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\recdocs.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1996
//
// File:      recdocs.cpp
//
// History -  created from recent.c in explorer  - ZekeL - 5-MAR-98
//              combining functionality in to one place
//              now that the desktop lives here.
//---------------------------------------------------------------------------

#include "shellprv.h"
#include "recdocs.h"
#include "fstreex.h"
#include "shcombox.h"
#include "ids.h"
#include <urlhist.h>
#include <runtask.h>

#define DM_RECENTDOCS 0x00000000

#define GETRECNAME(p) ((LPCTSTR)(p))
#define GETRECPIDL(p) ((LPCITEMIDLIST) (((LPBYTE) (p)) + CbFromCch(lstrlen(GETRECNAME(p)) +1)))

#define REGSTR_KEY_RECENTDOCS TEXT("RecentDocs")

#define MAX_RECMRU_BUF      (CbFromCch(3 * MAX_PATH))   // Max MRUBuf size

// Used to blow off adding the same file multiple times
TCHAR g_szLastFile[MAX_URL_STRING] = {0};
FILETIME g_ftLastFileCacheUpdate = {0};

STDAPI_(BOOL) SetFolderString(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszData);

STDAPI_(void) OpenWithListSoftRegisterProcess(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszProcess);

class CTaskAddDoc : public CRunnableTask
{
public:
    CTaskAddDoc();
    HRESULT Init(HANDLE hMem, DWORD dwProcId);

    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void);

private:
    virtual ~CTaskAddDoc();

    void _AddToRecentDocs(LPCITEMIDLIST pidlItem, LPCTSTR pszPath);
    void _TryDeleteMRUItem(IMruDataList *pmru, DWORD cMax, LPCTSTR pszFileName, LPCITEMIDLIST pidlItem, IMruDataList *pmruOther, BOOL fOverwrite);
    LPBYTE _CreateMRUItem(LPCITEMIDLIST pidlItem, LPCTSTR pszItem, DWORD *pcbItem, UINT uFlags);
    BOOL _AddDocToRecentAndExtRecent(LPCITEMIDLIST pidlItem, LPCTSTR pszFileName, LPCTSTR pszExt);
    void _TryUpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszFolder);
    void _UpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszShare);

    //  private members
    HANDLE _hMem;
    DWORD  _dwProcId;
    IMruDataList *_pmruRecent;
    DWORD _cMaxRecent;
    LPITEMIDLIST _pidlTarget;
};


BOOL ShouldAddToRecentDocs(LPCITEMIDLIST pidl)
{
    BOOL fRet = TRUE;  //  default to true
    IQueryAssociations *pqa;
    if (SUCCEEDED(SHGetAssociations(pidl, (void **)&pqa)))
    {
        DWORD dwAttributes, dwSize = sizeof(dwAttributes);
        if (SUCCEEDED(pqa->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwAttributes, &dwSize)))
        {
            fRet = !(dwAttributes & FTA_NoRecentDocs);
        }
        pqa->Release();
    }  
    return fRet;
}

int RecentDocsComparePidl(const BYTE * p1, const BYTE *p2, int cb)
{
    int iRet;

    LPCIDFOLDER pidf1 = CFSFolder_IsValidID((LPCITEMIDLIST)p1);
    LPCIDFOLDER pidf2 = CFSFolder_IsValidID(GETRECPIDL(p2));

    if (pidf1 && pidf2)
    {
        iRet = CFSFolder_CompareNames(pidf1, pidf2);
    }
    else
    {
        ASSERTMSG(0, "Caller shouldn't be passing in bogus data");
        // return 0 (equal) if they're both NULL.
        iRet = (pidf1 != pidf2);
    }

    return iRet;
}

CTaskAddDoc::~CTaskAddDoc(void)
{
    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc destroyed", this);
}

CTaskAddDoc::CTaskAddDoc(void) : CRunnableTask(RTF_DEFAULT)
{
    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc created", this);
}


HRESULT CTaskAddDoc::Init( HANDLE hMem, DWORD dwProcId)
{
    if (hMem)
    {
        _hMem = hMem;
        _dwProcId = dwProcId;
        return S_OK;
    }
    return E_FAIL;
}

typedef struct {
    DWORD   dwOffsetPath;
    DWORD   dwOffsetPidl;
    DWORD   dwOffsetProcess;
} XMITARD;


LPCTSTR _OffsetToStrValidate(void *px, DWORD dw)
{
    LPCTSTR psz = dw ? (LPTSTR)((LPBYTE)px + dw) : NULL;
    return psz;
}

HRESULT CTaskAddDoc::RunInitRT(void)
{
    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc::RunInitRT() running", this);

    XMITARD *px = (XMITARD *)SHLockShared(_hMem, _dwProcId);
    if (px)
    {
        LPITEMIDLIST pidl = px->dwOffsetPidl ? (LPITEMIDLIST)((LPBYTE)px+px->dwOffsetPidl) : NULL;
        LPCTSTR pszPath = _OffsetToStrValidate(px, px->dwOffsetPath);
        LPCTSTR pszProcess = _OffsetToStrValidate(px, px->dwOffsetProcess);

        ASSERT(pszPath);
        
        if (pszPath && pszProcess)
            OpenWithListSoftRegisterProcess(0, PathFindExtension(pszPath), pszProcess);

        _AddToRecentDocs(pidl, pszPath);

        SHUnlockShared(px);
        SHFreeShared(_hMem, _dwProcId);
    }
    
    return S_OK;
}


BOOL GetExtensionClassDescription(LPCTSTR pszFile)
{
    LPTSTR pszExt = PathFindExtension(pszFile);
    HKEY hk;
    if (*pszExt && SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, pszExt, NULL, &hk)))
    {
        RegCloseKey(hk);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(void) FlushRunDlgMRU(void);

#define MAXRECENT_DEFAULTDOC      10
#define MAXRECENT_MAJORDOC        20

//  SRMLF_* flags to pass into CreateSharedRecentMRUList()
#define SRMLF_COMPNAME  0x00000000   // default:  compare using the name of the recent file
#define SRMLF_COMPPIDL  0x00000001   // use the pidl in the recent folder


IMruDataList *CreateSharedRecentMRUList(LPCTSTR pszClass, DWORD *pcMax, DWORD dwFlags)
{
    IMruDataList *pmru = NULL;

    if (SHRestricted(REST_NORECENTDOCSHISTORY))
        return NULL;

    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, REGSTR_KEY_RECENTDOCS, TRUE);

    if (hk)
    {
        DWORD cMax;

        if (pszClass)
        {

            //  we need to find out how many
            if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszClass, TEXT("MajorDoc"), NULL, NULL, NULL))
                cMax = MAXRECENT_MAJORDOC;
            else
                cMax = MAXRECENT_DEFAULTDOC;
        }
        else
        {
            //  this the root MRU
            cMax = SHRestricted(REST_MaxRecentDocs);

            //  default max docs...
            if (cMax < 1)
                cMax = MAXRECENTDOCS * MAXRECENT_DEFAULTDOC;
        }

        if (pcMax)
            *pcMax = cMax;

        if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_MruLongList, NULL, IID_PPV_ARG(IMruDataList, &pmru))))
        {
            if (FAILED(pmru->InitData(cMax, MRULISTF_USE_STRCMPIW, hk, pszClass, dwFlags & SRMLF_COMPPIDL ? RecentDocsComparePidl : NULL)))
            {
                pmru->Release();
                pmru = NULL;
            }
        }

        RegCloseKey(hk);
    }
    
    return pmru;
}

HRESULT CreateRecentMRUList(IMruDataList **ppmru)
{
    *ppmru = CreateSharedRecentMRUList(NULL, NULL, SRMLF_COMPPIDL);
    return *ppmru ? S_OK : E_OUTOFMEMORY;
}



//
//  _CleanRecentDocs()
//  cleans out the recent docs folder and the associate registry keys.
//
void _CleanRecentDocs(void)
{
    LPITEMIDLIST pidlTargetLocal = SHCloneSpecialIDList(NULL, CSIDL_RECENT, TRUE);
    if (pidlTargetLocal)
    {
        TCHAR szDir[MAX_PATH];

        // first, delete all the files
        SHFILEOPSTRUCT sFileOp =
        {
            NULL,
            FO_DELETE,
            szDir,
            NULL,
            FOF_NOCONFIRMATION | FOF_SILENT,
        };
        
        SHGetPathFromIDList(pidlTargetLocal, szDir);
        szDir[lstrlen(szDir) +1] = 0;     // double null terminate
        SHFileOperation(&sFileOp);


        ILFree(pidlTargetLocal);

        pidlTargetLocal = SHCloneSpecialIDList(NULL, CSIDL_NETHOOD, TRUE);

        if (pidlTargetLocal)
        {
            //  now we take care of cleaning out the nethood
            //  we have to more careful, cuz we let other people
            //  add their own stuff in here.
            
            IMruDataList *pmru = CreateSharedRecentMRUList(TEXT("NetHood"), NULL, SRMLF_COMPPIDL);

            if (pmru)
            {
                IShellFolder* psf;

                if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlTargetLocal, &psf))))
                {
                    BOOL fUpdate = FALSE;
                    int iItem = 0;
                    LPITEMIDLIST pidlItem;

                    ASSERT(psf);

                    while (SUCCEEDED(RecentDocs_Enum(pmru, iItem++, &pidlItem)))
                    {
                        ASSERT(pidlItem);
                        STRRET str;
                        if (SUCCEEDED(psf->GetDisplayNameOf(pidlItem, SHGDN_FORPARSING, &str))
                        && SUCCEEDED(StrRetToBuf(&str, pidlItem, szDir, ARRAYSIZE(szDir))))
                        {
                            szDir[lstrlen(szDir) +1] = 0;     // double null terminate
                            SHFileOperation(&sFileOp);
                        }
                            
                        ILFree(pidlItem);
                    }

                    if (fUpdate)
                        SHChangeNotify(SHCNE_UPDATEDIR, 0, (void *)pidlTargetLocal, NULL);

                    psf->Release();
                }

                pmru->Release();
            }

            ILFree(pidlTargetLocal);
        }

        //  force the recreation of the recent folder.
        SHGetFolderPath(NULL, CSIDL_RECENT | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, szDir);

        // now delete the registry stuff
        HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, FALSE);
        if (hk)
        {
            SHDeleteKey(hk, REGSTR_KEY_RECENTDOCS);
            RegCloseKey(hk);
        }

        SHChangeNotifyHandleEvents();
    }
    
    FlushRunDlgMRU();

    ENTERCRITICAL;
    g_szLastFile[0] = 0;
    g_ftLastFileCacheUpdate.dwLowDateTime = 0;
    g_ftLastFileCacheUpdate.dwHighDateTime = 0;
    LEAVECRITICAL;

    return;
}

//
//  WARNING - _TryDeleteMRUItem() returns an allocated string that must be freed
//
void CTaskAddDoc::_TryDeleteMRUItem(IMruDataList *pmru, DWORD cMax, LPCTSTR pszFileName, LPCITEMIDLIST pidlItem, IMruDataList *pmruOther, BOOL fOverwrite)
{
    BYTE buf[MAX_RECMRU_BUF] = {0};

    DWORD cbItem = CbFromCch(lstrlen(pszFileName) + 1);
    int iItem;
    if (!fOverwrite || FAILED(pmru->FindData((BYTE *)pszFileName, cbItem, &iItem)))
    {
        //
        //  if iItem is not -1 then it is already existing item that we will replace.
        //  if it is -1 then we need to point iItem to the last in the list.
        //  torch the last one if we have the max number of items in the list.
        //  default to success, cuz if we dont find it we dont need to delete it
        iItem = cMax - 1;
    }

    //  if we cannot get it in order to delete it, 
    //  then we will not overwrite the item.
    if (SUCCEEDED(pmru->GetData(iItem, buf, sizeof(buf))))
    {
        //  convert the buf into the last segment of the pidl
        LPITEMIDLIST pidlFullLink = ILCombine(_pidlTarget, GETRECPIDL(buf));
        if (pidlFullLink)
        {
            // This is semi-gross, but some link types like calling cards are the
            // actual data.  If we delete and recreate they lose their info for the
            // run.  We will detect this by knowing that their pidl will be the
            // same as the one we are deleting...
            if (!ILIsEqual(pidlFullLink, pidlItem))
            {
                TCHAR sz[MAX_PATH];

                // now remove out link to it
                SHGetPathFromIDList(pidlFullLink, sz);

                Win32DeleteFile(sz);
                TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc::_TryDeleteMRUItem() deleting '%s'", this, sz);   

                if (pmruOther) 
                {
                    //  deleted a shortcut, 
                    //  need to try and remove it from the pmruOther...
                    if (SUCCEEDED(pmruOther->FindData((BYTE *)GETRECNAME(buf), CbFromCch(lstrlen(GETRECNAME(buf)) +1), &iItem)))
                        pmruOther->Delete(iItem);
                }
            }
            ILFree(pidlFullLink);
        }
    }
}

// in:
// pidlItem - full IDList for the item being added
// pszItem  - name (file spec) of the item (used in the display to the user)
// uFlags   - SHCL_ flags

LPBYTE CTaskAddDoc::_CreateMRUItem(LPCITEMIDLIST pidlItem, LPCTSTR pszItem, 
                                   DWORD *pcbOut, UINT uFlags)
{
    TCHAR sz[MAX_PATH];
    LPBYTE pitem = NULL;

    // create the new one
    if (SHGetPathFromIDList(_pidlTarget, sz)) 
    {
        LPITEMIDLIST pidlFullLink;

        if (SUCCEEDED(CreateLinkToPidl(pidlItem, sz, &pidlFullLink, uFlags)) &&
            pidlFullLink)
        {
            LPCITEMIDLIST pidlLinkLast = ILFindLastID(pidlFullLink);
            int cbLinkLast = ILGetSize(pidlLinkLast);
            DWORD cbItem = CbFromCch(lstrlen(pszItem) + 1);

            pitem = (LPBYTE) LocalAlloc(NONZEROLPTR, cbItem + cbLinkLast);
            if (pitem)
            {
                memcpy( pitem, pszItem, cbItem );
                memcpy( pitem + cbItem, pidlLinkLast, cbLinkLast);
                *pcbOut = cbItem + cbLinkLast;
            }
            ILFree(pidlFullLink);
        }
    }
    
    return pitem;
}

HRESULT RecentDocs_Enum(IMruDataList *pmru, int iItem, LPITEMIDLIST *ppidl)
{
    BYTE buf[MAX_RECMRU_BUF] = {0};
    *ppidl = NULL;
        
    if (SUCCEEDED(pmru->GetData(iItem, buf, sizeof(buf))))
    {
        *ppidl = ILClone(GETRECPIDL(buf));
    }

    return *ppidl ? S_OK : E_FAIL;
}
BOOL CTaskAddDoc::_AddDocToRecentAndExtRecent(LPCITEMIDLIST pidlItem, LPCTSTR pszFileName, 
                                              LPCTSTR pszExt)
{
    DWORD cbItem = CbFromCch(lstrlen(pszFileName) + 1);
    DWORD cMax;
    IMruDataList *pmru = CreateSharedRecentMRUList(pszExt, &cMax, SRMLF_COMPNAME);

    _TryDeleteMRUItem(_pmruRecent, _cMaxRecent, pszFileName, pidlItem, pmru, TRUE);

    LPBYTE pitem = _CreateMRUItem(pidlItem, pszFileName, &cbItem, 0);
    if (pitem)
    {
        _pmruRecent->AddData(pitem, cbItem, NULL);

        if (pmru)
        {
            //  we dont want to delete the file if it already existed, because
            //  the TryDelete on the RecentMRU would have already done that
            //  we only want to delete if we have some overflow from the ExtMRU
            _TryDeleteMRUItem(pmru, cMax, pszFileName, pidlItem, _pmruRecent, FALSE);

            //  can reuse the already created item to this mru
            pmru->AddData(pitem, cbItem, NULL);

            pmru->Release();
        }
                
        LocalFree(pitem);
    }

    //  its been freed but not nulled out...
    return (pitem != NULL);
}


// 
//  WARNING:  UpdateNetHood() changes _pidlTarget to the NetHood then frees it!
//
void CTaskAddDoc::_UpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszShare)
{
    if (SHRestricted(REST_NORECENTDOCSNETHOOD))
        return;

    //  need to add this boy to the Network Places
    LPITEMIDLIST pidl = ILCreateFromPath(pszShare);
    if (pidl)
    {
        //
        //  NOTE - must verify parentage here - ZekeL - 27-MAY-99
        //  http servers exist in both the webfolders namespace 
        //  and the Internet namespace.  thus we must make sure
        //  that what ever parent the folder had, the share has
        //  the same one.
        //
        if (ILIsParent(pidl, pidlFolder, FALSE))
        {
            ASSERT(_pidlTarget);
            ILFree(_pidlTarget);
            
            _pidlTarget = SHCloneSpecialIDList(NULL, CSIDL_NETHOOD, TRUE);
            if (_pidlTarget)
            {
                DWORD cMax;
                IMruDataList *pmru = CreateSharedRecentMRUList(TEXT("NetHood"), &cMax, SRMLF_COMPNAME);
                if (pmru)
                {
                    _TryDeleteMRUItem(pmru, cMax, pszShare, pidl, NULL, TRUE);
                    DWORD cbItem = CbFromCch(lstrlen(pszShare) + 1);
                    // SHCL_NOUNIQUE - if there is already a shortcut with the same name,
                    // just overwrite it; this avoids pointless duplicates in nethood
                    LPBYTE pitem = _CreateMRUItem(pidl, pszShare, &cbItem, SHCL_MAKEFOLDERSHORTCUT | SHCL_NOUNIQUE);
                    if (pitem)
                    {
                        pmru->AddData(pitem, cbItem, NULL);
                        LocalFree(pitem);
                    }

                    pmru->Release();
                }

                ILFree(_pidlTarget);
                _pidlTarget = NULL;
            }
        }
        
        ILFree(pidl);
    }
}
            
BOOL _IsPlacesFolder(LPCTSTR pszFolder)
{
    static const UINT places[] = {
        CSIDL_PERSONAL,
        CSIDL_DESKTOPDIRECTORY,
        CSIDL_COMMON_DESKTOPDIRECTORY,
        CSIDL_NETHOOD,
        CSIDL_FAVORITES,
    };
    return PathIsOneOf(pszFolder, places, ARRAYSIZE(places));
}

void _AddToUrlHistory(LPCTSTR pszPath)
{
    ASSERT(pszPath);
    WCHAR szUrl[MAX_URL_STRING];
    DWORD cchUrl = ARRAYSIZE(szUrl);

    //  the URL parsing APIs tolerate same in/out buffer
    if (SUCCEEDED(UrlCreateFromPathW(pszPath, szUrl, &cchUrl, 0)))
    {
        IUrlHistoryStg *puhs;
        if (SUCCEEDED(CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, 
                IID_PPV_ARG(IUrlHistoryStg, &puhs))))
        {
            ASSERT(puhs);
            puhs->AddUrl(szUrl, NULL, 0);
            puhs->Release();
        }
    }
}

void CTaskAddDoc::_TryUpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszFolder)
{
    TCHAR sz[MAX_URL_STRING];
    DWORD cch = SIZECHARS(sz);
    BOOL fUpdate = FALSE;
    // changing szFolder, and changing _pidlTarget here...
    //  if this is an URL or a UNC share add it to the nethood

    if (UrlIs(pszFolder, URLIS_URL) 
    && !UrlIs(pszFolder, URLIS_OPAQUE)
    && SUCCEEDED(UrlCombine(pszFolder, TEXT("/"), sz, &cch, 0)))
        fUpdate = TRUE;
    else if (PathIsUNC(pszFolder) 
    && (S_OK == StringCchCopy(sz, cch, pszFolder))
    && PathStripToRoot(sz))
        fUpdate = TRUE;

    if (fUpdate)
        _UpdateNetHood(pidlFolder, sz);
}

//-----------------------------------------------------------------
//
// Add the named file to the Recently opened MRU list, that is used
// by the shell to display the recent menu of the tray.

// this registry will hold two pidls:  the target pointing to followed by
// the pidl of the link created pointing it.  In both cases,
// only the last item id is stored. (we may want to change this... but
// then again, we may not)

void CTaskAddDoc::_AddToRecentDocs(LPCITEMIDLIST pidlItem, LPCTSTR pszItem)
{
    TCHAR szUnescaped[MAX_PATH];
    LPTSTR pszFileName;

    //  if these are NULL the caller meant to call _CleanRecentDocs()
    ASSERT(pszItem && *pszItem);

    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc::_AddToRecentDocs() called for '%s'", this, pszItem);   
    // allow only classes with default commands
    //
    //  dont add if:
    //     it is RESTRICTED
    //     it is in the temporary directory
    //     it actually has a file name
    //     it can be shell exec'd with "open" verb
    //
    if ( (SHRestricted(REST_NORECENTDOCSHISTORY))     ||
         (PathIsTemporary(pszItem))                   ||
         (!(pszFileName = PathFindFileName(pszItem))) ||
         (!*pszFileName)                              ||
         (!GetExtensionClassDescription(pszFileName))   
       )  
        return;

    //  pretty up the URL file names.
    if (UrlIs(pszItem, URLIS_URL))
    {
        StringCchCopy(szUnescaped, ARRAYSIZE(szUnescaped), pszFileName);
        UrlUnescapeInPlace(szUnescaped, 0);
        pszFileName = szUnescaped;
    }
    
    //  otherwise we try our best.
    ASSERT(!_pidlTarget);
    _pidlTarget = SHCloneSpecialIDList(NULL, CSIDL_RECENT, TRUE);
    if (_pidlTarget) 
    {
        _pmruRecent = CreateSharedRecentMRUList(NULL, &_cMaxRecent, SRMLF_COMPNAME);
        if (_pmruRecent)
        {
            if (_AddDocToRecentAndExtRecent(pidlItem, pszFileName, PathFindExtension(pszFileName)))
            {
                _AddToUrlHistory(pszItem);
                //  get the folder and do it to the folder
                LPITEMIDLIST pidlFolder = ILClone(pidlItem);
                
                if (pidlFolder)
                {
                    ILRemoveLastID(pidlFolder);
                    //  if it is a folder we already have quick
                    //  access to from the shell, dont put it in here

                    TCHAR szFolder[MAX_URL_STRING];
                    if (SUCCEEDED(SHGetNameAndFlags(pidlFolder, SHGDN_FORPARSING, szFolder, SIZECHARS(szFolder), NULL))
                    && !_IsPlacesFolder(szFolder))
                    {
                        //  get the friendly name for the folder
                        TCHAR szTitle[MAX_PATH];
                        if (FAILED(SHGetNameAndFlags(pidlFolder, SHGDN_NORMAL, szTitle, SIZECHARS(szTitle), NULL)))
                            StringCchCopy(szTitle, ARRAYSIZE(szTitle), PathFindFileName(szFolder));
                            
                        _AddDocToRecentAndExtRecent(pidlFolder, szTitle, TEXT("Folder"));

                        _TryUpdateNetHood(pidlFolder, szFolder);
                    }
                    
                    ILFree(pidlFolder);
                }
            }
            
            _pmruRecent->Release();
            _pmruRecent = NULL;
        }

        //cleanup
        if (_pidlTarget)
        {
            ILFree(_pidlTarget);
            _pidlTarget = NULL;
        }
    }
    
    SHChangeNotifyHandleEvents();
}

// This cache helps winstone!
// The 1 minute timeout is incase another process cleared recent docs, or filled it
// to capacity & scrolled out our cached item.

#define FT_ONEMINUTE (10000000*60)

BOOL CheckIfFileIsCached(LPCTSTR pszItem)
{
    BOOL bRet = FALSE;

    ENTERCRITICAL;
    if (StrCmp(pszItem, g_szLastFile) == 0)
    {
        FILETIME ftNow;
        GetSystemTimeAsFileTime(&ftNow);

        // Pull one minute off the current time, then compare to cache time
        DecrementFILETIME(&ftNow, FT_ONEMINUTE);

        // if the cache'd time is greater than 1 minute ago, use cache
        if (CompareFileTime(&g_ftLastFileCacheUpdate, &ftNow) >= 0)
            bRet = TRUE;
    }
    LEAVECRITICAL;
    return bRet;
}


void AddToRecentDocs(LPCITEMIDLIST pidl, LPCTSTR pszItem)
{
    HWND hwnd = GetShellWindow();
    // Check to see if we just added the same file to recent docs.
    //  or this is an executeable
    //  or something else that shouldnt be added
    if (!CheckIfFileIsCached(pszItem)
    && (!PathIsExe(pszItem))
    && (ShouldAddToRecentDocs(pidl))
    && (hwnd))
    {
        DWORD cchPath = lstrlen(pszItem);
        DWORD cbSizePidl = ILGetSize(pidl);
        DWORD cbSizePath = CbFromCch(cchPath + 1);
        XMITARD *px;
        DWORD dwProcId, dwOffset;
        HANDLE hARD;
        TCHAR szApp[MAX_PATH];  // name of the app which is calling us
        DWORD cbSizeApp;
        DWORD cbSizePidlRound, cbSizePathRound, cbSizeAppRound;

        ASSERT(cchPath != 0);

        GetWindowThreadProcessId(hwnd, &dwProcId);
        if (GetModuleFileName(NULL, szApp, ARRAYSIZE(szApp)) && szApp[0])
            cbSizeApp = CbFromCch(1 + lstrlen(szApp));
        else
            cbSizeApp = 0;

        cbSizePidlRound = ROUNDUP(cbSizePidl,4);
        cbSizePathRound = ROUNDUP(cbSizePath,4);
        cbSizeAppRound  = ROUNDUP(cbSizeApp,4);

        hARD = SHAllocShared(NULL, sizeof(XMITARD) + cbSizePathRound + cbSizePidlRound + cbSizeAppRound, dwProcId);
        if (!hARD)
            return;         // Well, we are going to miss one, sorry.

        px = (XMITARD *)SHLockShared(hARD,dwProcId);
        if (!px)
        {
            SHFreeShared(hARD,dwProcId);
            return;         // Well, we are going to miss one, sorry.
        }

        px->dwOffsetPidl = 0;
        px->dwOffsetPath = 0;
        px->dwOffsetProcess = 0;

        dwOffset = sizeof(XMITARD);

        {
            px->dwOffsetPath = dwOffset;
            memcpy((LPBYTE)px + dwOffset, pszItem, cbSizePath);
            dwOffset += cbSizePathRound;
        }

        {
            px->dwOffsetPidl = dwOffset;
            memcpy((LPBYTE)px + dwOffset, pidl, cbSizePidl);
            dwOffset += cbSizePidlRound;
        }

        if (cbSizeApp)
        {
            px->dwOffsetProcess = dwOffset;
            memcpy((LPBYTE)px + dwOffset, szApp, cbSizeApp);
        }


        SHUnlockShared(px);

        PostMessage(hwnd, CWM_ADDTORECENT, (WPARAM)hARD, (LPARAM)dwProcId);
        ENTERCRITICAL;
        StringCchCopy(g_szLastFile, ARRAYSIZE(g_szLastFile), pszItem);
        GetSystemTimeAsFileTime(&g_ftLastFileCacheUpdate);
        LEAVECRITICAL;
    }
}

HRESULT _ParseRecentDoc(LPCWSTR psz, LPITEMIDLIST *ppidl)
{
    BINDCTX_PARAM rgParams[] = 
    { 
        { STR_PARSE_TRANSLATE_ALIASES, NULL},
        { STR_PARSE_PREFER_FOLDER_BROWSING, NULL},
    };
    
    IBindCtx *pbc;
    HRESULT hr = BindCtx_RegisterObjectParams(NULL, rgParams, ARRAYSIZE(rgParams), &pbc);
    if (SUCCEEDED(hr))
    {
        hr = SHParseDisplayName(psz, pbc, ppidl, 0, 0);
        pbc->Release();
        
        if (FAILED(hr))
        {
            //  we need to fallback to a simple parsing
            IBindCtx *pbcSimple;
            hr = SHCreateFileSysBindCtx(NULL, &pbcSimple);
            if (SUCCEEDED(hr))
            {
                hr = BindCtx_RegisterObjectParams(pbcSimple, rgParams, ARRAYSIZE(rgParams), &pbc);
                if (SUCCEEDED(hr))
                {
                    hr = SHParseDisplayName(psz, pbc, ppidl, 0, 0);
                    pbc->Release();
                }
                pbcSimple->Release();
            }
        }
    }

    return hr;
}

//
// put things in the shells recent docs list for the start menu
//
// in:
//      uFlags  SHARD_ (shell add recent docs) flags
//      pv      LPCSTR or LPCITEMIDLIST (path or pidl indicated by uFlags)
//              may be NULL, meaning clear the recent list
//
STDAPI_(void) SHAddToRecentDocs(UINT uFlags, LPCVOID pv)
{
    TCHAR szTemp[MAX_URL_STRING]; // for double null

    TraceMsg(DM_RECENTDOCS, "SHAddToRecentDocs() called with %d, [%X]", uFlags, pv);
    
    if (pv == NULL)     // we should nuke all recent docs.
    {
        //  we do this synchronously
        _CleanRecentDocs();
        return;
    }

    if (SHRestricted(REST_NORECENTDOCSHISTORY))
        // Don't bother tracking recent documents if restriction is set
        // for privacy.
        return;

    switch (uFlags)
    {
    case SHARD_PIDL:
        // pv is a LPCITEMIDLIST (pidl)
        if (SUCCEEDED(SHGetNameAndFlags((LPCITEMIDLIST)pv, SHGDN_FORPARSING, szTemp, SIZECHARS(szTemp), NULL)))
        {
            AddToRecentDocs((LPCITEMIDLIST)pv, szTemp);
        }
        break;

    case SHARD_PATHA:
        //  pv is an ANSI path
        SHAnsiToUnicode((LPCSTR)pv, szTemp, ARRAYSIZE(szTemp));
        pv = szTemp;
        //  fall through to SHARD_PATHW;
    
    case SHARD_PATHW:
        {
            // pv is a UNICODE path
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_ParseRecentDoc((LPCWSTR)pv, &pidl)))
            {
                AddToRecentDocs(pidl, (LPCTSTR)pv);
                ILFree(pidl);
            }
            break;
        }
    default:
        ASSERTMSG(FALSE, "SHAddToRecent() called with invalid params");
        break;
    }
}

STDAPI CTaskAddDoc_Create(HANDLE hMem, DWORD dwProcId, IRunnableTask **pptask)
{
    HRESULT hres;
    CTaskAddDoc *ptad = new CTaskAddDoc();
    if (ptad)
    {
        hres = ptad->Init(hMem, dwProcId);
        if (SUCCEEDED(hres))
            hres = ptad->QueryInterface(IID_PPV_ARG(IRunnableTask, pptask));
        ptad->Release();
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}


STDAPI RecentDocs_GetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName, DWORD cchName)
{
    IMruDataList *pmru;
    HRESULT hr = CreateRecentMRUList(&pmru);

    if (SUCCEEDED(hr))
    {
        int iItem;
        hr = pmru->FindData((BYTE *)pidl, ILGetSize(pidl), &iItem);
        if (SUCCEEDED(hr))
        {
            BYTE buf[MAX_RECMRU_BUF];

            hr = pmru->GetData(iItem, buf, sizeof(buf));
            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(pszName,  cchName, GETRECNAME(buf));
            }
        }

        pmru->Release();
     }

     return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regenv.c ===
#define UNICODE 1

#include "shellprv.h"
#include <regapi.h>
#pragma  hdrstop

char * __cdecl StrTokEx (char ** pstring, const char * control);

//
// Value names for for different environment variables
//

#define PATH_VARIABLE            TEXT("Path")
#define LIBPATH_VARIABLE         TEXT("LibPath")
#define OS2LIBPATH_VARIABLE      TEXT("Os2LibPath")
#define AUTOEXECPATH_VARIABLE    TEXT("AutoexecPath")

#define HOMEDRIVE_VARIABLE       TEXT("HOMEDRIVE")
#define HOMESHARE_VARIABLE       TEXT("HOMESHARE")
#define HOMEPATH_VARIABLE        TEXT("HOMEPATH")

#define COMPUTERNAME_VARIABLE    TEXT("COMPUTERNAME")
#define USERNAME_VARIABLE        TEXT("USERNAME")
#define USERDOMAIN_VARIABLE      TEXT("USERDOMAIN")
#define USERDNSDOMAIN_VARIABLE   TEXT("USERDNSDOMAIN")
#define USERPROFILE_VARIABLE     TEXT("USERPROFILE")
#define ALLUSERSPROFILE_VARIABLE TEXT("ALLUSERSPROFILE")
#define OS_VARIABLE              TEXT("OS")
#define PROCESSOR_VARIABLE       TEXT("PROCESSOR_ARCHITECTURE")
#define PROCESSOR_LEVEL_VARIABLE TEXT("PROCESSOR_LEVEL")

#define SYSTEMDRIVE_VARIABLE     TEXT("SystemDrive")
#define SYSTEMROOT_VARIABLE      TEXT("SystemRoot")
#define PROGRAMFILES_VARIABLE    TEXT("ProgramFiles")
#define COMMONPROGRAMFILES_VARIABLE     TEXT("CommonProgramFiles")
#if defined(WX86) || defined(_WIN64)
#define PROGRAMFILESX86_VARIABLE        TEXT("ProgramFiles(x86)")
#define COMMONPROGRAMFILESX86_VARIABLE  TEXT("CommonProgramFiles(x86)")
#endif
#define SYSTEM_ENV_SUBKEY        TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment")
#define USER_ENV_SUBKEY          TEXT("Environment")
#define USER_VOLATILE_ENV_SUBKEY TEXT("Volatile Environment")

//
// Max environment variable length
//

#define MAX_VALUE_LEN          1024

//
// Parsing information for autoexec.bat
//
#define PARSE_AUTOEXEC_KEY     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define PARSE_AUTOEXEC_ENTRY   TEXT("ParseAutoexec")
#define PARSE_AUTOEXEC_DEFAULT TEXT("1")
#define MAX_PARSE_AUTOEXEC_BUFFER 2


#ifdef _X86_
BOOL IsPathIncludeRemovable(LPCTSTR lpValue)
{
    BOOL ret = FALSE;
    LPTSTR pszDup = StrDup(lpValue);
    if (pszDup)
    {
        LPTSTR pszTemp = pszDup;
        while (*pszTemp) 
        {
            // skip spaces
            for ( ; *pszTemp && *pszTemp == TEXT(' '); pszTemp++)
                ;

            // check if the drive is removable
            if (pszTemp[0] && pszTemp[1] && pszTemp[1] == TEXT(':') && pszTemp[2]) {        // ex) "A:\"
                TCHAR c = pszTemp[3];
                pszTemp[3] = 0;
                if (PathIsRemovable(pszTemp)) {
                    pszTemp[3] = c;
                    ret = TRUE;
                    break;
                }
                pszTemp[3] = c;
            }

            // skip to the next path
            for ( ; *pszTemp && *pszTemp != TEXT(';'); pszTemp++)
                ;
            if (*pszTemp)
                pszTemp++;
        }
        LocalFree(pszDup);
    }
    return ret;
}
#endif

/***************************************************************************\
* SetUserEvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL SetUserEnvironmentVariable(void **pEnv, LPTSTR lpVariable, LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    DWORD cch;
    TCHAR szValue[1024];

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }
    if (!NT_SUCCESS(RtlInitUnicodeStringEx(&Name, lpVariable)))
    {
        return FALSE;
    }
    cch = 1024;
    Value.Buffer = (PTCHAR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
    if (Value.Buffer) {
        Value.Length = 0;
        Value.MaximumLength = (USHORT)cch * sizeof(WCHAR);
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
        LocalFree(Value.Buffer);
        if (NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }
    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, ARRAYSIZE(szValue))) 
             {
                 lstrcpyn (szValue, lpValue, ARRAYSIZE(szValue));
             }
        } else {
            lstrcpyn (szValue, lpValue, ARRAYSIZE(szValue));
        }

        RtlInitUnicodeString(&Value, szValue); // known to be < 1024
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable( pEnv, &Name, NULL);
    }
    return NT_SUCCESS(Status);
}


/***************************************************************************\
* ExpandUserEvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
NTSTATUS ExpandUserEnvironmentStrings(void *pEnv, LPTSTR lpSrc, LPWSTR *ppszDst, int *pcchDst)
{
    NTSTATUS ntStatus;
    UNICODE_STRING Source, Destination;
    ULONG cbLength;

    *ppszDst = 0;
    *pcchDst = 0;
    
    ntStatus = RtlInitUnicodeStringEx(&Source, lpSrc);
    if (NT_SUCCESS(ntStatus))
    {
        Destination.Buffer = NULL;
        Destination.Length = 0;
        Destination.MaximumLength = 0;
        cbLength = 0;

        // RtlExpandEnvironmentStrings_U returns the byte count including space for the NULL
        ntStatus = RtlExpandEnvironmentStrings_U( pEnv, (PUNICODE_STRING)&Source, (PUNICODE_STRING)&Destination, &cbLength);
        if (ntStatus == STATUS_BUFFER_TOO_SMALL)
        {
            ntStatus = STATUS_NO_MEMORY;
            Destination.Buffer = (LPWSTR)LocalAlloc(LPTR, cbLength);
            if (Destination.Buffer)
            {
                Destination.Length = 0;
                Destination.MaximumLength = (USHORT)cbLength;

                ntStatus = RtlExpandEnvironmentStrings_U( pEnv, (PUNICODE_STRING)&Source, (PUNICODE_STRING)&Destination, NULL);
                if (NT_SUCCESS(ntStatus)) 
                {
                    *ppszDst = Destination.Buffer;
                    *pcchDst = Destination.MaximumLength / sizeof(WCHAR);
                }
                else
                {
                    LocalFree(Destination.Buffer);
                }
            }
        }
    }
    return ntStatus;
}



/***************************************************************************\
* BuildEnvironmentPath
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL BuildEnvironmentPath(void **pEnv, LPTSTR lpPathVariable, LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR szTemp[1025];
    DWORD cb;

    if (!*pEnv) {
        return(FALSE);
    }
    if (!NT_SUCCESS(RtlInitUnicodeStringEx(&Name, lpPathVariable)))
    {
        return FALSE;
    }
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(WCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(WCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        Value.Length = 0;
        *szTemp = 0;
    }
    if (Value.Length) {
        StrCpyN(szTemp, Value.Buffer, ARRAYSIZE(szTemp));
        if ( *( szTemp + lstrlen(szTemp) - 1) != TEXT(';') ) {
            StrCatBuff(szTemp, TEXT(";"), ARRAYSIZE(szTemp));
        }
        LocalFree(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(szTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) {
        StrCatBuff(szTemp, lpPathValue, ARRAYSIZE(szTemp));

        RtlInitUnicodeString(&Value, szTemp); // known to be < 1025

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}


/***************************************************************************\
* SetEnvironmentVariables
*
* Reads the user-defined environment variables from the user registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL SetEnvironmentVariables(void **pEnv, LPTSTR lpRegSubKey)
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE  lpData;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;

    if (RegOpenKeyExW(HKEY_CURRENT_USER, lpRegSubKey, 0, KEY_READ, &hkey)) {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {
                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) 
    {
        if (cbValueName) 
        {
            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) 
            {
                int cchExpandedValue;
                LPWSTR pszExpandedValue = NULL;
                ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, &pszExpandedValue, &cchExpandedValue);
                if (pszExpandedValue == NULL) 
                {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)pszExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)pszExpandedValue, TRUE);
                }

                LocalFree(pszExpandedValue);

            }

        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }



    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

/***************************************************************************\
* SetSystemEnvironmentVariables
*
* Reads the system environment variables from the LOCAL_MACHINE registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL SetSystemEnvironmentVariables(void **pEnv)
{
    WCHAR szValueName[MAX_PATH];
    LPBYTE lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE lpData;
    DWORD cchValueName = ARRAYSIZE(szValueName);
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, SYSTEM_ENV_SUBKEY, 0, KEY_READ, &hkey)) {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        KdPrint(("REGENENV: SetSystemEnvironmentVariables: Failed to allocate %d bytes\n", cbDataBuffer));
        RegCloseKey(hkey);
        return(FALSE);
    }

    //
    // First start by getting the systemroot and systemdrive values and
    // setting it in the new environment.
    //
    GetEnvironmentVariable(SYSTEMROOT_VARIABLE, (LPTSTR)lpDataBuffer, cbDataBuffer);
    SetUserEnvironmentVariable(pEnv, SYSTEMROOT_VARIABLE, (LPTSTR)lpDataBuffer, TRUE);

    GetEnvironmentVariable(SYSTEMDRIVE_VARIABLE, (LPTSTR)lpDataBuffer, cbDataBuffer);
    SetUserEnvironmentVariable(pEnv, SYSTEMDRIVE_VARIABLE, (LPTSTR)lpDataBuffer, TRUE);

    GetEnvironmentVariable(ALLUSERSPROFILE_VARIABLE, (LPTSTR)lpDataBuffer, cbDataBuffer);
    SetUserEnvironmentVariable(pEnv, ALLUSERSPROFILE_VARIABLE, (LPTSTR)lpDataBuffer, TRUE);

    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;

    //
    // To generate the environment, this requires two passes.  First pass
    // sets all the variables which do not need to be expanded.  The
    // second pass expands variables (so it can use the variables from
    // the first pass.
    //

    while (!RegEnumValue(hkey, dwIndex, szValueName, &cchValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cchValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');

            if (dwType == REG_SZ) {
                SetUserEnvironmentVariable(pEnv, szValueName, (LPTSTR)lpData, TRUE);
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cchValueName = ARRAYSIZE(szValueName);
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cchValueName = ARRAYSIZE(szValueName);


    while (!RegEnumValue(hkey, dwIndex, szValueName, &cchValueName, 0, &dwType,
                         lpData, &cbData)) 
    {
        if (cchValueName) 
        {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) 
            {
                int cchExpandedValue;
                LPWSTR pszExpandedValue = NULL;
                ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, &pszExpandedValue, &cchExpandedValue);
                if (pszExpandedValue == NULL) 
                {
                    bResult = FALSE;
                    break;
                }

                SetUserEnvironmentVariable(pEnv, szValueName, (LPTSTR)pszExpandedValue, TRUE);

                LocalFree(pszExpandedValue);

            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cchValueName = ARRAYSIZE(szValueName);
    }


    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

/***************************************************************************\
* ProcessCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessCommand(LPSTR lpStart, void **pEnv)
{
    LPTSTR lpt, lptt;
    LPTSTR lpVariable;
    LPTSTR lpValue;
    int cchExpandedValue;
    LPWSTR pszExpandedValue = NULL;
    WCHAR c;
    DWORD cch;
    LPTSTR lpu;
    
    //
    // convert to Unicode
    //
    cch = lstrlenA(lpStart) + 1;
    lpu = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
    
    if (!lpu) {
        return FALSE;
    }
    
    MultiByteToWideChar(CP_OEMCP, 0, lpStart, -1, lpu, cch);
    
    //
    // Find environment variable.
    //
    for (lpt = lpu; *lpt && *lpt == TEXT(' '); lpt++) //skip spaces
        ;
    
    if (!*lpt) {
        LocalFree (lpu);
        return(FALSE);
    }
    
    lptt = lpt;
    for (; *lpt && *lpt != TEXT(' ') && *lpt != TEXT('='); lpt++) //find end of variable name
        ;
    
    c = *lpt;
    *lpt = 0;
    lpVariable = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lptt) + 1)*sizeof(WCHAR));
    if (!lpVariable) {
        LocalFree (lpu);
        return(FALSE);
    }
    // strcpy okay, just allocated based on length
    lstrcpy(lpVariable, lptt);
    *lpt = c;
    
    //
    // Find environment variable value.
    //
    for (; *lpt && (*lpt == TEXT(' ') || *lpt == TEXT('=')); lpt++)
        ;
    
    if (!*lpt) {
        // if we have a blank path statement in the autoexec file,
        // then we don't want to pass "PATH" as the environment
        // variable because it trashes the system's PATH.  Instead
        // we want to change the variable AutoexecPath.  This would have
        // be handled below if a value had been assigned to the
        // environment variable.
        if (lstrcmpi(lpVariable, PATH_VARIABLE) == 0)
        {
            SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, TEXT(""), TRUE);
        }
        else
        {
            SetUserEnvironmentVariable(pEnv, lpVariable, TEXT(""), TRUE);
        }
        LocalFree (lpu);
        LocalFree (lpVariable);
        return(FALSE);
    }
    
    lptt = lpt;
    for (; *lpt; lpt++)  //find end of varaible value
        ;
    
    c = *lpt;
    *lpt = 0;
    lpValue = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lptt) + 1)*sizeof(WCHAR));
    if (!lpValue) {
        LocalFree (lpu);
        LocalFree(lpVariable);
        return(FALSE);
    }
    
    // strcpy okay, we just allocated it based on length
    lstrcpy(lpValue, lptt);
    *lpt = c;
    
#ifdef _X86_
    // NEC98
    //
    // If the path includes removable drive,
    //  it is assumed that the drive assignment has changed from DOS.
    //
    if (IsNEC_98 && (lstrcmpi(lpVariable, PATH_VARIABLE) == 0) && IsPathIncludeRemovable(lpValue)) {
        LocalFree(lpVariable);
        LocalFree(lpValue);
        return(FALSE);
    }
#endif

    pszExpandedValue = NULL;
    ExpandUserEnvironmentStrings(*pEnv, lpValue, &pszExpandedValue, &cchExpandedValue);
    if (!pszExpandedValue) 
    {
        pszExpandedValue = lpValue;
    }
    if (lstrcmpi(lpVariable, PATH_VARIABLE)) {
        SetUserEnvironmentVariable(pEnv, lpVariable, pszExpandedValue, FALSE);
    }
    else {
        SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, pszExpandedValue, TRUE);
        
    }
    
    if (pszExpandedValue != lpValue) {
        LocalFree(pszExpandedValue);
    }
    LocalFree(lpVariable);
    LocalFree(lpValue);
    
    return(TRUE);
}

/***************************************************************************\
* ProcessSetCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessSetCommand(LPSTR lpStart, void **pEnv)
{
    LPSTR lpt;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt != TEXT(' '); lpt++)
        ;

    if (!*lpt)
       return(FALSE);

    return (ProcessCommand(lpt, pEnv));

}

/***************************************************************************\
* ProcessAutoexec
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessAutoexec(void **pEnv, LPTSTR lpPathVariable)
{
    HANDLE fh;
    DWORD dwFileSize;
    DWORD dwBytesRead;
    CHAR *lpBuffer = NULL;
    CHAR *token;
    CHAR Seps[] = "&\n\r";   // Seperators for tokenizing autoexec.bat
    BOOL Status = FALSE;
    TCHAR szAutoExecBat [] = TEXT("c:\\autoexec.bat");
#ifdef _X86_
    TCHAR szTemp[3];
#endif
    UINT uiErrMode;
	CHAR *lpszStrTokBegin = NULL;


    // There is a case where the OS might not be booting from drive
    // C, so we can not assume that the autoexec.bat file is on c:\.
    // Set the error mode so the user doesn't see the critical error
    // popup and attempt to open the file on c:\.

    uiErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef _X86_
    if (IsNEC_98) {
        if (GetEnvironmentVariable (TEXT("SystemDrive"), szTemp, 3)) {
            szAutoExecBat[0] = szTemp[0];
        }
    }
#endif

    fh = CreateFile (szAutoExecBat, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    SetErrorMode (uiErrMode);

    if (fh ==  INVALID_HANDLE_VALUE) {
        return(FALSE);  //could not open autoexec.bat file, we're done.
    }
    dwFileSize = GetFileSize(fh, NULL);
    if (dwFileSize == -1) {
        goto Exit;      // can't read the file size
    }

    lpBuffer = (PCHAR)LocalAlloc(LPTR, dwFileSize+1);
    if (!lpBuffer) {
        goto Exit;
    }

    Status = ReadFile(fh, lpBuffer, dwFileSize, &dwBytesRead, NULL);
    if (!Status) {
        goto Exit;      // error reading file
    }

    //
    // Zero terminate the buffer so we don't walk off the end
    //

    ASSERT(dwBytesRead <= dwFileSize);
    lpBuffer[dwBytesRead] = 0;

    //
    // Search for SET and PATH commands
    //

	// save off lpBuffer 
	lpszStrTokBegin = lpBuffer;
	
    token = StrTokEx(&lpBuffer, Seps);
    while (token != NULL) {
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (*token == TEXT('@'))
            token++;
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (!_strnicmp(token, "Path", 4)) {
            ProcessCommand(token, pEnv);
        }
        if (!_strnicmp(token, "SET", 3)) {
            ProcessSetCommand(token, pEnv);
        }
        token = StrTokEx(&lpBuffer, Seps);
    }
	lpBuffer=lpszStrTokBegin;
	
Exit:
    CloseHandle(fh);
    if (lpBuffer) {
        LocalFree(lpBuffer);
    }
    return(Status);
}


/***************************************************************************\
* AppendNTPathWithAutoexecPath
*
* Gets the AutoexecPath created in ProcessAutoexec, and appends it to
* the NT path.
*
* History:
* 05-28-92  Johannec     Created.
*
\***************************************************************************/
BOOL
AppendNTPathWithAutoexecPath(
    void **pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR AutoexecPathValue[1024];
    DWORD cch;
    BOOL Success;

    if (!*pEnv) {
        return(FALSE);
    }

    if (!NT_SUCCESS(RtlInitUnicodeStringEx(&Name, lpAutoexecPath)))
    {
        return FALSE;
    }
    cch = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }

    Value.Length = 0;
    Value.MaximumLength = (USHORT)cch * sizeof(WCHAR);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        return(FALSE);
    }

    if (Value.Length) {
        lstrcpyn(AutoexecPathValue, Value.Buffer, ARRAYSIZE(AutoexecPathValue));
    }

    LocalFree(Value.Buffer);

    Success = BuildEnvironmentPath(pEnv, lpPathVariable, AutoexecPathValue);
    RtlSetEnvironmentVariable( pEnv, &Name, NULL);

    return(Success);
}

STDAPI_(BOOL) GetUserNameAndDomain(LPTSTR *ppszUserName, LPTSTR *ppszUserDomain)
{
    BOOL bRet = FALSE;
    HANDLE hToken;
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        DWORD cbTokenBuffer = 0;
        if (GetTokenInformation(hToken, TokenUser, NULL, 0, &cbTokenBuffer) ||
            GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            PTOKEN_USER pUserToken = (PTOKEN_USER)LocalAlloc(LPTR, cbTokenBuffer * sizeof(WCHAR));
            if (pUserToken) 
            {
                if (GetTokenInformation(hToken, TokenUser, pUserToken, cbTokenBuffer, &cbTokenBuffer)) 
                {
                    DWORD cbAccountName = 0, cbUserDomain = 0;
                    SID_NAME_USE SidNameUse;

                    if (LookupAccountSid(NULL, pUserToken->User.Sid, NULL, &cbAccountName, NULL, &cbUserDomain, &SidNameUse) || 
                        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        LPTSTR pszUserName   = (LPTSTR)LocalAlloc(LPTR, cbAccountName * sizeof(WCHAR));
                        LPTSTR pszUserDomain = (LPTSTR)LocalAlloc(LPTR, cbUserDomain * sizeof(WCHAR));

                        if (pszUserName && pszUserDomain &&
                            LookupAccountSid(NULL, pUserToken->User.Sid, 
                                pszUserName, &cbAccountName, 
                                pszUserDomain, &cbUserDomain, &SidNameUse))
                        {
                            if (ppszUserName)
                            {
                                *ppszUserName = pszUserName;
                                pszUserName = NULL;
                            }
                            if (ppszUserDomain)
                            {
                                *ppszUserDomain = pszUserDomain;
                                pszUserDomain = NULL;
                            }

                            bRet = TRUE;
                        }

                        if (pszUserName)
                            LocalFree(pszUserName);
                        if (pszUserDomain)
                            LocalFree(pszUserDomain);
                    }
                }
                LocalFree(pUserToken);
            }
        }
        CloseHandle(hToken);
    }
    return bRet;
}

//
// tsnotify.dll export
//
typedef BOOL (*PTERMSRVCREATETEMPDIR) (PVOID *pEnv,HANDLE UserToken,PSECURITY_DESCRIPTOR SD);
/***************************************************************************\
* SetPerSessionTempDir - adds a session number to the TMP/TEMP path if necessary.
*
*
* History:
* 10-4-2000  skuzin     Created
*
\***************************************************************************/
void
SetPerSessionTempDir(
        PVOID *ppEnvironment)
{
    HKEY   Handle;
    DWORD  fPerSessionTempDir = 0;
    DWORD  dwValueData;
    
    /*
     *  Open registry value set thru TSCC
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) == ERROR_SUCCESS )
    {
        DWORD ValueSize;
        DWORD ValueType;
        LONG   rc;

        ValueSize = sizeof(fPerSessionTempDir);

        /*
         *  Read registry value
         */
        rc = RegQueryValueExW( Handle,
                               REG_TERMSRV_PERSESSIONTEMPDIR,
                               NULL,
                               &ValueType,
                               (LPBYTE) &fPerSessionTempDir,
                               &ValueSize );

        /*
         *  Close registry and key handle
         */
        RegCloseKey( Handle );
    }

    /*
     * Check the machine wide policy set thru Group Policy
     */

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       TS_POLICY_SUB_TREE,
                       0,
                       KEY_READ,
                       &Handle ) == ERROR_SUCCESS )
    {
        DWORD ValueSize;
        DWORD ValueType;
        LONG   rc;

        ValueSize = sizeof(fPerSessionTempDir);

        /*
         *  Read registry value
         */
        rc = RegQueryValueExW( Handle,
                               REG_TERMSRV_PERSESSIONTEMPDIR,
                               NULL,
                               &ValueType,
                               (LPBYTE) &dwValueData,
                               &ValueSize );

        if (rc == ERROR_SUCCESS )
        {
            fPerSessionTempDir = dwValueData;
        }

        /*
         *  Close registry and key handle
         */
        RegCloseKey( Handle );
    }

    if (fPerSessionTempDir) 
    {
        PTERMSRVCREATETEMPDIR pfnTermsrvCreateTempDir;
        HANDLE dllHandle;

        dllHandle = LoadLibrary(TEXT("wlnotify.dll"));
        if (dllHandle) 
        {
            pfnTermsrvCreateTempDir = (PTERMSRVCREATETEMPDIR) 
                GetProcAddress(dllHandle, "TermsrvCreateTempDir");

            if (pfnTermsrvCreateTempDir)  
            {
                pfnTermsrvCreateTempDir(ppEnvironment, NULL, NULL);
            }

            FreeLibrary(dllHandle);
        }
    }
}

/***************************************************************************\
* RegenerateUserEnvironment
*
*
* History:
* 11-5-92  Johannec     Created
*
\***************************************************************************/
BOOL APIENTRY RegenerateUserEnvironment(void **pNewEnv, BOOL bSetCurrentEnv)
{
    NTSTATUS Status;
    WCHAR szValue[1025];
    TCHAR szExpValue[1025];
    void *pEnv = NULL;
    void *pPrevEnv;
    LPTSTR UserName = NULL;
    LPTSTR UserDomain = NULL;
    HKEY  hKey;
    DWORD dwDisp, dwType, dwMaxBufferSize;
    TCHAR szParseAutoexec[MAX_PARSE_AUTOEXEC_BUFFER];
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwComputerNameSize = MAX_COMPUTERNAME_LENGTH+1;

    /*
     * Create a new environment for the user.
     */
    Status = RtlCreateEnvironment((BOOLEAN)FALSE, &pEnv);
    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    SetSystemEnvironmentVariables(&pEnv);

    /*
     * Initialize user's environment.
     */
    if (GetComputerName (szComputerName, &dwComputerNameSize)) {
        SetUserEnvironmentVariable(&pEnv, COMPUTERNAME_VARIABLE, (LPTSTR) szComputerName, TRUE);
    }
    if (GetUserNameAndDomain(&UserName, &UserDomain))
    {
        SetUserEnvironmentVariable( &pEnv, USERNAME_VARIABLE, UserName, TRUE);
        SetUserEnvironmentVariable( &pEnv, USERDOMAIN_VARIABLE, UserDomain, TRUE);
        LocalFree(UserName);
        LocalFree(UserDomain);
    }

    if (GetEnvironmentVariable(USERDNSDOMAIN_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, USERDNSDOMAIN_VARIABLE, szValue, TRUE);

    //
    // Set home directory env. vars.
    //
    if (GetEnvironmentVariable(HOMEDRIVE_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, HOMEDRIVE_VARIABLE, szValue, TRUE);

    if (GetEnvironmentVariable(HOMESHARE_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, HOMESHARE_VARIABLE, szValue, TRUE);

    if (GetEnvironmentVariable(HOMEPATH_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, HOMEPATH_VARIABLE, szValue, TRUE);

    //
    // Set the user profile dir env var
    //

    if (GetEnvironmentVariable(USERPROFILE_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, USERPROFILE_VARIABLE, szValue, TRUE);


    //
    // Set the program files env var
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("ProgramFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings(szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, PROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("CommonFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings (szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, COMMONPROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

#if defined(WX86) || defined(_WIN64)
        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("ProgramFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings(szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, PROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("CommonFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings (szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, COMMONPROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

#endif

        RegCloseKey (hKey);
    }

    /*
     * Set 16-bit apps environment variables by processing autoexec.bat
     * User can turn this off and on via the registry.
     */

    //
    // Set the default case, and open the key
    //

    lstrcpyn(szParseAutoexec, PARSE_AUTOEXEC_DEFAULT, ARRAYSIZE(szParseAutoexec));

    // does reads/writes
    if (RegCreateKeyEx (HKEY_CURRENT_USER, PARSE_AUTOEXEC_KEY, 0, 0,
                    REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {


        //
        // Query the current value.  If it doesn't exist, then add
        // the entry for next time.
        //

        dwMaxBufferSize = sizeof (TCHAR) * MAX_PARSE_AUTOEXEC_BUFFER;
        if (SHQueryValueEx (hKey, PARSE_AUTOEXEC_ENTRY, NULL, &dwType,
                        (LPBYTE) szParseAutoexec, &dwMaxBufferSize)
                         != ERROR_SUCCESS) {

            //
            // Set the default value
            //

            RegSetValueEx (hKey, PARSE_AUTOEXEC_ENTRY, 0, REG_SZ,
                           (LPBYTE) szParseAutoexec,
                           sizeof (TCHAR) * lstrlen (szParseAutoexec) + 1);
        }

        //
        // Close key
        //

        RegCloseKey (hKey);
     }


    //
    // Process the autoexec if appropriate
    //

    if (szParseAutoexec[0] == TEXT('1')) {
        ProcessAutoexec(&pEnv, PATH_VARIABLE);
    }


    /*
     * Set User environment variables.
     */
    SetEnvironmentVariables( &pEnv, USER_ENV_SUBKEY);

    /*
     * Set User volatile environment variables.
     */
    SetEnvironmentVariables( &pEnv, USER_VOLATILE_ENV_SUBKEY);

    AppendNTPathWithAutoexecPath( &pEnv, PATH_VARIABLE, AUTOEXECPATH_VARIABLE);

    if (bSetCurrentEnv) 
    {
        // Currently RtlSetCurrentEnvironment always returns STATUS_SUCCESS
        // RtlDestroyEnvironment(pEnv) is not destroyed on failure (which can't happen) because
        // they always take control of the pEnv we pass in no matter what.
        Status = RtlSetCurrentEnvironment( pEnv, &pPrevEnv);
        if (!NT_SUCCESS(Status)) {
//            RtlDestroyEnvironment(pEnv);
            return(FALSE);
        }
        else {
            RtlDestroyEnvironment(pPrevEnv);
        }
    }
    
    //
    //If it's not a session 0 we might need to change value of TMP/TEMP
    //so they will be different for each session.
    //
    if(NtCurrentPeb()->SessionId)
    {
        SetPerSessionTempDir(&pEnv);
    }

    *pNewEnv = pEnv;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regsprtb.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "regsprtb.h"


BOOL CRegSupportBuf::_InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2)
{
    HRESULT hr;

    hr = StringCchCopy(_szRoot, ARRAYSIZE(_szRoot), pszSubKey1);

    if (SUCCEEDED(hr) && pszSubKey2)
    {
        hr = StringCchCat(_szRoot, ARRAYSIZE(_szRoot), TEXT("\\"));
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(_szRoot, ARRAYSIZE(_szRoot), pszSubKey2);
        }
    }

    return SUCCEEDED(hr);
}

LPCTSTR CRegSupportBuf::_GetRoot(LPTSTR pszRoot, DWORD cchRoot)
{
    return _szRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regsprtb.h ===
#ifndef __REGSPRTB_H
#define __REGSPRTB_H

#include "regsuprt.h"

class CRegSupportBuf : public CRegSupport
{
protected:
    BOOL _InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2);

    LPCTSTR _GetRoot(LPTSTR pszRoot, DWORD cchRoot);

private:
    TCHAR                   _szRoot[MAX_PATH];
};

#endif //__REGSPRTB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\reglist.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: reglist.h
//
// History:
//   5-30-94 KurtE      Created.
//
//---------------------------------------------------------------------------

// Define Callback used for different enumeration functions.
typedef BOOL (CALLBACK *PRLCALLBACK)(HDPA hdpa, HKEY hkey, LPCTSTR pszKey,
        LPCTSTR pszValueName, LPTSTR pszValue, LPCTSTR pszSrc,
        LPCTSTR pszDest);       

// Called to force rebuilding the list of paths.
BOOL WINAPI RLBuildListOfPaths(void);

// Terminate and cleanup our use of the Registry list.
void WINAPI RLTerminate(void);

// Define the main iterater function that uses the call back.
BOOL WINAPI RLEnumRegistry(HDPA hdpa, PRLCALLBACK prlcb,
        LPCTSTR pszSrc, LPCTSTR pszDest);


// RLIsPathInList: This function returns ht index of which item a string
// is in the list or -1 if not found.

int WINAPI RLIsPathInList(LPCTSTR pszPath);


// Function to call when the files really have changed...
int WINAPI RLFSChanged (LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regfldr.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "infotip.h"
#include "datautil.h"
#include <caggunk.h>
#include "pidl.h"
#include "fstreex.h"
#include "views.h"
#include "shitemid.h"
#include "ole2dup.h"
#include "deskfldr.h"
#include "prop.h"
#include "util.h"  // GetVariantFromRegistryValue
#include "defcm.h"
#include "cowsite.h"
#pragma hdrstop


//
// HACKHACK: GUIDs for _IsInNameSpace hack
//

// {D6277990-4C6A-11CF-8D87-00AA0060F5BF}
const GUID CLSID_ScheduledTasks =  { 0xD6277990, 0x4C6A, 0x11CF, { 0x8D, 0x87, 0x00, 0xAA, 0x00, 0x60, 0xF5, 0xBF } };

// {7007ACC7-3202-11D1-AAD2-00805FC1270E}
const GUID CLSID_NetworkConnections = { 0x7007ACC7, 0x3202, 0x11D1, { 0xAA, 0xD2, 0x00, 0x80, 0x5F, 0xC1, 0x27, 0x0E } };


//
// delegate regitems are a special type of IDLIST.  they share the same type as a regular REGITEM however
// they have a different IDLIST format.  we are unable to change the format of REGITEM IDLISTs so to facilitate
// delegate objects we store items using the following format:
//
//  <DELEGATEITEMID> <folder specific data> <DELEGATEITEMDATA>
//
// DELEGATEITEMID 
//      is a shell structure which contains information about the folder specific information,
//      and a regular ITEMIDLIST header.
//
// <folder specific data>
//      this is specific to the IShellFolder that is being merged into the namespace.
//
// <DELEGATEITEMDATA>
//      this contains a signature so we can determine if the IDLIST is a special delegate, 
//      and the CLSID of the IShellFolder which owns this data.
//

// all delegate regitems are allocated using the IDelegateMalloc

// {5e591a74-df96-48d3-8d67-1733bcee28ba}
const GUID CLSID_DelegateItemSig = { 0x5e591a74, 0xdf96, 0x48d3, {0x8d, 0x67, 0x17, 0x33, 0xbc, 0xee, 0x28, 0xba} };

typedef struct
{
    CLSID clsidSignature;            // == CLSID_DelegateItemSig (indicating this is a delegate object)
    CLSID clsidShellFolder;           // == CLSID of IShellFolder implementing this delegateitem
} DELEGATEITEMDATA;
typedef UNALIGNED DELEGATEITEMDATA *PDELEGATEITEMDATA;
typedef const UNALIGNED DELEGATEITEMDATA *PCDELEGATEITEMDATA;

// IDREGITEM as implemented in NT5 Beta 3, breaks the ctrlfldr IShellFolder of downlevel
// platforms.  The clsid is interpreted as the IDCONTROL's oName and oInfo and these offsets
// are way to big for the following buffer (cBuf).  On downlevel platform, when we are lucky,
// the offset is still in memory readable by our process, and we just do random stuff.  When
// unlucky we try to read memory which we do not have access to and crash.  The IDREGITEMEX
// struct solves this by putting padding between bOrder and the CLSID and filling these bytes
// with 0's.  When persisted, downlevel platform will interpret these 0's as oName, oInfo and
// as L'\0' at the beggining of cBuf.  A _bFlagsLegacy was also added to handle the NT5 Beta3
// persisted pidls. (stephstm, 7/15/99)

// Note: in the case where CRegFldr::_cbPadding == 0, IDREGITEMEX.rgbPadding[0] is at
//       same location as the IDREGITEM.clsid

#pragma pack(1)
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    BYTE    rgbPadding[16]; // at least 16 to store the clsid
} IDREGITEMEX;
typedef UNALIGNED IDREGITEMEX *LPIDREGITEMEX;
typedef const UNALIGNED IDREGITEMEX *LPCIDREGITEMEX;
#pragma pack()

STDAPI_(BOOL) IsNameListedUnderKey(LPCTSTR pszFileName, LPCTSTR pszKey);

C_ASSERT(sizeof(IDREGITEMEX) == sizeof(IDREGITEM));

EXTERN_C const IDLREGITEM c_idlNet =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_NETWORK,
    { 0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_NetworkPlaces
    0,
} ;

EXTERN_C const IDLREGITEM c_idlDrives =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    0,
} ;

EXTERN_C const IDLREGITEM c_idlInetRoot =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_INETROOT,
    { 0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CSIDL_Internet
    0,
} ;

EXTERN_C const IDREGITEM c_aidlConnections[] =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    {sizeof(IDREGITEM), SHID_COMPUTER_REGITEM, 0,
    { 0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_ControlPanel
    {sizeof(IDREGITEM), SHID_CONTROLPANEL_REGITEM, 0,
    { 0x7007ACC7, 0x3202, 0x11D1, 0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E, },}, // CLSID_NetworkConnections
    { 0 },
};

enum
{
    REGORDERTYPE_OUTERBEFORE    = -1,
    REGORDERTYPE_REQITEM        = 0,   
    REGORDERTYPE_REGITEM,
    REGORDERTYPE_DELEGATE,
    REGORDERTYPE_OUTERAFTER
};


//
// class that implements the regitems folder
//

// CLSID_RegFolder {0997898B-0713-11d2-A4AA-00C04F8EEB3E}
const GUID CLSID_RegFolder =  { 0x997898b, 0x713, 0x11d2, { 0xa4, 0xaa, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e } };

class CRegFolderEnum;     // forward

class CRegFolder : public CAggregatedUnknown,
                   public IShellFolder2,
                   public IContextMenuCB,
                   public IShellIconOverlay
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CAggregatedUnknown::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void) 
                { return CAggregatedUnknown::AddRef(); };

    //
    //  PowerDesk98 passes a CFSFolder to CRegFolder::Release(), so validate
    //  the pointer before proceeding down the path to iniquity.
    //
    STDMETHODIMP_(ULONG) Release(void) 
                { return _dwSignature == c_dwSignature ?
                            CAggregatedUnknown::Release() : 0; };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, 
                     UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IRegItemFolder 
    STDMETHODIMP Initialize(REGITEMSINFO *pri);

protected:
    CRegFolder(IUnknown *punkOuter);
    ~CRegFolder();

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid,void **ppvObj);

    HRESULT _GetOverlayInfo(LPCIDLREGITEM pidlr, int *pIndex, BOOL fIconIndex);
    
    LPCITEMIDLIST _GetFolderIDList();
    LPCIDLREGITEM _AnyRegItem(UINT cidl, LPCITEMIDLIST apidl[]);
    BOOL _AllDelegates(UINT cidl, LPCITEMIDLIST *apidl, IShellFolder **ppsf);

    int _ReqItemIndex(LPCIDLREGITEM pidlr);
    BYTE _GetOrderPure(LPCIDLREGITEM pidlr);
    BYTE _GetOrder(LPCIDLREGITEM pidlr);
    int _GetOrderType(LPCITEMIDLIST pidl);
    void _GetNameSpaceKey(LPCIDLREGITEM pidlr, LPTSTR pszKeyName, UINT cchKeyName);
    LPCIDLREGITEM _IsReg(LPCITEMIDLIST pidl);                                                               
    PDELEGATEITEMID _IsDelegate(LPCIDLREGITEM pidlr);
    HRESULT _CreateDelegateFolder(const CLSID* pclsid, REFIID riid, void **ppv);
    HRESULT _GetDelegateFolder(PDELEGATEITEMID pidld, REFIID riid, void **ppv);

    BOOL _IsInNameSpace(LPCIDLREGITEM pidlr);
    HDCA _ItemArray();
    HDCA _DelItemArray();
    HRESULT _InitFromMachine(IUnknown *punk, BOOL bEnum);
    HRESULT _CreateAndInit(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _BindToItem(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv, BOOL bOneLevel);
    HRESULT _GetInfoTip(LPCIDLREGITEM pidlr, void **ppv);
    HRESULT _GetRegItemColumnFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, LPTSTR pszColumnData, int cchColumnData);
    HRESULT _GetRegItemVariantFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, VARIANT *pv);
    void _GetClassKeys(LPCIDLREGITEM pidlr, HKEY *phkCLSID, HKEY *phkBase);
    HRESULT _GetDisplayNameFromSelf(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName);
    HRESULT _GetDisplayName(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName);
    HRESULT _DeleteRegItem(LPCIDLREGITEM pidlr);
    BOOL _GetDeleteMessage(LPCIDLREGITEM pidlr, LPTSTR pszMsg, int cchMax);

    HRESULT _ParseNextLevel(HWND hwnd, LPBC pbc, LPCIDLREGITEM pidlr,
                            LPOLESTR pwzRest, LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes);

    HRESULT _ParseGUIDName(HWND hwnd, LPBC pbc, LPOLESTR pwzDisplayName, 
                           LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes);

    HRESULT _ParseThroughItem(LPCIDLREGITEM pidlr, HWND hwnd, LPBC pbc,
                              LPOLESTR pszName, ULONG *pchEaten,
                              LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes);
    HRESULT _SetAttributes(LPCIDLREGITEM pidlr, BOOL bPerUser, DWORD dwMask, DWORD dwNewBits);
    LONG _RegOpenCLSIDUSKey(CLSID clsid, PHUSKEY phk);
    ULONG _GetPerUserAttributes(LPCIDLREGITEM pidlr);
    HRESULT _AttributesOf(LPCIDLREGITEM pidlr, DWORD dwAttributesNeeded, DWORD *pdwAttributes);
    HRESULT _CreateDefExtIconKey(HKEY hkey, UINT cidl, LPCITEMIDLIST *apidl, int iItem,
                                 REFIID riid, void** ppvOut);
    BOOL _CanDelete(LPCIDLREGITEM pidlr);
    void _Delete(HWND hwnd, UINT uFlags, IDataObject *pdtobj);
    HRESULT _AssocCreate(LPCIDLREGITEM pidl, REFIID riid, void **ppv);
    //
    // inline
    //

    // Will probably not be expanded inline as _GetOrderPure is a behemoth of a fct
    void _FillIDList(const CLSID *pclsid, IDLREGITEM *pidlr)
    {
        pidlr->idri.cb = sizeof(pidlr->idri) + (WORD)_cbPadding;
        pidlr->idri.bFlags = _bFlags;
        _SetPIDLRCLSID(pidlr, pclsid);
        pidlr->idri.bOrder = _GetOrderPure((LPCIDLREGITEM)pidlr);
    };

    BOOL _IsDesktop() { return ILIsEmpty(_GetFolderIDList()); }

    int _MapToOuterColNo(int iCol);

    // CompareIDs Helpers
    int _CompareIDsOriginal(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _CompareIDsFolderFirst(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _CompareIDsAlphabetical(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    BOOL _IsFolder(LPCITEMIDLIST pidl);
    HRESULT _CreateViewObjectFor(LPCIDLREGITEM pidlr, HWND hwnd, REFIID riid, void **ppv, BOOL bOneLevel);

private:
    inline UNALIGNED const CLSID& _GetPIDLRCLSID(LPCIDLREGITEM pidlr);
    inline void _SetPIDLRCLSID(LPIDLREGITEM pidlr, const CLSID *pclsid);
    inline IDLREGITEM* _CreateAndFillIDLREGITEM(const CLSID *pclsid);

    BOOL _GetNameFromCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName, UINT cchName);
    inline void _ClearNameFromCache();
    void _SaveNameInCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName);
    
private:
    enum { c_dwSignature = 0x38394450 }; // "PD98" - PowerDesk 98 hack
    DWORD           _dwSignature;
    LPTSTR          _pszMachine;
    LPITEMIDLIST    _pidl;

    IShellFolder2   *_psfOuter;
    IShellIconOverlay *_psioOuter;

    IPersistFreeThreadedObject *_pftoReg;   // cached pointer of last free threaded bind

    int             _iTypeOuter;            // default sort order for outer items
    LPCTSTR         _pszRegKey;
    LPCTSTR         _pszSesKey;
    REGITEMSPOLICY*  _pPolicy;
    TCHAR           _chRegItem;         // parsing prefix, must be TEXT(':')
    BYTE            _bFlags;            // flags field for PIDL construction
    DWORD           _dwDefAttributes;   // default attributes for items
    int             _nRequiredItems;    // # of required items
    DWORD           _dwSortAttrib;      // sorting attributes
    DWORD           _cbPadding;         // see comment in views.h      
    BYTE            _bFlagsLegacy;      // see comment in views.h

    CLSID           _clsidAttributesCache;
    ULONG           _dwAttributesCache;
    ULONG           _dwAttributesCacheValid;
    LONG            _lNameCacheInterlock;
    DWORD           _dwNameCacheTime;
    CLSID           _clsidNameCache;
    DWORD           _dwFlagsNameCache;
    TCHAR           _szNameCache[64];
    REQREGITEM      *_aReqItems;

    IPersistFreeThreadedObject *_pftoDelegate;

    CRITICAL_SECTION _cs;
    BOOL             _fcs;

    friend DWORD CALLBACK _RegFolderPropThreadProc(void *pv);
    friend HRESULT CRegFolder_CreateInstance(REGITEMSINFO *pri, IUnknown *punkOuter, REFIID riid, void **ppv);
    friend CRegFolderEnum;
};  

class CRegFolderEnum : public CObjectWithSite, IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; };
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum) { return E_NOTIMPL; };

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite); // we need to override this

protected:
    CRegFolderEnum(CRegFolder* prf, DWORD grfFlags, IEnumIDList* pesf, HDCA dcaItems, HDCA dcaDel, REGITEMSPOLICY* pPolicy);
    ~CRegFolderEnum();
    BOOL _IsRestricted();
    BOOL _WrongMachine();
    BOOL _TestFolderness(DWORD dwAttribItem);
    BOOL _TestHidden(LPCIDLREGITEM pidlRegItem);
    BOOL _TestHiddenInWebView(LPCLSID clsidRegItem);
    BOOL _TestHiddenInDomain(LPCLSID clsidRegItem);

private:
    LONG         _cRef;
    CRegFolder*  _prf;          // reg item folder
    IEnumIDList* _peidl;
    DWORD        _grfFlags;     // guy we are wrapping
    REGITEMSPOLICY* _pPolicy;   // controls what items are visible

    HDCA         _hdca;         // DCA of regitem objects
    INT          _iCur;

    HDCA        _hdcaDel;       // delegate shell folder;
    INT         _iCurDel;       // index into the delegate folder DCA.
    IEnumIDList *_peidlDel;     // delegate folder enumerator

    friend CRegFolder;
};

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

HRESULT ShowHideIconOnlyOnDesktop(const CLSID *pclsid, int StartIndex, int EndIndex, BOOL fHide);

//
// Construction / Destruction and aggregation
//

CRegFolder::CRegFolder(IUnknown *punkOuter) : 
    _dwSignature(c_dwSignature),
    CAggregatedUnknown(punkOuter),
    _pidl(NULL),
    _pszMachine(NULL),
    _psfOuter(NULL),
    _lNameCacheInterlock(-1)
{
    DllAddRef();
}

CRegFolder::~CRegFolder()
{
    IUnknown *punkCached = (IUnknown *)InterlockedExchangePointer((void**)&_pftoReg, NULL);
    if (punkCached)
        punkCached->Release();
        
    punkCached = (IUnknown *)InterlockedExchangePointer((void**)&_pftoDelegate, NULL);
    if (punkCached)
        punkCached->Release();

    ILFree(_pidl);
    Str_SetPtr(&_pszMachine, NULL);
    LocalFree(_aReqItems);

    SHReleaseOuterInterface(_GetOuter(), (IUnknown **)&_psfOuter);     // release _psfOuter
    SHReleaseOuterInterface(_GetOuter(), (IUnknown **)&_psioOuter);

    if (_fcs)
    {
        DeleteCriticalSection(&_cs);
    }

    DllRelease();
}

HRESULT CRegFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CRegFolder, IShellFolder, IShellFolder2), // IID_IShellFolder
        QITABENT(CRegFolder, IShellFolder2),                    // IID_IShellFolder2
        QITABENT(CRegFolder, IShellIconOverlay),                // IID_IShellIconOverlay
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && IsEqualIID(CLSID_RegFolder, riid))
    {
        *ppv = this;                // not ref counted
        hr = S_OK;
    }
    return hr;
}


//
// get the pidl used to initialize this namespace
//

LPCITEMIDLIST CRegFolder::_GetFolderIDList()
{
    if (!_pidl)
        SHGetIDListFromUnk(_psfOuter, &_pidl);

    return _pidl;
}

//
// check to see if this pidl is a regitem
//

LPCIDLREGITEM CRegFolder::_IsReg(LPCITEMIDLIST pidl)
{
    if (pidl && !ILIsEmpty(pidl))
    {
        LPCIDLREGITEM pidlr = (LPCIDLREGITEM)pidl;
        if ((pidlr->idri.bFlags == _bFlags) && 
            ((pidl->mkid.cb >= (sizeof(pidlr->idri) + (WORD)_cbPadding)) || _IsDelegate(pidlr)))
        {
            return pidlr;
        }
        else if (_cbPadding && _bFlagsLegacy && (pidlr->idri.bFlags == _bFlagsLegacy))
        {
            // We needed to add padding to the Control Panel regitems.  There was CP
            // regitems out there without the padding.  If there is padding and we fail
            // the above case then maybe we are dealing with one of these. (stephstm)
            return pidlr;
        }
    }
    return NULL;
}

PDELEGATEITEMID CRegFolder::_IsDelegate(LPCIDLREGITEM pidlr)
{
    PDELEGATEITEMID pidld = (PDELEGATEITEMID)pidlr;             // save casting below
    if ((pidld->cbSize > sizeof(*pidld)) && 
        /* note, (int) casts needed to force signed evaluation as we need the < 0 case */
        (((int)pidld->cbSize - (int)pidld->cbInner) >= (int)sizeof(DELEGATEITEMDATA)))
    {
        PDELEGATEITEMDATA pdeidl = (PDELEGATEITEMDATA)&pidld->rgb[pidld->cbInner];
        const CLSID clsid = pdeidl->clsidSignature;    // alignment
        if (IsEqualGUID(clsid, CLSID_DelegateItemSig))
        {                
            return pidld;
        }
    }
    return NULL;
}

BOOL CRegFolder::_AllDelegates(UINT cidl, LPCITEMIDLIST *apidl, IShellFolder **ppsf)
{
    *ppsf = NULL;
    PDELEGATEITEMID pidld = NULL;
    CLSID clsid, clsidFirst;
    for (UINT i = 0; i < cidl; i++)
    {
        LPCIDLREGITEM pidlr = _IsReg(apidl[i]);
        if (pidlr)
        {
            pidld = _IsDelegate(pidlr);
            if (pidld)
            {
                if (i == 0)
                {
                    // get the clsid of the first guy
                    clsidFirst = _GetPIDLRCLSID(pidlr);
                }
                else if (clsid = _GetPIDLRCLSID(pidlr), clsidFirst != clsid)
                {
                    pidld = NULL;   // not from the same delegate
                    break;
                }
            }
            else
            {
                break;
            }
        }
        else
        {
            pidld = NULL;
            break;
        }
    }

    return pidld && SUCCEEDED(_GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, ppsf)));
}

__inline IPersistFreeThreadedObject *ExchangeFTO(IPersistFreeThreadedObject **ppfto, IPersistFreeThreadedObject *pfto)
{
    return (IPersistFreeThreadedObject *)InterlockedExchangePointer((void**)ppfto, pfto);
}

HRESULT CRegFolder::_CreateDelegateFolder(const CLSID* pclsid, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    // try using the cached delegate (if it exists)
    IPersistFreeThreadedObject *pfto = ExchangeFTO(&_pftoDelegate, NULL);
    if (pfto)
    {
        CLSID clsidT;
        if (SUCCEEDED(pfto->GetClassID(&clsidT)) && IsEqualGUID(clsidT, *pclsid))
        {
            // if this fails, ppv will still be NULL
            // so we will create a new cache item...
            hr = pfto->QueryInterface(riid, ppv);
        }
    }
   
    if (NULL == *ppv)
    {
        IDelegateFolder *pdel;
        hr = SHExtCoCreateInstance(NULL, pclsid, NULL, IID_PPV_ARG(IDelegateFolder, &pdel));
        if (SUCCEEDED(hr))
        {
            DELEGATEITEMDATA delid = { 0 };
            delid.clsidSignature = CLSID_DelegateItemSig;
            delid.clsidShellFolder = *pclsid;

            IMalloc *pm;
            hr = CDelegateMalloc_Create(&delid, sizeof(delid), _bFlags, &pm);
            if (SUCCEEDED(hr))
            {
                hr = pdel->SetItemAlloc(pm);
                if (SUCCEEDED(hr))
                {
                    IPersistFolder *ppf;
                    if (SUCCEEDED(pdel->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf))))
                    {
                        hr = ppf->Initialize(_GetFolderIDList());
                        ppf->Release();
                    }

                    if (SUCCEEDED(hr))
                        hr = pdel->QueryInterface(riid, ppv);
                }
                pm->Release();
            }

            // now, we might be able to cache this guy if he is "free threaded"
            if (SUCCEEDED(hr))
            {
                if (pfto)
                {
                    pfto->Release();
                    pfto = NULL;
                }

                if (SUCCEEDED(pdel->QueryInterface(IID_PPV_ARG(IPersistFreeThreadedObject, &pfto))))
                {
                    SHPinDllOfCLSID(pclsid);
                }
            }

            pdel->Release();
        }
    }

    if (pfto)
    {
        pfto = ExchangeFTO(&_pftoDelegate, pfto);
        if (pfto)
            pfto->Release();    //  protect against race condition or re-entrancy
    }

    return hr;
}
    
HRESULT CRegFolder::_GetDelegateFolder(PDELEGATEITEMID pidld, REFIID riid, void **ppv)
{    
    PDELEGATEITEMDATA pdeidl = (PDELEGATEITEMDATA)&pidld->rgb[pidld->cbInner];
    CLSID clsid = pdeidl->clsidShellFolder; // alignment
    return _CreateDelegateFolder(&clsid, riid, ppv);
}

//
// returns a ~REFERENCE~ to the CLSID in the pidlr.  HintHint: the ref has
// the same scope as the pidlr.  This is to replace the pidlr->idri.clsid
// usage. (stephstm)
//

UNALIGNED const CLSID& CRegFolder::_GetPIDLRCLSID(LPCIDLREGITEM pidlr)
{
#ifdef DEBUG
    if (_cbPadding && (_bFlagsLegacy != pidlr->idri.bFlags))
    {
        LPIDREGITEMEX pidriex = (LPIDREGITEMEX)&(pidlr->idri);

        for (DWORD i = 0; i < _cbPadding; ++i)
        {
            ASSERT(0 == pidriex->rgbPadding[i]);
        }
    }
#endif

    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        PDELEGATEITEMDATA pdeidl = (PDELEGATEITEMDATA)&pidld->rgb[pidld->cbInner];
        return pdeidl->clsidShellFolder;
    }

    return (pidlr->idri.bFlags != _bFlagsLegacy) ?
        // return the new padded clsid
        ((UNALIGNED CLSID&)((LPIDREGITEMEX)&(pidlr->idri))->rgbPadding[_cbPadding]) :
        // return the old non-padded clsid
        (pidlr->idri.clsid);
}

// This fct is called only for IDREGITEMs created within this file.  It is not
// called for existing PIDL, so we do not need to check if it is a legacy pidl.
void CRegFolder::_SetPIDLRCLSID(LPIDLREGITEM pidlr, const CLSID *pclsid)
{
    LPIDREGITEMEX pidriex = (LPIDREGITEMEX)&(pidlr->idri);

    ((UNALIGNED CLSID&)pidriex->rgbPadding[_cbPadding]) = *pclsid;

    ZeroMemory(pidriex->rgbPadding, _cbPadding);
}

IDLREGITEM* CRegFolder::_CreateAndFillIDLREGITEM(const CLSID *pclsid)
{
    IDLREGITEM* pidlRegItem = (IDLREGITEM*)_ILCreate(sizeof(IDLREGITEM) + _cbPadding);

    if (pidlRegItem)
    {
        _FillIDList(pclsid, pidlRegItem);
    }

    return pidlRegItem;
}

//
// Returns: ptr to the first reg item if there are any
//

LPCIDLREGITEM CRegFolder::_AnyRegItem(UINT cidl, LPCITEMIDLIST apidl[])
{
    for (UINT i = 0; i < cidl; i++) 
    {
        LPCIDLREGITEM pidlr = _IsReg(apidl[i]);
        if (pidlr)
            return pidlr;
    }
    return NULL;
}


int CRegFolder::_ReqItemIndex(LPCIDLREGITEM pidlr)
{
    const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment

    for (int i = _nRequiredItems - 1; i >= 0; i--)
    {
        if (IsEqualGUID(clsid, *_aReqItems[i].pclsid))
        {
            break;
        }
    }
    return i;
}


//
// a sort order of 0 means there is not specified sort order for this item
//

BYTE CRegFolder::_GetOrderPure(LPCIDLREGITEM pidlr)
{
    BYTE bRet;
    int i = _ReqItemIndex(pidlr);
    if (i != -1)
    {
        bRet = _aReqItems[i].bOrder;
    }
    else
    {
        HKEY hkey;
        TCHAR szKey[MAX_PATH], szCLSID[GUIDSTR_MAX];
        HRESULT hr;

        SHStringFromGUID(_GetPIDLRCLSID(pidlr), szCLSID, ARRAYSIZE(szCLSID));

        bRet = 128;     // default for items that do not register a SortOrderIndex

        hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s"), szCLSID);
        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, NULL, KEY_QUERY_VALUE, &hkey))
            {
                DWORD dwOrder, cbSize = sizeof(dwOrder);
                if (SHQueryValueEx(hkey, TEXT("SortOrderIndex"), NULL, NULL, (BYTE *)&dwOrder, &cbSize) == ERROR_SUCCESS)
                {

                    // B#221890 - PowerDesk assumes that it can do this:
                    //      Desktop -> First child -> Third child
                    // and it will get the C: drive.  This means that
                    // My Computer must be the first regitem.  So any items
                    // in front of My Computer are put immediately behind.
                    if ((SHGetAppCompatFlags(ACF_MYCOMPUTERFIRST) & ACF_MYCOMPUTERFIRST) &&
                        dwOrder <= SORT_ORDER_DRIVES)
                        dwOrder = SORT_ORDER_DRIVES + 1;

                    bRet = (BYTE)dwOrder;
                }
                RegCloseKey(hkey);
            }
        }
    }
    return bRet;
}

BYTE CRegFolder::_GetOrder(LPCIDLREGITEM pidlr)
{
    if (!_IsDelegate(pidlr))
    {
        // If the bOrder values are less than 0x40, then they are the old values
        // Therefore compute the new bOrder values for these cases.
        if (pidlr->idri.bOrder <= 0x40) 
            return _GetOrderPure(pidlr);
        else 
            return pidlr->idri.bOrder;
    }
    else
        return 128;
}

//
// validate that this item exists in this name space (look in the registry)
//

BOOL CRegFolder::_IsInNameSpace(LPCIDLREGITEM pidlr)
{
    TCHAR szKeyName[MAX_PATH];

    if (_IsDelegate(pidlr))
        return FALSE;                    // its a delegate, therefore by default its transient

    if (_ReqItemIndex(pidlr) >= 0)
        return TRUE;

    // HACKHACK: we will return TRUE for Printers, N/W connections and Scheduled tasks
    //           since they've been moved from My Computer to Control Panel and they
    //           don't really care where they live

    const CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment

    if (IsEqualGUID(CLSID_Printers, clsid) ||
        IsEqualGUID(CLSID_NetworkConnections, clsid) ||
        IsEqualGUID(CLSID_ScheduledTasks, clsid))
    {
        return TRUE;
    }

    _GetNameSpaceKey(pidlr, szKeyName, ARRAYSIZE(szKeyName));

   // Note that we do not look in the session key,
   // since it by definition is transient

    return SHRegSubKeyExists(HKEY_LOCAL_MACHINE, szKeyName) ||
           SHRegSubKeyExists(HKEY_CURRENT_USER,  szKeyName);
}

//
//  The "Session key" is a volatile registry key unique to this session.
//  A session is a single continuous logon.  If Explorer crashes and is
//  auto-restarted, the two Explorers share the same session.  But if you
//  log off and back on, that new Explorer is a new session.
//

//
//  The s_SessionKeyName is the name of the session key relative to
//  REGSTR_PATH_EXPLORER\SessionInfo.  On NT, this is normally the
//  Authentication ID, but we pre-initialize it to something safe so
//  we don't fault if for some reason we can't get to it.  Since
//  Win95 supports only one session at a time, it just stays at the
//  default value.
//
//  Sometimes we want to talk about the full path (SessionInfo\BlahBlah)
//  and sometimes just the partial path (BlahBlah) so we wrap it inside
//  this goofy structure.
//

union SESSIONKEYNAME {
    TCHAR szPath[12+16+1];
    struct {
        TCHAR szSessionInfo[12];    // strlen("SessionInfo\\")
        TCHAR szName[16+1];         // 16 = two DWORDs converted to hex
    };
} s_SessionKeyName = {
    { TEXT("SessionInfo\\.Default") }
};

BOOL g_fHaveSessionKeyName = FALSE;

//
//  samDesired = a registry security access mask, or the special value
//               0xFFFFFFFF to delete the session key.
//  phk        = receives the session key on success
//
//  NOTE!  Only Explorer should delete the session key (when the user
//         logs off).
//
STDAPI SHCreateSessionKey(REGSAM samDesired, HKEY *phk)
{
    LONG lRes;

    *phk = NULL;

    if (!g_fHaveSessionKeyName)
    {
        ENTERCRITICAL;

        //
        //  Build the name of the session key.  We use the authentication ID
        //  which is guaranteed to be unique forever.  We can't use the
        //  Hydra session ID since that can be recycled.
        //
        //  Note: Do not use OpenThreadToken since it will fail if the
        //  thread is not impersonating.  People who do impersonation
        //  cannot use SHCreateSessionKey anyway since we cache the
        //  session key on the assumption that there is no impersonation
        //  going on.  (And besides, HKCU is wrong when impersonating.)
        //
        HANDLE hToken;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            TOKEN_STATISTICS stats;
            DWORD cbOut;

            if (GetTokenInformation(hToken, TokenStatistics, &stats, sizeof(stats), &cbOut))
            {
                StringCchPrintf(s_SessionKeyName.szName, ARRAYSIZE(s_SessionKeyName.szName),   // ok to truncate
                         TEXT("%08x%08x"),
                         stats.AuthenticationId.HighPart,
                         stats.AuthenticationId.LowPart);       // should never truncate
                g_fHaveSessionKeyName = TRUE;
            }
            CloseHandle(hToken);
        }

        LEAVECRITICAL;
    }

    HKEY hkExplorer = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, TRUE);
    if (hkExplorer)
    {
        if (samDesired != 0xFFFFFFFF)
        {
            DWORD dwDisposition;
            lRes = RegCreateKeyEx(hkExplorer, s_SessionKeyName.szPath, 0,
                           NULL,
                           REG_OPTION_VOLATILE,
                           samDesired,
                           NULL,
                           phk,
                           &dwDisposition);
        }
        else
        {
            lRes = SHDeleteKey(hkExplorer, s_SessionKeyName.szPath);
        }

        RegCloseKey(hkExplorer);
    }
    else
    {
        lRes = ERROR_ACCESS_DENIED;
    }
    return HRESULT_FROM_WIN32(lRes);
}

//
// We use a HDCA to store the CLSIDs for the regitems in this folder, this call returns
// that HDCA>
//

HDCA CRegFolder::_ItemArray()
{
    HDCA hdca = DCA_Create();
    if (hdca)
    {
        for (int i = 0; i < _nRequiredItems; i++)
        {
            DCA_AddItem(hdca, *_aReqItems[i].pclsid);
        }

        DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, _pszRegKey);
        DCA_AddItemsFromKey(hdca, HKEY_CURRENT_USER,  _pszRegKey);

        if (_pszSesKey)
        {
            HKEY hkSession;
            if (SUCCEEDED(SHCreateSessionKey(KEY_QUERY_VALUE, &hkSession)))
            {
                DCA_AddItemsFromKey(hdca, hkSession, _pszSesKey);
                RegCloseKey(hkSession);
            }
        }

    }
    return hdca;
}


HDCA CRegFolder::_DelItemArray()
{
    HDCA hdca = DCA_Create();
    if (hdca)
    {
        TCHAR szKey[MAX_PATH*2];
        HRESULT hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\DelegateFolders"), _pszRegKey);
        if (SUCCEEDED(hr))
        {
            DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, szKey);
            DCA_AddItemsFromKey(hdca, HKEY_CURRENT_USER, szKey);
        }

        if (_pszSesKey)
        {
            HKEY hkSession;
            if (SUCCEEDED(SHCreateSessionKey(KEY_QUERY_VALUE, &hkSession)))
            {
                hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\DelegateFolders"), _pszSesKey);
                if (SUCCEEDED(hr))
                {
                    DCA_AddItemsFromKey(hdca, hkSession, szKey);
                }
                RegCloseKey(hkSession);
            }
        }
    }
    return hdca;
}


//
// Given our cached machine name, attempt get the object on that machine.
//

HRESULT CRegFolder::_InitFromMachine(IUnknown *punk, BOOL bEnum)
{
    HRESULT hr = S_OK;
    if (_pszMachine)
    {
        // prior to Win2K there was IRemoteComputerA/W, we removed IRemoteComputerA and
        // made IRemoteComputer map to the W version of the API, therefore we 
        // thunk the string to its wide version before calling the Initialize method. (daviddv 102099)

        IRemoteComputer * premc;
        hr = punk->QueryInterface(IID_PPV_ARG(IRemoteComputer, &premc));
        if (SUCCEEDED(hr))
        {
            WCHAR wszName[MAX_PATH];
            SHTCharToUnicode(_pszMachine, wszName, ARRAYSIZE(wszName));
            hr = premc->Initialize(wszName, bEnum);
            premc->Release();
        }
    }
    return hr;
}

//
// Given a pidl, lets get an instance of the namespace that provides it.
//  - handles caching accordingly
//

HRESULT CRegFolder::_CreateAndInit(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_FAIL;
    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        IShellFolder *psf;
        hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->BindToObject((LPCITEMIDLIST)pidlr, pbc, riid, ppv);
            psf->Release();
        }
    }
    else
    {
        CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment

        //  try using the cached pointer
        IPersistFreeThreadedObject *pfto = ExchangeFTO(&_pftoReg, NULL);
        if (pfto)
        {
            CLSID clsidT;
            if (SUCCEEDED(pfto->GetClassID(&clsidT)) && IsEqualGUID(clsidT, clsid))
            {
                // if this fails, ppv will still be NULL
                // so we will create a new cache item...
                hr = pfto->QueryInterface(riid, ppv);
            }
        }

        // cache failed, cocreate it ourself
        if (NULL == *ppv)
        {
            OBJCOMPATFLAGS ocf = SHGetObjectCompatFlags(NULL, &clsid);

            if (!(OBJCOMPATF_UNBINDABLE & ocf))
            {
                //
                //  HACKHACK - some regitems can only be CoCreated with IID_IShellFolder
                //  specifically the hummingbird shellext will DebugBreak() bringing
                //  down the shell...  but we can CoCreate() and then QI after...
                //
            
                hr = SHExtCoCreateInstance(NULL, &clsid, NULL, 
                    (OBJCOMPATF_COCREATESHELLFOLDERONLY & ocf) ? IID_IShellFolder : riid , ppv);

                if (SUCCEEDED(hr))
                {
                    IUnknown *punk = (IUnknown *)*ppv;  // avoid casts below

                    if ((OBJCOMPATF_COCREATESHELLFOLDERONLY & ocf))
                    {
                        hr = punk->QueryInterface(riid, ppv);
                        punk->Release();
                        punk = (IUnknown *)*ppv;  // avoid casts below
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = _InitFromMachine(punk, FALSE);
                        if (SUCCEEDED(hr))
                        {
                            IPersistFolder *ppf;
                            if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf))))
                            {
                                LPITEMIDLIST pidlAbs = ILCombine(_GetFolderIDList(), (LPCITEMIDLIST)pidlr);
                                if (pidlAbs)
                                {
                                    hr = ppf->Initialize(pidlAbs);
                                    ILFree(pidlAbs);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                                ppf->Release();
                            }

                            if (SUCCEEDED(hr))
                            {
                                if (pfto)
                                {
                                    pfto->Release();    //  we are going to replace the cache
                                    pfto = NULL;
                                }
                                if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFreeThreadedObject, &pfto))))
                                {
                                    SHPinDllOfCLSID(&clsid);
                                }
                            }
                        }

                        if (FAILED(hr))
                        {
                            // we're going to return failure -- don't leak the object we created
                            punk->Release();
                            *ppv = NULL;
                        }
                    }
                }
            }
        }

        // recache the pfto
        if (pfto)
        {
            pfto = ExchangeFTO(&_pftoReg, pfto);
            if (pfto)
                pfto->Release();    //  protect against race condition or re-entrancy
        }
    }
    return hr;
}


//
// lets the reg item itself pick off the GetDisplayNameOf() impl for itself. this lets
// MyDocs on the desktop return c:\win\profile\name\My Documents as it's parsing name
//
// returns:
//      S_FALSE     do normal parsing, reg item did not handel
//
//

HRESULT CRegFolder::_GetDisplayNameFromSelf(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    HRESULT hr        = S_FALSE;     // normal case
    const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment
    BOOL bGetFromSelf = FALSE;
    const BOOL bForParsingOnly = ((dwFlags & (SHGDN_FORADDRESSBAR | SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING);

    if (bForParsingOnly)
    {
        if (SHQueryShellFolderValue(&clsid, TEXT("WantsFORPARSING")))
        {
            bGetFromSelf = TRUE;
        }
    }
    else
    {
        const BOOL bForParsing    = (0 != (dwFlags & SHGDN_FORPARSING));
        const BOOL bForAddressBar = (0 != (dwFlags & SHGDN_FORADDRESSBAR));
        if (!bForParsing || bForAddressBar)
        {
            if (SHQueryShellFolderValue(&clsid, TEXT("WantsFORDISPLAY")))
            {
                bGetFromSelf = TRUE;
            }
        }
    }
    if (bGetFromSelf)
    {
        IShellFolder *psf;
        if (SUCCEEDED(_BindToItem(pidlr, NULL, IID_PPV_ARG(IShellFolder, &psf), TRUE)))
        {
            //
            // Pass NULL pidl (c_idlDesktop) to get display name of the folder itself.
            // Note that we can't use DisplayNameOf() because that function 
            // eats the S_FALSE that can be returned from the
            // IShellFolder::GetDisplayNameOf implementation to indicate
            // "do the default thing".
            //
            STRRET sr;
            hr = psf->GetDisplayNameOf(&c_idlDesktop, dwFlags, &sr);
            if (S_OK == hr)
            {
                hr = StrRetToBuf(&sr, &c_idlDesktop, pszName, cchName);
            }
            psf->Release();
        }
    }
    return hr;
}


//
//  Managing the name cache is tricky because it is hit frequently on
//  multiple threads, and collisions are frequent.  E.g., one thread
//  does a SetNameOf+SHChangeNotify, and multiple other threads try
//  to pull the name out simultaneously.  If you're not careful, these
//  threads step on each other and some poor schmuck gets invalid data.
//
//  _lNameCacheInterlock = -1 if nobody is using the name cache, else >= 0
//
//  Therefore, if InterlockedIncrement(&_lNameCacheInterlock) == 0, then
//  you are the sole owner of the cache.  Otherwise, the cache is busy
//  and you should get out.
//
//  Furthermore, we don't use the name cache if it is more than 500ms stale.
//
BOOL CRegFolder::_GetNameFromCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    BOOL fSuccess = FALSE;

    // Quick check to avoid entering the interlock unnecessarily
    if (rclsid.Data1 == _clsidNameCache.Data1 &&
        GetTickCount() - _dwNameCacheTime < 500)
    {
        if (InterlockedIncrement(&_lNameCacheInterlock) == 0)
        {
            if (IsEqualGUID(rclsid, _clsidNameCache) &&
                (_dwFlagsNameCache == dwFlags))
            {
                StringCchCopy(pszName, cchName, _szNameCache); // ok to truncate
                fSuccess = TRUE;
            }
        }
        InterlockedDecrement(&_lNameCacheInterlock);
    }
    return fSuccess;
}

void CRegFolder::_ClearNameFromCache()
{
    _clsidNameCache = CLSID_NULL;
}

void CRegFolder::_SaveNameInCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName)
{
    if (lstrlen(pszName) < ARRAYSIZE(_szNameCache))
    {
        if (InterlockedIncrement(&_lNameCacheInterlock) == 0)
        {
            StringCchCopy(_szNameCache, ARRAYSIZE(_szNameCache), pszName); // ok to truncate
            _dwFlagsNameCache = dwFlags;
            _clsidNameCache = rclsid;
            _dwNameCacheTime = GetTickCount();
        }
        InterlockedDecrement(&_lNameCacheInterlock);
    }
}


//
// Given a pidl in the regitms folder, get the friendly name for this (trying the user
// store ones, then the global one).
//

#define GUIDSIZE    50

HRESULT CRegFolder::_GetDisplayName(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    *pszName = 0;

    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        IShellFolder *psf;
        HRESULT hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = DisplayNameOf(psf, (LPCITEMIDLIST)pidlr, dwFlags, pszName, cchName);
            psf->Release();                
        }
        return hr;
    }
    else
    {
        HKEY hkCLSID;
        CLSID clsid = _GetPIDLRCLSID(pidlr);

        if (_GetNameFromCache(clsid, dwFlags, pszName, cchName))
        {
            // Satisfied from cache; all done!
        }
        else
        {
            HRESULT hr = _GetDisplayNameFromSelf(pidlr, dwFlags, pszName, cchName);
            if (hr != S_FALSE)
                return hr;

            if (dwFlags & SHGDN_FORPARSING)
            {
                if (!(dwFlags & SHGDN_FORADDRESSBAR))
                {
                    // Get the parent folder name
                    TCHAR szParentName[MAX_PATH];
                    szParentName[0] = 0;
                    if (!(dwFlags & SHGDN_INFOLDER) && !ILIsEmpty(_GetFolderIDList()))
                    {
                        SHGetNameAndFlags(_GetFolderIDList(), SHGDN_FORPARSING, szParentName, SIZECHARS(szParentName), NULL);
                        hr = StringCchCat(szParentName, ARRAYSIZE(szParentName), TEXT("\\"));
                        if (FAILED(hr))
                        {
                            return hr;
                        }
                    }

                    // Win95 didn't support SHGDN_FORPARSING on regitems; it always
                    // returned the display name.  Norton Unerase relies on this,
                    // because it assumes that if the second character of the FORPARSING
                    // name is a colon, then it's a drive.  Therefore, we can't return
                    // ::{guid} or Norton will fault.  (I guess they didn't believe in
                    // SFGAO_FILESYSTEM.)  So if we are Norton Unerase, then ignore
                    // the FORPARSING flag; always get the name for display.
                    // And good luck to any user who sets his computer name to something
                    // with a colon as the second character...

                    if (SHGetAppCompatFlags(ACF_OLDREGITEMGDN) & ACF_OLDREGITEMGDN)
                    {

                        // In Application compatibility mode turn SHGDN_FORPARSING
                        // off and fall thru to the remainder of the function which
                        // avoids the ::{GUID} when required.
                    
                        dwFlags &= ~SHGDN_FORPARSING;
                    }
                    else
                    {
                        // Get this reg folder name
                        TCHAR szFolderName[GUIDSIZE + 2];
                        szFolderName[0] = szFolderName[1] = _chRegItem;
                        SHStringFromGUID(clsid, szFolderName + 2, cchName - 2);

                        // Copy the full path into szParentName.
                        hr = StringCchCat(szParentName, ARRAYSIZE(szParentName), szFolderName);
                        if (FAILED(hr))
                        {
                            return hr;
                        }

                        // Copy the full path into the output buffer.
                        return StringCchCopy(pszName, cchName, szParentName);
                    }
                }
            }

            // Check per-user settings first...
            if ((*pszName == 0) && SUCCEEDED(SHRegGetCLSIDKey(clsid, NULL, TRUE, FALSE, &hkCLSID)))
            {
                DWORD cbName = cchName * sizeof(TCHAR);
                if (ERROR_SUCCESS != SHRegGetValue(hkCLSID, NULL, NULL, SRRF_RT_REG_SZ, NULL, pszName, &cbName))
                    *pszName = 0;
                RegCloseKey(hkCLSID);
            }

            // If we have to, use per-machine settings...
            if (*pszName == 0)
            {
                _GetClassKeys(pidlr, &hkCLSID, NULL);

                if (hkCLSID)
                {
                    SHLoadLegacyRegUIString(hkCLSID, NULL, pszName, cchName);
                    RegCloseKey(hkCLSID);
                }
            }

            // try the required item names, they might not be in the registry
            if (*pszName == 0)
            {
                int iItem = _ReqItemIndex(pidlr);
                if (iItem >= 0)
                    LoadString(HINST_THISDLL, _aReqItems[iItem].uNameID, pszName, cchName);
            }

            if (*pszName)
            {
                if (_pszMachine && !(dwFlags & SHGDN_INFOLDER))
                {
                    // szName now holds the item name, and _pszMachine holds the machine.
                    LPTSTR pszRet = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON), 
                                                                    SkipServerSlashes(_pszMachine), pszName);
                    if (pszRet)
                    {
                        StringCchCopy(pszName, cchName, pszRet);    // ok to truncate
                        LocalFree(pszRet);
                    }
                }

                _SaveNameInCache(clsid, dwFlags, pszName);
            }
        }
    }
    return *pszName ? S_OK : E_FAIL;
}


//
// get the HKEYs that map to the regitm.
//
// NOTE: this function returns a void so that the caller explicitly must check the keys
//       to see if they are non-null before using them.
//
void CRegFolder::_GetClassKeys(LPCIDLREGITEM pidlr, HKEY* phkCLSID, HKEY* phkBase)
{
    HRESULT hr;
    IQueryAssociations *pqa;
    
    if (phkCLSID)
        *phkCLSID = NULL;
    
    if (phkBase)
        *phkBase = NULL;

    hr = _AssocCreate(pidlr, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        if (phkCLSID)
        {
            hr = pqa->GetKey(0, ASSOCKEY_CLASS, NULL, phkCLSID);

            ASSERT((SUCCEEDED(hr) && *phkCLSID) || (FAILED(hr) && (*phkCLSID == NULL)));
        }

        if (phkBase)
        {
            hr = pqa->GetKey(0, ASSOCKEY_BASECLASS, NULL, phkBase);

            ASSERT((SUCCEEDED(hr) && *phkBase) || (FAILED(hr) && (*phkBase == NULL)));
        }

        pqa->Release();
    }
}

// {9EAC43C0-53EC-11CE-8230-CA8A32CF5494}
static const GUID GUID_WINAMP = { 0x9eac43c0, 0x53ec, 0x11ce, { 0x82, 0x30, 0xca, 0x8a, 0x32, 0xcf, 0x54, 0x94 } };

#define SZ_BROKEN_WINAMP_VERB   TEXT("OpenFileOrPlayList")


// IQA - Move this to Legacy Mapper.
void _MaybeDoWinAmpHack(UNALIGNED REFGUID rguid)
{
    if (IsEqualGUID(rguid, GUID_WINAMP))
    {
        // WinAmp writes in "OpenFileOrPlayList" as default value under shell, but they
        // don't write a corresponding "OpenFileorPlayList" verb key.  So we need to whack
        // the registry into shape for them.  Otherwise, they won't get the default verb
        // they want (due to an NT5 change in CDefExt_QueryContextMenu's behavior).

        TCHAR szCLSID[GUIDSTR_MAX];
        SHStringFromGUID(rguid, szCLSID, ARRAYSIZE(szCLSID));

        TCHAR szRegKey[GUIDSTR_MAX + 40];
        HRESULT hr;

        hr = StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("CLSID\\%s\\shell"), szCLSID);
        if (SUCCEEDED(hr))
        {
            TCHAR szValue[ARRAYSIZE(SZ_BROKEN_WINAMP_VERB)+2];
            DWORD dwType;
            DWORD dwSize = sizeof(szValue);
            if (SHGetValue(HKEY_CLASSES_ROOT, szRegKey, NULL, &dwType, szValue, &dwSize) == 0)
            {
                if (dwType == REG_SZ && lstrcmp(szValue, SZ_BROKEN_WINAMP_VERB) == 0)
                {
                    // Make "open" the default verb
                    SHSetValue(HKEY_CLASSES_ROOT, szRegKey, NULL, REG_SZ, TEXT("open"), sizeof(TEXT("open")));
                }
            }
        }
    }
}

HRESULT CRegFolder::_AssocCreate(LPCIDLREGITEM pidlr, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        WCHAR szCLSID[GUIDSTR_MAX];
        const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment
        ASSOCF flags = ASSOCF_INIT_NOREMAPCLSID;
        DWORD dwAttributes;

        if ((SUCCEEDED(_AttributesOf(pidlr, SFGAO_FOLDER, &dwAttributes)) && 
            (dwAttributes & SFGAO_FOLDER)) && 
            !SHQueryShellFolderValue(&clsid, TEXT("HideFolderVerbs")))
            flags |= ASSOCF_INIT_DEFAULTTOFOLDER;

        SHStringFromGUIDW(clsid, szCLSID, ARRAYSIZE(szCLSID));

        _MaybeDoWinAmpHack(clsid);

        hr = pqa->Init(flags, szCLSID, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pqa->QueryInterface(riid, ppv);

        pqa->Release();
    }

    return hr;
}

//
// get the namespace key for this objec.
//

void CRegFolder::_GetNameSpaceKey(LPCIDLREGITEM pidlr, LPTSTR pszKeyName, UINT cchKeyName)
{
    TCHAR szClass[GUIDSTR_MAX];
    SHStringFromGUID(_GetPIDLRCLSID(pidlr), szClass, ARRAYSIZE(szClass));
    StringCchPrintf(pszKeyName, cchKeyName, TEXT("%s\\%s"), _pszRegKey, szClass);  // ok to truncate
}


BOOL CRegFolder::_CanDelete(LPCIDLREGITEM pidlr)
{
    DWORD dwAttributes;
    return pidlr && 
           SUCCEEDED(_AttributesOf(pidlr, SFGAO_CANDELETE, &dwAttributes)) &&
           (dwAttributes & SFGAO_CANDELETE);
}
//
// the user is trying to delete an object from a regitem folder, therefore
// lets look in the IDataObject to see if that includes any regitems, if
// so then handle their deletion, before passing to the outer guy to 
// handle the other objects.
//

#define MAX_REGITEM_WARNTEXT 1024

void CRegFolder::_Delete(HWND hwnd, UINT uFlags, IDataObject *pdtobj)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        TCHAR szItemWarning[MAX_REGITEM_WARNTEXT];
        UINT nregfirst = (UINT)-1;
        UINT creg = 0;
        UINT cwarn = 0;
        UINT countfs = 0;
        LPCITEMIDLIST *ppidlFS = NULL;

        // calc number of regitems and index of first
        for (UINT i = 0; i < pida->cidl; i++)
        {
            LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, i);
            LPCIDLREGITEM pidlr = _IsReg(pidl);
            if (_CanDelete(pidlr))
            {
                TCHAR szTemp[MAX_REGITEM_WARNTEXT];
                creg++;
                if (nregfirst == (UINT)-1)
                    nregfirst = i;

                // use a temporary here because _GetDeleteMessage clobbers the buffer
                // when it doesn't get a delete message --ccooney
                if ((cwarn < 2) && _GetDeleteMessage(pidlr, szTemp, ARRAYSIZE(szTemp)))
                {
                    StringCchCopy(szItemWarning, ARRAYSIZE(szItemWarning), szTemp);    // ok to truncate
                    cwarn++;
                }
            }
            else if (!pidlr) //only do this for non reg items
            {
                // alloc an alternate array for FS pidls 
                // for simplicitu over alloc in the case where there are reg items
                if (ppidlFS == NULL)
                    ppidlFS = (LPCITEMIDLIST *)LocalAlloc(LPTR, pida->cidl * sizeof(LPCITEMIDLIST));
                if (ppidlFS)
                {
                    ppidlFS[countfs++] = pidl;
                }
            }
        }

        //
        // compose the confirmation message / ask the user / fry the items...
        //
        if (creg)
        {
            SHELLSTATE ss = {0};

            SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, FALSE);

            if ((uFlags & CMIC_MASK_FLAG_NO_UI) || ss.fNoConfirmRecycle)
            {
                for (i = 0; i < pida->cidl; i++)
                {
                    LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, i));
                    if (_CanDelete(pidlr))
                        _DeleteRegItem(pidlr);
                }
            }
            else
            {
                TCHAR szItemName[MAX_PATH];
                TCHAR szWarnText[1024 + MAX_REGITEM_WARNTEXT];
                TCHAR szWarnCaption[128];
                TCHAR szTemp[256];
                MSGBOXPARAMS mbp = {sizeof(mbp), hwnd,
                    HINST_THISDLL, szWarnText, szWarnCaption,
                    MB_YESNO | MB_USERICON, MAKEINTRESOURCE(IDI_NUKEFILE),
                    0, NULL, 0};

                //
                // so we can tell if we got these later
                //
                *szItemName = 0;
                *szWarnText = 0;

                //
                // if there is only one, retrieve its name
                //
                if (creg == 1)
                {
                    LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, nregfirst));

                    _GetDisplayName(pidlr, SHGDN_NORMAL, szItemName, ARRAYSIZE(szItemName));
                }
                //
                // ask the question "are you sure..."
                //
                if ((pida->cidl == 1) && *szItemName)
                {
                    TCHAR szTemp2[256];
                    LoadString(HINST_THISDLL, _IsDesktop() ? IDS_CONFIRMDELETEDESKTOPREGITEM : IDS_CONFIRMDELETEREGITEM, szTemp2, ARRAYSIZE(szTemp2));
                    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szTemp2, szItemName);    // ok to truncate
                }
                else
                {
                    LoadString(HINST_THISDLL, _IsDesktop() ? IDS_CONFIRMDELETEDESKTOPREGITEMS : IDS_CONFIRMDELETEREGITEMS, szTemp, ARRAYSIZE(szTemp));
                }
                StringCchCat(szWarnText, ARRAYSIZE(szWarnText), szTemp);    // ok to truncate


                //
                // if there is exactly one special warning message and one item total, add it in
                //
                if (creg == 1 && cwarn == 1 && *szItemWarning)
                {
                    StringCchCat(szWarnText, ARRAYSIZE(szWarnText), TEXT("\r\n\n"));    // ok to truncate
                    StringCchCat(szWarnText, ARRAYSIZE(szWarnText), szItemWarning); // ok to truncate
                }
                else
                {
                    if (creg == 1)
                    {
                        TCHAR szTemp2[256];
                        TCHAR szControlPanel[256];
                        LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, nregfirst));
                        CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment

                        int idString = (1 == pida->cidl) ?
                            IDS_CANTRECYCLEREGITEMS_NAME :
                            IDS_CANTRECYCLEREGITEMS_INCL_NAME;

                        LoadString(HINST_THISDLL, idString, szTemp, ARRAYSIZE(szTemp));
                        if ((IsEqualCLSID(CLSID_NetworkPlaces, clsid)) ||
                                 (IsEqualCLSID(CLSID_Internet, clsid)) ||
                                 (IsEqualCLSID(CLSID_MyComputer, clsid)) ||
                                 (IsEqualCLSID(CLSID_MyDocuments, clsid)))
                        {
                            LoadString(HINST_THISDLL, IDS_CANTRECYLE_FOLDER, szControlPanel, ARRAYSIZE(szControlPanel));
                        }
                        else
                        {
                            LoadString(HINST_THISDLL, IDS_CANTRECYLE_GENERAL, szControlPanel, ARRAYSIZE(szControlPanel));
                        }
                        StringCchCat(szWarnText, ARRAYSIZE(szWarnText), TEXT("\r\n\n"));    // ok to truncate
                        StringCchPrintf(szTemp2, ARRAYSIZE(szTemp2), szTemp, szControlPanel);   // ok to truncate
                        StringCchCat(szWarnText, ARRAYSIZE(szWarnText), szTemp2);   // ok to truncate
                    }

                    //
                    // otherwise, say "these items..." or "some of these items..."
                    //
                    else
                    {
                        TCHAR szTemp2[256];
                        TCHAR szControlPanel[256];
                        int idString = (creg == pida->cidl) ? IDS_CANTRECYCLEREGITEMS_ALL : IDS_CANTRECYCLEREGITEMS_SOME;
                        LoadString(HINST_THISDLL, idString, szTemp, ARRAYSIZE(szTemp));
                        LoadString(HINST_THISDLL, IDS_CANTRECYLE_GENERAL, szControlPanel, ARRAYSIZE(szControlPanel));

                        StringCchCat(szWarnText, ARRAYSIZE(szWarnText), TEXT("\r\n\n"));    // ok to truncate
                        StringCchPrintf(szTemp2, ARRAYSIZE(szTemp2), szTemp, szControlPanel); // ok to truncate
                        StringCchCat(szWarnText, ARRAYSIZE(szWarnText), szTemp2);   // ok to truncate

                        //
                        // we just loaded a very vague message
                        // don't confuse the user any more by adding random text
                        // if these is a special warning, force it to show separately
                        //
                        if (cwarn == 1)
                            cwarn++;
                    }
                }


                //
                // finally, the message box caption (also needed in loop below)
                //
                LoadString(HINST_THISDLL, IDS_CONFIRMDELETE_CAPTION, szWarnCaption, ARRAYSIZE(szWarnCaption));

                // make sure the user is cool with it
                if (MessageBoxIndirect(&mbp) == IDYES)
                {
                    // go ahead and delete the reg items
                    for (i = 0; i < pida->cidl; i++)
                    {
                        LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, i));
                        if (_CanDelete(pidlr))
                        {
                            if ((cwarn > 1) && _GetDeleteMessage(pidlr, szItemWarning, ARRAYSIZE(szItemWarning)))
                            {
                                if (FAILED(_GetDisplayName(pidlr, SHGDN_NORMAL, szItemName, ARRAYSIZE(szItemName))))
                                {
                                    StringCchCopy(szItemName, ARRAYSIZE(szItemName), szWarnCaption);    // ok to truncate
                                }
                                MessageBox(hwnd, szItemWarning, szItemName, MB_OK | MB_ICONINFORMATION);
                            }
                            _DeleteRegItem(pidlr);
                        }
                    }
                }
            }
        }

        // now delete the fs objects
        if (ppidlFS)
        {
            SHInvokeCommandOnPidlArray(hwnd, NULL, (IShellFolder *)this, ppidlFS, countfs, uFlags, "delete");
            LocalFree((HANDLE)ppidlFS);
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }
}

//
// Delete a regitem given its pidl.
//

HRESULT CRegFolder::_DeleteRegItem(LPCIDLREGITEM pidlr)
{
    if (_IsDelegate(pidlr))
        return E_INVALIDARG;

    HRESULT hr = E_ACCESSDENIED;
    if (_CanDelete(pidlr))
    {
        const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment

        if (SHQueryShellFolderValue(&clsid, TEXT("HideOnDesktopPerUser")))
        {
            // hide this icon only on desktop for StartPanel on (0) and off (1)
            hr = ShowHideIconOnlyOnDesktop(&clsid, 0, 1, TRUE);  
        }
        else if (SHQueryShellFolderValue(&clsid, TEXT("HideAsDeletePerUser")))
        {
            // clear the non enuerated bit to hide this item
            hr = _SetAttributes(pidlr, TRUE, SFGAO_NONENUMERATED, SFGAO_NONENUMERATED);
        }
        else if (SHQueryShellFolderValue(&clsid, TEXT("HideAsDelete")))
        {
            // clear the non enuerated bit to hide this item
            hr = _SetAttributes(pidlr, FALSE, SFGAO_NONENUMERATED, SFGAO_NONENUMERATED);
        }
        else
        {
            // remove from the key to delete it
            TCHAR szKeyName[MAX_PATH];

            _GetNameSpaceKey(pidlr, szKeyName, ARRAYSIZE(szKeyName));

            if ((RegDeleteKey(HKEY_CURRENT_USER,  szKeyName) == ERROR_SUCCESS) ||
                (RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName) == ERROR_SUCCESS))
            {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr))
        {
            // tell the world
            LPITEMIDLIST pidlAbs = ILCombine(_GetFolderIDList(), (LPCITEMIDLIST)pidlr);
            if (pidlAbs)
            {
                SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlAbs, NULL);
                ILFree(pidlAbs);
            }
        }
    }
    return hr;
}


// 
// Get the prompt to be displayed if the user tries to delete the regitem,
// this is stored both globally (HKLM) and as s user configured preference.
//

BOOL CRegFolder::_GetDeleteMessage(LPCIDLREGITEM pidlr, LPTSTR pszMsg, int cchMax)
{
    HKEY hk;
    TCHAR szKeyName[MAX_PATH];

    ASSERT(!_IsDelegate(pidlr));
    *pszMsg = 0;

    _GetNameSpaceKey(pidlr, szKeyName, ARRAYSIZE(szKeyName));
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyName, NULL, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS) ||
        (RegOpenKeyEx(HKEY_CURRENT_USER,  szKeyName, NULL, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS))
    {
        SHLoadRegUIString(hk, REGSTR_VAL_REGITEMDELETEMESSAGE, pszMsg, cchMax);
        RegCloseKey(hk);
    }
    return *pszMsg != 0;
}


HRESULT CRegFolder::_GetRegItemColumnFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, LPTSTR pszColumnData, int cchColumnData)
{
    HKEY hkCLSID;
    HRESULT hr = E_FAIL;
    
    _GetClassKeys(pidlr, &hkCLSID, NULL);
    
    *pszColumnData = 0; // Default string
    
    if (hkCLSID)
    {
        // Use SHLoadRegUIString to allow the string to be localized
        if (SUCCEEDED(SHLoadRegUIString(hkCLSID, pszColumnName, pszColumnData, cchColumnData)))
        {
            
            hr = S_OK;
        }        
        
        // FIXED kenwic 052699 #342955
        RegCloseKey(hkCLSID);
    }
    return hr;
}

//
// A more generic version of _GetRegItemColumnFromRegistry which takes a pidlr and a string 
// and finds the corresponding variant value from the registry. 
//
// pidlr:           pidl of the regitem, we open the registry key corresponding to its CLSID
// pszColumnName:   name of the value to took for under the opened key
// pv:              variant to return the value
//
HRESULT CRegFolder::_GetRegItemVariantFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, VARIANT *pv)
{
    HKEY hkCLSID;
    HRESULT hr = E_FAIL;
    
    _GetClassKeys(pidlr, &hkCLSID, NULL);
    
    if (hkCLSID)
    {   
        hr = GetVariantFromRegistryValue(hkCLSID, pszColumnName, pv);                
        RegCloseKey(hkCLSID);        
    }
    return hr;
}

//
//  App compat:  McAfee Nuts & Bolts Quick Copy has the wrong function
//  signature for CreateViewObject.  They implemented it as
//
//      STDAPI CreateViewObject(HWND hwnd) { return S_OK; }
//
//  so we must manually reset the stack after the call.
//
#ifdef _X86_
STDAPI SHAppCompatCreateViewObject(IShellFolder *psf, HWND hwnd, REFIID riid, void * *ppv)
{
    HRESULT hr;
    _asm mov edi, esp
    hr = psf->CreateViewObject(hwnd, riid, ppv);
    _asm mov esp, edi

    // AppCompat - Undelete 2.0 returns S_OK for interfaces that it doesnt support
    // but they do correctly NULL the ppv out param so we check for that as well
    if (SUCCEEDED(hr) && !*ppv)
        hr = E_NOINTERFACE;
    return hr;
}
#else
#define SHAppCompatCreateViewObject(psf, hwnd, riid, ppv) \
        psf->CreateViewObject(hwnd, riid, ppv)
#endif

HRESULT CRegFolder::_CreateViewObjectFor(LPCIDLREGITEM pidlr, HWND hwnd, REFIID riid, void **ppv, BOOL bOneLevel)
{
    IShellFolder *psf;
    HRESULT hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IShellFolder, &psf), bOneLevel);
    if (SUCCEEDED(hr))
    {
        hr = SHAppCompatCreateViewObject(psf, hwnd, riid, ppv);
        psf->Release();
    }
    else
        *ppv = NULL;
    return hr;
}

// Geta an infotip object for the namespace

HRESULT CRegFolder::_GetInfoTip(LPCIDLREGITEM pidlr, void **ppv)
{
    HKEY hkCLSID;
    HRESULT hr = E_FAIL;
    
    _GetClassKeys(pidlr, &hkCLSID, NULL);

    if (hkCLSID)
    {
        DWORD dwQuery, lLen = sizeof(dwQuery);

        // let the regitem code compute the info tip if it wants to...
        if (SHQueryValueEx(hkCLSID, TEXT("QueryForInfoTip"), NULL, NULL, (BYTE *)&dwQuery, &lLen) == ERROR_SUCCESS)
        {
            hr = _CreateViewObjectFor(pidlr, NULL, IID_IQueryInfo, ppv, TRUE);
        }
        else
        {
            hr = E_FAIL;
        }

        // fall back to reading it from the registry
        if (FAILED(hr))
        {
            TCHAR szText[INFOTIPSIZE];

            // Use SHLoadRegUIString to allow the info tip to be localized
            if (SUCCEEDED(SHLoadRegUIString(hkCLSID, TEXT("InfoTip"), szText, ARRAYSIZE(szText))) &&
                szText[0])
            {
                hr = CreateInfoTipFromText(szText, IID_IQueryInfo, ppv); //The InfoTip COM object
            }
        }

        RegCloseKey(hkCLSID);
    }

    return hr;
}

// there are 2 forms for parsing syntax we support
//
// to parse reg items in this folder
//  ::{clsid reg item} [\ optional extra stuff to parse]
//
// to parse items that might live in a delegate folder
//  ::{clsid delegate folder},<delegate folder specific parse string> [\ optional extra stuff to parse]
//
// in both cases the optional remander stuff gets passed through to complete 
// the parse in that name space

HRESULT CRegFolder::_ParseGUIDName(HWND hwnd, LPBC pbc, LPOLESTR pwzDisplayName, 
                                   LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    LPOLESTR pwzNext;
    LPOLESTR pwzDelegateInfo = NULL;

    // Note that we add 2 to skip the RegItem identifier characters
    pwzDisplayName += 2;

    // Skip to a '\\'
    for (pwzNext = pwzDisplayName; *pwzNext && *pwzNext != TEXT('\\'); pwzNext++)
    {
        // if we hit a ',' then eg, ::{GUID},stuff then we assume the stuff is for a delegate 
        if ((*pwzNext == TEXT(',')) && !pwzDelegateInfo)
        {
            pwzDelegateInfo = pwzNext + 1;        // skip comma
        }
    }

    CLSID clsid;
    HRESULT hr = SHCLSIDFromString(pwzDisplayName, &clsid);
    if (SUCCEEDED(hr))
    {
        if (pwzDelegateInfo)
        {
            IShellFolder *psf;
            if (SUCCEEDED(_CreateDelegateFolder(&clsid, IID_PPV_ARG(IShellFolder, &psf))))
            {
                ULONG chEaten;
                hr = psf->ParseDisplayName(hwnd, pbc, pwzDelegateInfo, &chEaten, ppidlOut, pdwAttributes);
                psf->Release();
            }
        }
        else
        {
            IDLREGITEM* pidlRegItem = _CreateAndFillIDLREGITEM(&clsid);
            if (pidlRegItem)
            {
                if (_IsInNameSpace(pidlRegItem) || (BindCtx_GetMode(pbc, 0) & STGM_CREATE))
                {
                    hr = _ParseNextLevel(hwnd, pbc, pidlRegItem, pwzNext, ppidlOut, pdwAttributes);
                }
                else
                    hr = E_INVALIDARG;

                ILFree((LPITEMIDLIST)pidlRegItem);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

//
// ask a (known) regitem to parse a displayname
//

HRESULT CRegFolder::_ParseThroughItem(LPCIDLREGITEM pidlr, HWND hwnd, LPBC pbc,
                                      LPOLESTR pszName, ULONG *pchEaten,
                                      LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    IShellFolder *psfItem;
    HRESULT hr = _BindToItem(pidlr, pbc, IID_PPV_ARG(IShellFolder, &psfItem), FALSE);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlRight;
        hr = psfItem->ParseDisplayName(hwnd, pbc, pszName, pchEaten,
                                         &pidlRight, pdwAttributes);
        if (SUCCEEDED(hr))
        {
            hr = SHILCombine((LPCITEMIDLIST)pidlr, pidlRight, ppidlOut);
            ILFree(pidlRight);
        }
        psfItem->Release();
    }
    return hr;
}

//
// Parse through the GUID to the namespace below
//

HRESULT CRegFolder::_ParseNextLevel(HWND hwnd, LPBC pbc, LPCIDLREGITEM pidlr,
                                    LPOLESTR pwzRest, LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    if (!*pwzRest)
    {
        // base case for recursive calls
        // pidlNext should be a simple pidl.
        ASSERT(!ILIsEmpty((LPCITEMIDLIST)pidlr) && ILIsEmpty(_ILNext((LPCITEMIDLIST)pidlr)));
        if (pdwAttributes && *pdwAttributes)
            _AttributesOf(pidlr, *pdwAttributes, pdwAttributes);
        return SHILClone((LPCITEMIDLIST)pidlr, ppidlOut);
    }

    ASSERT(*pwzRest == TEXT('\\'));

    ++pwzRest;

    IShellFolder *psfNext;
    HRESULT hr = _BindToItem(pidlr, pbc, IID_PPV_ARG(IShellFolder, &psfNext), FALSE);
    if (SUCCEEDED(hr))
    {
        ULONG chEaten;
        LPITEMIDLIST pidlRest;
        hr = psfNext->ParseDisplayName(hwnd, pbc, pwzRest, &chEaten, &pidlRest, pdwAttributes);
        if (SUCCEEDED(hr))
        {
            hr = SHILCombine((LPCITEMIDLIST)pidlr, pidlRest, ppidlOut);
            SHFree(pidlRest);
        }
        psfNext->Release();
    }
    return hr;
}

BOOL _FailForceReturn(HRESULT hr)
{
    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME):
    case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
    case HRESULT_FROM_WIN32(ERROR_CANCELLED):
        return TRUE;
    }
    return FALSE;
}


HRESULT CRegFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, 
                                     ULONG *pchEaten, LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidlOut)
        *ppidlOut = NULL;

    if (ppidlOut && pszName)
    {
        // ::{guid} lets you get the pidl for a reg item

        if (*pszName && (pszName[0] == _chRegItem) && (pszName[1] == _chRegItem))
        {
            hr = _ParseGUIDName(hwnd, pbc, pszName, ppidlOut, pdwAttributes);
        }
        else
        {
            // inner folder gets a chance to parse

            hr = _psfOuter->ParseDisplayName(hwnd, pbc, pszName, pchEaten, ppidlOut, pdwAttributes);
            if (FAILED(hr) && 
                !_FailForceReturn(hr) &&
                !SHSkipJunctionBinding(pbc, NULL))
            {
                // loop over all of the items
            
                HDCA hdca = _ItemArray();
                if (hdca)
                {
                    HRESULT hrTemp = E_FAIL;
                    for (int i = 0; FAILED(hrTemp) && (i < DCA_GetItemCount(hdca)); i++)
                    {
                        const CLSID clsid = *DCA_GetItem(hdca, i);
                        if (!SHSkipJunction(pbc, &clsid)
                        && SHQueryShellFolderValue(&clsid, L"WantsParseDisplayName"))
                        {
                            IDLREGITEM* pidlRegItem = _CreateAndFillIDLREGITEM(DCA_GetItem(hdca, i));
                            if (pidlRegItem)
                            {
                                hrTemp = _ParseThroughItem(pidlRegItem, hwnd, pbc, pszName, pchEaten, ppidlOut, pdwAttributes);
                            }
                            ILFree((LPITEMIDLIST)pidlRegItem);
                        }
                    }
                    DCA_Destroy(hdca);

                    if (SUCCEEDED(hrTemp) || _FailForceReturn(hrTemp))
                        hr = hrTemp;
                    else
                        hr = E_INVALIDARG; // no one could handle it
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        ASSERT(SUCCEEDED(hr) ? *ppidlOut != NULL : *ppidlOut == NULL);
    }

    if (FAILED(hr))
        TraceMsg(TF_WARNING, "CRegFolder::ParseDisplayName(), hr:%x %hs", hr, pszName);

    return hr;
}

HRESULT CRegFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    IEnumIDList *penumOuter;
    HRESULT hr = _psfOuter->EnumObjects(hwnd, grfFlags, &penumOuter);
    if (SUCCEEDED(hr))
    {
        // SUCCEEDED(hr) may be S_FALSE with penumOuter == NULL
        // CRegFolderEnum deals with this just fine
        CRegFolderEnum *preidl = new CRegFolderEnum(this, grfFlags, penumOuter, 
                                                    _ItemArray(), _DelItemArray(), 
                                                    _pPolicy);
        if (preidl)
        {
            *ppenum = SAFECAST(preidl, IEnumIDList*);
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;

        if (penumOuter)
            penumOuter->Release();       // _psfOuter returned S_FALSE
    }
    return hr;
}

// Handle binding to the inner namespace, or the regitem accordingly given its pidl.

HRESULT CRegFolder::_BindToItem(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv, BOOL bOneLevel)
{
    LPITEMIDLIST pidlAlloc;

    *ppv = NULL;

    LPCITEMIDLIST pidlNext = _ILNext((LPCITEMIDLIST)pidlr);
    if (ILIsEmpty(pidlNext))
    {
        pidlAlloc = NULL;
        bOneLevel = TRUE;   // we know for sure it is one level
    }
    else
    {
        pidlAlloc = ILCloneFirst((LPCITEMIDLIST)pidlr);
        if (!pidlAlloc)
            return E_OUTOFMEMORY;

        pidlr = (LPCIDLREGITEM)pidlAlloc;   // a single item IDLIST
    }

    HRESULT hr;
    if (bOneLevel)
    {
        hr = _CreateAndInit(pidlr, pbc, riid, ppv);    // create on riid to avoid loads on interfaces not supported
    }
    else
    {
        IShellFolder *psfNext;
        hr = _CreateAndInit(pidlr, pbc, IID_PPV_ARG(IShellFolder, &psfNext));
        if (SUCCEEDED(hr))
        {
            hr = psfNext->BindToObject(pidlNext, pbc, riid, ppv);
            psfNext->Release();
        }
    }

    if (pidlAlloc)
        ILFree(pidlAlloc);      // we allocated in this case

    return hr;
}

HRESULT CRegFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
        hr = _BindToItem(pidlr, pbc, riid, ppv, FALSE);
    else
        hr = _psfOuter->BindToObject(pidl, pbc, riid, ppv);
    return hr;
}

HRESULT CRegFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

// I can't believe there is no "^^"
#define LOGICALXOR(a, b) (((a) && !(b)) || (!(a) && (b)))

BOOL CRegFolder::_IsFolder(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    if (pidl)
    {
        ULONG uAttrib = SFGAO_FOLDER;
        if (SUCCEEDED(GetAttributesOf(1, &pidl, &uAttrib)) && (SFGAO_FOLDER & uAttrib))
            fRet = TRUE;            
    }

    return fRet;
}

int CRegFolder::_CompareIDsOriginal(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCIDLREGITEM pidlr1 = _IsReg(pidl1);
    LPCIDLREGITEM pidlr2 = _IsReg(pidl2);
    int iRes = 0;
    
    if (pidlr1 && pidlr2)
    {
        iRes = memcmp(&(_GetPIDLRCLSID(pidlr1)), &(_GetPIDLRCLSID(pidlr2)), sizeof(CLSID));
        if (0 == iRes)
        {
            //  if they are the same clsid
            //  and delegates then we need to query
            //  the delegate for the compare
            PDELEGATEITEMID pidld1 = _IsDelegate(pidlr1);
            PDELEGATEITEMID pidld2 = _IsDelegate(pidlr2);
            if (pidld1 && pidld2)
            {
                //  these are both the same delegate
                IShellFolder *psf;
                if (SUCCEEDED(_GetDelegateFolder(pidld1, IID_PPV_ARG(IShellFolder, &psf))))
                {
                    HRESULT hr = psf->CompareIDs(lParam, pidl1, pidl2);
                    psf->Release();
                    iRes = HRESULT_CODE(hr);
                }
            }
            else
            {
                ASSERT(!pidld1 && !pidld2);
            }
        }
        else if (!(SHCIDS_CANONICALONLY & lParam))
        {
            //  sort by defined order
            BYTE bOrder1 = _GetOrder(pidlr1);
            BYTE bOrder2 = _GetOrder(pidlr2);
            int iUI = bOrder1 - bOrder2;
            if (0 == iUI)
            {
                // All of the required items come first, in reverse
                // order (to make this simpler)
                int iItem1 = _ReqItemIndex(pidlr1);
                int iItem2 = _ReqItemIndex(pidlr2);

                if (iItem1 == -1 && iItem2 == -1)
                {
                    TCHAR szName1[MAX_PATH], szName2[MAX_PATH];
                    _GetDisplayName(pidlr1, SHGDN_NORMAL, szName1, ARRAYSIZE(szName1));
                    _GetDisplayName(pidlr2, SHGDN_NORMAL, szName2, ARRAYSIZE(szName2));

                    iUI = StrCmpLogicalRestricted(szName1, szName2);
                }
                else
                {
                    iUI = iItem2 - iItem1;
                }
            }

            if (iUI)
                iRes = iUI;
        }
    }

    return iRes;
}

// Alphabetical (doesn't care about folder, regitems, ...)
int CRegFolder::_CompareIDsAlphabetical(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRes = 0;

    // Do we have only one ptr?
    if (!LOGICALXOR(pidl1, pidl2))
    {
        // No,  either we have two or none.
        if (pidl1 && pidl2)
        {
            iRes = CompareIDsAlphabetical(SAFECAST(this, IShellFolder2*), iColumn, pidl1, pidl2);
        }
        // else iRes already = 0
    }
    else
    {
        // Yes, the one which is non-NULL is first
        iRes = (pidl1 ? -1 : 1);
    }

    return iRes;
}

// Folders comes first, and are ordered in alphabetical order among themselves,
// then comes all the non-folders again sorted among thmeselves
int CRegFolder::_CompareIDsFolderFirst(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRes = 0;

    BOOL fIsFolder1 = _IsFolder(pidl1);
    BOOL fIsFolder2 = _IsFolder(pidl2);

    // Is there one folder and one non-folder?
    if (LOGICALXOR(fIsFolder1, fIsFolder2))
    {
        // Yes, the folder will be first
        iRes = fIsFolder1 ? -1 : 1;
    }
    else
    {
        // No, either both are folders or both are not.  One way or the other, go
        // alphabetically
        iRes = _CompareIDsAlphabetical(iColumn, pidl1, pidl2);
    }

    return iRes;
}

int CRegFolder::_GetOrderType(LPCITEMIDLIST pidl)
{
    if (_IsReg(pidl))
    {
        if (_IsDelegate((LPCIDLREGITEM)pidl))
            return REGORDERTYPE_DELEGATE;
        else if (-1 == _ReqItemIndex((LPCIDLREGITEM)pidl))
            return REGORDERTYPE_REGITEM;
        else 
            return REGORDERTYPE_REQITEM;
    }
    return _iTypeOuter;
}

HRESULT CRegFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iType1 = _GetOrderType(pidl1);
    int iType2 = _GetOrderType(pidl2);
    int iTypeCompare = iType1 - iType2;
    int iRes = 0;
    UINT iColumn = (UINT) (SHCIDS_COLUMNMASK & lParam);

    // first we compare the first level only
    
    switch (_dwSortAttrib)
    {
    case RIISA_ORIGINAL:
        if (0 == iTypeCompare && iType1 == _iTypeOuter)
        {
            // neither are regitems
            return _psfOuter->CompareIDs(lParam, pidl1, pidl2);
        }
        else
        {
            ASSERT(iRes == 0);  // this handled by by CompareIDsOriginal() below
        }
        break;

    case RIISA_FOLDERFIRST:
        iRes = _CompareIDsFolderFirst(iColumn, pidl1, pidl2);
        break;

    case RIISA_ALPHABETICAL:
        iRes = _CompareIDsAlphabetical(iColumn, pidl1, pidl2);
        break;
    }

    //  all our foofy compares and it still looks the same to us
    //  time to get medieval.
    if (0 == iRes)
    {
        iRes = _CompareIDsOriginal(lParam, pidl1, pidl2);
        
        if (0 == iRes)
            iRes = iTypeCompare;

        if (0 == iRes)
        {
            // If the class ID's really are the same, 
            // we'd better check the next level(s)
            return ILCompareRelIDs(SAFECAST(this, IShellFolder *), pidl1, pidl2, lParam);
        }
    }

    return ResultFromShort(iRes);
}

HRESULT CRegFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    return _psfOuter->CreateViewObject(hwnd, riid, ppv);
}

HRESULT CRegFolder::_SetAttributes(LPCIDLREGITEM pidlr, BOOL bPerUser, DWORD dwMask, DWORD dwNewBits)
{
    HKEY hk;
    HRESULT hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), TEXT("ShellFolder"), bPerUser, TRUE, &hk);
    if (SUCCEEDED(hr))
    {
        DWORD err, dwValue = 0, cbSize = sizeof(dwValue);
        SHQueryValueEx(hk, TEXT("Attributes"), NULL, NULL, (BYTE *)&dwValue, &cbSize);

        dwValue = (dwValue & ~dwMask) | (dwNewBits & dwMask);

        err = RegSetValueEx(hk, TEXT("Attributes"), 0, REG_DWORD, (BYTE *)&dwValue, sizeof(dwValue));
        hr = HRESULT_FROM_WIN32(err);
        RegCloseKey(hk);
    }

    EnterCriticalSection(&_cs);
    _clsidAttributesCache = CLSID_NULL;
    LeaveCriticalSection(&_cs);

    return hr;
}

LONG CRegFolder::_RegOpenCLSIDUSKey(CLSID clsid, PHUSKEY phk)
{
    WCHAR wszCLSID[39];
    LONG iRetVal = ERROR_INVALID_PARAMETER;

    if (StringFromGUID2(clsid, wszCLSID, ARRAYSIZE(wszCLSID)))
    {
        TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
        HRESULT hr;

        hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\%s\\ShellFolder"), wszCLSID);
        if (SUCCEEDED(hr))
        {
            iRetVal = SHRegOpenUSKey(szKey, KEY_QUERY_VALUE, NULL, phk, FALSE);
        }
    }

    return iRetVal;    
}

ULONG CRegFolder::_GetPerUserAttributes(LPCIDLREGITEM pidlr)
{
    DWORD dwAttribute = 0;
    HUSKEY hk;
    if (ERROR_SUCCESS == _RegOpenCLSIDUSKey(_GetPIDLRCLSID(pidlr), &hk))
    {
        DWORD cb = sizeof(dwAttribute);
        DWORD dwType = REG_DWORD;
        SHRegQueryUSValue(hk, TEXT("Attributes"), &dwType, &dwAttribute, &cb, FALSE, 0, sizeof(DWORD));
        SHRegCloseUSKey(hk);
    }

    // we only allow these bits to change
    return dwAttribute & (SFGAO_NONENUMERATED | SFGAO_CANDELETE | SFGAO_CANMOVE);
}


#define SFGAO_REQ_MASK (SFGAO_NONENUMERATED | SFGAO_CANDELETE | SFGAO_CANMOVE)

HRESULT CRegFolder::_AttributesOf(LPCIDLREGITEM pidlr, DWORD dwAttributesNeeded, DWORD *pdwAttributes)
{
    HRESULT hr = S_OK;
    *pdwAttributes = 0;

    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        IShellFolder *psf;
        hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            *pdwAttributes = dwAttributesNeeded;
            hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlr, pdwAttributes);
            psf->Release();
        }
    }        
    else
    {
        EnterCriticalSection(&_cs);
        CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment
        BOOL bGuidMatch = IsEqualGUID(clsid, _clsidAttributesCache);
        if (bGuidMatch && ((dwAttributesNeeded & _dwAttributesCacheValid) == dwAttributesNeeded))
        {
            *pdwAttributes = _dwAttributesCache;
        }
        else
        {
            int iItem = _ReqItemIndex(pidlr);

            // if the guid didn't match, we need to start from scratch.
            // otherwise, we'll or back in the cahced bits...
            if (!bGuidMatch)
            {
                _dwAttributesCacheValid = 0;
                _dwAttributesCache = 0;
            }

            if (iItem >= 0)
            {
                *pdwAttributes = _aReqItems[iItem].dwAttributes;
                // per machine attributes allow items to be hidden per machine
                *pdwAttributes |= SHGetAttributesFromCLSID2(&clsid, 0, SFGAO_REQ_MASK) & SFGAO_REQ_MASK;
            }
            else
            {
                *pdwAttributes = SHGetAttributesFromCLSID2(&clsid, SFGAO_CANMOVE | SFGAO_CANDELETE, dwAttributesNeeded & ~_dwAttributesCacheValid);
            }
            *pdwAttributes |= _GetPerUserAttributes(pidlr);   // hidden per user
            *pdwAttributes |= _dwDefAttributes;               // per folder defaults
            *pdwAttributes |= _dwAttributesCache;

            _clsidAttributesCache = clsid;
            _dwAttributesCache = *pdwAttributes;
            _dwAttributesCacheValid |= dwAttributesNeeded | *pdwAttributes; // if they gave us more than we asked for, cache them 
        }
        LeaveCriticalSection(&_cs);
    }
    return hr;
}

HRESULT CRegFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    HRESULT hr;

    if (!cidl)
    {
        // special case for the folder as a whole, so I know nothing about it.
        hr = _psfOuter->GetAttributesOf(cidl, apidl, prgfInOut);
    }
    else
    {
        hr = S_OK;
        UINT rgfOut = *prgfInOut;
        LPCITEMIDLIST *ppidl = (LPCITEMIDLIST*)LocalAlloc(LPTR, cidl * sizeof(*ppidl));
        if (ppidl)
        {
            LPCITEMIDLIST *ppidlEnd = ppidl + cidl;

            for (int i = cidl - 1; SUCCEEDED(hr) && (i >= 0); --i)
            {
                LPCIDLREGITEM pidlr = _IsReg(apidl[i]);
                if (pidlr)
                {
                    if ((*prgfInOut & SFGAO_VALIDATE) && !_IsDelegate(pidlr))
                    {
                        if (!_IsInNameSpace(pidlr))
                        {
                            // validate by binding
                            IUnknown *punk;
                            hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IUnknown, &punk), FALSE);
                            if (SUCCEEDED(hr))
                                punk->Release();
                        }
                    }
                    DWORD dwAttributes;
                    hr = _AttributesOf(pidlr, *prgfInOut, &dwAttributes);
                    if (SUCCEEDED(hr))
                        rgfOut &= dwAttributes;
                    cidl--;     // remove this from the list used below...
                }
                else
                {
                    --ppidlEnd;
                    *ppidlEnd = apidl[i];
                }
            }

            if (SUCCEEDED(hr) && cidl)   // any non reg items left?
            {
                ULONG rgfThis = rgfOut;
                hr = _psfOuter->GetAttributesOf(cidl, ppidlEnd, &rgfThis);
                rgfOut &= rgfThis;
            }

            LocalFree((HLOCAL)ppidl);
            *prgfInOut = rgfOut;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CRegFolder::_CreateDefExtIconKey(HKEY hkey,
                        UINT cidl, LPCITEMIDLIST *apidl, int iItem,
                        REFIID riid, void** ppvOut)
{
    // See if this guy has an icon handler

    TCHAR szHandler[GUIDSTR_MAX];
    HRESULT hr;

    if (hkey &&
        SUCCEEDED(AssocQueryStringByKey(NULL, ASSOCSTR_SHELLEXTENSION, hkey,
                        TEXT("IconHandler"), szHandler, IntToPtr_(LPDWORD, ARRAYSIZE(szHandler)))) &&
        SUCCEEDED(SHExtCoCreateInstance(szHandler, NULL, NULL, riid, ppvOut)))
    {
        IShellExtInit *psei;
        if (SUCCEEDED(((IUnknown*)*ppvOut)->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
        {
            IDataObject *pdto;
            hr = GetUIObjectOf(NULL, cidl, apidl, IID_PPV_ARG_NULL(IDataObject, &pdto));
            if (SUCCEEDED(hr))
            {
                hr = psei->Initialize(_GetFolderIDList(), pdto, hkey);
                pdto->Release();
            }
            psei->Release();
        }
        else
        {   // Object doesn't need to be initialized, no problemo
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }

        ((IUnknown *)*ppvOut)->Release();  // Lose this bad guy
    }

    // No icon handler (or icon handler punted); look for DefaultIcon key.

    LPCTSTR pszIconFile;
    int iDefIcon;

    if (iItem >= 0)
    {
        pszIconFile = _aReqItems[iItem].pszIconFile;
        iDefIcon = _aReqItems[iItem].iDefIcon;
    }
    else
    {
        pszIconFile = NULL;
        iDefIcon = II_FOLDER;
    }

    return SHCreateDefExtIconKey(hkey, pszIconFile, iDefIcon, iDefIcon, -1, -1, GIL_PERCLASS, riid, ppvOut);
}

HRESULT CRegFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, 
                                  REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr;
    
    *ppv = NULL;
    LPCIDLREGITEM pidlr = _AnyRegItem(cidl, apidl);
    if (pidlr)
    {
        IShellFolder *psf;
        if (_AllDelegates(cidl, apidl, &psf))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
            psf->Release();
        }
        else
        {
            if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW))
            {
                HKEY hkCLSID;
                int iItem = _ReqItemIndex(pidlr);

                // try first to get a per-user icon
                hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), NULL, TRUE, FALSE, &hkCLSID);
                if (SUCCEEDED(hr))
                {
                    hr = _CreateDefExtIconKey(hkCLSID, cidl, apidl, iItem, riid, ppv);
                    if (hr == S_FALSE)
                    {
                        ((IUnknown *)*ppv)->Release();    // Lose this bad guy
                        *ppv = NULL;
                    }
                    RegCloseKey(hkCLSID);
                }

                //
                // fall back to a per-class icon
                //
                if (*ppv == NULL)
                {
                    hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), NULL, FALSE, FALSE, &hkCLSID);
                    if (SUCCEEDED(hr))
                    {
                        hr = _CreateDefExtIconKey(hkCLSID, cidl, apidl, iItem, riid, ppv);
                        RegCloseKey(hkCLSID);
                    }
                }
            }
            else if (IsEqualIID(riid, IID_IQueryInfo))
            {
                hr = _GetInfoTip(pidlr, ppv);
            }
            else if (IsEqualIID(riid, IID_IQueryAssociations))
            {
                hr = _AssocCreate(pidlr, riid, ppv);
            }
            else if (IsEqualIID(riid, IID_IDataObject))
            {
                hr = CIDLData_CreateFromIDArray(_GetFolderIDList(), cidl, apidl, (IDataObject **)ppv);
            }
            else if (IsEqualIID(riid, IID_IContextMenu))
            {
                hr = _psfOuter->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
                if (SUCCEEDED(hr))
                {
                    HKEY keys[2];

                    _GetClassKeys(pidlr, &keys[0], &keys[1]);
                    hr = CDefFolderMenu_Create2Ex(_GetFolderIDList(), hwnd,
                                                   cidl, apidl, 
                                                   psf, this,
                                                   ARRAYSIZE(keys), keys, 
                                                   (IContextMenu **)ppv);

                    SHRegCloseKeys(keys, ARRAYSIZE(keys));
                    psf->Release();
                }
            }
            else if (cidl == 1)
            {
                // blindly delegate unknown riid (IDropTarget, IShellLink, etc) through
                // APP COMPAT!  GetUIObjectOf does not support multilevel pidls, but
                // Symantec Internet Fast Find does a
                //
                //      psfDesktop->GetUIObjectOf(1, &pidlComplex, IID_IDropTarget, ...)
                //
                //  on a multilevel pidl and expects it to work.  I guess it worked by
                //  lucky accident once upon a time, so now it must continue to work,
                //  but only on the desktop.
                //
                hr = _CreateViewObjectFor(pidlr, hwnd, riid, ppv, !_IsDesktop());
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }
    }
    else
    {
        hr = _psfOuter->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    return hr;
}

HRESULT CRegFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *pStrRet)
{
    HRESULT hr;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        LPCITEMIDLIST pidlNext = _ILNext(pidl);

        if (ILIsEmpty(pidlNext))
        {
            TCHAR szName[MAX_PATH];
            hr = _GetDisplayName(pidlr, dwFlags, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
                hr = StringToStrRet(szName, pStrRet);
        }
        else
        {
            IShellFolder *psfNext;
            hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IShellFolder, &psfNext), TRUE);
            if (SUCCEEDED(hr))
            {
                hr = psfNext->GetDisplayNameOf(pidlNext, dwFlags, pStrRet);
                //  If it returns an offset to the pidlNext, we should
                // change the offset relative to pidl.
                if (SUCCEEDED(hr) && pStrRet->uType == STRRET_OFFSET)
                    pStrRet->uOffset += (DWORD)((BYTE *)pidlNext - (BYTE *)pidl);

                psfNext->Release();
            }
        }
    }
    else
        hr = _psfOuter->GetDisplayNameOf(pidl, dwFlags, pStrRet);

    return hr;
}

HRESULT CRegFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, 
                              LPCOLESTR pszName, DWORD dwFlags, LPITEMIDLIST *ppidlOut)
{
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        HRESULT hr = E_INVALIDARG;

        if (ppidlOut)
            *ppidlOut = NULL;

        PDELEGATEITEMID pidld = _IsDelegate(pidlr);
        if (pidld)
        {
            IShellFolder *psf;
            hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->SetNameOf(hwnd, pidl, pszName, dwFlags, ppidlOut);
                psf->Release();
            }
        }        
        else
        {        
            HKEY hkCLSID;

            _ClearNameFromCache();

            // See if per-user entry exists...
            hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), NULL, TRUE, TRUE, &hkCLSID);

            // If no per-user, then use per-machine...
            if (FAILED(hr))
            {
                _GetClassKeys(pidlr, &hkCLSID, NULL);

                if (hkCLSID)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            if (SUCCEEDED(hr))
            {
                TCHAR szName[MAX_PATH];

                SHUnicodeToTChar(pszName, szName, ARRAYSIZE(szName));

                if (RegSetValue(hkCLSID, NULL, REG_SZ, szName, (lstrlen(szName) + 1) * sizeof(szName[0])) == ERROR_SUCCESS)
                {
                    LPITEMIDLIST pidlAbs = ILCombine(_GetFolderIDList(), pidl);
                    if (pidlAbs)
                    {
                        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidlAbs, NULL);
                        ILFree(pidlAbs);
                    }

                    if (ppidlOut)
                        *ppidlOut = ILClone(pidl);  // name is not in the PIDL so old == new

                    hr = S_OK;
                }
                else
                    hr = E_FAIL;

                RegCloseKey(hkCLSID);
            }
        }
        return hr;
    }
    return _psfOuter->SetNameOf(hwnd, pidl, pszName, dwFlags, ppidlOut);
}

HRESULT CRegFolder::GetDefaultSearchGUID(LPGUID lpGuid)
{
    return _psfOuter->GetDefaultSearchGUID(lpGuid);
}   

HRESULT CRegFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    return _psfOuter->EnumSearches(ppenum);
}

HRESULT CRegFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    return _psfOuter->GetDefaultColumn(dwRes, pSort, pDisplay);
}

HRESULT CRegFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{
    return _psfOuter->GetDefaultColumnState(iColumn, pbState);
}

HRESULT CRegFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_NOTIMPL;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        PDELEGATEITEMID pidld = _IsDelegate(pidlr);
        if (pidld)
        {
            IShellFolder2 *psf2;
            hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder2, &psf2));
            if (SUCCEEDED(hr))
            {
                hr = psf2->GetDetailsEx(pidl, pscid, pv);
                psf2->Release();
            }
        }        
        else
        {
            TCHAR szTemp[INFOTIPSIZE];
            szTemp[0] = 0;
            if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
            {
                SHDESCRIPTIONID did;
                did.dwDescriptionId = SHDID_ROOT_REGITEM;
                did.clsid = _GetPIDLRCLSID(pidlr);
                hr = InitVariantFromBuffer(pv, &did, sizeof(did));
            }
            else if (IsEqualSCID(*pscid, SCID_NAME))
            {
                _GetDisplayName(pidlr, SHGDN_NORMAL, szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else if (IsEqualSCID(*pscid, SCID_TYPE))
            {
                LoadString(HINST_THISDLL, IDS_DRIVES_REGITEM, szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else if (IsEqualSCID(*pscid, SCID_Comment))
            {
                _GetRegItemColumnFromRegistry(pidlr, TEXT("InfoTip"), szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else if (IsEqualSCID(*pscid, SCID_FolderIntroText))
            {
                _GetRegItemColumnFromRegistry(pidlr, TEXT("IntroText"), szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else
            {
                TCHAR ach[SCIDSTR_MAX];
                StringFromSCID(pscid, ach, ARRAYSIZE(ach));                    
                hr = _GetRegItemVariantFromRegistry(pidlr, ach, pv);
            }
        }
    }
    else
    {
        hr = _psfOuter->GetDetailsEx(pidl, pscid, pv);
    }
    return hr;
}

HRESULT CRegFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetail)
{
    HRESULT hr = E_FAIL;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        pDetail->str.uType = STRRET_CSTR;
        pDetail->str.cStr[0] = 0;
        SHCOLUMNID scid;

        hr = _psfOuter->MapColumnToSCID(iColumn, &scid);
        if (SUCCEEDED(hr))
        {
            VARIANT var = {0};
            hr = GetDetailsEx(pidl, &scid, &var);
            if (SUCCEEDED(hr))
            {
                // we need to use SHFormatForDisplay (or we could have use IPropertyUI)
                // to format arbitrary properties into the right display type

                TCHAR szText[MAX_PATH];
                hr = SHFormatForDisplay(scid.fmtid, scid.pid, (PROPVARIANT *)&var, 
                    PUIFFDF_DEFAULT, szText, ARRAYSIZE(szText));
                if (SUCCEEDED(hr))
                {
                    hr = StringToStrRet(szText, &pDetail->str);
                }
                VariantClear(&var);
            }
        }
    }
    else
    {
        hr = _psfOuter->GetDetailsOf(pidl, iColumn, pDetail);
    }
    return hr;
}

HRESULT CRegFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    return _psfOuter->MapColumnToSCID(iColumn, pscid);
}

HRESULT CRegFolder::_GetOverlayInfo(LPCIDLREGITEM pidlr, int *pIndex, BOOL fIconIndex)
{
    HRESULT hr = E_FAIL;
    const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment  
    if (SHQueryShellFolderValue(&clsid, TEXT("QueryForOverlay")))
    {
        IShellIconOverlay* psio;
        hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IShellIconOverlay, &psio), TRUE);
        if (SUCCEEDED(hr))
        {
            // NULL pidl means "I want to know about YOU, folder, not one of your kids",
            // we only pass that though when its is not a deligate.

            LPITEMIDLIST pidlToPass = (LPITEMIDLIST)_IsDelegate(pidlr);
            if (fIconIndex)
                hr = psio->GetOverlayIconIndex(pidlToPass, pIndex);
            else
                hr = psio->GetOverlayIndex(pidlToPass, pIndex);

            psio->Release();
        }
    }

    return hr;
}

// IShellIconOverlay
HRESULT CRegFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;

    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        hr = _GetOverlayInfo(pidlr, pIndex, FALSE);
    }
    else if (_psioOuter)
    {
        hr = _psioOuter->GetOverlayIndex(pidl, pIndex);
    }

    return hr;
}

HRESULT CRegFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    HRESULT hr = E_FAIL;

    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        hr = _GetOverlayInfo(pidlr, pIconIndex, TRUE);
    }
    else if (_psioOuter)
    {
        hr = _psioOuter->GetOverlayIconIndex(pidl, pIconIndex);
    }

    return hr;
}


// CContextMenuCB

DWORD CALLBACK _RegFolderPropThreadProc(void *pv)
{
    PROPSTUFF *pdps = (PROPSTUFF *)pv;
    CRegFolder *prf = (CRegFolder *)pdps->psf;
    STGMEDIUM medium;
    ULONG_PTR dwCookie = 0;
    ActivateActCtx(NULL, &dwCookie);

    LPIDA pida = DataObj_GetHIDA(pdps->pdtobj, &medium);
    if (pida)
    {
        LPCIDLREGITEM pidlr = prf->_IsReg(IDA_GetIDListPtr(pida, 0));
        if (pidlr)
        {
            int iItem = prf->_ReqItemIndex(pidlr);
            if (iItem >= 0 && prf->_aReqItems[iItem].pszCPL)
                SHRunControlPanel(prf->_aReqItems[iItem].pszCPL, NULL);
            else
            {
                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(prf->_GetDisplayName(pidlr, SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
                {
                    HKEY hk;

                    prf->_GetClassKeys(pidlr, &hk, NULL);

                    if (hk)
                    {
                        SHOpenPropSheet(szName, &hk, 1, NULL, pdps->pdtobj, NULL, (LPCTSTR)pdps->pStartPage);
                        RegCloseKey(hk);
                    }
                }   
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return 0;
}

DWORD DisconnectDialogOnThread(void *pv)
{
    WNetDisconnectDialog(NULL, RESOURCETYPE_DISK);
    SHChangeNotifyHandleEvents();       // flush any drive notifications
    return 0;
}

HRESULT CRegFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, 
                                       UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                // some ugly specal cases...
                if (HIDA_GetCount(medium.hGlobal) == 1)
                {
                    LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, 0));
                    if (pidlr && !_IsDelegate(pidlr))
                    {
                        const CLSID clsid = _GetPIDLRCLSID(pidlr);  // alignment

                        if ((IsEqualGUID(clsid, CLSID_MyComputer) ||
                             IsEqualGUID(clsid, CLSID_NetworkPlaces)) &&
                            (GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS) &&
                             !SHRestricted(REST_NONETCONNECTDISCONNECT))
                        {
                            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DESKTOP_ITEM, 0, (LPQCMINFO)lParam);
                        }
                    }
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMANDEX:
        {
            DFMICS *pdfmics = (DFMICS *)lParam;
            switch (wParam)
            {
            case FSIDM_CONNECT:
                SHStartNetConnectionDialog(NULL, NULL, RESOURCETYPE_DISK);
                break;

            case FSIDM_DISCONNECT:
                SHCreateThread(DisconnectDialogOnThread, NULL, CTF_COINIT, NULL);
                break;

            case DFM_CMD_PROPERTIES:
                hr = SHLaunchPropSheet(_RegFolderPropThreadProc, pdtobj, (LPCTSTR)pdfmics->lParam, this, NULL);
                break;

            case DFM_CMD_DELETE:
                _Delete(hwnd, pdfmics->fMask, pdtobj);
                break;

            default:
                // This is one of view menu items, use the default code.
                hr = S_FALSE;
                break;
            }
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

// IRegItemsFolder

TCHAR const c_szRegExplorerBackslash[] = REGSTR_PATH_EXPLORER  TEXT("\\");

HRESULT CRegFolder::Initialize(REGITEMSINFO *pri)
{
    ASSERT(pri != NULL);
    HRESULT hr = E_INVALIDARG;

    if (!_fcs)
    {
        if (!InitializeCriticalSectionAndSpinCount(&_cs, 0))
        {
            return E_FAIL;
        }
    }
    _fcs = TRUE;

    _pszRegKey        = pri->pszRegKey;
    _pPolicy          = pri->pPolicy;
    _chRegItem        = pri->cRegItem;
    _bFlags           = pri->bFlags;
    _iTypeOuter       = pri->iCmp > 0 ? REGORDERTYPE_OUTERAFTER : REGORDERTYPE_OUTERBEFORE ;
    _dwDefAttributes  = pri->rgfRegItems;
    _dwSortAttrib     = pri->dwSortAttrib;
    _cbPadding        = pri->cbPadding;
    _bFlagsLegacy     = pri->bFlagsLegacy;

    // If the registry key lives under HKEY_PATH_EXPLORER, then
    // we will also support per-session regitems.
    //
    int cchPrefix = ARRAYSIZE(c_szRegExplorerBackslash) - 1;
    if (StrCmpNI(_pszRegKey, c_szRegExplorerBackslash, cchPrefix) == 0)
    {
        _pszSesKey = _pszRegKey + cchPrefix;
    } 
    else 
    {
        _pszSesKey = NULL;
    }

    if ((RIISA_ORIGINAL == _dwSortAttrib) ||
        (RIISA_FOLDERFIRST == _dwSortAttrib) ||
        (RIISA_ALPHABETICAL == _dwSortAttrib))
    {
        Str_SetPtr(&_pszMachine, pri->pszMachine);    // save a copy of this

        _aReqItems = (REQREGITEM *)LocalAlloc(LPTR, sizeof(*_aReqItems) * pri->iReqItems);
        if (!_aReqItems)
            return E_OUTOFMEMORY;

        memcpy(_aReqItems, pri->pReqItems, sizeof(*_aReqItems) * pri->iReqItems);
        _nRequiredItems = pri->iReqItems;

        // If we are aggregated, cache the _psioOuter and _psfOuter
        _QueryOuterInterface(IID_PPV_ARG(IShellIconOverlay, &_psioOuter));
        hr = _QueryOuterInterface(IID_PPV_ARG(IShellFolder2, &_psfOuter));
    }
    return hr;
}


//
// instance creation of the RegItems object
//

STDAPI CRegFolder_CreateInstance(REGITEMSINFO *pri, IUnknown *punkOuter, REFIID riid, void **ppv) 
{
    HRESULT hr;

    // we only suport being created as an agregate
    if (!punkOuter || !IsEqualIID(riid, IID_IUnknown))
    {
        ASSERT(0);
        return E_FAIL;
    }

    CRegFolder *prif = new CRegFolder(punkOuter);
    if (prif)
    {
        hr = prif->Initialize(pri);           // initialize the regfolder
        if (SUCCEEDED(hr))
            hr = prif->_GetInner()->QueryInterface(riid, ppv);

        //
        //  If the Initalize and QueryInterface succeeded, this will drop
        //  the refcount from 2 to 1.  If they failed, then this will drop
        //  the refcount from 1 to 0 and free the object.
        //
        ULONG cRef = prif->_GetInner()->Release();

        //
        //  On success, the object should have a refcout of exactly 1.
        //  On failure, the object should have a refcout of exactly 0.
        //
        ASSERT(SUCCEEDED(hr) == (BOOL)cRef);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

CRegFolderEnum::CRegFolderEnum(CRegFolder* prf, DWORD grfFlags, IEnumIDList* peidl, 
                               HDCA hdca, HDCA hdcaDel, 
                               REGITEMSPOLICY* pPolicy) :
    _cRef(1),
    _grfFlags(grfFlags),
    _prf(prf),
    _peidl(peidl),
    _hdca(hdca),
    _pPolicy(pPolicy),
    _hdcaDel(hdcaDel)
{
    ASSERT(_iCur == 0);
    ASSERT(_iCurDel == 0);
    ASSERT(_peidlDel == NULL);

    _prf->AddRef();

    if (_peidl)
        _peidl->AddRef();

    DllAddRef();
}

CRegFolderEnum::~CRegFolderEnum()
{
    if (_hdca)
        DCA_Destroy(_hdca);
    if (_hdcaDel)
        DCA_Destroy(_hdcaDel);

    ATOMICRELEASE(_prf);
    ATOMICRELEASE(_peidl);
    ATOMICRELEASE(_peidlDel);

    DllRelease();
}

//
// IUnknown
//

STDMETHODIMP_(ULONG) CRegFolderEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CRegFolderEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CRegFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CRegFolderEnum, IEnumIDList), // IID_IEnumIDList
        QITABENT(CRegFolderEnum, IObjectWithSite), // IID_IObjectWithSite
        { 0 },
    };    
    return QISearch(this, qit, riid, ppv);
}

//
// IEnumIDList
//

BOOL CRegFolderEnum::_TestFolderness(DWORD dwAttribItem)
{
    if ((_grfFlags & (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS)) != (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS))
    {
        if (dwAttribItem & SFGAO_FOLDER)
        {
            if (!(_grfFlags & SHCONTF_FOLDERS))
                return FALSE;
        }
        else
        {
            if (!(_grfFlags & SHCONTF_NONFOLDERS))
                return FALSE;
        }
    }
    return TRUE;
}

BOOL CRegFolderEnum::_TestHidden(LPCIDLREGITEM pidlRegItem)
{
    CLSID clsidRegItem = _prf->_GetPIDLRCLSID(pidlRegItem);
    return _TestHiddenInWebView(&clsidRegItem) || _TestHiddenInDomain(&clsidRegItem);
}

BOOL CRegFolderEnum::_TestHiddenInWebView(LPCLSID clsidRegItem)
{
    BOOL fRetVal = FALSE;
    if (S_FALSE == SHShouldShowWizards(_punkSite))
    {
        fRetVal = SHQueryShellFolderValue(clsidRegItem, TEXT("HideInWebView"));
    }
    return fRetVal;
}

BOOL CRegFolderEnum::_TestHiddenInDomain(LPCLSID clsidRegItem)
{
    return IsOS(OS_DOMAINMEMBER) && SHQueryShellFolderValue(clsidRegItem, TEXT("HideInDomain"));
}

// Check policy restrictions
BOOL CRegFolderEnum::_IsRestricted()
{
    BOOL bIsRestricted = FALSE;
    if (_pPolicy)
    {
        TCHAR szName[256];
        szName[0] = 0;
    
        HKEY hkRoot;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, _T("CLSID"), NULL, KEY_QUERY_VALUE, &hkRoot))
        {
            TCHAR szGUID[64];
            SHStringFromGUID(*DCA_GetItem(_hdca, _iCur - 1), szGUID, ARRAYSIZE(szGUID));
        
            SHLoadLegacyRegUIString(hkRoot, szGUID, szName, ARRAYSIZE(szName));
            RegCloseKey(hkRoot);
        }

        if (szName[0])
        {
            if (SHRestricted(_pPolicy->restAllow) && !IsNameListedUnderKey(szName, _pPolicy->pszAllow))
                bIsRestricted = TRUE;

            if (SHRestricted(_pPolicy->restDisallow) && IsNameListedUnderKey(szName, _pPolicy->pszDisallow))
                bIsRestricted = TRUE;
        }
    }
    return bIsRestricted;
}

BOOL CRegFolderEnum::_WrongMachine()
{
    BOOL bWrongMachine = FALSE;

    // We're filling the regitem with class id clsid. If this is a
    // remote item, first invoke the class to see if it really wants
    // to be enumerated for this remote computer.
    if (_prf->_pszMachine)
    {
        IUnknown* punk;
        // Don't need DCA_ExtCreateInstance since these keys come from
        // HKLM which is already trusted and HKCU which is the user's
        // own fault.
        HRESULT hr = DCA_CreateInstance(_hdca, _iCur - 1, IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {
            hr = _prf->_InitFromMachine(punk, TRUE);
            punk->Release();
        }
        
        bWrongMachine = FAILED(hr);
    }
    return bWrongMachine;
}

HRESULT CRegFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidlOut, ULONG *pceltFetched)
{
    // enumerate from the DCA containing the regitems objects
    if (_hdca)
    {
        if (0 == (SHCONTF_NETPRINTERSRCH & _grfFlags)) //don't enumerate phantom folders for printer search dialog
        {
            while (_iCur < DCA_GetItemCount(_hdca))
            {
                _iCur++;

                if (_WrongMachine())
                    continue;

                if (_IsRestricted())
                    continue;

                // Ok, actually enumerate the item
                
                HRESULT hr;
                IDLREGITEM* pidlRegItem = _prf->_CreateAndFillIDLREGITEM(DCA_GetItem(_hdca, _iCur-1));
                if (pidlRegItem)
                {
                    DWORD dwAttribItem;
                    _prf->_AttributesOf(pidlRegItem, SFGAO_NONENUMERATED | SFGAO_FOLDER, &dwAttribItem);
    
                    if (!(dwAttribItem & SFGAO_NONENUMERATED) &&
                        _TestFolderness(dwAttribItem) &&
                        !_TestHidden(pidlRegItem))
                    {
                        *ppidlOut = (LPITEMIDLIST)pidlRegItem;
                        hr = S_OK;
                    }
                    else
                    {
                        SHFree(pidlRegItem);
                        continue;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
                if (SUCCEEDED(hr) && pceltFetched)
                    *pceltFetched = 1;
                
                return hr;
            }
        }
    }

    // enumerate from the DCA containing the delegate shell folders

    while (_peidlDel || (_hdcaDel && (_iCurDel < DCA_GetItemCount(_hdcaDel))))
    {
        // we have an enumerator object, so lets call it and see
        // what it generates, if it runs out of items then we either
        // give up (saying were done) or allow us to be called again.

        if (_peidlDel)
        {
            if (S_OK == _peidlDel->Next(celt, ppidlOut, pceltFetched))
                return S_OK;

            ATOMICRELEASE(_peidlDel);
        }
        else
        {
            // we didn't have an enumerator to call, so lets try and 
            // create an new IDelegateFolderObject, if that worked
            // then we can set its item allocator, then get an
            // enumerator back from it.

            IShellFolder *psfDelegate;
            if (SUCCEEDED(_prf->_CreateDelegateFolder(DCA_GetItem(_hdcaDel, _iCurDel++), IID_PPV_ARG(IShellFolder, &psfDelegate))))
            {
                psfDelegate->EnumObjects(NULL, _grfFlags, &_peidlDel);
                psfDelegate->Release();
            }
        }
    }     

    // now DKA, or we are just about done so lets pass to the inner ISF
    // and see what they return.

    if (_peidl)
        return _peidl->Next(celt, ppidlOut, pceltFetched);

    *ppidlOut = NULL;
    if (pceltFetched)
        pceltFetched = 0;

    return S_FALSE;
}

STDMETHODIMP CRegFolderEnum::Reset()
{
    // Adaptec Easy CD Creator (versions 3.0, 3.01, 3.5) enumerates the
    // items in an IShellFolder like this:
    //
    //  psf->EnumObjects(&penum);
    //  UINT cObjects = 0;
    //  while (SUCCEEDED(penum->Next(...)) {
    //      [code]
    //      penum->Reset();
    //      penum->Skip(++cObjects);
    //  }
    //
    //  So they took an O(n) algorithm and turned it into an O(n^2)
    //  algorithm.  They got away with it because in the old days,
    //  regfldr implemented neither IEnumIDList::Reset nor
    //  IEnumIDList::Skip, so the two calls were just NOPs.
    //
    //  Now we implement IEnumIDList::Reset, so without this hack,
    //  they end up enumerating the same object over and over again.

    if (SHGetAppCompatFlags(ACF_IGNOREENUMRESET) & ACF_IGNOREENUMRESET)
        return E_NOTIMPL;

    _iCurDel = _iCur = 0;
    ATOMICRELEASE(_peidlDel);

    if (_peidl)
        return _peidl->Reset();

    return S_OK;
}

STDMETHODIMP CRegFolderEnum::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(_peidl, punkSite);

    return CObjectWithSite::SetSite(punkSite);
}

//
// Delegate Malloc functions
//

#undef new // Hack!! Need to remove this (daviddv)

class CDelagateMalloc : public IMalloc
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IMalloc
    STDMETHODIMP_(void *) Alloc(SIZE_T cb);
    STDMETHODIMP_(void *) Realloc(void *pv, SIZE_T cb);
    STDMETHODIMP_(void) Free(void *pv);
    STDMETHODIMP_(SIZE_T) GetSize(void *pv);
    STDMETHODIMP_(int) DidAlloc(void *pv);
    STDMETHODIMP_(void) HeapMinimize();

private:
    CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter);
    ~CDelagateMalloc() {}
    void* operator new(size_t cbClass, SIZE_T cbSize)
    {
        return ::operator new(cbClass + cbSize);
    }


    friend HRESULT CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

protected:
    LONG _cRef;
    WORD _wOuter;           // delegate item outer signature
    WORD _wUnused;          // to allign
#ifdef DEBUG
    UINT _cAllocs;
#endif
    SIZE_T _cb;
    BYTE _data[EMPTY_SIZE];
};

CDelagateMalloc::CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter)
{
    _cRef = 1;
    _wOuter = wOuter;
    _cb = cbSize;

    memcpy(_data, pv, _cb);
}

HRESULT CDelagateMalloc::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDelagateMalloc, IMalloc),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDelagateMalloc::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDelagateMalloc::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// the cbInner is the size of the data needed by the delegate. we need to compute
// the full size of the pidl for the allocation and init that we the outer folder data

void *CDelagateMalloc::Alloc(SIZE_T cbInner)
{
    DELEGATEITEMID *pidl;
    SIZE_T cbAlloc = 
        sizeof(DELEGATEITEMID) - sizeof(pidl->rgb[0]) + // header
        cbInner +                                       // inner
        _cb +                                           // outer data
        sizeof(WORD);                                   // trailing null (pidl terminator)

    pidl = (DELEGATEITEMID *)SHAlloc(cbAlloc);
    if (pidl)
    {
        ZeroMemory(pidl, cbAlloc);              // make it all empty
        pidl->cbSize = (WORD)cbAlloc - sizeof(WORD);
        pidl->wOuter = _wOuter;
        pidl->cbInner = (WORD)cbInner;
        memcpy(&pidl->rgb[cbInner], _data, _cb);
#ifdef DEBUG
        _cAllocs++;
#endif
    }
    return pidl;
}

void *CDelagateMalloc::Realloc(void *pv, SIZE_T cb)
{
    return NULL;
}

void CDelagateMalloc::Free(void *pv)
{
    SHFree(pv);
}

SIZE_T CDelagateMalloc::GetSize(void *pv)
{
    return (SIZE_T)-1;
}

int CDelagateMalloc::DidAlloc(void *pv)
{
    return -1;
}

void CDelagateMalloc::HeapMinimize()
{
}

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc)
{
    HRESULT hr;
    CDelagateMalloc *pdm = new(cbSize) CDelagateMalloc(pv, cbSize, wOuter);
    if (pdm)
    {
        hr = pdm->QueryInterface(IID_PPV_ARG(IMalloc, ppmalloc));
        pdm->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regsuprt.h ===
#ifndef __REGSUPRT_H
#define __REGSUPRT_H

#define REG_OPTION_INVALID  0xFFFFFFFF

// MAX_ROOT is the maximum we support for the root
#define MAX_ROOT            MAX_PATH

class CRegSupport
{
public:
    CRegSupport();
    virtual ~CRegSupport();

public:
    void RSInitRoot(HKEY hkey, LPCTSTR pszSubKey1, LPCTSTR pszSubKey2, 
        DWORD dwRootOptions = REG_OPTION_VOLATILE, 
        DWORD dwDefaultOptions = REG_OPTION_VOLATILE);

    virtual BOOL RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    virtual BOOL RSSubKeyExist(LPCTSTR pszSubKey);

    virtual BOOL RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    virtual BOOL RSDeleteSubKey(LPCTSTR pszSubKey);
    virtual BOOL RSDeleteKey();

    virtual HKEY RSDuplicateRootKey();
    virtual HKEY RSDuplicateSubKey(LPCTSTR pszSubKey, BOOL fCreate, BOOL fVolatile);

    BOOL RSGetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               LPTSTR pszValue, DWORD* pcchValue);
    BOOL RSGetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD* pcb);
    BOOL RSGetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD* pdwValue);

    BOOL RSSetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, LPCTSTR pszValue,
        DWORD dwOptions = REG_OPTION_INVALID);
    BOOL RSSetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, PBYTE pb, DWORD cb,
        DWORD dwOptions = REG_OPTION_INVALID);
    BOOL RSSetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD dwValue,
        DWORD dwOptions = REG_OPTION_INVALID);

protected:
    virtual void _CloseRegSubKey(HKEY hkeyVolumeSubKey);

    virtual HKEY _GetRootKey(BOOL fCreate, DWORD dwOptions = REG_OPTION_INVALID);

    virtual BOOL _SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD cb, DWORD dwType,
                                DWORD dwOptions);
    virtual BOOL _GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD* pcb);

    HKEY _GetSubKey(LPCTSTR pszSubKey, BOOL fCreate,
        DWORD dwOptions = REG_OPTION_INVALID);

    static HKEY _RegCreateKeyExHelper(HKEY hkey, LPCTSTR pszSubKey,
        DWORD dwOptions);
    static HKEY _RegOpenKeyExHelper(HKEY hkey, LPCTSTR pszSubKey);

protected:
    virtual BOOL _InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2);
    void _EnterCSKeyRoot();
    void _LeaveCSKeyRoot();

    virtual LPCTSTR _GetRoot(LPTSTR pszRoot, DWORD cchRoot);

protected:
    LPCTSTR                 _pszSubKey1;
    LPCTSTR                 _pszSubKey2;

private:
    DWORD                   _dwRootOptions;
    DWORD                   _dwDefaultOptions;

    HKEY                    _hkeyInit; // HKEY_CURRENT_USER, ...
    
    CRITICAL_SECTION        _csKeyRoot;
    BOOL                    _fcsKeyRoot;

#ifdef DEBUG
    static UINT             _cRefHKEY;
    static UINT             _cRefExternalHKEY;

    BOOL                    _fInited;
#endif
};

#endif //__REGSUPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regtreeitems.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "theme.h"


class CRegTreeItemBase : public IRegTreeItem
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj)
    {
        static const QITAB qit[] =
        {
            QITABENT(CRegTreeItemBase, IRegTreeItem),
            { 0 },
        };

        return QISearch(this, qit, riid, ppvObj);
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef == 0)
        {
            delete this;
            return 0;
        }
        return _cRef;
    }
    STDMETHODIMP GetCheckState(BOOL *pbCheck) PURE;
    STDMETHODIMP SetCheckState(BOOL bCheck) PURE;

    virtual ~CRegTreeItemBase() { }

protected:
    CRegTreeItemBase() : _cRef(1) { }

    ULONG _cRef;
};


class CWebViewRegTreeItem : public CRegTreeItemBase
{
public:
    STDMETHODIMP GetCheckState(BOOL *pbCheck)
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_WEBVIEW, FALSE);
        *pbCheck = BOOLIFY(ss.fWebView);

        return S_OK;
    }

    STDMETHODIMP SetCheckState(BOOL bCheck)
    {
        SHELLSTATE ss;
        ss.fWebView = bCheck;
        SHGetSetSettings(&ss, SSF_WEBVIEW, TRUE);

        return S_OK;
    }

protected:

    friend HRESULT CWebViewRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
};

// aggregation checking is handled in class factory

HRESULT CWebViewRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CWebViewRegTreeItem* pwvi = new CWebViewRegTreeItem();
    if (pwvi)
    {
        hr = pwvi->QueryInterface(riid, ppv);
        pwvi->Release();
    }

    return hr;
}

class CThemesRegTreeItem : public CRegTreeItemBase
{
    CThemesRegTreeItem() { m_fVisualStyleOn = 2;}
    
public:
    STDMETHODIMP GetCheckState(BOOL *pbCheck)
    {
        // We want to return TRUE if the visual style has a path.
        IThemeManager * pThemeManager;
        HRESULT hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeManager, &pThemeManager));

        *pbCheck = FALSE;
        if (SUCCEEDED(hr))
        {
            IThemeScheme * pThemeScheme;

            hr = pThemeManager->get_SelectedScheme(&pThemeScheme);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrPathSelected;

                // This will return failure if no "Visual Style" is selected.
                if (SUCCEEDED(pThemeScheme->get_Path(&bstrPathSelected)) &&
                    bstrPathSelected && bstrPathSelected[0])
                {
                    *pbCheck = TRUE;
                }

                pThemeScheme->Release();
            }

            pThemeManager->Release();
        }

        m_fVisualStyleOn = *pbCheck;
        return hr;
    }


    STDMETHODIMP SetCheckState(BOOL bCheck)
    {
        HRESULT hr = S_OK;

        if (2 == m_fVisualStyleOn)
        {
            GetCheckState(&m_fVisualStyleOn);
        }

        // The user will loose settings when visual styles are switch so
        // only do it if the user made a change.
        if (bCheck != m_fVisualStyleOn)
        {
            IThemeManager * pThemeManager;

            hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeManager, &pThemeManager));
            if (SUCCEEDED(hr))
            {
                IThemeScheme * pThemeSchemeNew;
                IThemeStyle * pThemeColorNew;
                IThemeSize * pThemeSizeNew;

                hr = pThemeManager->GetSpecialScheme((bCheck ? SZ_SSDEFAULVISUALSTYLEON : SZ_SSDEFAULVISUALSTYLEOFF), &pThemeSchemeNew, &pThemeColorNew, &pThemeSizeNew);
                if (SUCCEEDED(hr))
                {
                    hr = pThemeColorNew->put_SelectedSize(pThemeSizeNew);
                    if (SUCCEEDED(hr))
                    {
                        hr = pThemeSchemeNew->put_SelectedStyle(pThemeColorNew);
                        if (SUCCEEDED(hr))
                        {
                            hr = pThemeManager->put_SelectedScheme(pThemeSchemeNew);
                            if (SUCCEEDED(hr))
                            {
                                // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
                                // to broadcast the message to all open apps.  If a top level window is hung, it may take the
                                // full 30 seconds to timeout.  This code may want to move this code onto a background thread.
                                hr = pThemeManager->ApplyNow();
                            }
                        }
                    }

                    pThemeSchemeNew->Release();
                    pThemeColorNew->Release();
                    pThemeSizeNew->Release();
                }

                pThemeManager->Release();
            }
        }

        return hr;
    }

protected:
    friend HRESULT CThemesRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);

private:
    BOOL    m_fVisualStyleOn;
};

HRESULT CThemesRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CThemesRegTreeItem* pti = new CThemesRegTreeItem();
    if (pti)
    {
        hr = pti->QueryInterface(riid, ppv);
        pti->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SHELL2.RC
//
#define CTLWID                          60

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\regsuprt.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "regsuprt.h"

#ifdef DEBUG
UINT CRegSupport::_cRefHKEY = 0;
UINT CRegSupport::_cRefExternalHKEY = 0;
#endif

void CRegSupport::RSInitRoot(HKEY hkey, LPCTSTR pszSubKey1, LPCTSTR pszSubKey2,
        DWORD dwRootOptions, DWORD dwDefaultOptions)
{
    _dwRootOptions = dwRootOptions; 
    _dwDefaultOptions = dwDefaultOptions;
    
    _hkeyInit = hkey;

    _InitSetRoot(pszSubKey1, pszSubKey2);

#ifdef DEBUG
    ASSERT(!_fInited);

    _fInited = TRUE;
#endif
}

BOOL CRegSupport::RSSubKeyExist(LPCTSTR pszSubKey)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        fRet = TRUE;
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        fRet = (RegQueryValueEx(hkeySubKey, pszValueName, 0, NULL, NULL, NULL) ==
            ERROR_SUCCESS);

        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegDeleteValue(hkeySubKey, pszValueName))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSDeleteKey()
{
    BOOL bRet = FALSE;
    TCHAR szRoot[MAX_ROOT];

    if (_hkeyInit)
    {
        if (SHDeleteKey(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot))) == ERROR_SUCCESS)
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL CRegSupport::RSDeleteSubKey(LPCTSTR pszSubKey)
{
    BOOL fRet = FALSE;

    _EnterCSKeyRoot();

    HKEY hkey = _GetRootKey(FALSE);

    if (hkey)
    {
        if (ERROR_SUCCESS == SHDeleteKey(hkey, pszSubKey))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSSetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD cb,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, pb, cb, REG_BINARY, dwOptions);
}

BOOL CRegSupport::RSSetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               LPCTSTR pszValue,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, (PBYTE)pszValue,
        (lstrlen(pszValue) + 1) * sizeof(TCHAR), REG_SZ, dwOptions);
}

BOOL CRegSupport::RSSetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               DWORD dwValue,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, (PBYTE)&dwValue, 
        sizeof(DWORD), REG_DWORD, dwOptions);
}

BOOL CRegSupport::RSGetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD* pcb)
{
    return _GetGeneric(pszSubKey, pszValueName, pb, pcb);
}

BOOL CRegSupport::RSGetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                LPTSTR pszValue, DWORD* pcchValue)
{
    DWORD cbData = *pcchValue * sizeof(TCHAR);

    return _GetGeneric(pszSubKey, pszValueName, (PBYTE)pszValue, &cbData);
}

BOOL CRegSupport::RSGetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD* pdwValue)
{
    DWORD cbData = sizeof(DWORD);

    return _GetGeneric(pszSubKey, pszValueName, (PBYTE)pdwValue, &cbData);
}

BOOL CRegSupport::_SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD cb, DWORD dwType,
                                DWORD dwOptions)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, TRUE, dwOptions);
    else
        hkeySubKey = _GetRootKey(TRUE, dwOptions);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkeySubKey, pszValueName, 0, 
            dwType, pb, cb))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::_GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD* pcb)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == SHQueryValueEx(hkeySubKey, pszValueName, 0, 
            NULL, pb, pcb))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

HKEY CRegSupport::RSDuplicateRootKey()
{
    RIP(_fInited);
#ifdef DEBUG
    // we need to decrement here since it will be icnremented inside this fct
    // and the key will not be close by this object
    --_cRefHKEY;
    ++_cRefExternalHKEY;
#endif
    TCHAR szRoot[MAX_ROOT];

    return _RegCreateKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)), _dwRootOptions);
}

HKEY CRegSupport::RSDuplicateSubKey(LPCTSTR pszSubKey, BOOL fCreate, BOOL fVolatile)
{
    return _GetSubKey(pszSubKey, fCreate, fVolatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE);
}

HKEY CRegSupport::_GetRootKey(BOOL fCreate, DWORD dwOptions)
{
    RIP(_fInited);

    HKEY hkey;
    TCHAR szRoot[MAX_ROOT];

    if (REG_OPTION_INVALID == dwOptions)
        dwOptions = _dwRootOptions;

    if (fCreate)
        hkey = _RegCreateKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)), dwOptions);
    else
        hkey = _RegOpenKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)));

    return hkey;
}

void CRegSupport::_CloseRegSubKey(HKEY hkeySubKey)
{
    RegCloseKey(hkeySubKey);

#ifdef DEBUG
    --_cRefHKEY;
#endif
}

// Always need to be called from within the _csRootKey critical section (when critical section
// stuff is enabled)

HKEY CRegSupport::_GetSubKey(LPCTSTR pszSubKey, BOOL fCreate, DWORD dwOptions)
{
    HKEY hkey = NULL;

    HKEY hRootKey = _GetRootKey(fCreate, dwOptions);

    if (REG_OPTION_INVALID == dwOptions)
        dwOptions = _dwDefaultOptions;

    if (hRootKey)
    {
        if (fCreate)
            hkey = _RegCreateKeyExHelper(hRootKey, pszSubKey, dwOptions);
        else
            hkey = _RegOpenKeyExHelper(hRootKey, pszSubKey);

        _CloseRegSubKey(hRootKey);
    }

    return hkey;
}

//static
HKEY CRegSupport::_RegCreateKeyExHelper(HKEY hkey, LPCTSTR pszSubKey, DWORD dwOptions)
{
    HKEY hkeyTmp;
    DWORD dwDisp;

    ASSERT(REG_OPTION_INVALID != dwOptions);

    if (ERROR_SUCCESS != RegCreateKeyEx(hkey, pszSubKey, 0, NULL, 
        dwOptions, MAXIMUM_ALLOWED, NULL, &hkeyTmp, &dwDisp))
    {
        hkeyTmp = NULL;
    }
#ifdef DEBUG
    else
    {
        ++_cRefHKEY;
    }
#endif

    return hkeyTmp;
}

//static
HKEY CRegSupport::_RegOpenKeyExHelper(HKEY hkey, LPCTSTR pszSubKey)
{
    HKEY hkeyTmp;

    if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0,
        MAXIMUM_ALLOWED, &hkeyTmp))
    {
        hkeyTmp = NULL;
    }
#ifdef DEBUG
    else
    {
        ++_cRefHKEY;
    }
#endif

    return hkeyTmp;
}

BOOL CRegSupport::_InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2)
{
    _pszSubKey1 = pszSubKey1;
    _pszSubKey2 = pszSubKey2;

    return TRUE;
}

LPCTSTR CRegSupport::_GetRoot(LPTSTR pszRoot, DWORD cchRoot)
{
    ASSERT(cchRoot > 0);
    LPTSTR pszNext;
    size_t cchLeft;
    HRESULT hr;

    hr = StringCchCopyEx(pszRoot, cchRoot, _pszSubKey1, &pszNext, &cchLeft, 0);

    if (SUCCEEDED(hr))
    {
        if (_pszSubKey2)
        {
            hr = StringCchCopyEx(pszNext, cchLeft, TEXT("\\"), &pszNext, &cchLeft, 0);

            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(pszNext, cchLeft, _pszSubKey2);
            }
        }
    }

    if (FAILED(hr))
    {
        *pszRoot = 0;
    }

    return pszRoot;
}

void CRegSupport::_EnterCSKeyRoot()
{
    if (_fcsKeyRoot)
    {
        EnterCriticalSection(&_csKeyRoot);
    }
}

void CRegSupport::_LeaveCSKeyRoot()
{
    if (_fcsKeyRoot)
    {
        LeaveCriticalSection(&_csKeyRoot);
    }
}

CRegSupport::CRegSupport() : _hkeyInit(NULL)
{}

CRegSupport::~CRegSupport()
{
    if (_fcsKeyRoot)
    {
        DeleteCriticalSection(&_csKeyRoot);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\rundlg.cpp ===
#include "shellprv.h"
#include <regstr.h>
#include <shellp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include "lvutil.h"
#include "idlcomm.h"
#include "filetbl.h"
#include "undo.h"
#include "cnctnpt.h"

BOOL g_bCheckRunInSep = FALSE;
HANDLE g_hCheckNow = NULL;
HANDLE h_hRunDlgCS = NULL;

const TCHAR c_szRunMRU[] = REGSTR_PATH_EXPLORER TEXT("\\RunMRU");
const TCHAR c_szRunDlgReady[] = TEXT("MSShellRunDlgReady");
const TCHAR c_szWaitingThreadID[] = TEXT("WaitingThreadID");

BOOL RunDlgNotifyParent(HWND hDlg, HWND hwnd, LPTSTR pszCmd, LPCTSTR pszWorkingDir);
void ExchangeWindowPos(HWND hwnd0, HWND hwnd1);

#define WM_SETUPAUTOCOMPLETE (WM_APP)

// implements the Dialog that can navigate through the Shell Name Space and ShellExec() commands.
class CRunDlg : public IDropTarget
{
public:
    CRunDlg();

    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);

    // *** IDropTarget methods ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);


private:
    ~CRunDlg(void);        // This is now an OLE Object and cannot be used as a normal Class.

    BOOL OKPushed(void);
    void ExitRunDlg(BOOL bOK);
    void InitRunDlg(HWND hDlg);
    void InitRunDlg2(HWND hDlg);
    void BrowsePushed(void);

    friend DWORD CALLBACK CheckRunInSeparateThreadProc(void *pv);
    friend BOOL_PTR CALLBACK RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend WINAPI RunFileDlg(HWND hwndParent, HICON hIcon, LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
        LPCTSTR pszPrompt, DWORD dwFlags);

    LONG            m_cRef;

    HWND            m_hDlg;

    // parameters
    HICON           m_hIcon;
    LPCTSTR         m_pszWorkingDir;
    LPCTSTR         m_pszTitle;
    LPCTSTR         m_pszPrompt;
    DWORD           m_dwFlags;
    HANDLE          m_hEventReady;
    DWORD           m_dwThreadId;

    BOOL            _fDone : 1;
    BOOL            _fAutoCompInitialized : 1;
    BOOL            _fOleInited : 1;
};


// optimistic cache for this
HANDLE g_hMRURunDlg = NULL;

HANDLE OpenRunDlgMRU()
{
    HANDLE hmru = InterlockedExchangePointer(&g_hMRURunDlg, NULL);
    if (hmru == NULL)
    {
        MRUINFO mi =  {
            sizeof(MRUINFO),
            26,
            MRU_CACHEWRITE,
            HKEY_CURRENT_USER,
            c_szRunMRU,
            NULL        // NOTE: use default string compare
                        // since this is a GLOBAL MRU
        } ;
        hmru = CreateMRUList(&mi);
    }
    return hmru;
}

void CloseRunDlgMRU(HANDLE hmru)
{
    hmru = InterlockedExchangePointer(&g_hMRURunDlg, hmru);
    if (hmru)
        FreeMRUList(hmru);  // race, destroy copy
}

STDAPI_(void) FlushRunDlgMRU(void)
{
    CloseRunDlgMRU(NULL);
}

HRESULT CRunDlg_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return E_FAIL;

    *ppv = NULL;
    CRunDlg * p = new CRunDlg();
    if (p) 
    {
    	*ppv = SAFECAST(p, IDropTarget *);
	    return S_OK;
    }

    return E_OUTOFMEMORY;
}

CRunDlg::CRunDlg() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // ASSERT that all Member Variables are inited to Zero.
    ASSERT(!m_hDlg);
    ASSERT(!m_hIcon);
    ASSERT(!m_pszWorkingDir);
    ASSERT(!m_pszTitle);
    ASSERT(!m_pszPrompt);
    ASSERT(!m_dwFlags);
    ASSERT(!m_hEventReady);
    ASSERT(!_fDone);
    ASSERT(!m_dwThreadId);
}

CRunDlg::~CRunDlg()
{
}

// IUnknown
HRESULT CRunDlg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CRunDlg, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CRunDlg::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CRunDlg::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDropTarget

STDMETHODIMP CRunDlg::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DAD_DragEnterEx3(m_hDlg, ptl, pdtobj);
    *pdwEffect &= DROPEFFECT_LINK | DROPEFFECT_COPY;
    return S_OK;
}

STDMETHODIMP CRunDlg::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DAD_DragMoveEx(m_hDlg, ptl);
    *pdwEffect &= DROPEFFECT_LINK | DROPEFFECT_COPY;
    return S_OK;
}

STDMETHODIMP CRunDlg::DragLeave(void)
{
    DAD_DragLeave();
    return S_OK;
}

typedef struct {
    HRESULT (*pfnGetData)(STGMEDIUM *, LPTSTR pszFile);
    FORMATETC fmte;
} DATA_HANDLER;

HRESULT _GetHDROPFromData(STGMEDIUM *pmedium, LPTSTR pszPath)
{
    return DragQueryFile((HDROP)pmedium->hGlobal, 0, pszPath, MAX_PATH) ? S_OK : E_FAIL;
}

HRESULT _GetText(STGMEDIUM *pmedium, LPTSTR pszPath)
{
    LPCSTR psz = (LPCSTR)GlobalLock(pmedium->hGlobal);
    if (psz)
    {
        SHAnsiToTChar(psz, pszPath, MAX_PATH);
        GlobalUnlock(pmedium->hGlobal);
        return S_OK;
    }
    return E_FAIL;
}

HRESULT _GetUnicodeText(STGMEDIUM *pmedium, LPTSTR pszPath)
{
    LPCWSTR pwsz = (LPCWSTR)GlobalLock(pmedium->hGlobal);
    if (pwsz)
    {
        SHUnicodeToTChar(pwsz, pszPath, MAX_PATH);
        GlobalUnlock(pmedium->hGlobal);
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CRunDlg::Drop(IDataObject * pdtobj, DWORD grfKeyState, 
                           POINTL pt, DWORD *pdwEffect)
{
    TCHAR szPath[MAX_PATH];

    DAD_DragLeave();

    szPath[0] = 0;

    DATA_HANDLER rg_data_handlers[] = {
        _GetHDROPFromData,  {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        _GetUnicodeText,    {CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        _GetText,           {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        _GetText,           {CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    IEnumFORMATETC *penum;

    if (SUCCEEDED(pdtobj->EnumFormatEtc(DATADIR_GET, &penum)))
    {
        FORMATETC fmte;
        while (penum->Next(1, &fmte, NULL) == S_OK)
        {
            SHFree(fmte.ptd);
            fmte.ptd = NULL; // so nobody will look at it
            for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
            {
                STGMEDIUM medium;
                if ((rg_data_handlers[i].fmte.cfFormat == fmte.cfFormat) && 
                    SUCCEEDED(pdtobj->GetData(&rg_data_handlers[i].fmte, &medium)))
                {
                    HRESULT hres = rg_data_handlers[i].pfnGetData(&medium, szPath);
                    ReleaseStgMedium(&medium);

                    if (SUCCEEDED(hres))
                        goto Done;
                }
            }
        }
Done:
        penum->Release();
    }

    if (szPath[0])
    {
        TCHAR szText[MAX_PATH + MAX_PATH];

        GetDlgItemText(m_hDlg, IDD_COMMAND, szText, ARRAYSIZE(szText) - ARRAYSIZE(szPath));
        if (szText[0])
            StrCatBuff(szText, c_szSpace, ARRAYSIZE(szText));

        if (StrChr(szPath, TEXT(' '))) 
            PathQuoteSpaces(szPath);    // there's a space in the file... add qutoes

        StrCatBuff(szText, szPath, ARRAYSIZE(szText));

        SetDlgItemText(m_hDlg, IDD_COMMAND, szText);
        EnableOKButtonFromID(m_hDlg, IDD_COMMAND);

        if (g_hCheckNow)
            SetEvent(g_hCheckNow);

        *pdwEffect &= DROPEFFECT_COPY | DROPEFFECT_LINK;
    }
    else
        *pdwEffect = 0;

    return S_OK;
}


BOOL PromptForMedia(HWND hwnd, LPCTSTR pszPath)
{
    BOOL fContinue = TRUE;
    TCHAR szPathTemp[MAX_URL_STRING];
    
    StrCpyN(szPathTemp, pszPath, ARRAYSIZE(szPathTemp));
    PathRemoveArgs(szPathTemp);
    PathUnquoteSpaces(szPathTemp);

    // We only want to check for media if it's a drive path
    // because the Start->Run dialog can receive all kinds of
    // wacky stuff. (Relative paths, URLs, App Path exes, 
    // any shell exec hooks, etc.)
    if (-1 != PathGetDriveNumber(szPathTemp))
    {
        if (FAILED(SHPathPrepareForWrite(hwnd, NULL, szPathTemp, SHPPFW_IGNOREFILENAME)))
            fContinue = FALSE;      // User decliened to insert or format media.
    }

    return fContinue;
}

BOOL CRunDlg::OKPushed(void)
{
    TCHAR szText[MAX_PATH];
    BOOL fSuccess = FALSE;
    TCHAR szNotExp[MAX_PATH + 2];

    if (_fDone)
        return TRUE;

    // Get out of the "synchronized input queues" state
    if (m_dwThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), m_dwThreadId, FALSE);
    }

    // Get the command line and dialog title, leave some room for the slash on the end
    GetDlgItemText(m_hDlg, IDD_COMMAND, szNotExp, ARRAYSIZE(szNotExp) - 2);
    PathRemoveBlanks(szNotExp);

    // This used to happen only on NT, do it everywhere:
    SHExpandEnvironmentStrings(szNotExp, szText, ARRAYSIZE(szText));

    // We will go ahead if this isn't a file path.  If it is, we
    if (PromptForMedia(m_hDlg, szText))
    {
        TCHAR szTitle[64];
        GetWindowText(m_hDlg, szTitle, ARRAYSIZE(szTitle));

        // Hide this dialog (REVIEW, to avoid save bits window flash)
        SetWindowPos(m_hDlg, 0, 0, 0, 0, 0, SWP_HIDEWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);

        //
        // HACK: We need to activate the owner window before we call
        //  ShellexecCmdLine, so that our folder DDE code can find an
        //  explorer window as the ForegroundWindow.
        //
        HWND hwndOwner = GetWindow(m_hDlg, GW_OWNER);
        if (hwndOwner)
        {
            SetActiveWindow(hwndOwner);
        }
        else
        {
            hwndOwner = m_hDlg;
        }

        int iRun = RunDlgNotifyParent(m_hDlg, hwndOwner, szText, m_pszWorkingDir);
        switch (iRun)
        {
        case RFR_NOTHANDLED:
            {
                DWORD dwFlags;
                if (m_dwFlags & RFD_USEFULLPATHDIR)
                {
                    dwFlags = SECL_USEFULLPATHDIR;
                }
                else
                {
                    dwFlags = 0;
                }

                if ((!(m_dwFlags & RFD_NOSEPMEMORY_BOX)) && (m_dwFlags & RFD_WOW_APP))
                {
                    if (IsDlgButtonChecked(m_hDlg, IDD_RUNINSEPARATE) == 1)
                    {
                        if (IsDlgButtonChecked(m_hDlg, IDD_RUNINSEPARATE ) == 1 )
                        {
                            dwFlags |= SECL_SEPARATE_VDM;
                        }
                    }
                }

                dwFlags |= SECL_LOG_USAGE;
                fSuccess = ShellExecCmdLine(hwndOwner, szText, m_pszWorkingDir, SW_SHOWNORMAL, szTitle, dwFlags);
            }
            break;

        case RFR_SUCCESS:
            fSuccess = TRUE;
            break;

        case RFR_FAILURE:
            fSuccess = FALSE;
            break;
        }
    }

    // Get back into "synchronized input queues" state
    if (m_dwThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), m_dwThreadId, TRUE);
    }

    if (fSuccess)
    {
        HANDLE hmru = OpenRunDlgMRU();
        if (hmru)
        {
            // NB the old MRU format has a slash and the show cmd on the end
            // we need to maintain that so we don't end up with garbage on
            // the end of the line
            StrCatBuff(szNotExp, TEXT("\\1"), ARRAYSIZE(szNotExp));
            AddMRUString(hmru, szNotExp);

            CloseRunDlgMRU(hmru);
        }
        return TRUE;
    }

    // Something went wrong. Put the dialog back up.
    SetWindowPos(m_hDlg, 0, 0, 0, 0, 0, SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
    if (!SetForegroundWindow(m_hDlg))
    {
        // HACKHACK:
        // If ShellHook is working on, SetForegroundWindow() can failed to
        // bring RunDlg to foreground window. To force focus to RunDlg, wait
        // a second and retry SetForegroundWindow() again.
        SHWaitForSendMessageThread(GetCurrentThread(), 300);
        SetForegroundWindow(m_hDlg);
    }
    SetFocus(GetDlgItem(m_hDlg, IDD_COMMAND));
    return FALSE;
}


void CRunDlg::ExitRunDlg(BOOL bOK)
{
    if (!_fDone) 
    {
        if (_fOleInited)
        {
            // Need to call oleinit/uninit, because if anyone else does it down the line,
            // and theirs is the last OleUninit, that will NULL out the clipboard hwnd, which
            // is what RevokeDragDrop uses to determine if it is being called on the same
            // thread as RegisterDragDrop.  If the clipboard hwnd is NULL and therefore not
            // equal to the original, and it therefore thinks we're on a different thread,
            // it will bail, and thus won't release it's ref to CRunDlg ... leak!
            RevokeDragDrop(m_hDlg);
            OleUninitialize();
        }
        _fDone = TRUE;
    }

    if (!(m_dwFlags & RFD_NOSEPMEMORY_BOX))
    {
        g_bCheckRunInSep = FALSE;
        SetEvent(g_hCheckNow);
    }

    EndDialog(m_hDlg, bOK);
}


void CRunDlg::InitRunDlg(HWND hDlg)
{
    HWND hCB;

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)this);

    if (m_pszTitle)
        SetWindowText(hDlg, m_pszTitle);

    if (m_pszPrompt)
        SetDlgItemText(hDlg, IDD_PROMPT, m_pszPrompt);

    if (m_hIcon)
        Static_SetIcon(GetDlgItem(hDlg, IDD_ICON), m_hIcon);

    if (m_dwFlags & RFD_NOBROWSE)
    {
        HWND hBrowse = GetDlgItem(hDlg, IDD_BROWSE);

        ExchangeWindowPos(hBrowse, GetDlgItem(hDlg, IDCANCEL));
        ExchangeWindowPos(hBrowse, GetDlgItem(hDlg, IDOK));

        ShowWindow(hBrowse, SW_HIDE);
    }

    if (m_dwFlags & RFD_NOSHOWOPEN)
        ShowWindow(GetDlgItem(hDlg, IDD_RUNDLGOPENPROMPT), SW_HIDE);

    hCB = GetDlgItem(hDlg, IDD_COMMAND);
    SendMessage(hCB, CB_LIMITTEXT, MAX_PATH - 1, 0L);

    HANDLE hmru = OpenRunDlgMRU();
    if (hmru)
    {
        for (int nMax = EnumMRUList(hmru, -1, NULL, 0), i=0; i<nMax; ++i)
        {
            TCHAR szCommand[MAX_PATH + 2];
            if (EnumMRUList(hmru, i, szCommand, ARRAYSIZE(szCommand)) > 0)
            {
                // old MRU format has a slash at the end with the show cmd
                LPTSTR pszField = StrRChr(szCommand, NULL, TEXT('\\'));
                if (pszField)
                    *pszField = 0;

                // The command to run goes in the combobox.
                SendMessage(hCB, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szCommand);
            }
        }
        CloseRunDlgMRU(hmru);
    }

    if (!(m_dwFlags & RFD_NODEFFILE))
        SendMessage(hCB, CB_SETCURSEL, 0, 0L);

    SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDD_COMMAND, CBN_SELCHANGE), (LPARAM) hCB);

    // Make sure the OK button is initialized properly
    EnableOKButtonFromID(hDlg, IDD_COMMAND);

    // Create the thread that will take care of the
    // "Run in Separate Memory Space" checkbox in the background.
    //
    if (m_dwFlags & RFD_NOSEPMEMORY_BOX)
    {
        ShowWindow(GetDlgItem(hDlg, IDD_RUNINSEPARATE), SW_HIDE);
    }
    else
    {
        HANDLE hThread = NULL;
        ASSERT(g_hCheckNow == NULL);
        g_hCheckNow = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (g_hCheckNow) 
        {
            DWORD dwDummy;
            g_bCheckRunInSep = TRUE;
            hThread = CreateThread(NULL, 0, CheckRunInSeparateThreadProc, hDlg, 0, &dwDummy);
        }

        if ((g_hCheckNow==NULL) || (!g_bCheckRunInSep) || (hThread==NULL)) 
        {
            // We've encountered a problem setting up, so make the user
            // choose.
            CheckDlgButton(hDlg, IDD_RUNINSEPARATE, 1);
            EnableWindow(GetDlgItem(hDlg, IDD_RUNINSEPARATE), TRUE);
            g_bCheckRunInSep = FALSE;
        }

        //
        // These calls will just do nothing if either handle is NULL.
        //
        if (hThread)
            CloseHandle(hThread);
        if (g_hCheckNow)
            SetEvent(g_hCheckNow);
    }
}

//
// InitRunDlg 2nd phase. It must be called after freeing parent thread.
//
void CRunDlg::InitRunDlg2(HWND hDlg)
{
    // Register ourselves as a drop target. Allow people to drop on
    // both the dlg box and edit control.
    _fOleInited = SUCCEEDED(OleInitialize(NULL));

    if (_fOleInited)
    {
        RegisterDragDrop(hDlg, SAFECAST(this, IDropTarget*));
    }
}


void CRunDlg::BrowsePushed(void)
{
    HWND hDlg = m_hDlg;
    TCHAR szText[MAX_PATH];

    // Get out of the "synchronized input queues" state
    if (m_dwThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), m_dwThreadId, FALSE);
        m_dwThreadId = 0;
    }

    GetDlgItemText(hDlg, IDD_COMMAND, szText, ARRAYSIZE(szText));
    PathUnquoteSpaces(szText);

    if (GetFileNameFromBrowse(hDlg, szText, ARRAYSIZE(szText), m_pszWorkingDir,
            MAKEINTRESOURCE(IDS_EXE), MAKEINTRESOURCE(IDS_PROGRAMSFILTER),
            MAKEINTRESOURCE(IDS_BROWSE)))
    {
        PathQuoteSpaces(szText);
        SetDlgItemText(hDlg, IDD_COMMAND, szText);
        EnableOKButtonFromID(hDlg, IDD_COMMAND);
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
    }
}


// Use the common browse dialog to get a filename.
// The working directory of the common dialog will be set to the directory
// part of the file path if it is more than just a filename.
// If the filepath consists of just a filename then the working directory
// will be used.
// The full path to the selected file will be returned in szFilePath.
//    HWND hDlg,           // Owner for browse dialog.
//    LPSTR szFilePath,    // Path to file
//    UINT cchFilePath,     // Max length of file path buffer.
//    LPSTR szWorkingDir,  // Working directory
//    LPSTR szDefExt,      // Default extension to use if the user doesn't
//                         // specify enter one.
//    LPSTR szFilters,     // Filter string.
//    LPSTR szTitle        // Title for dialog.

STDAPI_(BOOL) _GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cbFilePath,
                                       LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle,
                                       DWORD dwFlags)
{
    TCHAR szBrowserDir[MAX_PATH];      // Directory to start browsing from.
    TCHAR szFilterBuf[MAX_PATH];       // if szFilters is MAKEINTRESOURCE
    TCHAR szDefExtBuf[10];             // if szDefExt is MAKEINTRESOURCE
    TCHAR szTitleBuf[64];              // if szTitleBuf is MAKEINTRESOURCE

    szBrowserDir[0] = TEXT('0'); // By default use CWD.

    // Set up info for browser.
    StrCpyN(szBrowserDir, szFilePath, ARRAYSIZE(szBrowserDir));
    PathRemoveArgs(szBrowserDir);
    PathRemoveFileSpec(szBrowserDir);

    if (*szBrowserDir == TEXT('\0') && szWorkingDir)
    {
        StrCpyN(szBrowserDir, szWorkingDir, ARRAYSIZE(szBrowserDir));
    }

    // Stomp on the file path so that the dialog doesn't
    // try to use it to initialise the dialog. The result is put
    // in here.
    szFilePath[0] = TEXT('\0');

    // Set up szDefExt
    if (IS_INTRESOURCE(szDefExt))
    {
        LoadString(HINST_THISDLL, (UINT)LOWORD((DWORD_PTR)szDefExt), szDefExtBuf, ARRAYSIZE(szDefExtBuf));
        szDefExt = szDefExtBuf;
    }

    // Set up szFilters
    if (IS_INTRESOURCE(szFilters))
    {
        LPTSTR psz;

        LoadString(HINST_THISDLL, (UINT)LOWORD((DWORD_PTR)szFilters), szFilterBuf, ARRAYSIZE(szFilterBuf));
        psz = szFilterBuf;
        while (*psz)
        {
            if (*psz == TEXT('#'))
#if (defined(DBCS) || (defined(FE_SB) && !defined(UNICODE)))
                *psz++ = TEXT('\0');
            else
                psz = CharNext(psz);
#else
            *psz = TEXT('\0');
            psz = CharNext(psz);
#endif
        }
        szFilters = szFilterBuf;
    }

    // Set up szTitle
    if (IS_INTRESOURCE(szTitle))
    {
        LoadString(HINST_THISDLL, (UINT)LOWORD((DWORD_PTR)szTitle), szTitleBuf, ARRAYSIZE(szTitleBuf));
        szTitle = szTitleBuf;
    }

    OPENFILENAME ofn = { 0 };          // Structure used to init dialog.
    // Setup info for comm dialog.
    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    ofn.nMaxCustFilter    = 0;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = cbFilePath;
    ofn.lpstrInitialDir   = szBrowserDir;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = dwFlags;
    ofn.lpfnHook          = NULL;
    ofn.lpstrDefExt       = szDefExt;
    ofn.lpstrFileTitle    = NULL;

    // Call it.
    return GetOpenFileName(&ofn);
}


BOOL WINAPI GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
        LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle)
{
    RIPMSG(szFilePath && IS_VALID_WRITE_BUFFER(szFilePath, TCHAR, cchFilePath), "GetFileNameFromBrowse: caller passed bad szFilePath");
    DEBUGWhackPathBuffer(szFilePath , cchFilePath);
    if (!szFilePath)
        return FALSE;

    return _GetFileNameFromBrowse(hwnd, szFilePath, cchFilePath,
                                 szWorkingDir, szDefExt, szFilters, szTitle,
                                 OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR | OFN_NODEREFERENCELINKS);
}


//
// Do checking of the .exe type in the background so the UI doesn't
// get hung up while we scan.  This is particularly important with
// the .exe is over the network or on a floppy.
//
DWORD CALLBACK CheckRunInSeparateThreadProc(void *pv)
{
    DWORD dwBinaryType;
    DWORD cch;
    LPTSTR pszFilePart;
    TCHAR szFile[MAX_PATH+1];
    TCHAR szFullFile[MAX_PATH+1];
    TCHAR szExp[MAX_PATH+1];
    HWND hDlg = (HWND)pv;
    BOOL fCheck = TRUE, fEnable = FALSE;

    HRESULT hrInit = SHCoInitialize();

    // PERF: Re-write to use PIDL from CShellUrl because it will prevent from having
    //         to do the Search for the file name a second time.

    DebugMsg(DM_TRACE, TEXT("CheckRunInSeparateThreadProc created and running"));

    while (g_bCheckRunInSep)
    {
        WaitForSingleObject(g_hCheckNow, INFINITE);
        ResetEvent(g_hCheckNow);

        if (g_bCheckRunInSep)
        {
            CRunDlg * prd;
            LPTSTR pszT;
            BOOL f16bit = FALSE;

            szFile[0] = 0;
            szFullFile[0] = 0;
            cch = 0;
            GetWindowText(GetDlgItem(hDlg, IDD_COMMAND), szFile, ARRAYSIZE(szFile));
            // Remove & throw away arguments
            PathRemoveBlanks(szFile);

            if (PathIsNetworkPath(szFile))
            {
                f16bit = TRUE;
                fCheck = FALSE;
                fEnable = TRUE;
                goto ChangeTheBox;
            }

            // if the unquoted string exists as a file, just use it

            if (!PathFileExistsAndAttributes(szFile, NULL))
            {
                pszT = PathGetArgs(szFile);
                if (*pszT)
                    *(pszT - 1) = TEXT('\0');

                PathUnquoteSpaces(szFile);
            }

            if (szFile[0])
            {
                SHExpandEnvironmentStrings(szFile, szExp, ARRAYSIZE(szExp));

                if (PathIsRemote(szExp))
                {
                    f16bit = TRUE;
                    fCheck = FALSE;
                    fEnable = TRUE;
                    goto ChangeTheBox;
                }

                cch = SearchPath(NULL, szExp, TEXT(".EXE"),
                                 ARRAYSIZE(szFullFile), szFullFile, &pszFilePart);
            }

            if ((cch != 0) && (cch <= (ARRAYSIZE(szFullFile) - 1)))
            {
                if ((GetBinaryType(szFullFile, &dwBinaryType) &&
                     (dwBinaryType == SCS_WOW_BINARY)))
                {
                    f16bit = TRUE;
                    fCheck = FALSE;
                    fEnable = TRUE;
                } 
                else 
                {
                    f16bit = FALSE;
                    fCheck = TRUE;
                    fEnable = FALSE;
                }
            } 
            else 
            {
                f16bit = FALSE;
                fCheck = TRUE;
                fEnable = FALSE;
            }

ChangeTheBox:
            CheckDlgButton(hDlg, IDD_RUNINSEPARATE, fCheck ? 1 : 0);
            EnableWindow(GetDlgItem(hDlg, IDD_RUNINSEPARATE), fEnable);

            prd = (CRunDlg *)GetWindowLongPtr(hDlg, DWLP_USER);
            if (prd)
            {
                if (f16bit)
                    prd->m_dwFlags |= RFD_WOW_APP;
                else
                    prd->m_dwFlags &= (~RFD_WOW_APP);
            }
        }
    }
    CloseHandle(g_hCheckNow);
    g_hCheckNow = NULL;

    SHCoUninitialize(hrInit);
    return 0;
}


void ExchangeWindowPos(HWND hwnd0, HWND hwnd1)
{
    HWND hParent;
    RECT rc[2];

    hParent = GetParent(hwnd0);
    ASSERT(hParent == GetParent(hwnd1));

    GetWindowRect(hwnd0, &rc[0]);
    GetWindowRect(hwnd1, &rc[1]);

    MapWindowPoints(HWND_DESKTOP, hParent, (LPPOINT)rc, 4);

    SetWindowPos(hwnd0, NULL, rc[1].left, rc[1].top, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE);
    SetWindowPos(hwnd1, NULL, rc[0].left, rc[0].top, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE);
}

BOOL RunDlgNotifyParent(HWND hDlg, HWND hwnd, LPTSTR pszCmd, LPCTSTR pszWorkingDir)
{
    NMRUNFILE rfn;

    rfn.hdr.hwndFrom = hDlg;
    rfn.hdr.idFrom = 0;
    rfn.hdr.code = RFN_EXECUTE;
    rfn.lpszCmd = pszCmd;
    rfn.lpszWorkingDir = pszWorkingDir;
    rfn.nShowCmd = SW_SHOWNORMAL;

    return (BOOL) SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)&rfn);
}

void MRUSelChange(HWND hDlg)
{
    TCHAR szCmd[MAX_PATH];
    HWND hCB = GetDlgItem(hDlg, IDD_COMMAND);
    int nItem = (int)SendMessage(hCB, CB_GETCURSEL, 0, 0L);
    if (nItem < 0)
        return;

    // CB_LIMITTEXT has been done, so there's no chance of buffer overrun here.
    SendMessage(hCB, CB_GETLBTEXT, nItem, (LPARAM)szCmd);

    // We can't use EnableOKButtonFromID here because when we get this message,
    // the window does not have the text yet, so it will fail.
    EnableOKButtonFromString(hDlg, szCmd);
}

const DWORD aRunHelpIds[] = {
    IDD_ICON,             NO_HELP,
    IDD_PROMPT,           NO_HELP,
    IDD_RUNDLGOPENPROMPT, IDH_TRAY_RUN_COMMAND,
    IDD_COMMAND,          IDH_TRAY_RUN_COMMAND,
    IDD_RUNINSEPARATE,    IDH_TRAY_RUN_SEPMEM,
    IDD_BROWSE,           IDH_BROWSE,
    IDOK,                 IDH_TRAY_RUN_OK,
    IDCANCEL,             IDH_TRAY_RUN_CANCEL,
    0, 0
};

BOOL_PTR CALLBACK RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CRunDlg * prd = (CRunDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        /* The title will be in the lParam. */
        prd = (CRunDlg *)lParam;
        prd->m_hDlg = hDlg;
        prd->_fDone = FALSE;
        prd->InitRunDlg(hDlg);
        // Let the parent thread run on if it was waiting for us to
        // grab type-ahead.
        if (prd->m_hEventReady)
        {
            // We need to grab the activation so we can process input.
            // DebugMsg(DM_TRACE, "s.rdp: Getting activation.");
            SetForegroundWindow(hDlg);
            SetFocus(GetDlgItem(hDlg, IDD_COMMAND));
            // Now it's safe to wake the guy up properly.
            // DebugMsg(DM_TRACE, "s.rdp: Waking sleeping parent.");
            SetEvent(prd->m_hEventReady);
            CloseHandle(prd->m_hEventReady);
        }       
        else
        {
            SetForegroundWindow(hDlg);
            SetFocus(GetDlgItem(hDlg, IDD_COMMAND));
        }

        // InitRunDlg 2nd phase (must be called after SetEvent)
        prd->InitRunDlg2(hDlg);

        // We're handling focus changes.
        return FALSE;

    case WM_PAINT:
        if (!prd->_fAutoCompInitialized)
        {
            prd->_fAutoCompInitialized = TRUE;
            PostMessage(hDlg, WM_SETUPAUTOCOMPLETE, 0, 0);
        }
        return FALSE;

    case WM_SETUPAUTOCOMPLETE:
        SHAutoComplete(GetWindow(GetDlgItem(hDlg, IDD_COMMAND), GW_CHILD), (SHACF_FILESYSTEM | SHACF_URLALL | SHACF_FILESYS_ONLY));
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP,
            (ULONG_PTR) (LPTSTR) aRunHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPTSTR) aRunHelpIds);
        break;

    case WM_DESTROY:
        break;
    case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDHELP:
                break;

            case IDD_COMMAND:
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case CBN_SELCHANGE:
                    MRUSelChange(hDlg);
                    if (g_hCheckNow)
                        SetEvent(g_hCheckNow);
                    break;

                case CBN_EDITCHANGE:
                case CBN_SELENDOK:
                    EnableOKButtonFromID(hDlg, IDD_COMMAND);
                    if (g_hCheckNow)
                        SetEvent(g_hCheckNow);
                    break;

                case CBN_SETFOCUS:

                    SetModeBias(MODEBIASMODE_FILENAME);
                    break;

                case CBN_KILLFOCUS:

                    SetModeBias(MODEBIASMODE_DEFAULT);
                    break;

                }
                break;

            case IDOK:
            // fake an ENTER key press so AutoComplete can do it's thing
            if (SendMessage(GetDlgItem(hDlg, IDD_COMMAND), WM_KEYDOWN, VK_RETURN, 0x1c0001))
            {
                if (!prd->OKPushed()) 
                {
                    if (!(prd->m_dwFlags & RFD_NOSEPMEMORY_BOX))
                    {
                        g_bCheckRunInSep = FALSE;
                        SetEvent(g_hCheckNow);
                    }
                    break;
                }
            }
            else
            {
                break;  // AutoComplete wants more user input
            }
            // fall through

            case IDCANCEL:
                prd->ExitRunDlg(FALSE);
                break;

            case IDD_BROWSE:
                prd->BrowsePushed();
                SetEvent(g_hCheckNow);
                break;

            default:
                return FALSE;
            }
            break;

    default:
        return FALSE;
    }
    return TRUE;
}

// Puts up the standard file.run dialog.
// REVIEW UNDONE This should use a RUNDLG structure for all the various
// options instead of just passing them as parameters, a ptr to the struct
// would be passed to the dialog via the lParam.

STDAPI_(int) RunFileDlg(HWND hwndParent, HICON hIcon, 
                        LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
                        LPCTSTR pszPrompt, DWORD dwFlags)
{
    int rc = 0;

    HRESULT hrInit = SHCoInitialize();

    IDropTarget *pdt;
    if (SUCCEEDED(CRunDlg_CreateInstance(NULL, IID_PPV_ARG(IDropTarget, &pdt))))
    {
        CRunDlg * prd = (CRunDlg *) pdt;

        prd->m_hIcon = hIcon;
        prd->m_pszWorkingDir = pszWorkingDir;
        prd->m_pszTitle = pszTitle;
        prd->m_pszPrompt = pszPrompt;
        prd->m_dwFlags = dwFlags;

        if (SHRestricted(REST_RUNDLGMEMCHECKBOX))
            ClearFlag(prd->m_dwFlags, RFD_NOSEPMEMORY_BOX);
        else
            SetFlag(prd->m_dwFlags, RFD_NOSEPMEMORY_BOX);

        // prd->m_hEventReady = 0;
        // prd->m_dwThreadId = 0;

        // We do this so we can get type-ahead when we're running on a
        // separate thread. The parent thread needs to block to give us time
        // to do the attach and then get some messages out of the queue hence
        // the event.
        if (hwndParent)
        {
            // HACK The parent signals it's waiting for the dialog to grab type-ahead
            // by sticking it's threadId in a property on the parent.
            prd->m_dwThreadId = PtrToUlong(GetProp(hwndParent, c_szWaitingThreadID));
            if (prd->m_dwThreadId)
            {
                // DebugMsg(DM_TRACE, "s.rfd: Attaching input to %x.", idThread);
                AttachThreadInput(GetCurrentThreadId(), prd->m_dwThreadId, TRUE);
                // NB Hack.
                prd->m_hEventReady = OpenEvent(EVENT_ALL_ACCESS, TRUE, c_szRunDlgReady);
            }
        }

        rc = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_RUN), hwndParent,
                            RunDlgProc, (LPARAM)prd);

        if (hwndParent && prd->m_dwThreadId)
        {
            AttachThreadInput(GetCurrentThreadId(), prd->m_dwThreadId, FALSE);
        }

        pdt->Release();
    }

    SHCoUninitialize(hrInit);

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\restart.c ===
#include "shellprv.h"
#pragma  hdrstop

#include <msginaexports.h>
#include <ntddapmt.h>
#include <lmcons.h>     // Username length constant
#include <winsta.h>     // Hydra functions/constants
#include <powrprof.h>

#include "SwitchUserDialog.h"
#include "filetbl.h"

#define DOCKSTATE_DOCKED            0
#define DOCKSTATE_UNDOCKED          1
#define DOCKSTATE_UNKNOWN           2

void FlushRunDlgMRU(void);

// Disconnect API fn-ptr
typedef BOOLEAN (WINAPI *PWINSTATION_DISCONNECT) (HANDLE hServer, ULONG SessionId, BOOL bWait);

// Process all of the strange ExitWindowsEx codes and privileges.
STDAPI_(BOOL) CommonRestart(DWORD dwExitWinCode, DWORD dwReasonCode)
{
    BOOL fOk;
    DWORD dwExtraExitCode = 0;
    DWORD OldState;
    DWORD dwError;

    DebugMsg(DM_TRACE, TEXT("CommonRestart(0x%x, 0x%x)"), dwExitWinCode, dwReasonCode);

    IconCacheSave();

    if ((dwExitWinCode == EWX_SHUTDOWN) && IsPwrShutdownAllowed())
    {
        dwExtraExitCode = EWX_POWEROFF;
    }

    dwError = SetPrivilegeAttribute(SE_SHUTDOWN_NAME, SE_PRIVILEGE_ENABLED, &OldState);

    switch (dwExitWinCode) 
    {
    case EWX_SHUTDOWN:
    case EWX_REBOOT:
    case EWX_LOGOFF:

        if (GetKeyState(VK_CONTROL) < 0)
        {
            dwExtraExitCode |= EWX_FORCE;
        }

        break;
    }

    fOk = ExitWindowsEx(dwExitWinCode | dwExtraExitCode, dwReasonCode);

    // If we were able to set the privilege, then reset it.
    if (dwError == ERROR_SUCCESS)
    {
        SetPrivilegeAttribute(SE_SHUTDOWN_NAME, OldState, NULL);
    }
    else
    {
        // Otherwise, if we failed, then it must have been some
        // security stuff.
        if (!fOk)
        {
            ShellMessageBox(HINST_THISDLL, NULL,
                            dwExitWinCode == EWX_SHUTDOWN ?
                             MAKEINTRESOURCE(IDS_NO_PERMISSION_SHUTDOWN) :
                             MAKEINTRESOURCE(IDS_NO_PERMISSION_RESTART),
                            dwExitWinCode == EWX_SHUTDOWN ?
                             MAKEINTRESOURCE(IDS_SHUTDOWN) :
                             MAKEINTRESOURCE(IDS_RESTART),
                            MB_OK | MB_ICONSTOP);
        }
    }

    DebugMsg(DM_TRACE, TEXT("CommonRestart done"));

    return fOk;
}

void EarlySaveSomeShellState()
{
    // We flush two MRU's here (RecentMRU and RunDlgMRU).
    // Note that they won't flush if there is any reference count.
    
    FlushRunDlgMRU();
}


/*
 * Display a dialog asking the user to restart Windows, with a button that
 * will do it for them if possible.
 */
STDAPI_(int) RestartDialog(HWND hParent, LPCTSTR lpPrompt, DWORD dwReturn)
{
    return RestartDialogEx(hParent, lpPrompt, dwReturn, 0);
}

STDAPI_(int) RestartDialogEx(HWND hParent, LPCTSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode)
{
    UINT id;
    LPCTSTR pszMsg;

    EarlySaveSomeShellState();

    if (lpPrompt && *lpPrompt == TEXT('#'))
    {
        pszMsg = lpPrompt + 1;
    }
    else if (dwReturn == EWX_SHUTDOWN)
    {
        pszMsg = MAKEINTRESOURCE(IDS_RSDLG_SHUTDOWN);
    }
    else
    {
        pszMsg = MAKEINTRESOURCE(IDS_RSDLG_RESTART);
    }

    id = ShellMessageBox(HINST_THISDLL, hParent, pszMsg, MAKEINTRESOURCE(IDS_RSDLG_TITLE),
                MB_YESNO | MB_ICONQUESTION, lpPrompt ? lpPrompt : c_szNULL);

    if (id == IDYES)
    {
        CommonRestart(dwReturn, dwReasonCode);
    }
    return id;
}


BOOL IsShutdownAllowed(void)
{
    return SHTestTokenPrivilege(NULL, SE_SHUTDOWN_NAME);
}

// Determine if "Suspend" should appear in the shutdown dialog.
// Returns: TRUE if Suspend should appear, FALSE if not.

STDAPI_(BOOL) IsSuspendAllowed(void)
{
    //
    // Suspend requires SE_SHUTDOWN_PRIVILEGE
    // Call IsShutdownAllowed() to test for this
    //

    return IsShutdownAllowed() && IsPwrSuspendAllowed();
}

BOOL _LogoffAvailable()
{
    // If dwStartMenuLogoff is zero, then we remove it.
    BOOL fUpgradeFromIE4 = FALSE;
    BOOL fUserWantsLogoff = FALSE;
    DWORD dwStartMenuLogoff = 0;
    TCHAR sz[MAX_PATH];
    DWORD dwRestriction = SHRestricted(REST_STARTMENULOGOFF);

    DWORD cbData = sizeof(dwStartMenuLogoff);

    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, 
                    TEXT("StartMenuLogoff"), NULL, &dwStartMenuLogoff, &cbData))
    {
        fUserWantsLogoff = (dwStartMenuLogoff != 0);
    }

    cbData = ARRAYSIZE(sz);
    if (SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, TEXT("WindowsUpdate"), 
                    TEXT("UpdateURL"), NULL, sz, &cbData)))
    {
        fUpgradeFromIE4 = (sz[0] != TEXT('\0'));
    }

    // Admin is forcing the logoff to be on the menu
    if (dwRestriction == 2)
        return FALSE;

    // The user does wants logoff on the start menu.
    // Or it's an upgrade from IE4
    if ((fUpgradeFromIE4 || fUserWantsLogoff) && dwRestriction != 1)
        return FALSE;

    return TRUE;
}

DWORD GetShutdownOptions()
{
    LONG lResult = ERROR_SUCCESS + 1;
    DWORD dwOptions = SHTDN_SHUTDOWN;

    // No shutdown on terminal server
    if (!GetSystemMetrics(SM_REMOTESESSION))
    {
        dwOptions |= SHTDN_RESTART;
    }

    // Add logoff if supported
    if (_LogoffAvailable())
    {
        dwOptions |= SHTDN_LOGOFF;
    }

    // Add the hibernate option if it's supported.

    if (IsPwrHibernateAllowed())
    {
        dwOptions |= SHTDN_HIBERNATE;
    }

    if (IsSuspendAllowed())
    {
        HKEY hKey;
        DWORD dwAdvSuspend = 0;
        DWORD dwType, dwSize;

        // At least basic sleep is supported
        dwOptions |= SHTDN_SLEEP;

        //
        // Check if we should offer advanced suspend options
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power"),
                         0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwAdvSuspend);
            SHQueryValueEx(hKey, TEXT("Shutdown"), NULL, &dwType,
                                 (LPBYTE) &dwAdvSuspend, &dwSize);

            RegCloseKey(hKey);
        }


        if (dwAdvSuspend != 0)
        {
            dwOptions |= SHTDN_SLEEP2;
        }
    }

    return dwOptions;
}

BOOL_PTR CALLBACK LogoffDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    static BOOL s_fLogoffDialog = FALSE;
    HICON hIcon;

    switch (msg)
    {
    case WM_INITMENUPOPUP:
        EnableMenuItem((HMENU)wparam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        break;

    case WM_INITDIALOG:
        // We could call them when the user actually selects the shutdown,
        // but I put them here to leave the shutdown process faster.
        //
        EarlySaveSomeShellState();

        s_fLogoffDialog = FALSE;
        hIcon = LoadImage (HINST_THISDLL, MAKEINTRESOURCE(IDI_STLOGOFF),
                           IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);

        if (hIcon)
        {
            SendDlgItemMessage (hdlg, IDD_LOGOFFICON, STM_SETICON, (WPARAM) hIcon, 0);
        }
        return TRUE;

    // Blow off moves (only really needed for 32bit land).
    case WM_SYSCOMMAND:
        if ((wparam & ~0x0F) == SC_MOVE)
            return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            s_fLogoffDialog = TRUE;
            EndDialog(hdlg, SHTDN_LOGOFF);
            break;

        case IDCANCEL:
            s_fLogoffDialog = TRUE;
            EndDialog(hdlg, SHTDN_NONE);
            break;

        case IDHELP:
            WinHelp(hdlg, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
            break;
        }
        break;

    case WM_ACTIVATE:
        // If we're loosing the activation for some other reason than
        // the user click OK/CANCEL then bail.
        if (LOWORD(wparam) == WA_INACTIVE && !s_fLogoffDialog)
        {
            s_fLogoffDialog = TRUE;
            EndDialog(hdlg, SHTDN_NONE);
        }
        break;
    }
    return FALSE;
}

//  These dialog procedures more or less mirror the behavior of LogoffDlgProc.

INT_PTR CALLBACK DisconnectDlgProc(HWND hwndDialog, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL s_fIgnoreActivate = FALSE;

    INT_PTR ipResult = FALSE;
    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND | MF_GRAYED);
        break;

    case WM_INITDIALOG:
    {
        HICON   hIcon;

        EarlySaveSomeShellState();
        s_fIgnoreActivate = FALSE;
        hIcon = LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_MU_DISCONN), IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);
        if (hIcon != NULL)
        {
            SendDlgItemMessage(hwndDialog, IDD_DISCONNECTICON, STM_SETICON, (WPARAM)hIcon, 0);
        }
        ipResult = TRUE;
        break;
    }

    case WM_SYSCOMMAND:
        ipResult = ((wParam & ~0x0F) == SC_MOVE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            s_fIgnoreActivate = TRUE;
            TBOOL(EndDialog(hwndDialog, SHTDN_DISCONNECT));
            break;
        case IDCANCEL:
            s_fIgnoreActivate = TRUE;
            TBOOL(EndDialog(hwndDialog, SHTDN_NONE));
            break;
        }
        break;

    case WM_ACTIVATE:
        if ((WA_INACTIVE == LOWORD(wParam)) && !s_fIgnoreActivate)
        {
            s_fIgnoreActivate = TRUE;
            TBOOL(EndDialog(hwndDialog, SHTDN_NONE));
        }
        break;
    }
    return ipResult;
}

BOOL CanDoFastRestart()
{
    return GetAsyncKeyState(VK_SHIFT) < 0;
}

// ---------------------------------------------------------------------------
// Shutdown thread

typedef struct 
{
    DWORD_PTR nCmd;
    HWND hwndParent;
} SDTP_PARAMS;

// Hydra-specific
void Disconnect(void)
{
    TW32(ShellSwitchUser(FALSE));
}

DWORD CALLBACK ShutdownThreadProc(void *pv)
{
    SDTP_PARAMS *psdtp = (SDTP_PARAMS *)pv;

    BOOL fShutdownWorked = FALSE;

    // tell USER that anybody can steal foreground from us
    // This allows apps to put up UI during shutdown/suspend/etc.
    //    AllowSetForegroundWindow(ASFW_ANY);
 
    switch (psdtp->nCmd) 
    {
    case SHTDN_SHUTDOWN:
        fShutdownWorked = CommonRestart(EWX_SHUTDOWN, 0);
        break;

    case SHTDN_RESTART:
        fShutdownWorked = CommonRestart(CanDoFastRestart() ? EW_RESTARTWINDOWS : EWX_REBOOT, 0);
        break;

    case SHTDN_LOGOFF:
        fShutdownWorked = CommonRestart(EWX_LOGOFF, 0);
        break;

    case SHTDN_RESTART_DOS:        // Special hack to mean exit to dos
    case SHTDN_SLEEP:
    case SHTDN_SLEEP2:
    case SHTDN_HIBERNATE:
        SetSuspendState((psdtp->nCmd == SHTDN_HIBERNATE) ? TRUE : FALSE,
                        (GetKeyState(VK_CONTROL) < 0) ? TRUE : FALSE,
                        (psdtp->nCmd == SHTDN_SLEEP2) ? TRUE : FALSE);
        break;
    }

    LocalFree(psdtp);

    return fShutdownWorked;
}

#define DIALOG_LOGOFF       1
#define DIALOG_EXIT         2
#define DIALOG_DISCONNECT   3

void CloseWindowsDialog(HWND hwndParent, int iDialogType)
{
    INT_PTR     nCmd = SHTDN_NONE;
    IUnknown*   pIUnknown;
    HWND        hwndBackground;

    if (FAILED(ShellDimScreen(&pIUnknown, &hwndBackground)))
    {
        pIUnknown = NULL;
        hwndBackground = NULL;
    }

    switch (iDialogType)
    {
        LPCTSTR     pszDialogID;
        DLGPROC     pfnDialogProc;

        case DIALOG_LOGOFF:
        case DIALOG_DISCONNECT:
        {
            if (!GetSystemMetrics(SM_REMOTESESSION) && IsOS(OS_FRIENDLYLOGONUI) && IsOS(OS_FASTUSERSWITCHING))
            {

                //  If not remote with friendly UI and FUS show the licky button dialog.

                nCmd = SwitchUserDialog_Show(hwndBackground);
                pszDialogID = 0;
                pfnDialogProc = NULL;
            }
            else if (iDialogType == DIALOG_LOGOFF)
            {

                //  Otherwise show the Win32 log off dialog if log off.

                pszDialogID = MAKEINTRESOURCE(DLG_LOGOFFWINDOWS);
                pfnDialogProc = LogoffDlgProc;
            }
            else if (iDialogType == DIALOG_DISCONNECT)
            {

                //  Or the Win32 disconnect dialog if disconnect.

                pszDialogID = MAKEINTRESOURCE(DLG_DISCONNECTWINDOWS);
                pfnDialogProc = DisconnectDlgProc;
            }
            else
            {
                ASSERTMSG(FALSE, "Unexpected case hit in CloseWindowsDialog");
            }
            if ((pszDialogID != 0) && (pfnDialogProc != NULL))
            {
                nCmd = DialogBoxParam(HINST_THISDLL, pszDialogID, hwndBackground, pfnDialogProc, 0);
            }
            if (nCmd == SHTDN_DISCONNECT)
            {
                Disconnect();
                nCmd = SHTDN_NONE;
            }
            break;
        }
        case DIALOG_EXIT:
        {
            BOOL fGinaShutdownCalled = FALSE;
            HINSTANCE hGina;

            TCHAR szUsername[UNLEN];
            DWORD cchUsernameLength = UNLEN;
            DWORD dwOptions;

            if (WNetGetUser(NULL, szUsername, &cchUsernameLength) != NO_ERROR)
            {
                szUsername[0] = TEXT('\0');
            }
          
            EarlySaveSomeShellState();

            // Load MSGINA.DLL and get appropriate shutdown function
            hGina = LoadLibrary(TEXT("msgina.dll"));
            if (hGina != NULL)
            {
                if (IsOS(OS_FRIENDLYLOGONUI))
                {
                    nCmd = ShellTurnOffDialog(hwndBackground);
                    fGinaShutdownCalled = TRUE;
                }
                else
                {
                    PFNSHELLSHUTDOWNDIALOG pfnShellShutdownDialog = (PFNSHELLSHUTDOWNDIALOG)
                        GetProcAddress(hGina, "ShellShutdownDialog");

                    if (pfnShellShutdownDialog != NULL)
                    {
                        nCmd = pfnShellShutdownDialog(hwndBackground,
                            szUsername, 0);

                        // Handle disconnect right now
                        if (nCmd == SHTDN_DISCONNECT)
                        {

                            Disconnect();

                            // No other action
                            nCmd = SHTDN_NONE;
                        }

                        fGinaShutdownCalled = TRUE;
                    }
                }
                FreeLibrary(hGina);
            }

            if (!fGinaShutdownCalled)
            {
                dwOptions = GetShutdownOptions();
        
                // Gina call failed; use our cheesy private version
                nCmd = DownlevelShellShutdownDialog(hwndBackground,
                        dwOptions, szUsername);
            }
            break;
        }
    }

    if (hwndBackground)
        SetForegroundWindow(hwndBackground);

    if (nCmd == SHTDN_NONE)
    {
        if (hwndBackground)
        {
            ShowWindow(hwndBackground, SW_HIDE);
            PostMessage(hwndBackground, WM_CLOSE, 0, 0);
        }
    }
    else
    {
        SDTP_PARAMS *psdtp = LocalAlloc(LPTR, sizeof(*psdtp));
        if (psdtp)
        {
            DWORD dw;
            HANDLE h;

            psdtp->nCmd = nCmd;
            psdtp->hwndParent = hwndParent;

            //  have another thread call ExitWindows() so our
            //  main pump keeps running durring shutdown.
            //
            h = CreateThread(NULL, 0, ShutdownThreadProc, psdtp, 0, &dw);
            if (h)
            {
                CloseHandle(h);
            }
            else
            {
                if (hwndBackground)
                    ShowWindow(hwndBackground, SW_HIDE);
                ShutdownThreadProc(psdtp);
            }
        }
    }
    if (pIUnknown != NULL)
    {
        pIUnknown->lpVtbl->Release(pIUnknown);
    }
}

// API functions

STDAPI_(void) ExitWindowsDialog(HWND hwndParent)
{
    if (!IsOS(OS_FRIENDLYLOGONUI) || IsShutdownAllowed())
    {
        CloseWindowsDialog (hwndParent, DIALOG_EXIT);
    }
    else
    {
        LogoffWindowsDialog(hwndParent);
    }
}

STDAPI_(void) LogoffWindowsDialog(HWND hwndParent)
{
    CloseWindowsDialog (hwndParent, DIALOG_LOGOFF);
}

STDAPI_(void) DisconnectWindowsDialog(HWND hwndParent)
{
    CloseWindowsDialog(hwndParent, DIALOG_DISCONNECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\reminder.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "ole2dup.h"

class CPostBootReminder : public IShellReminderManager, 
                          public IOleCommandTarget,
                          public IQueryContinue
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellReminderManager
    STDMETHOD(Add)(const SHELLREMINDER* psr);
    STDMETHOD(Delete)(LPCWSTR pszName);
    STDMETHOD(Enum)(IEnumShellReminder** ppesr);

    // IOleCommandTarget Implementation (used to display the PostBootReminders as a shell service object)
    STDMETHOD(QueryStatus)(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    STDMETHOD(Exec)(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    // IQueryContinue
    STDMETHOD(QueryContinue)(void);

    CPostBootReminder();
    
private:
    static DWORD _ThreadProc(void* pv);

    LONG  _cRef;
    TCHAR _szKeyShowing[MAX_PATH];
};

HRESULT CPostBootReminder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (NULL != punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CPostBootReminder* pPbr = new CPostBootReminder();

    if (!pPbr)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPbr->QueryInterface(riid, ppv);
    pPbr->Release();

    return hr;
}

// Per-user (HKCU)
#define REGPATH_POSTBOOTREMINDERS REGSTR_PATH_EXPLORER TEXT("\\PostBootReminders")
#define REGPATH_POSTBOOTTODO      REGSTR_PATH_EXPLORER TEXT("\\PostBootToDo")

#define PROP_POSTBOOT_TITLE           TEXT("Title")                   // REG_SZ
#define PROP_POSTBOOT_TEXT            TEXT("Text")                    // REG_SZ
#define PROP_POSTBOOT_TOOLTIP         TEXT("ToolTip")                 // REG_SZ
#define PROP_POSTBOOT_CLSID           TEXT("Clsid")                   // REG_SZ
#define PROP_POSTBOOT_SHELLEXECUTE    TEXT("ShellExecute")            // REG_SZ
#define PROP_POSTBOOT_ICONRESOURCE    TEXT("IconResource")            // REG_SZ "module,-resid"
#define PROP_POSTBOOT_SHOWTIME        TEXT("ShowTime")                // REG_DWORD
#define PROP_POSTBOOT_RETRYINTERVAL   TEXT("RetryInterval")           // REG_DWORD
#define PROP_POSTBOOT_RETRYCOUNT      TEXT("RetryCount")              // REG_DWORD
#define PROP_POSTBOOT_TYPEFLAGS       TEXT("TypeFlags")               // REG_DWORD (NIIF_WARNING, NIIF_INFO, NIIF_ERROR)

CPostBootReminder::CPostBootReminder()
{
    _cRef = 1;
}

// IUnknown

HRESULT CPostBootReminder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPostBootReminder, IShellReminderManager),
        QITABENT(CPostBootReminder, IOleCommandTarget),
        QITABENT(CPostBootReminder, IQueryContinue),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CPostBootReminder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPostBootReminder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IShellReminderManager

HRESULT CPostBootReminder::Add(const SHELLREMINDER* psr)
{
    HRESULT hr = E_FAIL;

    // Ensure the parent key is created
    HKEY hkeyCurrentUser;
    if (ERROR_SUCCESS == RegOpenCurrentUser(KEY_WRITE, &hkeyCurrentUser))
    {
        HKEY hkeyReminders;
        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCurrentUser, REGPATH_POSTBOOTREMINDERS, 0, NULL, 0, KEY_WRITE, NULL, &hkeyReminders, NULL))
        {
            IPropertyBag* pPb;
            hr = SHCreatePropertyBagOnRegKey(hkeyReminders, psr->pszName, STGM_WRITE | STGM_CREATE, IID_PPV_ARG(IPropertyBag, &pPb));

            if (SUCCEEDED(hr))
            {
                // need to check the SHELLREMINDER values for null or we will RIP in SHPropertyBag_WriteStr/GUID
                if (psr->pszTitle)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_TITLE, psr->pszTitle);
                }

                if (psr->pszText)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_TEXT, psr->pszText);
                }
                
                if (psr->pszTooltip)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_TOOLTIP, psr->pszTooltip);
                }

                if (psr->pszIconResource)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_ICONRESOURCE, psr->pszIconResource);
                }

                if (psr->pszShellExecute)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_SHELLEXECUTE, psr->pszShellExecute);
                }

                if (psr->pclsid)
                {
                    SHPropertyBag_WriteGUID(pPb, PROP_POSTBOOT_CLSID, psr->pclsid);
                }

                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_SHOWTIME, psr->dwShowTime);
                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_RETRYINTERVAL, psr->dwRetryInterval);
                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_RETRYCOUNT, psr->dwRetryCount);
                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_TYPEFLAGS, psr->dwTypeFlags);

                pPb->Release();
            }

            RegCloseKey(hkeyReminders);
            hr = S_OK;
        }
        RegCloseKey(hkeyCurrentUser);
    }

    return hr;
}

HRESULT CPostBootReminder::Delete(LPCWSTR pszName)
{
    HRESULT hr = E_FAIL;

    HKEY hKey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_POSTBOOTREMINDERS, 0, KEY_WRITE, &hKey))
    {
        SHDeleteKey(hKey, pszName);
        RegCloseKey(hKey);
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CPostBootReminder::Enum(IEnumShellReminder** ppesr)
{
    *ppesr = NULL;
    return E_NOTIMPL;
}

// IOleCommandTarget implementation

HRESULT CPostBootReminder::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // We like Shell Service Object notifications...
        hr = S_OK;
    }

    return hr;
}

HRESULT CPostBootReminder::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        hr = S_OK; // Any ol' notification is ok with us
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
        case SSOCMDID_OPEN:
            AddRef();       // AddRef so that this instance stays around. An equivalent Release() is in _ThreadProc
            if (!SHCreateThread(_ThreadProc, this, CTF_COINIT, NULL))
            {
                Release();
            }
            break;
        }
    }

    return hr;
}


// IQueryContinue implementation

HRESULT CPostBootReminder::QueryContinue()
{
    HRESULT hr = S_OK;

    if (_szKeyShowing[0])
    {
        HKEY hKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, _szKeyShowing, 0, KEY_READ, &hKey))
        {
            RegCloseKey(hKey);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

// Function prototypes
HRESULT CreateUserNotificationFromPropertyBag(IPropertyBag* pPb, IUserNotification** ppun);
HRESULT _SetBalloonInfoFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun);
HRESULT _SetBalloonRetryFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun);
HRESULT _SetBalloonIconFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun);
HRESULT _InvokeFromPropertyBag(IPropertyBag* pPb);

HRESULT GetSubKeyPropertyBag(HKEY hkey, DWORD iSubKey, DWORD grfMode, IPropertyBag** ppPb, TCHAR * szKey, DWORD cchKey);

HRESULT _SetBalloonInfoFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun)
{
    TCHAR szTitle[256];
    HRESULT hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_TITLE, szTitle, ARRAYSIZE(szTitle));
    if (SUCCEEDED(hr))
    {
        TCHAR szText[512];
        hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_TEXT, szText, ARRAYSIZE(szText));
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = 0;
            hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_TYPEFLAGS, &dwFlags);
            if (SUCCEEDED(hr))
            {
                hr = pun->SetBalloonInfo(szTitle, szText, dwFlags);
            }
        }
    }

    return hr;
}

HRESULT _SetBalloonRetryFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun)
{
    DWORD dwShowTime;
    HRESULT hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_SHOWTIME, &dwShowTime);
    if (SUCCEEDED(hr))
    {
        DWORD dwRetryInterval;
        hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_RETRYINTERVAL, &dwRetryInterval);
        if (SUCCEEDED(hr))
        {
            DWORD dwRetryCount;
            hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_RETRYCOUNT, &dwRetryCount);
            if (SUCCEEDED(hr))
            {
                hr = pun->SetBalloonRetry(dwShowTime, dwRetryInterval, dwRetryCount);
            }
        }
    }

    return hr;
}

HRESULT _SetBalloonIconFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun)
{
    TCHAR szTooltip[256];
    HRESULT hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_TOOLTIP, szTooltip, ARRAYSIZE(szTooltip));

    if (FAILED(hr))
    {
        *szTooltip = 0;
    }

    TCHAR szIcon[MAX_PATH + 6];
    hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_ICONRESOURCE, szIcon, ARRAYSIZE(szIcon));
    if (SUCCEEDED(hr))
    {
        int iIcon = PathParseIconLocation(szIcon);
        HICON hIcon;
        hr = (0 == ExtractIconEx(szIcon, iIcon, NULL, &hIcon, 1)) ? E_FAIL : S_OK;
        if (SUCCEEDED(hr))
        {
            pun->SetIconInfo(hIcon, szTooltip);

            DestroyIcon(hIcon);
        }
    }

    return hr;
}

HRESULT _InvokeFromPropertyBag(IPropertyBag* pPb)
{
    // First try to use the CLSID to find a handler for the click
    CLSID clsid;
    HRESULT hr = SHPropertyBag_ReadGUID(pPb, PROP_POSTBOOT_CLSID, &clsid);

    if (SUCCEEDED(hr))
    {
        IContextMenu* pcm;
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            CMINVOKECOMMANDINFO ici = {0};
            ici.cbSize = sizeof(ici);
            ici.lpVerb = "open";
            ici.nShow = SW_SHOWNORMAL;

            pcm->InvokeCommand(&ici);
            pcm->Release();
        }
    }

    if (FAILED(hr))
    {
        // Second, use the shellexecute line
        TCHAR szExecute[MAX_PATH + 1];
        hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_SHELLEXECUTE, szExecute, ARRAYSIZE(szExecute));
        if (SUCCEEDED(hr))
        {
            // Use shellexecuteex to open a view folder
            SHELLEXECUTEINFO shexinfo = {0};
            shexinfo.cbSize = sizeof (shexinfo);
            shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
            shexinfo.nShow = SW_SHOWNORMAL;
            shexinfo.lpFile = szExecute;

            ShellExecuteEx(&shexinfo);
        }
    }

    return hr;
}

DWORD CPostBootReminder::_ThreadProc(void* pv)
{
    HKEY hkeyReminders;
    CPostBootReminder * ppbr = (CPostBootReminder *) pv;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_POSTBOOTREMINDERS, 0, KEY_READ, &hkeyReminders))
    {
        DWORD iReminder = 0;
        HRESULT hr = S_OK;
        while (S_OK == hr)
        {
            IPropertyBag* pPb;
            hr = GetSubKeyPropertyBag(hkeyReminders, iReminder, STGM_READ, &pPb, ppbr->_szKeyShowing, ARRAYSIZE(ppbr->_szKeyShowing));
            if (S_OK == hr)
            {
                IUserNotification* pun;
                hr = CreateUserNotificationFromPropertyBag(pPb, &pun);
                if (SUCCEEDED(hr))
                {
                    if (S_OK == pun->Show(SAFECAST(ppbr, IQueryContinue *), 0))
                    {
                        _InvokeFromPropertyBag(pPb);
                    }
                    pun->Release();
                }

                pPb->Release();
            }

            // No key is showing now...
            ppbr->_szKeyShowing[0] = 0;

            iReminder++;
        }

        RegCloseKey(hkeyReminders);

        SHDeleteKey(HKEY_CURRENT_USER, REGPATH_POSTBOOTREMINDERS);         // Recursive delete
    }
    ppbr->Release();

    return 0;
}

HRESULT CreateUserNotificationFromPropertyBag(IPropertyBag* pPb, IUserNotification** ppun)
{
    HRESULT hr = CUserNotification_CreateInstance(NULL, IID_PPV_ARG(IUserNotification, ppun));
    if (SUCCEEDED(hr))
    {
        hr = _SetBalloonInfoFromPropertyBag(pPb, *ppun);

        if (SUCCEEDED(hr))
        {
            _SetBalloonRetryFromPropertyBag(pPb, *ppun);
            _SetBalloonIconFromPropertyBag(pPb, *ppun);
        }
        else
        {
            (*ppun)->Release();
            *ppun = NULL;
        }
    }
    return hr;
}

HRESULT GetSubKeyPropertyBag(HKEY hkey, DWORD iSubKey, DWORD grfMode, IPropertyBag** ppPb, TCHAR *pszKey, DWORD cchKey)
{
    *ppPb = NULL;

    TCHAR szName[256];
    DWORD cchSize = ARRAYSIZE(szName);
    LONG lResult = RegEnumKeyEx(hkey, iSubKey, szName, &cchSize, NULL, NULL, NULL, NULL);

    if (ERROR_NO_MORE_ITEMS == lResult)
        return S_FALSE;

    if (ERROR_SUCCESS != lResult)
        return E_FAIL;

    StringCchCopy(pszKey, cchKey, REGPATH_POSTBOOTREMINDERS);
    StringCchCat(pszKey, cchKey, TEXT("\\"));
    StringCchCat(pszKey, cchKey, szName);

    return SHCreatePropertyBagOnRegKey(hkey, szName, grfMode, IID_PPV_ARG(IPropertyBag, ppPb));    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\scnotifyp.h ===
//  private declarations for scnotify.cpp

typedef struct
{
    DWORD   dwSig;
    UINT    uCmd;                                                       
    ULONG   ulID;                                                       
    ULONG   ulHwnd;
    UINT    uMsg;                                                       
    DWORD   fSources;                                                   
    LONG    lEvents;                                                    
    BOOL    fRecursive;                                                 
    UINT    uidlRegister;                                               
} CHANGEREGISTER;                        
                                                                        
typedef struct 
{
    DWORD   dwSig;
    DWORD   cbSize;                                                     
    LONG    lEvent;                                                     
    UINT    uFlags;                                                     
    DWORD   dwEventTime;                                                
    UINT    uidlMain;                                                   
    UINT    uidlExtra;                                                  
} CHANGEEVENT;                        
                                                                        
typedef struct 
{
    DWORD dwSig;
    LPITEMIDLIST pidlMain;                                   
    LPITEMIDLIST pidlExtra;                                  
    CHANGEEVENT *pce;                                      
} CHANGELOCK;               

HANDLE SHChangeNotification_Create(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidlMain, LPCITEMIDLIST pidlExtra, DWORD dwProcId, DWORD dwEventTime);


class CNotifyEvent;
class CCollapsingClient;
class CRegisteredClient;
class CInterruptSource;
class CAnyAlias;

//
//  this is the global object g_pscn
//  its lifetime is tied to the SCNotify thread and window.
//  if the thread or window dies, then the object is destroyed
//
class CChangeNotify
{
public:  //  methods
    CNotifyEvent *GetEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags);
    BOOL AddClient(IDLDATAF flags, LPCITEMIDLIST pidl, BOOL *pfInterrupt, BOOL fRecursive, CCollapsingClient *pclient);
    HRESULT RemoveClient(LPCITEMIDLIST pidl, BOOL fInterrupt, CCollapsingClient *pclient);
    BOOL AddInterruptSource(LPCITEMIDLIST pidlClient, BOOL fRecursive);
    void ReleaseInterruptSource(LPCITEMIDLIST pidlClient);
    void AddAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias, DWORD dwEventTime);
    void AddSpecialAlias(int csidlReal, int csidlAlias);
    void UpdateSpecialAlias(int csidlAlias);
    void NotifyEvent(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime);
    void PendingCallbacks(BOOL fAdd);
    void SetFlush(int idt);

    static DWORD WINAPI ThreadProc(void *pv);
    static DWORD WINAPI ThreadStartUp(void *pv);
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:  //  methods
    BOOL _OnChangeRegistration(HANDLE hChangeRegistration, DWORD dwProcId);
    LRESULT _OnNotifyEvent(HANDLE hChange, DWORD dwProcId);
    LRESULT _OnSuspendResume(HANDLE hChange, DWORD dwProcId);
    void _OnDeviceBroadcast(ULONG_PTR code, DEV_BROADCAST_HANDLE *pbhnd);
    ULONG _RegisterClient(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne);
    BOOL _DeregisterClient(CRegisteredClient *pclient);
    BOOL _DeregisterClientByID(ULONG ulID);
    BOOL _DeregisterClientsByWindow(HWND hwnd);
    void _FreshenClients(void);
    BOOL _InitTree(CIDLTree **pptree);
    BOOL _AddToClients(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags);
    void _MatchAndNotify(LPCITEMIDLIST pidl, CNotifyEvent *pne, BOOL fFromExtra);
    void _AddGlobalEvent(CNotifyEvent *pne);
    CInterruptSource *_InsertInterruptSource(LPCITEMIDLIST pidl, BOOL fRecursive);
    DWORD _GetInterruptEvents(HANDLE *ahEvents, DWORD cEvents);
    void _ResetRelatedInterrupts(LPCITEMIDLIST pidl);
    void _FlushInterrupts();
    void _Flush(BOOL fShouldWait);
    void _WaitForCallbacks(void);
    BOOL _SuspendResume(BOOL fSuspend, BOOL fRecursive, LPCITEMIDLIST pidl);

    BOOL _HandleMessages(void);
    void _MessagePump(void);
    void _SignalInterrupt(HANDLE hEvent);
    void _FreshenUp(void);

    CAnyAlias *_FindAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
    CAnyAlias *_FindSpecialAlias(int csidlReal, int csidlAlias);
    void _CheckAliasRollover(void);
    void _FreshenAliases(void);
    BOOL _InsertAlias(CLinkedNode<CAnyAlias> *p);
    void _ActivateAliases(LPCITEMIDLIST pidl, BOOL fActivate);
    
protected:  //  members

    CIDLTree *_ptreeClients;
    CIDLTree *_ptreeInterrupts;
    CIDLTree *_ptreeAliases;
    
    CLinkedList<CInterruptSource> _listInterrupts;
    CLinkedList<CRegisteredClient> _listClients;
    CLinkedList<CAnyAlias> _listAliases;

    LONG _cFlushing;
    LONG _cCallbacks;
    HANDLE _hCallbackEvent;
};

typedef struct _MSGEVENT
{
    HANDLE hChange;
    DWORD dwProcId;
} MSGEVENT;

//
//  LIFETIME - based on clients holding references
//  Each event can have multiple references
//  each CRegisteredClient has a DPA that points to a list
//  of events that the client will want to know.
//  the first time an event is used, it is added
//  to the ptreeEvents, so that it may be reused.
//  when the last client stops using the event, then
//  it is removed from the tree.
//
class CNotifyEvent
{
public:
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    MSGEVENT *GetNotification(DWORD dwProcId)
    {
        MSGEVENT *pme = new MSGEVENT;

        if (pme)
        {
            pme->dwProcId = dwProcId;
            pme->hChange = SHChangeNotification_Create((lEvent & ~SHCNE_INTERRUPT), // clients should never see the SHCNE_INTERRUPT flag
                                           0,
                                           pidl,
                                           pidlExtra,
                                           dwProcId,
                                           dwEventTime);
            if (!pme->hChange)
            {
                delete pme;
                pme = NULL;
            }
        }

        return pme;
    }
    
    BOOL Init(LPCITEMIDLIST pidlIn, LPCITEMIDLIST pidlExtraIn);

    LONG  lEvent;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlExtra;
    DWORD dwEventTime;
    UINT uEventFlags;
    
protected:
    LONG _cRef;

    static CNotifyEvent *Create(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags);
    CNotifyEvent(LONG lEventIn, DWORD dwEventTimeIn, UINT uEventFlagsIn) 
        : lEvent(lEventIn), dwEventTime(dwEventTimeIn), uEventFlags(uEventFlagsIn), _cRef(1) {}
    ~CNotifyEvent() { ILFree(pidl); ILFree(pidlExtra); }
    //  so CSCN can set fUsed;
    friend class CChangeNotify;
    friend class CRegisteredClient;
};

class CCollapsingClient
{
public:  // methods
    void Notify(CNotifyEvent *pne, BOOL fFromExtra);
    BOOL Flush(BOOL fNeedsCallbackEvent);
    BOOL Init(LPCITEMIDLIST pidl, BOOL fRecursive);

    CCollapsingClient();

protected:
    virtual ~CCollapsingClient();

    virtual BOOL _WantsEvent(LONG lEvent) = 0;
    virtual void _SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb) = 0;
    virtual BOOL _IsValidClient() = 0;
    virtual BOOL _CheckUpdatingSelf() = 0;

    LPITEMIDLIST        _pidl;
    LONG                _fEvents;
    HWND                _hwnd;
    BOOL                _fUpdatingSelf;
    BOOL                _fRecursive;

private:

    BOOL _Flush(BOOL fNeedsCallbackEvent);
    BOOL _CanCollapse(LONG lEvent);
    BOOL _IsDupe(CNotifyEvent *pne);
    BOOL _AddEvent(CNotifyEvent *pne, BOOL fFromExtra);

    CDPA<CNotifyEvent>  _dpaPendingEvents;
    int                 _iUpdatingSelfIndex;
    int                 _cEvents;
};

//
//  LIFETIME - based on client registration
//  when an SCN client calls Register, we create
//  a corresponding object that lives
//  as long as the client window is valid
//  or until Deregister is called.
//  references are kept in ptreeClients and in 
//  the pclientFirst list.  when a client is
//  removed from the list, it is also removed
//  from the tree.
//
class CRegisteredClient : public CCollapsingClient
{
public:  // methods
    CRegisteredClient();
    ~CRegisteredClient();
    BOOL Init(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne);
    
protected:  // methods
    void _SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb);
    BOOL _WantsEvent(LONG lEvent);
    BOOL _IsValidClient() { return (!_fDeadClient); }
    BOOL _CheckUpdatingSelf() { return _fUpdatingSelf; }

protected:  // members
    ULONG               _ulID;
    BOOL                _fDeadClient;
    BOOL                _fInterrupt;

private: // members
    DWORD               _dwProcId;
    int                 _fSources;
    UINT                _wMsg;
    
    friend class CChangeNotify;
};

class CAnyAlias : public CCollapsingClient
{
public:  // methods
    void Activate(BOOL fActivate);
    BOOL Remove();
    BOOL Init(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
    BOOL InitSpecial(int csidlReal, int csidlAlias);
    BOOL IsAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
    BOOL IsSpecial(int csidlReal, int csidlAlias);
    ~CAnyAlias();

protected:
    BOOL _CustomTranslate();
    
    void _SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb);
    BOOL _WantsEvent(LONG lEvent);
    BOOL _IsValidClient() { return TRUE; }
    BOOL _CheckUpdatingSelf() { return FALSE; }
    BOOL _OkayToNotifyTranslatedEvent(CNotifyEvent *pne, LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);

private:
    LONG _cActivated;
    LPITEMIDLIST _pidlAlias;
    ITranslateShellChangeNotify *_ptscn;
    DWORD _dwTime;
    BOOL _fRemove;
    BOOL _fInterrupt;
    BOOL _fCheckedCustom;
    BOOL _fSpecial;
    int _csidlReal;
    int _csidlAlias;
    
    friend class CChangeNotify;
};

//
//  LIFETIME - based on client registration
//  when an SCN client calls Register, we may create
//  a corresponding object that lives
//  as long as the client window is valid
//  or until Deregister is called.
//  references are kept in ptreeClients and in 
//  the pclientFirst list.  when a client is
//  removed from the list, it is also removed
//  from the tree.
//
class CInterruptSource
{
public:  // methods
    BOOL Init(LPCITEMIDLIST pidl, BOOL fRecursive);
    void Reset(BOOL fSignal);
    BOOL GetEvent(HANDLE *phEvent);
    void Suspend(BOOL fSuspend);
    BOOL SuspendDevice(BOOL fSuspend, HDEVNOTIFY hPNP);
    BOOL Flush(void);
    ~CInterruptSource();
    
protected: // methods
    void _Reset(BOOL fDeviceNotify);
    
protected: // members
    LPITEMIDLIST pidl;     // this is SHARED with the fs registered client structure.
    DWORD cClients;         // how many clients are interested in this. (ref counts)

private:
    typedef enum
    {
        NO_SIGNAL = 0,
        SH_SIGNAL,
        FS_SIGNAL
    } SIGNAL_STATE;

    BOOL _fRecursive;        // is this a recursive interrupt client?
    HANDLE _hEvent;
    // cRecursive  clients
    LONG _cSuspend;         //  suspended for extended fileops
    SIGNAL_STATE _ssSignal;  //  FS has signaled us with an event on this directory
    HDEVNOTIFY _hPNP;        // PnP handle to warn us about drives coming and going
    HDEVNOTIFY _hSuspended;  // suspended PnP handle

    friend class CChangeNotify;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\scffile.cpp ===
// this file implements shell command files.
// .scf scffile
// when executed, they run a shell internal command.
// they can have stream storage, or whatnot in them
//
// file format is *PURPOSELY* text so that folks can create and modify by hand

#include "shellprv.h"
#include <desktopp.h>
#include <trayp.h>
#include <strsafe.h>

extern HWND g_hwndTray; // desktop.cpp

void SFC_IECommand(LPCTSTR pszFile)
{
    TCHAR szCommand[40];
    
    if (GetPrivateProfileString(TEXT("IE"), TEXT("Command"), TEXT(""), szCommand, ARRAYSIZE(szCommand), pszFile)) 
    {
        if (!lstrcmpi(szCommand, TEXT("Channels"))
            && !SHRestricted2W(REST_NoChannelUI, NULL, 0))
        {
            Channel_QuickLaunch();
        }
    }
}

void SFC_TrayCommand(LPCTSTR pszFile)
{
    HWND hwnd = g_hwndTray;
    if (hwnd && IsWindowInProcess(hwnd))
    {
        TCHAR szCommand[40];
        if (GetPrivateProfileString(TEXT("Taskbar"), TEXT("Command"), TEXT(""), szCommand, ARRAYSIZE(szCommand), pszFile)) 
        {
            char szAnsiCommand[40];
            SHTCharToAnsi(szCommand, szAnsiCommand, ARRAYSIZE(szAnsiCommand));

            LPSTR psz = StrDupA(szAnsiCommand);
            if (psz) 
            {
                if (!PostMessage(hwnd, TM_PRIVATECOMMAND, 0, (LPARAM)psz))
                    LocalFree(psz);
            }
        }
    }
}

const struct
{
    UINT id;
    void (*pfn)(LPCTSTR pszBuf);
} 
c_sCmdInfo[] = 
{
    { 2, SFC_TrayCommand},
    { 3, SFC_IECommand},
};

STDAPI_(void) ShellExecCommandFile(LPCITEMIDLIST pidl)
{
    TCHAR szFile[MAX_PATH];

    if (SHGetPathFromIDList(pidl, szFile)) 
    {
        UINT uID = GetPrivateProfileInt(TEXT("Shell"), TEXT("Command"), 0, szFile);
        if (uID) 
        {
            for (int i = 0; i < ARRAYSIZE(c_sCmdInfo); i++) 
            {
                if (uID == c_sCmdInfo[i].id) 
                {
                    c_sCmdInfo[i].pfn(szFile);
                    break;
                }
            }
        }
    }
}

class CShellCmdFileIcon : public IExtractIconA, public IExtractIconW, public IPersistFile
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IExtractIconA
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize) {return S_FALSE;};

    // IExtractIconW
    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCWSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize) {return S_FALSE;};

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) { *pclsid = CLSID_CmdFileIcon; return S_OK;};
    
    // IPersistFile
    STDMETHODIMP IsDirty(void) {return S_FALSE;};
    STDMETHODIMP Save(LPCOLESTR pcwszFileName, BOOL bRemember) {return S_OK;};
    STDMETHODIMP SaveCompleted(LPCOLESTR pcwszFileName){return S_OK;};
    STDMETHODIMP Load(LPCOLESTR pcwszFileName, DWORD dwMode);
    STDMETHODIMP GetCurFile(LPOLESTR *ppwszFileName);
    
    CShellCmdFileIcon() { _cRef = 1; DllAddRef(); };
private:
    ~CShellCmdFileIcon() { DllRelease(); };

    LONG _cRef;
    TCHAR _szFile[MAX_PATH];
};


ULONG CShellCmdFileIcon::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CShellCmdFileIcon::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CShellCmdFileIcon::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    TCHAR szData[MAX_PATH + 80];

    if (_szFile[0]) 
    {
        *pwFlags = 0;
        *piIndex = 0;
        szIconFile[0] = 0;

        GetPrivateProfileString(TEXT("Shell"), TEXT("IconFile"), TEXT(""), szData, ARRAYSIZE(szData), _szFile);
        
        *piIndex = PathParseIconLocation(szData);
        HRESULT hr = StringCchCopy(szIconFile, cchMax, szData);
        return hr;
    }
    
    return E_FAIL;
}

HRESULT CShellCmdFileIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    WCHAR szAnsiIconPath[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szAnsiIconPath, MAX_PATH, piIndex, pwFlags);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(szAnsiIconPath, szIconFile, cchMax);
    }
    
    return hr;
}


// IPersistFile::Load

STDMETHODIMP CShellCmdFileIcon::Load(LPCOLESTR pwszFile, DWORD dwMode)
{
    SHUnicodeToTChar(pwszFile, _szFile, ARRAYSIZE(_szFile));
    return S_OK;
}

STDMETHODIMP CShellCmdFileIcon::GetCurFile(LPOLESTR *ppwszFileName)
{
    SHTCharToUnicode(_szFile, *ppwszFileName, ARRAYSIZE(_szFile));
    return S_OK;
}

HRESULT CShellCmdFileIcon::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CShellCmdFileIcon, IExtractIconA),
        QITABENT(CShellCmdFileIcon, IExtractIconW),
        QITABENT(CShellCmdFileIcon, IPersistFile),
        QITABENTMULTI(CShellCmdFileIcon, IPersist, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CShellCmdFileIcon_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CShellCmdFileIcon *pObj = new CShellCmdFileIcon();
    if (pObj)
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\security.cpp ===
#include "shellprv.h"

extern "C" {
#include <shellp.h>
#include "ole2dup.h"
};

#include "util.h"
#include "_security.h"

/**********************************************************************\
    FUNCTION: ZoneCheckPidl

    DESCRIPTION:
        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
STDAPI ZoneCheckPidl(LPCITEMIDLIST pidl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    HRESULT hr = E_FAIL;
    TCHAR szUrl[MAX_URL_STRING];

    SetFlag(dwFlags, PUAF_ISFILE);

    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szUrl, SIZECHARS(szUrl), NULL)))
        hr = ZoneCheckUrl(szUrl, dwActionType, dwFlags, pisms);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\securent.cpp ===
#include "shellprv.h"
#include "TokenUtil.h"
#pragma  hdrstop


//  Gets the current process's user token and returns
//  it. It can later be free'd with LocalFree.
//
//  NOTE: This code is duped in shlwapi\shellacl.c. If you change it, modify
//        it there as well.

STDAPI_(PTOKEN_USER) GetUserToken(HANDLE hUser)
{
    DWORD dwSize = 64;
    HANDLE hToClose = NULL;

    if (hUser == NULL)
    {
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hUser);
        hToClose = hUser;
    }

    PTOKEN_USER pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwSize);
    if (pUser)
    {
        DWORD dwNewSize;
        BOOL fOk = GetTokenInformation(hUser, TokenUser, pUser, dwSize, &dwNewSize);
        if (!fOk && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            LocalFree((HLOCAL)pUser);

            pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwNewSize);
            if (pUser)
            {
                fOk = GetTokenInformation(hUser, TokenUser, pUser, dwNewSize, &dwNewSize);
            }
        }
        if (!fOk)
        {
            LocalFree((HLOCAL)pUser);
            pUser = NULL;
        }
    }

    if (hToClose)
    {
        CloseHandle(hToClose);
    }

    return pUser;
}

//  Returns a localalloc'd string containing the text version of the current user's SID.

STDAPI_(LPTSTR) GetUserSid(HANDLE hToken)
{
    LPTSTR pString = NULL;
    PTOKEN_USER pUser = GetUserToken(hToken);
    if (pUser)
    {
        UNICODE_STRING UnicodeString;
        if (STATUS_SUCCESS == RtlConvertSidToUnicodeString(&UnicodeString, pUser->User.Sid, TRUE))
        {
            UINT nChars = (UnicodeString.Length / 2) + 1;
            pString = (LPTSTR)LocalAlloc(LPTR, nChars * sizeof(TCHAR));
            if (pString)
            {
                SHUnicodeToTChar(UnicodeString.Buffer, pString, nChars);
            }
            RtlFreeUnicodeString(&UnicodeString);
        }
        LocalFree((HLOCAL)pUser);
    }
    return pString;
}


/*++

    sets the security attributes for a given privilege.

Arguments:

    PrivilegeName - Name of the privilege we are manipulating.

    NewPrivilegeAttribute - The new attribute value to use.

    OldPrivilegeAttribute - Pointer to receive the old privilege value. OPTIONAL

Return value:

    NO_ERROR or WIN32 error.

--*/

DWORD SetPrivilegeAttribute(LPCTSTR PrivilegeName, DWORD NewPrivilegeAttribute, DWORD *OldPrivilegeAttribute)
{
    LUID             PrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) 
    {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &TokenHandle)) 
    {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof( TOKEN_PRIVILEGES );
    if (!AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                &OldTokenPrivileges,
                &ReturnLength
                )) 
    {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else 
    {
        if (OldPrivilegeAttribute != NULL) 
        {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}

//
//  Purpose:    Determines if the user is a member of the administrators group.
//
//  Parameters: void
//
//  Return:     TRUE if user is a admin
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              4/12/95     ericflo    Created
//              11/4/99     jeffreys   Use CheckTokenMembership
//

STDAPI_(BOOL) IsUserAnAdmin()
{
    return SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS);
}

// is user a guest but not a full user?
STDAPI_(BOOL) IsUserAGuest()
{
    return SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS);
}

STDAPI_(BOOL) GetUserProfileKey(HANDLE hToken, REGSAM samDesired, HKEY *phkey)
{
    LPTSTR pUserSid = GetUserSid(hToken);
    if (pUserSid)
    {
        LONG err = RegOpenKeyEx(HKEY_USERS, pUserSid, 0, samDesired, phkey);

        LocalFree(pUserSid);
        return err == ERROR_SUCCESS;
    }
    return FALSE;
}

//
//  Arguments:  phToken     =   Handle to token.
//
//  Returns:    BOOL
//
//  Purpose:    Opens the thread token. If no thread impersonation token is
//              present open the process token.
//
//  History:    2000-02-28  vtan        created


STDAPI_(BOOL) SHOpenEffectiveToken(HANDLE *phToken)
{
    return OpenEffectiveToken(TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, phToken);
}

//
//  Arguments:  hToken              =   Handle to token (may be NULL).
//              pszPrivilegeName    =   Name of privilege to check for.
//
//  Returns:    BOOL
//
//  Purpose:    Uses the given token or if no token is specified the effective
//              token and looks through the list of privileges contained in
//              token for a match against the given privilege being checked.
//
//  History:    2000-02-28  vtan        created


STDAPI_(BOOL) SHTestTokenPrivilege(HANDLE hToken, LPCTSTR pszPrivilegeName)
{
    //  Validate privilege name.

    if (pszPrivilegeName == NULL)
    {
        return FALSE;
    }

    BOOL fResult = FALSE;
    HANDLE hTokenToFree = NULL;
    if (hToken == NULL)
    {
        if (SHOpenEffectiveToken(&hTokenToFree) != FALSE)
        {
            hToken = hTokenToFree;
        }
    }
    if (hToken != NULL)
    {
        LUID luidPrivilege;

        if (LookupPrivilegeValue(NULL, pszPrivilegeName, &luidPrivilege) != FALSE)
        {
            DWORD dwTokenPrivilegesSize = 0;
            GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwTokenPrivilegesSize);
            TOKEN_PRIVILEGES *pTokenPrivileges = static_cast<TOKEN_PRIVILEGES*>(LocalAlloc(LMEM_FIXED, dwTokenPrivilegesSize));
            if (pTokenPrivileges != NULL)
            {
                DWORD dwReturnLength;

                if (GetTokenInformation(hToken, TokenPrivileges, pTokenPrivileges, dwTokenPrivilegesSize, &dwReturnLength) != FALSE)
                {
                    DWORD   dwIndex;

                    for (dwIndex = 0; !fResult && (dwIndex < pTokenPrivileges->PrivilegeCount); ++dwIndex)
                    {
                        fResult = (RtlEqualLuid(&luidPrivilege, &pTokenPrivileges->Privileges[dwIndex].Luid));
                    }
                }
                (HLOCAL)LocalFree(pTokenPrivileges);
            }
        }
    }
    if (hTokenToFree != NULL)
    {
        TBOOL(CloseHandle(hTokenToFree));
    }
    return fResult;
}

//
//  Arguments:  hToken  =   Handle to token (may be NULL).
//              ulRID   =   RID of local group to test membership of.
//
//  Returns:    BOOL
//
//  Purpose:    Uses advapi32!CheckTokenMembership to test whether the given
//              token is a member of the local group with the specified RID.
//              This function wraps CheckTokenMember and only checks local
//              groups.
//
//  History:    2000-03-22  vtan        created


STDAPI_(BOOL) SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
{
    static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

    PSID pSIDLocalGroup;
    BOOL fResult = FALSE;
    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 ulRID,
                                 0, 0, 0, 0, 0, 0,
                                 &pSIDLocalGroup) != FALSE)
    {
        if (CheckTokenMembership(hToken, pSIDLocalGroup, &fResult) == FALSE)
        {
            TraceMsg(TF_WARNING, "shell32: SHTestTokenMembership call to advapi32!CheckTokenMembership failed with error %d", GetLastError());
            fResult = FALSE;
        }
        FreeSid(pSIDLocalGroup);
    }
    return fResult;
}

//
//  Arguments:  pszPrivilegeName        =   Name of privilege to be enabled.
//              pfnPrivilegedFunction   =   Pointer to function to invoke.
//              pv                      =   Caller supplied data.
//
//  Returns:    HRESULT
//
//  Purpose:    Enables the given privilege in the current thread's
//              impersonation or primary process' token, invokes the given
//              function pointer with the caller supplied data and then
//              restores the privilege back to its previous state.
//
//  History:    2000-03-13  vtan        created


STDAPI SHInvokePrivilegedFunction(LPCTSTR pszPrivilegeName, PFNPRIVILEGEDFUNCTION pfnPrivilegedFunction, void *pv)
{
    if ((pszPrivilegeName == NULL) || (pfnPrivilegedFunction == NULL))
    {
        return E_INVALIDARG;
    }

    CPrivilegeEnable privilege(pszPrivilegeName);

    return pfnPrivilegedFunction(pv);
}

//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns the ID of the active console session.
//
//  History:    2000-03-13  vtan        created


STDAPI_(DWORD)  SHGetActiveConsoleSessionId (void)

{
    return static_cast<DWORD>(USER_SHARED_DATA->ActiveConsoleId);
}

//
//  Arguments:  hToken  =   Handle to the user token.
//
//  Returns:    DWORD
//
//  Purpose:    Returns the session ID associated with the given token. If no
//              token is specified the effective token is used. This will
//              allow a service to call this function when impersonating a
//              client.
//
//              The token must have TOKEN_QUERY access.
//
//  History:    2000-03-13  vtan        created


STDAPI_(DWORD) SHGetUserSessionId(HANDLE hToken)
{
    ULONG   ulUserSessionID = 0;        // default to session 0
    HANDLE  hTokenToFree = NULL;
    if (hToken == NULL)
    {
        TBOOL(SHOpenEffectiveToken(&hTokenToFree));
        hToken = hTokenToFree;
    }
    if (hToken != NULL)
    {
        DWORD dwReturnLength;
        TBOOL(GetTokenInformation(hToken,
                                  TokenSessionId,
                                  &ulUserSessionID,
                                  sizeof(ulUserSessionID),
                                  &dwReturnLength));
    }
    if (hTokenToFree != NULL)
    {
        TBOOL(CloseHandle(hTokenToFree));
    }
    return ulUserSessionID;
}


//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the current process is the console session.
//
//  History:    2000-03-27  vtan        created


STDAPI_(BOOL) SHIsCurrentProcessConsoleSession(void)

{
    return USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\securent.h ===
#ifndef _SECURENT_INC
#define _SECURENT_INC

//
// Shell helper functions for security
//
STDAPI_(PTOKEN_USER) GetUserToken(HANDLE hUser);
STDAPI_(LPTSTR) GetUserSid(HANDLE hToken);

STDAPI_(BOOL) GetUserProfileKey(HANDLE hToken, REGSAM samDesired, HKEY *phkey);
STDAPI_(BOOL) IsUserAnAdmin();
STDAPI_(BOOL) IsUserAGuest();

#endif // _SECURENT_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\rundll32.c ===
#include "shellprv.h"
#pragma  hdrstop
#include <regstr.h>

TCHAR const c_szRunDll[] = TEXT("rundll32.exe");

//
// Emulate multi-threads with multi-processes.
//
STDAPI_(BOOL) SHRunDLLProcess(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow, UINT idStr, BOOL fRunAsNewUser)
{
    BOOL bRet = FALSE;
    TCHAR szPath[MAX_PATH];
    DWORD dwType;
    DWORD cbData;
    
    szPath[0] = TEXT('\0');

    // I hate network install. The windows directory is not the windows directory
    if (SHGetValue(HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_SETUP TEXT("\\Setup"),
                   TEXT("SharedDir"),
                   &dwType,
                   szPath,
                   &cbData) != ERROR_SUCCESS)
    {
        GetSystemDirectory(szPath, ARRAYSIZE(szPath));
    }

    if ((szPath[0] != TEXT('\0')) &&
        PathAppend(szPath, c_szRunDll))
    {
        SHELLEXECUTEINFO ExecInfo = {0};

        DebugMsg(DM_TRACE, TEXT("sh TR - RunDLLProcess (%s)"), pszCmdLine);
        FillExecInfo(ExecInfo, hwnd, NULL, szPath, pszCmdLine, TEXT(""), nCmdShow);

        // if we want to launch this cpl as a new user, set the verb to be "runas"
        if (fRunAsNewUser)
        {
            ExecInfo.lpVerb = TEXT("runas");
        }
        else
        {
            // normal execute so no ui, we do our own error messages
            ExecInfo.fMask = SEE_MASK_FLAG_NO_UI;
        }

        // We need to put an appropriate message box.
        bRet = ShellExecuteEx(&ExecInfo);

        if (!bRet && !fRunAsNewUser)
        {
            // If we failed and we werent passing fRunAsNewUser, then we put up our own error UI,
            // else, if we were running this as a new user, then we didnt pass SEE_MASK_FLAG_NO_UI
            // so the error is already taken care of for us by shellexec.
            TCHAR szTitle[64];
            DWORD dwErr = GetLastError(); // LoadString can stomp on this (on failure)
            
            LoadString(HINST_THISDLL, idStr, szTitle, ARRAYSIZE(szTitle));
            ExecInfo.fMask = 0;
            _ShellExecuteError(&ExecInfo, szTitle, dwErr);
        }
    }

    return bRet;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case STUBM_SETICONTITLE:
        if (lParam)
            SetWindowText(hWnd, (LPCTSTR)lParam);
        if (wParam)
            SendMessage(hWnd, WM_SETICON, ICON_BIG, wParam);
        break;

    case STUBM_SETDATA:
        SetWindowLongPtr(hWnd, 0, wParam);
        break;
        
    case STUBM_GETDATA:
        return GetWindowLong(hWnd, 0);
        
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam) ;
    }
    
    return 0;
}


HWND _CreateStubWindow(POINT * ppt, HWND hwndParent)
{
    WNDCLASS wc;
    int cx, cy;
    // If the stub window is parented, then we want it to be a tool window. This prevents activation
    // problems when this is used in multimon for positioning.

    DWORD dwExStyle = hwndParent? WS_EX_TOOLWINDOW : WS_EX_APPWINDOW;
    if (!GetClassInfo(HINST_THISDLL, c_szStubWindowClass, &wc))
    {
        wc.style         = 0;
        wc.lpfnWndProc   = WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = SIZEOF(DWORD) * 2;
        wc.hInstance     = HINST_THISDLL;
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject (WHITE_BRUSH);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szStubWindowClass;

        RegisterClass(&wc);
    }

    cx = cy = CW_USEDEFAULT;
    if (ppt)
    {
        cx = (int)ppt->x;
        cy = (int)ppt->y;
    }

    if (IS_BIDI_LOCALIZED_SYSTEM()) 
    {
        dwExStyle |= dwExStyleRTLMirrorWnd;
    }
    
    // WS_EX_APPWINDOW makes this show up in ALT+TAB, but not the tray.
        
    return CreateWindowEx(dwExStyle, c_szStubWindowClass, c_szNULL, hwndParent? WS_POPUP : WS_OVERLAPPED, cx, cy, 0, 0, hwndParent, NULL, HINST_THISDLL, NULL);
}


typedef struct  // dlle
{
    HINSTANCE  hinst;
    RUNDLLPROC lpfn;
    BOOL       fCmdIsANSI;
} DLLENTRY;


BOOL _InitializeDLLEntry(LPTSTR lpszCmdLine, DLLENTRY* pdlle)
{
    TCHAR szName[MAXPATHLEN];
    LPTSTR lpStart, lpEnd, lpFunction;
    LPSTR pszFunctionName;
    DWORD cbFunctionName;
    UINT cchLength;

    DebugMsg(DM_TRACE, TEXT("sh TR - RunDLLThread (%s)"), lpszCmdLine);

    for (lpStart=lpszCmdLine; ; )
    {
        // Skip leading blanks
        //
        while (*lpStart == TEXT(' '))
        {
            ++lpStart;
        }

        // Check if there are any switches
        //
        if (*lpStart != TEXT('/'))
        {
            break;
        }

        // Look at all the switches; ignore unknown ones
        //
        for (++lpStart; ; ++lpStart)
        {
            switch (*lpStart)
            {
                case TEXT(' '):
                case TEXT('\0'):
                    goto EndSwitches;
                    break;

                // Put any switches we care about here
                //

                default:
                    break;
            }
        }
EndSwitches:
        ;
    }

    // We have found the DLL,FN parameter
    //
    lpEnd = StrChr(lpStart, TEXT(' '));
    if (lpEnd)
    {
        *lpEnd++ = TEXT('\0');
    }

    // There must be a DLL name and a function name
    //
    lpFunction = StrChr(lpStart, TEXT(','));
    if (!lpFunction)
    {
        return(FALSE);
    }
    *lpFunction++ = TEXT('\0');

    // Load the library and get the procedure address
    // Note that we try to get a module handle first, so we don't need
    // to pass full file names around
    //
    pdlle->hinst = GetModuleHandle(lpStart);
    if ((pdlle->hinst) && GetModuleFileName(pdlle->hinst, szName, ARRAYSIZE(szName)))
    {
        pdlle->hinst = LoadLibrary(szName);
    }
    else
    {
        pdlle->hinst = LoadLibrary(lpStart);
    }

    if (!ISVALIDHINSTANCE(pdlle->hinst))
    {
        return(FALSE);
    }

    /*
    * Look for a 'W' tagged Unicode function.
    * If it is not there, then look for the 'A' tagged ANSI function
    * if we cant find that one either, then look for an un-tagged function
    */
    pdlle->fCmdIsANSI = FALSE;

    cchLength = lstrlen(lpFunction);
    cbFunctionName = (cchLength + 1 + 1) * 2 * sizeof(char);    // +1 for "W", +1 for null terminator, *2 for DBCS

    pszFunctionName = (LPSTR)LocalAlloc(LMEM_FIXED, cbFunctionName);

    if (pszFunctionName)
    {
        if (WideCharToMultiByte(CP_ACP,
                                0,
                                lpFunction,
                                -1,
                                pszFunctionName,
                                cbFunctionName,
                                NULL,
                                NULL))
        {
            cchLength = lstrlenA(pszFunctionName);
            pszFunctionName[cchLength] = 'W';           // convert name to Wide version
            pszFunctionName[cchLength + 1] = '\0';

            pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunctionName);

            if (pdlle->lpfn == NULL)
            {
                // No UNICODE version, try for ANSI
                pszFunctionName[cchLength] = 'A';       // convert name to ANSI version
                pdlle->fCmdIsANSI = TRUE;

                pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunctionName);

                if (pdlle->lpfn == NULL)
                {
                    // No ANSI version either, try for non-tagged
                    pszFunctionName[cchLength] = '\0';  // convert name to non-tagged

                    pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunctionName);
                }
            }
        }

        LocalFree(pszFunctionName);
    }

    if (!pdlle->lpfn)
    {
        if (pdlle->hinst)
        {
            FreeLibrary(pdlle->hinst);
        }

        return FALSE;
    }

    // Copy the rest of the command parameters down
    //
    if (lpEnd)
    {
        MoveMemory(lpszCmdLine, lpEnd, (lstrlen(lpEnd) + 1) * sizeof(TCHAR));
    }
    else
    {
        *lpszCmdLine = TEXT('\0');
    }

    return TRUE;
}

typedef struct tagRunThreadParam {
    int nCmdShow;
    TCHAR szCmdLine[1];
} RUNTHREADPARAM;

DWORD WINAPI _ThreadInitDLL(LPVOID pv)
{
    RUNTHREADPARAM * prtp = (RUNTHREADPARAM*)pv;
    LPTSTR pszCmdLine = (LPTSTR)&prtp->szCmdLine;
    DLLENTRY dlle;

    if (_InitializeDLLEntry(pszCmdLine, &dlle))
    {
        HWND hwndStub=_CreateStubWindow(NULL, NULL);
        if (hwndStub)
        {
            ULONG cchCmdLine = 0;
            SetForegroundWindow(hwndStub);

            if (dlle.fCmdIsANSI)
            {
                //
                // If the function is an ANSI version 
                // Change the command line parameter strings to ANSI before we call the function
                //
                LPSTR pszCmdLineA;
                DWORD cbCmdLineA;

                cbCmdLineA = (lstrlen(pszCmdLine) + 1) * 2 * sizeof(char);  // +1 for null terminator, *2 for dbcs

                pszCmdLineA = (LPSTR)LocalAlloc(LMEM_FIXED, cbCmdLineA);
                if (pszCmdLineA)
                {
                    if (WideCharToMultiByte(CP_ACP, 0, pszCmdLine, -1, pszCmdLineA, cbCmdLineA, NULL, NULL))
                    {
                        dlle.lpfn(hwndStub, g_hinst, (LPTSTR)pszCmdLineA, prtp->nCmdShow);
                    }

                    LocalFree(pszCmdLineA);
                }
            }
            else
            {
                dlle.lpfn(hwndStub, g_hinst, pszCmdLine, prtp->nCmdShow);
            }
            
            DestroyWindow(hwndStub);
        }

        FreeLibrary(dlle.hinst);
    }

    LocalFree((HLOCAL)prtp);

    return 0;
}

BOOL WINAPI SHRunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow)
{
    BOOL fSuccess = FALSE; // assume error
    RUNTHREADPARAM* prtp;
    int cchCmdLine;

    cchCmdLine = lstrlen(pszCmdLine);

    // don't need +1 on lstrlen since szCmdLine is already of size 1 (for NULL)
    prtp = LocalAlloc(LPTR, sizeof(RUNTHREADPARAM) + (cchCmdLine * sizeof(TCHAR)));

    if (prtp)
    {
        DWORD idThread;
        HANDLE hthread = NULL;

        if (SUCCEEDED(StringCchCopy(prtp->szCmdLine, cchCmdLine + 1,  pszCmdLine)))
        {
            hthread = CreateThread(NULL, 0, _ThreadInitDLL, prtp, 0, &idThread);
        }

        if (hthread)
        {
            // We don't need to communicate with this thread any more.
            // Close the handle and let it run and terminate itself.
            //
            // Notes: In this case, prtp will be freed by the thread.
            //
            CloseHandle(hthread);
            fSuccess = TRUE;
        }
        else
        {
            // Thread creation failed, we should free the buffer.
            LocalFree((HLOCAL)prtp);
        }
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\scnotify.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <initguid.h>

#include <dbt.h>
#include "printer.h"
#include <dpa.h>
#include "idltree.h"
#include "scnotifyp.h"
#include "mtpt.h"

#include "shitemid.h"

#include <ioevent.h>

#define TF_SHELLCHANGENOTIFY        0x40000

#define SCNM_REGISTERCLIENT         WM_USER + 1
#define SCNM_DEREGISTERCLIENT       WM_USER + 2
#define SCNM_NOTIFYEVENT            WM_USER + 3
#define SCNM_FLUSHEVENTS            WM_USER + 4
#define SCNM_TERMINATE              WM_USER + 5
#define SCNM_SUSPENDRESUME          WM_USER + 6
#define SCNM_DEREGISTERWINDOW       WM_USER + 7
#define SCNM_AUTOPLAYDRIVE          WM_USER + 8

enum
{
    FLUSH_OVERFLOW = 1,
    FLUSH_SOFT,
    FLUSH_HARD,
    FLUSH_INTERRUPT,
};

#define IDT_SCN_FLUSHEVENTS     1
#define IDT_SCN_FRESHENTREES    2

#define EVENT_OVERFLOW          10

HWND g_hwndSCN = NULL;
CChangeNotify *g_pscn = NULL;
EXTERN_C CRITICAL_SECTION g_csSCN;
CRITICAL_SECTION g_csSCN = {0};

#define PERFTEST(x)

EXTERN_C void SFP_FSEvent        (LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
EXTERN_C int WINAPI RLFSChanged (LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra);
STDAPI CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
STDAPI_(HWND) _SCNGetWindow(BOOL fUseDesktop, BOOL fNeedsFallback);

STDAPI SHChangeNotifyAutoplayDrive(PCWSTR pszDrive)
{
    ASSERT(PathIsRoot(pszDrive));
    HWND hwnd = _SCNGetWindow(TRUE, FALSE);
    if (hwnd)
    {
        DWORD dwProcessID = 0;
        GetWindowThreadProcessId(hwnd, &dwProcessID);
        if (dwProcessID)
        {
            AllowSetForegroundWindow(dwProcessID);
        }
        PostMessage(g_hwndSCN, SCNM_AUTOPLAYDRIVE, DRIVEID(pszDrive), 0);
        return S_OK;
    }
    return E_FAIL;
}

//
//  special folders that are aliases.  these are always running
//  csidlAlias refers to the users perceived namespace
//  csidlReal refers to the actual filesystem folder behind the alias
//
typedef struct ALIASFOLDER {
    int     csidlAlias;
    int     csidlReal;
} ALIASFOLDER, *PALIASFOLDER;

static const ALIASFOLDER s_rgaf[] = {
  {CSIDL_DESKTOP, CSIDL_DESKTOPDIRECTORY},
  {CSIDL_DESKTOP, CSIDL_COMMON_DESKTOPDIRECTORY },
  {CSIDL_PERSONAL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS},
  {CSIDL_NETWORK, CSIDL_NETHOOD},
  {CSIDL_PRINTERS, CSIDL_PRINTHOOD},
};

void InitAliasFolderTable(void)
{
    for (int i = 0; i < ARRAYSIZE(s_rgaf); i++)
    {
        g_pscn->AddSpecialAlias(s_rgaf[i].csidlReal, s_rgaf[i].csidlAlias);
    }
}

#pragma pack(1)
typedef struct {
    WORD cb;
    LONG lEEvent;
} ALIASREGISTER;

typedef struct {
    ALIASREGISTER ar;
    WORD wNull;
} ALIASREGISTERLIST;
#pragma pack()

STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    static const ALIASREGISTERLIST arl = { {sizeof(ALIASREGISTER), SHCNEE_ALIASINUSE}, 0};
    LPITEMIDLIST pidlRegister = ILCombine((LPCITEMIDLIST)&arl, pidlReal);

    if (pidlRegister)
    {
        SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_ONLYNOTIFYINTERNALS | SHCNF_IDLIST, pidlRegister, pidlAlias);
        ILFree(pidlRegister);
    }
}

LPCITEMIDLIST IsAliasRegisterPidl(LPCITEMIDLIST pidl)
{
    ALIASREGISTER *par = (ALIASREGISTER *)pidl;

    if (par->cb == sizeof(ALIASREGISTER)
    && par->lEEvent == SHCNEE_ALIASINUSE)
        return _ILNext(pidl);
    return NULL;
}

LONG g_cAliases = 0;

LPITEMIDLIST TranslateAlias(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    //  see if its child of one of our watched items
    
    LPCITEMIDLIST pidlChild = pidl ? ILFindChild(pidlReal, pidl) : NULL;
    if (pidlChild)
    {
        return ILCombine(pidlAlias, pidlChild);
    }
    return NULL;
}

CAnyAlias::~CAnyAlias()
{
    ILFree(_pidlAlias);

    ATOMICRELEASE(_ptscn);
}

BOOL CCollapsingClient::Init(LPCITEMIDLIST pidl, BOOL fRecursive)
{
    _pidl = ILClone(pidl);
    _fRecursive = fRecursive;
    return (_pidl && _dpaPendingEvents.Create(EVENT_OVERFLOW + 1));
}

BOOL CAnyAlias::Init(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    ASSERT(!_fSpecial);
    _pidlAlias = ILClone(pidlAlias);

    return (_pidlAlias && CCollapsingClient::Init(pidlReal, TRUE));
}

BOOL CAnyAlias::_WantsEvent(LONG lEvent)
{
    return (lEvent & (SHCNE_DISKEVENTS | SHCNE_DRIVEREMOVED | SHCNE_NETSHARE | SHCNE_NETUNSHARE));
}

BOOL CAnyAlias::InitSpecial(int csidlReal, int csidlAlias)
{
    _fSpecial = TRUE;
    _csidlReal = csidlReal;
    _csidlAlias = csidlAlias;

    LPITEMIDLIST pidlNew;

    WIN32_FIND_DATA fd = {0};

    fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY; // Special folders are always directories
    SHGetSpecialFolderPath(NULL, fd.cFileName, csidlReal | CSIDL_FLAG_DONT_VERIFY, FALSE);
    SHSimpleIDListFromFindData(fd.cFileName, &fd, &pidlNew);

    SHGetSpecialFolderLocation(NULL, csidlAlias | CSIDL_FLAG_DONT_VERIFY, &_pidlAlias);

    BOOL fRet = _pidlAlias && CCollapsingClient::Init(pidlNew, TRUE);
    ILFree(pidlNew);
    return fRet;
}

BOOL CAnyAlias::IsAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    // if this hits, an alias has been registered already
    // this means the guy doing the registration isn't doing it at the junction point like
    // theyre supposed to
    ASSERT((ILIsEqual(pidlReal, _pidl) && ILIsEqual(pidlAlias, _pidlAlias)) ||
           !(ILIsParent(_pidl, pidlReal, FALSE) && ILIsParent(_pidlAlias, pidlAlias, FALSE)));

    return (ILIsEqual(pidlReal, _pidl)
         && ILIsEqual(pidlAlias, _pidlAlias));
}

BOOL CAnyAlias::IsSpecial(int csidlReal, int csidlAlias)
{
    return (_fSpecial && csidlReal == _csidlReal && csidlAlias == _csidlAlias);
}

CAnyAlias::_CustomTranslate()
{
    if (!_fCheckedCustom)
    {
        SHBindToObjectEx(NULL, _pidlAlias, NULL, IID_PPV_ARG(ITranslateShellChangeNotify, &_ptscn));
        _fCheckedCustom = TRUE;
    }
    return  (_ptscn != NULL);
}

// some pidl translators may not translate the event.  if we pass on a notifyevent thats identical,
// we'll get into an infinite loop.  our translators are good about this so this doesnt happen, but
// we'll catch it here to be more robust -- we wouldnt want a bad translating shell extension to
// be able to spinlock the changenotify thread.
BOOL CAnyAlias::_OkayToNotifyTranslatedEvent(CNotifyEvent *pne, LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    //  mydocs has an issue where it can be removed from the desktop when 
    //  it is redirected, because the alias only propagates the first
    //  half of the notification (remove). so we dont Translate the remove.
    if (_fSpecial && _csidlAlias == CSIDL_PERSONAL)
    {
        if (pne->lEvent == SHCNE_RENAMEFOLDER || pne->lEvent == SHCNE_RMDIR)
        {
            if (ILIsEqual(pidl, _pidlAlias))
                return FALSE;
        }
    }
    
    // if the original event wasn't already translated, let it proceed.

    // if its a different event, its fine -- a translator could flip-flop between events but we cant detect that case.

    // in addition we need to beware of aliases that translate to themselves or their children --
    // for example a my computer shortcut in the start menu will be registered recursively, so if you try
    // to delete it it will get into a loop.
    // so if the events are the same, verify that both the resultant pidls aren't underneath _pidl.

    return !(pne->uEventFlags & SHCNF_TRANSLATEDALIAS) ||
           (lEvent != pne->lEvent) ||
           !(pidl && ILIsParent(_pidl, pidl, FALSE)) && !(pidlExtra && ILIsParent(_pidl, pidlExtra, FALSE));
}

void CAnyAlias::_SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb)
{
    //
    //  see if its child of one of our watched items
    
    if (_CustomTranslate())
    {
        LPITEMIDLIST pidl1Alias = pne->pidl;
        LPITEMIDLIST pidl1AliasExtra = pne->pidlExtra;
        LPITEMIDLIST pidl2Alias = NULL, pidl2AliasExtra = NULL;
        LONG lEvent1 = pne->lEvent & ~SHCNE_INTERRUPT;  // translator shouldn't see this flag
        LONG lEvent2 = -1;
        if (SUCCEEDED(_ptscn->TranslateIDs(&lEvent1, pne->pidl, pne->pidlExtra, &pidl1Alias, &pidl1AliasExtra,
                                           &lEvent2, &pidl2Alias, &pidl2AliasExtra)))
        {
            if (_OkayToNotifyTranslatedEvent(pne, lEvent1, pidl1Alias, pidl1AliasExtra))
            {
                g_pscn->NotifyEvent(lEvent1, SHCNF_IDLIST | SHCNF_TRANSLATEDALIAS,
                    pidl1Alias, pidl1AliasExtra, 
                    pne->dwEventTime);
            }

            if ((lEvent2 != -1) && _OkayToNotifyTranslatedEvent(pne, lEvent2, pidl2Alias, pidl2AliasExtra))
            {
                g_pscn->NotifyEvent(lEvent2, SHCNF_IDLIST | SHCNF_TRANSLATEDALIAS,
                    pidl2Alias, pidl2AliasExtra,
                    pne->dwEventTime);
            }
            if (pidl1Alias != pne->pidl)
                ILFree(pidl1Alias);
            if (pidl1AliasExtra != pne->pidlExtra)
                ILFree(pidl1AliasExtra);
            ILFree(pidl2Alias);
            ILFree(pidl2AliasExtra);
        }
    }
    else
    {
        LPITEMIDLIST pidlAlias = TranslateAlias(pne->pidl, _pidl, _pidlAlias);
        LPITEMIDLIST pidlAliasExtra = TranslateAlias(pne->pidlExtra, _pidl, _pidlAlias);

        if (pidlAlias || pidlAliasExtra)
        {
            LPCITEMIDLIST pidlNotify = pidlAlias ? pidlAlias : pne->pidl;
            LPCITEMIDLIST pidlNotifyExtra = pidlAliasExtra ? pidlAliasExtra : pne->pidlExtra;
            if (_OkayToNotifyTranslatedEvent(pne, pne->lEvent, pidlNotify, pidlNotifyExtra))
            {
                g_pscn->NotifyEvent(pne->lEvent, SHCNF_IDLIST | SHCNF_TRANSLATEDALIAS,
                    pidlNotify, pidlNotifyExtra,
                    pne->dwEventTime);
            }

            //  do some special handling here
            //  like refresh folders or something will clean out an entry.
            switch (pne->lEvent)
            {
            case SHCNE_UPDATEDIR:
                if (!_fSpecial && ILIsEqual(pne->pidl, _pidl))
                {
                    //  this is target, and it will be refreshed.
                    //  if the alias is still around, then it will
                    //  have to reenum and re-register
                    //  there-fore we will clean this out now.
                    _fRemove = TRUE;
                }
                break;

            default:
                break;
            }
            ILFree(pidlAlias);
            ILFree(pidlAliasExtra);
        }
    }

    //  this is the notify we get when a drive mapping is deleted
    //  when this happens we need to kill the aliases to that drive
    if (pne->lEvent == SHCNE_DRIVEREMOVED)
    {
        if (!_fSpecial && ILIsEqual(pne->pidl, _pidlAlias))
        {
            //  when net drives are removed
            //  pidlExtra is the UNC 
            _fRemove = TRUE;
        }
    }
}

void CAnyAlias::Activate(BOOL fActivate)
{
    if (fActivate)
    {
        ASSERT(_cActivated >= 0);
        if (!_cActivated++)
        {
            // turn this puppy on!
            _fRemove = FALSE;
            if (!_fInterrupt)
                _fInterrupt = g_pscn->AddInterruptSource(_pidl, TRUE);
        }
    }
    else
    {
        ASSERT(_cActivated > 0);
        if (!--_cActivated)
        {
            // now turn it off
            _fRemove = TRUE;
            g_pscn->SetFlush(FLUSH_SOFT);
        }
    }
}
            
void CChangeNotify::_CheckAliasRollover(void)
{
    static DWORD s_tick = 0;
    DWORD tick = GetTickCount();

    if (tick < s_tick)
    {
        // we rolled the tick count over
        CLinkedWalk<CAnyAlias> lw(&_listAliases);
        
        while (lw.Step())
        {
            lw.That()->_dwTime = tick;
        }
    }

    s_tick = tick;
}

CAnyAlias *CChangeNotify::_FindSpecialAlias(int csidlReal, int csidlAlias)
{
    CLinkedWalk<CAnyAlias> lw(&_listAliases);
    
    while (lw.Step())
    {
        CAnyAlias *paa = lw.That();    
        if (paa->IsSpecial(csidlReal, csidlAlias))
        {
            //  we found it
            return paa;
        }
    }
    return NULL;
}

CAnyAlias *CChangeNotify::_FindAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    CLinkedWalk<CAnyAlias> lw(&_listAliases);
    
    while (lw.Step())
    {
        CAnyAlias *paa = lw.That();    
        if (paa->IsAlias(pidlReal, pidlAlias))
        {
            //  we found it
            return paa;
        }
    }
    return NULL;
}

void CChangeNotify::AddSpecialAlias(int csidlReal, int csidlAlias)
{
    CAnyAlias *paa = _FindSpecialAlias(csidlReal, csidlAlias);

    if (!paa)
    {
        CLinkedNode<CAnyAlias> *p = new CLinkedNode<CAnyAlias>;
        if (p)
        {
            if (p->that.InitSpecial(csidlReal, csidlAlias))
            {
                if (_InsertAlias(p))
                    paa = &p->that;
            }

            if (!paa)
                delete p;
        }
    }
}

void CChangeNotify::UpdateSpecialAlias(int csidlAlias)
{
    for (int i = 0; i < ARRAYSIZE(s_rgaf); i++)
    {
        if (csidlAlias == s_rgaf[i].csidlAlias)
        {
            CLinkedNode<CAnyAlias> *p = new CLinkedNode<CAnyAlias>;
            if (p)
            {
                if (!p->that.InitSpecial(s_rgaf[i].csidlReal, csidlAlias)
                || !_InsertAlias(p))
                {
                    delete p;
                }
            }
            break;
        }
    }
}

// the semantic of the return value of this function is not necessarily success or failure,
// since it's possible to stick something in _ptreeAliases with AddData and not be able to
// clean up and remove it with RemoveData (if CompareIDs fails along the way).
// reordering our inserts won't help since g_pscn->AddClient does the same thing.
// so,
// return TRUE == do not free p, something has ownership
// return FALSE == free p, we dont reference it anywhere
BOOL CChangeNotify::_InsertAlias(CLinkedNode<CAnyAlias> *p)
{
    BOOL fRet = _InitTree(&_ptreeAliases); 
    if (fRet)
    {
        fRet = _listAliases.Insert(p);
        if (fRet)
        {
            fRet = SUCCEEDED(_ptreeAliases->AddData(IDLDATAF_MATCH_RECURSIVE, p->that._pidlAlias, (INT_PTR)&p->that));
            if (fRet)
            {
                fRet = g_pscn->AddClient(IDLDATAF_MATCH_RECURSIVE, p->that._pidl, NULL, FALSE, SAFECAST(&p->that, CCollapsingClient *));
                if (fRet)
                {
                    if (_ptreeClients)
                    {
                        // now tell all the registered clients already waiting on this to wake up.
                        CLinkedWalk<CRegisteredClient> lw(&_listClients);

                        while (lw.Step())
                        {
                            if (ILIsParent(p->that._pidlAlias, lw.That()->_pidl, FALSE))
                            {
                                // increase activation count one time on this alias for each client that wants this one.
                                p->that.Activate(TRUE);
                            }
                        }
                    }
                }
                else
                {
                    // if we blow it, then we need to clean up.
                    // right now both the tree and _listAliases have p.
                    _listAliases.Remove(p); // the list always succeeds
                    if (FAILED(_ptreeAliases->RemoveData(p->that._pidlAlias, (INT_PTR)&p->that)))
                    {
                        // oh no!  we added it to the tree but we cant find it to remove it.
                        // return TRUE to prevent freeing it later.
                        fRet = TRUE;
                    }
                }
            }
            else
            {
                // we only have to remove from _listAliases.
                _listAliases.Remove(p); // the list always succeeds
            }
        }
    }
    
    return fRet;
}

void CChangeNotify::AddAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias, DWORD dwEventTime)
{
    CAnyAlias *paa = _FindAlias(pidlReal, pidlAlias);

    if (!paa)
    {
        CLinkedNode<CAnyAlias> *p = new CLinkedNode<CAnyAlias>;
        if (p)
        {
            if (p->that.Init(pidlReal, pidlAlias))
            {
                if (_InsertAlias(p))
                {
                    paa = &p->that;
                    g_cAliases++;
                }
            }

            if (!paa)
                delete p;
        }
    }
    
    if (paa)
    {
        //  we just want to update the time on the existing entry
        paa->_dwTime = dwEventTime;
        paa->_fRemove = FALSE;
        _CheckAliasRollover();
    }
}        

BOOL CAnyAlias::Remove()
{
    if (_fRemove)
    {
        if (_fSpecial)
        {
            //  we dont remove the special aliases, 
            //  we only quiet them a little
            if (_fInterrupt)
            {
                g_pscn->ReleaseInterruptSource(_pidl);
                _fInterrupt = FALSE;
            }
            _fRemove = FALSE;
        }
        else
        {
            return SUCCEEDED(g_pscn->RemoveClient(_pidl, _fInterrupt, SAFECAST(this, CCollapsingClient *)));
        }
    }
    return FALSE;
}
   
void CChangeNotify::_FreshenAliases(void)
{
    CLinkedWalk<CAnyAlias> lw(&_listAliases);

    while (lw.Step())
    {
        CAnyAlias *paa = lw.That();
        if (paa->Remove())
        {
            if (SUCCEEDED(_ptreeAliases->RemoveData(paa->_pidlAlias, (INT_PTR)paa)))
            {
                // if RemoveData failed, we have to leak the client so the tree doesnt point to freed memory.
                lw.Delete();
            }
        }
    }
}
    
void AnyAlias_Change(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    if (lEvent == SHCNE_EXTENDED_EVENT)
    {
        LPCITEMIDLIST pidlAlias = IsAliasRegisterPidl(pidl);
        if (pidlAlias)
            g_pscn->AddAlias(pidlAlias, pidlExtra, dwEventTime);
        else 
        {
            SHChangeDWORDAsIDList *pdwidl = (SHChangeDWORDAsIDList *)pidl;
            if (pdwidl->dwItem1 == SHCNEE_UPDATEFOLDERLOCATION)
            {
                g_pscn->UpdateSpecialAlias(pdwidl->dwItem2);
            }
        }
    }
}

void NotifyShellInternals(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    //  if they are only interested in the real deal
    //  make sure we dont pass them the translated events
    //  this keeps them from getting multiple notifications 
    //  about the same paths, since the alias and the non-alias
    //  pidls will generally resolve to the same parsing name
    //  for the events/pidls that these guys are interested in
    if (!(SHCNF_TRANSLATEDALIAS & uFlags))
    {
        PERFTEST(RLFS_EVENT) RLFSChanged(lEvent, (LPITEMIDLIST)pidl, (LPITEMIDLIST)pidlExtra);
        PERFTEST(SFP_EVENT) SFP_FSEvent(lEvent, pidl,  pidlExtra);
        PERFTEST(ICON_EVENT) CFSFolder_IconEvent(lEvent, pidl,  pidlExtra);
    }
    //  aliases actually can be children of other aliases, so we need
    //  them to get the translated events
    PERFTEST(ALIAS_EVENT) AnyAlias_Change(lEvent, pidl, pidlExtra, dwEventTime);
}

BOOL IsMultiBitSet(LONG l)
{
    return (l && (l & (l-1)));
}

#define CHANGELOCK_SIG          0xbabebabe
#define CHANGEEVENT_SIG         0xfadefade
#define CHANGEREGISTER_SIG      0xdeafdeaf

#ifdef DEBUG

BOOL IsValidChangeEvent(CHANGEEVENT *pce)
{
    return (pce && (pce->dwSig == CHANGEEVENT_SIG)
        && (!IsMultiBitSet(pce->lEvent)));
}

BOOL _LockSizeMatchEvent(CHANGELOCK *pcl)
{
    UINT cbPidlMainAligned = (ILGetSize(pcl->pidlMain) + 3) & ~(0x0000003);       // Round up to dword size
    UINT cbPidlExtra = ILGetSize(pcl->pidlExtra);
    DWORD cbSize = sizeof(CHANGEEVENT) + cbPidlMainAligned + cbPidlExtra;
    return cbSize == pcl->pce->cbSize;
}

BOOL IsValidChangeLock(CHANGELOCK *pcl)
{
    return (pcl && IsValidChangeEvent(pcl->pce)
        && (pcl->dwSig == CHANGELOCK_SIG)
        && _LockSizeMatchEvent(pcl));
}

BOOL IsValidChangeEventHandle(HANDLE h, DWORD id)
{
    CHANGEEVENT *pce = (CHANGEEVENT *)SHLockSharedEx(h, id, FALSE);
#ifdef DEBUG
    BOOL fRet = TRUE; //  can fail in low memory so must default to TRUE
#endif // force DEBUG
    if (pce)
    {
        fRet = IsValidChangeEvent(pce);
        SHUnlockShared(pce);
    }

    return fRet;
}

#define ISVALIDCHANGEEVENTHANDLE(h, id)   IsValidChangeEventHandle(h, id)
#define ISVALIDCHANGEEVENT(p)   IsValidChangeEvent(p)
#define ISVALIDCHANGELOCK(p)    IsValidChangeLock(p)
#define ISVALIDCHANGEREGISTER(p)    TRUE
#endif 

ULONG SHChangeNotification_Destroy(HANDLE hChange, DWORD dwProcId)
{
    ASSERT(ISVALIDCHANGEEVENTHANDLE(hChange, dwProcId));
    TraceMsg(TF_SHELLCHANGENOTIFY, "CHANGEEVENT destroyed [0x%X]", hChange);

    return SHFreeShared(hChange, dwProcId);
}

HANDLE SHChangeNotification_Create(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidlMain, LPCITEMIDLIST pidlExtra, DWORD dwProcId, DWORD dwEventTime)
{
    //  some bad callers send us multiple events
    RIP(!IsMultiBitSet(lEvent));
    if (!IsMultiBitSet(lEvent))
    {
        UINT cbPidlMain = ILGetSize(pidlMain);
        UINT cbPidlMainAligned = (cbPidlMain + 3) & ~(0x0000003);       // Round up to dword size
        UINT cbPidlExtra = ILGetSize(pidlExtra);
        DWORD cbSize = sizeof(CHANGEEVENT) + cbPidlMainAligned + cbPidlExtra;
        HANDLE h = SHAllocShared(NULL, cbSize, dwProcId);
        if (h)
        {
            CHANGEEVENT * pce = (CHANGEEVENT *) SHLockSharedEx(h, dwProcId, TRUE);
            if (pce)
            {
                BYTE *lpb = (LPBYTE)(pce + 1);
                
                pce->cbSize   = cbSize;
                pce->dwSig    = CHANGEEVENT_SIG;
                pce->lEvent   = lEvent;
                pce->uFlags   = uFlags;
                pce->dwEventTime = dwEventTime;

                if (pidlMain)
                {
                    pce->uidlMain = sizeof(CHANGEEVENT);
                    CopyMemory(lpb, pidlMain, cbPidlMain);
                    lpb += cbPidlMainAligned;
                }            

                if (pidlExtra)
                {
                    pce->uidlExtra = (UINT) (lpb - (LPBYTE)pce);
                    CopyMemory(lpb, pidlExtra, cbPidlExtra);
                }
                
                SHUnlockShared(pce);

                TraceMsg(TF_SHELLCHANGENOTIFY, "CHANGEEVENT created [0x%X]", h);
            }
            else
            {
                SHFreeShared(h, dwProcId);
                h = NULL;
            }
        }

        return h;
    }

    return NULL;
}

CHANGELOCK *_SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId)
{
    CHANGEEVENT *pce = (CHANGEEVENT *) SHLockSharedEx(hChange, dwProcId, FALSE);
    if (pce)
    {
#ifdef DEBUG
        if (!ISVALIDCHANGEEVENT(pce))
        {
            // during shell32 development it is convenient to use .local to use
            // a different version of shell32 than the os version.  but then
            // non-explorer processes use the old shell32 which might have
            // a different CHANGEEVENT structure causing this assert to fire
            // and us to fault shortly after.  do this hack check to see if
            // we are in this situation...
            //
            static int nExplorerIsLocalized = -1;
            if (nExplorerIsLocalized < 1)
            {
                TCHAR szPath[MAX_PATH];
                if (GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath)))
                {
                    PathRemoveFileSpec(szPath);
                    PathCombine(szPath, szPath, TEXT("explorer.exe.local"));
                    if (PathFileExists(szPath))
                        nExplorerIsLocalized = 1;
                    else
                        nExplorerIsLocalized = 0;
                }
            }
            if (0==nExplorerIsLocalized)
            {
                // We should never send ourselves an invalid changeevent!
                ASSERT(ISVALIDCHANGEEVENT(pce));
            }
            else
            {
                // Except in this case.  Rip this out once hit -- I haven't been
                // able to repro this in a while...
                ASSERTMSG(ISVALIDCHANGEEVENT(pce), "Press 'g', if this doesn't fault you've validated a known .local bug fix for debug only that's hard to repro but a pain when it does.  Remove this assert.  Thanks.");
                return NULL;
            }

        }
#endif
        CHANGELOCK *pcl = (CHANGELOCK *)LocalAlloc(LPTR, sizeof(CHANGELOCK));
        if (pcl)
        {
            pcl->dwSig = CHANGELOCK_SIG;
            pcl->pce   = pce;
            
            if (pce->uidlMain)
                pcl->pidlMain  = _ILSkip(pce, pce->uidlMain);

            if (pce->uidlExtra)
                pcl->pidlExtra = _ILSkip(pce, pce->uidlExtra);

            return pcl;
        }
        else
            SHUnlockShared(pce);
    }

    return NULL;
}

HANDLE SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId, LPITEMIDLIST **pppidl, LONG *plEvent)
{
    CHANGELOCK *pcl = _SHChangeNotification_Lock(hChange, dwProcId);
    if (pcl)
    {
        //
        // Give back some easy values (causes less code to change for now)
        //
        if (pppidl)
            *pppidl = &(pcl->pidlMain);

        if (plEvent)
            *plEvent = pcl->pce->lEvent;
    }
    return (HANDLE) pcl;
}


BOOL SHChangeNotification_Unlock(HANDLE hLock)
{
    CHANGELOCK *pcl = (CHANGELOCK *)hLock;

    ASSERT(ISVALIDCHANGELOCK(pcl));

    BOOL fRet = SHUnlockShared(pcl->pce);
    LocalFree(pcl); 

    ASSERT(fRet);
    return fRet; 
}

STDMETHODIMP_(ULONG) CNotifyEvent::AddRef()
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_(ULONG) CNotifyEvent::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

BOOL CNotifyEvent::Init(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    if (pidl)
        this->pidl = ILClone(pidl);

    if (pidlExtra)
        this->pidlExtra = ILClone(pidlExtra);

    return ((!pidl || this->pidl) && (!pidlExtra || this->pidlExtra));
}

CNotifyEvent *CNotifyEvent::Create(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags)
{
    CNotifyEvent *p = new CNotifyEvent(lEvent, dwEventTime, uEventFlags);

    if (p)
    {
        if (!p->Init(pidl, pidlExtra))
        {
            //  we failed here
            p->Release();
            p = NULL;
        }
    }

    return p;
}

CCollapsingClient::CCollapsingClient()
{
}

CCollapsingClient::~CCollapsingClient()
{
    ILFree(_pidl);
    if (_dpaPendingEvents)
    {
        int iCount = _dpaPendingEvents.GetPtrCount();
        while (iCount--) 
        {
            CNotifyEvent *pne = _dpaPendingEvents.FastGetPtr(iCount);
            //  to parallel our UsingEvent() call
            pne->Release();
        }
        _dpaPendingEvents.Destroy();
    }
}

ULONG g_ulNextID = 1;
CRegisteredClient::CRegisteredClient()
{
    //
    // Skip ID 0, as this is our error value.
    //
    _ulID = g_ulNextID;
    if (!++g_ulNextID)
        g_ulNextID = 1;
}

CRegisteredClient::~CRegisteredClient()
{
    TraceMsg(TF_SHELLCHANGENOTIFY, "SCN::~CRegisteredClient() [0x%X] id = %d", this, _ulID);
}

BOOL CRegisteredClient::Init(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne)
{
    //  need one or the other
    ASSERT(fSources & (SHCNRF_InterruptLevel | SHCNRF_ShellLevel));
    
    _hwnd = hwnd;
    GetWindowThreadProcessId(hwnd, &_dwProcId);
    _fSources = fSources;
    _fInterrupt = fSources & SHCNRF_InterruptLevel;
    _fEvents = fEvents;
    _wMsg = wMsg;

    LPITEMIDLIST pidlNew;
    if (pfsne->pidl)
        pidlNew = ILClone(pfsne->pidl);
    else
        pidlNew = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, FALSE);

    BOOL fRet = CCollapsingClient::Init(pidlNew, pfsne->fRecursive);
    ILFree(pidlNew);
    return fRet;
}

BOOL CRegisteredClient::_WantsEvent(LONG lEvent)
{
    if (!_fDeadClient && (lEvent & _fEvents))
    {
        //
        //  if this event was generated by an interrupt, and the
        //  client has interrupt notification turned off, we dont want it
        //
        if (lEvent & SHCNE_INTERRUPT)
        {
            if (!(_fSources & SHCNRF_InterruptLevel))
            {
                return FALSE;
            }
        }
        else if (!(_fSources & SHCNRF_ShellLevel))
        {
            //
            //  This event was generated by the shell, and the
            //  client has shell notification turned off, so
            //  we skip it.
            //

            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL CCollapsingClient::_CanCollapse(LONG lEvent)
{
    return (!_CheckUpdatingSelf()
    && (lEvent & SHCNE_DISKEVENTS)
    && !(lEvent & SHCNE_GLOBALEVENTS)
    && (_dpaPendingEvents.GetPtrCount() >= EVENT_OVERFLOW));
}

STDAPI_(BOOL) ILIsEqualEx(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fMatchDepth, LPARAM lParam);

//
// checks for null so we dont assert in ILIsEqual
//
BOOL ILIsEqualOrBothNull(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fMemCmpOnly)
{
    if (!pidl1 || !pidl2)
    {
        return (pidl1 == pidl2);
    }

    if (!fMemCmpOnly)
        return ILIsEqualEx(pidl1, pidl2, TRUE, SHCIDS_CANONICALONLY);
    else
    {
        UINT cb1 = ILGetSize(pidl1);

        return (cb1 == ILGetSize(pidl2) && 0 == memcmp(pidl1, pidl2, cb1));
    }        
}

#define SHCNE_ELIMINATE_DUPE_EVENTS (SHCNE_ATTRIBUTES | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | SHCNE_UPDATEIMAGE | SHCNE_FREESPACE)

BOOL CCollapsingClient::_IsDupe(CNotifyEvent *pne)
{
    BOOL fRet = FALSE;
    if (pne->lEvent & SHCNE_ELIMINATE_DUPE_EVENTS)
    {
        //  look for duplicates starting with the last one
        for (int i = _dpaPendingEvents.GetPtrCount() - 1; !fRet && i >= 0; i--)
        {
            CNotifyEvent *pneMaybe = _dpaPendingEvents.FastGetPtr(i);
            if (pne == pneMaybe)
                fRet = TRUE;
            else if ((pneMaybe->lEvent == pne->lEvent)
            && ILIsEqualOrBothNull(pne->pidl, pneMaybe->pidl, (pne->lEvent & SHCNE_GLOBALEVENTS))
            && ILIsEqualOrBothNull(pne->pidlExtra, pneMaybe->pidlExtra, (pneMaybe->lEvent & SHCNE_GLOBALEVENTS)))
                fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CCollapsingClient::_AddEvent(CNotifyEvent *pneOld, BOOL fFromExtra)
{
    CNotifyEvent *pne = pneOld;
    pne->AddRef();

    BOOL fCollapse = _CanCollapse(pne->lEvent);

    if (fCollapse)
    {
        //
        // If we get too many messages in the queue at any given time,
        // we set the last message in the cue to be an UPDATEDIR that will
        // stand for all messages that we cant fit because the queue is full.
        //
        BOOL fAddSelf = TRUE;
        if (_fRecursive && _dpaPendingEvents.GetPtrCount() < (EVENT_OVERFLOW *2))
        {
            BOOL fFreeUpdate = FALSE;
            LPITEMIDLIST pidlUpdate = fFromExtra ? pne->pidlExtra : pne->pidl;
            DWORD dwAttrs = SFGAO_FOLDER;

            SHGetNameAndFlags(pidlUpdate, 0, NULL, 0, &dwAttrs);
            if (!(dwAttrs & SFGAO_FOLDER))
            {
                pidlUpdate = ILCloneParent(pidlUpdate);
                fFreeUpdate = TRUE;
            }

            if (pidlUpdate)
            {
                if (ILGetSize(pidlUpdate) > ILGetSize(_pidl))
                {
                    pne->Release();

                    //  then we should add this folder to the update list
                    pne = g_pscn->GetEvent(SHCNE_UPDATEDIR, pidlUpdate, NULL, pne->dwEventTime, 0);
                    if (pne)
                    {
                        fAddSelf = FALSE;
                    }
                }

                if (fFreeUpdate)
                    ILFree(pidlUpdate);
            }
        }
        
        if (fAddSelf && pne)
        {
            pne->Release();
            pne = g_pscn->GetEvent(SHCNE_UPDATEDIR, _pidl, NULL, pne->dwEventTime, 0);
        }
    }

    if (pne)
    {
        if (!_IsDupe(pne))
        {
            //  if this is one of our special collapsed
            //  events then we force it in even if we are full
            if ((fCollapse || _dpaPendingEvents.GetPtrCount() < EVENT_OVERFLOW)
            && _dpaPendingEvents.AppendPtr(pne) != -1)
            {
                pne->AddRef();
                g_pscn->SetFlush(FLUSH_SOFT);

                if (!_fUpdatingSelf && (pne->lEvent & SHCNE_UPDATEDIR) && ILIsEqualEx(_pidl, pne->pidl, TRUE, SHCIDS_CANONICALONLY))
                {
                    _fUpdatingSelf = TRUE;
                    _iUpdatingSelfIndex = _dpaPendingEvents.GetPtrCount() - 1;
                }
            }

            //  if we are getting filesystem updates
            //  always pretend that we overflowed
            //  this is because UPDATEDIR's are the
            //  most expensive thing we do.
            if (pne->lEvent & SHCNE_INTERRUPT)
            {
                TraceMsg(TF_SHELLCHANGENOTIFY, "SCN [0x%X]->_AddEvent adding interrupt", this);
                _cEvents += EVENT_OVERFLOW;
            }

            //  count all events even if they 
            //  they werent added.
            _cEvents++;
        }

        pne->Release();
    }

    return TRUE;
}

void CCollapsingClient::Notify(CNotifyEvent *pne, BOOL fFromExtra)
{
    if (_WantsEvent(pne->lEvent))
    {
        _AddEvent(pne, fFromExtra);
    }
}


//--------------------------------------------------------------------------
//  Notifies hCallbackEvent when all the notification packets for
//  all clients in this process have been handled.
//
// This function is primarily called from the FSNotifyThreadProc thread,
// but in flush cases, it can be called from the desktop thread
//
void CALLBACK _DispatchCallbackNoRef(HWND hwnd, UINT uiMsg,
                                DWORD_PTR dwParam, LRESULT result)
{
    MSGEVENT *pme = (MSGEVENT *)dwParam;
    SHChangeNotification_Destroy(pme->hChange, pme->dwProcId);
    delete pme;
}

void CALLBACK _DispatchCallback(HWND hwnd, UINT uiMsg,
                                DWORD_PTR hChange, LRESULT result)
{
    _DispatchCallbackNoRef(hwnd, uiMsg, hChange, result);

    if (EVAL(g_pscn))
        g_pscn->PendingCallbacks(FALSE);
}

void CChangeNotify::PendingCallbacks(BOOL fAdd)
{
    if (fAdd)
    {
        _cCallbacks++;

        ASSERT(_cCallbacks != 0);
        //
        // callback count must be non-zero, we just incremented it.
        // Put the event into the reset/false state.
        //
        if (!_hCallbackEvent)
        {
            _hCallbackEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        }
        else
        {
            ResetEvent(_hCallbackEvent);
        }
    }
    else
    {
        //  
        // PERF: Waits like this happen on flush, but that really cares about flushing that thread
        // only, and this hCallbackEvent is per-process.  So that thread may be stuck
        // waiting for some dead app to respond.  Fortunately the wait is only 30 seconds,
        // but some wedged window could really make the system crawl...
        //
        ASSERT(_cCallbacks != 0);
        _cCallbacks--;

        if (!_cCallbacks && _hCallbackEvent)
        {
            //  we just got the last of our callbacks
            //  signal incase somebody is waiting
            SetEvent(_hCallbackEvent);    
        }
    }
}

BOOL CCollapsingClient::Flush(BOOL fNeedsCallbackEvent)
{
    BOOL fRet = FALSE;
    if (fNeedsCallbackEvent || _cEvents < EVENT_OVERFLOW)
    {
        TraceMsg(TF_SHELLCHANGENOTIFY, "SCN [0x%X]->Flush is completing", this);
        fRet = _Flush(fNeedsCallbackEvent);
    }
    else
    {
        TraceMsg(TF_SHELLCHANGENOTIFY, "SCN [0x%X]->Flush is deferred", this);

        g_pscn->SetFlush(FLUSH_OVERFLOW);
    }

    _cEvents = 0;
    return fRet;
}
    
void CRegisteredClient::_SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb)
{
    //  we could possibly reuse one in some cases
    MSGEVENT * pme = pne->GetNotification(_dwProcId);
    if (pme)
    {
        if (fNeedsCallbackEvent)
        {
            g_pscn->PendingCallbacks(TRUE);
        }

        if (!SendMessageCallback(_hwnd, _wMsg,
                                        (WPARAM)pme->hChange,
                                        (LPARAM)_dwProcId,
                                        pfncb,
                                        (DWORD_PTR)pme))
        {
            pfncb(_hwnd, _wMsg, (DWORD_PTR)pme, 0);
            TraceMsg(TF_WARNING, "(_SHChangeNotifyHandleClientEvents) SendMessageCB timed out");
            
            // if the hwnd is bad, the process probably died,
            // remove the window from future notifications.
            if (!IsWindow(_hwnd))
            {
                _fDeadClient = TRUE;
                //  we failed to Flush
            }
        }
    }
}

BOOL CCollapsingClient::_Flush(BOOL fNeedsCallbackEvent)
{
    if (fNeedsCallbackEvent && _hwnd)
    {
        DWORD_PTR dwResult = 0;
        fNeedsCallbackEvent = (0 != SendMessageTimeout(_hwnd, WM_NULL, 0, 0, SMTO_ABORTIFHUNG, 0, &dwResult));
    }
    SENDASYNCPROC pfncb = fNeedsCallbackEvent ? _DispatchCallback : _DispatchCallbackNoRef;

    BOOL fProcessedAny = FALSE;
    //  as long as there are events keep pulling them out
    while (_dpaPendingEvents.GetPtrCount())
    {
        //
        //  2000JUL3 - ZekeL - remove each one from our dpa so that if we reenter 
        //  a flush during the sendmessage, we wont reprocess the event
        //  this also allows for an event to be added to the dpa while
        //  we proccessing and still be flushed on this pass.
        //
        CNotifyEvent *pne = _dpaPendingEvents.DeletePtr(0);
        if (pne)
        {
            fProcessedAny = TRUE;
            //  we never send this if we are dead
            if (_IsValidClient())
            {
                //
                //  if we are about to refresh this client (_fUpdatingSelf)
                //  only send if we are looking at the UPDATEDIR of _pidl
                //  or if this event is not a disk event.
                //
                if (!_CheckUpdatingSelf()
                || (0 == _iUpdatingSelfIndex) 
                || !(pne->lEvent & SHCNE_DISKEVENTS))
                {
                    BOOL fPreCall = BOOLIFY(_fUpdatingSelf);
                    _SendNotification(pne, fNeedsCallbackEvent, pfncb);
                    if (_fUpdatingSelf && !fPreCall)
                    {
                        // we were re-entered while sending this notification and
                        // during the re-entered call we collapsed notifications.
                        // the _iUpdatingSelfIndex value was set without knowing
                        // that we were going to decrement it after unwinding.
                        // account for that now:
                        _iUpdatingSelfIndex++;
                    }
                }
#ifdef DEBUG
                if (_fUpdatingSelf && 0 == _iUpdatingSelfIndex)
                {
                    // RIP because fault injection 
                    // can make this fail
                    if (!ILIsEqual(_pidl, pne->pidl))
                        TraceMsg(TF_WARNING, "CCollapsingClient::_Flush() maybe mismatched _fUpdatingSelf");
                }
#endif // DEBUG                    
            }
            _iUpdatingSelfIndex--;
            pne->Release();
        }
    }
    _fUpdatingSelf = FALSE;
    return fProcessedAny;
}

HRESULT CChangeNotify::RemoveClient(LPCITEMIDLIST pidl, BOOL fInterrupt, CCollapsingClient *pclient)
{
    HRESULT hr = S_OK;
    // remove this boy from the tree
    if (_ptreeClients)
    {
        hr = _ptreeClients->RemoveData(pidl, (INT_PTR)pclient);

        if (fInterrupt)
            ReleaseInterruptSource(pidl);
    }
    return hr;
}


BOOL CChangeNotify::AddClient(IDLDATAF flags, LPCITEMIDLIST pidl, BOOL *pfInterrupt, BOOL fRecursive, CCollapsingClient *pclient)
{
    BOOL fRet = FALSE;
    if (_InitTree(&_ptreeClients))
    {
        ASSERT(pclient);
        
        if (SUCCEEDED(_ptreeClients->AddData(flags, pidl, (INT_PTR)pclient)))
        {
            fRet = TRUE;
            // set up the interrupt events if desired
            if (pfInterrupt && *pfInterrupt)
            {
                *pfInterrupt = AddInterruptSource(pidl, fRecursive);
            }
        }
    }

    return fRet;
}

LPITEMIDLIST _ILCloneInterruptID(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet = NULL;
    if (pidl)
    {
        TCHAR sz[MAX_PATH];
        if (SHGetPathFromIDList(pidl, sz))
        {
            WIN32_FIND_DATA fd = {0};
            fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;        
            SHSimpleIDListFromFindData(sz, &fd, &pidlRet);
        }
    }
    else // NULL is special for desktop
        pidlRet = SHCloneSpecialIDList(NULL, CSIDL_DESKTOPDIRECTORY, FALSE);
        
    return pidlRet;
}

CInterruptSource *CChangeNotify::_InsertInterruptSource(LPCITEMIDLIST pidl, BOOL fRecursive)
{
    CLinkedNode<CInterruptSource> *p = new CLinkedNode<CInterruptSource>;

    if (p)
    {
        IDLDATAF flags = fRecursive ? IDLDATAF_MATCH_RECURSIVE : IDLDATAF_MATCH_IMMEDIATE;
        if (p->that.Init(pidl, fRecursive)
        && _listInterrupts.Insert(p))
        {
            if (SUCCEEDED(_ptreeInterrupts->AddData(flags, p->that.pidl, (INT_PTR)&p->that)))
            {
                return &p->that;
            }
            else
            {
                _listInterrupts.Remove(p);
                delete p;
            }
        }
        else
            delete p;
    }
    return NULL;
}

BOOL CChangeNotify::AddInterruptSource(LPCITEMIDLIST pidlClient, BOOL fRecursive)
{
    if (_InitTree(&_ptreeInterrupts))
    {
        LPITEMIDLIST pidl = _ILCloneInterruptID(pidlClient);

        if (pidl)
        {
            CInterruptSource *pintc = NULL;

            if (FAILED(_ptreeInterrupts->MatchOne(IDLDATAF_MATCH_EXACT, pidl, (INT_PTR*)&pintc, NULL)))
            {
                pintc = _InsertInterruptSource(pidl, fRecursive);
            }

            ILFree(pidl);

            if (pintc)
            {
                pintc->cClients++;
                return TRUE;
            }
        }
    }
    return FALSE;
}

void CChangeNotify::ReleaseInterruptSource(LPCITEMIDLIST pidlClient)
{
    if (_ptreeInterrupts)
    {
        LPITEMIDLIST pidl = _ILCloneInterruptID(pidlClient);
        if (pidl)
        {
            CInterruptSource *pintc;
            if (SUCCEEDED(_ptreeInterrupts->MatchOne(IDLDATAF_MATCH_EXACT, pidl, (INT_PTR*)&pintc, NULL)))
            {
                if (--(pintc->cClients) == 0)
                {
                    // if RemoveData fails, we have to leak the client so the tree doesnt point to freed memory.
                    if (SUCCEEDED(_ptreeInterrupts->RemoveData(pidl, (INT_PTR)pintc)))
                    {
                        CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

                        while (lw.Step())
                        {
                            if (lw.That() == pintc)
                            {
                                lw.Delete();
                                break;
                            }
                        }
                    }
                }
            }
            ILFree(pidl);
        }
    }
}

void CChangeNotify::_ActivateAliases(LPCITEMIDLIST pidl, BOOL fActivate)
{
    if (_ptreeAliases)
    {
        CIDLMatchMany *pmany;

        if (SUCCEEDED(_ptreeAliases->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
        {
            CAnyAlias *paa;
            while (S_OK == pmany->Next((INT_PTR *)&paa, NULL))
            {
                paa->Activate(fActivate);
            }

            delete pmany;
        }
    }
}

ULONG CChangeNotify::_RegisterClient(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne)
{
    ULONG ulRet = 0;
    CLinkedNode<CRegisteredClient> *p = new CLinkedNode<CRegisteredClient>;

    if (p)
    {
        if (p->that.Init(hwnd, fSources, fEvents, wMsg, pfsne))
        {
            IDLDATAF flags = IDLDATAF_MATCH_IMMEDIATE;
            if (!pfsne->pidl || pfsne->fRecursive)
                flags = IDLDATAF_MATCH_RECURSIVE;

            if (_listClients.Insert(p)  
            && AddClient(   flags, 
                            pfsne->pidl, 
                            &(p->that._fInterrupt), 
                            pfsne->fRecursive && (fSources & SHCNRF_RecursiveInterrupt),
                            SAFECAST(&p->that, CCollapsingClient *)))
            {
#ifdef DEBUG        
                TCHAR szName[MAX_PATH];
                SHGetNameAndFlags(p->that._pidl, 0, szName, ARRAYSIZE(szName), NULL);
                TraceMsg(TF_SHELLCHANGENOTIFY, "SCN::RegCli() added %s [0x%X] id = %d", szName, p, p->that._ulID);
#endif
                _ActivateAliases(pfsne->pidl, TRUE);
                ulRet = p->that._ulID;
            }
        }

        if (!ulRet)
        {
            _listClients.Remove(p);
            delete p;
        }
    }

    return ulRet;
}

BOOL CChangeNotify::_InitTree(CIDLTree**pptree)
{
    if (!*pptree)
    {
        CIDLTree::Create(pptree);
    }

    return *pptree != NULL;
}

CNotifyEvent *CChangeNotify::GetEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags)
{
    return CNotifyEvent::Create(lEvent, pidl, pidlExtra, dwEventTime, uEventFlags);
}

BOOL CChangeNotify::_DeregisterClient(CRegisteredClient *pclient)
{
    TraceMsg(TF_SHELLCHANGENOTIFY, "SCN::RegCli() removing [0x%X] id = %d", pclient, pclient->_ulID);
    if (SUCCEEDED(RemoveClient(pclient->_pidl, pclient->_fInterrupt, SAFECAST(pclient, CCollapsingClient *))))
    {
        _ActivateAliases(pclient->_pidl, FALSE);
        return TRUE;
    }
    return FALSE;
}
    
BOOL CChangeNotify::_DeregisterClientByID(ULONG ulID)
{
    BOOL fRet = FALSE;
    CLinkedWalk <CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        if (lw.That()->_ulID == ulID)
        {
            //  if we are flushing,
            //  then this is coming in while
            //  we are in SendMessageTimeout()
            if (!_cFlushing)
            {
                fRet = _DeregisterClient(lw.That());
                if (fRet)
                {
                    lw.Delete();
                }
            }
            else
                lw.That()->_fDeadClient = TRUE;
                
            break;
        }
    }

    return fRet;
}

BOOL CChangeNotify::_DeregisterClientsByWindow(HWND hwnd)
{
    BOOL fRet = FALSE;
    CLinkedWalk <CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        if (lw.That()->_hwnd == hwnd)
        {
            //  if we are flushing,
            //  then this is coming in while
            //  we are in SendMessageTimeout()
            if (!_cFlushing)
            {
                fRet = _DeregisterClient(lw.That());
                if (fRet)
                {
                    lw.Delete();
                }
            }
            else
                lw.That()->_fDeadClient = TRUE;
        }
    }

    return fRet;
}

void CChangeNotify::_AddGlobalEvent(CNotifyEvent *pne)
{
    CLinkedWalk <CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        lw.That()->Notify(pne, FALSE);
    }

    //  this is the notify we get when a drive mapping is deleted
    //  when this happens we need to kill the aliases to that drive
    if ((pne->lEvent == SHCNE_DRIVEREMOVED) && !(pne->uEventFlags & SHCNF_TRANSLATEDALIAS))
    {
        CLinkedWalk<CAnyAlias> lw(&_listAliases);
        while (lw.Step())
        {
            lw.That()->Notify(pne, FALSE);
        }
    }
}


void CChangeNotify::_MatchAndNotify(LPCITEMIDLIST pidl, CNotifyEvent *pne, BOOL fFromExtra)
{
    if (_ptreeClients)
    {
        CIDLMatchMany *pmany;

        if (SUCCEEDED(_ptreeClients->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
        {
            CCollapsingClient *pclient;
            while (S_OK == pmany->Next((INT_PTR *)&pclient, NULL))
            {
                pclient->Notify(pne, fFromExtra);
            }

            delete pmany;
        }
    }
}

BOOL CChangeNotify::_AddToClients(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags)
{
    BOOL bOnlyUpdateDirs = TRUE;

    CNotifyEvent *pne = GetEvent(lEvent, pidl, pidlExtra, dwEventTime, uEventFlags);

    if (pne)
    {
        if (lEvent & SHCNE_GLOBALEVENTS)
        {
            _AddGlobalEvent(pne);
        }
        else
        {
            _MatchAndNotify(pidl, pne, FALSE);

            if (pidlExtra)
                _MatchAndNotify(pidlExtra, pne, TRUE);
        }

        pne->Release();
    }

    return bOnlyUpdateDirs;
}

BOOL CChangeNotify::_HandleMessages(void)
{
    MSG msg;
    // There was some message put in our queue, so we need to dispose
    // of it
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (msg.hwnd)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else
        {
            switch (msg.message)
            {
            case SCNM_TERMINATE:
                DestroyWindow(g_hwndSCN);
                g_hwndSCN = NULL;
                return TRUE;
                break;
                
            default:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SCN thread proc: eating unknown message %#lx", msg.message);
                break;
            }
        }
    }
    return FALSE;
}

CInterruptSource::~CInterruptSource()
{
    _Reset(TRUE);
    ILFree(pidl);
}

BOOL CInterruptSource::Init(LPCITEMIDLIST pidl, BOOL fRecursive)
{
    this->pidl = ILClone(pidl);
    _fRecursive = fRecursive;
    return (this->pidl != NULL);
}

BOOL CInterruptSource::Flush(void)
{
    if (FS_SIGNAL == _ssSignal)
    {
        g_pscn->NotifyEvent(SHCNE_UPDATEDIR | SHCNE_INTERRUPT, SHCNF_IDLIST, pidl, NULL, GetTickCount());
    }

    _ssSignal = NO_SIGNAL;

    return TRUE;
}

void CInterruptSource::_Reset(BOOL fDeviceNotify)
{
    if (_hEvent && _hEvent != INVALID_HANDLE_VALUE)
    {
        FindCloseChangeNotification(_hEvent);
        _hEvent = NULL;
    }

    if (fDeviceNotify && _hPNP)
    {
        UnregisterDeviceNotification(_hPNP);
        _hPNP = NULL;
    }
}

void CInterruptSource::Reset(BOOL fSignal)
{
    if (fSignal)           // file system event
    {
        switch(_ssSignal)
        {
            case NO_SIGNAL:  _ssSignal = FS_SIGNAL;  break;
            case SH_SIGNAL:  _ssSignal = NO_SIGNAL;  break;
        }

        if (!FindNextChangeNotification(_hEvent))
        {
            _Reset(FALSE);
            //  when we fail, we dont want
            //  to retry.  which we will do
            //  in the case of _hEvent = NULL;
            _hEvent = INVALID_HANDLE_VALUE;
        }
    }
    else                   // shell event
    {
        switch(_ssSignal)
        {
            case NO_SIGNAL:  _ssSignal = SH_SIGNAL;  break;
            case FS_SIGNAL:  _ssSignal = NO_SIGNAL;  break;
        }
    }
}

#define FFCN_INTERESTING_EVENTS     (FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_ATTRIBUTES)

BOOL CInterruptSource::GetEvent(HANDLE *phEvent)
{
    if (_cSuspend == 0 && cClients)
    {
        // create this here so that it will be owned by our global thread
        if (!_hEvent)
        {
            TCHAR szPath[MAX_PATH];
            if (SHGetPathFromIDList(pidl, szPath))
            {
                _hEvent = FindFirstChangeNotification(szPath, _fRecursive, FFCN_INTERESTING_EVENTS);

                if (_hEvent != INVALID_HANDLE_VALUE)
                {
                    // PERF optimization alert: RegisterDeviceNotification is being used for removable drives
                    // to ensure that the FindFirstChangeNotification call will not prevent the disk
                    // from being ejected or dismounted. However, RegisterDeviceNotification is a very expensive
                    // call to make at startup as it brings a bunch of DLLs in the address space. Besides,
                    // we really don't need to call this for the system drive since it needs to remain 
                    // mounted at all times. - FabriceD

                    // Exclude FIXED drives too
                    int iDrive = PathGetDriveNumber(szPath);
                    int nType = DRIVE_UNKNOWN;
                    if (iDrive != -1)
                    {
                        nType = DriveType(iDrive);
                    }

                    // PERF: Exclude the system drive from the RegisterDeviceNotification calls.
                    TCHAR chDrive = *szPath;
                    if ((!GetEnvironmentVariable(TEXT("SystemDrive"), szPath, ARRAYSIZE(szPath)) || *szPath != chDrive) &&
                            nType != DRIVE_FIXED)
                    {
                        //  DO WE NEED TO UnRegister() first?
                        DEV_BROADCAST_HANDLE dbh;
                        ZeroMemory(&dbh, sizeof(dbh));
                        dbh.dbch_size = sizeof(dbh);
                        dbh.dbch_devicetype = DBT_DEVTYP_HANDLE;
                        dbh.dbch_handle = _hEvent;
                        _hPNP = RegisterDeviceNotification(g_hwndSCN, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
                    }
                }
            }
            else
                _hEvent = INVALID_HANDLE_VALUE;
        }

        if (_hEvent != INVALID_HANDLE_VALUE)
        {
            *phEvent = _hEvent;
            return TRUE;
        }
    }
    return FALSE;
}
    
void CChangeNotify::_SignalInterrupt(HANDLE hEvent)
{
    CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

    while (lw.Step())
    {   
        //  searching for valid clients
        HANDLE h;
        if (lw.That()->GetEvent(&h) && h == hEvent)
        {
            g_pscn->SetFlush(FLUSH_INTERRUPT);
            lw.That()->Reset(TRUE);
            break;
        }
    }
}

DWORD CChangeNotify::_GetInterruptEvents(HANDLE *ahEvents, DWORD cEventsSize)
{
    DWORD cEvents = 0;
    CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

    while (cEvents < cEventsSize && lw.Step())
    {   
        //  go through and find all the valid
        //  clients that need waiting on
        if (lw.That()->GetEvent(&ahEvents[cEvents]))
        {
//            lw.That()->Reset(FALSE);
            cEvents++;
        }
    }

    return cEvents;
}

void CChangeNotify::_MessagePump(void)
{
    DWORD cFails = 0;
    while (TRUE)
    {
        HANDLE ahEvents[MAXIMUM_WAIT_OBJECTS - 1];
        DWORD cEvents = _GetInterruptEvents(ahEvents, ARRAYSIZE(ahEvents));
        //  maybe cache the events?
        
        //  NEED to handle pending Events with a Timer

        DWORD dwWaitResult = MsgWaitForMultipleObjectsEx(cEvents, ahEvents,
                INFINITE, QS_ALLINPUT, MWMO_ALERTABLE);
        if (dwWaitResult != (DWORD)-1)
        {
            if (dwWaitResult != WAIT_IO_COMPLETION)
            {
                dwWaitResult -= WAIT_OBJECT_0;
                if (dwWaitResult == cEvents)
                {
                    //  there is a message
                    if (_HandleMessages())
                        break;
                } 
                else if (dwWaitResult < cEvents) 
                {
                    _SignalInterrupt(ahEvents[dwWaitResult]);
                }
            }

            cFails = 0;
        }
        else
        {
            //  there was some kind of error
            TraceMsg(TF_ERROR, "SCNotify WaitForMulti() failed with %d", GetLastError());
            //  if MWFM() fails over and over, we give up.
            if (++cFails > 10)
            {
                TraceMsg(TF_ERROR, "SCNotify WaitForMulti() bailing out");
                break;
            }
        }
    }
}

void SCNUninitialize(void)
{
    if (g_pscn)
    {
        if (IsWindow(g_hwndSCN))
            DestroyWindow(g_hwndSCN);
        g_hwndSCN = NULL;

        delete g_pscn;
        g_pscn = NULL;
    }
}

// the real thread proc, runs after CChangeNotify::ThreadStartUp runs sync

DWORD WINAPI CChangeNotify::ThreadProc(void *pv)
{
    if (g_pscn)
    {
        CMountPoint::RegisterForHardwareNotifications();

#ifdef RESTARTSCN
        __try 
#endif
        {
            g_pscn->_MessagePump();
        }
#ifdef RESTARTSCN
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ASSERT(FALSE);
        }
#endif
    }
    SCNUninitialize();
    return 0;
}

BOOL CChangeNotify::_OnChangeRegistration(HANDLE hChangeRegistration, DWORD dwProcId)
{
    BOOL fResult = FALSE;
    CHANGEREGISTER *pcr = (CHANGEREGISTER *)SHLockSharedEx(hChangeRegistration, dwProcId, TRUE);
    if (pcr)
    {
        SHChangeNotifyEntry fsne;

        fsne.pidl = NULL;
        fsne.fRecursive = pcr->fRecursive;
        if (pcr->uidlRegister)
            fsne.pidl = _ILSkip(pcr, pcr->uidlRegister);

        pcr->ulID = _RegisterClient((HWND)ULongToPtr(pcr->ulHwnd), pcr->fSources,
                                pcr->lEvents, pcr->uMsg, &fsne);
        fResult = TRUE;
        SHUnlockShared(pcr);
    }
    return fResult;
}

void CChangeNotify::_ResetRelatedInterrupts(LPCITEMIDLIST pidl)
{
    if (_ptreeInterrupts)
    {
        //  we need to match whoever listens on this pidl
        CIDLMatchMany *pmany;

        if (SUCCEEDED(_ptreeInterrupts->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
        {
            CInterruptSource *pintc;
            while (S_OK == pmany->Next((INT_PTR *)&pintc, NULL))
            {
                //  we might need WFSO(pintc->GetEvent()) here first
                //  if this is already signaled,
                //  we need to unsignal
                pintc->Reset(FALSE);
            }
            delete pmany;
        }
    }
}

void CChangeNotify::_FlushInterrupts(void)
{
    CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

    while (lw.Step())
    {   
        lw.That()->Flush();
    }
}


#define CALLBACK_TIMEOUT    30000       // 30 seconds
void CChangeNotify::_WaitForCallbacks(void)
{
    while (_cCallbacks && _hCallbackEvent)
    {
        MSG msg;
        DWORD dwWaitResult = MsgWaitForMultipleObjects(1, &_hCallbackEvent, FALSE,
                              CALLBACK_TIMEOUT, QS_SENDMESSAGE);

        TraceMsg(TF_SHELLCHANGENOTIFY, "FSN_WaitForCallbacks returned 0x%X", dwWaitResult);
        if (dwWaitResult == WAIT_OBJECT_0) break;   // Event completed
        if (dwWaitResult == WAIT_TIMEOUT)  break;   // Ran out of time

        if (dwWaitResult == WAIT_OBJECT_0+1) 
        {
            //
            // Some message came in, reset message event, deliver callbacks, etc.
            //
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);  // we need to do this to flush callbacks
        }
    } 

    if (_hCallbackEvent)
    {
        CloseHandle(_hCallbackEvent);
        _hCallbackEvent = NULL;
    }
}

void CChangeNotify::SetFlush(int idt)
{
    switch (idt)
    {
    case FLUSH_OVERFLOW:
    case FLUSH_SOFT:
        SetTimer(g_hwndSCN, IDT_SCN_FLUSHEVENTS, 500, NULL);
        break;
        
    case FLUSH_HARD:
        PostMessage(g_hwndSCN, SCNM_FLUSHEVENTS, 0, 0);
        break;
        
    case FLUSH_INTERRUPT:
        SetTimer(g_hwndSCN, IDT_SCN_FLUSHEVENTS, 1000, NULL);
        break;
    }
}
    

void CChangeNotify::_Flush(BOOL fShouldWait)
{
    _cFlushing++;
    KillTimer(g_hwndSCN, IDT_SCN_FLUSHEVENTS);
    // flush any pending interrupt events
    _FlushInterrupts();

    int iNumLoops = 0;
    BOOL fProcessedAny;
    do
    {
        fProcessedAny = FALSE;
        CLinkedWalk<CAnyAlias> lwAliases(&_listAliases);
        while (lwAliases.Step())
        {
            if (lwAliases.That()->Flush(TRUE))
            {
                fProcessedAny = TRUE;
            }
        }

        iNumLoops++;
        // in free builds bail out if there's a loop so we don't spin the thread.
        // but this is pretty bad so assert anyway (the most people would usually have
        // is 2 -- a folder shortcut to something on the desktop / mydocs)
        ASSERTMSG(iNumLoops < 10, "we're in an alias loop, we're screwed");
    } while (fProcessedAny && (iNumLoops < 10));

    CLinkedWalk<CRegisteredClient> lwRegistered(&_listClients);
    while (lwRegistered.Step())
    {
        lwRegistered.That()->Flush(fShouldWait);
    }

    if (fShouldWait)
    {
        // now wait for all the callbacks to empty out
        _WaitForCallbacks();
    }
    _cFlushing--;

    //  wait until we have 10 seconds of free time
    SetTimer(g_hwndSCN, IDT_SCN_FRESHENTREES, 10000, NULL);
}

BOOL IsILShared(LPCITEMIDLIST pidl, BOOL fUpdateCache)
{
    TCHAR szTemp[MAXPATHLEN];
    SHGetPathFromIDList(pidl, szTemp);
    return IsShared(szTemp, fUpdateCache);
}

void CChangeNotify::NotifyEvent(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    if (!(uFlags & SHCNF_ONLYNOTIFYINTERNALS) && lEvent)
    {
        /// now do the actual generating of the event
        if (lEvent & (SHCNE_NETSHARE | SHCNE_NETUNSHARE))
        {
            // Update the cache.

            IsILShared(pidl, TRUE);
        }

        _AddToClients(lEvent, pidl, pidlExtra, dwEventTime, uFlags);

        // remove any shell generated events for the file system
        if ((lEvent & SHCNE_DISKEVENTS) &&
            !(lEvent & (SHCNE_INTERRUPT | SHCNE_UPDATEDIR)))
        {
            _ResetRelatedInterrupts(pidl);

            if (pidlExtra)
                _ResetRelatedInterrupts(pidlExtra);

        }
    }

    // note make sure the internal events go first.
    if (lEvent)
        NotifyShellInternals(lEvent, uFlags, pidl, pidlExtra, dwEventTime);

    //
    // then the registered events
    //
    if (uFlags & (SHCNF_FLUSH)) 
    {
        if (uFlags & SHCNF_FLUSHNOWAIT)
        {
            SetFlush(FLUSH_HARD);
        }
        else
            _Flush(TRUE);
    }
}

LRESULT CChangeNotify::_OnNotifyEvent(HANDLE hChange, DWORD dwProcId)
{
    CHANGELOCK *pcl = _SHChangeNotification_Lock(hChange, dwProcId);
    if (pcl)
    {
        NotifyEvent(pcl->pce->lEvent,
                                pcl->pce->uFlags,
                                pcl->pidlMain,
                                pcl->pidlExtra,
                                pcl->pce->dwEventTime);
        SHChangeNotification_Unlock(pcl);
        SHChangeNotification_Destroy(hChange, dwProcId);
    }
    return TRUE;
}


void CInterruptSource::Suspend(BOOL fSuspend) 
{ 
    if (fSuspend) 
    {
        if (!_cSuspend)
            _Reset(FALSE);

        _cSuspend++; 
    }
    else if (_cSuspend)
        _cSuspend--; 
}

BOOL CChangeNotify::_SuspendResume(BOOL fSuspend, BOOL fRecursive, LPCITEMIDLIST pidl)
{
    if (_ptreeInterrupts)
    {
        CInterruptSource *pintc;
        if (!fRecursive)
        {
            if (SUCCEEDED(_ptreeInterrupts->MatchOne(IDLDATAF_MATCH_EXACT, pidl, (INT_PTR*)&pintc, NULL)))
            {
                pintc->Suspend(fSuspend);
            }
        }
        else
        {
            CIDLMatchMany *pmany;
            if (SUCCEEDED(_ptreeInterrupts->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
            {
                while (S_OK == pmany->Next((INT_PTR *)&pintc, NULL))
                {
                    pintc->Suspend(fSuspend);
                }
                delete pmany;
            }
        }
    }
    return TRUE;
}

#define SCNSUSPEND_SUSPEND      1
#define SCNSUSPEND_RECURSIVE    2

LRESULT CChangeNotify::_OnSuspendResume(HANDLE hChange, DWORD dwProcId)
{
    BOOL fRet = FALSE;
    CHANGELOCK *pcl = _SHChangeNotification_Lock(hChange, dwProcId);
    if (pcl)
    {
        fRet = _SuspendResume(pcl->pce->uFlags & SCNSUSPEND_SUSPEND, pcl->pce->uFlags & SCNSUSPEND_RECURSIVE, pcl->pidlMain);
        SHChangeNotification_Unlock((HANDLE)pcl);
    }
    return fRet;
}

BOOL CInterruptSource::SuspendDevice(BOOL fSuspend, HDEVNOTIFY hPNP)
{
    BOOL fRet = FALSE;
    if (hPNP)
    {
        if (fSuspend && _hPNP == hPNP)
        {
            _hSuspended = _hPNP;
            Suspend(fSuspend);
            _Reset(TRUE);
            fRet = TRUE;
        }
        else if (!fSuspend && _hSuspended == hPNP)
        {
            _hSuspended = NULL;
            Suspend(fSuspend);
            fRet = TRUE;
        }
    }
    else if (_hPNP)
    {
        // NULL means we are shutting down and should close all handles.
        UnregisterDeviceNotification(_hPNP);
        _hPNP = NULL;
    }
    return fRet;
}

//  __HandleDevice
void CChangeNotify::_OnDeviceBroadcast(ULONG_PTR code, DEV_BROADCAST_HANDLE *pbhnd)
{
    if (IsWindowVisible(GetShellWindow()) && pbhnd
    && (pbhnd->dbch_devicetype == DBT_DEVTYP_HANDLE && pbhnd->dbch_hdevnotify))
    {
        BOOL fSuspend;
        switch (code)
        {

        // When PnP is finished messing with the drive (either successfully
        // or unsuccessfully), resume notifications on that drive.
        case DBT_DEVICEREMOVECOMPLETE:
        case DBT_DEVICEQUERYREMOVEFAILED:
            fSuspend = FALSE;
            break;

        // When PnP is starting to mess with the drive, suspend notifications
        // so it can do its thing
        case DBT_DEVICEQUERYREMOVE:

            // This will wait on another thread to exit if this hdevnotify
            // was registered for a Sniffing Dialog
            CSniffDrive::HandleNotif(pbhnd->dbch_hdevnotify);

            fSuspend = TRUE;
            break;

        case DBT_CUSTOMEVENT:
            if (GUID_IO_VOLUME_LOCK == pbhnd->dbch_eventguid)
            {
                TraceMsg(TF_MOUNTPOINT, "GUID_IO_VOLUME_LOCK: Suspending!");
                fSuspend = TRUE;
            }
            else
            {
                if (GUID_IO_VOLUME_LOCK_FAILED == pbhnd->dbch_eventguid)
                {
                    TraceMsg(TF_MOUNTPOINT, "GUID_IO_VOLUME_LOCK_FAILED: Resuming!");
                    fSuspend = FALSE;
                }
                else
                {
                    if (GUID_IO_VOLUME_UNLOCK == pbhnd->dbch_eventguid)
                    {
                        TraceMsg(TF_MOUNTPOINT, "GUID_IO_VOLUME_UNLOCK: Resuming!");
                        fSuspend = FALSE;
                    }
                }
            }
            
            break;

        default:
            //  we dont handle anything else here
            return;
        }

        CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

        while (lw.Step())
        {
            //  returns true if found
            if (lw.That()->SuspendDevice(fSuspend, pbhnd->dbch_hdevnotify))
                break;
        }
    }
}

void CChangeNotify::_FreshenClients(void)
{
    CLinkedWalk<CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        if (lw.That()->_fDeadClient || !IsWindow(lw.That()->_hwnd))
        {
            if (_DeregisterClient(lw.That()))
            {
                lw.Delete();
            }
        }
    }
}

void CChangeNotify::_FreshenUp(void)
{
    ASSERT(!_cFlushing);
    KillTimer(g_hwndSCN, IDT_SCN_FRESHENTREES);
    
    if (_ptreeClients)
        _ptreeClients->Freshen();

    if (_ptreeInterrupts)
        _ptreeInterrupts->Freshen();

    _FreshenAliases();
    _FreshenClients();
}

LRESULT CChangeNotify::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = 0;
    ASSERT(g_pscn);

    switch (uMsg)
    {
    case SCNM_REGISTERCLIENT:
        lRes = g_pscn->_OnChangeRegistration((HANDLE)wParam, (DWORD)lParam);
        break;

    case SCNM_DEREGISTERCLIENT:
        lRes = g_pscn->_DeregisterClientByID((ULONG)wParam);
        break;

    case SCNM_DEREGISTERWINDOW:
        lRes = g_pscn->_DeregisterClientsByWindow((HWND)wParam);
        break;
        
    case SCNM_NOTIFYEVENT:
        lRes = g_pscn->_OnNotifyEvent((HANDLE)wParam, (DWORD)lParam);
        break;
        
    case SCNM_SUSPENDRESUME:
        lRes = g_pscn->_OnSuspendResume((HANDLE)wParam, (DWORD)lParam);
        break;

    case WM_TIMER:
        if (wParam == IDT_SCN_FRESHENTREES)
        {
            g_pscn->_FreshenUp();
            break;
        }
        // Fall through to SCNM_FLUSHEVENTS
    case SCNM_FLUSHEVENTS:
        g_pscn->_Flush(FALSE);
        break;

    case SCNM_AUTOPLAYDRIVE:
        CMountPoint::DoAutorunPrompt(wParam);
        break;
        
    case WM_DEVICECHANGE:
        g_pscn->_OnDeviceBroadcast(wParam, (DEV_BROADCAST_HANDLE *)lParam);
        break;

    default:
        lRes = DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    }

    return lRes;
}

// thread setup routine, executed before SHCreateThread() returns

DWORD WINAPI CChangeNotify::ThreadStartUp(void *pv)
{
    g_pscn = new CChangeNotify();
    if (g_pscn)
    {
        g_hwndSCN = SHCreateWorkerWindow(CChangeNotify::WndProc, NULL, 0, 0, NULL, g_pscn);

        CSniffDrive::InitNotifyWindow(g_hwndSCN);

        InitAliasFolderTable();
    }
    return 0;
}

// now we create the window
BOOL SCNInitialize()
{
    EnterCriticalSection(&g_csSCN);
    if (!IsWindow(g_hwndSCN))
    {
        SHCreateThread(CChangeNotify::ThreadProc, NULL, CTF_COINIT, CChangeNotify::ThreadStartUp);
    }
    LeaveCriticalSection(&g_csSCN);
    return g_hwndSCN ? TRUE : FALSE;    // ThreadStartUp is executed sync
}

BOOL _IsImpersonating()
{
    HANDLE hToken;
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        CloseHandle(hToken);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(HWND) _SCNGetWindow(BOOL fUseDesktop, BOOL fNeedsFallback)
{
    //  if explorer is trashed
    //  then this hwnd can go bad
    //  get a new copy from the desktop
    if (!g_hwndSCN || !IsWindow(g_hwndSCN))
    {
        HWND hwndDesktop = fUseDesktop ? GetShellWindow() : NULL;
        if (hwndDesktop)
        {
            HWND hwndSCN = (HWND) SendMessage(hwndDesktop, CWM_GETSCNWINDOW, 0, 0);
            if (_IsImpersonating())
                return hwndSCN;
            else
                g_hwndSCN = hwndSCN;
        }
        else if (fNeedsFallback && SHIsCurrentThreadInteractive())
        {
            //  there is no desktop.
            //  so we create a private desktop
            //  this will create the thread and window
            //  and set
            SCNInitialize();
        }
    }

    return g_hwndSCN;
}

STDAPI_(HWND) SCNGetWindow(BOOL fUseDesktop)
{
    return _SCNGetWindow(fUseDesktop, TRUE);
}

HANDLE SHChangeRegistration_Create(ULONG ulID,
                                    HWND hwnd, UINT uMsg,
                                    DWORD fSources, LONG lEvents,
                                    BOOL fRecursive, LPCITEMIDLIST pidl,
                                    DWORD dwProcId)
{
    UINT uidlSize = ILGetSize(pidl);
    HANDLE hReg = SHAllocShared(NULL, sizeof(CHANGEREGISTER) + uidlSize, dwProcId);
    if (hReg)
    {
        CHANGEREGISTER *pcr = (CHANGEREGISTER *) SHLockSharedEx(hReg, dwProcId, TRUE);
        if (pcr)
        {
            pcr->dwSig        = CHANGEREGISTER_SIG;
            pcr->ulID         = ulID;
            pcr->ulHwnd       = PtrToUlong(hwnd);
            pcr->uMsg         = uMsg;
            pcr->fSources     = fSources;
            pcr->lEvents      = lEvents;
            pcr->fRecursive   = fRecursive;
            pcr->uidlRegister = 0;

            if (pidl)
            {
                pcr->uidlRegister = sizeof(CHANGEREGISTER);
                memcpy((pcr + 1), pidl, uidlSize);
            }
            SHUnlockShared(pcr);
        }
        else
        {
            SHFreeShared(hReg, dwProcId);
            hReg = NULL;
        }

    }

    return hReg;
}

typedef struct 
{
    HWND hwnd;
    UINT wMsg;
} NOTIFY_PROXY_DATA;
#define WM_CHANGENOTIFYMSG    WM_USER + 1
LRESULT CALLBACK _HiddenNotifyWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;
    NOTIFY_PROXY_DATA *pData = (NOTIFY_PROXY_DATA *) GetWindowLongPtr( hWnd, 0 );

    switch (iMessage)
    {
     case WM_NCDESTROY:
        ASSERT(pData != NULL );

        // clear it so it won't be in use....
        SetWindowLongPtr( hWnd, 0, (LONG_PTR)NULL );

        // free the memory ...
        LocalFree( pData );
        break;

    case WM_CHANGENOTIFYMSG :
        if (pData)
        {
            // lock and break the info structure ....
            LPITEMIDLIST *ppidl;
            LONG lEvent;
            HANDLE hLock = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);

            if (hLock)
            {
                // pass on to the old style client. ...
                lRes = SendMessage( pData->hwnd, pData->wMsg, (WPARAM) ppidl, (LPARAM) lEvent );

                // new notifications ......
                SHChangeNotification_Unlock(hLock);
            }
        }
        break;

    default:
        lRes = DefWindowProc(hWnd, iMessage, wParam, lParam);
        break;
    }

    return lRes;
}


HWND _CreateProxyWindow(HWND hwnd, UINT wMsg)
{
    HWND hwndRet = NULL;
    // This is an old style notification, we need to create a hidden
    // proxy type of window to properly handle the messages...

    NOTIFY_PROXY_DATA *pnpd = (NOTIFY_PROXY_DATA *)LocalAlloc(LPTR, sizeof(*pnpd));

    if (pnpd)
    {
        pnpd->hwnd = hwnd;
        pnpd->wMsg = wMsg;

        hwndRet = SHCreateWorkerWindow(_HiddenNotifyWndProc, NULL, 0, 0, NULL, pnpd);

        if (!hwndRet)
            LocalFree(pnpd);

    }

    return hwndRet;
}
            


//--------------------------------------------------------------------------
//
//  Returns a positive integer registration ID, or 0 if out of memory or if
//  invalid parameters were passed in.
//
//  If the hwnd is != NULL we do a PostMessage(hwnd, wMsg, ...) when a
//  relevant FS event takes place, otherwise if fsncb is != NULL we call it.
//
STDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd,
                               int fSources, LONG fEvents,
                               UINT wMsg, int cEntries,
                               SHChangeNotifyEntry *pfsne)
{
    ULONG ulID = 0;
    BOOL fResult = FALSE;
    HWND hwndSCN = SCNGetWindow(TRUE);

    if (hwndSCN)
    {
        if (!(fSources & SHCNRF_NewDelivery))
        {
            // Now setup to use the proxy window instead
            hwnd = _CreateProxyWindow(hwnd, wMsg);
            wMsg = WM_CHANGENOTIFYMSG;
        }

        if ((fSources & SHCNRF_RecursiveInterrupt) && !(fSources & SHCNRF_InterruptLevel))
        {
            // bad caller, they asked for recursive interrupt events, but not interrupt events
            ASSERTMSG(FALSE, "SHChangeNotifyRegister: caller passed SHCNRF_RecursiveInterrupt but NOT SHCNRF_InterruptLevel !!");

            // clear the flag
            fSources = fSources & (~SHCNRF_RecursiveInterrupt);
        }

        // This same assert is CRegisteredClient::Init, caled by SCNM_REGISTERCLIENT message below
        ASSERT(fSources & (SHCNRF_InterruptLevel | SHCNRF_ShellLevel));
    
        //  NOTE - if we have more than one registration entry here, 
        //  we only support Deregister'ing the last one
        for (int i = 0; i < cEntries; i++)
        {
            DWORD dwProcId;
            GetWindowThreadProcessId(hwndSCN, &dwProcId);
            HANDLE hChangeRegistration = SHChangeRegistration_Create(
                                        ulID, hwnd, wMsg,
                                        fSources, fEvents,
                                        pfsne[i].fRecursive, pfsne[i].pidl,
                                        dwProcId);
            if (hChangeRegistration)
            {
                CHANGEREGISTER * pcr;
                //
                // Transmit the change regsitration
                //
                SendMessage(hwndSCN, SCNM_REGISTERCLIENT,
                            (WPARAM)hChangeRegistration, (LPARAM)dwProcId);

                //
                // Now get back the ulID value, for further registrations and
                // for returning to the calling function...
                //
                pcr = (CHANGEREGISTER *)SHLockSharedEx(hChangeRegistration, dwProcId, FALSE);
                if (pcr)
                {
                    ulID = pcr->ulID;
                    SHUnlockShared(pcr);
                }
                else
                {
                    ASSERT(0 == ulID);       // Error condition initialized above
                }
                
                SHFreeShared(hChangeRegistration, dwProcId);
            }

            if ((ulID == 0) && !(fSources & SHCNRF_NewDelivery))
            {
                //  this is our proxy window
                DestroyWindow(hwnd);
                break;
            }
        }
    }
    return ulID;
}

//--------------------------------------------------------------------------
//
//  Returns TRUE if we found and removed the specified Client, otherwise
//  returns FALSE.
//
STDAPI_(BOOL) SHChangeNotifyDeregister(ULONG ulID)
{
    BOOL fResult = FALSE;
    HWND hwnd = _SCNGetWindow(TRUE, FALSE);

    if (hwnd)
    {
        //
        // Transmit the change registration
        //
        fResult = (BOOL) SendMessage(hwnd, SCNM_DEREGISTERCLIENT, ulID, 0);
    }
    return fResult;
}

// send the notify to the desktop... telling it to put it in the queue.
// if we are in the desktop's process, we can handle it directly ourselves.
// the one exception is flush.  we want the desktop to be one serializing flush so
// we send in that case as well
void SHChangeNotifyTransmit(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    HWND hwndSCN = _SCNGetWindow(TRUE, FALSE);

    if (hwndSCN)
    {
        DWORD   dwProcId;
        GetWindowThreadProcessId(hwndSCN, &dwProcId);
        HANDLE  hChange = SHChangeNotification_Create(lEvent, uFlags, pidl, pidlExtra, dwProcId, dwEventTime);

        if (hChange)
        {
            BOOL fFlushNow = ((uFlags & (SHCNF_FLUSH | SHCNF_FLUSHNOWAIT)) == SHCNF_FLUSH);
            
            // Flush but not flush no wait
            if (fFlushNow)
            {
                SendMessage(hwndSCN, SCNM_NOTIFYEVENT,
                            (WPARAM)hChange, (LPARAM)dwProcId);
            }
            else
            {
                SendNotifyMessage(hwndSCN, SCNM_NOTIFYEVENT,
                                  (WPARAM)hChange, (LPARAM)dwProcId);
            }
        }
    }
}

void FreeSpacePidlToPath(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    TCHAR szPath1[MAX_PATH];
    if (SHGetPathFromIDList(pidl1, szPath1)) 
    {
        TCHAR szPath2[MAX_PATH];
        szPath2[0] = 0;
        if (pidl2) 
        {
            SHGetPathFromIDList(pidl2, szPath2);
        }
        SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPath1, szPath2[0] ? szPath2 : NULL);
    }
}
    
STDAPI_(void) SHChangeNotify(LONG lEvent, UINT uFlags, const void * dwItem1, const void * dwItem2)
{
    if (!_SCNGetWindow(TRUE, FALSE))
        return;
        
    LPCITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlExtra = NULL;
    LPITEMIDLIST pidlFree = NULL;
    LPITEMIDLIST pidlExtraFree = NULL;
    UINT uType = uFlags & SHCNF_TYPE;
    SHChangeDWORDAsIDList dwidl;
    BOOL    fPrinter = FALSE;
    BOOL    fPrintJob = FALSE;
    DWORD dwEventTime = GetTickCount();

    // first setup anything the flags request
    switch (uType)
    {
    case SHCNF_PRINTJOBA:
        fPrintJob = TRUE;
        // fall through
    case SHCNF_PRINTERA:
        fPrinter = TRUE;
        // fall through
    case SHCNF_PATHA:
        {
            TCHAR szPath1[MAX_PATH], szPath2[MAX_PATH];
            LPCVOID pvItem1 = NULL;
            LPCVOID pvItem2 = NULL;

            if (dwItem1)
            {
                SHAnsiToTChar((LPSTR)dwItem1, szPath1, ARRAYSIZE(szPath1));
                pvItem1 = szPath1;
            }

            if (dwItem2)
            {
                if (fPrintJob)
                    pvItem2 = dwItem2;  // SHCNF_PRINTJOB_DATA needs no conversion
                else
                {
                    SHAnsiToTChar((LPSTR)dwItem2, szPath2, ARRAYSIZE(szPath2));
                    pvItem2 = szPath2;
                }
            }

            SHChangeNotify(lEvent, (fPrintJob ? SHCNF_PRINTJOB : (fPrinter ? SHCNF_PRINTER : SHCNF_PATH)),
                           pvItem1, pvItem2);
            goto Cleanup;       // Let the recursive version do all the work
        }
        break;

    case SHCNF_PATH:
        if (lEvent == SHCNE_FREESPACE) 
        {
            DWORD dwItem = 0;
            int idDrive = PathGetDriveNumber((LPCTSTR)dwItem1);
            if (idDrive != -1)
                dwItem = (1 << idDrive);

            if (dwItem2) 
            {
                idDrive = PathGetDriveNumber((LPCTSTR)dwItem2);
                if (idDrive != -1)
                    dwItem |= (1 << idDrive);
            }

            dwItem1 = (LPCVOID)ULongToPtr( dwItem );
            if (dwItem1)
                goto DoDWORD;
            goto Cleanup;
        } 
        else 
        {
            if (dwItem1)
            {
                pidl = pidlFree = SHSimpleIDListFromPath((LPCTSTR)dwItem1);
                if (!pidl)
                    goto Cleanup;

                if (dwItem2) 
                {
                    pidlExtra = pidlExtraFree = SHSimpleIDListFromPath((LPCTSTR)dwItem2);
                    if (!pidlExtra)
                        goto Cleanup;
                }
            }
        }
        break;

    case SHCNF_PRINTER:
        if (dwItem1)
        {
            TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNF_PRINTER %s", (LPTSTR)dwItem1);

            if (FAILED(ParsePrinterName((LPCTSTR)dwItem1, &pidlFree)))
            {
                goto Cleanup;
            }
            pidl = pidlFree;

            if (dwItem2)
            {
                if (FAILED(ParsePrinterName((LPCTSTR)dwItem2, &pidlExtraFree)))
                {
                    goto Cleanup;
                }
                pidlExtra = pidlExtraFree;
            }
        }
        break;

    case SHCNF_PRINTJOB:
        if (dwItem1)
        {
#ifdef DEBUG
            switch (lEvent)
            {
            case SHCNE_CREATE:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_CREATE SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            case SHCNE_DELETE:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_DELETE SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            case SHCNE_UPDATEITEM:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_UPDATEITEM SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            default:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_? SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            }
#endif
            pidl = pidlFree = Printjob_GetPidl((LPCTSTR)dwItem1, (LPSHCNF_PRINTJOB_DATA)dwItem2);
            if (!pidl)
                goto Cleanup;
        }
        else
        {
            // Caller goofed.
            goto Cleanup;
        }
        break;

    case SHCNF_DWORD:
DoDWORD:
        ASSERT(lEvent & SHCNE_GLOBALEVENTS);

        dwidl.cb      = sizeof(dwidl) - sizeof(dwidl.cbZero);
        dwidl.dwItem1 = PtrToUlong(dwItem1);
        dwidl.dwItem2 = PtrToUlong(dwItem2);
        dwidl.cbZero  = 0;
        pidl = (LPCITEMIDLIST)&dwidl;
        pidlExtra = NULL;
        break;

    case 0:
        if (lEvent == SHCNE_FREESPACE) {
            // convert this to paths.
            FreeSpacePidlToPath((LPCITEMIDLIST)dwItem1, (LPCITEMIDLIST)dwItem2);
            goto Cleanup;
        }
        pidl = (LPCITEMIDLIST)dwItem1;
        pidlExtra = (LPCITEMIDLIST)dwItem2;
        break;

    default:
        TraceMsg(TF_ERROR, "SHChangeNotify: Unrecognized uFlags 0x%X", uFlags);
        return;
    }

    if (lEvent && !(lEvent & SHCNE_ASSOCCHANGED) && !pidl)
    {
        // Caller goofed. SHChangeNotifyTransmit & clients assume pidl is
        // non-NULL if lEvent is non-zero (except in the SHCNE_ASSOCCHANGED case),
        // and they will crash if we try to send this bogus event. So throw out 
        // this event and rip.
        RIP(FALSE);
        goto Cleanup;
    }

    SHChangeNotifyTransmit(lEvent, uFlags, pidl, pidlExtra, dwEventTime);

Cleanup:

    if (pidlFree)
        ILFree(pidlFree);
    if (pidlExtraFree)
        ILFree(pidlExtraFree);
}

// SHChangeNotifySuspendResume
//
// Suspends or resumes filesystem notifications on a path.  If bRecursive
// is set, disable/enables them for all child paths as well.

STDAPI_(BOOL) SHChangeNotifySuspendResume(BOOL         bSuspend, 
                                          LPITEMIDLIST pidlSuspend, 
                                          BOOL         bRecursive, 
                                          DWORD        dwReserved)
{
    BOOL fRet = FALSE;
    HWND hwndSCN = _SCNGetWindow(TRUE, FALSE);

    if (hwndSCN)
    {
        HANDLE  hChange;
        DWORD   dwProcId;
        UINT uiFlags = bSuspend ? SCNSUSPEND_SUSPEND : 0;
        if (bRecursive)
            uiFlags |= SCNSUSPEND_RECURSIVE;

        GetWindowThreadProcessId(hwndSCN, &dwProcId);

        //  overloading the structure semantics here a little bit.
        //  our two flags
        hChange = SHChangeNotification_Create(0, uiFlags, pidlSuspend, NULL, dwProcId, 0);
        if (hChange)
        {
            // Transmit to SCN
            fRet = (BOOL)SendMessage(hwndSCN, SCNM_SUSPENDRESUME, (WPARAM)hChange, (LPARAM)dwProcId);
            SHChangeNotification_Destroy(hChange, dwProcId);
        }
    }

    return fRet;
}


STDAPI_(void) SHChangeNotifyTerminate(BOOL bLastTerm, BOOL bProcessShutdown)
{
    if (g_pscn)
    {
        PostThreadMessage(GetWindowThreadProcessId(g_hwndSCN, NULL), SCNM_TERMINATE, 0, 0);
    }
}

// this deregisters anything that this window might have been registered in
STDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd)
{
    HWND hwndSCN = _SCNGetWindow(TRUE, FALSE);

    if (hwndSCN)
    {
        SendMessage(hwndSCN, SCNM_DEREGISTERWINDOW, (WPARAM)hwnd, 0);
    }
}

//--------------------------------------------------------------------------
// We changed the way that the SHChangeNotifyRegister function worked, so
// to prevent people from calling the old function, we stub it out here.
// The change we made would have broken everbody because we changed the
// lparam and wparam for the notification messages which are sent to the
// registered window.
//
STDAPI_(ULONG) NTSHChangeNotifyRegister(HWND hwnd,
                               int fSources, LONG fEvents,
                               UINT wMsg, int cEntries,
                               SHChangeNotifyEntry *pfsne)
{
    return SHChangeNotifyRegister(hwnd, fSources | SHCNRF_NewDelivery , fEvents, wMsg, cEntries, pfsne);
}
STDAPI_(BOOL) NTSHChangeNotifyDeregister(ULONG ulID)
{
    return SHChangeNotifyDeregister(ulID);
}



// NOTE: There is a copy of these functions in shdocvw util.cpp for browser only mode supprt.
// NOTE: functionality changes should also be reflected there.
STDAPI_(void) SHUpdateImageA( LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex )
{
    WCHAR szWHash[MAX_PATH];

    SHAnsiToUnicode(pszHashItem, szWHash, ARRAYSIZE(szWHash));

    SHUpdateImageW(szWHash, iIndex, uFlags, iImageIndex);
}

STDAPI_(void) SHUpdateImageW( LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex )
{
    SHChangeUpdateImageIDList rgPidl;
    SHChangeDWORDAsIDList rgDWord;

    int cLen = MAX_PATH - (lstrlenW( pszHashItem ) + 1);
    cLen *= sizeof( WCHAR );

    if ( cLen < 0 )
    {
        cLen = 0;
    }

    // make sure we send a valid index
    if ( iImageIndex == -1 )
    {
        iImageIndex = II_DOCUMENT;
    }
        
    rgPidl.dwProcessID = GetCurrentProcessId();
    rgPidl.iIconIndex = iIndex;
    rgPidl.iCurIndex = iImageIndex;
    rgPidl.uFlags = uFlags;
    StrCpyNW(rgPidl.szName, pszHashItem, ARRAYSIZE(rgPidl.szName));
    rgPidl.cb = (USHORT)(sizeof( rgPidl ) - cLen);
    _ILNext( (LPITEMIDLIST) &rgPidl )->mkid.cb = 0;

    rgDWord.cb = sizeof( rgDWord) - sizeof(USHORT);
    rgDWord.dwItem1 = iImageIndex;
    rgDWord.dwItem2 = 0;
    rgDWord.cbZero = 0;

    // pump it as an extended event
    SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_IDLIST, &rgDWord, &rgPidl);
}

// REVIEW: pretty poor implementation of handling updateimage, requiring the caller
// to handle the pidl case instead of passing both pidls down here.
//
STDAPI_(int) SHHandleUpdateImage( LPCITEMIDLIST pidlExtra )
{
    SHChangeUpdateImageIDList * pUs = (SHChangeUpdateImageIDList*) pidlExtra;

    if ( !pUs )
    {
        return -1;
    }

    // if in the same process, or an old style notification
    if ( pUs->dwProcessID == GetCurrentProcessId())
    {
        return *(int UNALIGNED *)((BYTE *)&pUs->iCurIndex);
    }
    else
    {
        WCHAR szBuffer[MAX_PATH];
        int iIconIndex = *(int UNALIGNED *)((BYTE *)&pUs->iIconIndex);
        UINT uFlags = *(UINT UNALIGNED *)((BYTE *)&pUs->uFlags);

        ualstrcpynW(szBuffer, pUs->szName, ARRAYSIZE(szBuffer));
        
        // we are in a different process, look up the hash in our index to get the right one...
        return SHLookupIconIndexW( szBuffer, iIconIndex, uFlags );
    }
}

//
// NOTE: these are OLD APIs, new clients should use new APIs
//
// REVIEW: BobDay - SHChangeNotifyUpdateEntryList doesn't appear to be
// called by anybody and since we've change the notification message
// structure, anybody who calls it needs to be identified and fixed.
//
BOOL  WINAPI SHChangeNotifyUpdateEntryList(ULONG ulID, int iUpdateType,
                               int cEntries, SHChangeNotifyEntry *pfsne)
{
    ASSERT(FALSE);
    return FALSE;
}


void SHChangeNotifyReceive(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    ASSERT(FALSE);
}

BOOL WINAPI SHChangeRegistrationReceive(HANDLE hChangeRegistration, DWORD dwProcId)
{
    ASSERT(FALSE);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sencrypt.cpp ===
#include "shellprv.h"
#include "propsht.h"
#include "sencrypt.h"
#include "datautil.h"

#define IDM_ENCRYPT 0
#define IDM_DECRYPT 1
#define BOOL_UNINIT 5

// Local fns to this .cpp file
STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
BOOL InitSinglePrshtNoDlg(FILEPROPSHEETPAGE * pfpsp);
BOOL InitMultiplePrshtNoDlg(FILEPROPSHEETPAGE* pfpsp);

// Class definition
class CEncryptionContextMenu : public IShellExtInit, public IContextMenu
{
public:
    CEncryptionContextMenu();
    HRESULT Init_FolderContentsInfo();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
     
    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

private:
    virtual ~CEncryptionContextMenu();
    static DWORD CALLBACK EncryptThreadProc(void *pv) { return ((CEncryptionContextMenu *) pv)->_Encrypt(); };
    DWORD _Encrypt();
    BOOL _InitPrsht(FILEPROPSHEETPAGE * pfpsp);
    BOOL _AreFilesEncryptable(IDataObject *pdtobj);

    LONG _cRef;                 // Reference count
    UINT _uFileCount;           // number of files selected
    HWND _hwnd;                 // Window that we're working over
    BOOL _fEncrypt;             // If true, do encrypt; if false, do decrypt
    FILEPROPSHEETPAGE _fpsp;    // Prop sheet page to be filled in and run through properties funcs
    BOOL _fEncryptAllowed;      // True iff we are allowed to encrypt
    IDataObject *_pdtobj;       // Our data object.  Keep in orig. thread
    TCHAR _szPath[MAX_PATH];    // Path of first thing clicked on
};


// Constructor & Destructor
CEncryptionContextMenu::CEncryptionContextMenu() : _cRef(1)
{   
    DllAddRef();

    _fEncryptAllowed = FALSE;   // compute this at ::Initialize() time

    _uFileCount = 0;
    _hwnd = 0;
    _fEncrypt = FALSE;
    _pdtobj = NULL;
    ZeroMemory(&_fpsp, sizeof(_fpsp));
}

CEncryptionContextMenu::~CEncryptionContextMenu()
{
    ATOMICRELEASE(_pdtobj);
    if (_fpsp.pfci)
    {
        Release_FolderContentsInfo(_fpsp.pfci);
    }
    DllRelease();
}

HRESULT CEncryptionContextMenu::Init_FolderContentsInfo()
{
    HRESULT hr = E_OUTOFMEMORY;
    _fpsp.pfci = Create_FolderContentsInfo();
    if (_fpsp.pfci)
    {
        hr = S_OK;
    }
    return hr;
}

// IUnknown implementation.  Standard stuff, nothing fancy.
HRESULT CEncryptionContextMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEncryptionContextMenu, IShellExtInit),
        QITABENT(CEncryptionContextMenu, IContextMenu),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CEncryptionContextMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CEncryptionContextMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IShellExtInit implementation

STDMETHODIMP CEncryptionContextMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{   
    HRESULT hr = S_FALSE;
    
    // registry key that enables/disables this menu
    BOOL fEnableEncryptMenu = SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"), 
                TEXT("EncryptionContextMenu"), 0, 0);

    if (fEnableEncryptMenu && !SHRestricted(REST_NOENCRYPTION) && !_fEncryptAllowed)
    {
        _fEncryptAllowed = _AreFilesEncryptable(pdtobj);
        if (_fEncryptAllowed)
        {
            IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
            hr = S_OK;
        }
    }
    
    return hr;
}

// Checks the data object to see if we can encrypt here.
BOOL CEncryptionContextMenu::_AreFilesEncryptable(IDataObject *pdtobj)
{
    BOOL fSuccess = FALSE;
 
    STGMEDIUM medium;
    FORMATETC fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pdtobj->GetData(&fe, &medium)))
    {
        // Get the file name from the CF_HDROP.
        _uFileCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);
        if (_uFileCount)
        {
            if (DragQueryFile((HDROP)medium.hGlobal, 0, _szPath, ARRAYSIZE(_szPath)))
            {
                TCHAR szFileSys[MAX_PATH];
                fSuccess = (FS_FILE_ENCRYPTION & GetVolumeFlags(_szPath, szFileSys, ARRAYSIZE(szFileSys)));
            }
        }
        ReleaseStgMedium(&medium);
    }
    return fSuccess;
}
    
// IContextMenuHandler impelementation
STDMETHODIMP CEncryptionContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, 
                                                      UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = E_FAIL;

    if ((uFlags & CMF_DEFAULTONLY) || !_fEncryptAllowed) 
    {
        hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(1));  //this menu only allows the defaults or we can't encrypt
    }
    else
    {
        TCHAR szEncryptMsg[128], szDecryptMsg[128];

        // If only one item is selected, display enc or dec as appropriate
        if (_uFileCount == 1)
        {
            DWORD dwAttribs = GetFileAttributes(_szPath);
            if (dwAttribs != (DWORD)-1)
            {
                LoadString(HINST_THISDLL, IDS_ECM_ENCRYPT, szEncryptMsg, ARRAYSIZE(szEncryptMsg));
                if (!(dwAttribs & FILE_ATTRIBUTE_ENCRYPTED))
                {
                    if (InsertMenu(hmenu, 
                        indexMenu, 
                        MF_STRING | MF_BYPOSITION, 
                        idCmdFirst + IDM_ENCRYPT, 
                        szEncryptMsg))
                    {
                        hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_ENCRYPT + 1));
                    }
                }
                else
                {
                    LoadString(HINST_THISDLL, IDS_ECM_DECRYPT, szDecryptMsg, ARRAYSIZE(szDecryptMsg));
                    if (InsertMenu(hmenu, 
                        indexMenu, 
                        MF_STRING | MF_BYPOSITION, 
                        idCmdFirst + IDM_ENCRYPT + 1, 
                        szDecryptMsg))  
                    {
                        hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_DECRYPT + 1));
                    }
                }
            }
        }
        else if (idCmdLast - idCmdFirst >= 2)
        {
            LoadString(HINST_THISDLL, IDS_ECM_ENCRYPT, szEncryptMsg, ARRAYSIZE(szDecryptMsg));
            LoadString(HINST_THISDLL, IDS_ECM_DECRYPT, szDecryptMsg, ARRAYSIZE(szDecryptMsg));

            // If more than one item is selected, display both enc and dec
            if (InsertMenu(hmenu, 
                indexMenu, 
                MF_STRING | MF_BYPOSITION, 
                idCmdFirst + IDM_ENCRYPT, 
                szEncryptMsg))
            {
                if (InsertMenu(hmenu, 
                    indexMenu + 1, 
                    MF_STRING | MF_BYPOSITION, 
                    idCmdFirst + IDM_DECRYPT, 
                    szDecryptMsg))  
                {
                    hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_DECRYPT + 1));
                }
                else
                {
                    // If you can't add both, add neither
                    RemoveMenu(hmenu, indexMenu, MF_BYPOSITION);
                }
            }
        }
    }

    return hr;
}

const ICIVERBTOIDMAP c_IDMap[] =
{
    { L"encrypt", "encrypt", IDM_ENCRYPT, IDM_ENCRYPT, },
    { L"decrypt", "decrypt", IDM_DECRYPT, IDM_DECRYPT, },
};

STDMETHODIMP CEncryptionContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT uID;
    HRESULT hr = E_FAIL;
    if (_fEncryptAllowed)
    {
        hr = SHMapICIVerbToCmdID(pici, c_IDMap, ARRAYSIZE(c_IDMap), &uID);
        if (SUCCEEDED(hr))
        {
            switch (uID)
            {
            case IDM_ENCRYPT:
            case IDM_DECRYPT:
                _fEncrypt = (IDM_ENCRYPT == uID);
                break;

            default:
                ASSERTMSG(0, "Should never get commands we didn't put on the menu...");
                break;
            }

            _hwnd = pici->hwnd;  // The handle to the explorer window that called us.
       
            ASSERT(NULL == _fpsp.pfci->hida);

            hr = DataObj_CopyHIDA(_pdtobj, &_fpsp.pfci->hida);
            if (SUCCEEDED(hr))
            {
                AddRef();   // Give our background thread a ref

                // Start the new thread here
                if (SHCreateThread(EncryptThreadProc, this, CTF_COINIT | CTF_FREELIBANDEXIT, NULL))
                {
                    hr = S_OK;
                }
                else
                {
                    Release();  // thread create failed
                }
            }
        }
    }

    // If we succeeded or not, we give up our data here
    ATOMICRELEASE(_pdtobj);
    return hr;
}


STDMETHODIMP CEncryptionContextMenu::GetCommandString(UINT_PTR idCommand, UINT uFlags,
                                               UINT *pRes, LPSTR pszName, UINT uMaxNameLen)
{
    HRESULT  hr = E_INVALIDARG;

    // Note that because we can be specifically asked for 
    // UNICODE or ansi strings, we have to be ready to load all strings in
    // either version.

    if (idCommand == IDM_ENCRYPT ||
        idCommand == IDM_DECRYPT)
    {
        switch(uFlags)
        {
        case GCS_HELPTEXTA:
            if (idCommand == IDM_ENCRYPT)
            {
                LoadStringA(HINST_THISDLL, IDS_ECM_ENCRYPT_HELP, pszName, uMaxNameLen);
            }
            else
            {
                LoadStringA(HINST_THISDLL, IDS_ECM_DECRYPT_HELP, pszName, uMaxNameLen);
            }

            hr = S_OK;
            break; 
            
        case GCS_HELPTEXTW: 
            if (idCommand == IDM_ENCRYPT)
            {
                LoadStringW(HINST_THISDLL, IDS_ECM_ENCRYPT_HELP, (LPWSTR)pszName, uMaxNameLen);
            }
            else
            {
                LoadStringW(HINST_THISDLL, IDS_ECM_DECRYPT_HELP, (LPWSTR)pszName, uMaxNameLen);
            }

            hr = S_OK;
            break; 
            
        case GCS_VERBA:
        case GCS_VERBW:
            hr = SHMapCmdIDToVerb(idCommand, c_IDMap, ARRAYSIZE(c_IDMap), pszName, uMaxNameLen, GCS_VERBW == uFlags);
            break; 
            
        default:
            hr = S_OK;
            break; 
        }
    }
    return hr;

}

STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;
    CEncryptionContextMenu *pdocp = new CEncryptionContextMenu();
    if (pdocp)
    {
        hr = pdocp->Init_FolderContentsInfo();
        if (SUCCEEDED(hr))
        {
            hr = pdocp->QueryInterface(riid, ppv);
        }
        pdocp->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Multithread code

// Proc for thread that does the encryption and manages the progress dialong.
// The passed parameter is a ptr hwnd to be made modal for the context menu
DWORD CEncryptionContextMenu::_Encrypt(void)
{
    // Transfer ownership in case someone reenters our thread creator
    // Init the property sheet
    BOOL fSuccess = _InitPrsht(&_fpsp);    
    if (fSuccess)
    {
        // Set encryption opts, turn off compression
        if (_fEncrypt)
        {
            _fpsp.asCurrent.fCompress = FALSE;
            _fpsp.asCurrent.fEncrypt = TRUE;    
        }
        else
        {
            _fpsp.asCurrent.fEncrypt = FALSE;
        }
        
        // See if the user wants to do this recursive-style
        if (_fpsp.fIsDirectory)
        {
            // check to see if the user wants to apply the attribs recursively or not
            fSuccess = (int)DialogBoxParam(HINST_THISDLL, 
                MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                _hwnd, RecursivePromptDlgProc, (LPARAM)&_fpsp);
        }
        
        // Apply encryption, remember to turn off compression
        if (fSuccess)
        {
            if (_fpsp.pfci->fMultipleFiles || _fpsp.fRecursive)
            {
                ApplyMultipleFileAttributes(&_fpsp);
            }
            else
            {
                ApplySingleFileAttributesNoDlg(&_fpsp, _hwnd);
            }
        }
    }
    // As far as I can tell, nothing in fpsp must be freed
    // But, we give up the storage medium here
    Release();      // Release our ref
    return fSuccess;  // Must give a ret value
}

// Helper to init the passed prsht
BOOL CEncryptionContextMenu::_InitPrsht(FILEPROPSHEETPAGE * pfpsp)
{
    // Init the propsht properly 
    BOOL fSuccess = S_OK == InitCommonPrsht(pfpsp);
    if (fSuccess)
    {        
        if (_uFileCount == 1)
        {
            fSuccess = InitSinglePrshtNoDlg(pfpsp);
        }
        else if (_uFileCount > 1)
        {
            fSuccess = InitMultiplePrshtNoDlg(pfpsp);
        }
    }
    return fSuccess;
}

//
// Descriptions:
//   This function fills fields of the multiple object property sheet,
//   without getting the current state from the dialog.
//
BOOL InitMultiplePrshtNoDlg(FILEPROPSHEETPAGE* pfpsp)
{
    SHFILEINFO sfi;
    TCHAR szBuffer[MAX_PATH+1];
    TCHAR szType[MAX_PATH] = {0};
    TCHAR szDirPath[MAX_PATH] = {0};
    int iItem;
    BOOL fMultipleType = FALSE;
    BOOL fSameLocation = TRUE;
    DWORD dwFlagsOR = 0;                // start all clear
    DWORD dwFlagsAND = (DWORD)-1;       // start all set
    DWORD dwVolumeFlagsAND = (DWORD)-1; // start all set

    // For all the selected files compare their types and get their attribs
    for (iItem = 0; HIDA_FillFindData(pfpsp->pfci->hida, iItem, szBuffer, NULL, FALSE); iItem++)
    {
        DWORD dwFileAttributes = GetFileAttributes(szBuffer);

        dwFlagsAND &= dwFileAttributes;
        dwFlagsOR  |= dwFileAttributes;

        // process types only if we haven't already found that there are several types
        if (!fMultipleType)
        {
            SHGetFileInfo((LPTSTR)IDA_GetIDListPtr((LPIDA)GlobalLock(pfpsp->pfci->hida), iItem), 0,
                &sfi, sizeof(sfi), SHGFI_PIDL|SHGFI_TYPENAME);

            if (szType[0] == TEXT('\0'))
                StringCchCopy(szType, ARRAYSIZE(szType), sfi.szTypeName);
            else
                fMultipleType = lstrcmp(szType, sfi.szTypeName) != 0;
        }

        dwVolumeFlagsAND &= GetVolumeFlags(szBuffer, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys));
        // check to see if the files are in the same location
        if (fSameLocation)
        {
            PathRemoveFileSpec(szBuffer);

            if (szDirPath[0] == TEXT('\0'))
                StrCpyN(szDirPath, szBuffer, ARRAYSIZE(szDirPath));
            else
                fSameLocation = (lstrcmpi(szDirPath, szBuffer) == 0);
        }
    }

    if ((dwVolumeFlagsAND & FS_FILE_ENCRYPTION) && !SHRestricted(REST_NOENCRYPTION))
    {
        // all the files are on volumes that support encryption (eg NTFS)
        pfpsp->fIsEncryptionAvailable = TRUE;
    }
    
    if (dwVolumeFlagsAND & FS_FILE_COMPRESSION)
    {
        pfpsp->pfci->fIsCompressionAvailable = TRUE;
    }

    //
    // HACKHACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we 
    // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
    // appeared first on NTFS5 volumes, at the same time sparse file support
    // was implemented.
    //
    if (dwVolumeFlagsAND & FILE_SUPPORTS_SPARSE_FILES)
    {
        // yup, we are on NTFS5 or greater
        pfpsp->fIsIndexAvailable = TRUE;
    }

    // if any of the files was a directory, then we set this flag
    if (dwFlagsOR & FILE_ATTRIBUTE_DIRECTORY)
    {
        pfpsp->fIsDirectory = TRUE;
    }

    // setup all the flags based on what we found out
    SetInitialFileAttribs(pfpsp, dwFlagsAND, dwFlagsOR);

    // set the current attributes to the same as the initial
    pfpsp->asCurrent = pfpsp->asInitial;

    if (fSameLocation)
    {
        LoadString(HINST_THISDLL, IDS_ALLIN, szBuffer, ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, szDirPath, ARRAYSIZE(szBuffer));
        StrCpyN(pfpsp->szPath, szDirPath, ARRAYSIZE(pfpsp->szPath));
    }

    UpdateSizeField(pfpsp, NULL);

    return TRUE;
}

//
// Descriptions:
//   This function fills fields of the "general" dialog box (a page of
//  a property sheet) with attributes of the associated file. Doesn't
//  make calss to hDlg
//
BOOL InitSinglePrshtNoDlg(FILEPROPSHEETPAGE * pfpsp)
{
    TCHAR szBuffer[MAX_PATH];
    SHFILEINFO sfi;

    // fd is filled in with info from the pidl, but this
    // does not contain all the date/time information so hit the disk here.
    HANDLE hfind = FindFirstFile(pfpsp->szPath, &pfpsp->fd);
    ASSERT(hfind != INVALID_HANDLE_VALUE);
    if (hfind == INVALID_HANDLE_VALUE)
    {
        // if this failed we should clear out some values as to not show garbage on the screen.
        ZeroMemory(&pfpsp->fd, sizeof(pfpsp->fd));
    }
    else
    {
        FindClose(hfind);
    }

    // get info about the file.
    SHGetFileInfo(pfpsp->szPath, pfpsp->fd.dwFileAttributes, &sfi, sizeof(sfi),
        SHGFI_ICON|SHGFI_LARGEICON|
        SHGFI_DISPLAYNAME|
        SHGFI_TYPENAME | SHGFI_ADDOVERLAYS);

    // .ani cursor hack!
    if (StrCmpI(PathFindExtension(pfpsp->szPath), TEXT(".ani")) == 0)
    {
        HICON hIcon = (HICON)LoadImage(NULL, pfpsp->szPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
        if (hIcon)
        {
            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);

            sfi.hIcon = hIcon;
        }
    }

    // set the initial rename state
    pfpsp->fRename = FALSE;

    // set the file type
    if (pfpsp->fMountedDrive)
    {
        TCHAR szVolumeGUID[MAX_PATH];
        TCHAR szVolumeLabel[MAX_PATH];

        //Borrow szVolumeGUID
        LoadString(HINST_THISDLL, IDS_MOUNTEDVOLUME, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        //use szVolumeLabel temporarily
        StringCchCopy(szVolumeLabel, ARRAYSIZE(szVolumeLabel), pfpsp->szPath);
        PathAddBackslash(szVolumeLabel);
        GetVolumeNameForVolumeMountPoint(szVolumeLabel, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        if (!GetVolumeInformation(szVolumeGUID, szVolumeLabel, ARRAYSIZE(szVolumeLabel),
            NULL, NULL, NULL, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys)))
        {
            *szVolumeLabel = 0;
        }

        if (!(*szVolumeLabel))
            LoadString(HINST_THISDLL, IDS_UNLABELEDVOLUME, szVolumeLabel, ARRAYSIZE(szVolumeLabel));        
    }

    // save off the initial short filename, and set the "Name" edit box
    StringCchCopy(pfpsp->szInitialName, ARRAYSIZE(pfpsp->szInitialName), sfi.szDisplayName);

    // use a strcmp to see if we are showing the extension
    if (lstrcmpi(sfi.szDisplayName, PathFindFileName(pfpsp->szPath)) == 0)
    {
        // since the strings are the same, we must be showing the extension
        pfpsp->fShowExtension = TRUE;
    }

    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pfpsp->szPath);
    PathRemoveFileSpec(szBuffer);
    
    // Are we a folder shortcut?
    if (!pfpsp->fFolderShortcut)
    {
        // set the initial attributes
        SetInitialFileAttribs(pfpsp, pfpsp->fd.dwFileAttributes, pfpsp->fd.dwFileAttributes);
        
        // set the current attributes to the same as the initial
        pfpsp->asCurrent = pfpsp->asInitial;
        
        UpdateSizeField(pfpsp, &pfpsp->fd);
        
        if (!(pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Check to see if the target file is a lnk, because if it is a lnk then 
            // we need to display the type information for the target, not the lnk itself.
            if (PathIsShortcut(pfpsp->szPath, pfpsp->fd.dwFileAttributes))
            {
                pfpsp->fIsLink = TRUE;
            }
            if (!(GetFileAttributes(pfpsp->szPath) & FILE_ATTRIBUTE_OFFLINE))
            {
                 UpdateOpensWithInfo(pfpsp);
            }
        }
        else
        {
            pfpsp->fIsDirectory = TRUE;
        }
        
        // get the full path to the folder that contains this file.
        StrCpyN(szBuffer, pfpsp->szPath, ARRAYSIZE(szBuffer));
        PathRemoveFileSpec(szBuffer);
    }
    return TRUE;
}

STDAPI_(BOOL) ApplySingleFileAttributesNoDlg(FILEPROPSHEETPAGE* pfpsp, HWND hwnd)
{
    BOOL bRet = TRUE;
    BOOL bSomethingChanged = FALSE;

    if (!pfpsp->fRecursive)
    {
        bRet = ApplyFileAttributes(pfpsp->szPath, pfpsp, hwnd, &bSomethingChanged);
        
        if (bSomethingChanged)
        {
            // something changed, so generate a notification for the item
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);
        }
    }
    else
    {
        // We only should be doing a recursive operation if we have a directory!
        ASSERT(pfpsp->fIsDirectory);

        CreateAttributeProgressDlg(pfpsp);

        // apply attribs to this folder & sub files/folders
        bRet = ApplyRecursiveFolderAttribs(pfpsp->szPath, pfpsp);
        
        // send out a notification for the whole dir, regardless of the return value since
        // something could have changed even if the user hit cancel
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, pfpsp->szPath, NULL);
        
        DestroyAttributeProgressDlg(pfpsp);
    }

    if (bRet)
    {
        // since we just sucessfully applied attribs, reset any tri-state checkboxes as necessary
        //UpdateTriStateCheckboxes(pfpsp);

        // the user did NOT hit cancel, so update the prop sheet to reflect the new attribs
        pfpsp->asInitial = pfpsp->asCurrent;
    }

    // handle any events we may have generated
    SHChangeNotifyHandleEvents();

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sencrypt.h ===
#ifndef _SENCRYPT_H_
#define _SENCRYPT_H_

#include "prshtcpp.h" // for UpdateOpensWithInfo()

// Funcs in sencrypt.cpp
STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **pcpOut);
BOOL InitSinglePrshtNoDlg(FILEPROPSHEETPAGE * pfpsp);
BOOL InitMultiplePrshtNoDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) ApplySingleFileAttributesNoDlg(FILEPROPSHEETPAGE* pfpsp, HWND hwnd);

// Funcs from mulpshrt.c  -- use C linkage
STDAPI_(BOOL) ApplyMultipleFileAttributes(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) ApplySingleFileAttributes(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) HIDA_FillFindData(HIDA hida, UINT iItem, LPTSTR pszPath, WIN32_FIND_DATA *pfd, BOOL fReturnCompressedSize);
STDAPI_(void) UpdateSizeField(FILEPROPSHEETPAGE* pfpsp, WIN32_FIND_DATA* pfd);

#endif  // _SENCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sfstorage.cpp ===
#include "shellprv.h"
#include "prop.h"

#include "../inc/sfstorage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sfstorage.h ===
#include "../inc/sfstorage.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shared.c ===
#include "shellprv.h"
#pragma  hdrstop

//---------------------------------------------------------------------------
// SHAllocShared  - Allocates a handle (in a given process) to a copy of a
//                  memory block in this process.
// SHFreeShared   - Releases the handle (and the copy of the memory block)
//
// SHLockShared   - Maps a handle (from a given process) into a memory block
//                  in this process.  Has the option of transfering the handle
//                  to this process, thereby deleting it from the given process
// SHUnlockShared - Opposite of SHLockShared, unmaps the memory block
//---------------------------------------------------------------------------

HANDLE _SHAllocShared(LPCVOID pvData, DWORD dwSize, DWORD dwDestinationProcessId) 
{
    return SHAllocShared(pvData, dwSize, dwDestinationProcessId);
}

void *_SHLockShared(HANDLE hData, DWORD dwSourceProcessId) 
{
    return SHLockShared(hData, dwSourceProcessId);
}

BOOL _SHUnlockShared(void * pvData) 
{
    return SHUnlockShared(pvData);
}

BOOL _SHFreeShared(HANDLE hData, DWORD dwSourceProcessId) 
{
    return SHFreeShared(hData, dwSourceProcessId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sfvcmpt.cpp ===
#include "shellprv.h"
#include <shellp.h>
#include <sfview.h>
#include "basefvcb.h"
#include "ids.h"
#include "prop.h"

CBaseShellFolderViewCB::CBaseShellFolderViewCB(LPCITEMIDLIST pidl, LONG lEvents)
    : _cRef(1), _hwndMain(NULL), _lEvents(lEvents)
{
    _pidl = ILClone(pidl);
}

CBaseShellFolderViewCB::~CBaseShellFolderViewCB()
{
    ILFree(_pidl);    // accpets NULL
}

STDMETHODIMP CBaseShellFolderViewCB::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBaseShellFolderViewCB, IShellFolderViewCB),   // IID_IShellFolderViewCB
        QITABENT(CBaseShellFolderViewCB, IObjectWithSite),      // IID_IObjectWithSite
        QITABENT(CBaseShellFolderViewCB, IServiceProvider),     // IID_IServiceProvider
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CBaseShellFolderViewCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBaseShellFolderViewCB::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CBaseShellFolderViewCB::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = RealMessage(uMsg, wParam, lParam);
    if (FAILED(hr))
    {
        switch (uMsg)
        {
        case SFVM_HWNDMAIN:
            _hwndMain = (HWND)lParam;
            hr = S_OK;
            break;

        case SFVM_GETNOTIFY:
            *(LPCITEMIDLIST*)wParam = _pidl;
            *(LONG*)lParam = _lEvents;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

class CWrapOldCallback : public CBaseShellFolderViewCB
{
public:
    CWrapOldCallback(LPCSFV pcsfv);

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);

private:
    ~CWrapOldCallback();

    LPFNVIEWCALLBACK _pfnCB;
    IShellView* _psvOuter;
    IShellFolder *_psf;

    UINT _fvm;
    LPARAM _lSelChangeInfo;
};

CWrapOldCallback::CWrapOldCallback(LPCSFV pcsfv) : CBaseShellFolderViewCB(pcsfv->pidl, pcsfv->lEvents)
{
    _psf = pcsfv->pshf;
    _psf->AddRef();
    _psvOuter  = pcsfv->psvOuter;
    _fvm = pcsfv->fvm;
    _pfnCB = pcsfv->pfnCallback;
}

CWrapOldCallback::~CWrapOldCallback()
{
    _psf->Release();
}

// Some older clients may not support IObjectWithSite::SetSite
// For compat send them the old SFVM_SETISFV message
HRESULT CWrapOldCallback::SetSite(IUnknown *punkSite)
{
    HRESULT hr = CBaseShellFolderViewCB::SetSite( punkSite );
    MessageSFVCB( SFVM_SETISFV, 0, (LPARAM)punkSite );
    return hr;
}


STDMETHODIMP CWrapOldCallback::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DVSELCHANGEINFO dvsci;

    switch (uMsg)
    {
    case SFVM_DEFVIEWMODE:
        if (_fvm)
            *(UINT*)lParam = _fvm;
        break;

    case SFVM_SELCHANGE:
    {
        SFVM_SELCHANGE_DATA* pSelChange = (SFVM_SELCHANGE_DATA*)lParam;

        dvsci.uNewState = pSelChange->uNewState;
        dvsci.uOldState = pSelChange->uOldState;
        dvsci.plParam = &_lSelChangeInfo;
        dvsci.lParamItem = pSelChange->lParamItem;
        lParam = (LPARAM)&dvsci;
        break;
    }

    case SFVM_INSERTITEM:
    case SFVM_DELETEITEM:
    case SFVM_WINDOWCREATED:
        dvsci.plParam = &_lSelChangeInfo;
        dvsci.lParamItem = lParam;
        lParam = (LPARAM)&dvsci;
        break;

    case SFVM_REFRESH:
    case SFVM_SELECTALL:
    case SFVM_UPDATESTATUSBAR:
    case SFVM_SETFOCUS:
    case SFVM_PRERELEASE:
        lParam = _lSelChangeInfo;
        break;

    default:
        break;
    }

    // NOTE: The DVM_ messages are the same as the SFVM_ message
    return _pfnCB(_psvOuter, _psf, _hwndMain, uMsg, wParam, lParam);
}

LRESULT _ShellFolderViewMessage(IShellFolderView* psfv, UINT uMsg, LPARAM lParam)
{
    UINT uScratch;

    switch (uMsg)
    {
    case SFVM_REARRANGE:
        psfv->Rearrange(lParam);
        break;

    case SFVM_ARRANGEGRID:
        psfv->ArrangeGrid();
        break;

    case SFVM_AUTOARRANGE:
        psfv->AutoArrange();
        break;

    case SFVM_GETAUTOARRANGE:
        return psfv->GetAutoArrange() == S_OK;

    case SFVM_GETARRANGEPARAM:
        psfv->GetArrangeParam(&lParam);
        return lParam;

    case SFVM_ADDOBJECT:
        if (SUCCEEDED(psfv->AddObject((LPITEMIDLIST)lParam, &uScratch))
             && (int)uScratch >= 0)
        {
            // New semantics make a copy of the IDList
            ILFree((LPITEMIDLIST)lParam);
            return uScratch;
        }
        return -1;

    case SFVM_GETOBJECTCOUNT:
        return SUCCEEDED(psfv->GetObjectCount(&uScratch)) ? uScratch : -1;

    case SFVM_GETOBJECT:
    {
        LPITEMIDLIST pidl;

        return SUCCEEDED(psfv->GetObject(&pidl, (UINT)lParam)) ? (LPARAM)pidl : NULL;
    }

    case SFVM_REMOVEOBJECT:
        return SUCCEEDED(psfv->RemoveObject((LPITEMIDLIST)lParam, &uScratch)) ? uScratch : -1;

    case SFVM_UPDATEOBJECT:
    {
        LPITEMIDLIST *ppidl = (LPITEMIDLIST*)lParam;

        if (SUCCEEDED(psfv->UpdateObject(ppidl[0], ppidl[1], &uScratch))
            && (int)uScratch >= 0)
        {
            // New semantics make a copy of the IDList
            ILFree(ppidl[1]);
            return uScratch;
        }
        return -1;
    }

    case SFVM_REFRESHOBJECT:
    {
        LPITEMIDLIST *ppidl = (LPITEMIDLIST*)lParam;

        return SUCCEEDED(psfv->RefreshObject(ppidl[0], &uScratch)) ? uScratch : -1;
    }

    case SFVM_SETREDRAW:
        psfv->SetRedraw(BOOLFROMPTR(lParam));
        break;

    case SFVM_GETSELECTEDOBJECTS:
        return SUCCEEDED(psfv->GetSelectedObjects((LPCITEMIDLIST**)lParam, &uScratch)) ? uScratch : -1;

    case SFVM_GETSELECTEDCOUNT:
        return SUCCEEDED(psfv->GetSelectedCount(&uScratch)) ? uScratch : -1;

    case SFVM_ISDROPONSOURCE:
        return psfv->IsDropOnSource((IDropTarget *)lParam) == S_OK;

    case SFVM_MOVEICONS:
        psfv->MoveIcons((IDataObject *)lParam);
        break;

    case SFVM_GETDROPPOINT:
        return psfv->GetDropPoint((POINT *)lParam) == S_OK;

    case SFVM_GETDRAGPOINT:
        return psfv->GetDragPoint((POINT *)lParam) == S_OK;

    case SFVM_SETITEMPOS:
    {
        SFV_SETITEMPOS* psip = (SFV_SETITEMPOS*)lParam;
        psfv->SetItemPos(psip->pidl, &psip->pt);
        break;
    }

    case SFVM_ISBKDROPTARGET:
        return psfv->IsBkDropTarget((IDropTarget *)lParam) == S_OK;

    case SFVM_SETCLIPBOARD:
        psfv->SetClipboard(lParam == DFM_CMD_MOVE);
        break;

    case SFVM_SETPOINTS:
        psfv->SetPoints((IDataObject *)lParam);
        return 0;

    case SFVM_GETITEMSPACING:
        return psfv->GetItemSpacing((LPITEMSPACING)lParam) == S_OK;

    default:
        // -1L is the default return value
        return 0;
    }

    return 1;
}

IShellFolderView* ShellFolderViewFromWindow(HWND hwnd)
{
    IShellFolderView* psfv = NULL;

    // HPCView sometimes gets confused and passes HWND_BROADCAST as its
    // window.  We can't let this reach FileCabinet_GetIShellBrowser or
    // we end up broadcasting the CWM_GETISHELLBROWSER message and screwing
    // up everybody in the system.  (Not to mention that it will return TRUE,
    // indicating a successful broadcast, and then we fault thinking that
    // it's a vtbl.)

    if (hwnd && hwnd != HWND_BROADCAST)
    {
        IShellBrowser* psb = FileCabinet_GetIShellBrowser(hwnd);

        // Use !IS_INTRESOURCE() to protect against blatanly bogus values
        // that clearly aren't pointers to objects.
        if (!IS_INTRESOURCE(psb))
        {
            IShellView* psv;
            if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
            {
                psv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv));
                psv->Release();
            }
        }
    }
    return psfv;
}

STDAPI_(HWND) ShellFolderViewWindow(HWND hwnd)
{
    HWND hwndRet = NULL;
    IShellBrowser *psb = FileCabinet_GetIShellBrowser(hwnd);
    if (psb)
    {
        IShellView *psv;
        if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
        {
            IUnknown_GetWindow(psv, &hwndRet);
            psv->Release();
        }
    }
    return hwndRet;
}

// undoced shell32 export
STDAPI_(IShellFolderViewCB *) SHGetShellFolderViewCB(HWND hwnd)
{
    ASSERT(0);
    return NULL;    // no one calls this (search of the NT code finds no callers)
}

// old msg based way of programming defview (pre dates IShellFolderView)

STDAPI_(LRESULT) SHShellFolderView_Message(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    LRESULT lret = 0;
    IShellFolderView* psfv = ShellFolderViewFromWindow(hwnd);
    if (psfv)
    {
        lret = _ShellFolderViewMessage(psfv, uMsg, lParam);
        psfv->Release();
    }
    return lret;
}


STDAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, IShellView **ppsv)
{
    SFV_CREATE sfvc;

    sfvc.cbSize = sizeof(sfvc);
    sfvc.pshf = pcsfv->pshf;
    sfvc.psvOuter = pcsfv->psvOuter;

    sfvc.psfvcb = pcsfv->pfnCallback ? new CWrapOldCallback(pcsfv) : NULL;

    HRESULT hr = SHCreateShellFolderView(&sfvc, ppsv);

    if (sfvc.psfvcb)
        sfvc.psfvcb->Release();

    return hr;
}

STDAPI_(void) InitializeStatus(IUnknown *psite)
{
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        LONG_PTR nParts = 0, n;

        psb->SendControlMsg(FCW_STATUS, SB_GETPARTS, 0, 0, &nParts);

        for (n = 0; n < nParts; n ++)
        {
            psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, n, (LPARAM)TEXT(""), NULL);
            psb->SendControlMsg(FCW_STATUS, SB_SETICON, n, (LPARAM)NULL, NULL);
        }
        psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, 0, 0, NULL);
        psb->Release();
    }
}

//
//  The status bar partitioning has undergone several changes.  Here's
//  what we've got right now:
//
//      Pane 0 = Selection - all remaining space
//      Pane 1 = Size      - just big enough to say 9,999 bytes (11 chars)
//      Pane 2 = Zone      - just big enough to hold longest zone
//

STDAPI_(void) ResizeStatus(IUnknown *psite, UINT cx)
{
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        HWND hwndStatus;
        if (SUCCEEDED(psb->GetControlWindow(FCW_STATUS, &hwndStatus)) && hwndStatus)
        {
            RECT rc;
            int ciParts[3];
            int ciBorders[3];
            int cxPart;
            GetClientRect(hwndStatus, &rc);

            // Must also take status bar borders into account.
            psb->SendControlMsg(FCW_STATUS, SB_GETBORDERS, 0, (LPARAM)ciBorders, NULL);

            // We build the panes from right to left.
            ciParts[2] = -1;

            // The Zones part
            cxPart = ciBorders[0] + ZoneComputePaneSize(hwndStatus) + ciBorders[2];
            ciParts[1] = rc.right - cxPart;

            // The Size part
            HDC hdc = GetDC(hwndStatus);
            HFONT hfPrev = SelectFont(hdc, GetWindowFont(hwndStatus));
            SIZE siz;
            GetTextExtentPoint32(hdc, TEXT("0"), 1, &siz);
            SelectObject(hdc, hfPrev);
            ReleaseDC(hwndStatus, hdc);
            
            cxPart = ciBorders[0] + siz.cx * (11 + 2); // "+2" for slop
            ciParts[0] = ciParts[1] - cxPart;

            //
            //  If we underflowed, then give up and just give everybody
            //  one third.
            //
            if (ciParts[0] < 0)
            {
                ciParts[0] = rc.right / 3;
                ciParts[1] = 2 * ciParts[0];
            }

            psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts, NULL);
        }
        psb->Release();
    }
}

STDAPI_(void) SetStatusText(IUnknown *psite, LPCTSTR *ppszText, int iStart, int iEnd)
{
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        for (; iStart <= iEnd; iStart++) 
        {
            LPCTSTR psz;

            if (ppszText) 
            {
                psz = *ppszText;
                ppszText++;
            } 
            else 
                psz = c_szNULL;

            psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, (WPARAM)iStart, (LPARAM)psz, NULL);
        }
        psb->Release();
    }
}

STDAPI_(void) ViewShowSelectionState(IUnknown *psite, FSSELCHANGEINFO *pfssci)
{
    TCHAR szTemp[20], szBytes[30];
    LPTSTR pszStatus = NULL;

    if (pfssci->nItems > 1)
    {
        pszStatus = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FSSTATUSSELECTED),
                            AddCommas(pfssci->nItems, szTemp, ARRAYSIZE(szTemp)));
    }

    if (pfssci->cNonFolders)
        ShortSizeFormat64(pfssci->cbBytes, szBytes, ARRAYSIZE(szBytes));
    else
        szBytes[0] = 0;

    LPCTSTR rgpsz[] = { pszStatus, szBytes };
    SetStatusText(psite, rgpsz, 0, 1);

    if (pszStatus)
        LocalFree(pszStatus);
}

HRESULT _UpdateDiskFreeSpace(LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci)
{
    IShellFolder2 *psf2;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidlFolder, IID_PPV_ARG(IShellFolder2, &psf2), &pidlLast);
    if (SUCCEEDED(hr))
    {
        ULONGLONG ullTotalFreeCaller;
        hr = GetLongProperty(psf2, pidlLast, &SCID_FREESPACE, &ullTotalFreeCaller);
        if (SUCCEEDED(hr))
        {
            pfssci->cbFree = ullTotalFreeCaller;
        }
        else if (!ILIsEmpty(pidlFolder) && !ILIsEmpty(_ILNext(pidlFolder)))
        {
            // if there are at least 2 segments in the IDList rip off the
            // last item and recurse to compute the size
            LPITEMIDLIST pidl = ILCloneParent(pidlFolder);
            if (pidl)
            {
                hr = _UpdateDiskFreeSpace(pidl, pfssci);
                ILFree(pidl);
            }
        }
        psf2->Release();
    }
    return hr;
}

void _ShowNoSelectionState(IUnknown *psite, LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci)
{
    TCHAR szTemp[30], szTempHidden[30], szFreeSpace[30];
    UINT ids = IDS_FSSTATUSBASE;

    // Assume we don't need freespace info
    szFreeSpace[0] = 0;

    // See if we need the freespace info (idDrive != -1)
    ULONGLONG cbFree = -1;
    if (pidlFolder && IsExplorerModeBrowser(psite))
    {
        if (pfssci->cbFree == -1)
            _UpdateDiskFreeSpace(pidlFolder, pfssci);

        // cbFree couldstill be -1 if GetDiskFreeSpace didn't get any info
        cbFree = pfssci->cbFree;
        if (cbFree != -1)
        {
            ShortSizeFormat64(pfssci->cbFree, szFreeSpace, ARRAYSIZE(szFreeSpace));
            ids += DIDS_FSSPACE;            // Also show freespace
        }
    }

    // hidden files -> show "and nn hidden".
    if (pfssci->cHiddenFiles)
        ids += DIDS_FSHIDDEN;

    // Get the status string
    LPTSTR pszStatus = ShellConstructMessageString(HINST_THISDLL, IntToPtr_(LPCTSTR, ids),
                AddCommas(pfssci->cFiles, szTemp, ARRAYSIZE(szTemp)),
                AddCommas(pfssci->cHiddenFiles, szTempHidden, ARRAYSIZE(szTempHidden)),
                szFreeSpace);

    // Get the size portion
    StrFormatByteSize64(pfssci->cbSize, szTemp, ARRAYSIZE(szTemp));

    LPCTSTR rgpsz[] = { pszStatus, szTemp };
    SetStatusText(psite, rgpsz, 0, 1);

    LocalFree(pszStatus);   // may be NULL
}

STDAPI ViewUpdateStatusBar(IUnknown *psite, LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci)
{
    HRESULT hr = S_OK;
    switch (pfssci->nItems)
    {
    case 0:
        _ShowNoSelectionState(psite, pidlFolder, pfssci);
        hr = S_OK;
        break;

    case 1:
        ViewShowSelectionState(psite, pfssci); //Set the Size only.
        hr = SFVUSB_INITED;   // Make defview set infotip as text
        break;

    default:
        ViewShowSelectionState(psite, pfssci);
        hr = S_OK;
        break;
    }
    return hr;
}

STDAPI_(void) ViewInsertDeleteItem(IShellFolder2 *psf, FSSELCHANGEINFO *pfssci, LPCITEMIDLIST pidl, int iMul)
{
    ULONGLONG ullSize;
    if (SUCCEEDED(GetLongProperty(psf, pidl, &SCID_SIZE, &ullSize)))
    {
        pfssci->cFiles += iMul;
        pfssci->cbSize += iMul * ullSize;
        if (pfssci->cFiles <= 0)
        {
            pfssci->cbSize = 0;
            pfssci->cFiles = 0;
        }
    } 
    else 
    {
        // means a delete all
        pfssci->cFiles = 0;
        pfssci->cbSize = 0;
        pfssci->nItems = 0;
        pfssci->cbBytes = 0;
        pfssci->cNonFolders = 0;
        pfssci->cHiddenFiles = 0;
    }
}

STDAPI_(void) ViewSelChange(IShellFolder2 *psf, SFVM_SELCHANGE_DATA* pdvsci, FSSELCHANGEINFO *pfssci)
{
    ULONGLONG ullSize;
    LPCITEMIDLIST pidl = (LPCITEMIDLIST)pdvsci->lParamItem;
    if (SUCCEEDED(GetLongProperty(psf, pidl, &SCID_SIZE, &ullSize)))
    {
        int iMul = -1;

        // Update selection count
        if (pdvsci->uNewState & LVIS_SELECTED)
            iMul = 1;
        else
            ASSERT(0 != pfssci->nItems);

        // assert that soemthing changed
        ASSERT((pdvsci->uOldState & LVIS_SELECTED) != (pdvsci->uNewState & LVIS_SELECTED));

        pfssci->nItems += iMul;

        pfssci->cbBytes += (iMul * ullSize);
        if (!SHGetAttributes(psf, pidl, SFGAO_FOLDER))
            pfssci->cNonFolders += iMul;
    }
}

STDAPI DefaultGetWebViewTemplateFromHandler(LPCTSTR pszKey, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    HRESULT hr = S_OK;

    TCHAR szKey[200];
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}"), pszKey);

    DWORD cbSize = sizeof(pvit->szWebView);
    if (ERROR_SUCCESS == SHGetValueW(HKEY_CLASSES_ROOT, szKey, TEXT("PersistMoniker"), NULL, pvit->szWebView, &cbSize))
    {
        //if the %UserAppData% exists, expand it!
        hr = ExpandOtherVariables(pvit->szWebView, ARRAYSIZE(pvit->szWebView));
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI DefaultGetWebViewTemplateFromClsid(REFCLSID clsid, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    TCHAR szHandler[6+40] = TEXT("CLSID\\"); // 6 for "CLSID\\", 40 for GUID
    SHStringFromGUID(clsid, &szHandler[6], ARRAYSIZE(szHandler)-6);
    return DefaultGetWebViewTemplateFromHandler(szHandler, pvit);
}

STDAPI DefaultGetWebViewTemplateFromPath(LPCTSTR pszDir, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    TCHAR szPath[MAX_PATH+40]; // slop for "webview://file://"
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_WEBVIEWTEMPLATE;
    fcs.pszWebViewTemplate = szPath;
    fcs.cchWebViewTemplate = ARRAYSIZE(szPath);
    HRESULT hr = SHGetSetFolderCustomSettings(&fcs, pszDir, FCS_READ);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszPath = szPath;
        // We want to allow relative paths for the file: protocol
        //
        if (0 == StrCmpNI(TEXT("file://"), pszPath, 7)) // ARRAYSIZE(TEXT("file://"))
        {
            pszPath += 7;   // ARRAYSIZE(TEXT("file://"))
        }
        // for webview:// compatibility, keep this working:
        else if (0 == StrCmpNI(TEXT("webview://file://"), pszPath, 17)) // ARRAYSIZE(TEXT("webview://file://"))
        {
            pszPath += 17;  // ARRAYSIZE(TEXT("webview://file://"))
        }
        // handle relative references...
        PathCombine(pszPath, pszDir, pszPath);

        StrCpyN(pvit->szWebView, szPath, ARRAYSIZE(pvit->szWebView));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sfvext.cpp ===
#include "shellprv.h"
#include <shellp.h>
#include "ole2dup.h"
#include "defview.h"
#include "bookmk.h"

#include <sfview.h>
#include "defviewp.h"
#include "ids.h"
#include <htiface.h>
#include <olectl.h>
#include "mshtml.h"
#include <mshtmdid.h>
#include <shguidp.h>    // get the CLSID definitions, the bits are built into shguidp.lib
#include "basefvcb.h"
#include "clsobj.h"

#define TF_FOCUS    TF_ALLOC

CSFVFrame::~CSFVFrame()
{
    ATOMICRELEASE(_pvoActive);
    ATOMICRELEASE(_pActive);
    ATOMICRELEASE(_pDocView);
    ATOMICRELEASE(_pOleObj);
    if (_dwConnectionCookie)
        _RemoveReadyStateNotifyCapability();
    ATOMICRELEASE(_pOleObjNew);
}

// Default implementation of SFVM_GETVIEWDATA is to grab the info
// from SFVM_GETVIEWS.  We no longer provide a default implementation
// of that message, so if SFVM_GETVIEWS fails, we manually look in:
// shellex\ExtShellFolderViews\{VID_WebView}\PersistMoniker
//
HRESULT CCallback::OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);

    // try the old message
    pvit->szWebView[0] = 0;

    // For now, use the old one - clean up soon...
    SFVM_VIEWINFO_DATA data;
    data.bWantWebview = TRUE;
    HRESULT hr = pView->CallCB(SFVM_GETVIEWINFO, (WPARAM)uViewMode, (LPARAM)&data);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCopy(pvit->szWebView, ARRAYSIZE(pvit->szWebView), data.szWebView);
    }
    else
    {
        if (FAILED(hr))
            hr = TryLegacyGetViews(pvit);
    }

    return hr;
}

void CleanUpDocView(IOleDocumentView* pDocView, IOleObject* pOleObj)
{
    pDocView->UIActivate(FALSE);

    IOleInPlaceObject* pipo;
    if (SUCCEEDED(pOleObj->QueryInterface(IID_PPV_ARG(IOleInPlaceObject, &pipo))))
    {
        pipo->InPlaceDeactivate();
        pipo->Release();
    }
    pDocView->CloseView(0);
    pDocView->SetInPlaceSite(NULL);
    pDocView->Release();
}

void CSFVFrame::_CleanupOldDocObject( )
{
    //See if we have already switched to the new Ole Obj
    if (_pDocView)
    {
        //Save the current values first!
        IOleObject          *pOleObjOld = _pOleObj;
        IOleDocumentView    *pDocViewOld = _pDocView;

        _pDocView = NULL;
        _pOleObj = NULL;
        CleanUpDocView(pDocViewOld, pOleObjOld);
        _CleanUpOleObjAndDt(pOleObjOld);
        SetActiveObject(NULL, NULL);
    }

    if (_dwConnectionCookie)
        _RemoveReadyStateNotifyCapability();

    _CleanupNewOleObj();
}

void CSFVFrame::_CleanUpOleObj(IOleObject* pOleObj)
{
    pOleObj->Close(OLECLOSE_NOSAVE);
    pOleObj->SetClientSite(NULL);
    pOleObj->Release();
}

void CSFVFrame::_CleanUpOleObjAndDt(IOleObject* pOleObj)
{
    _CleanUpOleObj(pOleObj);

    // If we have a wrapping droptarget, release it now. 
    IDropTarget* pdtTemp = _cSite._dt._pdtFrame;
    if (pdtTemp) 
    {
        _cSite._dt._pdtFrame = NULL;
        pdtTemp->Release();
    }
}

void CSFVFrame::_CleanupNewOleObj()
{
    IOleObject *pOleObj = _pOleObjNew;
    if (pOleObj)
    {
        _pOleObjNew = NULL;
        _CleanUpOleObj(pOleObj);
    }
}

void DisableActiveDesktop()
{
    SHELLSTATE  ss;

    // Disable this settings in the registry!
    ss.fDesktopHTML = FALSE;
    SHGetSetSettings(&ss, SSF_DESKTOPHTML, TRUE);  // Write back the new

    // Tell the user that we have just disabled the active desktop!
    ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_HTMLFILE_NOTFOUND),
                       MAKEINTRESOURCE(IDS_DESKTOP),
                       MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
}

HRESULT CSFVFrame::_GetCurrentZone(IOleObject *pOleObj, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    VariantInit(pvar);
    V_VT(pvar) = VT_EMPTY;

    IOleCommandTarget* pct;
    if (pOleObj && SUCCEEDED(GetCommandTarget(&pct)))
    {
        hr = pct->Exec(&CGID_Explorer, SBCMDID_MIXEDZONE, 0, 0, pvar);
        pct->Release();
    } 
    else 
    {
        V_VT(pvar) = VT_UI4;
        V_UI4(pvar) = URLZONE_LOCAL_MACHINE; // Default is "My Computer"
        pView->CallCB(SFVM_GETZONE, 0, (LPARAM)&V_UI4(pvar));
    }

    if (V_VT(pvar) == VT_UI4) // We were able to figure out what zone we are in
        { }                   // the zone is just fine
    else if (V_VT(pvar) == VT_NULL)  // MSHTML has figured us to be in a mixed zone
        V_UI4(pvar) = ZONE_MIXED;
    else // We don't have zone info
        V_UI4(pvar) = ZONE_UNKNOWN;
       
    V_VT(pvar) = VT_UI4;
            
    return hr;
}

HRESULT CSFVFrame::_UpdateZonesStatusPane(IOleObject *pOleObj)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    VARIANT var;
    HRESULT hr = _GetCurrentZone(pOleObj, &var);

    // Tell CShellbrowser to show the zone stuff in the second pane
    ASSERT(V_VT(&var) == VT_UI4);

    // The "2" means "second pane"
    V_UI4(&var) = MAKELONG(2, V_UI4(&var));

    IUnknown_Exec(pView->_psb, &CGID_Explorer, SBCMDID_MIXEDZONE, 0, &var, NULL);

    ASSERT((V_VT(&var) == VT_I4)    || (V_VT(&var) == VT_UI4)  || 
           (V_VT(&var) == VT_EMPTY) || (V_VT(&var) == VT_NULL));

    return hr;
}

HRESULT CSFVFrame::_GetHTMLBackgroundColor(COLORREF *pclr)
{
    HRESULT hr = E_FAIL;

    if (_bgColor == CLR_INVALID)
        hr = IUnknown_HTMLBackgroundColor(_pOleObj, &_bgColor);
    else
        hr = S_OK;  // cached

    if (SUCCEEDED(hr))
        *pclr = _bgColor;
    return hr;
}

#ifdef DEBUG

BOOL_PTR CALLBACK s_WVDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 
lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        RECT rc;
        if (GetWindowRect(hWnd, &rc))
        {
            HWND hEdit = CreateWindow(TEXT("edit"), NULL, WS_CHILD|WS_VISIBLE|ES_MULTILINE|ES_AUTOVSCROLL, 10, 10, (rc.right-rc.left)-20, (rc.bottom-rc.top)-20, hWnd, NULL, NULL, 0);
            if (hEdit)
            {
                SetWindowTextA(hEdit, (LPCSTR)lParam);
            }
        }
        SetWindowText(hWnd, TEXT("WebView Content (DEBUG)"));
        break;
    }

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            EndDialog(hWnd, 0);
            break;
        }
        break;
    }

    return FALSE;
}

void CSFVFrame::_ShowWebViewContent()
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);

    HRESULT hr = E_FAIL;
    LPSTR pszFree = NULL;

    if (_pOleObj)
    {
        IStream* pstm = SHCreateMemStream(NULL, 0);
        if (pstm)
        {
            VARIANTARG vt;
            vt.vt = VT_UNKNOWN;
            vt.punkVal = pstm;

            #define IDM_DEBUG_GETTREETEXT 7102 // stolen from mshtml\src\include\privcid.h

            if (SUCCEEDED(IUnknown_Exec(_pOleObj, &CGID_MSHTML, IDM_DEBUG_GETTREETEXT, 0, &vt, NULL)))
            {
                STATSTG stg;
                if (SUCCEEDED(pstm->Stat(&stg, 0)))
                {
                    pszFree = (LPSTR)LocalAlloc(LPTR, stg.cbSize.LowPart+2); // stream doesn't include NULL...
                    if (pszFree)
                    {
                        pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);
                        pstm->Read(pszFree, stg.cbSize.LowPart, NULL);
                    }
                }
            }

            pstm->Release();
        }
    }

    // I'm not sure if the output from Trident is always ANSI, but right now that seems to be the case.
    LPSTR pszMessage = pszFree ? pszFree : "Error collecting WebView content";

    DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DRV_HWTAB), pView->_hwndView, s_WVDlgProc, (LPARAM)pszFree);

    if (pszFree)
        LocalFree(pszFree);
}
#endif

// ready state complete has occured, ready to do the switch thing.  

HRESULT CSFVFrame::_SwitchToNewOleObj()
{
    HRESULT hr = S_OK;

    if (!_fSwitchedToNewOleObj && _pOleObjNew)
    {
        _fSwitchedToNewOleObj = TRUE;

        CDefView* pView = IToClass(CDefView, _cFrame, this);
    
        //Save the current values first!
        IOleObject          *pOleObjOld = _pOleObj;
        IOleDocumentView    *pDocViewOld = _pDocView;
        IOleObject          *pOleObjNew = _pOleObjNew;
        
        _pDocView = NULL;
        _pOleObj = NULL;
        _pOleObjNew = NULL;
    
        //If we already have one, destroy it!
        if (pDocViewOld)
        {
            //To prevent flashing, set the flag that avoids the painting
            SendMessage(pView->_hwndView, WM_SETREDRAW, 0, 0);
    
            CleanUpDocView(pDocViewOld, pOleObjOld);
            _CleanUpOleObjAndDt(pOleObjOld);
            SetActiveObject(NULL, NULL);
    
            //Is the ViewWindow still around?
            if (IsWindow(pView->_hwndView))
            {
                SendMessage(pView->_hwndView, WM_SETREDRAW, TRUE, 0);
                if (pView->_hwndListview)
                    InvalidateRect(pView->_hwndListview, NULL, TRUE);
            }
        }
    
        // HACK: We need to set the host names for Word to force embedding mode
        pOleObjNew->SetHostNames(L"1", L"2");
    
        OleRun(pOleObjNew);
    
        IOleDocumentView* pDocView = NULL;
    
        IOleDocument* pDocObj;
        hr = pOleObjNew->QueryInterface(IID_PPV_ARG(IOleDocument, &pDocObj));
        if (SUCCEEDED(hr))
        {
            hr = pDocObj->CreateView(&_cSite, NULL, 0, &pDocView);
            if (SUCCEEDED(hr))
            {
                RECT rcView;
    
                pDocView->SetInPlaceSite(&_cSite);
    
                GetClientRect(pView->_hwndView, &rcView);
                hr = pOleObjNew->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL,
                                &_cSite, (UINT)-1, pView->_hwndView, &rcView);
                if (FAILED(hr))
                    CleanUpDocView(pDocView, pOleObjNew);
            }
    
            pDocObj->Release();
        }
    
        if (SUCCEEDED(hr))
        {
            hr = S_OK; // S_FALSE -> S_OK, needed?

            ASSERT(_pOleObj == NULL);
            ASSERT(_pDocView == NULL);

            _pDocView = pDocView;
            pDocView->AddRef();     // copy hold the ref for our copy

            _pOleObj = pOleObjNew;
            _pOleObjNew = NULL;

            RECT rcClient;
    
            // Make sure the new view is the correct size
            GetClientRect(pView->_hwndView, &rcClient);
            SetRect(&rcClient);

            // If this is desktop, then we need to see the listview's background color
            if (pView->_IsDesktop())
            {
                _bgColor = CLR_INVALID;

                pView->_SetFolderColors(); //Tell the listview about color change!
            }
        }
        else
        {
            if (pView->_IsDesktop())
                PostMessage(pView->_hwndView, WM_DSV_DISABLEACTIVEDESKTOP, 0, 0);
    
            // Clean up if necessary
            _CleanupNewOleObj();
        }

        ATOMICRELEASE(pDocView);
    }

    return hr;
}

// IBindStatusCallback impl
HRESULT CSFVFrame::CBindStatusCallback::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSFVFrame::CBindStatusCallback, IBindStatusCallback),  // IID_IBindStatusCallback
        QITABENT(CSFVFrame::CBindStatusCallback, IServiceProvider),     // IID_IServiceProvider
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CSFVFrame::CBindStatusCallback::AddRef(void)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _bsc, this);
    return pFrame->AddRef();
}

ULONG CSFVFrame::CBindStatusCallback::Release(void)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _bsc, this);
    return pFrame->Release();
}

HRESULT CSFVFrame::CBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::GetPriority(LONG *pnPriority)
{
    *pnPriority = NORMAL_PRIORITY_CLASS;
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnLowResource(DWORD reserved)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnStopBinding(HRESULT hr, LPCWSTR pszError)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _bsc, this);

    if (IsEqualGUID(guidService, SID_DefView))
    {
        // QueryService from a pluggable protocol/mime filter winds up
        // here during the Bind, but Trident re-binds during F5 processing
        // so the QueryService winds up directly at _cSite. Handle all
        // SID_DefView processing there so there's no discrepencies.
        //
        return pFrame->_cSite.QueryService(guidService, riid, ppv);
    }

    *ppv = NULL;
    return E_FAIL;
}

HRESULT CSFVFrame::_CreateNewOleObjFromMoniker(LPCWSTR wszMoniker, IOleObject **ppOleObj)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    HRESULT hr = E_FAIL;
    IOleObject* pOleObj = NULL;

    if (wszMoniker[0])
    {
        LPWSTR pwszExtension = PathFindExtensionW(wszMoniker);
        // Only htt's are allowed
        if (StrCmpIW(pwszExtension, L".htt") == 0)
        {
            IMoniker * pMoniker;
            hr = CreateURLMoniker(NULL, wszMoniker, &pMoniker);
            if (SUCCEEDED(hr))
            {
                IBindCtx * pbc;
                hr = CreateBindCtx(0, &pbc);
                if (SUCCEEDED(hr))
                {
                    // NOTE: We only support synchronous bind here!
                    //
                    //
                    //  Associate the client site as an object parameter to this
                    // bind context so that Trident can pick it up while processing
                    // IPersistMoniker::Load().
                    //
                    pbc->RegisterObjectParam(WSZGUID_OPID_DocObjClientSite,
                                                SAFECAST((&_cSite), IOleClientSite*));
                                        
                    RegisterBindStatusCallback(pbc, SAFECAST(&_bsc, IBindStatusCallback*), 0, 0);

                    hr = pMoniker->BindToObject(pbc, NULL, IID_PPV_ARG(IOleObject, &pOleObj));
                    if (FAILED(hr))
                    {
                        if (pView->_IsDesktop())
                            PostMessage(pView->_hwndView, WM_DSV_DISABLEACTIVEDESKTOP, 0, 0);
                    }

                    RevokeBindStatusCallback(pbc, SAFECAST(&_bsc, IBindStatusCallback*));
                    pbc->Release();
                }
                pMoniker->Release();
            }
        }
    }

    *ppOleObj = pOleObj;

    return hr;
}

HRESULT CSFVFrame::_GetCurrentWebViewMoniker(LPWSTR pszCurrentMoniker, DWORD cchCurrentMoniker)
{
    HRESULT hr = StringCchCopy(pszCurrentMoniker, cchCurrentMoniker, _szCurrentWebViewMoniker);
    if (SUCCEEDED(hr))
    {
        if (pszCurrentMoniker[0] == TEXT('\0'))
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

// Show Web View content for the specified template/moniker
//
HRESULT CSFVFrame::ShowWebView(LPCWSTR pszMoniker)
{
    if (GetSystemMetrics(SM_CLEANBOOT))
        return E_FAIL;

    // kill previous readystatenotify and cleanup old pending hoster.
    //
    // TODO: move into _CleanupNewOleObj
    if (_dwConnectionCookie)
        _RemoveReadyStateNotifyCapability();

    // Clean up if a new Ole object is already awaiting ready state
    if (_pOleObjNew)
        _CleanupNewOleObj();    // TODO: rename to _CleanupPendingView
    ASSERT(_dwConnectionCookie == NULL);
    ASSERT(_pOleObjNew == NULL);

    // Create and initialize the new old object!
    IOleObject *pOleObj;

    HRESULT hr = _CreateNewOleObjFromMoniker(pszMoniker, &pOleObj);
    if (SUCCEEDED(hr) && pOleObj)
    {
        if (!_pOleObjNew)
        {
            CDefView* pView = IToClass(CDefView, _cFrame, this);

            hr = StringCchCopy(_szCurrentWebViewMoniker, ARRAYSIZE(_szCurrentWebViewMoniker), pszMoniker);
            if (SUCCEEDED(hr))
            {
                hr = _ShowExtView_Helper(pOleObj);  // takes ownership of pOleObj (yuck)
                pOleObj->SetClientSite(&_cSite);

                pView->ShowHideListView(); // we just changed IsWebView
            }
            else
            {
                pOleObj->Release();
            }
        }
        else
        {
            // Yikes!  We got reentered during the creation of the OleObj, blow away the object
            // and just return.
            pOleObj->Release();
        }
    }

    return hr;
}

HRESULT CSFVFrame::HideWebView()
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    _szCurrentWebViewMoniker[0] = 0;
    _CleanupOldDocObject();

    pView->ShowHideListView(); // we just changed IsWebView

    return S_OK;
}


HRESULT CSFVFrame::_ShowExtView_Helper(IOleObject* pOleObj)
{
    HRESULT hr;

    // Don't leak the old object, it must be NULL at this point
    ASSERT(_pOleObjNew == NULL);

    // Save the new ole object
    _pOleObjNew = pOleObj;
    _fSwitchedToNewOleObj = FALSE;

    // Establish to connection point to receive the READYSTATE notification.
    if (!_SetupReadyStateNotifyCapability())
    {
        _SwitchToNewOleObj();
        _UpdateZonesStatusPane(_pOleObj);   
        // If the object doesn't support readystate (or it's already interactive)
        // then we return S_OK to indicate synchronous switch.
        hr = S_OK;
    }
    else
    {
        // We're waiting on the docobj, we'll call _SwitchToNewOleObj
        // when it goes interactive...
        hr = S_FALSE;
    }

    return hr;
}

BOOL CSFVFrame::_SetupReadyStateNotifyCapability()
{
    // By default we don't have gray-flash communication
    BOOL fSupportsReadystate = FALSE;
    
    // Sanity Check
    if (!_pOleObjNew)  
        return fSupportsReadystate;
    
    // Check for proper readystate support
    BOOL fReadyStateOK = FALSE;
    IDispatch *pdisp;
    if (SUCCEEDED(_pOleObjNew->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
    {
        EXCEPINFO exInfo;
        VARIANTARG va = {0};
        DISPPARAMS dp = {0};

        if (SUCCEEDED(pdisp->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &dp, &va, &exInfo, NULL)))
        {
            if ((va.vt == VT_I4) && (va.lVal < READYSTATE_COMPLETE))
            {
                fReadyStateOK = TRUE;
            }
        }
        pdisp->Release();
    }

    if (fReadyStateOK)
    {
        // Check and Set-Up IPropertyNotifySink
        if (SUCCEEDED(ConnectToConnectionPoint(SAFECAST(this, IPropertyNotifySink*), IID_IPropertyNotifySink, TRUE, _pOleObjNew, &_dwConnectionCookie, NULL)))
        {
            fSupportsReadystate = TRUE;
            _fReadyStateInteractiveProcessed = FALSE;
            _fReadyStateComplete = FALSE;
            _pOleObjReadyState = _pOleObjNew;
            _pOleObjReadyState->AddRef();
        }
    }

    return fSupportsReadystate;
}

BOOL CSFVFrame::_RemoveReadyStateNotifyCapability()
{
    BOOL fRet = FALSE;

    if (_dwConnectionCookie)
    {
        ASSERT(_pOleObjReadyState);
        ConnectToConnectionPoint(NULL, IID_IPropertyNotifySink, FALSE, _pOleObjReadyState, &_dwConnectionCookie, NULL);
        ATOMICRELEASE(_pOleObjReadyState);
        fRet = TRUE;
        _dwConnectionCookie = 0;
    }

    return fRet;
}

HWND CSFVFrame::GetExtendedViewWindow()
{
    HWND hwnd;

    if (SUCCEEDED(IUnknown_GetWindow(_pDocView, &hwnd)))
        return hwnd;
        
    if (_pActive && SUCCEEDED(_pActive->GetWindow(&hwnd)))
        return hwnd;

    return NULL;
}

STDMETHODIMP CSFVSite::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSFVSite, IOleInPlaceSite),
        QITABENTMULTI(CSFVSite, IOleWindow, IOleInPlaceSite),
        QITABENT(CSFVSite, IOleClientSite),
        QITABENT(CSFVSite, IOleDocumentSite),
        QITABENT(CSFVSite, IServiceProvider),
        QITABENT(CSFVSite, IOleCommandTarget),
        QITABENT(CSFVSite, IDocHostUIHandler),
        QITABENT(CSFVSite, IOleControlSite),
        QITABENT(CSFVSite, IDispatch),
        QITABENT(CSFVSite, IInternetSecurityManager),
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSFVSite::AddRef()
{
    return IToClass(CSFVFrame, _cSite, this)->AddRef();
}

STDMETHODIMP_(ULONG) CSFVSite::Release()
{
    return IToClass(CSFVFrame, _cSite, this)->Release();
}

// IOleWindow
STDMETHODIMP CSFVSite::GetWindow(HWND *phwnd)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    return pFrame->GetWindow(phwnd);
}

STDMETHODIMP CSFVSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    return pFrame->ContextSensitiveHelp(fEnterMode);
}

// IInternetSecurityManager
HRESULT CSFVSite::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE * pPolicy, DWORD cbPolicy, BYTE * pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if ((((URLACTION_ACTIVEX_MIN <= dwAction) &&
          (URLACTION_ACTIVEX_MAX >= dwAction)) ||
         ((URLACTION_SCRIPT_MIN <= dwAction) &&
          (URLACTION_SCRIPT_MAX >= dwAction))) &&
        pContext &&
        (sizeof(CLSID) == cbContext) &&
        (IsEqualIID(*(CLSID *) pContext, CLSID_WebViewFolderContents) ||
        (IsEqualIID(*(CLSID *) pContext, CLSID_ThumbCtl))))
    {
        if (EVAL(pPolicy) && EVAL(sizeof(DWORD) == cbPolicy))
        {
            *pPolicy = (DWORD) URLPOLICY_ALLOW;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

// IOleInPlaceSite
STDMETHODIMP CSFVSite::CanInPlaceActivate(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnInPlaceActivate(void)
{
    TraceMsg(TF_FOCUS, "sfvf.oipa: _pAct=%x", IToClass(CSFVFrame, _cSite, this)->_pActive);
    IToClass(CSFVFrame, _cSite, this)->_uState = SVUIA_ACTIVATE_NOFOCUS;
    return S_OK;
}

STDMETHODIMP CSFVSite::OnUIActivate(void)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame._cSite, this);

    HRESULT hr = pView->_OnViewWindowActive();

    pFrame->_uState = SVUIA_ACTIVATE_FOCUS;
    TraceMsg(TF_FOCUS, "sfvf.ouia: _pAct'=%x", IToClass(CSFVFrame, _cSite, this)->_pActive);
    return hr;
}

STDMETHODIMP CSFVSite::GetWindowContext(
    /* [out] */ IOleInPlaceFrame **ppFrame,
    /* [out] */ IOleInPlaceUIWindow **ppDoc,
    /* [out] */ LPRECT lprcPosRect,
    /* [out] */ LPRECT lprcClipRect,
    /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    *ppFrame = pFrame; pFrame->AddRef();
    *ppDoc = NULL; // indicating that doc window == frame window

    GetClientRect(pView->_hwndView, lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = pView->_hwndView;   // Yes, should be view window
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;

    return S_OK;
}

STDMETHODIMP CSFVSite::Scroll(SIZE scrollExtant)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnUIDeactivate(BOOL fUndoable)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnInPlaceDeactivate(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::DiscardUndoState(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::DeactivateAndUndo(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnPosRectChange(LPCRECT lprcPosRect)
{
    return S_OK;
}

// IOleClientSite
STDMETHODIMP CSFVSite::SaveObject(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_FAIL;
}

STDMETHODIMP CSFVSite::GetContainer(IOleContainer **ppContainer)
{
    *ppContainer = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CSFVSite::ShowObject(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::RequestNewObjectLayout(void)
{
    return S_OK;
}

// IOleDocumentSite
STDMETHODIMP CSFVSite::ActivateMe(IOleDocumentView *pviewToActivate)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    if (pView->_uState == SVUIA_ACTIVATE_FOCUS)
        pviewToActivate->UIActivate(TRUE);
    pviewToActivate->Show(TRUE);
    return S_OK;
}

//
// IOleCommandTarget stuff - just forward to _psb
//
STDMETHODIMP CSFVSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);
    IOleCommandTarget* pct;
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (SUCCEEDED(pView->_psb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
    {
        hr = pct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        pct->Release();
    }

    return hr;
}

STDMETHODIMP CSFVSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup)
    {
        if (IsEqualIID(*pguidCmdGroup, CGID_DefView))
        {
            hr = E_INVALIDARG;
            if (pvarargOut) 
            {
                VariantClear(pvarargOut);
                TCHAR szPath[MAX_PATH];

                switch (nCmdID)
                {
                case DVCMDID_GETTHISDIRPATH:
                case DVCMDID_GETTHISDIRNAME:
                    hr = pView->_GetNameAndFlags(nCmdID == DVCMDID_GETTHISDIRPATH ? 
                            SHGDN_FORPARSING : SHGDN_INFOLDER, 
                            szPath, ARRAYSIZE(szPath), NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = InitVariantFromStr(pvarargOut, szPath);
                    }
                    break;

                case DVCMDID_GETTEMPLATEDIRNAME:
                    if (pFrame->IsWebView()) 
                    {
                        WCHAR wszMoniker[MAX_PATH];
                        if (SUCCEEDED(pFrame->_GetCurrentWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker))) ||
                            SUCCEEDED(pView->_GetWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker))))
                        {
                            hr = InitVariantFromStr(pvarargOut, wszMoniker);
                        }
                    }
                    break;
                }
            }
            return hr;
        }
        else if (IsEqualIID(*pguidCmdGroup, CGID_Explorer))
        {
            if ((SBCMDID_UPDATETRAVELLOG == nCmdID) && !pView->_fCanActivateNow)
            {
                //
                // We get a spurious UPDATETRAVELLOG command because we have enabled
                // CDefviewPersistHistory to call the MSHTML IPersistHistory in webview
                // mode. 
                // This seems to be the best place to fix this as the call stack
                // below this call is trident, and the call stack above this call is 
                // browser code.
                //
                // The travellog is subsequently updated correctly when 
                // CBaseBrowser2::ActivatePendingView is called.
                //
                return S_OK;
            }
        }
        // fall through on other cmd groups...
    }
    else if ((OLECMDID_SETTITLE == nCmdID) && !pView->_fCanActivateNow)
    {
        // NT #282632: Don't forward this message if we aren't the active view.
        return S_OK;
    }
   
    IOleCommandTarget* pct;
    if (SUCCEEDED(pView->_psb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
    {
        hr = pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        pct->Release();
    }

    return hr;
}

//***   IOleControlSite {

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    int nDir = 0;

    if (!pMsg)
        return nDir;

    if (pMsg->message != WM_KEYDOWN)
        return nDir;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return nDir;

    nDir = (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;

#ifdef KEYBOARDCUES
    SendMessage(GetParent(pMsg->hwnd), WM_CHANGEUISTATE,
        MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
#endif
    
    return nDir;
}

//***   CSFVSite::TranslateAccelerator (IOCS::TranslateAccelerator)
// NOTES
//  (following comment/logic stolen from shdocvw/dochost.cpp)
//  trident (or any other DO that uses IOCS::TA) calls us back when TABing
//  off the last link.  to handle it, we flag it for our original caller
//  (IOIPAO::TA), and then pretend we handled it by telling trident S_OK.
//  trident returns S_OK to IOIPAO::TA, which checks the flag and says
//  'trident did *not* handle it' by returning S_FALSE.  that propagates
//  way up to the top where it sees it was a TAB so it does a CycleFocus.
//
//  that's how we do it when we're top-level.  when we're a frameset, we
//  need to do it the 'real' way, sending it up to our parent IOCS.
HRESULT CSFVSite::TranslateAccelerator(MSG *pMsg, DWORD grfModifiers)
{
    if (IsVK_TABCycler(pMsg)) 
    {
        CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
        CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

        TraceMsg(TF_FOCUS, "csfvs::IOCS::TA(wParam=VK_TAB) ret _fCycleFocus=TRUE hr=S_OK (lie)");
        // defer it, set flag for cdv::IOIPAO::TA, and pretend we handled it
        ASSERT(!pView->_fCycleFocus);
        pView->_fCycleFocus = TRUE;
        return S_OK;
    }
    //ASSERT(!pView->_fCycleFocus);
    return S_FALSE;
}

// }

// IServiceProvider

HRESULT CSFVSite::QueryService(REFGUID guidService, REFIID riid, void ** ppv)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    *ppv = NULL;
    HRESULT hr = E_FAIL;
    if (guidService == SID_DefView)
    {
        if (riid == IID_IDefViewFrame && pView->_IsDesktop()) 
        {
            return E_FAIL; 
        } 
        // Try site QI
        hr = QueryInterface(riid, ppv);
    }

    if (FAILED(hr))
    {
        // Delegate to defview QS
        hr = pView->QueryService(guidService, riid, ppv);
        if (FAILED(hr))
        {
            // Look for IID_IInternetSecurityManager
            if (guidService == IID_IInternetSecurityManager)
            {
                ASSERT(riid == IID_IInternetSecurityManager);
                hr = QueryInterface(riid, ppv);
            }
        }
    }
    return hr;
}

HRESULT CSFVSite::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                         VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!pVarResult)
        return E_INVALIDARG;

    //Get pointer to the defview
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    // We handle the query of whether we want to show images, ourselves.
    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
            case DISPID_AMBIENT_DLCONTROL:
            {
                // Do the following only if this is NOT the desktop. 
                // (Because Desktop is in offline mode, it should 
                // return DLCTL_OFFLINEIFNOTCONNECTED flag). The following code
                // should be executed only for NON-desktop folders.
                if (!(pView->_IsDesktop()))
                {
                    pVarResult->vt = VT_I4;
                    pVarResult->lVal = DLCTL_DLIMAGES | DLCTL_VIDEOS;
                    return S_OK;
                }
            }
        }
    }

    // We delegate all other queries to shdocvw.
    if (!_peds)
    {
        IUnknown_QueryService(pView->_psb, IID_IExpDispSupport, IID_PPV_ARG(IExpDispSupport, &_peds));
    }

    if (!_peds)
        return E_NOTIMPL;

    return _peds->OnInvoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr);
}

HRESULT CHostDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CHostDropTarget, IDropTarget),  // IID_IDropTarget
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CHostDropTarget::AddRef(void)
{
    CSFVSite* pcsfvs = IToClass(CSFVSite, _dt, this);
    return pcsfvs->AddRef();
}

ULONG CHostDropTarget::Release(void)
{
    CSFVSite* pcsfvs = IToClass(CSFVSite, _dt, this);
    return pcsfvs->Release();
}

HRESULT CHostDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _pdtFrame->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
}

HRESULT CHostDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _pdtFrame->DragOver(grfKeyState, pt, pdwEffect);
}

HRESULT CHostDropTarget::DragLeave(void)
{
    return _pdtFrame->DragLeave();
}

HRESULT CHostDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _pdtFrame->Drop(pdtobj, grfKeyState, pt, pdwEffect);
}

STDMETHODIMP CSFVFrame::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CSFVFrame, IOleWindow, IOleInPlaceFrame),  // IID_IOleWindow
        QITABENTMULTI(CSFVFrame, IOleInPlaceUIWindow, IOleInPlaceFrame),  // IID_IOleInPlaceUIWindow
        QITABENT(CSFVFrame, IOleInPlaceFrame),        // IID_IOleInPlaceFrame
        QITABENT(CSFVFrame, IAdviseSink),             // IID_IAdviseSink
        QITABENT(CSFVFrame, IPropertyNotifySink),     // IID_IPropertyNotifySink
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSFVFrame::AddRef()
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->AddRef();
}

STDMETHODIMP_(ULONG) CSFVFrame::Release()
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->Release();
}

// IOleWindow
STDMETHODIMP CSFVFrame::GetWindow(HWND *phwnd)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->GetWindow(phwnd);
}

STDMETHODIMP CSFVFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->ContextSensitiveHelp(fEnterMode);
}

// IOleInPlaceUIWindow
STDMETHODIMP CSFVFrame::GetBorder(LPRECT lprectBorder)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    GetClientRect(pView->_hwndView, lprectBorder);
    return S_OK;
}

STDMETHODIMP CSFVFrame::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    return INPLACE_E_NOTOOLSPACE;
}

STDMETHODIMP CSFVFrame::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    return INPLACE_E_NOTOOLSPACE;
}

STDMETHODIMP CSFVFrame::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    TraceMsg(TF_FOCUS, "sfvf.sao(pAct'=%x): _pAct=%x", pActiveObject, _pActive);
    if (pActiveObject != _pActive)
    {
        IAdviseSink* pOurSink = SAFECAST(this, IAdviseSink*);
#ifdef DEBUG
        QueryInterface(IID_PPV_ARG(IAdviseSink, &pOurSink));
#endif
        if (_pActive)
        {
            //
            // if we had an OLE view object then disconnect our advise sink and
            // release the view object.
            //
            if (_pvoActive)
            {
                IAdviseSink *pSink;
                if (SUCCEEDED(_pvoActive->GetAdvise(NULL, NULL, &pSink)))
                {
                    // Be polite, only blow away the advise if we're the
                    // one who's listening
                    if (pSink == pOurSink)
                    {
                        _pvoActive->SetAdvise(0, 0, NULL);
                    }

                    // If there was no sink, GetAdvise succeeds but sets
                    // pSink to NULL, so need to check pSink here.
                    if (pSink)
                        pSink->Release();
                }
                ATOMICRELEASE(_pvoActive);
            }

            ATOMICRELEASE(_pActive);
        }
    
        _pActive = pActiveObject;
    
        if (_pActive)
        {
            _pActive->AddRef();

            //
            // try to get an OLE view object and set up an advisory connection.
            //
            if (SUCCEEDED(_pActive->QueryInterface(IID_PPV_ARG(IViewObject, &_pvoActive))))
            {
                ASSERT(_pvoActive);
                _pvoActive->SetAdvise(DVASPECT_CONTENT, 0, pOurSink);
            }
        }

        //
        // since we changed the active view, tell our owner that the content
        // may have changed...
        //
        OnViewChange(DVASPECT_CONTENT, -1);

#ifdef DEBUG
        ATOMICRELEASE(pOurSink);
#endif
    }

    return S_OK;
}


// IOleInPlaceFrame
STDMETHODIMP CSFVFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    if (hmenuShared)
    {
        // No menu merging
        // or fill lpMenuWidths with 0 and return success
        lpMenuWidths->width[0] = 0;
        lpMenuWidths->width[2] = 0;
        lpMenuWidths->width[4] = 0;
    }
    return S_OK;
}

STDMETHODIMP CSFVFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return S_OK;    // No menu merging
}

STDMETHODIMP CSFVFrame::RemoveMenus(HMENU hmenuShared)
{
    return E_FAIL;      // No menu merging
}

//
//  This one is a bit tricky.  If the client wants to clear the status
//  area, then restore it to the original defview status area text.
//
//  For example, in webview, MSHTML will keep clearing the status area
//  whenever you are not over a link, which would otherwise keep erasing
//  the "n object(s) selected" message from defview.
//
//  To really clear the status area, set the text to " " instead of "".
//
STDMETHODIMP CSFVFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    if (pszStatusText && pszStatusText[0])
        return pView->_psb->SetStatusTextSB(pszStatusText);

    pView->_UpdateStatusBar(FALSE);
    return S_OK;
}

STDMETHODIMP CSFVFrame::EnableModeless(BOOL fEnable)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    if (pView->_IsDesktop())
    {
        if (fEnable)
        {
            pView->_fDesktopModal = FALSE;
            if (pView->_fDesktopRefreshPending)  //Was a refresh pending?
            {
                pView->_fDesktopRefreshPending = FALSE;
                //Let's do a refresh asynchronously. 
                PostMessage(pView->_hwndView, WM_KEYDOWN, (WPARAM)VK_F5, 0);
            }
            TraceMsg(TF_DEFVIEW, "A Modal dlg is going away!");
        }
        else
        {
            pView->_fDesktopModal = TRUE;
            TraceMsg(TF_DEFVIEW, "A Modal dlg is coming up for Desktop!");
        }
    }

    return pView->_psb->EnableModelessSB(fEnable);
}

STDMETHODIMP CSFVFrame::TranslateAccelerator(LPMSG lpmsg,WORD wID)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->_psb->TranslateAcceleratorSB(lpmsg, wID);
}

// IAdviseSink
void CSFVFrame::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CSFVFrame::OnViewChange(DWORD dwAspect, LONG lindex)
{
    if (IsWebView() && _pvoActive)
    {
        CDefView *pView = IToClass(CDefView, _cFrame, this);
        pView->PropagateOnViewChange(dwAspect, lindex);
    }
}

void CSFVFrame::OnRename(IMoniker *)
{
}

void CSFVFrame::OnSave()
{
}

void CSFVFrame::OnClose()
{
    if (IsWebView() && _pvoActive)
    {
        CDefView *pView = IToClass(CDefView, _cFrame, this);
        pView->PropagateOnClose();
    }
}

HRESULT CSFVFrame::OnChanged(DISPID dispid)
{
    if (DISPID_READYSTATE == dispid || DISPID_UNKNOWN == dispid)
    {
        ASSERT(_pOleObjReadyState);
        if (!_pOleObjReadyState)
            return S_OK;  //Documentation says we need to return this all the time

        IDispatch *pdisp;
        if (SUCCEEDED(_pOleObjReadyState->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
        {
            CDefView* pView = IToClass(CDefView, _cFrame, this);
            EXCEPINFO exInfo;
            VARIANTARG va = {0};
            DISPPARAMS dp = {0};

            if (EVAL(SUCCEEDED(pdisp->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &dp, &va, &exInfo, NULL))
                && va.vt == VT_I4))
            {
                if (va.lVal >= READYSTATE_INTERACTIVE)
                {
                    if (!_fReadyStateInteractiveProcessed)
                    {
                        _fReadyStateInteractiveProcessed = TRUE;

                        // First time through this function we need to request
                        // activation.  After that, we can switch immediately.
                        //
                        // Switch the bit early since SHDVID_ACTIVATEMENOW calls
                        // SHDVID_CANACTIVATENOW which checks it.
                        //
                        BOOL fTmp = !pView->_fCanActivateNow;
                        pView->_fCanActivateNow = TRUE;
                        if (fTmp)
                        {
                            // If we did an async CreateViewWindow2, then we
                            // need to notify the browser that we're ready
                            // to be activated - it will uiactivate us which
                            // will cause us to switch.

                            //Don't Make the View Visible, if it is in
                            //DEACTIVATE State. The View would be made visible
                            //during uiactivate call. - KishoreP 

                            if (pView->_uState != SVUIA_DEACTIVATE)
                            {
                                SetWindowPos(pView->_hwndView, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
                            }
                            IUnknown_Exec(pView->_psb, &CGID_ShellDocView, SHDVID_ACTIVATEMENOW, NULL, NULL, NULL);
                        }
                        else
                        {
                            // Technically we only want to do this iff our view is currently
                            // the active visible view.  !fCanActivateNow => we are definitely not visible,
                            // but _fCanActivateNow does NOT imply visible, it implies we are ready to be
                            // made the active visible guy, and that we've requested to be made the active
                            // visible view, but not necessarily that we *are* the active visible view.  If
                            // the previous view wasn't ready to go away, then we are in limbo.  But if that's
                            // the case, then our menus aren't merged, so there's no way the user could
                            // switch views on us...  Verify this.
#ifdef DEBUG
                            CDefView* pView = IToClass(CDefView, _cFrame, this);
                            IShellView* psvCurrent;
                            if (EVAL(SUCCEEDED(pView->_psb->QueryActiveShellView(&psvCurrent))))
                            {
                                ASSERT(SHIsSameObject(SAFECAST(pView, IShellView2*), psvCurrent));
                                psvCurrent->Release();
                            }

                            ASSERT(pView->_uState != SVUIA_DEACTIVATE)
#endif
                        
                            // If we're simply switching views, go ahead
                            // and do it.
                            _SwitchToNewOleObj();
                        }

                        if (g_dwProfileCAP & 0x00010000)
                            StopCAP();
                    }
                }
            }

            if (va.lVal == READYSTATE_COMPLETE)
            {
                _UpdateZonesStatusPane(_pOleObjReadyState);
                
                _RemoveReadyStateNotifyCapability();

                _fReadyStateComplete = TRUE;
            }    
            pdisp->Release();
        }
    }

    return S_OK;
}

HRESULT CSFVFrame::OnRequestEdit(DISPID dispid)
{
    return E_NOTIMPL;
}

// randum stuff
HRESULT CSFVFrame::GetCommandTarget(IOleCommandTarget** ppct)
{
    if (_pDocView)
    {
        return _pDocView->QueryInterface(IID_PPV_ARG(IOleCommandTarget, ppct));
    }
    *ppct = NULL;
    return E_FAIL;
}

HRESULT CSFVFrame::SetRect(LPRECT prc)
{
    if (IsWebView() && _pDocView)
        return _pDocView->SetRect(prc);
    return E_FAIL;
}

HRESULT CSFVFrame::OnTranslateAccelerator(LPMSG pmsg, BOOL* pbTabOffLastTridentStop)
{
    HRESULT hr = E_FAIL;

    *pbTabOffLastTridentStop = FALSE;
    if (IsWebView())
    {
        if (_pActive)
        {
            hr = _pActive->TranslateAccelerator(pmsg);
        }
        else if (_pOleObj)
        {
            IOleInPlaceActiveObject* pIAO;
            if (SUCCEEDED(_pOleObj->QueryInterface(IID_PPV_ARG(IOleInPlaceActiveObject, &pIAO))))
            {
                hr = pIAO->TranslateAccelerator(pmsg);
                pIAO->Release();
            }
        }
        if (hr == S_OK)
        {
            CDefView* pView = IToClass(CDefView, _cFrame, this);

            if (pView->_fCycleFocus)
            {
                // we got called back by trident (IOCS::TA), but deferred it.
                // time to pay the piper.
                *pbTabOffLastTridentStop = TRUE;
                TraceMsg(TF_FOCUS, "sfvf::IOIPAO::OnTA piao->TA==S_OK ret _fCycleFocus=FALSE hr=S_FALSE (piper)");
                pView->_fCycleFocus = FALSE;
                // _UIActivateIO(FALSE, NULL);
                hr = S_FALSE;       // time to pay the piper
            }
        }

        ASSERT(! IToClass(CDefView, _cFrame, this)->_fCycleFocus);
    }

    return hr;
}

HRESULT CSFVFrame::_HasFocusIO()
{
    TraceMsg(TF_FOCUS, "sfvf._hfio: uState=%x hr=%x", _uState, (_uState == SVUIA_ACTIVATE_FOCUS) ? S_OK : S_FALSE);
    if (IsWebView()) 
    {
        return (_uState == SVUIA_ACTIVATE_FOCUS) ? S_OK : S_FALSE;
    }
    return S_FALSE;
}

HRESULT CSFVFrame::_UIActivateIO(BOOL fActivate, MSG *pMsg)
{
    HRESULT hr;
    if (IsWebView() && _pOleObj) 
    {
        CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
        CDefView* pView = IToClass(CDefView, _cFrame, pFrame);
        LONG iVerb;
        RECT rcView;

        if (fActivate) 
        {
            iVerb = OLEIVERB_UIACTIVATE;
            _uState = SVUIA_ACTIVATE_FOCUS;
        }
        else 
        {
            iVerb = OLEIVERB_INPLACEACTIVATE;
            _uState = SVUIA_ACTIVATE_NOFOCUS;
        }
        if (fActivate) 
        {
            GetClientRect(pView->_hwndView, &rcView);
            hr = _pOleObj->DoVerb(iVerb, pMsg,
                &_cSite, (UINT)-1, pView->_hwndView, &rcView);
        }
        else 
        {
            IOleInPlaceObject *pipo;
            hr = _pOleObj->QueryInterface(IID_PPV_ARG(IOleInPlaceObject, &pipo));
            if (SUCCEEDED(hr)) 
            {
                hr = pipo->UIDeactivate();
                pipo->Release();
            }
        }

        ASSERT(SUCCEEDED(hr));
        ASSERT(_uState == (UINT)(fActivate ? SVUIA_ACTIVATE_FOCUS : SVUIA_ACTIVATE_NOFOCUS));
        TraceMsg(TF_FOCUS, "sfvf._uiaio(fAct=%d) ExtView DoVerb S_OK", fActivate);
        hr = S_OK;
    }
    else
    {
        TraceMsg(TF_FOCUS, "sfvf._uiaio(fAct=%d) else S_FALSE", fActivate);
        hr = S_FALSE;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shcombox.cpp ===
#include "shellprv.h"
#include "shcombox.h"
#include "filetype.h"
#include "recdocs.h"
#include "ids.h"

//  Adds the specified item to a comboboxex window
HRESULT AddCbxItemToComboBox(HWND hwndComboEx, PCCBXITEM pItem, INT_PTR *pnPosAdded)
{
    ASSERT(hwndComboEx);

    //  Convert to COMBOBOXEXITEM.
    COMBOBOXEXITEM cei;
    cei.mask            = pItem->mask;
    cei.iItem           = pItem->iItem;
    cei.pszText         = (LPTSTR)pItem->szText;
    cei.cchTextMax      = ARRAYSIZE(pItem->szText);
    cei.iImage          = pItem->iImage;
    cei.iSelectedImage  = pItem->iSelectedImage;
    cei.iOverlay        = pItem->iOverlay;
    cei.iIndent         = pItem->iIndent;
    cei.lParam          = pItem->lParam;

    int nPos = (int)::SendMessage(hwndComboEx, CBEM_INSERTITEM, 0, (LPARAM)&cei);

    *pnPosAdded = nPos;

    return nPos < 0 ? E_FAIL : S_OK;
}

//  Adds the specified item to a comboboxex window, and invokes
//  a notification callback function if successful.
HRESULT AddCbxItemToComboBoxCallback(IN HWND hwndComboEx, IN PCBXITEM pItem, IN ADDCBXITEMCALLBACK pfn, IN LPARAM lParam)
{
    INT_PTR iPos = -1;

    if (pfn && E_ABORT == pfn(CBXCB_ADDING, pItem, lParam))
        return E_ABORT;

    HRESULT hr = AddCbxItemToComboBox(hwndComboEx, pItem, &iPos);
    
    if (pfn && S_OK == hr)
    {
        ((CBXITEM*)pItem)->iItem = iPos;
        pfn(CBXCB_ADDED, pItem, lParam);
    }
    return hr;
}

//  image list indices known
void MakeCbxItemKnownImage(CBXITEM* pcbi, LPCTSTR pszDisplayName, void *pvData, 
                            int iImage, int iSelectedImage, INT_PTR nPos, int iIndent)
{
    ZeroMemory(pcbi, sizeof(*pcbi));

    StringCchCopy(pcbi->szText, ARRAYSIZE(pcbi->szText), pszDisplayName);
    pcbi->lParam = (LPARAM)pvData;
    pcbi->iIndent = iIndent;
    pcbi->iItem = nPos;
    pcbi->mask = (CBEIF_TEXT | CBEIF_INDENT | CBEIF_LPARAM);
    if (-1 != iImage)
    {
        pcbi->mask |= CBEIF_IMAGE;
        pcbi->iImage = iImage;
    }
    if (-1 != iSelectedImage)
    {
        pcbi->mask |= CBEIF_SELECTEDIMAGE;
        pcbi->iSelectedImage = iSelectedImage;
    }
}

//  Retrieves the system image list indices for the specified ITEMIDLIST
HRESULT _GetPidlIcon(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage)
{
    IShellFolder *psfParent;
    LPCITEMIDLIST pidlChild;

    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
    if (SUCCEEDED(hr))
    {
        *piImage = SHMapPIDLToSystemImageListIndex(psfParent, pidlChild, NULL);

        *piSelectedImage = *piImage;

        psfParent->Release();
    }
    return hr;
}

//  image icon image list indices unknown
STDAPI_(void) MakeCbxItem(CBXITEM* pcbi, LPCTSTR pszDisplayName, void *pvData, LPCITEMIDLIST pidlIcon, INT_PTR nPos, int iIndent)
{
    int iImage = -1;
    int iSelectedImage = -1;

    if (pidlIcon)
        _GetPidlIcon(pidlIcon, &iImage, &iSelectedImage);

    MakeCbxItemKnownImage(pcbi, pszDisplayName, pvData, iImage, iSelectedImage, nPos, iIndent);
}

HRESULT _MakeFileTypeCbxItem(
    OUT CBXITEM* pcbi, 
    IN  LPCTSTR pszDisplayName, 
    IN  LPCTSTR pszExt, 
    IN  LPCITEMIDLIST pidlIcon, 
    IN  INT_PTR nPos, 
    IN  int iIndent)
{
    HRESULT hr = E_OUTOFMEMORY;
    void *pvData = NULL;
    LPITEMIDLIST pidlToFree = NULL;

    if (!pidlIcon)
    {
        TCHAR szFileName[MAX_PATH] = TEXT("C:\\notexist");       // This is bogus and that's ok

        StringCchCat(szFileName, ARRAYSIZE(szFileName), pszExt);
        pidlIcon = pidlToFree = SHSimpleIDListFromPath(szFileName);
    }

    if (pidlIcon && Str_SetPtr((LPTSTR *)&pvData, pszExt))
    {
        MakeCbxItem(pcbi, pszDisplayName, pvData, pidlIcon, nPos, iIndent);
        hr = S_OK;
    }

    ILFree(pidlToFree); // may be NULL

    return hr;
}

//  Enumerates children of the indicated special shell item id.
HRESULT EnumSpecialItemIDs(int csidl, DWORD dwSHCONTF, LPFNPIDLENUM_CB pfn, void *pvData)
{
    LPITEMIDLIST pidlFolder;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidlFolder)))
    {
        IShellFolder *psf;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf))))
        {
            IEnumIDList * penum;
            if (S_OK == psf->EnumObjects(NULL, dwSHCONTF, &penum))
            {
                LPITEMIDLIST pidl;
                BOOL bContinue = TRUE;

                while (bContinue && (S_OK == penum->Next(1, &pidl, NULL)))
                {
                    LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidl);
                    if (pidlFull)
                    {
                        if (FAILED(pfn(pidlFull, pvData)))
                            bContinue = FALSE;

                        ILFree(pidlFull);
                    }
                    ILFree(pidl);
                }
                penum->Release();
            }
            psf->Release();
        }
        ILFree(pidlFolder);
    }

    return S_OK;
}

STDAPI_(HIMAGELIST) GetSystemImageListSmallIcons()
{
    HIMAGELIST himlSmall;
    Shell_GetImageLists(NULL, &himlSmall);
    return himlSmall;
}

HRESULT _MakeLocalDrivesCbxItem(CBXITEM* pItem, LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = S_FALSE;
    ULONG ulAttrs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED;

    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), &ulAttrs)) &&
        ((SFGAO_FOLDER | SFGAO_FILESYSTEM) == (ulAttrs & (SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED))) &&
        (GetDriveType(szPath) == DRIVE_FIXED))
    {
        TCHAR szDisplayName[MAX_PATH];       
        SHGetNameAndFlags(pidl, SHGDN_NORMAL, szDisplayName, SIZECHARS(szDisplayName), NULL);

        LPTSTR pszPath = NULL;
        Str_SetPtr(&pszPath, szPath);

        MakeCbxItem(pItem, szDisplayName, (void *)pszPath, pidl, LISTINSERT_LAST, NO_ITEM_INDENT);
        hr = S_OK;
    }
    return hr;
}

typedef struct
{
    HWND                hwndComboBox;
    ADDCBXITEMCALLBACK  pfn; 
    LPARAM              lParam;
} ENUMITEMPARAM;

HRESULT _PopulateLocalDrivesCB(LPCITEMIDLIST pidl, void *pv) 
{ 
    CBXITEM item;
    HRESULT hr = _MakeLocalDrivesCbxItem(&item, pidl);
    if (hr == S_OK)
    {
        ENUMITEMPARAM *peip = (ENUMITEMPARAM *) pv;
        item.iID = CSIDL_DRIVES;
        hr = AddCbxItemToComboBoxCallback(peip->hwndComboBox, &item, peip->pfn, peip->lParam);
    }
    return hr;    
}

STDAPI PopulateLocalDrivesCombo(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    ENUMITEMPARAM eip;

    eip.hwndComboBox = hwndComboBoxEx;
    eip.pfn          = pfn;
    eip.lParam       = lParam;

    ::SendMessage(hwndComboBoxEx, CB_RESETCONTENT, 0, 0);

    return EnumSpecialItemIDs(CSIDL_DRIVES, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, _PopulateLocalDrivesCB, &eip);
}

//  File Associations selector combo methods

HRESULT _AddFileType(IN HWND hwndComboBox, IN LPCTSTR pszDisplayName, IN LPCTSTR pszExt, IN LPCITEMIDLIST pidlIcon, IN int iIndent,
                      IN OPTIONAL ADDCBXITEMCALLBACK pfn, IN OPTIONAL LPARAM lParam);


HRESULT _AddFileTypes(HWND hwndComboBox, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    HRESULT hr = S_OK;
    DWORD dwSubKey = 0;
    TCHAR szExtension[MAX_PATH];   // string containing the classes key
    DWORD dwExtension;
    BOOL bFoundFirstExt = FALSE;

    // Enumerate extensions from registry to get file types
    dwExtension = ARRAYSIZE(szExtension);
    while (hr != E_ABORT && SHEnumKeyEx(HKEY_CLASSES_ROOT, dwSubKey, szExtension, &dwExtension) != ERROR_NO_MORE_ITEMS)
    {
        if (*szExtension == TEXT('.'))  // find the file type identifier and description from the extension
        {
            IQueryAssociations *pqa;
            if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa))))
            {
                if (SUCCEEDED(pqa->Init(0, szExtension, NULL, NULL)))
                {
                    TCHAR szDesc[MAX_PATH];
                    DWORD dwAttributes = 0;
                    DWORD dwSize = sizeof(dwAttributes);
                    BOOL fAdd;

                    if (SUCCEEDED(pqa->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwAttributes, &dwSize)))
                    {
                        fAdd = !(dwAttributes & FTA_Exclude);
                    }
                    else
                    {
                        dwSize = ARRAYSIZE(szDesc);
                        fAdd = SUCCEEDED(pqa->GetString(NULL, ASSOCSTR_DEFAULTICON, NULL, NULL, &dwSize));
                    }

                    if (fAdd)
                    {
                        dwSize = ARRAYSIZE(szDesc);
                        pqa->GetString(NULL, ASSOCSTR_FRIENDLYDOCNAME, NULL, szDesc, &dwSize);
                        hr = _AddFileType(hwndComboBox, szDesc, szExtension, NULL, NO_ITEM_INDENT, pfn, lParam);
                    }
                }
                pqa->Release();
             }

            bFoundFirstExt = TRUE;
        }
        else if (bFoundFirstExt)      // stop after first non-ext key (if sorted registry)
            break;

        dwSubKey++;
        dwExtension = ARRAYSIZE(szExtension);
    }

    if (hr != E_ABORT && LoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, szExtension, ARRAYSIZE(szExtension)))
    {
        LPITEMIDLIST pidlIcon = SHCloneSpecialIDList(NULL, CSIDL_RECENT, FALSE);
        if (pidlIcon)
        {
            hr = _AddFileType(hwndComboBox, szExtension, TEXT("."), pidlIcon, NO_ITEM_INDENT, pfn, lParam);
            ILFree(pidlIcon);
        }
    }

    return hr;
}

HRESULT _AddFileType(HWND hwndComboBox, LPCTSTR pszDisplayName, LPCTSTR pszExt, LPCITEMIDLIST pidlIcon, int iIndent, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    HRESULT hr = S_OK;
    BOOL    bExists = FALSE;

    LRESULT lRet = ::SendMessage(hwndComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM) pszDisplayName);
    LRESULT nIndex = lRet;
    
    // Is the string already in the list?
    if (CB_ERR != nIndex)
    {
        // Yes, so we want to combine our extension with the current extension or extension list
        // and erase the old one.  Then we can continue to add it below.
        LPTSTR pszOldExt = NULL;

        lRet = SendMessage(hwndComboBox, CB_GETITEMDATA, nIndex, 0);
        if (!(0 == lRet || CB_ERR == lRet))
        {
            pszOldExt = (LPTSTR)lRet;
            UINT cchLen = lstrlen(pszOldExt) + 1 + lstrlen(pszExt) + 1;

            LPTSTR pszNewExt = (LPTSTR)LocalReAlloc(pszOldExt, sizeof(TCHAR) * cchLen, LMEM_ZEROINIT | LMEM_MOVEABLE);
            if (pszNewExt)
            {
                StringCchCat(pszNewExt, cchLen, TEXT(";"));
                StringCchCat(pszNewExt, cchLen, pszExt);
                lRet = ::SendMessage(hwndComboBox, CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pszNewExt);
            }
            bExists = TRUE;
        }
    }

    if (!bExists)
    {
        // No, so we can add it.
        TCHAR szString[MAX_URL_STRING];
        INT_PTR nPos = 0;
        INT_PTR nLast = CB_ERR;
        
        lRet = ::SendMessage(hwndComboBox, CB_GETCOUNT, 0, 0);

        if (lRet == CB_ERR)
            return E_FAIL;

        nLast = lRet - 1;
        *szString = 0;

        // Combo box is never populated with strings longer than MAX_PATH
        lRet = ::SendMessage(hwndComboBox, CB_GETLBTEXT, (WPARAM)nLast, (LPARAM)szString);

        if (lRet == CB_ERR)
            return E_FAIL;

        // Base case, does his the new string need to be inserted into the end?
        if ((-1 == nLast) || (0 > StrCmp(szString, pszDisplayName)))
        {
            // Yes, so add it to the end.
            CBXITEM item;
            hr = _MakeFileTypeCbxItem(&item, pszDisplayName, pszExt, pidlIcon, (nLast + 1), iIndent);
            if (SUCCEEDED(hr))
                hr = AddCbxItemToComboBoxCallback(hwndComboBox, &item, pfn, lParam);
        }
        else
        {
#ifdef DEBUG
            INT_PTR nCycleDetector = nLast + 5;
#endif // DEBUG
            BOOL bDisplayName = TRUE;
            do
            {
                //  Determine ordered insertion point:
                INT_PTR nTest = nPos + ((nLast - nPos) / 2);
                // Combo box is never populated with strings longer than MAX_PATH
                bDisplayName = CB_ERR != ::SendMessage(hwndComboBox, CB_GETLBTEXT, (WPARAM)nTest, (LPARAM)szString);

                if (bDisplayName)
                {
                    // Does the string need to before nTest?
                    if (0 > StrCmp(pszDisplayName, szString))
                        nLast = nTest;  // Yes
                    else
                    {
                        if (nPos == nTest)
                            nPos++;
                        else
                            nPos = nTest;  // No
                    }

#ifdef DEBUG
                    ASSERT(nCycleDetector);   // Make sure we converge.
                    nCycleDetector--;
#endif // DEBUG
                }

            } while (bDisplayName && nLast - nPos);
            
            if (bDisplayName)
            {
                CBXITEM item;
                hr = _MakeFileTypeCbxItem(&item, pszDisplayName, pszExt, pidlIcon, nPos, iIndent);
                if (SUCCEEDED(hr))
                    hr = AddCbxItemToComboBoxCallback(hwndComboBox, &item, pfn, lParam);
            }
        }
    }

    return hr;
}

STDAPI PopulateFileAssocCombo(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    ASSERT(hwndComboBoxEx);

    ::SendMessage(hwndComboBoxEx, CB_RESETCONTENT, 0, 0);

    HRESULT hr = _AddFileTypes(hwndComboBoxEx, pfn, lParam);
    if (E_ABORT == hr)
        return hr;
    
    // Now add this to the top of the list.
    CBXITEM item;
    TCHAR szDisplayName[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_SNS_ALL_FILE_TYPES, szDisplayName, ARRAYSIZE(szDisplayName));
    MakeCbxItem(&item, szDisplayName, (void *)FILEASSOCIATIONSID_ALLFILETYPES, NULL, LISTINSERT_FIRST, NO_ITEM_NOICON_INDENT);

    return AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
}

void *_getFileAssocComboData(HWND hwndComboBox)
{
    LRESULT nSelected = ::SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);

    if (-1 == nSelected)
        return NULL;

    LRESULT itemData = ::SendMessage(hwndComboBox, CB_GETITEMDATA, nSelected, 0);

    if (itemData == CB_ERR)
        itemData = NULL;

    return (LPVOID)itemData;
}

DWORD _getFileAssocComboID(HWND hwndComboBox)
{
    DWORD dwID = 0;
    void *pvData = _getFileAssocComboData(hwndComboBox);

    // Is this an ID?
    if (pvData && ((DWORD_PTR)pvData <= FILEASSOCIATIONSID_MAX))
    {
        // Yes, so let's get it.
        dwID = PtrToUlong(pvData);
    }

    return dwID;
}

LONG GetFileAssocComboSelItemText(IN HWND hwndComboBox, OUT LPTSTR *ppszText)
{
    ASSERT(hwndComboBox);
    ASSERT(ppszText);
    *ppszText = NULL;

    int nSel = (LONG)::SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);
    if (nSel >= 0)
    {
        DWORD dwID = _getFileAssocComboID(hwndComboBox);

        if (dwID > FILEASSOCIATIONSID_FILE_PATH)
        {
            *ppszText = StrDup(TEXT(".*"));
        }
        else
        {
            LPTSTR pszText = (LPTSTR)_getFileAssocComboData(hwndComboBox);
            if (pszText)
            {            
                *ppszText = StrDup((LPCTSTR)pszText);
            }
        }
    }

    if (!*ppszText)
    {
        nSel = -1;
    }
    return nSel;
}


LRESULT DeleteFileAssocComboItem(IN LPNMHDR pnmh)
{
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnmh;
    if (pnmce->ceItem.lParam)
    {
        // Is this a pidl?
        if ((pnmce->ceItem.lParam) > FILEASSOCIATIONSID_MAX)
        {
            // Yes, so let's free it.
            Str_SetPtr((LPTSTR *)&pnmce->ceItem.lParam, NULL);
        }
    }
    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shapi.cpp ===
#include "shellprv.h"
#include "util.h"

#include "ids.h"
#include "ole2dup.h"
#include "datautil.h"
#include "filetbl.h"
#include "copy.h"
#include "prop.h"
#include <pif.h>
#include "fstreex.h"    // GetIconOverlayManager()
#include <runtask.h>

extern void PathStripTrailingDots(LPTSTR szPath);

HRESULT IExtractIcon_Extract(IExtractIcon *pei, LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    // wrapper to let us ask an IExtractIcon for only one icon (the large one)
    // since many implementations will fault if you pass NULL phiconSmall

    HICON hiconDummy;
    if (phiconSmall == NULL)
    {
        phiconSmall = &hiconDummy;
        nIconSize = MAKELONG(nIconSize, nIconSize);
    }

    HRESULT hr = pei->Extract(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    if (hr == S_OK && phiconSmall == &hiconDummy)
    {
        DestroyIcon(hiconDummy);
    }
    return hr;
}

HRESULT IExtractIconA_Extract(IExtractIconA *peia, LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    // wrapper to let us ask an IExtractIcon for only one icon (the large one)
    // since many dudes don't check for NULL phiconSmall

    HICON hiconDummy;
    if (phiconSmall == NULL)
    {
        phiconSmall = &hiconDummy;
        nIconSize = MAKELONG(nIconSize, nIconSize);
    }

    HRESULT hr = peia->Extract(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    if (hr == S_OK && phiconSmall == &hiconDummy)
    {
        DestroyIcon(hiconDummy);
    }
    return hr;
}

//  try to figure out if this is an icon already
//  in our system image list, so that we dont re-add
BOOL _HijackOfficeIcons(HICON hLarge, int iIndex)
{
    BOOL fRet = FALSE;
    HIMAGELIST himl;
    ASSERT(hLarge);
    if (Shell_GetImageLists(NULL, &himl))
    {
        HICON hMaybe = ImageList_GetIcon(himl, iIndex, 0);
        if (hMaybe)
        {
            fRet = SHAreIconsEqual(hLarge, hMaybe);
            DestroyIcon(hMaybe);
        }
    }

#ifdef DEBUG
    if (!fRet)
        TraceMsg(TF_WARNING, "_HijackOfficeIcons() called in suspicious circumstance");
#endif        

    return fRet;
}

HRESULT _GetILIndexGivenPXIcon(IExtractIcon *pxicon, UINT uFlags, LPCITEMIDLIST pidl, int *piImage, BOOL fAnsiCrossOver)
{
    TCHAR szIconFile[MAX_PATH];
    CHAR szIconFileA[MAX_PATH];
    IExtractIconA *pxiconA = (IExtractIconA *)pxicon;
    int iIndex;
    int iImage = -1;
    UINT wFlags=0;
    HRESULT hr;

    if (fAnsiCrossOver)
    {
        szIconFileA[0] = 0;
        hr = pxiconA->GetIconLocation(uFlags | GIL_FORSHELL,
                    szIconFileA, ARRAYSIZE(szIconFileA), &iIndex, &wFlags);
        SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
    }
    else
    {
        szIconFile[0] = '\0';
        hr = pxicon->GetIconLocation(uFlags | GIL_FORSHELL,
                    szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags);
    }

    //
    //  "*" as the file name means iIndex is already a system
    //  icon index, we are done.
    //
    //  this is a hack for our own internal icon handler
    //
    if (SUCCEEDED(hr) && (wFlags & GIL_NOTFILENAME) &&
        szIconFile[0] == TEXT('*') && szIconFile[1] == 0)
    {
        *piImage = iIndex;
        return hr;
    }

    // Do not replace this with SUCCEEDED(hr). hr = S_FALSE means we need to use a default icon.
    if (hr == S_OK)
    {
        // If we have it in shell32, don't delay the extraction
        if (!(wFlags & GIL_NOTFILENAME) && lstrcmpi(PathFindFileName(szIconFile), c_szShell32Dll) == 0)
        {
            iImage = Shell_GetCachedImageIndex(szIconFile, iIndex, wFlags);
        }
        else
        {
            //
            // if GIL_DONTCACHE was returned by the icon handler, dont
            // lookup the previous icon, assume a cache miss.
            //
            if (!(wFlags & GIL_DONTCACHE) && *szIconFile)
            {
                iImage = LookupIconIndex(szIconFile, iIndex, wFlags);
            }
        }
    }

    // if we miss our cache...
    if (iImage == -1 && hr != S_FALSE)
    {
        if (uFlags & GIL_ASYNC)
        {
            // If we couldn't get the final icon, try to get a good temporary one
            if (fAnsiCrossOver)
            {
                szIconFileA[0] = 0;
                hr = pxiconA->GetIconLocation(uFlags | GIL_FORSHELL | GIL_DEFAULTICON,
                            szIconFileA, ARRAYSIZE(szIconFileA), &iIndex, &wFlags);
                SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
            }
            else
            {
                hr = pxicon->GetIconLocation(uFlags | GIL_FORSHELL | GIL_DEFAULTICON,
                            szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags);
            }
            if (hr == S_OK)
            {
                iImage = LookupIconIndex(szIconFile, iIndex, wFlags);
            }

            // When all else fails...
            if (iImage == -1)
            {
                iImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);
            }

            // force a lookup incase we are not in explorer.exe
            *piImage = iImage;
            return E_PENDING;
        }

        // try getting it from the ExtractIcon member fuction
        HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};
        BOOL fHandlerOk = FALSE;

        for (int i = 0; i < ARRAYSIZE(g_rgshil); i += 2)
        {
            // Ask for two at a time because
            //
            // (a) it's slightly more efficient, and
            //
            // (b) otherwise we break compatibility with IExtractIcon::Extract
            //     implementions which ignore the size parameter (the Network
            //     Connections folder is one).  The SHIL_'s are conveniently
            //     arranged in large/small alternating order for this purpose.
            //
            HICON *phiconSmall = NULL;

            HICON *phiconLarge = &rghicon[i];
            UINT nIconSize = g_rgshil[i].size.cx;

            if (i + 1 < ARRAYSIZE(g_rgshil))
            {
                phiconSmall = &rghicon[i+1];
                nIconSize = MAKELONG(nIconSize, g_rgshil[i+1].size.cx);
            }

            if (fAnsiCrossOver)
            {
                hr = IExtractIconA_Extract(pxiconA, szIconFileA, iIndex,
                    phiconLarge, phiconSmall, nIconSize);
            }
            else
            {
                hr = IExtractIcon_Extract(pxicon, szIconFile, iIndex,
                    phiconLarge, phiconSmall, nIconSize);
            }
            // S_FALSE means, can you please do it...Thanks

            if (hr == S_FALSE && !(wFlags & GIL_NOTFILENAME))
            {
                hr = SHDefExtractIcon(szIconFile, iIndex, wFlags,
                    phiconLarge, phiconSmall, nIconSize);
            }
            if (SUCCEEDED(hr))
            {
                fHandlerOk = TRUE;
            }
        }

        //  our belief knows no bounds
        if (!*szIconFile && rghicon[1] && iIndex > 0 && _HijackOfficeIcons(rghicon[1], iIndex))
        {
            //  it lives!
            iImage = iIndex;
        }
        else
        {
            //  if we extracted a icon add it to the cache.
            iImage = SHAddIconsToCache(rghicon, szIconFile, iIndex, wFlags);
        }

        _DestroyIcons(rghicon, ARRAYSIZE(rghicon));

        // if we failed in any way pick a default icon

        if (iImage == -1)
        {
            if (wFlags & GIL_SIMULATEDOC)
            {
                iImage = II_DOCUMENT;
            }
            else if ((wFlags & GIL_PERINSTANCE) && PathIsExe(szIconFile))
            {
                iImage = II_APPLICATION;
            }
            else
            {
                iImage = II_DOCNOASSOC;
            }

            // force a lookup incase we are not in explorer.exe
            iImage = Shell_GetCachedImageIndex(c_szShell32Dll, iImage, 0);

            // if the handler failed dont cache this default icon.
            // so we will try again later and maybe get the right icon.
            // handlers should only fail if they cant access the file
            // or something equally bad.
            //
            // if the handler succeeded then go ahead and assume this is
            // a usable icon, we must be in some low memory situation, or
            // something.  So keep mapping to the same shell icon.
            //
            if (fHandlerOk)
            {
                if (iImage != -1 && *szIconFile && !(wFlags & (GIL_DONTCACHE | GIL_NOTFILENAME)))
                {
                    AddToIconTable(szIconFile, iIndex, wFlags, iImage);
                }
            }
            else
            {
                TraceMsg(TF_DEFVIEW, "not caching icon for '%s' because cant access file", szIconFile);
            }
        }
    }

    if (iImage < 0)
    {
        iImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);
    }

    *piImage = iImage;
    return hr;
}

// given an IShellFolder and and an Idlist that is
// contained in it, get back the index into the system image list.

STDAPI SHGetIconFromPIDL(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, int *piImage)
{
    HRESULT hr;

    if (psi)
    {
#ifdef DEBUG
        *piImage = -1;
#endif
        hr = psi->GetIconOf(pidl, flags, piImage);

        if (hr == S_OK)
        {
            ASSERT(*piImage != -1);
            return hr;
        }

        if (hr == E_PENDING)
        {
            ASSERT(flags & GIL_ASYNC);
            ASSERT(*piImage != -1);
            return hr;
        }
    }

    *piImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);

    // Be careful.  Some shellfolders erroneously return S_OK when they fail
    IExtractIcon *pxi = NULL;
    hr = psf->GetUIObjectOf(NULL, pidl ? 1 : 0, pidl ? &pidl : NULL, IID_PPV_ARG_NULL(IExtractIcon, &pxi));
    if (SUCCEEDED(hr) && pxi)
    {
        hr = _GetILIndexGivenPXIcon(pxi, flags, pidl, piImage, FALSE);
        pxi->Release();
    }
    else
    {
        // Try the ANSI interface, see if we are dealing with an old set of code
        IExtractIconA *pxiA = NULL;
        hr = psf->GetUIObjectOf(NULL, pidl ? 1 : 0, pidl ? &pidl : NULL, IID_PPV_ARG_NULL(IExtractIconA, &pxiA));
        if (SUCCEEDED(hr))
        {
            if (pxiA)
            {
                hr = _GetILIndexGivenPXIcon((IExtractIcon *)pxiA, flags, pidl, piImage, TRUE);
                pxiA->Release();
            }
            else
            {
                // IShellFolder lied to us - returned S_OK even though it failed
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


// given an IShellFolder and and an Idlist that is
// contained in it, get back the index into the system image list.

STDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *psf, LPCITEMIDLIST pidl, int *piIndexSel)
{
    int iIndex;

    if (piIndexSel)
    {
        SHGetIconFromPIDL(psf, NULL, pidl, GIL_OPENICON, piIndexSel);
    }

    SHGetIconFromPIDL(psf, NULL, pidl,  0, &iIndex);
    return iIndex;
}


class CGetIconTask : public CRunnableTask
{
public:
    STDMETHODIMP RunInitRT(void);

    CGetIconTask(HRESULT *phr, IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, BOOL fGetOpenIcon,
                 PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint);
protected:
    ~CGetIconTask();

    IShellFolder *_psf;
    IShellIcon *_psi;
    LPITEMIDLIST _pidl;
    UINT _flags;
    BOOL _fGetOpenIcon;
    PFNASYNCICONTASKBALLBACK _pfn;
    void *_pvData;
    void *_pvHint;
};

CGetIconTask::CGetIconTask(HRESULT *phr, IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, BOOL fGetOpenIcon,
                           PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint) : 
    CRunnableTask(RTF_DEFAULT), _psf(psf), _psi(psi), _flags(flags), _fGetOpenIcon(fGetOpenIcon), _pfn(pfn), _pvData(pvData), _pvHint(pvHint)
{
    *phr = SHILClone(pidl, &_pidl);

    _psf->AddRef();

    if (_psi)
        _psi->AddRef();
}

CGetIconTask::~CGetIconTask()
{
    ILFree(_pidl);
    _psf->Release();

    if (_psi)
        _psi->Release();
}

STDMETHODIMP CGetIconTask::RunInitRT()
{
    int iIcon = -1;
    int iOpenIcon = -1;

    ASSERT(_pidl);

    if (_fGetOpenIcon)
    {
        SHGetIconFromPIDL(_psf, _psi, _pidl, _flags | GIL_OPENICON, &iOpenIcon);
    }

    // get the icon for this item.
    SHGetIconFromPIDL(_psf, _psi, _pidl, _flags, &iIcon);

    _pfn(_pidl, _pvData, _pvHint, iIcon, iOpenIcon);

    return S_OK;
}

HRESULT CGetIconTask_CreateInstance(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, BOOL fGetOpenIcon,
                                    PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint, IRunnableTask **ppTask)
{
    *ppTask = NULL;
    
    HRESULT hr;
    CGetIconTask * pNewTask = new CGetIconTask(&hr, psf, psi, pidl, flags, fGetOpenIcon, pfn, pvData, pvHint);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pNewTask, IRunnableTask *);
        else
            pNewTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


// given an IShellFolder and and an Idlist that is
// contained in it, get back a -possibly temporary - index into the system image list,
// and get the final icon from the callback if necessary

STDAPI SHMapIDListToImageListIndexAsync(IShellTaskScheduler* pts, IShellFolder *psf, LPCITEMIDLIST pidl, UINT flags,
                                        PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint, int *piIndex, int *piIndexSel)
{
    HRESULT hr = S_OK;

    IShellIcon *psi = NULL;
    psf->QueryInterface(IID_PPV_ARG(IShellIcon, &psi));

    // We are doing all the ASYNC handling, not the caller.
    flags &= ~GIL_ASYNC;

    // Try asynchronous first
    if (pfn)
    {
        hr = SHGetIconFromPIDL(psf, psi, pidl,  flags | GIL_ASYNC, piIndex);

        if (piIndexSel)
        {
            HRESULT hr2 = SHGetIconFromPIDL(psf, psi, pidl, flags | GIL_OPENICON | GIL_ASYNC, piIndexSel);

            if (SUCCEEDED(hr))
            {
                // Don't lose the result if the first GetIcon succeeds, but the second one is E_PENDING
                hr = hr2;
            }
        }

        if (hr == E_PENDING)
        {
            if (pts)
            {
                IRunnableTask *pTask;
                hr = CGetIconTask_CreateInstance(psf, psi, pidl, flags, (piIndexSel != NULL), pfn, pvData, pvHint, &pTask);
                if (SUCCEEDED(hr))
                {
                    hr = pts->AddTask(pTask, TOID_DVIconExtract, 0, ITSAT_DEFAULT_PRIORITY);
                    if (SUCCEEDED(hr))
                    {
                        hr = E_PENDING;
                    }
                    pTask->Release();
                }
            }
            else
            {
                hr = E_POINTER;
            }
        }
        else if (hr == S_OK)
        {
            goto cleanup;
        }
    }

    // If asynchronous get failed, try synchronous
    if (hr != E_PENDING)
    {
        if (piIndexSel)
        {
            SHGetIconFromPIDL(psf, psi, pidl, flags | GIL_OPENICON, piIndexSel);
        }

        hr = SHGetIconFromPIDL(psf, psi, pidl, flags, piIndex);
    }

cleanup:
    if (psi)
    {
        psi->Release();
    }
    
    return hr;
}


// returns the icon handle to be used to represent the specified
// file. The caller should destroy the icon eventually.

STDAPI_(HICON) SHGetFileIcon(HINSTANCE hinst, LPCTSTR pszPath, DWORD dwFileAttributes, UINT uFlags)
{
    SHFILEINFO sfi;
    SHGetFileInfo(pszPath, dwFileAttributes, &sfi, sizeof(sfi), uFlags | SHGFI_ICON);
    return sfi.hIcon;
}

// Return 1 on success and 0 on failure.
DWORD_PTR _GetFileInfoSections(LPITEMIDLIST pidl, SHFILEINFO *psfi, UINT uFlags)
{
    DWORD_PTR dwResult = 1;
    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        // get attributes for file
        if (uFlags & SHGFI_ATTRIBUTES)
        {
            // [New in IE 4.0] If SHGFI_ATTR_SPECIFIED is set, we use psfi->dwAttributes as is

            if (!(uFlags & SHGFI_ATTR_SPECIFIED))
                psfi->dwAttributes = 0xFFFFFFFF;      // get all of them

            if (FAILED(psf->GetAttributesOf(1, &pidlLast, &psfi->dwAttributes)))
                psfi->dwAttributes = 0;
        }

        //
        // get icon location, place the icon path into szDisplayName
        //
        if (uFlags & SHGFI_ICONLOCATION)
        {
            IExtractIcon *pxi;

            if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_PPV_ARG_NULL(IExtractIcon, &pxi))))
            {
                UINT wFlags;
                pxi->GetIconLocation(0, psfi->szDisplayName, ARRAYSIZE(psfi->szDisplayName),
                    &psfi->iIcon, &wFlags);

                pxi->Release();

                // the returned location is not a filename we cant return it.
                // just give then nothing.
                if (wFlags & GIL_NOTFILENAME)
                {
                    // special case one of our shell32.dll icons......

                    if (psfi->szDisplayName[0] != TEXT('*'))
                        psfi->iIcon = 0;

                    psfi->szDisplayName[0] = 0;
                }
            }
        }

        HIMAGELIST himlLarge, himlSmall;

        // get the icon for the file.
        if ((uFlags & SHGFI_SYSICONINDEX) || (uFlags & SHGFI_ICON))
        {
            Shell_GetImageLists(&himlLarge, &himlSmall);

            if (uFlags & SHGFI_SYSICONINDEX)
                dwResult = (DWORD_PTR)((uFlags & SHGFI_SMALLICON) ? himlSmall : himlLarge);

            if (uFlags & SHGFI_OPENICON)
                SHMapPIDLToSystemImageListIndex(psf, pidlLast, &psfi->iIcon);
            else
                psfi->iIcon = SHMapPIDLToSystemImageListIndex(psf, pidlLast, NULL);
        }

        if (uFlags & SHGFI_ICON)
        {
            HIMAGELIST himl;
            UINT flags = 0;
            int cx, cy;

            if (uFlags & SHGFI_SMALLICON)
            {
                himl = himlSmall;
                cx = GetSystemMetrics(SM_CXSMICON);
                cy = GetSystemMetrics(SM_CYSMICON);
            }
            else
            {
                himl = himlLarge;
                cx = GetSystemMetrics(SM_CXICON);
                cy = GetSystemMetrics(SM_CYICON);
            }

            if (!(uFlags & SHGFI_ATTRIBUTES))
            {
                psfi->dwAttributes = SFGAO_LINK;    // get link only
                psf->GetAttributesOf(1, &pidlLast, &psfi->dwAttributes);
            }

            //
            //  check for a overlay image thing (link overlay)
            //
            if ((psfi->dwAttributes & SFGAO_LINK) || (uFlags & SHGFI_LINKOVERLAY))
            {
                IShellIconOverlayManager *psiom;
                HRESULT hrT = GetIconOverlayManager(&psiom);
                if (SUCCEEDED(hrT))
                {
                    int iOverlayIndex = 0;
                    hrT = psiom->GetReservedOverlayInfo(NULL, -1, &iOverlayIndex, SIOM_OVERLAYINDEX, SIOM_RESERVED_LINK);
                    if (SUCCEEDED(hrT))
                        flags |= INDEXTOOVERLAYMASK(iOverlayIndex);
                }
            }
            if ((uFlags & SHGFI_ADDOVERLAYS) || (uFlags & SHGFI_OVERLAYINDEX))
            {
                IShellIconOverlay * pio;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &pio))))
                {
                    int iOverlayIndex = 0;
                    if (SUCCEEDED(pio->GetOverlayIndex(pidlLast, &iOverlayIndex)))
                    {
                        if (uFlags & SHGFI_ADDOVERLAYS)
                        {
                            flags |= INDEXTOOVERLAYMASK(iOverlayIndex);
                        }
                        if (uFlags & SHGFI_OVERLAYINDEX)
                        {
                            // use the upper 16 bits for the overlayindex
                            psfi->iIcon |= iOverlayIndex << 24;
                        }
                    }
                    pio->Release();
                }
            }
            
            
            //  check for selected state
            if (uFlags & SHGFI_SELECTED)
                flags |= ILD_BLEND50;

            psfi->hIcon = ImageList_GetIcon(himl, psfi->iIcon, flags);

            // if the caller does not want a "shell size" icon
            // convert the icon to the "system" icon size.
            if (psfi->hIcon && !(uFlags & SHGFI_SHELLICONSIZE))
                psfi->hIcon = (HICON)CopyImage(psfi->hIcon, IMAGE_ICON, cx, cy, LR_COPYRETURNORG | LR_COPYDELETEORG);
        }

        // get display name for the path
        if (uFlags & SHGFI_DISPLAYNAME)
        {
            DisplayNameOf(psf, pidlLast, SHGDN_NORMAL, psfi->szDisplayName, ARRAYSIZE(psfi->szDisplayName));
        }

        if (uFlags & SHGFI_TYPENAME)
        {
            IShellFolder2 *psf2;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                VARIANT var;
                VariantInit(&var);
                if (SUCCEEDED(psf2->GetDetailsEx(pidlLast, &SCID_TYPE, &var)))
                {
                    VariantToStr(&var, psfi->szTypeName, ARRAYSIZE(psfi->szTypeName));
                    VariantClear(&var);
                }
                psf2->Release();
            }
        }

        psf->Release();
    }
    else
        dwResult = 0;

    return dwResult;
}

//
//  This function returns shell info about a given pathname.
//  a app can get the following:
//
//      Icon (large or small)
//      Display Name
//      Name of File Type
//
//  this function replaces SHGetFileIcon

#define BUGGY_SHELL16_CBFILEINFO    (sizeof(SHFILEINFO) - 4)

STDAPI_(DWORD_PTR) SHGetFileInfo(LPCTSTR pszPath, DWORD dwFileAttributes, SHFILEINFO *psfi, UINT cbFileInfo, UINT uFlags)
{
    LPITEMIDLIST pidlFull;
    DWORD_PTR res = 1;
    TCHAR szPath[MAX_PATH];

    // this was never enforced in the past
    // TODDB: The 16 to 32 bit thunking layer passes in the wrong value for cbFileInfo.
    // The size passed in looks to be the size of the 16 bit version of the structure
    // rather than the size of the 32 bit version, as such it is 4 bytes shorter.
    // TJGREEN: Special-case that size to keep the assertion from firing and party on.
    // 
    ASSERT(!psfi || cbFileInfo == sizeof(*psfi) || cbFileInfo == BUGGY_SHELL16_CBFILEINFO);

    // You can't use both SHGFI_ATTR_SPECIFIED and SHGFI_ICON.
    ASSERT(uFlags & SHGFI_ATTR_SPECIFIED ? !(uFlags & SHGFI_ICON) : TRUE);

    if (pszPath == NULL)
        return 0;

    if (uFlags == SHGFI_EXETYPE)
        return GetExeType(pszPath);     // funky way to get EXE type

    if (psfi == NULL)
        return 0;

    psfi->hIcon = 0;

    // Zip Pro 6.0 relies on the fact that if you don't ask for the icon,
    // the iIcon field doesn't change.
    //
    // psfi->iIcon = 0;

    psfi->szDisplayName[0] = 0;
    psfi->szTypeName[0] = 0;

    //  do some simmple check on the input path.
    if (!(uFlags & SHGFI_PIDL))
    {
        // If the caller wants us to give them the file attributes, we can't trust
        // the attributes they gave us in the following two situations.
        if (uFlags & SHGFI_ATTRIBUTES)
        {
            if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
            {
                DebugMsg(TF_FSTREE, TEXT("SHGetFileInfo cant use caller supplied file attribs for a sys/ro directory (possible junction)"));
                uFlags &= ~SHGFI_USEFILEATTRIBUTES;
            }
            else if (PathIsRoot(pszPath))
            {
                DebugMsg(TF_FSTREE, TEXT("SHGetFileInfo cant use caller supplied file attribs for a roots"));
                uFlags &= ~SHGFI_USEFILEATTRIBUTES;
            }
        }

        if (PathIsRelative(pszPath))
        {
            if (uFlags & SHGFI_USEFILEATTRIBUTES)
            {
                // get a shorter path than the current directory to support
                // long pszPath names (that might get truncated in the 
                // long current dir case)

                GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
            }
            else
            {
                GetCurrentDirectory(ARRAYSIZE(szPath), szPath);
            }
            PathCombine(szPath, szPath, pszPath);
            pszPath = szPath;
        }
    }

    if (uFlags & SHGFI_PIDL)
        pidlFull = (LPITEMIDLIST)pszPath;
    else if (uFlags & SHGFI_USEFILEATTRIBUTES)
    {
        WIN32_FIND_DATA fd = {0};
        fd.dwFileAttributes = dwFileAttributes;
        SHSimpleIDListFromFindData(pszPath, &fd, &pidlFull);
    }
    else
        pidlFull = ILCreateFromPath(pszPath);

    if (pidlFull)
    {
        if (uFlags & (
            SHGFI_DISPLAYNAME   |
            SHGFI_ATTRIBUTES    |
            SHGFI_SYSICONINDEX  |
            SHGFI_ICONLOCATION  |
            SHGFI_ICON          | 
            SHGFI_TYPENAME))
        {
            res = _GetFileInfoSections(pidlFull, psfi, uFlags);
        }

        if (!(uFlags & SHGFI_PIDL))
            ILFree(pidlFull);
    }
    else
        res = 0;

    return res;
}


//===========================================================================
//
// SHGetFileInfoA Stub
//
//  This function calls SHGetFileInfoW and then converts the returned
//  information back to ANSI.
//
//===========================================================================
STDAPI_(DWORD_PTR) SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags)
{
    WCHAR szPathW[MAX_PATH];
    LPWSTR pszPathW;
    DWORD_PTR dwRet;

    if (uFlags & SHGFI_PIDL)
    {
        pszPathW = (LPWSTR)pszPath;     // Its a pidl, fake it as a WSTR
    }
    else
    {
        SHAnsiToUnicode(pszPath, szPathW, ARRAYSIZE(szPathW));
        pszPathW = szPathW;
    }
    if (psfi)
    {
        SHFILEINFOW sfiw;

        ASSERT(cbFileInfo == sizeof(*psfi));

        // Zip Pro 6.0 sets SHGFI_SMALLICON | SHGFI_OPENICON but forgets to
        // pass SHGFI_ICON or SHGFI_SYSICONINDEX, even though they really
        // wanted the sys icon index.
        //
        // In Windows 95, fields of the SHFILEINFOA structure that you didn't
        // query for were left unchanged.  They happened to have the icon for
        // a closed folder lying around there from a previous query, so they
        // got away with it by mistake.  They got the wrong icon, but it was
        // close enough that nobody really complained.
        //
        // So pre-initialize the sfiw's iIcon with the app's iIcon.  That
        // way, if it turns out the app didn't ask for the icon, he just
        // gets his old value back.
        //

        sfiw.iIcon = psfi->iIcon;
        sfiw.dwAttributes = psfi->dwAttributes;

        dwRet = SHGetFileInfoW(pszPathW, dwFileAttributes, &sfiw, sizeof(sfiw), uFlags);

        psfi->hIcon = sfiw.hIcon;
        psfi->iIcon = sfiw.iIcon;
        psfi->dwAttributes = sfiw.dwAttributes;
        SHUnicodeToAnsi(sfiw.szDisplayName, psfi->szDisplayName, ARRAYSIZE(psfi->szDisplayName));
        SHUnicodeToAnsi(sfiw.szTypeName, psfi->szTypeName, ARRAYSIZE(psfi->szTypeName));
    }
    else
    {
        dwRet = SHGetFileInfoW(pszPathW, dwFileAttributes, NULL, 0, uFlags);
    }
    return dwRet;
}

STDAPI ThunkFindDataWToA(WIN32_FIND_DATAW *pfd, WIN32_FIND_DATAA *pfda, int cb)
{
    if (cb < sizeof(WIN32_FIND_DATAA))
        return DISP_E_BUFFERTOOSMALL;

    memcpy(pfda, pfd, FIELD_OFFSET(WIN32_FIND_DATAA, cFileName));

    SHUnicodeToAnsi(pfd->cFileName, pfda->cFileName, ARRAYSIZE(pfda->cFileName));
    SHUnicodeToAnsi(pfd->cAlternateFileName, pfda->cAlternateFileName, ARRAYSIZE(pfda->cAlternateFileName));
    return S_OK;
}

STDAPI ThunkNetResourceWToA(LPNETRESOURCEW pnrw, LPNETRESOURCEA pnra, UINT cb)
{
    HRESULT hr;

    if (cb >= sizeof(NETRESOURCEA))
    {
        LPSTR psza, pszDest[4] = {NULL, NULL, NULL, NULL};

        CopyMemory(pnra, pnrw, FIELD_OFFSET(NETRESOURCE, lpLocalName));

        psza = (LPSTR)(pnra + 1);   // Point just past the structure
        if (cb > sizeof(NETRESOURCE))
        {
            LPWSTR pszSource[4];
            UINT i, cchRemaining = cb - sizeof(NETRESOURCE);

            pszSource[0] = pnrw->lpLocalName;
            pszSource[1] = pnrw->lpRemoteName;
            pszSource[2] = pnrw->lpComment;
            pszSource[3] = pnrw->lpProvider;

            for (i = 0; i < 4; i++)
            {
                if (pszSource[i])
                {
                    UINT cchItem;
                    pszDest[i] = psza;
                    cchItem = SHUnicodeToAnsi(pszSource[i], pszDest[i], cchRemaining);
                    cchRemaining -= cchItem;
                    psza += cchItem;
                }
            }

        }
        pnra->lpLocalName  = pszDest[0];
        pnra->lpRemoteName = pszDest[1];
        pnra->lpComment    = pszDest[2];
        pnra->lpProvider   = pszDest[3];
        hr = S_OK;
    }
    else
        hr = DISP_E_BUFFERTOOSMALL;
    return hr;
}

STDAPI NetResourceWVariantToBuffer(const VARIANT* pvar, void* pv, UINT cb)
{
    HRESULT hr;

    if (cb >= sizeof(NETRESOURCEW))
    {
        if (pvar && pvar->vt == (VT_ARRAY | VT_UI1))
        {
            int i;
            NETRESOURCEW* pnrw = (NETRESOURCEW*) pvar->parray->pvData;
            UINT cbOffsets[4] = { 0, 0, 0, 0 };
            UINT cbEnds[4] = { 0, 0, 0, 0 };
            LPWSTR pszPtrs[4] = { pnrw->lpLocalName, pnrw->lpRemoteName,
                                  pnrw->lpComment, pnrw->lpProvider };
            hr = S_OK;
            for (i = 0; i < ARRAYSIZE(pszPtrs); i++)
            {
                if (pszPtrs[i])
                {
                    cbOffsets[i] = (UINT) ((BYTE*) pszPtrs[i] - (BYTE*) pnrw);
                    cbEnds[i] = cbOffsets[i] + (sizeof(WCHAR) * (lstrlenW(pszPtrs[i]) + 1));
                
                    // If any of the strings start or end too far into the buffer, then fail:
                    if ((cbOffsets[i] >= cb) || (cbEnds[i] > cb))
                    {
                        hr = DISP_E_BUFFERTOOSMALL;
                        break;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = VariantToBuffer(pvar, pv, cb) ? S_OK : E_FAIL;
                pnrw = (NETRESOURCEW*) pv;
                if (SUCCEEDED(hr))
                {
                    // Fixup pointers in structure to point into the output buffer,
                    // instead of the variant buffer:
                    LPWSTR* ppszPtrs[4] = { &(pnrw->lpLocalName), &(pnrw->lpRemoteName),
                                            &(pnrw->lpComment), &(pnrw->lpProvider) };
                                
                    for (i = 0; i < ARRAYSIZE(ppszPtrs); i++)
                    {
                        if (*ppszPtrs[i])
                        {
                            *ppszPtrs[i] = (LPWSTR) ((BYTE*) pnrw + cbOffsets[i]);
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = DISP_E_BUFFERTOOSMALL;
    }
    return hr;
}

//  This function will extract information that is cached in the pidl such
//  in the information that was returned from a FindFirst file.  This function
//  is sortof a hack as t allow outside callers to be able to get at the infomation
//  without knowing how we store it in the pidl.
//  a app can get the following:

STDAPI SHGetDataFromIDListW(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb)
{
    HRESULT hr = E_NOTIMPL;
    SHCOLUMNID* pscid;

    if (!pv || !psf || !pidl)
        return E_INVALIDARG;

    switch (nFormat)
    {
        case SHGDFIL_FINDDATA:
            if (cb < sizeof(WIN32_FIND_DATAW))
                return DISP_E_BUFFERTOOSMALL;
            else
                pscid = (SHCOLUMNID*)&SCID_FINDDATA;
            break;
        case SHGDFIL_NETRESOURCE:
            if (cb < sizeof(NETRESOURCEW))
                return  DISP_E_BUFFERTOOSMALL;
            else
                pscid = (SHCOLUMNID*)&SCID_NETRESOURCE;
            break;
        case SHGDFIL_DESCRIPTIONID:
            pscid = (SHCOLUMNID*)&SCID_DESCRIPTIONID;
            break;
        default:
            return E_INVALIDARG;
    }

    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        VARIANT var;
        VariantInit(&var);
        hr = psf2->GetDetailsEx(pidl, pscid, &var);
        if (SUCCEEDED(hr))
        {
            if (SHGDFIL_NETRESOURCE == nFormat)
            {
                hr = NetResourceWVariantToBuffer(&var, pv, cb);
            }
            else
            {
                if (!VariantToBuffer(&var, pv, cb))
                    hr = E_FAIL;
            }
            VariantClear(&var);
        }
        else
        {
            TraceMsg(TF_WARNING, "Trying to retrieve find data from unknown PIDL %s", DumpPidl(pidl));
        }

        psf2->Release();
    }

    return hr;
}

STDAPI SHGetDataFromIDListA(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb)
{
    HRESULT hr;
    WIN32_FIND_DATAW fdw;
    NETRESOURCEW *pnrw = NULL;
    void *pvData = pv;
    int cbData = cb;

    if (nFormat == SHGDFIL_FINDDATA)
    {
        cbData = sizeof(fdw);
        pvData = &fdw;
    }
    else if (nFormat == SHGDFIL_NETRESOURCE)
    {
        cbData = cb;
        pvData = pnrw = (NETRESOURCEW *)LocalAlloc(LPTR, cbData);
        if (pnrw == NULL)
            return E_OUTOFMEMORY;
    }

    hr = SHGetDataFromIDListW(psf, pidl, nFormat, pvData, cbData);

    if (SUCCEEDED(hr))
    {
        if (nFormat == SHGDFIL_FINDDATA)
        {
            hr = ThunkFindDataWToA(&fdw, (WIN32_FIND_DATAA *)pv, cb);
        }
        else if (nFormat == SHGDFIL_NETRESOURCE)
        {
            hr = ThunkNetResourceWToA(pnrw, (NETRESOURCEA *)pv, cb);
        }
    }

    if (pnrw)
        LocalFree(pnrw);

    return hr;
}


int g_iUseLinkPrefix = -1;

#define INITIALLINKPREFIXCOUNT 20
#define MAXLINKPREFIXCOUNT  30

void LoadUseLinkPrefixCount()
{
    TraceMsg(TF_FSTREE, "LoadUseLinkPrefixCount %d", g_iUseLinkPrefix);
    if (g_iUseLinkPrefix < 0)
    {
        DWORD cb = sizeof(g_iUseLinkPrefix);
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, c_szLink, NULL, &g_iUseLinkPrefix, &cb))
        || g_iUseLinkPrefix < 0)
        {
            g_iUseLinkPrefix = INITIALLINKPREFIXCOUNT;
        }
    }
}

void SaveUseLinkPrefixCount()
{
    if (g_iUseLinkPrefix >= 0)
    {
        SKSetValue(SHELLKEY_HKCU_EXPLORER, NULL, c_szLink, REG_BINARY, &g_iUseLinkPrefix, sizeof(g_iUseLinkPrefix));
    }
}

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

// psz2 = destination
// psz1 = source
void _StripNumber(LPWSTR psz)
{
    // strip out the '(' and the numbers after it
    // We need to verify that it is either simply () or (999) but not (A)
    for (; *psz; psz++) 
    {
        if (*psz == TEXT('(')) 
        {
            LPCWSTR pszT = psz + 1;
            while (*pszT && ISDIGIT(*pszT))
            {
                pszT++; 
            }  

            if (*pszT == TEXT(')'))
            {
                //  we got a match
                if (*++pszT == TEXT(' '))
                {
                    pszT++; // skip the extra space
                }

                int cch = lstrlen(pszT);
                MoveMemory(psz, pszT, CbFromCchW(cch + 1));
                return;
            }
            //   else Continue to scan for the pattern
        }
    }
}

#define SHORTCUT_PREFIX_DECR 5
#define SHORTCUT_PREFIX_INCR 1

// this checks to see if you've renamed 'Shortcut #x To Foo' to 'Foo'

void CheckShortcutRename(LPCTSTR pszOldPath, LPCTSTR pszNewPath)
{
    ASSERT(pszOldPath);
    ASSERT(pszNewPath);

    // already at 0.
    if (g_iUseLinkPrefix)
    {
        LPCTSTR pszOldName = PathFindFileName(pszOldPath);
        if (PathIsLnk(pszOldName)) 
        {
            TCHAR szBaseName[MAX_PATH];
            TCHAR szLinkTo[80];
            TCHAR szMockName[MAX_PATH];

            StringCchCopy(szBaseName, ARRAYSIZE(szBaseName), PathFindFileName(pszNewPath));
            PathRemoveExtension(szBaseName);

            // mock up a name using the basename and the linkto template
            LoadString(HINST_THISDLL, IDS_LINKTO, szLinkTo, ARRAYSIZE(szLinkTo));
            wnsprintf(szMockName, ARRAYSIZE(szMockName), szLinkTo, szBaseName);

            StringCchCopy(szBaseName, ARRAYSIZE(szBaseName), pszOldName);

            _StripNumber(szMockName);
            _StripNumber(szBaseName);

            // are the remaining gunk the same?
            if (!lstrcmp(szMockName, szBaseName)) 
            {
                // yes!  do the link count magic
                LoadUseLinkPrefixCount();
                ASSERT(g_iUseLinkPrefix >= 0);
                g_iUseLinkPrefix -= SHORTCUT_PREFIX_DECR;
                if (g_iUseLinkPrefix < 0)
                    g_iUseLinkPrefix = 0;
                SaveUseLinkPrefixCount();
            }
        }
    }
}

STDAPI_(int) SHRenameFileEx(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszDir, 
                            LPCTSTR pszOldName, LPCTSTR pszNewName)
{
    int iRet = ERROR_CANCELLED; // user saw the error, don't report again
    TCHAR szOldPathName[MAX_PATH + 1];    // +1 for double nul terminating on SHFileOperation
    TCHAR szTempNewPath[MAX_PATH];
    BOOL bEnableUI = hwnd || punkEnableModless;

    IUnknown_EnableModless(punkEnableModless, FALSE);

    PathCombine(szOldPathName, pszDir, pszOldName);
    szOldPathName[lstrlen(szOldPathName) + 1] = 0;

    StrCpyN(szTempNewPath, pszNewName, ARRAYSIZE(szTempNewPath));
    int err = PathCleanupSpec(pszDir, szTempNewPath);
    if (err)
    {
        if (bEnableUI)
        {
            ShellMessageBox(HINST_THISDLL, hwnd,
                    err & PCS_PATHTOOLONG ?
                        MAKEINTRESOURCE(IDS_REASONS_INVFILES) :
                        IsLFNDrive(pszDir) ?
                            MAKEINTRESOURCE(IDS_INVALIDFN) :
                            MAKEINTRESOURCE(IDS_INVALIDFNFAT),
                    MAKEINTRESOURCE(IDS_RENAME), MB_OK | MB_ICONHAND);
        }
    }
    else
    {
        // strip off leading and trailing blanks off of the new file name.
        StrCpyN(szTempNewPath, pszNewName, ARRAYSIZE(szTempNewPath));
        PathRemoveBlanks(szTempNewPath);
        if (!szTempNewPath[0] || (szTempNewPath[0] == TEXT('.')))
        {
            if (bEnableUI)
            {
                ShellMessageBox(HINST_THISDLL, hwnd,
                    MAKEINTRESOURCE(IDS_NONULLNAME),
                    MAKEINTRESOURCE(IDS_RENAME), MB_OK | MB_ICONHAND);
            }
        }
        else
        {
            int idPrompt = IDYES;
            TCHAR szNewPathName[MAX_PATH + 1];    // +1 for double nul terminating on SHFileOperation

            PathCombine(szNewPathName, pszDir, szTempNewPath);

            // if there was an old extension and the new and old don't match complain
            LPTSTR pszExt = PathFindExtension(pszOldName);
            if (*pszExt && lstrcmpi(pszExt, PathFindExtension(szTempNewPath)))
            {
                HKEY hk;
                if (!PathIsDirectory(szOldPathName) && 
                    SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, pszExt, NULL, &hk)))
                {
                    RegCloseKey(hk);

                    if (bEnableUI)
                    {
                        idPrompt = ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_WARNCHANGEEXT),
                            MAKEINTRESOURCE(IDS_RENAME), MB_YESNO | MB_ICONEXCLAMATION);
                    }
                }
            }

            if (IDYES == idPrompt)
            {
                szNewPathName[lstrlen(szNewPathName) + 1] = 0;     // double NULL terminate

                SHFILEOPSTRUCT fo = { hwnd, FO_RENAME, szOldPathName, szNewPathName, FOF_SILENT | FOF_ALLOWUNDO, };

                iRet = SHFileOperation(&fo);

                if (ERROR_SUCCESS == iRet)
                    CheckShortcutRename(szOldPathName, szNewPathName);
            }
        }
    }
    IUnknown_EnableModless(punkEnableModless, TRUE);
    return iRet;
}


HKEY SHOpenShellFolderKey(const CLSID *pclsid)
{
    HKEY hkey;
    return SUCCEEDED(SHRegGetCLSIDKey(*pclsid, TEXT("ShellFolder"), FALSE, FALSE, &hkey)) ? hkey : NULL;
}

BOOL SHQueryShellFolderValue(const CLSID *pclsid, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;      // assume no
    HKEY hkey = SHOpenShellFolderKey(pclsid);
    if (hkey)
    {
        bRet = SHQueryValueEx(hkey, pszValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        RegCloseKey(hkey);
    }
    return bRet;
}

//
//  The SZ_REGKEY_MYCOMPUTER_NONENUM_POLICY key contains a bunch of values,
//  each named after a GUID.  The data associated with each value is a
//  DWORD, which is either...
//
//  0 = no restriction on this CLSID
//  1 = unconditional restriction on this CLSID
//  0xFFFFFFFF = same as 1 (in case somebody got "creative")
//  any other value = pass to SHRestricted() to see what the restriction is
//
//  We support 0xFFFFFFFF only out of paranoia.  This flag was only 0 or 1
//  in Windows 2000, and somebody might've decided that "all bits set"
//  is better than "just one bit set".
//
#define SZ_REGKEY_MYCOMPUTER_NONENUM_POLICY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\NonEnum")

BOOL _IsNonEnumPolicySet(const CLSID *pclsid)
{
    BOOL fPolicySet = FALSE;
    TCHAR szCLSID[GUIDSTR_MAX];
    DWORD dwDefault = 0;
    RESTRICTIONS rest = REST_NONE;
    DWORD cbSize = sizeof(rest);

    if (EVAL(SHStringFromGUID(*pclsid, szCLSID, ARRAYSIZE(szCLSID))) &&
       (ERROR_SUCCESS == SHRegGetUSValue(SZ_REGKEY_MYCOMPUTER_NONENUM_POLICY, szCLSID, NULL, &rest, &cbSize, FALSE, &dwDefault, sizeof(dwDefault))) &&
       rest)
    {
        fPolicySet = rest == 1 || rest == 0xFFFFFFFF || SHRestricted(rest);
    }

    return fPolicySet;
}

DWORD QueryCallForAttributes(HKEY hkey, const CLSID *pclsid, DWORD dwDefAttrs, DWORD dwRequested)
{
    DWORD dwAttr = dwDefAttrs;
    DWORD dwData, cbSize = sizeof(dwAttr);

    // consider caching this folder to avoid creating over and over
    // mydocs.dll uses this for compat with old apps

    // See if this folder has asked us specifically to call and get
    // the attributes...
    //
    if (SHQueryValueEx(hkey, TEXT("CallForAttributes"), NULL, NULL, &dwData, &cbSize) == ERROR_SUCCESS)
    {
        // CallForAttributes can be a masked value. See if it's being supplied in the value.
        // NOTE: MyDocs.dll registers with a NULL String, so this check works.
        DWORD dwMask = (DWORD)-1;
        if (sizeof(dwData) == cbSize)
        {
            // There is a mask, Use this.
            dwMask = dwData;
        }

        // Is the requested bit contained in the specified mask?
        if (dwMask & dwRequested)
        {
            // Yes. Then CoCreate and Query.
            IShellFolder *psf;
            if (SUCCEEDED(SHExtCoCreateInstance(NULL, pclsid, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                dwAttr = dwRequested;
                psf->GetAttributesOf(0, NULL, &dwAttr);
                psf->Release();
            }
            else
            {
                 dwAttr |= SFGAO_FILESYSTEM;
            }
        }
    }

    return dwAttr;
}

// dwRequested is the bits you are explicitly looking for. This is an optimization that prevents reg hits.

STDAPI_(DWORD) SHGetAttributesFromCLSID2(const CLSID *pclsid, DWORD dwDefAttrs, DWORD dwRequested)
{
    DWORD dwAttr = dwDefAttrs;
    HKEY hkey = SHOpenShellFolderKey(pclsid);
    if (hkey)
    {
        DWORD dwData, cbSize = sizeof(dwAttr);

        // We are looking for some attributes on a shell folder. These attributes can be in two locations:
        // 1) In the "Attributes" value in the registry.
        // 2) Stored in a the shell folder's GetAttributesOf.

        // First, Check to see if the reqested value is contained in the registry.
        if (SHQueryValueEx(hkey, TEXT("Attributes"), NULL, NULL, (BYTE *)&dwData, &cbSize) == ERROR_SUCCESS &&
            cbSize == sizeof(dwData))
        {
            // We have data there, but it may not contain the data we are looking for
            dwAttr = dwData & dwRequested;

            // Does it contain the bit we are looking for?
            if (((dwAttr & dwRequested) != dwRequested) && dwRequested != 0)
            {
                // No. Check to see if it is in the shell folder implementation
                goto CallForAttributes;
            }
        }
        else
        {
CallForAttributes:
            // See if we have to talk to the shell folder.
            // I'm passing dwAttr, because if the previous case did not generate any attributes, then it's
            // equal to dwDefAttrs. If the call to CallForAttributes fails, then it will contain the value of
            // dwDefAttrs or whatever was in the shell folder's Attributes key
            dwAttr = QueryCallForAttributes(hkey, pclsid, dwAttr, dwRequested);
        }

        RegCloseKey(hkey);
    }

    if (_IsNonEnumPolicySet(pclsid))
        dwAttr |= SFGAO_NONENUMERATED;

    if (SHGetObjectCompatFlags(NULL, pclsid) & OBJCOMPATF_NOTAFILESYSTEM)
        dwAttr &= ~SFGAO_FILESYSTEM;

    return dwAttr;
}

// _BuildLinkName
//
// Used during the creation of a shortcut, this function determines an appropriate name for the shortcut.
// This is not the exact name that will be used becuase it will usually contain "() " which will either
// get removed or replaced with "(x) " where x is a number that makes the name unique.  This removal is done
// elsewhere (currently in PathYetAnotherMakeUniqueName).
//
// in:
//      pszName file spec part
//      pszDir  path part of name to know how to limit the long name...
//
// out:
//      pszLinkName - Full path to link name (May fit in 8.3...).  Can be the same buffer as pszName.
//
// NOTES: If pszDir + pszLinkName is greater than MAX_PATH we will fail to create the shortcut.
// In an effort to prevent 
void _BuildLinkName(LPTSTR pszLinkName, LPCTSTR pszName, LPCTSTR pszDir, BOOL fLinkTo)
{
    TCHAR szLinkTo[40]; // "Shortcut to %s.lnk"
    TCHAR szTemp[MAX_PATH + 40];

    if (fLinkTo)
    {
        // check to see if we're in the "don't ever say 'shortcut to' mode"
        LoadUseLinkPrefixCount();

        if (!g_iUseLinkPrefix)
        {
            fLinkTo = FALSE;
        }
        else if (g_iUseLinkPrefix > 0)
        {
            if (g_iUseLinkPrefix < MAXLINKPREFIXCOUNT)
            {
                g_iUseLinkPrefix += SHORTCUT_PREFIX_INCR;
                SaveUseLinkPrefixCount();
            }
        }
    }

    if (!fLinkTo)
    {
        // Generate the title of this link ("XX.lnk")
        LoadString(HINST_THISDLL, IDS_LINKEXTENSION, szLinkTo, ARRAYSIZE(szLinkTo));
    }
    else
    {
        // Generate the title of this link ("Shortcut to XX.lnk")
        LoadString(HINST_THISDLL, IDS_LINKTO, szLinkTo, ARRAYSIZE(szLinkTo));
    }
    wnsprintf(szTemp, ARRAYSIZE(szTemp), szLinkTo, pszName);

    PathCleanupSpecEx(pszDir, szTemp);      // get rid of illegal chars AND ensure correct filename length
    StrCpyN(pszLinkName, szTemp, MAX_PATH);

    ASSERT(PathIsLnk(pszLinkName));
}

// return a new destination path for a link
//
// in:
//      fErrorSoTryDesktop      we are called because there was an error saving
//                              the shortcut and we want to prompt to see if the
//                              desktop should be used.
//
// in/out:
//      pszPath     on input the place being tried, on output the desktop folder
//
// returns:
//
//      IDYES       user said yes to creating a link at new place
//      IDNO        user said no to creating a link at new place
//      -1          error
//

int _PromptTryDesktopLinks(HWND hwnd, LPTSTR pszPath, BOOL fErrorSoTryDesktop)
{
    TCHAR szPath[MAX_PATH];
    if (!SHGetSpecialFolderPath(hwnd, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
        return -1;      // fail no desktop dir

    int idOk;

    if (fErrorSoTryDesktop)
    {
        // Fail, if pszPath already points to the desktop directory.
        if (lstrcmpi(szPath, pszPath) == 0)
            return -1;

        idOk = ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_TRYDESKTOPLINK),
                        MAKEINTRESOURCE(IDS_LINKTITLE),
                        MB_YESNO | MB_ICONQUESTION);
    }
    else
    {
        ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_MAKINGDESKTOPLINK),
                        MAKEINTRESOURCE(IDS_LINKTITLE),
                        MB_OK | MB_ICONASTERISK);
        idOk = IDYES;
    }

    if (idOk == IDYES)
        StrCpyN(pszPath, szPath, MAX_PATH);  // output

    return idOk;    // return yes or no
}

// in:
//      pszpdlLinkTo    LPCITEMIDLIST or LPCTSTR, target of link to create
//      pszDir          where we will put the link
//      uFlags          SHGNLI_ flags
//       
// out:
//      pszName         file name to create "c:\Shortcut to Foo.lnk"
//      pfMustCopy      pszpdlLinkTo was a link itself, make a copy of this

STDAPI_(BOOL) SHGetNewLinkInfo(LPCTSTR pszpdlLinkTo, LPCTSTR pszDir, LPTSTR pszName,
                               BOOL *pfMustCopy, UINT uFlags)
{
    BOOL fDosApp = FALSE;
    BOOL fLongFileNames = IsLFNDrive(pszDir);
    SHFILEINFO sfi;

    *pfMustCopy = FALSE;

    sfi.dwAttributes = SFGAO_FILESYSTEM | SFGAO_LINK | SFGAO_FOLDER;

    if (uFlags & SHGNLI_PIDL)
    {
        if (FAILED(SHGetNameAndFlags((LPCITEMIDLIST)pszpdlLinkTo, SHGDN_NORMAL,
                            pszName, MAX_PATH, &sfi.dwAttributes)))
            return FALSE;
    }
    else
    {
        if (SHGetFileInfo(pszpdlLinkTo, 0, &sfi, sizeof(sfi),
                          SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES | SHGFI_ATTR_SPECIFIED |
                          ((uFlags & SHGNLI_PIDL) ? SHGFI_PIDL : 0)))
            StrCpyN(pszName, sfi.szDisplayName, MAX_PATH);
        else
            return FALSE;
    }

    if (PathCleanupSpecEx(pszDir, pszName) & PCS_FATAL)
        return FALSE;

    //
    //  WARNING:  From this point on, sfi.szDisplayName may be re-used to
    //  contain the file path of the PIDL we are linking to.  Don't rely on
    //  it containing the display name.
    //
    if (sfi.dwAttributes & SFGAO_FILESYSTEM)
    {
        LPTSTR pszPathSrc;

        if (uFlags & SHGNLI_PIDL)
        {
            pszPathSrc = sfi.szDisplayName;
            SHGetPathFromIDList((LPCITEMIDLIST)pszpdlLinkTo, pszPathSrc);
        }
        else
        {
            pszPathSrc = (LPTSTR)pszpdlLinkTo;
        }
        fDosApp = (lstrcmpi(PathFindExtension(pszPathSrc), TEXT(".pif")) == 0) ||
                  (LOWORD(GetExeType(pszPathSrc)) == 0x5A4D); // 'MZ'

        if (sfi.dwAttributes & SFGAO_LINK)
        {
            *pfMustCopy = TRUE;
            if (!(sfi.dwAttributes & SFGAO_FOLDER))
            {
                uFlags &= ~SHGNLI_NOLNK; // if copying the file then don't trim the extension
            }
            StrCpyN(pszName, PathFindFileName(pszPathSrc), MAX_PATH);
        }
        else
        {
            //
            // when making a link to a drive root. special case a few things
            //
            // if we are not on a LFN drive, dont use the full name, just
            // use the drive letter.    "C.LNK" not "Label (C).LNK"
            //
            // if we are making a link to removable media, we dont want the
            // label as part of the name, we want the media type.
            //
            // CD-ROM drives are currently the only removable media we
            // show the volume label for, so we only need to special case
            // cdrom drives here.
            //
            if (PathIsRoot(pszPathSrc) && !PathIsUNC(pszPathSrc))
            {
                if (!fLongFileNames)
                    StrCpyN(pszName, pszPathSrc, MAX_PATH);
                else if (IsCDRomDrive(DRIVEID(pszPathSrc)))
                    LoadString(HINST_THISDLL, IDS_DRIVES_CDROM, pszName, MAX_PATH);
            }
        }
        if (fLongFileNames && fDosApp)
        {
            HANDLE hPif = PifMgr_OpenProperties(pszPathSrc, NULL, 0, OPENPROPS_INHIBITPIF);
            if (hPif)
            {
                PROPPRG PP = {0};
                if (PifMgr_GetProperties(hPif, (LPCSTR)MAKELP(0, GROUP_PRG), &PP, sizeof(PP), 0) &&
                    ((PP.flPrgInit & PRGINIT_INFSETTINGS) ||
                    ((PP.flPrgInit & (PRGINIT_NOPIF | PRGINIT_DEFAULTPIF)) == 0)))
                {
                    SHAnsiToTChar(PP.achTitle, pszName, MAX_PATH);
                }
                PifMgr_CloseProperties(hPif, 0);
            }
        }
    }
    if (!*pfMustCopy)
    {
        // create full dest path name.  only use template iff long file names
        // can be created and the caller requested it.  _BuildLinkName will
        // truncate files on non-lfn drives and clean up any invalid chars.
        _BuildLinkName(pszName, pszName, pszDir,
           (!(*pfMustCopy) && fLongFileNames && (uFlags & SHGNLI_PREFIXNAME)));
    }

    if (fDosApp)
        PathRenameExtension(pszName, TEXT(".pif"));

    if (uFlags & SHGNLI_NOLNK)
    {
        // Don't do PathRemoveExtension because pszName might contain
        // internal dots ("Windows 3.1") and passing that to
        // PathYetAnotherMakeUniqueName will result in
        // "Windows 3  (2).1" which is wrong.  We leave the dot at the
        // end so we get "Windows 3.1 (2)." back.  We will strip off the
        // final dot later.
        PathRenameExtension(pszName, TEXT("."));
    }

    // make sure the name is unique
    // NOTE: PathYetAnotherMakeUniqueName will return the directory+filename in the pszName buffer.
    // It returns FALSE if the name is not unique or the dir+filename is too long.  If it returns
    // false then this function should return false because creation will fail.
    BOOL fSuccess;
    if (!(uFlags & SHGNLI_NOUNIQUE))
        fSuccess = PathYetAnotherMakeUniqueName(pszName, pszDir, pszName, pszName);
    else
        fSuccess = TRUE;

    // Strip off any trailing dots that may have been generated by SHGNI_NOLNK
    PathStripTrailingDots(pszName);

    return fSuccess;
}

STDAPI_(BOOL) SHGetNewLinkInfoA(LPCSTR pszpdlLinkTo, LPCSTR pszDir, LPSTR pszName,
                                BOOL *pfMustCopy, UINT uFlags)
{
    ThunkText * pThunkText;
    BOOL bResult = FALSE;

    if (uFlags & SHGNLI_PIDL) 
    {
        // 1 string (pszpdlLinkTo is a pidl)
        pThunkText = ConvertStrings(2, NULL, pszDir);

        if (pThunkText)
            pThunkText->m_pStr[0] = (LPWSTR)pszpdlLinkTo;
    } 
    else 
    {
        // 2 strings
        pThunkText = ConvertStrings(2, pszpdlLinkTo, pszDir);
    }

    if (pThunkText)
    {
        WCHAR wszName[MAX_PATH];
        bResult = SHGetNewLinkInfoW(pThunkText->m_pStr[0], pThunkText->m_pStr[1],
                                    wszName, pfMustCopy, uFlags);
        LocalFree(pThunkText);
        if (bResult)
        {
            if (0 == WideCharToMultiByte(CP_ACP, 0, wszName, -1,
                                         pszName, MAX_PATH, NULL, NULL))
            {
                SetLastError((DWORD)E_FAIL);
                bResult = FALSE;
            }
        }
    }
    return bResult;
}

//
// in:
//      pidlTo

STDAPI CreateLinkToPidl(LPCITEMIDLIST pidlTo, LPCTSTR pszDir, LPITEMIDLIST *ppidl, UINT uFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szPathDest[MAX_PATH];
    BOOL fCopyLnk;
    BOOL fUseLinkTemplate = (SHCL_USETEMPLATE & uFlags);
    UINT uSHGNLI = fUseLinkTemplate ? SHGNLI_PIDL | SHGNLI_PREFIXNAME : SHGNLI_PIDL;

    if (uFlags & SHCL_MAKEFOLDERSHORTCUT)
    {
        // Don't add ".lnk" to the folder shortcut name; that's just stupid
        uSHGNLI |= SHGNLI_NOLNK;
    }

    if (uFlags & SHCL_NOUNIQUE)
    {
        uSHGNLI |= SHGNLI_NOUNIQUE;
    }

    if (SHGetNewLinkInfo((LPTSTR)pidlTo, pszDir, szPathDest, &fCopyLnk, uSHGNLI))
    {
        TCHAR szPathSrc[MAX_PATH];
        IShellLink *psl = NULL;

        // If we passed SHGNLI_NOUNIQUE then we need to do the PathCombine ourselves
        // because SHGetNewLinkInfo won't
        if (uFlags & SHCL_NOUNIQUE)
        {
            PathCombine(szPathDest, pszDir, szPathDest);
        }

        DWORD dwAttributes = SFGAO_FILESYSTEM | SFGAO_FOLDER;
        SHGetNameAndFlags(pidlTo, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szPathSrc, ARRAYSIZE(szPathSrc), &dwAttributes);

        if (fCopyLnk)
        {
            // if it is file system and not a folder (CopyFile does not work on folders)
            // just copy it.
            if (((dwAttributes & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM) &&
                CopyFile(szPathSrc, szPathDest, TRUE))
            {
                TouchFile(szPathDest);

                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szPathDest, NULL);
                SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPathDest, NULL);
                hr = S_OK;
            }
            else
            {
                // load the source object that will be "copied" below (with the ::Save call)
                hr = SHGetUIObjectFromFullPIDL(pidlTo, NULL, IID_PPV_ARG(IShellLink, &psl));
            }
        } 
        else
        {
            hr = SHCoCreateInstance(NULL, uFlags & SHCL_MAKEFOLDERSHORTCUT ?
                &CLSID_FolderShortcut : &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(pidlTo);
                // set the working directory to the same path
                // as the file we are linking too
                if (szPathSrc[0] && ((dwAttributes & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM))
                {
                    PathRemoveFileSpec(szPathSrc);
                    psl->SetWorkingDirectory(szPathSrc);
                }
            }
        }

        if (psl)
        {
            if (SUCCEEDED(hr))
            {
                IPersistFile *ppf;
                hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                if (SUCCEEDED(hr))
                {
                    hr = ppf->Save(szPathDest, TRUE);
                    if (SUCCEEDED(hr))
                    {
                        // in case ::Save translated the name of the 
                        // file (.LNK -> .PIF, or Folder Shortcut)
                        WCHAR *pwsz;
                        if (SUCCEEDED(ppf->GetCurFile(&pwsz)) && pwsz)
                        {
                            SHUnicodeToTChar(pwsz, szPathDest, ARRAYSIZE(szPathDest));
                            SHFree(pwsz);
                        }
                    }
                    ppf->Release();
                }
            }
            psl->Release();
        }
    }

    if (ppidl)
    {
        *ppidl = SUCCEEDED(hr) ? SHSimpleIDListFromPath(szPathDest) : NULL;
    }
    return hr;
}


// in/out:
//      pszDir         inital folder to try, output new folder (desktop)
// out:
//      ppidl          optional output PIDL of thing created

HRESULT _CreateLinkRetryDesktop(HWND hwnd, LPCITEMIDLIST pidlTo, LPTSTR pszDir, UINT fFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    if (ppidl)
        *ppidl = NULL;          // assume error

    if (*pszDir && (fFlags & SHCL_CONFIRM))
    {
        hr = CreateLinkToPidl(pidlTo, pszDir, ppidl, fFlags);
    }
    else
    {
        hr = E_FAIL;
    }

    // if we were unable to save, ask user if they want us to
    // try it again but change the path to the desktop.

    if (FAILED(hr))
    {
        int id;

        if (hr == STG_E_MEDIUMFULL)
        {
            DebugMsg(TF_ERROR, TEXT("failed to create link because disk is full"));
            id = IDYES;
        }
        else
        {
            if (fFlags & SHCL_CONFIRM)
            {
                id = _PromptTryDesktopLinks(hwnd, pszDir, (fFlags & SHCL_CONFIRM));
            }
            else
            {
                id = (SHGetSpecialFolderPath(hwnd, pszDir, CSIDL_DESKTOPDIRECTORY, FALSE)) ? IDYES : IDNO;
            }

            if (id == IDYES && *pszDir)
            {
                hr = CreateLinkToPidl(pidlTo, pszDir, ppidl, fFlags);
            }
        }

        //  we failed to create the link complain to the user.
        if (FAILED(hr) && id != IDNO)
        {
            ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_CANNOTCREATELINK),
                            MAKEINTRESOURCE(IDS_LINKTITLE),
                            MB_OK | MB_ICONASTERISK);
        }
    }

#ifdef DEBUG
    if (FAILED(hr) && ppidl)
        ASSERT(*ppidl == NULL);
#endif

    return hr;
}

//
// This function creates links to the stuff in the IDataObject
//
// Arguments:
//  hwnd        for any UI
//  pszDir      optional target directory (where to create links)
//  pDataObj    data object describing files (array of idlist)
//  ppidl       optional pointer to an array that receives pidls pointing to the new links
//              or NULL if not interested
STDAPI SHCreateLinks(HWND hwnd, LPCTSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl)
{
    DECLAREWAITCURSOR;
    STGMEDIUM medium;
    HRESULT hr;

    SetWaitCursor();

    LPIDA pida = DataObj_GetHIDA(pDataObj, &medium);
    if (pida)
    {
        TCHAR szTargetDir[MAX_PATH];
        hr = S_OK;          // In case hida contains zero elements

        szTargetDir[0] = 0;

        if (pszDir)
            StrCpyN(szTargetDir, pszDir, ARRAYSIZE(szTargetDir));

        if (!(fFlags & SHCL_USEDESKTOP))
            fFlags |= SHCL_CONFIRM;

        for (UINT i = 0; i < pida->cidl; i++)
        {
            LPITEMIDLIST pidlTo = IDA_ILClone(pida, i);
            if (pidlTo)
            {
                hr = _CreateLinkRetryDesktop(hwnd, pidlTo, szTargetDir, fFlags, ppidl ? &ppidl[i] : NULL);

                ILFree(pidlTo);

                if (FAILED(hr))
                    break;
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
        hr = E_OUTOFMEMORY;

    SHChangeNotifyHandleEvents();
    ResetWaitCursor();

    return hr;
}

HRESULT SelectPidlInSFV(IShellFolderViewDual *psfv, LPCITEMIDLIST pidl, DWORD dwOpts)
{
    VARIANT var;
    HRESULT hr = InitVariantFromIDList(&var, pidl);
    if (SUCCEEDED(hr))
    {
        hr = psfv->SelectItem(&var, dwOpts);
        VariantClear(&var);
    }
    return hr;
}

HRESULT OpenFolderAndGetView(LPCITEMIDLIST pidlFolder, IShellFolderViewDual **ppsfv)
{
    *ppsfv = NULL;

    IWebBrowserApp *pauto;
    HRESULT hr = SHGetIDispatchForFolder(pidlFolder, &pauto);
    if (SUCCEEDED(hr))
    {
        HWND hwnd;
        if (SUCCEEDED(pauto->get_HWND((LONG_PTR*)&hwnd)))
        {
            // Make sure we make this the active window
            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_SHOWNORMAL);
        }

        IDispatch *pdoc;
        hr = pauto->get_Document(&pdoc);
        if (S_OK == hr) // careful, automation returns S_FALSE
        {
            hr = pdoc->QueryInterface(IID_PPV_ARG(IShellFolderViewDual, ppsfv));
            pdoc->Release();
        }
        else
            hr = E_FAIL;
        pauto->Release();
    }
    return hr;
}

// pidlFolder   - fully qualified pidl to the folder to open
// cidl/apidl   - array of items in that folder to select
//
// if cild == 0 then pidlFolder is the fully qualified pidl to a single item, it's
// folder is opened and it is selected.
//
// dwFlags - optional flags, pass 0 for now

SHSTDAPI SHOpenFolderAndSelectItems(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl, DWORD dwFlags)
{
    HRESULT hr;
    if (0 == cidl)
    {
        // overload the 0 item case to mean pidlFolder is the full pidl to the item
        LPITEMIDLIST pidlTemp;
        hr = SHILClone(pidlFolder, &pidlTemp);
        if (SUCCEEDED(hr))
        {
            ILRemoveLastID(pidlTemp); // strip to the folder
            LPCITEMIDLIST pidl = ILFindLastID(pidlFolder);

            hr = SHOpenFolderAndSelectItems(pidlTemp, 1, &pidl, 0); // recurse

            ILFree(pidlTemp);
        }
    }
    else
    {
        IShellFolderViewDual *psfv;
        hr = OpenFolderAndGetView(pidlFolder, &psfv);
        if (SUCCEEDED(hr))
        {
            DWORD dwSelFlags = SVSI_SELECT | SVSI_FOCUSED | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE;
            for (UINT i = 0; i < cidl; i++)
            {
                hr = SelectPidlInSFV(psfv, apidl[i], dwSelFlags);
                dwSelFlags = SVSI_SELECT;   // second items append to sel
            }
           psfv->Release();
        }
    }
    return hr;
}

SHSTDAPI SHCreateShellItem(LPCITEMIDLIST pidlParent, IShellFolder *psfParent, LPCITEMIDLIST pidl, IShellItem **ppsi)
{
    *ppsi = NULL;
    IShellItem *psi;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellItem, NULL, IID_PPV_ARG(IShellItem, &psi));
    if (SUCCEEDED(hr))
    {
        if (pidlParent || psfParent)
        {
            IParentAndItem *pinit;

            ASSERT(pidl);

            hr = psi->QueryInterface(IID_PPV_ARG(IParentAndItem, &pinit));
            if (SUCCEEDED(hr))
            {
                hr = pinit->SetParentAndItem(pidlParent, psfParent, pidl);
                pinit->Release();
            }
        }
        else
        {
            IPersistIDList *pinit;
            hr = psi->QueryInterface(IID_PPV_ARG(IPersistIDList, &pinit));
            if (SUCCEEDED(hr))
            {
                hr = pinit->SetIDList(pidl);
                pinit->Release();
            }
        }

        if (SUCCEEDED(hr))
            *ppsi = psi;
        else
            psi->Release();
    }

    return hr;
}

STDAPI SHCreateShellItemFromParent(IShellItem *psiParent, LPCWSTR pszName, IShellItem **ppsi)
{
    *ppsi = NULL;

    IShellFolder *psf;
    HRESULT hr = psiParent->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = SHGetIDListFromUnk(psiParent, &pidl);
        if (SUCCEEDED(hr))
        {
            ULONG cchEaten;
            LPITEMIDLIST pidlChild;
            hr = psf->ParseDisplayName(NULL, NULL, (LPWSTR)pszName, &cchEaten, &pidlChild, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateShellItem(pidl, psf, pidlChild, ppsi);
                ILFree(pidlChild);
            }
            ILFree(pidl);
        }
        psf->Release();
    }

    return hr;
}

SHSTDAPI SHSetLocalizedName(LPWSTR pszPath, LPCWSTR pszResModule, int idsRes)
{
    IShellFolder *psfDesktop;
    HRESULT hrInit = SHCoInitialize();
    HRESULT hr = hrInit;

    if (SUCCEEDED(hrInit))
    {
        hr = SHGetDesktopFolder(&psfDesktop);

        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = psfDesktop->ParseDisplayName(NULL, NULL, pszPath, NULL, &pidl, NULL);
        
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlChild;
                IShellFolder *psf;
                hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);

                if (SUCCEEDED(hr))
                {
                    //  WARNING - this is a stack sensitive function - ZekeL 29-Jan-2001
                    //  since this function is called by winlogon/userenv
                    //  we need to be sensitive to the stack limitations of those callers

                    //  the shortname will be no larger than the long name
                    DWORD cchShort = lstrlenW(pszResModule) + 1;
                    PWSTR pszShort;
                    hr = SHLocalAlloc(CbFromCchW(cchShort), &pszShort);
                    if (SUCCEEDED(hr))
                    {
                        DWORD cch = GetShortPathName(pszResModule, pszShort, cchShort);
                        if (cch)
                        {
                            pszResModule = pszShort;
                        }
                        else
                        {
                            //  GSPN() fails when the module passed in is a relative path
                            cch = cchShort;
                        }
                        
                        cch += 14;  //  11 for id + ',' + '@' + null
                        PWSTR pszName;
                        hr = SHLocalAlloc(CbFromCchW(cch), &pszName);
                        if (SUCCEEDED(hr))
                        {
                            wnsprintfW(pszName, cch, L"@%s,%d", pszResModule, (idsRes * -1));
                            hr = psf->SetNameOf(NULL, pidlChild, pszName, SHGDN_NORMAL, NULL);
                            LocalFree(pszName);
                        }
                        LocalFree(pszShort);
                     }

                    psf->Release();
                }
                SHFree(pidl);
            }
            psfDesktop->Release();
        }
    }

    SHCoUninitialize(hrInit);

    return hr;
}

// ShellHookProc was mistakenly exported in the original NT SHELL32.DLL when
// it didn't need to be (hookproc's, like wndproc's don't need to be exported
// in the 32-bit world).  In order to maintain loadability of a app
// which might have linked to it, we stub it here.  If some app ended up really
// using it, then we'll look into a specific fix for that app.
STDAPI_(LONG) ShellHookProc(int code, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

// RegisterShellHook - wrapper around RegisterShellHookWindow()/DeregisterShellHookWindow()
// the GetTaskmanWindow() stuff is legacy that I don't think is really needed

HWND g_hwndTaskMan = NULL;

STDAPI_(BOOL) RegisterShellHook(HWND hwnd, BOOL fInstall)
{
    BOOL fOk = TRUE;

    switch (fInstall) 
    {
    case 0:
        // un-installation of shell hooks
        g_hwndTaskMan = GetTaskmanWindow();
        if (hwnd == g_hwndTaskMan)
        {
            SetTaskmanWindow(NULL);
        }
        DeregisterShellHookWindow(hwnd);
        return TRUE;

    case 3:
        // explorer.exe Tray uses this
        if (g_hwndTaskMan != NULL)
        {
            SetTaskmanWindow(NULL);
            g_hwndTaskMan = NULL;
        }
        fOk = SetTaskmanWindow(hwnd);
        if (fOk)
        {
            g_hwndTaskMan = hwnd;
        }
        RegisterShellHookWindow(hwnd);   // install
        break;
    }
    return TRUE;
}

EXTERN_C DWORD g_dwThreadBindCtx;

class CThreadBindCtx : public IBindCtx
{
public:
    CThreadBindCtx(IBindCtx *pbc) : _cRef(1) { _pbc = pbc; _pbc->AddRef(); }
    ~CThreadBindCtx();
    
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IBindCtx methods ***
    STDMETHODIMP RegisterObjectBound(IUnknown *punk)
    {   return _pbc->RegisterObjectBound(punk); }
    
    STDMETHODIMP RevokeObjectBound(IUnknown *punk)
    {   return _pbc->RevokeObjectBound(punk); }
    
    STDMETHODIMP ReleaseBoundObjects(void)
    {   return _pbc->ReleaseBoundObjects(); }
    
    STDMETHODIMP SetBindOptions(BIND_OPTS *pbindopts)
    {   return _pbc->SetBindOptions(pbindopts); }
    
    STDMETHODIMP GetBindOptions(BIND_OPTS *pbindopts)
    {   return _pbc->GetBindOptions(pbindopts); }
    
    STDMETHODIMP GetRunningObjectTable(IRunningObjectTable **pprot)
    {   return _pbc->GetRunningObjectTable(pprot); }
    
    STDMETHODIMP RegisterObjectParam(LPOLESTR pszKey, IUnknown *punk)
    {   return _pbc->RegisterObjectParam(pszKey, punk); }
    
    STDMETHODIMP GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk)
    {   return _pbc->GetObjectParam(pszKey, ppunk); }
    
    STDMETHODIMP EnumObjectParam(IEnumString **ppenum)
    {   return _pbc->EnumObjectParam(ppenum); }
    
    STDMETHODIMP RevokeObjectParam(LPOLESTR pszKey)
    {   return _pbc->RevokeObjectParam(pszKey); }
    
private:
    LONG _cRef;
    IBindCtx *  _pbc;
};

CThreadBindCtx::~CThreadBindCtx()
{
    ATOMICRELEASE(_pbc);
}

HRESULT CThreadBindCtx::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThreadBindCtx, IBindCtx),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CThreadBindCtx::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CThreadBindCtx::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
        //  clear ourselves out
        TlsSetValue(g_dwThreadBindCtx, NULL);
    }
    return cRef;
}

STDAPI TBCGetBindCtx(BOOL fCreate, IBindCtx **ppbc)
{
    HRESULT hr = E_UNEXPECTED;
    *ppbc = NULL;
    if ((DWORD) -1 != g_dwThreadBindCtx)
    {
        CThreadBindCtx *ptbc = (CThreadBindCtx *)TlsGetValue(g_dwThreadBindCtx);
        if (ptbc)
        {
            ptbc->AddRef();
            *ppbc = SAFECAST(ptbc, IBindCtx *);
            hr = S_OK;
        }
        else if (fCreate)
        {
            IBindCtx *pbcInner;
            hr = CreateBindCtx(0, &pbcInner);

            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;
                ptbc = new CThreadBindCtx(pbcInner);
                if (ptbc)
                {
                    if (TlsSetValue(g_dwThreadBindCtx, ptbc))
                    {
                        *ppbc = SAFECAST(ptbc, IBindCtx *);
                        hr = S_OK;
                    }
                    else
                        delete ptbc;
                }
                pbcInner->Release();
            }
        }
    }

    return hr;
}

STDAPI TBCRegisterObjectParam(LPCOLESTR pszKey, IUnknown *punk, IBindCtx **ppbcLifetime)
{
    IBindCtx *pbc;
    HRESULT hr = TBCGetBindCtx(TRUE, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = BindCtx_RegisterObjectParam(pbc, pszKey, punk, ppbcLifetime);
        pbc->Release();    
    }
    else
        *ppbcLifetime = 0;
    
    return hr;
}

STDAPI TBCGetObjectParam(LPCOLESTR pszKey, REFIID riid, void **ppv)
{
    IBindCtx *pbc;
    HRESULT hr = TBCGetBindCtx(FALSE, &pbc);
    if (SUCCEEDED(hr))
    {
        IUnknown *punk;
        hr = pbc->GetObjectParam((LPOLESTR)pszKey, &punk);
        if (SUCCEEDED(hr) )
        {
            if (ppv)
                hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        pbc->Release();
    }
    return hr;
}

#define TBCENVOBJECT    L"ThreadEnvironmentVariables"
STDAPI TBCGetEnvironmentVariable(LPCWSTR pszVar, LPWSTR pszValue, DWORD cchValue)
{
    IPropertyBag *pbag;
    HRESULT hr = TBCGetObjectParam(TBCENVOBJECT, IID_PPV_ARG(IPropertyBag, &pbag));
    if (SUCCEEDED(hr))
    {
        hr = SHPropertyBag_ReadStr(pbag, pszVar, pszValue, cchValue);
        pbag->Release();
    }
    return hr;
}

STDAPI TBCSetEnvironmentVariable(LPCWSTR pszVar, LPCWSTR pszValue, IBindCtx **ppbcLifetime)
{
    *ppbcLifetime = 0;
    IPropertyBag *pbag;
    HRESULT hr = TBCGetObjectParam(TBCENVOBJECT, IID_PPV_ARG(IPropertyBag, &pbag));

    if (FAILED(hr))
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &pbag));

    if (SUCCEEDED(hr))
    {
        hr = SHPropertyBag_WriteStr(pbag, pszVar, pszValue);

        if (SUCCEEDED(hr))
            hr = TBCRegisterObjectParam(TBCENVOBJECT, pbag, ppbcLifetime);

        pbag->Release();
    }

    return hr;
}

// create a stock IExtractIcon handler for a thing that is file like. this is typically
// used by name space extensiosn that display things that are like files in the
// file system. that is the extension, file attributes decrive all that is needed
// for a simple icon extractor

STDAPI SHCreateFileExtractIconW(LPCWSTR pszFile, DWORD dwFileAttributes, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;

    SHFILEINFO sfi = {0};
    if (SHGetFileInfo(pszFile, dwFileAttributes, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES))
    {
        hr = SHCreateDefExtIcon(TEXT("*"), sfi.iIcon, sfi.iIcon, GIL_PERCLASS | GIL_NOTFILENAME, -1, riid, ppv);
        DestroyIcon(sfi.hIcon);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sharedfldr.cpp ===
#include "shellprv.h"
#include "util.h"
#include "ids.h"
#include "infotip.h"
#include "fstreex.h"
#include "lm.h"
#include "shgina.h"
#include "prop.h"
#include "datautil.h"
#include "filefldr.h"
#include "buytasks.h"
#pragma hdrstop


// this define causes the shared folder code to work on domains (for debug)
//#define SHOW_SHARED_FOLDERS 

// filter out the current user accounts
#define FILTER_CURRENT_USER 0

// where do we store the doc folder paths
#define REGSTR_PATH_DOCFOLDERPATH  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DocFolderPaths")

// state API for showing the shared documents folder

STDAPI_(BOOL) SHShowSharedFolders()
{
#ifndef SHOW_SHARED_FOLDERS
    // restriction overrides all logic for the shared documents

    if (SHRestricted(REST_NOSHAREDDOCUMENTS))
        return FALSE;

    // if we haven't computed the "show shared folders flag" then do so

    static int iShow = -1;
    if (iShow == -1)      
        iShow = (IsOS(OS_DOMAINMEMBER) || IsOS(OS_ANYSERVER)) ? 0:1;    // only works if we are not a domain/server user

    return (iShow >= 1);
#else
    return true;
#endif
}


// implementation of a delegate shell folder for merging in shared documents

STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);

HRESULT CSharedDocsEnum_CreateInstance(HDPA hItems, DWORD grfFlags, IEnumIDList **ppenum);

#pragma pack(1)
typedef struct
{
    // these memebers overlap DELEGATEITEMID struct
    // for our IDelegateFolder support
    WORD cbSize;
    WORD wOuter;
    WORD cbInner;

    // our stuff
    DWORD dwType;               // our type of folder
    TCHAR wszID[1];             // unique ID for the user
} SHAREDITEM;
#pragma pack()

typedef UNALIGNED SHAREDITEM * LPSHAREDITEM;
typedef const UNALIGNED SHAREDITEM * LPCSHAREDITEM;

#define SHAREDID_COMMON 0x0
#define SHAREDID_USER   0x2


class CSharedDocuments : public IDelegateFolder, IPersistFolder2, IShellFolder2, IShellIconOverlay
{
public:
    CSharedDocuments();
    ~CSharedDocuments();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDelegateFolder
    STDMETHODIMP SetItemAlloc(IMalloc *pmalloc);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pclsid)
        { *pclsid = CLSID_SharedDocuments; return S_OK; }
        
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        { return BindToObject(pidl, pbc, riid, ppv); }
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
        { return E_NOTIMPL; }
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,REFIID riid, UINT* prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST* ppidlOut)
        { return E_NOTIMPL; }

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
        { return E_NOTIMPL; }
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
        { return E_NOTIMPL; }

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
        { return _GetOverlayIndex(pidl, pIndex, FALSE); }
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
        { return _GetOverlayIndex(pidl, pIconIndex, TRUE); }

private:
    LONG _cRef;
    IMalloc *_pmalloc;
    LPITEMIDLIST _pidl;

    CRITICAL_SECTION _cs;                   // critical section for managing lifetime of the cache

    TCHAR _szCurrentUser[UNLEN+1];          // user name (cached for current user)

    BOOL _fCachedAllUser:1;                 // cached the all user account
    TCHAR _szCachedUser[UNLEN+1];           //  if (FALSE) then this contains the user ID.

    IUnknown *_punkCached;                  // IUnknown object (from FS folder) that we cache
    LPITEMIDLIST _pidlCached;               // IDLIST of the cached folder

    void _ClearCachedObjects();
    BOOL _IsCached(LPCITEMIDLIST pidl);
    HRESULT _CreateFolder(LPBC pbc, LPCITEMIDLIST pidl, REFIID riid, void **ppv, BOOL fRegisterAlias);
    HRESULT _GetTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);
    HRESULT _GetTargetIDList(BOOL fForceReCache, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);
    HRESULT _AddIDList(HDPA hdpa, DWORD dwType, LPCTSTR pszUser);
    HRESULT _AllocIDList(DWORD dwType, LPCTSTR pszUser, LPITEMIDLIST *ppidl);
    HRESULT _GetSharedFolders(HDPA *phItems);
    HRESULT _GetAttributesOf(LPCITEMIDLIST pidl, DWORD rgfIn, DWORD *prgfOut);
    LPCTSTR _GetUserFromIDList(LPCITEMIDLIST pidl, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _GetPathForUser(LPCTSTR pcszUser, LPTSTR pszBuffer, int cchBuffer);
    HRESULT _GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex, BOOL fIcon);

    static HRESULT s_FolderMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    friend class CSharedDocsEnum;
};


// constructors

CSharedDocuments::CSharedDocuments() :
    _cRef(1)
{
    InitializeCriticalSection(&_cs);
}

CSharedDocuments::~CSharedDocuments()
{
    ATOMICRELEASE(_pmalloc);
    ATOMICRELEASE(_punkCached);

    ILFree(_pidlCached);
    ILFree(_pidl);
    
    DeleteCriticalSection(&_cs);
}

STDAPI CSharedDocFolder_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv)
{
    CSharedDocuments *psdf = new CSharedDocuments;
    if (!psdf)
        return E_OUTOFMEMORY;

    HRESULT hr = psdf->QueryInterface(riid, ppv);
    psdf->Release();
    return hr;
}


// IUnknown handling

STDMETHODIMP CSharedDocuments::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSharedDocuments, IDelegateFolder),                                // IID_IDelegateFolder
        QITABENTMULTI(CSharedDocuments, IShellFolder, IShellFolder2),               // IID_IShellFOlder
        QITABENT(CSharedDocuments, IShellFolder2),                                  // IID_IShellFolder2
        QITABENTMULTI(CSharedDocuments, IPersistFolder, IPersistFolder2),           // IID_IPersistFolder
        QITABENTMULTI(CSharedDocuments, IPersist, IPersistFolder2),                 // IID_IPersist
        QITABENT(CSharedDocuments, IPersistFolder2),                                // IID_IPersistFolder2
        QITABENT(CSharedDocuments, IShellIconOverlay),                              // IID_IShellIconOverlay
        QITABENTMULTI2(CSharedDocuments, IID_IPersistFreeThreadedObject, IPersist), // IID_IPersistFreeThreadedObject
        { 0 },
    };

    if (riid == CLSID_SharedDocuments)
    {
        *ppv = this;                        // no ref
        return S_OK;
    }

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSharedDocuments::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSharedDocuments::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDelegateFolder
HRESULT CSharedDocuments::SetItemAlloc(IMalloc *pmalloc)
{
    IUnknown_Set((IUnknown**)&_pmalloc, pmalloc);
    return S_OK;
}


HRESULT CSharedDocuments::Initialize(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    return SHILClone(pidl, &_pidl);
}

HRESULT CSharedDocuments::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return SHILClone(_pidl, ppidl);
}


// single level cache for the objects

void CSharedDocuments::_ClearCachedObjects()
{
    ATOMICRELEASE(_punkCached);      // clear out the cached items (old)
    ILFree(_pidlCached);
    _pidlCached = NULL;
}

BOOL CSharedDocuments::_IsCached(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;

    TCHAR szUser[UNLEN+1];
    if (_GetUserFromIDList(pidl, szUser, ARRAYSIZE(szUser)))    
    {
        // did we cache the users account information?

        if (!_szCachedUser[0] || (StrCmpI(_szCachedUser, szUser) != 0))
        {
            _fCachedAllUser = FALSE;
            StrCpyN(_szCachedUser, szUser, ARRAYSIZE(_szCachedUser));
            _ClearCachedObjects();
        }
        else
        {
            fResult = TRUE;             // were set!
        }
    }
    else
    {
        // the all user case is keyed on a flag rather than the
        // account name we are supposed to be using.

        if (!_fCachedAllUser)
        {
            _fCachedAllUser = TRUE;
            _szCachedUser[0] = TEXT('\0');
            _ClearCachedObjects();
        }
        else
        {   
            fResult = TRUE;             // were set
        }
    }

    return fResult;
}

// IShellFolder methods

HRESULT CSharedDocuments::_CreateFolder(LPBC pbc, LPCITEMIDLIST pidl, REFIID riid, void **ppv, BOOL fRegisterAlias)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&_cs);

    // get the target folder (were already in a critical section) 
    // and then bind down to the shell folder if we have not already
    // cached one for ourselves.

    if (!_IsCached(pidl) || !_punkCached)
    {
        LPITEMIDLIST pidlTarget;
        hr = _GetTargetIDList(TRUE, pidl, &pidlTarget); // clears _punkCached in here (so no leak)
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlInit;
            hr = SHILCombine(_pidl, pidl, &pidlInit);
            if (SUCCEEDED(hr))
            {
                hr = SHCoCreateInstance(NULL, &CLSID_ShellFSFolder, NULL, IID_PPV_ARG(IUnknown, &_punkCached));
                if (SUCCEEDED(hr))
                {
                    IPersistFolder3 *ppf;
                    hr = _punkCached->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf));
                    if (SUCCEEDED(hr))
                    {
                        PERSIST_FOLDER_TARGET_INFO pfti = {0};
                        pfti.pidlTargetFolder = (LPITEMIDLIST)pidlTarget;
                        pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
                        pfti.csidl = -1;
                        hr = ppf->InitializeEx(NULL, pidlInit, &pfti);
                        ppf->Release();
                    }

                    if (SUCCEEDED(hr) && fRegisterAlias)
                        SHChangeNotifyRegisterAlias(pidlTarget, pidlInit);

                    if (FAILED(hr))
                    {
                        _punkCached->Release();
                        _punkCached = NULL;
                    }
                }
                ILFree(pidlInit);
            }
            ILFree(pidlTarget);
        }
    }

    if (SUCCEEDED(hr))
        hr = _punkCached->QueryInterface(riid, ppv);

    LeaveCriticalSection(&_cs);
    return hr;
}


HRESULT CSharedDocuments::_GetTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    EnterCriticalSection(&_cs);
    HRESULT hr = _GetTargetIDList(FALSE, pidl, ppidl);
    LeaveCriticalSection(&_cs);
    return hr;
}

HRESULT CSharedDocuments::_GetTargetIDList(BOOL fForceReCache, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;
    if (fForceReCache || !_IsCached(pidl) || !_pidlCached)
    {
        _ClearCachedObjects();              // we don't have it cached now

        LPCSHAREDITEM psid = (LPCSHAREDITEM)pidl;
        if (psid->dwType == SHAREDID_COMMON)
        {
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DOCUMENTS|CSIDL_FLAG_NO_ALIAS, &_pidlCached);
        }
        else if (psid->dwType == SHAREDID_USER)
        {
            TCHAR szPath[MAX_PATH], szUser[UNLEN+1];
            hr = _GetPathForUser(_GetUserFromIDList(pidl, szUser, ARRAYSIZE(szUser)), szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
            {
                hr = ILCreateFromPathEx(szPath, NULL, ILCFP_FLAG_NO_MAP_ALIAS, &_pidlCached, NULL);
            }
        }
        else
        {
            hr = E_INVALIDARG;              // invalid IDLIST passed
        }
    }

    if (SUCCEEDED(hr))
        hr = SHILClone(_pidlCached, ppidl);
    
    return hr;
}

HRESULT CSharedDocuments::_AddIDList(HDPA hdpa, DWORD dwType, LPCTSTR pszUser)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _AllocIDList(dwType, pszUser, &pidl);
    if (SUCCEEDED(hr))
    {
        DWORD grfFlags = SFGAO_FOLDER;
        hr = _GetAttributesOf(pidl, SFGAO_FOLDER, &grfFlags);
        if (SUCCEEDED(hr) && grfFlags & SFGAO_FOLDER)
        {        
            if (-1 == DPA_AppendPtr(hdpa, pidl))
            {
                ILFree(pidl);
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = S_OK;
            }
        }
        else
        {
            ILFree(pidl); 
        }   
    }
    return hr;
}


HRESULT CSharedDocuments::_AllocIDList(DWORD dwType, LPCTSTR pszUser, LPITEMIDLIST *ppidl)
{
    DWORD cb = sizeof(SHAREDITEM);
    int cchUser = pszUser ? lstrlen(pszUser) + 1 : 0;

    // ID list contains strings if its a user 
    
    if (dwType == SHAREDID_USER)
        cb += sizeof(TCHAR) * cchUser;

    SHAREDITEM *psid = (SHAREDITEM*)_pmalloc->Alloc(cb);
    if (!psid)
        return E_OUTOFMEMORY;

    psid->dwType = dwType;                  // type is universal

    if (dwType == SHAREDID_USER)
        StrCpyW(psid->wszID, pszUser); // strcpy okay, just got allocated

    *ppidl = (LPITEMIDLIST)psid;
    return S_OK;
}

LPCTSTR CSharedDocuments::_GetUserFromIDList(LPCITEMIDLIST pidl, LPTSTR pszUser, int cchUser)
{
    LPCSHAREDITEM psid = (LPCSHAREDITEM)pidl;

    if (psid->dwType == SHAREDID_COMMON)
    {
        pszUser[0] = 0;               // initialize
        return NULL;
    }

    ualstrcpynW(pszUser, psid->wszID, cchUser);
    return pszUser;
}

HRESULT CSharedDocuments::_GetPathForUser(LPCTSTR pszUser, LPTSTR pszBuffer, int cchBuffer)
{
    HRESULT hr = E_FAIL;
    BOOL fResult = FALSE;

    if (!pszUser)
    {
        // get the common documents path (which covers all users), this user is always defined
        // so lets return TRUE if they just want to check to see if its defined, otherwise
        // just pass out the result from fetching the path.

        fResult = !pszBuffer || ((cchBuffer >= MAX_PATH) && SHGetSpecialFolderPath(NULL, pszBuffer, CSIDL_COMMON_DOCUMENTS, FALSE));
    }
    else
    {
        // we have a user ID, so lets attempt to get the path fro that from the registry
        // if we get it then pass it back to the caller.

        DWORD dwType;
        DWORD cbBuffer = cchBuffer*sizeof(TCHAR);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, pszUser, &dwType,  pszBuffer, &cbBuffer))
        {
            fResult = ((dwType == REG_SZ) && cbBuffer);      // did we get a value back?
        }
    }

    if (fResult)
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CSharedDocuments::_GetSharedFolders(HDPA *phItems)
{
    HRESULT hr = E_OUTOFMEMORY;
    HDPA hItems = DPA_Create(16);
    if (hItems)
    {
        if (!IsUserAGuest()) // all other users' my documents folders should appear in my computer for non-guest users on workgroup machines
        {
            ILogonEnumUsers *peu;
            hr = SHCoCreateInstance(NULL, &CLSID_ShellLogonEnumUsers, NULL, IID_PPV_ARG(ILogonEnumUsers, &peu));
            if (SUCCEEDED(hr))
            {
                UINT cUsers, iUser;
                hr = peu->get_length(&cUsers);
                for (iUser = 0; (cUsers != iUser) && SUCCEEDED(hr); iUser++)
                {
                    VARIANT varUser = {VT_I4};
                    InitVariantFromInt(&varUser, iUser);

                    ILogonUser *plu;
                    hr = peu->item(varUser, &plu);
                    if (SUCCEEDED(hr))
                    {
                        // only show document folders for users that can log in
                        VARIANT_BOOL vbLogonAllowed;
                        hr = plu->get_interactiveLogonAllowed(&vbLogonAllowed);
                        if (SUCCEEDED(hr) && (vbLogonAllowed != VARIANT_FALSE))
                        {
                            // get the user name as this is our key to to the users documents path
                            VARIANT var = {0};
                            hr = plu->get_setting(L"LoginName", &var);
                            if (SUCCEEDED(hr))
                            {
#if FILTER_CURRENT_USER                            
                                if (!_szCurrentUser[0])
                                {
                                    DWORD cchUser = ARRAYSIZE(_szCurrentUser);
                                    if (!GetUserName(_szCurrentUser, &cchUser))
                                    {
                                        _szCurrentUser[0] = TEXT('\0');
                                    }
                                }

                                if (!_szCurrentUser[0] || (StrCmpI(var.bstrVal, _szCurrentUser) != 0))
                                {
                                    HRESULT hrT = _AddIDList(hItems, SHAREDID_USER, var.bstrVal);
                                    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrT)
                                    {
                                        SHDeleteValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, var.bstrVal);
                                    }                                    
                                }
#else
                                HRESULT hrT = _AddIDList(hItems, SHAREDID_USER, var.bstrVal);
                                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrT)
                                {
                                    SHDeleteValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, var.bstrVal);
                                }                                    
#endif
                                VariantClear(&var);
                            }
                        }
                        plu->Release();
                    }
                }

                peu->Release();
            }            
        }

        _AddIDList(hItems, SHAREDID_COMMON, NULL);  
        hr = S_OK;
    }

    *phItems = hItems;
    return hr;
}


// parsing support allows us to pick off SharedDocuments from the root
// of the shell namespace and navigate there - this a canonical name
// that we use for binding to the shared documents folder attached
// to the My Computer namespace.

HRESULT CSharedDocuments::ParseDisplayName(HWND hwnd, LPBC pbc, LPTSTR pszName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;
    if (SHShowSharedFolders())
    {
        if (0 == StrCmpI(pszName, L"SharedDocuments"))
        {
            hr = _AllocIDList(SHAREDID_COMMON, NULL, ppidl);
            if (SUCCEEDED(hr) && pdwAttributes)
            {
                hr = _GetAttributesOf(*ppidl, *pdwAttributes, pdwAttributes);
            }
        }
    }
    return hr;
}


// enumerate the shared documents folders

HRESULT CSharedDocuments::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    *ppenumIDList = NULL;               // no enumerator yet

    HRESULT hr = S_FALSE;
    if (SHShowSharedFolders())
    {
        HDPA hItems;
        hr = _GetSharedFolders(&hItems);
        if (SUCCEEDED(hr))
        {
            hr = CSharedDocsEnum_CreateInstance(hItems, grfFlags, ppenumIDList);
            if (FAILED(hr))
            {
                DPA_FreeIDArray(hItems);
            }
        }
    }
    return hr;
}


// return the display name for the folders that we have

HRESULT CSharedDocuments::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
    HRESULT hr = S_OK; 
    TCHAR szName[MAX_PATH] = {0};
 
    LPCSHAREDITEM psid = (LPCSHAREDITEM)pidl;
    if (((uFlags & (SHGDN_INFOLDER|SHGDN_FORPARSING)) == SHGDN_INFOLDER) && 
         (psid && (psid->dwType == SHAREDID_USER)))
    {
        // compute the <user>'s Documents name that we will show, we key this on 
        // the user name we have in the IDList and its display string.

        USER_INFO_10 *pui;
        TCHAR szUser[MAX_PATH];
        if (NERR_Success == NetUserGetInfo(NULL, _GetUserFromIDList(pidl, szUser, ARRAYSIZE(szUser)), 10, (LPBYTE*)&pui))
        {
            if (*pui->usri10_full_name)
            {
                StrCpyN(szUser, pui->usri10_full_name, ARRAYSIZE(szUser));
            }
            NetApiBufferFree(pui);
        }     

        TCHAR szFmt[MAX_PATH];
        LoadString(g_hinst, IDS_LOCALGDN_FLD_THEIRDOCUMENTS, szFmt, ARRAYSIZE(szFmt));
        wnsprintf(szName, ARRAYSIZE(szName), szFmt, szUser);
    }
    else
    {
        // all other scenarios dump down to the real folder to get their display
        // name for this folder.

        LPITEMIDLIST pidlTarget;
        hr = _GetTarget(pidl, &pidlTarget);
        if (SUCCEEDED(hr))
        {
            hr = SHGetNameAndFlags(pidlTarget, uFlags, szName, ARRAYSIZE(szName), NULL);
            ILFree(pidlTarget);
        }
    }

    if (SUCCEEDED(hr))
        hr = StringToStrRet(szName, lpName);

    return hr;
}

LONG CSharedDocuments::_GetAttributesOf(LPCITEMIDLIST pidl, DWORD rgfIn, DWORD *prgfOut)
{
    DWORD dwResult = rgfIn;
    LPITEMIDLIST pidlTarget;
    HRESULT hr = _GetTarget(pidl, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlChild;
        hr = SHBindToIDListParent(pidlTarget, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetAttributesOf(1, &pidlChild, &dwResult);
            psf->Release();
        }
        ILFree(pidlTarget);
    }

    if (!SHShowSharedFolders())
        dwResult |= SFGAO_NONENUMERATED;

    *prgfOut = *prgfOut & (dwResult & ~(SFGAO_CANDELETE|SFGAO_CANRENAME|SFGAO_CANMOVE|SFGAO_CANCOPY));

    return hr;
}

HRESULT CSharedDocuments::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut)
{
    ULONG rgfOut = *rgfInOut;

    if (!cidl || !apidl)
        return E_INVALIDARG;

    for (UINT i = 0; i < cidl; i++)
        _GetAttributesOf(apidl[i], *rgfInOut, &rgfOut);

    *rgfInOut = rgfOut;
    return S_OK;
}


// bind through our folder 

HRESULT CSharedDocuments::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (IsEqualIID(riid, IID_IShellIconOverlay))
    {
        hr = this->QueryInterface(riid, ppv);
    }
    else
    {
        LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
        if (pidlFirst)
        {
            IShellFolder *psf;
            hr = _CreateFolder(pbc, pidlFirst, IID_PPV_ARG(IShellFolder, &psf), TRUE);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlNext = _ILNext(pidl);
                if (ILIsEmpty(pidlNext))
                {
                    hr = psf->QueryInterface(riid, ppv);
                }
                else
                {
                    hr = psf->BindToObject(pidlNext, pbc, riid, ppv);
                }
                psf->Release();
            }
            ILFree(pidlFirst);
        }
    }
    return hr;
}


// handle UI objects - for the most part we delegate to the real namespace implementation

HRESULT CSharedDocuments::s_FolderMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSharedDocuments *psd;
    psf->QueryInterface(CLSID_SharedDocuments, (void **)&psd);

    // defcm will only add the default handlers (eg. Open/Explore) if we have a callback
    // and the DFM_MERGECONTEXTMENU is successful.  so lets honor that so we can navigate

    if (uMsg == DFM_MERGECONTEXTMENU)
    {
        return S_OK;
    }
    else if (uMsg == DFM_INVOKECOMMAND)
    {
        HRESULT hr;
        DFMICS *pdfmics = (DFMICS *)lParam;
        switch (wParam)
        {
            case DFM_CMD_LINK:
                hr = SHCreateLinks(hwnd, NULL, pdo, SHCL_CONFIRM|SHCL_USETEMPLATE|SHCL_USEDESKTOP, NULL);                
                break;
            
            case DFM_CMD_PROPERTIES:
                hr = SHLaunchPropSheet(CFSFolder_PropertiesThread, pdo, (LPCTSTR)lParam, NULL, (void *)&c_idlDesktop);
                break;

            default:
                hr = S_FALSE;           // use the default handler for this item
                break;
        }
        return hr;
    }

    return E_NOTIMPL;
}

HRESULT CSharedDocuments::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl, REFIID riid, UINT* prgfInOut, void **ppv)
{
    if (cidl != 1)
        return E_FAIL;

    HRESULT hr = E_FAIL;
    if (IsEqualIID(riid, IID_IContextMenu))
    {
        // we must construct our own context menu for this item, we do this using the
        // shell default implementation and we pass it the information about a folder
        // that way we can navigate up and down through the namespace.

        IQueryAssociations *pqa;
        hr = GetUIObjectOf(hwnd, 1, apidl, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            // this is broken for docfiles (shell\ext\stgfldr's keys work though)
            // maybe because GetClassFile punts when it's not fs?

            HKEY ahk[MAX_ASSOC_KEYS];
            DWORD cKeys = SHGetAssocKeys(pqa, ahk, ARRAYSIZE(ahk));
            hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, this, 
                                        s_FolderMenuCB, 
                                        cKeys, ahk, 
                                        (IContextMenu **)ppv);
            SHRegCloseKeys(ahk, cKeys);
            pqa->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        hr = SHCreateFileDataObject(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
    }
    else if (IsEqualIID(riid, IID_IQueryInfo))
    {
        IQueryAssociations *pqa;
        hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            WCHAR szCLSID[GUIDSTR_MAX];
            SHStringFromGUIDW(CLSID_SharedDocuments, szCLSID, ARRAYSIZE(szCLSID));
            hr = pqa->Init(0, szCLSID, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                WCHAR szInfotip[INFOTIPSIZE];
                DWORD cchInfotip = ARRAYSIZE(szInfotip);
                hr = pqa->GetString(0, ASSOCSTR_INFOTIP, NULL, szInfotip, &cchInfotip);
                if (SUCCEEDED(hr))
                {
                    hr = CreateInfoTipFromText(szInfotip, IID_IQueryInfo, ppv); // _the_ InfoTip COM object
                }
            }
            pqa->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations))
    {
        LPITEMIDLIST pidlTarget;
        hr = _GetTarget(apidl[0], &pidlTarget);
        if (SUCCEEDED(hr))
        {
            hr = SHGetUIObjectOf(pidlTarget, hwnd, riid, ppv);
            ILFree(pidlTarget);
        }
    }
    else if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW))
    {
        UINT iIcon = II_FOLDER;
        UINT iIconOpen = II_FOLDEROPEN;

        TCHAR szModule[MAX_PATH];
        GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));

        hr = SHCreateDefExtIcon(szModule, iIcon, iIconOpen, GIL_PERCLASS, -1, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        IShellFolder *psf;
        hr = _CreateFolder(NULL, *apidl, IID_PPV_ARG(IShellFolder, &psf), TRUE);
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject(hwnd, riid, ppv);
            psf->Release();
        }
    }
    return hr;
}


HRESULT CSharedDocuments::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = ResultFromShort(0);

    // compare the contents of our IDLIST before we attemt to compare other elements
    // within it.

    LPCSHAREDITEM psid1 = (LPCSHAREDITEM)pidl1;
    LPCSHAREDITEM psid2 = (LPCSHAREDITEM)pidl2;

    if (psid1->dwType == psid2->dwType)
    {
        if (psid1->dwType == SHAREDID_USER)
        {
            hr = ResultFromShort(ualstrcmpi(psid1->wszID, psid2->wszID));
        }
        else
        {
            hr = ResultFromShort(0);            // common item == common item?    
        }
    }
    else
    {
        hr = ResultFromShort(psid1->dwType - psid2->dwType);
    }

    // if there was an exact match then lets compare the trailing elements of the IDLIST
    // if there are some (by binding down) etc.

    if (hr == ResultFromShort(0))
    {
        LPITEMIDLIST pidlNext1 = _ILNext(pidl1);
        LPITEMIDLIST pidlNext2 = _ILNext(pidl2);

        if (ILIsEmpty(pidlNext1))
        {
            if (ILIsEmpty(pidlNext2))
            {
                hr = ResultFromShort(0);    // pidl1 == pidl2 (in length)
            }
            else
            {
                hr = ResultFromShort(-1);   // pidl1 < pidl2 (in length)
            }
        }
        else
        {
            // if IDLIST2 is shorter then return > otherwise we should just
            // recurse down the IDLIST and let the next level compare.

            if (ILIsEmpty(pidlNext2))
            {
                hr = ResultFromShort(+1);   // pidl1 > pidl2 (in lenght)
            }
            else
            {
                LPITEMIDLIST pidlFirst = ILCloneFirst(pidl1);
                if (pidlFirst)
                {
                    IShellFolder *psf;
                    hr = _CreateFolder(NULL, pidlFirst, IID_PPV_ARG(IShellFolder, &psf), FALSE);
                    if (SUCCEEDED(hr))
                    {
                        hr = psf->CompareIDs(lParam, pidlNext1, pidlNext2);
                        psf->Release();    
                    }
                    ILFree(pidlFirst);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    return hr;
}

HRESULT CSharedDocuments::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_FAIL;
    if (IsEqualSCID(SCID_DESCRIPTIONID, *pscid))
    {
        SHDESCRIPTIONID did = {0};
        did.dwDescriptionId = SHDID_COMPUTER_SHAREDDOCS;
        did.clsid = CLSID_NULL;
        hr = InitVariantFromBuffer(pv, &did, sizeof(did));
    }
    else
    {
        LPITEMIDLIST pidlTarget;
        hr = _GetTarget(pidl, &pidlTarget);
        if (SUCCEEDED(hr))
        {
            IShellFolder2 *psf2;
            LPCITEMIDLIST pidlChild;
            hr = SHBindToIDListParent(pidlTarget, IID_PPV_ARG(IShellFolder2, &psf2), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf2->GetDetailsEx(pidlChild, pscid, pv);
                psf2->Release();
            }
            ILFree(pidlTarget);
        }
    }
    return hr;
}


// icon overlay handling.   deligate this to the right handler

HRESULT CSharedDocuments::_GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex, BOOL fGetIconIndex)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = _GetTarget(pidl, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        IShellIconOverlay *psio;
        LPCITEMIDLIST pidlChild;
        hr = SHBindToIDListParent(pidlTarget, IID_PPV_ARG(IShellIconOverlay, &psio), &pidlChild);
        if (SUCCEEDED(hr))
        {   
            if (fGetIconIndex)
            {
                hr = psio->GetOverlayIconIndex(pidlChild, pIndex);
            }
            else
            {
                hr = psio->GetOverlayIndex(pidlChild, pIndex);
            }
            psio->Release();
        }
        ILFree(pidlTarget);
    }
    return hr;
}


// enumerator for listing all the shared documents in the system.

class CSharedDocsEnum : public IEnumIDList
{
private:
    LONG _cRef;
    HDPA _hItems;
    DWORD _grfFlags;
    int _index;

public:
    CSharedDocsEnum(HDPA hItems, DWORD grf);
    ~CSharedDocsEnum();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) 
        { return E_NOTIMPL; }
    STDMETHODIMP Reset()    
        { _index = 0; return S_OK; }
    STDMETHODIMP Clone(IEnumIDList **ppenum) 
        { return E_NOTIMPL; };

};

CSharedDocsEnum::CSharedDocsEnum(HDPA hItems, DWORD grfFlags) :
    _cRef(1),
    _hItems(hItems),
    _grfFlags(grfFlags),
    _index(0)
{
}

CSharedDocsEnum::~CSharedDocsEnum()
{
    DPA_FreeIDArray(_hItems);
}

HRESULT CSharedDocsEnum_CreateInstance(HDPA hItems, DWORD grfFlags, IEnumIDList **ppenum)
{
    CSharedDocsEnum *penum = new CSharedDocsEnum(hItems, grfFlags);
    if (!penum)
        return E_OUTOFMEMORY;

    HRESULT hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
    penum->Release();
    return hr;
}


// IUnknown handling

STDMETHODIMP CSharedDocsEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSharedDocsEnum, IEnumIDList),                              // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSharedDocsEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSharedDocsEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// enumeration handling

HRESULT CSharedDocsEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{   
    HRESULT hr = S_FALSE;
    ULONG cFetched = 0;

    if (_grfFlags & SHCONTF_FOLDERS)
    {
        // if we have more items to return and the buffer is still not full
        // then lets ensure that we return them.

        while (SUCCEEDED(hr) && (celt != cFetched) && (_index != DPA_GetPtrCount(_hItems)))
        {
            if (_index != DPA_GetPtrCount(_hItems))
            {
                hr = SHILClone((LPITEMIDLIST)DPA_GetPtr(_hItems, _index), &rgelt[cFetched]);
                if (SUCCEEDED(hr))
                {
                    cFetched++;       
                }
            }
            _index++;
        }
    }

    if (pceltFetched)
        *pceltFetched = cFetched;

    return hr;
}


// handle system initialization of the shared documents objects

void _SetLocalizedName(INT csidl, LPTSTR pszResModule, INT idsRes)
{
    TCHAR szPath[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szPath, csidl, TRUE))
    {
        SHSetLocalizedName(szPath, pszResModule, idsRes);
    }
}

HRESULT SHGetSampleMediaFolder(int nAllUsersMediaFolder, LPITEMIDLIST *ppidlSampleMedia);
#define PICTURES_BUYURL L"SamplePictures"
#define SAMPLEMUSIC_BUYURL L"http://windowsmedia.com/redir/xpsample.asp"

STDAPI_(void) InitializeSharedDocs(BOOL fWow64)
{
    // ACL the DocFolder paths key so that users can touch the keys and store their paths
    // for the document folders they have. 

    // we want the "Everyone" to have read/write access
    SHELL_USER_PERMISSION supEveryone;
    supEveryone.susID = susEveryone;
    supEveryone.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supEveryone.dwAccessMask = KEY_READ|KEY_WRITE;
    supEveryone.fInherit = TRUE;
    supEveryone.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supEveryone.dwInheritAccessMask = GENERIC_READ;

    // we want the "SYSTEM" to have full control
    SHELL_USER_PERMISSION supSystem;
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = KEY_ALL_ACCESS;
    supSystem.fInherit = TRUE;
    supSystem.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supSystem.dwInheritAccessMask = GENERIC_ALL;

    // we want the "Administrators" to have full control
    SHELL_USER_PERMISSION supAdministrators;
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = KEY_ALL_ACCESS;
    supAdministrators.fInherit = TRUE;
    supAdministrators.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supAdministrators.dwInheritAccessMask = GENERIC_ALL;

    PSHELL_USER_PERMISSION aPerms[3] = {&supEveryone, &supSystem, &supAdministrators};
    SECURITY_DESCRIPTOR* psd = GetShellSecurityDescriptor(aPerms, ARRAYSIZE(aPerms));
    if (psd)
    {
        HKEY hk;
        // setting security right afterwards.
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hk, NULL) == ERROR_SUCCESS)
        {
            RegSetKeySecurity(hk, DACL_SECURITY_INFORMATION, psd);
            RegCloseKey(hk);
        }
        LocalFree(psd);
    }
 
    // do file system initialization as needed so that the shared music/pictures folders
    // have the correct display names.

    if (!fWow64 && !IsOS(OS_ANYSERVER))
    {   
        _SetLocalizedName(CSIDL_COMMON_PICTURES, TEXT("shell32.dll"), IDS_SHAREDPICTURES);    
        _SetLocalizedName(CSIDL_COMMON_MUSIC, TEXT("shell32.dll"), IDS_SHAREDMUSIC);

        // Set the Sample Pictures buy URL
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetSampleMediaFolder(CSIDL_COMMON_PICTURES, &pidl)))
        {
            WCHAR szPath[MAX_PATH];
            WCHAR szDesktopIni[MAX_PATH];
            if (SUCCEEDED(SHGetPathFromIDList(pidl, szPath)) && PathCombine(szDesktopIni, szPath, L"desktop.ini"))
            {
                WritePrivateProfileString(L".ShellClassInfo", c_BuySamplePictures.szURLKey, PICTURES_BUYURL, szDesktopIni);

                // Ensure this is a system folder
                PathMakeSystemFolder(szPath);
            }

            ILFree(pidl);
        }

        // Set the Sample Music buy URL
        if (SUCCEEDED(SHGetSampleMediaFolder(CSIDL_COMMON_MUSIC, &pidl)))
        {
            WCHAR szPath[MAX_PATH];
            WCHAR szDesktopIni[MAX_PATH];
            if (SUCCEEDED(SHGetPathFromIDList(pidl, szPath)) && PathCombine(szDesktopIni, szPath, L"desktop.ini"))
            {
                WritePrivateProfileString(L".ShellClassInfo", c_BuySampleMusic.szURLKey, SAMPLEMUSIC_BUYURL, szDesktopIni);

                // Ensure this is a system folder
                PathMakeSystemFolder(szPath);
            }

            ILFree(pidl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shcombox.h ===
// shcombox.h : Shared shell comboboxEx methods

#ifndef __SHCOMBOX_H__
#define __SHCOMBOX_H__

//  COMBOITEMEX wrap with string storage.
typedef struct
{
    UINT    mask;
    INT_PTR iItem;
    TCHAR   szText[MAX_PATH] ;
    int     cchTextMax;
    int     iImage;
    int     iSelectedImage;
    int     iOverlay;
    int     iIndent;
    int     iID;  // application-specific item identifier.
    ULONG   Reserved; 
    LPARAM  lParam;

} CBXITEM, *PCBXITEM;
typedef CBXITEM CONST *PCCBXITEM;

//  ADDCBXITEMCALLBACK fAction flags
#define CBXCB_ADDING       0x00000001     // if callback returns E_ABORT, combo population aborts
#define CBXCB_ADDED        0x00000002     // callback's return value is ignored.

//  SendMessageTimeout constants
#define CBX_SNDMSG_TIMEOUT_FLAGS          SMTO_BLOCK
#define CBX_SNDMSG_TIMEOUT                15000 // milliseconds
#define CBX_SNDMSG_TIMEOUT_HRESULT        HRESULT_FROM_WIN32(ERROR_TIMEOUT)

//  Misc constants
#define NO_ITEM_NOICON_INDENT -2 // -1 to make up for the icon indent.
#define NO_ITEM_INDENT       0
#define ITEM_INDENT          1

#define LISTINSERT_FIRST    0
#define LISTINSERT_LAST     -1

#ifdef __cplusplus
extern "C"
{
#endif

//  General shell comboboxex methods
typedef HRESULT (WINAPI *LPFNPIDLENUM_CB)(LPCITEMIDLIST, void *);
typedef HRESULT (WINAPI *ADDCBXITEMCALLBACK)(ULONG fAction, PCBXITEM pItem, LPARAM lParam);

STDAPI AddCbxItemToComboBox(IN HWND hwndComboEx, IN PCCBXITEM pItem, IN INT_PTR *pnPosAdded);
STDAPI AddCbxItemToComboBoxCallback(IN HWND hwndComboEx, IN OUT PCBXITEM pItem, IN ADDCBXITEMCALLBACK pfn, IN LPARAM lParam);
STDAPI_(void) MakeCbxItem(OUT PCBXITEM pcbi, IN  LPCTSTR pszDisplayName, IN  void *pvData, IN  LPCITEMIDLIST pidlIcon, IN  INT_PTR nPos, IN  int iIndent);
STDAPI EnumSpecialItemIDs(int csidl, DWORD dwSHCONTF, LPFNPIDLENUM_CB pfn, void *pvData);

STDAPI_(HIMAGELIST) GetSystemImageListSmallIcons();

// local drive picker combo methods
STDAPI PopulateLocalDrivesCombo(IN HWND hwndComboEx, IN ADDCBXITEMCALLBACK pfn, IN LPARAM lParam);

//  helpers (note: once all dependents are brought into line using the above methods, we can eliminate
//  decl of the following:
typedef HRESULT (*LPFNRECENTENUM_CB)(IN LPCTSTR pszPath, IN BOOL fAddEntries, IN void *pvParam);

//  File Associations picker combo methods.
STDAPI PopulateFileAssocCombo(IN HWND, IN ADDCBXITEMCALLBACK, IN LPARAM);
STDAPI_(LONG) GetFileAssocComboSelItemText(IN HWND, OUT LPTSTR *ppszText);
STDAPI_(LRESULT) DeleteFileAssocComboItem(IN LPNMHDR pnmh);

#define FILEASSOCIATIONSID_ALLFILETYPES          20
#define FILEASSOCIATIONSID_FILE_PATH             1   // Go parse it.
#define FILEASSOCIATIONSID_MAX                   FILEASSOCIATIONSID_ALLFILETYPES

#ifdef __cplusplus
}
#endif

#endif __SHCOMBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shell.h ===
/*
 *  shell.h
 *
 *  Header file for shell association database management functions
 */

#include <shellapi.h>   // make sure we don't conflict
#include "winuserp.h"
#include "wowshlp.h"

#ifndef PUBLIC_ONLY

// HANDLE hInstance;               // hinstance of DLL

#define SE_ERR_FNF                      2       // ShellExec() error returns
#define SE_ERR_PNF                      3
#define SE_ERR_OOM                      8


BOOL APIENTRY RegisterShellHook(HWND, BOOL);
#endif  // closes #ifndef PUBLIC_ONLY

//****************************************************************************
// THIS INFORMATION IS PUBLIC

#define CP_WINDOWS              1004        // windows code page

BOOL APIENTRY RegenerateUserEnvironment(PVOID *pPrevEnv,
                                        BOOL bSetCurrentEnv);


int     SheGetCurDrive(VOID);
int     SheSetCurDrive(int iDrive);

int     SheFullPathA(CHAR *fname, DWORD sizpath, CHAR *buf);
int     SheGetDirA(int iDrive, CHAR *str);
int     SheChangeDirA(register CHAR *newdir);

int     SheFullPathW(WCHAR *fname, DWORD sizpath, WCHAR *buf);
int     SheGetDirW(INT iDrive, WCHAR *str);
int     SheChangeDirW(register WCHAR *newdir);

BOOL SheGetDirExW(LPWSTR lpszCurDisk, LPDWORD lpcchCurDir,LPWSTR lpszCurDir);
INT SheChangeDirExW(register WCHAR *newdir);

INT SheChangeDirExA(register CHAR *newdir);

INT SheGetPathOffsetW(LPWSTR lpszDir);

HANDLE APIENTRY InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons);
HANDLE APIENTRY InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons);

HICON APIENTRY ExtractAssociatedIconA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIcon);
HICON APIENTRY ExtractAssociatedIconW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIcon);

HICON APIENTRY ExtractAssociatedIconExA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
HICON APIENTRY ExtractAssociatedIconExW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);

WORD APIENTRY ExtractIconResInfoA(HANDLE hInst,LPSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
WORD APIENTRY ExtractIconResInfoW(HANDLE hInst,LPWSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);

VOID APIENTRY CheckEscapesA(LPSTR lpFileA, DWORD cch);
VOID APIENTRY CheckEscapesW(LPWSTR szFile, DWORD cch);

LPSTR APIENTRY SheRemoveQuotesA(LPSTR sz);
LPWSTR APIENTRY SheRemoveQuotesW(LPWSTR sz);

BOOL APIENTRY SheShortenPathA(LPSTR pPath, BOOL bShorten);
BOOL APIENTRY SheShortenPathW(LPWSTR pPath, BOOL bShorten);

BOOL SheConvertPathW(LPWSTR lpApp, LPWSTR lpFile, UINT cchCmdBuf);

DWORD ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData);

#ifndef UNICODE
#define RealShellExecute RealShellExecuteA
#define RealShellExecuteEx RealShellExecuteExA
#define SheFullPath SheFullPathA
#define SheGetDir SheGetDirA
#define SheChangeDir SheChangeDirA
#define InternalExtractIconList InternalExtractIconListA
#define ExtractAssociatedIcon ExtractAssociatedIconA
#define ExtractAssociatedIconEx ExtractAssociatedIconExA
#define ExtractIconResInfo ExtractIconResInfoA
#define CheckEscapes CheckEscapesA
#define SheRemoveQuotes SheRemoveQuotesA
#define SheShortenPath SheShortenPathA
#else
#define RealShellExecute RealShellExecuteW
#define RealShellExecuteEx RealShellExecuteExW
#define SheFullPath SheFullPathW
#define SheGetDir SheGetDirW
#define SheChangeDir SheChangeDirW
#define InternalExtractIconList InternalExtractIconListW
#define ExtractAssociatedIcon ExtractAssociatedIconW
#define ExtractAssociatedIconEx ExtractAssociatedIconExW
#define ExtractIconResInfo ExtractIconResInfoW
#define CheckEscapes CheckEscapesW
#define SheRemoveQuotes SheRemoveQuotesW
#define SheShortenPath SheShortenPathW
#endif //unicode

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shell32.inc ===
#
#  Common settings for shell32
#
C_DEFINES= $(C_DEFINES) -DMIME -DDBCS

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES= $(C_DEFINES) -DVSTF
!endif

!if !defined(TARGET_WIN95)
#  (We don't want this defined if we're building for Win95)
C_DEFINES= $(C_DEFINES) -DWINDOWS_ME
!endif

# Defines for nt sdk
C_DEFINES= $(C_DEFINES) -D_NTSDK 

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

# NTRAID 135202 (reinerf) - I promised bryant that I would fix these
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

INCLUDES= \
    $(INCLUDES);                \
    $(PROJECT_ROOT)\shell32;    \
    $(PRINTSCAN_INC_PATH);      \
    $(INETCORE_INC_PATH);       \
    $(DS_INC_PATH);             \
    $(BASE_INC_PATH);           \
    $(TERMSRV_INC_PATH);        \
    $(NET_INC_PATH);            \
    $(ADMIN_INC_PATH);          \
    $(WINDOWS_INC_PATH)\duser

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED= $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

USE_STATIC_ATL=1

CONDITIONAL_INCLUDES= \
    $(CONDITIONAL_INCLUDES) \
    filter.h                \
    rcids.h                 \
    tracker.h               \
    ver.h                   \
    unicpp\clsobj.tbl       \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shelldlg.h ===
#define ABOUTDLG           100
#define IDD_APPNAME        101
//#define IDD_CONFIG         102
#define IDD_CONVTITLE      103
#define IDD_CONVENTIONAL   104
//#define IDD_EMSFREE        105
//#define IDD_SDTEXT         106
//#define IDD_SDUSING        107
#define IDD_USERNAME       108
#define IDD_COMPANYNAME    109
#define IDD_SERIALNUM      110
#define IDD_ICON           111
#define IDD_VERSION        112
//#define IDD_EMSTEXT        113
#define IDD_OTHERSTUFF     115
#define IDD_DOSVER         116
#define IDD_PROCESSOR      117
#define IDD_PRODUCTID      118
#define IDD_OEMID          119

#define WINBMP             130

#define FINDEXEDLG         200
#define IDD_BROWSE             201
#define IDD_PATH               203
#define IDD_HELP               204
#define IDD_TEXT1              205
#define IDD_TEXT2              206

#define DLG_BROWSE             300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shelllnk.h ===
#ifndef __SHLINK_H__
#define __SHLINK_H__

#include <trkwks.h>
#include <rpcasync.h>
#include <filter.h>
#include "cowsite.h"

class CDarwinContextMenuCB;
class CTracker;

class CShellLink : public IShellLinkA,
                   public IShellLinkW,
                   public IPersistStream,
                   public IPersistFile,
                   public IShellExtInit,
                   public IContextMenu3,
                   public IDropTarget,
                   public IQueryInfo,
                   public IShellLinkDataList,
                   public IExtractIconA,
                   public IExtractIconW,
                   public IExtractImage2,
                   public IPersistPropertyBag,
                   public IServiceProvider,
                   public IFilter,
                   public CObjectWithSite,
                   public ICustomizeInfoTip
{
    friend CTracker;
    friend CDarwinContextMenuCB;

public:
    CShellLink();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IShellLinkA methods
    STDMETHOD(GetPath)(LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD flags);
    STDMETHOD(SetPath)(LPCSTR pszFile);
    //STDMETHOD(GetIDList)(LPITEMIDLIST *ppidl);
    //STDMETHOD(SetIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(GetDescription)(LPSTR pszName, int cchMaxName);
    STDMETHOD(SetDescription)(LPCSTR pszName);
    STDMETHOD(GetWorkingDirectory)(LPSTR pszDir, int cchMaxPath);
    STDMETHOD(SetWorkingDirectory)(LPCSTR pszDir);
    STDMETHOD(GetArguments)(LPSTR pszArgs, int cchMaxPath);
    STDMETHOD(SetArguments)(LPCSTR pszArgs);
    //STDMETHOD(GetHotkey)(WORD *pwHotkey);
    //STDMETHOD(SetHotkey)(WORD wHotkey);
    //STDMETHOD(GetShowCmd)(int *piShowCmd);
    //STDMETHOD(SetShowCmd)(int iShowCmd);
    STDMETHOD(GetIconLocation)(LPSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHOD(SetIconLocation)(LPCSTR pszIconPath, int iIcon);
    //STDMETHOD(Resolve)(HWND hwnd, DWORD dwResolveFlags);
    STDMETHOD(SetRelativePath)(LPCSTR pszPathRel, DWORD dwReserved);
    
    // IShellLinkW
    STDMETHOD(GetPath)(LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD fFlags);
    STDMETHOD(GetIDList)(LPITEMIDLIST *ppidl);
    STDMETHOD(SetIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(GetDescription)(LPWSTR pszName, int cchMaxName);
    STDMETHOD(SetDescription)(LPCWSTR pszName);
    STDMETHOD(GetWorkingDirectory)(LPWSTR pszDir, int cchMaxPath);
    STDMETHOD(SetWorkingDirectory)(LPCWSTR pszDir);
    STDMETHOD(GetArguments)(LPWSTR pszArgs, int cchMaxPath);
    STDMETHOD(SetArguments)(LPCWSTR pszArgs);
    STDMETHOD(GetHotkey)(WORD *pwHotKey);
    STDMETHOD(SetHotkey)(WORD wHotkey);
    STDMETHOD(GetShowCmd)(int *piShowCmd);
    STDMETHOD(SetShowCmd)(int iShowCmd);
    STDMETHOD(GetIconLocation)(LPWSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHOD(SetIconLocation)(LPCWSTR pszIconPath, int iIcon);
    STDMETHOD(SetRelativePath)(LPCWSTR pszPathRel, DWORD dwReserved);
    STDMETHOD(Resolve)(HWND hwnd, DWORD dwResolveFlags);
    STDMETHOD(SetPath)(LPCWSTR pszFile);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();

    // IPersistStream
    STDMETHOD(Load)(IStream *pstm);
    STDMETHOD(Save)(IStream *pstm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // IPersistFile
    STDMETHOD(Load)(LPCOLESTR pwszFile, DWORD grfMode);
    STDMETHOD(Save)(LPCOLESTR pwszFile, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pwszFile);
    STDMETHOD(GetCurFile)(LPOLESTR *lplpszFileName);

    // IPersistPropertyBag
    STDMETHOD(Save)(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    STDMETHOD(Load)(IPropertyBag* pPropBag, IErrorLog* pErrorLog);
    STDMETHOD(InitNew)(void);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    // IContextMenu3
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO piciIn);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT wFlags, UINT *pmf, LPSTR pszName, UINT cchMax);
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *lResult);

    // IDropTarget
    STDMETHOD(DragEnter)(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IQueryInfo
    STDMETHOD(GetInfoTip)(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHOD(GetInfoFlags)(LPDWORD pdwFlags);

    // IShellLinkDataList
    STDMETHOD(AddDataBlock)(void *pdb);
    STDMETHOD(CopyDataBlock)(DWORD dwSig, void **ppdb);
    STDMETHOD(RemoveDataBlock)(DWORD dwSig);
    STDMETHOD(GetFlags)(LPDWORD pdwFlags);
    STDMETHOD(SetFlags)(DWORD dwFlags);
    
    // IExtractIconA
    STDMETHOD(GetIconLocation)(UINT uFlags,LPSTR szIconFile,UINT cchMax,int *piIndex,UINT * pwFlags);
    STDMETHOD(Extract)(LPCSTR pszFile,UINT nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons);

    // IExtractIconW
    STDMETHOD(GetIconLocation)(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

    // IExtractImage
    STDMETHOD (GetLocation)(LPWSTR pszPathBuffer, DWORD cch, DWORD * pdwPriority, const SIZE * prgSize,
                            DWORD dwRecClrDepth, DWORD *pdwFlags);
    STDMETHOD (Extract)(HBITMAP *phBmpThumbnail);

    // IExtractImage2
    STDMETHOD (GetDateStamp)(FILETIME *pftDateStamp);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppv);

    // IFilter
    STDMETHOD(Init)(ULONG grfFlags, ULONG cAttributes, const FULLPROPSPEC *aAttributes, ULONG *pFlags);
    STDMETHOD(GetChunk)(STAT_CHUNK *pStat);
    STDMETHOD(GetText)(ULONG *pcwcBuffer, WCHAR *awcBuffer);
    STDMETHOD(GetValue)(PROPVARIANT **ppPropValue);
    STDMETHOD(BindRegion)(FILTERREGION origPos, REFIID riid, void **ppunk);

    //*** IObjectWithSite ***
    //STDMETHOD(SetSite)(IUnknown *punkSite);
    //STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

    // ICustomizeInfoTip
    STDMETHODIMP SetPrefixText(LPCWSTR pszPrefix);
    STDMETHODIMP SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid);

    // public non interface members
    void   _AddExtraDataSection(DATABLOCK_HEADER *pdbh);
    void   _RemoveExtraDataSection(DWORD dwSig);

protected:
    HRESULT _Resolve(HWND hwnd, DWORD dwResolveFlags, DWORD dwTracker);

private:
    ~CShellLink();

    static DWORD CALLBACK _InvokeThreadProc(void *pv);
    static DWORD CALLBACK _VerifyPathThreadProc(void *pv);

    void _ResetPersistData();
    BOOL _GetRelativePath(LPTSTR pszPath);

    HRESULT _SetPIDLPath(LPCITEMIDLIST pidl, LPCTSTR pszPath, BOOL bUpdateTrackingData);
    HRESULT _SetSimplePIDL(LPCTSTR pszPath);
    void _UpdateWorkingDir(LPCTSTR pszPath);

    PLINKINFO _GetLinkInfo(LPCTSTR pszPath);
    void _FreeLinkInfo();
    HRESULT _GetFindDataAndTracker(LPCTSTR pszPath);
    void _ClearTrackerData();

    BOOL _SetFindData(const WIN32_FIND_DATA *pfd);
    void _GetFindData(WIN32_FIND_DATA *pfd);
    BOOL _IsEqualFindData(const WIN32_FIND_DATA *pfd);

    HRESULT _ResolveIDList(HWND hwnd, DWORD dwResolveFlags);
    HRESULT _ResolveLinkInfo(HWND hwnd, DWORD dwResolveFlags, LPTSTR pszPath, DWORD *pfifFlags);
    HRESULT _ResolveRemovable(HWND hwnd, LPCTSTR pszPath);
    BOOL    _ShouldTryRemovable(HRESULT hr, LPCTSTR pszPath);
    void    _SetIDListFromEnvVars();
    BOOL    _ResolveDarwin(HWND hwnd, DWORD dwResolveFlags, HRESULT *phr);

    HRESULT _ResolveLogo3Link(HWND hwnd, DWORD dwResolveFlags);
    HRESULT _CheckForLinkBlessing(LPCTSTR *ppszPathIn);
    HRESULT BlessLink(LPCTSTR *ppszPath, DWORD dwSignature);
    BOOL _EncodeSpecialFolder();
    void _DecodeSpecialFolder();
    HRESULT _SetRelativePath(LPCTSTR pszRelSource);
    HRESULT _UpdateTracker();
    HRESULT _LoadFromFile(LPCTSTR pszPath);
    HRESULT _LoadFromPIF(LPCTSTR szPath);
    HRESULT _SaveToFile(LPTSTR pszPathSave, BOOL fRemember);
    HRESULT _SaveAsLink(LPCTSTR szPath);
    HRESULT _SaveAsPIF(LPCTSTR pszPath, BOOL fPath);
    BOOL _GetWorkingDir(LPTSTR pszDir);
    HRESULT _GetUIObject(HWND hwnd, REFIID riid, void **ppvOut);
    HRESULT _ShortNetTimeout();

    HRESULT _CreateDarwinContextMenu(HWND hwnd,IContextMenu **pcmOut);
    HRESULT _CreateDarwinContextMenuForPidl(HWND hwnd, LPCITEMIDLIST pidlTarget, IContextMenu **pcmOut);
    HRESULT _InvokeCommandAsync(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InitDropTarget();
    HRESULT _GetExtractIcon(REFIID riid, void **ppvOut);
    HRESULT _InitExtractIcon();
    HRESULT _InitExtractImage();
    BOOL _GetExpandedPath(LPTSTR psz, DWORD cch);
    HRESULT _SetField(LPTSTR *ppszField, LPCWSTR pszValueW);
    HRESULT _SetField(LPTSTR *ppszField, LPCSTR  pszValueA);
    HRESULT _GetField(LPCTSTR pszField, LPWSTR pszValueW, int cchValue);
    HRESULT _GetField(LPCTSTR pszField, LPSTR  pszValueA, int cchValue);
    int _IsOldDarwin(LPCTSTR pszPath);
    HRESULT _SetPathOldDarwin(LPCTSTR pszPath);
    HRESULT _CreateProcessWithShimLayer(HANDLE hData, BOOL fAllowAsync);
    HRESULT _MaybeAddShim(IBindCtx **ppbcRelease);
    HRESULT _UpdateIconFromExpIconSz();

    //
    //  Inner class to manage the context menu of the shortcut target.
    //  We do this to ensure that the target's context menu gets a proper
    //  SetSite call so it can contact the containing shortcut.
    //
    class TargetContextMenu {
    public:
        operator IUnknown*() { return _pcmTarget; }

        // WARNING!  Use only as an output pointer
        IContextMenu **GetOutputPtr() { return &_pcmTarget; }

        HRESULT QueryContextMenu(IShellLink *outer, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
        {
            IUnknown_SetSite(_pcmTarget, outer);
            HRESULT hr = _pcmTarget->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
            IUnknown_SetSite(_pcmTarget, NULL);
            return hr;
        }

        HRESULT InvokeCommand(IShellLink *outer, LPCMINVOKECOMMANDINFO pici)
        {
            IUnknown_SetSite(_pcmTarget, outer);
            HRESULT hr = _pcmTarget->InvokeCommand(pici);
            IUnknown_SetSite(_pcmTarget, NULL);
            return hr;
        }

        HRESULT HandleMenuMsg2(IShellLink *outer, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

        // This doesn't need to be wrapped in a SetSite (yet)
        UINT GetCommandString(IShellLink *outer, UINT_PTR idCmd, UINT wFlags, UINT *pmf, LPSTR pszName, UINT cchMax)
        {
            HRESULT hr = _pcmTarget->GetCommandString(idCmd, wFlags, pmf, pszName, cchMax);
            return hr;
        }

        // This doesn't need to be wrapped in a SetSite (yet)
        UINT GetMenuIndexForCanonicalVerb(IShellLink *outer, HMENU hMenu, UINT idCmdFirst, LPCWSTR pwszVerb)
        {
            UINT ui = ::GetMenuIndexForCanonicalVerb(hMenu, _pcmTarget, idCmdFirst, pwszVerb);
            return ui;
        }

        void AtomicRelease()
        {
            ATOMICRELEASE(_pcmTarget);
        }

        ~TargetContextMenu()
        {
            IUnknown_SetSite(_pcmTarget, NULL);
            AtomicRelease();
        }

    private:
        IContextMenu        *_pcmTarget;    // stuff for IContextMenu
    };

    // Data Members
    LONG                _cRef;              // Ref Count
    BOOL                _bDirty;            // something has changed
    LPTSTR              _pszCurFile;        // current file from IPersistFile
    LPTSTR              _pszRelSource;      // overrides pszCurFile in relative tracking

    TargetContextMenu   _cmTarget;          // stuff for IContextMenu
    CDarwinContextMenuCB *_pcbDarwin;

    UINT                _indexMenuSave;
    UINT                _idCmdFirstSave;
    UINT                _idCmdLastSave;
    UINT                _uFlagsSave;

    // IDropTarget specific
    IDropTarget*        _pdtSrc;        // IDropTarget of link source (unresolved)
    DWORD               _grfKeyStateLast;

    IExtractIconW       *_pxi;          // for IExtractIcon support
    IExtractIconA       *_pxiA;
    IExtractImage       *_pxthumb;
    UINT                _gilFlags;      // ::GetIconLocation() flags

    // persistant data

    LPITEMIDLIST        _pidl;          // may be NULL
    PLINKINFO           _pli;           // may be NULL

    LPTSTR              _pszName;       // title on short volumes
    LPTSTR              _pszRelPath;
    LPTSTR              _pszWorkingDir;
    LPTSTR              _pszArgs;
    LPTSTR              _pszIconLocation;

    LPDBLIST            _pExtraData;    // extra data to preserve for future compatibility

    CTracker            *_ptracker;

    WORD                _wOldHotkey;   // to broadcast hotkey changes
    WORD                _wAllign;
    SHELL_LINK_DATA     _sld;
    BOOL                _bExpandedIcon;  // have we already tried to update the icon from the env variable for this instance?

    // IFilter stuff
    UINT _iChunkIndex;
    UINT _iValueIndex;

    LPWSTR _pszPrefix;
};

DECLARE_INTERFACE_(ISLTracker, IUnknown)
{
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Resolve)(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions) PURE;
    STDMETHOD(GetIDs)(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid) PURE;
    STDMETHOD(CancelSearch)() PURE;
};

//  This class implements the object ID-based link tracking (new to NT5).

class CTracker : public ISLTracker
{
public:
    //  IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  ISLTracker
    STDMETHODIMP Resolve(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions);
    STDMETHODIMP GetIDs(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid);

    CTracker(CShellLink *psl) : _psl(psl)
    {
        _fLoadedAtLeastOnce = _fLoaded = _fDirty = FALSE;
        _fCritsecInitialized = _fMendInProgress = _fUserCancelled = FALSE;
        _hEvent = NULL;
        _pRpcAsyncState = NULL;
    };

    ~CTracker()
    {
        if (_fCritsecInitialized)
        {
            DeleteCriticalSection(&_cs);
            _fCritsecInitialized = FALSE;
        }

        if (NULL != _pRpcAsyncState)
        {
            delete _pRpcAsyncState;
            _pRpcAsyncState = NULL;
        }

        if (NULL != _hEvent)
        {
            CloseHandle(_hEvent);
            _hEvent = NULL;
        }
    }

    // Initialization.

    HRESULT     InitFromHandle(const HANDLE hFile, const TCHAR* ptszFile);
    HRESULT     InitNew();
    void        UnInit();

    // Load and Save

    HRESULT Load(BYTE *pb, ULONG cb);
    ULONG GetSize()
    {
        return sizeof(DWORD)   // To save the length
             + sizeof(DWORD) // To save flags
             + sizeof(_mcidLast) + sizeof(_droidLast) + sizeof(_droidBirth);
    }

    void Save(BYTE *pb, ULONG cb);

    // Search for a file

    HRESULT Search(const DWORD dwTickCountDeadline,
                    const WIN32_FIND_DATA *pfdIn,
                    WIN32_FIND_DATA *pfdOut,
                    UINT uShlinkFlags,
                    DWORD TrackerRestrictions);
    STDMETHODIMP CancelSearch(); // Also in ISLTracker

    BOOL IsDirty()
    {
        return _fDirty;
    }

    BOOL IsLoaded()
    {
        return _fLoaded;
    }

    BOOL WasLoadedAtLeastOnce()
    {
        return _fLoadedAtLeastOnce;
    }

private:
    // Call this from either InitNew or Load
    HRESULT     InitRPC();

    BOOL                    _fDirty:1;

    // TRUE => InitNew has be called, but neither InitFromHandle nor Load
    // has been called since.
    BOOL                    _fLoaded:1;

    // TRUE => _cs has been intialized and must be deleted on destruction.
    BOOL                    _fCritsecInitialized:1;

    // TRUE => An async call to LnkMendLink is active
    BOOL                    _fMendInProgress:1;

    BOOL                    _fUserCancelled:1;

    // Event used for the async RPC call LnkMendLink, and a critsec to
    // coordinate the search thread and UI thread.

    HANDLE                  _hEvent;
    CRITICAL_SECTION        _cs;

    // Either InitFromHandle or Load has been called at least once, though
    // InitNew may have been called since.
    BOOL                    _fLoadedAtLeastOnce:1;
    CShellLink             *_psl;
    PRPC_ASYNC_STATE        _pRpcAsyncState;

    CMachineId              _mcidLast;
    CDomainRelativeObjId    _droidLast;
    CDomainRelativeObjId    _droidBirth;
};

#endif //__SHLINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shelllnk.cpp ===
#include "shellprv.h"
#include <shlobjp.h>
#include "shelllnk.h"

#include "datautil.h"
#include "ids.h"        // For String Resource identifiers
#include "pif.h"        // For manipulating PIF files
#include "trayp.h"      // For  WMTRAY_* messages 
#include "views.h"      // For FSIDM_OPENPRN
#include "os.h"         // For Win32MoveFile ...
#include "util.h"       // For GetMenuIndexForCanonicalVerb
#include "defcm.h"      // For CDefFolderMenu_Create2Ex
#include "uemapp.h"
#include <filterr.h>
#include "folder.h"
#include <msi.h>
#include <msip.h>
#include "treewkcb.h"

#define GetLastHRESULT()    HRESULT_FROM_WIN32(GetLastError())

//  Flags for FindInFilder.fifFlags
//
// The drive referred to by the shortcut does not exist.
// Let pTracker search for it, but do not perform an old-style
// ("downlevel") search of our own.

#define FIF_NODRIVE     0x0001


// Only if the file we found scores more than this number do we 
// even show the user this result, any thing less than this would
// be too shameful of us to show the user. 
#define MIN_SHOW_USER_SCORE     10

// magic score that stops searches and causes us not to warn
// whe the link is actually found
#define MIN_NO_UI_SCORE         40

// If no User Interface will be provided during the search,
// then do not search more than 3 seconds.
#define NOUI_SEARCH_TIMEOUT     (3 * 1000)

// If a User Interface will be provided during the search,
// then search as much as 2 minutes.
#define UI_SEARCH_TIMEOUT       (120 * 1000)

#define LNKTRACK_HINTED_UPLEVELS 4  // directory levels to search upwards from last know object locn
#define LNKTRACK_DESKTOP_DOWNLEVELS 4 // infinite downlevels
#define LNKTRACK_ROOT_DOWNLEVELS 4  // levels down from root of fixed disks
#define LNKTRACK_HINTED_DOWNLEVELS 4 // levels down at each level on way up during hinted uplevels



class CLinkResolver : public CBaseTreeWalkerCB
{
public:
    CLinkResolver(CTracker *ptrackerobject, const WIN32_FIND_DATA *pofd, UINT dwResolveFlags, DWORD TrackerRestrictions, DWORD fifFlags);

    int Resolve(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszCurFile);
    void GetResult(LPTSTR psz, UINT cch);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

private:
    ~CLinkResolver();

    static DWORD CALLBACK _ThreadStartCallBack(void *pv);
    static DWORD CALLBACK _SearchThreadProc(void *pv);
    static BOOL_PTR CALLBACK _DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    void _HeuristicSearch();
    void _InitDlg(HWND hDlg);
    DWORD _Search();
    DWORD _GetTimeOut();
    int _ScoreFindData(const WIN32_FIND_DATA *pfd);
    HRESULT _ProcessFoundFile(LPCTSTR pszPath, WIN32_FIND_DATAW * pwfdw);
    BOOL _SearchInFolder(LPCTSTR pszFolder, int cLevels);
    HRESULT _InitWalkObject();

    HANDLE _hThread;
    DWORD _dwTimeOutDelta;
    HWND  _hDlg;
    UINT_PTR _idtDelayedShow;           // timer for delayed-show
    DWORD _fifFlags;                    // FIF_ flags
    CTracker *_ptracker;                // Implements ObjectID-based link tracking
    DWORD _TrackerRestrictions;         // Flags from the TrkMendRestrictions enumeration

    DWORD  _dwSearchFlags;
    int    _iFolderBonus;
    
    WCHAR  _wszSearchSpec[64];          // holds file extension filter for search
    LPCWSTR _pwszSearchSpec;            // NULL for folders
    IShellTreeWalker *_pstw;

    BOOL                _fFindLnk;      // are we looking for a lnk file?
    DWORD               _dwMatch;       // must match attributes
    WIN32_FIND_DATA     _ofd;           // original find data

    DWORD               _dwTimeLimit;   // don't go past this

    BOOL                _bContinue;     // keep going

    LPCTSTR             _pszSearchOrigin;       // path where current search originated, to help avoid dup searchs
    LPCTSTR             _pszSearchOriginFirst;  // path where search originated, to help avoid dup searchs

    int                 _iScore;        // score for current item
    WIN32_FIND_DATA     _fdFound;       // results

    WIN32_FIND_DATA     _sfd;           // to save stack space 
    UINT                _dwResolveFlags;        // SLR_ flags

    TCHAR               _szSearchStart[MAX_PATH];
};


// NOTE:(seanf) This is sleazy - This fn is defined in shlobj.h, but only if urlmon.h
// was included first. Rather than monkey with the include order in
// shellprv.h, we'll duplicate the prototype here, where SOFTDISTINFO
// is now defined.
SHDOCAPI_(DWORD) SoftwareUpdateMessageBox(HWND hWnd,
                                           LPCWSTR pszDistUnit,
                                           DWORD dwFlags,
                                           LPSOFTDISTINFO psdi);



// The following strings are used to support the shell link set path hack that
// allows us to bless links for Darwin without exposing stuff from IShellLinkDataList

#define DARWINGUID_TAG TEXT("::{9db1186e-40df-11d1-aa8c-00c04fb67863}:")
#define LOGO3GUID_TAG  TEXT("::{9db1186f-40df-11d1-aa8c-00c04fb67863}:")

#define TF_DEBUGLINKCODE 0x00800000

EXTERN_C BOOL IsFolderShortcut(LPCTSTR pszName);

class CDarwinContextMenuCB : public IContextMenuCB
{
public:
    CDarwinContextMenuCB() : _cRef(1) { }

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv) 
    {
        static const QITAB qit[] = {
            QITABENT(CDarwinContextMenuCB, IContextMenuCB), // IID_IContextMenuCB
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }

    STDMETHOD_(ULONG,AddRef)() 
    {
        return InterlockedIncrement(&_cRef);
    }

    STDMETHOD_(ULONG,Release)() 
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

    // IContextMenuCB
    STDMETHOD(CallBack)(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:

    void SetProductCodeFromDarwinID(LPCTSTR szDarwinID)
    {
        MsiDecomposeDescriptor(szDarwinID, _szProductCode, NULL, NULL, NULL);
    }

private:
    LONG _cRef;
    TCHAR _szProductCode[MAX_PATH];
};

CShellLink::CShellLink() : _cRef(1)
{
    _ptracker = new CTracker(this);
    _ResetPersistData();
}

CShellLink::~CShellLink()
{
    _ResetPersistData();        // free all data

    if (_pcbDarwin)
    {
        _pcbDarwin->Release(); 
    }

    if (_pdtSrc)
    {
        _pdtSrc->Release();
    }

    if (_pxi)
    {
        _pxi->Release();
    }

    if (_pxiA)
    {
        _pxiA->Release();
    }

    if (_pxthumb)
    {
        _pxthumb->Release();
    }

    Str_SetPtr(&_pszCurFile, NULL);
    Str_SetPtr(&_pszRelSource, NULL);

    if (_ptracker)
    {
        delete _ptracker;
    }
}

// Private interface used for testing

/* 7c9e512f-41d7-11d1-8e2e-00c04fb9386d */
EXTERN_C const IID IID_ISLTracker = { 0x7c9e512f, 0x41d7, 0x11d1, {0x8e, 0x2e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d} };

STDMETHODIMP CShellLink::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellLink, IShellLinkA),
        QITABENT(CShellLink, IShellLinkW),
        QITABENT(CShellLink, IPersistFile),
        QITABENT(CShellLink, IPersistStream),
        QITABENT(CShellLink, IShellExtInit),
        QITABENTMULTI(CShellLink, IContextMenu, IContextMenu3),
        QITABENTMULTI(CShellLink, IContextMenu2, IContextMenu3),
        QITABENT(CShellLink, IContextMenu3),
        QITABENT(CShellLink, IDropTarget),
        QITABENT(CShellLink, IExtractIconA),
        QITABENT(CShellLink, IExtractIconW),
        QITABENT(CShellLink, IShellLinkDataList),
        QITABENT(CShellLink, IQueryInfo),
        QITABENT(CShellLink, IPersistPropertyBag),
        QITABENT(CShellLink, IObjectWithSite),
        QITABENT(CShellLink, IServiceProvider),
        QITABENT(CShellLink, IFilter),
        QITABENT(CShellLink, IExtractImage2),
        QITABENTMULTI(CShellLink, IExtractImage, IExtractImage2),
        QITABENT(CShellLink, ICustomizeInfoTip),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr) && (IID_ISLTracker == riid) && _ptracker)
    {
        // ISLTracker is a private test interface, and isn't implemented
        *ppvObj = SAFECAST(_ptracker, ISLTracker*);
        _ptracker->AddRef();
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CShellLink::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

void CShellLink::_ClearTrackerData()
{
    if (_ptracker)
        _ptracker->InitNew();
}

void CShellLink::_ResetPersistData()
{
    Pidl_Set(&_pidl, NULL);

    _FreeLinkInfo();
    _ClearTrackerData();

    Str_SetPtr(&_pszName, NULL);
    Str_SetPtr(&_pszRelPath, NULL);
    Str_SetPtr(&_pszWorkingDir, NULL);
    Str_SetPtr(&_pszArgs, NULL);
    Str_SetPtr(&_pszIconLocation, NULL);
    Str_SetPtr(&_pszPrefix, NULL);

    if (_pExtraData)
    {
        SHFreeDataBlockList(_pExtraData);
        _pExtraData = NULL;
    }

    // init data members.  all others are zero inited
    memset(&_sld, 0, sizeof(_sld));

    _sld.iShowCmd = SW_SHOWNORMAL;

    _bExpandedIcon = FALSE;
}

STDMETHODIMP_(ULONG) CShellLink::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

#ifdef DEBUG
void DumpPLI(PCLINKINFO pli)
{
    DebugMsg(DM_TRACE, TEXT("DumpPLI:"));
    if (pli)
    {
        const void *p;
        if (GetLinkInfoData(pli, LIDT_VOLUME_SERIAL_NUMBER, &p))
            DebugMsg(DM_TRACE, TEXT("\tSerial #\t%8X"), *(DWORD *)p);

        if (GetLinkInfoData(pli, LIDT_DRIVE_TYPE, &p))
            DebugMsg(DM_TRACE, TEXT("\tDrive Type\t%d"), *(DWORD *)p);

        if (GetLinkInfoData(pli, LIDT_VOLUME_LABEL, &p))
            DebugMsg(DM_TRACE, TEXT("\tLabel\t%hs"), p);

        if (GetLinkInfoData(pli, LIDT_LOCAL_BASE_PATH, &p))
            DebugMsg(DM_TRACE, TEXT("\tBase Path\t%hs"), p);

        if (GetLinkInfoData(pli, LIDT_NET_RESOURCE, &p))
            DebugMsg(DM_TRACE, TEXT("\tNet Res\t%hs"), p);

        if (GetLinkInfoData(pli, LIDT_COMMON_PATH_SUFFIX, &p))
            DebugMsg(DM_TRACE, TEXT("\tPath Sufix\t%hs"), p);
    }
}
#else
#define DumpPLI(p)
#endif

// Compare _sld to a WIN32_FIND_DATA

BOOL CShellLink::_IsEqualFindData(const WIN32_FIND_DATA *pfd)
{
    return (pfd->dwFileAttributes == _sld.dwFileAttributes)                       &&
           (CompareFileTime(&pfd->ftCreationTime, &_sld.ftCreationTime) == 0)     &&
           (CompareFileTime(&pfd->ftLastWriteTime, &_sld.ftLastWriteTime) == 0)   &&
           (pfd->nFileSizeLow == _sld.nFileSizeLow);
}

BOOL CShellLink::_SetFindData(const WIN32_FIND_DATA *pfd)
{
    if (!_IsEqualFindData(pfd))
    {
        _sld.dwFileAttributes = pfd->dwFileAttributes;
        _sld.ftCreationTime = pfd->ftCreationTime;
        _sld.ftLastAccessTime = pfd->ftLastAccessTime;
        _sld.ftLastWriteTime = pfd->ftLastWriteTime;
        _sld.nFileSizeLow = pfd->nFileSizeLow;
        _bDirty = TRUE;
        return TRUE;
    }
    return FALSE;
}

// make a copy into LocalAlloc memory, to avoid having to load linkinfo.dll
// just to call DestroyLinkInfo()

PLINKINFO CopyLinkInfo(PCLINKINFO pcliSrc)
{
    ASSERT(pcliSrc);
    DWORD dwSize = pcliSrc->ucbSize; // size of this thing
    PLINKINFO pli = (PLINKINFO)LocalAlloc(LPTR, dwSize);      // make a copy
    if (pli)
        CopyMemory(pli, pcliSrc, dwSize);
    return  pli;
}

void CShellLink::_FreeLinkInfo()
{
    if (_pli)
    {
        LocalFree((HLOCAL)_pli);
        _pli = NULL;
    }
}

// creates a LINKINFO _pli from a given file name
//
// returns:
//
//      success, pointer to the LINKINFO
//      NULL     this link does not have LINKINFO

PLINKINFO CShellLink::_GetLinkInfo(LPCTSTR pszPath)
{
    // this bit disables LINKINFO tracking on a per link basis, this is set
    // externally by admins to make links more "transparent"
    if (!(_sld.dwFlags & SLDF_FORCE_NO_LINKINFO))
    {
        if (pszPath)
        {
            PLINKINFO pliNew;
            if (CreateLinkInfo(pszPath, &pliNew))
            {
                // avoid marking the link dirty if the linkinfo
                // blocks are the same, comparing the bits
                // gives us an accurate positive test
                if (!_pli || (_pli->ucbSize != pliNew->ucbSize) || memcmp(_pli, pliNew, pliNew->ucbSize))
                {
                    _FreeLinkInfo();

                    _pli = CopyLinkInfo(pliNew);
                    _bDirty = TRUE;
                }

                DumpPLI(_pli);

                DestroyLinkInfo(pliNew);
            }
        }
    }
    return _pli;
}

void PathGetRelative(LPTSTR pszPath, LPCTSTR pszFrom, DWORD dwAttrFrom, LPCTSTR pszRel)
{
    TCHAR szRoot[MAX_PATH];

    StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszFrom);
    if (!(dwAttrFrom & FILE_ATTRIBUTE_DIRECTORY))
    {
        PathRemoveFileSpec(szRoot);
    }

    ASSERT(PathIsRelative(pszRel));

    PathCombine(pszPath, szRoot, pszRel);
}

//
// update the working dir to match changes being made to the link target
//
void CShellLink::_UpdateWorkingDir(LPCTSTR pszNew)
{
    TCHAR szOld[MAX_PATH], szPath[MAX_PATH];

    if ((_sld.dwFlags & SLDF_HAS_DARWINID)  ||
        (_pszWorkingDir == NULL)            ||
        (_pszWorkingDir[0] == 0)            ||
        StrChr(_pszWorkingDir, TEXT('%'))   ||
        (_pidl == NULL)                     ||
        !SHGetPathFromIDList(_pidl, szOld)  ||
        (lstrcmpi(szOld, pszNew) == 0))
    {
        return;
    }

    if (PathRelativePathTo(szPath, szOld, _sld.dwFileAttributes, _pszWorkingDir, FILE_ATTRIBUTE_DIRECTORY))
    {
        PathGetRelative(szOld, pszNew, GetFileAttributes(pszNew), szPath);        // get result is szOld

        if (PathIsDirectory(szOld))
        {
            DebugMsg(DM_TRACE, TEXT("working dir updated to %s"), szOld);
            Str_SetPtr(&_pszWorkingDir, szOld);
            _bDirty = TRUE;
        }
    }
}

HRESULT CShellLink::_SetSimplePIDL(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;
    WIN32_FIND_DATA fd = {0};
    fd.dwFileAttributes = _sld.dwFileAttributes;
            
    HRESULT hr = SHSimpleIDListFromFindData(pszPath, &fd, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = _SetPIDLPath(pidl, NULL, FALSE);
        ILFree(pidl);
    }
    return hr;
}

// set the pidl either based on a new pidl or a path
// this will set the dirty flag if this info is different from the current
//
// in:
//      pidlNew         if non-null, use as new PIDL for link
//      pszPath         if non-null, create a pidl for this and set it
//
// returns:
//      hr based on success
//      FAILED() codes on failure (parsing failure for path case)

HRESULT CShellLink::_SetPIDLPath(LPCITEMIDLIST pidl, LPCTSTR pszPath, BOOL bUpdateTrackingData)
{
    LPITEMIDLIST pidlCreated;
    HRESULT hr;

    if (pszPath && !pidl)
    {
        // path as input. this can map the pidl into the alias form (relative to
        // ::{my docs} for example) but allow link to override that behavior
        ILCFP_FLAGS ilcfpFlags = (_sld.dwFlags & SLDF_NO_PIDL_ALIAS) ? ILCFP_FLAG_NO_MAP_ALIAS : ILCFP_FLAG_NORMAL;

        hr = ILCreateFromPathEx(pszPath, NULL, ilcfpFlags, &pidlCreated, NULL);
        
        // Force a SHGetPathFromIDList later so that the linkinfo will not get confused by letter case changing
        // as in c:\Winnt\System32\App.exe versus C:\WINNT\system32\app.exe
        pszPath = NULL;
    }
    else if (!pszPath && pidl)
    {
        // pidl as input, make copy that we will keep
        hr = SHILClone(pidl, &pidlCreated);
    }
    else if (!pszPath && !pidl)
    {
        pidlCreated = NULL;
        // setting to empty
        hr = S_OK;
    }
    else
    {
        // can't set path and pidl at the same time
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // this data needs to be kept in sync with _pidl
        _RemoveExtraDataSection(EXP_SPECIAL_FOLDER_SIG);

        if (pidlCreated)
        {
            TCHAR szPath[MAX_PATH];

            if (!_pidl || !ILIsEqual(_pidl, pidlCreated))
            {
                // new pidl
                _bDirty = TRUE;
            }

            if (!pszPath && SHGetPathFromIDList(pidlCreated, szPath))
            {
                pszPath = szPath;
            }

            if (pszPath)
            {
                // needs old _pidl to work
                _UpdateWorkingDir(pszPath);
            }

            ILFree(_pidl);
            _pidl = pidlCreated;

            if (pszPath)
            {
                if (bUpdateTrackingData)
                {
                    // this is a file/folder, get tracking info (ignore failures)
                    _GetLinkInfo(pszPath);              // the LinkInfo (_pli)
                    _GetFindDataAndTracker(pszPath);    // tracker & find data
                }
            }
            else
            {
                // not a file, clear the tracking info
                WIN32_FIND_DATA fd = {0};
                _SetFindData(&fd);
                _ClearTrackerData();
                _FreeLinkInfo();
            }
        }
        else
        {
            // clear out the contents of the link
            _ResetPersistData();
            _bDirty = TRUE;
        }
    }

    return hr;
}

// compute the relative path for the target is there is one
// pszPath is optionatl to test if there is a relative path

BOOL CShellLink::_GetRelativePath(LPTSTR pszPath)
{
    BOOL bRet = FALSE;

    LPCTSTR pszPathRel = _pszRelSource ? _pszRelSource : _pszCurFile;
    if (pszPathRel && _pszRelPath)
    {
        TCHAR szRoot[MAX_PATH];

        StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszPathRel);
        PathRemoveFileSpec(szRoot);         // pszPathRel is a file (not a directory)

        // this can fail for really deep paths
        if (PathCombine(pszPath, szRoot, _pszRelPath))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}

void CShellLink::_GetFindData(WIN32_FIND_DATA *pfd)
{
    ZeroMemory(pfd, sizeof(*pfd));

    pfd->dwFileAttributes = _sld.dwFileAttributes;
    pfd->ftCreationTime = _sld.ftCreationTime;
    pfd->ftLastAccessTime = _sld.ftLastAccessTime;
    pfd->ftLastWriteTime = _sld.ftLastWriteTime;
    pfd->nFileSizeLow = _sld.nFileSizeLow;

    TCHAR szPath[MAX_PATH];
    SHGetPathFromIDList(_pidl, szPath);
    ASSERT(szPath[0]);  // no one should call this on a pidl without a path

    StringCchCopy(pfd->cFileName, ARRAYSIZE(pfd->cFileName), PathFindFileName(szPath));
}


STDMETHODIMP CShellLink::GetPath(LPWSTR pszFile, int cchFile, WIN32_FIND_DATAW *pfd, DWORD fFlags)
{
    TCHAR szPath[MAX_PATH];

    if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {                                                                          
        // For darwin enabled links, we do NOT want to have to go and call         
        // ParseDarwinID here because that could possible force the app to install.
        // So, instead we return the path to the icon as the path for darwin enable
        // shortcuts. This allows the icon to be correct and since the darwin icon 
        // will always be an .exe, ensuring that the context menu will be correct. 
        SHExpandEnvironmentStrings(_pszIconLocation ? _pszIconLocation : TEXT(""), szPath, ARRAYSIZE(szPath));
    }
    else
    {
        DumpPLI(_pli);

        if (!_pidl || !SHGetPathFromIDListEx(_pidl, szPath, (fFlags & SLGP_SHORTPATH) ? GPFIDL_ALTNAME : 0))
            szPath[0] = 0;

        // Must do the pfd thing before we munge szPath, because the stuff
        // we do to szPath might render it unsuitable for PathFindFileName.
        // (For example, "C:\WINNT\Profiles\Bob" might turn into "%USERPROFILE%",
        // and we want to make sure we save "Bob" before it's too late.)

        if (pfd)
        {
            memset(pfd, 0, sizeof(*pfd));
            if (szPath[0])
            {
                pfd->dwFileAttributes = _sld.dwFileAttributes;
                pfd->ftCreationTime = _sld.ftCreationTime;
                pfd->ftLastAccessTime = _sld.ftLastAccessTime;
                pfd->ftLastWriteTime = _sld.ftLastWriteTime;
                pfd->nFileSizeLow = _sld.nFileSizeLow;
                SHTCharToUnicode(PathFindFileName(szPath), pfd->cFileName, ARRAYSIZE(pfd->cFileName));
            }
        }

        if ((_sld.dwFlags & SLDF_HAS_EXP_SZ) && (fFlags & SLGP_RAWPATH))
        {
            // Special case where we grab the Target name from
            // the extra data section of the link rather than from
            // the pidl.  We do this after we grab the name from the pidl
            // so that if we fail, then there is still some hope that a
            // name can be returned.
            LPEXP_SZ_LINK pszl = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_LINK_SIG);
            if (pszl)
            {
                SHUnicodeToTChar(pszl->swzTarget, szPath, ARRAYSIZE(szPath));
                DebugMsg(DM_TRACE, TEXT("CShellLink::GetPath() %s (from xtra data)"), szPath);
            }
        }
    }

    if (pszFile)
    {
        SHTCharToUnicode(szPath, pszFile, cchFile);
    }

    // note the lame return semantics, check for S_OK to be sure you have a path
    return szPath[0] ? S_OK : S_FALSE;
}

STDMETHODIMP CShellLink::GetIDList(LPITEMIDLIST *ppidl)
{
    if (_pidl)
    {
        return SHILClone(_pidl, ppidl);
    }

    *ppidl = NULL;
    return S_FALSE;     // success but empty
}

#ifdef DEBUG

#define DumpTimes(ftCreate, ftAccessed, ftWrite) \
    DebugMsg(DM_TRACE, TEXT("create   %8x%8x"), ftCreate.dwLowDateTime,   ftCreate.dwHighDateTime);     \
    DebugMsg(DM_TRACE, TEXT("accessed %8x%8x"), ftAccessed.dwLowDateTime, ftAccessed.dwHighDateTime);   \
    DebugMsg(DM_TRACE, TEXT("write    %8x%8x"), ftWrite.dwLowDateTime,    ftWrite.dwHighDateTime);

#else

#define DumpTimes(ftCreate, ftAccessed, ftWrite)

#endif

void CheckAndFixNullCreateTime(LPCTSTR pszFile, FILETIME *pftCreationTime, const FILETIME *pftLastWriteTime)
{
    if (IsNullTime(pftCreationTime) && !IsNullTime(pftLastWriteTime))
    {
        // this file has a bogus create time, set it to the last accessed time
        HANDLE hfile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL, OPEN_EXISTING, 0, NULL);

        if (INVALID_HANDLE_VALUE != hfile)
        {
            DebugMsg(DM_TRACE, TEXT("create   %8x%8x"), pftCreationTime->dwLowDateTime, pftCreationTime->dwHighDateTime);

            if (SetFileTime(hfile, pftLastWriteTime, NULL, NULL))
            {
                // get the time back to make sure we match the precision of the file system
                *pftCreationTime = *pftLastWriteTime;     // patch this up
#ifdef DEBUG
                {
                    FILETIME ftCreate, ftAccessed, ftWrite;
                    if (GetFileTime((HANDLE)hfile, &ftCreate, &ftAccessed, &ftWrite))
                    {
                        // we can't be sure that ftCreate == pftCreationTime because the GetFileTime
                        // spec says that the granularity of Set and Get may be different.
                        DumpTimes(ftCreate, ftAccessed, ftWrite);
                    }
                }
#endif
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("unable to set create time"));
            }
            CloseHandle(hfile);
        }
    }
}

//
// sets the current links find data and link tracker based on a path.
//
// returns:
//      S_OK        the file/folder is there
//      FAILED(hr)  the file could not be found
//      _bDirty set if the find data for the file (or tracker data) has been updated
//

HRESULT CShellLink::_GetFindDataAndTracker(LPCTSTR pszPath)
{
    WIN32_FIND_DATA fd = {0};
    HRESULT hr = S_OK;
    // Open the file or directory or root path.  We have to set FILE_FLAG_BACKUP_SEMANTICS
    // to get CreateFile to give us directory handles.
    HANDLE hFile = CreateFile(pszPath,
                              FILE_READ_ATTRIBUTES,
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              NULL, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                              NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        // Get the file attributes
        BY_HANDLE_FILE_INFORMATION fi;
        if (GetFileInformationByHandle(hFile, &fi))
        {
            fd.dwFileAttributes = fi.dwFileAttributes;
            fd.ftCreationTime = fi.ftCreationTime;
            fd.ftLastAccessTime = fi.ftLastAccessTime;
            fd.ftLastWriteTime = fi.ftLastWriteTime;
            fd.nFileSizeLow = fi.nFileSizeLow;

            // save the Object IDs as well.
            if (_ptracker)
            {
                if (SUCCEEDED(_ptracker->InitFromHandle(hFile, pszPath)))
                {
                    if (_ptracker->IsDirty())
                        _bDirty = TRUE;
                }
                else
                {
                    // Save space in the .lnk file
                    _ptracker->InitNew();
                }
            }
        }
        else
        {
            hr = GetLastHRESULT();
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = GetLastHRESULT();
    }

    if (SUCCEEDED(hr))
    {
        // If this file doesn't have a create time for some reason, set it to be the
        // current last-write time.
        CheckAndFixNullCreateTime(pszPath, &fd.ftCreationTime, &fd.ftLastWriteTime);
        _SetFindData(&fd);      // update _bDirty
    }
    return hr;
}

// IShellLink::SetIDList()
//
// note: the error returns here are really poor, they don't express
// any failures that might have occured (out of memory for example)

STDMETHODIMP CShellLink::SetIDList(LPCITEMIDLIST pidlnew)
{
    _SetPIDLPath(pidlnew, NULL, TRUE);
    return S_OK;    // return 
}

BOOL DifferentStrings(LPCTSTR psz1, LPCTSTR psz2)
{
    if (psz1 && psz2)
    {
        return lstrcmp(psz1, psz2);
    }
    else
    {
        return (!psz1 && psz2) || (psz1 && !psz2);
    }
}

// NOTE: NULL string ptr is valid argument for this function

HRESULT CShellLink::_SetField(LPTSTR *ppszField, LPCWSTR pszValueW)
{
    TCHAR szValue[INFOTIPSIZE], *pszValue;

    if (pszValueW)
    {
        SHUnicodeToTChar(pszValueW, szValue, ARRAYSIZE(szValue));
        pszValue = szValue;
    }
    else
    {
        pszValue = NULL;
    }

    if (DifferentStrings(*ppszField, pszValue))
    {
        _bDirty = TRUE;
    }

    Str_SetPtr(ppszField, pszValue);
    return S_OK;
}

HRESULT CShellLink::_SetField(LPTSTR *ppszField, LPCSTR pszValueA)
{
    TCHAR szValue[INFOTIPSIZE], *pszValue;

    if (pszValueA)
    {
        SHAnsiToTChar(pszValueA, szValue, ARRAYSIZE(szValue));
        pszValue = szValue;
    }
    else
    {
        pszValue = NULL;
    }

    if (DifferentStrings(*ppszField, pszValue))
    {
        _bDirty = TRUE;
    }

    Str_SetPtr(ppszField, pszValue);
    return S_OK;
}


HRESULT CShellLink::_GetField(LPCTSTR pszField, LPWSTR pszValue, int cchValue)
{
    if (pszField == NULL)
    {
        *pszValue = 0;
    }
    else
    {
        SHLoadIndirectString(pszField, pszValue, cchValue, NULL);
    }

    return S_OK;
}

HRESULT CShellLink::_GetField(LPCTSTR pszField, LPSTR pszValue, int cchValue)
{
    LPWSTR pwsz = (LPWSTR)alloca(cchValue * sizeof(WCHAR));

    _GetField(pszField, pwsz, cchValue);

    SHUnicodeToAnsi(pwsz, pszValue, cchValue);

    return S_OK;
}

//  order is important
const int c_rgcsidlUserFolders[] = {
    CSIDL_MYPICTURES | TEST_SUBFOLDER,
    CSIDL_PERSONAL | TEST_SUBFOLDER,
    CSIDL_DESKTOPDIRECTORY | TEST_SUBFOLDER,
    CSIDL_COMMON_DESKTOPDIRECTORY | TEST_SUBFOLDER,
};

STDAPI_(void) SHMakeDescription(LPCITEMIDLIST pidlDesc, int ids, LPTSTR pszDesc, UINT cch)
{
    LPCITEMIDLIST pidlName = pidlDesc;
    TCHAR szPath[MAX_PATH], szFormat[64];
    DWORD gdn;

    ASSERT(pidlDesc);
    
    //
    //  we want to only show the INFOLDER name for 
    //  folders the user sees often.  so in the desktop
    //  or mydocs or mypics we just show that name.
    //  otherwise show the whole path.
    //
    //  NOTE - there can be some weirdness if you start making
    //  shortcuts to special folders off the desktop
    //  specifically if you make a shortcut to mydocs the comment
    //  ends up being %USERPROFILE%, but this is a rare enough 
    //  case that i dont think we need to worry too much.
    //
    SHGetNameAndFlags(pidlDesc, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
    int csidl = GetSpecialFolderID(szPath, c_rgcsidlUserFolders, ARRAYSIZE(c_rgcsidlUserFolders));
    if (-1 != csidl)
    {
        gdn = SHGDN_INFOLDER   | SHGDN_FORADDRESSBAR;
        switch (csidl)
        {
        case CSIDL_DESKTOPDIRECTORY:
        case CSIDL_COMMON_DESKTOPDIRECTORY:
            {
                ULONG cb;
                if (csidl == GetSpecialFolderParentIDAndOffset(pidlDesc, &cb))
                {
                    //  reorient based off the desktop.
                    pidlName = (LPCITEMIDLIST)(((BYTE *)pidlDesc) + cb);
                }
            }
            break;

        case CSIDL_PERSONAL:
            if (SUCCEEDED(GetMyDocumentsDisplayName(szPath, ARRAYSIZE(szPath))))
                pidlName = NULL;
            break;

        default:
            break;
        }
    }
    else
        gdn = SHGDN_FORPARSING | SHGDN_FORADDRESSBAR;

    if (pidlName)
    {
        SHGetNameAndFlags(pidlName, gdn, szPath, ARRAYSIZE(szPath), NULL);
    }

    if (ids != -1)
    {
        LoadString(HINST_THISDLL, ids, szFormat, ARRAYSIZE(szFormat));

        wnsprintf(pszDesc, cch, szFormat, szPath);
    }
    else
        StrCpyN(pszDesc, szPath, cch);
}

void _MakeDescription(LPCITEMIDLIST pidlTo, LPTSTR pszDesc, UINT cch)
{
    LPCITEMIDLIST pidlInner;
    if (ILIsRooted(pidlTo))
    {
        pidlInner = ILRootedFindIDList(pidlTo);
    }
    else
    {
        pidlInner = pidlTo;
    }

    LPITEMIDLIST pidlParent = ILCloneParent(pidlInner);
    if (pidlParent)
    {
        SHMakeDescription(pidlParent, IDS_LOCATION, pszDesc, cch);
        ILFree(pidlParent);
    }
    else
    {
        *pszDesc = 0;
    }
}

STDMETHODIMP CShellLink::GetDescription(LPWSTR pszDesc, int cchMax)
{
    return _GetField(_pszName, pszDesc, cchMax);
}

STDMETHODIMP CShellLink::GetDescription(LPSTR pszDesc, int cchMax)
{
    return _GetField(_pszName, pszDesc, cchMax);
}

STDMETHODIMP CShellLink::SetDescription(LPCWSTR pszDesc)
{
    return _SetField(&_pszName, pszDesc);
}

STDMETHODIMP CShellLink::SetDescription(LPCSTR pszDesc)
{
    return _SetField(&_pszName, pszDesc);
}

STDMETHODIMP CShellLink::GetWorkingDirectory(LPWSTR pszDir, int cchDir)
{
    return _GetField(_pszWorkingDir, pszDir, cchDir);
}

STDMETHODIMP CShellLink::GetWorkingDirectory(LPSTR pszDir, int cchDir)
{
    return _GetField(_pszWorkingDir, pszDir, cchDir);
}

STDMETHODIMP CShellLink::SetWorkingDirectory(LPCWSTR pszWorkingDir)
{
    return _SetField(&_pszWorkingDir, pszWorkingDir);
}

STDMETHODIMP CShellLink::SetWorkingDirectory(LPCSTR pszDir)
{
    return _SetField(&_pszWorkingDir, pszDir);
}

STDMETHODIMP CShellLink::GetArguments(LPWSTR pszArgs, int cchArgs)
{
    return _GetField(_pszArgs, pszArgs, cchArgs);
}

STDMETHODIMP CShellLink::GetArguments(LPSTR pszArgs, int cch)
{
    return _GetField(_pszArgs, pszArgs, cch);
}

STDMETHODIMP CShellLink::SetArguments(LPCWSTR pszArgs)
{
    return _SetField(&_pszArgs, pszArgs);
}

STDMETHODIMP CShellLink::SetArguments(LPCSTR pszArgs)
{
    return _SetField(&_pszArgs, pszArgs);
}

STDMETHODIMP CShellLink::GetHotkey(WORD *pwHotkey)
{
    *pwHotkey = _sld.wHotkey;
    return S_OK;
}

STDMETHODIMP CShellLink::SetHotkey(WORD wHotkey)
{
    if (_sld.wHotkey != wHotkey)
    {
        _bDirty = TRUE;
        _sld.wHotkey = wHotkey;
    }
    return S_OK;
}

STDMETHODIMP CShellLink::GetShowCmd(int *piShowCmd)
{
    *piShowCmd = _sld.iShowCmd;
    return S_OK;
}

STDMETHODIMP CShellLink::SetShowCmd(int iShowCmd)
{
    if (_sld.iShowCmd != iShowCmd)
    {
        _bDirty = TRUE;
    }
    _sld.iShowCmd = iShowCmd;
    return S_OK;
}

// IShellLinkW::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(LPWSTR pszIconPath, int cchIconPath, int *piIcon)
{
    _UpdateIconFromExpIconSz();

    _GetField(_pszIconLocation, pszIconPath, cchIconPath);
    *piIcon = _sld.iIcon;

    return S_OK;
}

// IShellLinkA::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(LPSTR pszPath, int cch, int *piIcon)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = GetIconLocation(szPath, ARRAYSIZE(szPath), piIcon);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(szPath, pszPath, cch);
    }
    return hr;
}


// IShellLinkW::SetIconLocation
// NOTE: 
//      pszIconPath may be NULL

STDMETHODIMP CShellLink::SetIconLocation(LPCWSTR pszIconPath, int iIcon)
{
    TCHAR szIconPath[MAX_PATH];

    if (pszIconPath)
    {
        SHUnicodeToTChar(pszIconPath, szIconPath, ARRAYSIZE(szIconPath));
    }

    if (pszIconPath)
    {
        HANDLE  hToken;
        TCHAR   szIconPathEnc[MAX_PATH];

        if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken) == FALSE)
        {
            hToken = NULL;
        }

        if (PathUnExpandEnvStringsForUser(hToken, szIconPath, szIconPathEnc, ARRAYSIZE(szIconPathEnc)) != 0)
        {
            EXP_SZ_LINK expLink;

            // mark that link has expandable strings, and add them
            _sld.dwFlags |= SLDF_HAS_EXP_ICON_SZ; // should this be unique for icons?

            LPEXP_SZ_LINK lpNew = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_ICON_SIG);
            if (!lpNew) 
            {
                lpNew = &expLink;
                expLink.cbSize = 0;
                expLink.dwSignature = EXP_SZ_ICON_SIG;
            }

            // store both A and W version (for no good reason!)
            SHTCharToAnsi(szIconPathEnc, lpNew->szTarget, ARRAYSIZE(lpNew->szTarget));
            SHTCharToUnicode(szIconPathEnc, lpNew->swzTarget, ARRAYSIZE(lpNew->swzTarget));

            // See if this is a new entry that we need to add
            if (lpNew->cbSize == 0)
            {
                lpNew->cbSize = sizeof(*lpNew);
                _AddExtraDataSection((DATABLOCK_HEADER *)lpNew);
            }
        }
        else 
        {
            _sld.dwFlags &= ~SLDF_HAS_EXP_ICON_SZ;
            _RemoveExtraDataSection(EXP_SZ_ICON_SIG);
        }
        if (hToken != NULL)
        {
            CloseHandle(hToken);
        }
    }

    _SetField(&_pszIconLocation, pszIconPath);

    if (_sld.iIcon != iIcon)
    {
        _sld.iIcon = iIcon;
        _bDirty = TRUE;
    }

    if ((_sld.dwFlags & SLDF_HAS_DARWINID) && pszIconPath)
    {
        // NOTE: The comment below is for darwin as it shipped in win98/IE4.01,
        // and is fixed in the > NT5 versions of the shell's darwin implementation.
        //
        // for darwin enalbed links, we make the path point to the
        // icon location (which is must be of the type (ie same ext) as the real
        // destination. So, if I want a darwin link to readme.txt, the shell
        // needs the icon to be icon1.txt, which is not good!!. This ensures
        // that the context menu will be correct and allows us to return
        // from CShellLink::GetPath & CShellLink::GetIDList without faulting the 
        // application in because we lie to people and tell them that we 
        // really point to our icon, which is the same type as the real target,
        // thus making our context menu be correct.
        _SetPIDLPath(NULL, szIconPath, FALSE);
    }

    return S_OK;
}

// IShellLinkA::SetIconLocation
STDMETHODIMP CShellLink::SetIconLocation(LPCSTR pszPath, int iIcon)
{
    WCHAR szPath[MAX_PATH];
    LPWSTR pszPathW;

    if (pszPath)
    {
        SHAnsiToUnicode(pszPath, szPath, ARRAYSIZE(szPath));
        pszPathW = szPath;
    }
    else
    {
        pszPathW = NULL;
    }

    return SetIconLocation(pszPathW, iIcon);
}

HRESULT CShellLink::_InitExtractImage()
{
    HRESULT hr;
    if (_pxthumb)
    {
        hr = S_OK;
    }
    else
    {
        hr = _GetUIObject(NULL, IID_PPV_ARG(IExtractImage, &_pxthumb));
    }
    return hr;
}

// IExtractImage

STDMETHODIMP CShellLink::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                    DWORD * pdwPriority, const SIZE * prgSize,
                                    DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = _InitExtractImage();
    if (SUCCEEDED(hr))
    {
        hr = _pxthumb->GetLocation(pszPathBuffer, cch, pdwPriority, prgSize, dwRecClrDepth, pdwFlags);
    }
    return hr;
}

STDMETHODIMP CShellLink::Extract(HBITMAP *phBmpThumbnail)
{
    HRESULT hr = _InitExtractImage();
    if (SUCCEEDED(hr))
    {
        hr = _pxthumb->Extract(phBmpThumbnail);
    }
    return hr;
}

STDMETHODIMP CShellLink::GetDateStamp(FILETIME *pftDateStamp)
{
    HRESULT hr = _InitExtractImage();
    if (SUCCEEDED(hr))
    {
        IExtractImage2 * pExtract2;
        hr = _pxthumb->QueryInterface(IID_PPV_ARG(IExtractImage2, &pExtract2));
        if (SUCCEEDED(hr))
        {
            hr = pExtract2->GetDateStamp(pftDateStamp);
            pExtract2->Release();
        }
    }
    return hr;
}



// set the relative path, this is used before a link is saved so we know what
// we should use to store the link relative to as well as before the link is resolved
// so we know the new path to use with the saved relative path.
//
// in:
//      pszPathRel      path to make link target relative to, must be a path to
//                      a file, not a directory.
//
//      dwReserved      must be 0
//
// returns:
//      S_OK            relative path is set
//

STDMETHODIMP CShellLink::SetRelativePath(LPCWSTR pszPathRel, DWORD dwRes)
{
    if (dwRes != 0)
    {
        return E_INVALIDARG;
    }

    return _SetField(&_pszRelSource, pszPathRel);
}

STDMETHODIMP CShellLink::SetRelativePath(LPCSTR pszPathRel, DWORD dwRes)
{
    if (dwRes != 0)
    {
        return E_INVALIDARG;
    }

    return _SetField(&_pszRelSource, pszPathRel);
}

// IShellLink::Resolve()
// 
// If SLR_UPDATE isn't set, check IPersistFile::IsDirty after
// calling this to see if the link info has changed and save it.
//
// returns:
//      S_OK    all things good
//      S_FALSE user canceled (bummer, should be ERROR_CANCELLED)

STDMETHODIMP CShellLink::Resolve(HWND hwnd, DWORD dwResolveFlags)
{
    HRESULT hr = _Resolve(hwnd, dwResolveFlags, 0);
    
    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
    {
        hr = S_FALSE;
    }

    return hr;
}

//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
//    NOTE: Stolen from inet\urlmon\download\helpers.cxx
HRESULT GetVersionFromString(TCHAR *szBuf, DWORD *pdwFileVersionMS, DWORD *pdwFileVersionLS)
{
    const TCHAR *pch = szBuf;
    TCHAR ch;
    USHORT n = 0;
    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (lstrcmp(pch, TEXT("-1,-1,-1,-1")) == 0)
    {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
        return S_OK;
    }

    for (ch = *pch++;;ch = *pch++)
    {
        if ((ch == ',') || (ch == '\0'))
        {
            switch (have)
            {
            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0')
            {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        }
        else if ((ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}

//  Purpose:    A _Resolve-time check to see if the link has
//              Logo3 application channel
//
//  Inputs:     [LPCTSTR] - pszLogo3ID - the id/keyname for
//                          our Logo3 software.
//
//  Outputs:    [BOOL]
//                  -   TRUE if our peek at the registry
//                      indicates we have an ad to show
//                  -   FALSE indicates no new version
//                      to advertise.
//
//  Algorithm:  Check the software update registry info for the
//              ID embedded in the link. This is a sleazy hack
//              to avoid loading shdocvw and urlmon, which are
//              the normal code path for this check.
//              NOTE: The version checking logic is stolen from
//              shell\shdocvw\sftupmb.cpp

HRESULT GetLogo3SoftwareUpdateInfo(LPCTSTR pszLogo3ID, LPSOFTDISTINFO psdi)
{    
    HRESULT     hr = S_OK;
    HKEY        hkeyDistInfo = 0;
    HKEY        hkeyAvail = 0;
    HKEY        hkeyAdvertisedVersion = 0;
    DWORD       lResult = 0;
    DWORD       dwSize = 0;
    DWORD       dwType;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szVersionBuf[MAX_PATH];
    DWORD       dwLen = 0;
    DWORD       dwCurAdvMS = 0;
    DWORD       dwCurAdvLS = 0;

    wnsprintf(szBuffer, ARRAYSIZE(szBuffer),
             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s"),
             pszLogo3ID);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                     &hkeyDistInfo) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Exit;
    }
    
    if (RegOpenKeyEx(hkeyDistInfo, TEXT("AvailableVersion"), 0, KEY_READ,
                     &hkeyAvail) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Exit;
    }

    dwSize = sizeof(lResult);
    if (SHQueryValueEx(hkeyAvail, TEXT("Precache"), 0, &dwType,
                        (unsigned char *)&lResult, &dwSize) == ERROR_SUCCESS)
    {
        // Precached value was the code download HR
        if (lResult == S_OK)
            psdi->dwFlags = SOFTDIST_FLAG_USAGE_PRECACHE;
    }


    dwSize = sizeof(szVersionBuf);
    if (SHQueryValueEx(hkeyAvail, TEXT("AdvertisedVersion"), NULL, &dwType, 
                        szVersionBuf, &dwSize) == ERROR_SUCCESS)
    {
        GetVersionFromString(szVersionBuf, &psdi->dwAdvertisedVersionMS, &psdi->dwAdvertisedVersionLS);
        // Get the AdState, if any
        dwSize = sizeof(psdi->dwAdState);
        SHQueryValueEx(hkeyAvail, TEXT("AdState"), NULL, NULL, &psdi->dwAdState, &dwSize);
    }
 


    dwSize = sizeof(szVersionBuf);
    if (SHQueryValueEx(hkeyAvail, NULL, NULL, &dwType, szVersionBuf, &dwSize) != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if (FAILED(GetVersionFromString(szVersionBuf, &psdi->dwUpdateVersionMS, &psdi->dwUpdateVersionLS)))
    {
        hr = S_FALSE;
        goto Exit;
    }

 
    dwLen = sizeof(psdi->dwInstalledVersionMS);
    if (SHQueryValueEx(hkeyDistInfo, TEXT("VersionMajor"), 0, &dwType,
                        &psdi->dwInstalledVersionMS, &dwLen) != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto Exit;
    }

    dwLen = sizeof(psdi->dwInstalledVersionLS);
    if (SHQueryValueEx(hkeyDistInfo, TEXT("VersionMinor"), 0, &dwType,
                        &psdi->dwInstalledVersionLS, &dwLen) != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if (psdi->dwUpdateVersionMS > psdi->dwInstalledVersionMS ||
        (psdi->dwUpdateVersionMS == psdi->dwInstalledVersionMS &&
         psdi->dwUpdateVersionLS > psdi->dwInstalledVersionLS))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Exit:
    if (hkeyAdvertisedVersion)
    {
        RegCloseKey(hkeyAdvertisedVersion);
    }

    if (hkeyAvail)
    {
        RegCloseKey(hkeyAvail);
    }

    if (hkeyDistInfo)
    {
        RegCloseKey(hkeyDistInfo);
    }

    return hr;
}

//  Purpose:    A _Resolve-time check to see if the link has
//              Logo3 application channel
//
//  Inputs:     [LPCTSTR] - pszLogo3ID - the id/keyname for
//                          our Logo3 software.
//
//  Outputs:    [BOOL]
//                  -   TRUE if our peek at the registry
//                      indicates we have an ad to show
//                  -   FALSE indicates no new version
//                      to advertise.
//
//  Algorithm:  Check the software update registry info for the
//              ID embedded in the link. This is a sleazy hack
//              to avoid loading shdocvw and urlmon, which are
//              the normal code path for this check.
//              The version checking logic is stolen from

BOOL FLogo3RegPeek(LPCTSTR pszLogo3ID)
{
    BOOL            bHaveAd = FALSE;
    SOFTDISTINFO    sdi = { 0 };
    DWORD           dwAdStateNew = SOFTDIST_ADSTATE_NONE;

    HRESULT hr = GetLogo3SoftwareUpdateInfo(pszLogo3ID, &sdi);
 
    // we need an HREF to work properly. The title and abstract are negotiable.
    if (SUCCEEDED(hr))
    {
        // see if this is an update the user already knows about.
        // If it is, then skip the dialog.
        if ( (sdi.dwUpdateVersionMS >= sdi.dwInstalledVersionMS ||
                (sdi.dwUpdateVersionMS == sdi.dwInstalledVersionMS &&
                 sdi.dwUpdateVersionLS >= sdi.dwInstalledVersionLS))    && 
              (sdi.dwUpdateVersionMS >= sdi.dwAdvertisedVersionMS ||
                (sdi.dwUpdateVersionMS == sdi.dwAdvertisedVersionMS &&
                 sdi.dwUpdateVersionLS >= sdi.dwAdvertisedVersionLS)))
        { 
            if (hr == S_OK) // new version
            {
                // we have a pending update, either on the net, or downloaded
                if (sdi.dwFlags & SOFTDIST_FLAG_USAGE_PRECACHE)
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_DOWNLOADED;
                }
                else
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_AVAILABLE;
                }
            }
            else if (sdi.dwUpdateVersionMS == sdi.dwInstalledVersionMS &&
                      sdi.dwUpdateVersionLS == sdi.dwInstalledVersionLS)
            {
                // if installed version matches advertised, then we autoinstalled already
                // NOTE: If the user gets gets channel notification, then runs out
                // to the store and buys the new version, then installs it, we'll
                // mistake this for an auto-install.
                dwAdStateNew = SOFTDIST_ADSTATE_INSTALLED;
            }

            // only show the dialog if we've haven't been in this ad state before for
            // this update version
            if (dwAdStateNew > sdi.dwAdState)
            {
                bHaveAd = TRUE;
            }
        } // if update is a newer version than advertised
    }

    return bHaveAd;
}


//  Purpose:    A _Resolve-time check to see if the link has
//              Logo3 application channel
//
//  Inputs:     [HWND] hwnd
//                  -   The parent window (which could be the desktop).
//              [DWORD] dwResolveFlags
//                  -   Flags from the SLR_FLAGS enumeration.
//
// returns:
//  S_OK    The user wants to pursue the
//          software update thus we should not continue
//                  
// S_FALSE  No software update, or the user doesn't want it now.
//          proceed with regular resolve path
//
//  Algorithm:  Check the software update registry info for the
//              ID embedded in the link. If there's a new version
//              advertised, prompt the user with shdocvw's message
//              box. If the mb says update, tell the caller we
//              don't want the link target, as we're headed to the
//              link update page.

HRESULT CShellLink::_ResolveLogo3Link(HWND hwnd, DWORD dwResolveFlags)
{
    HRESULT hr = S_FALSE; // default to no update.

    if ((_sld.dwFlags & SLDF_HAS_LOGO3ID) &&
        !SHRestricted(REST_NOLOGO3CHANNELNOTIFY))
    {
        LPEXP_DARWIN_LINK pdl = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, EXP_LOGO3_ID_SIG);
        if (pdl)
        {
            TCHAR szLogo3ID[MAX_PATH];
            WCHAR szwLogo3ID[MAX_PATH];
            int cchBlessData;
            WCHAR *pwch;

            TCHAR *pch = pdl->szwDarwinID;

            // Ideally, we support multiple, semi-colon delmited IDs, for now
            // just grab the first one.
            for (pwch = pdl->szwDarwinID, cchBlessData = 0;
                  *pch != ';' && *pch != '\0' && cchBlessData < MAX_PATH;
                  pch++, pwch++, cchBlessData++)
            {
                szLogo3ID[cchBlessData] = *pch;
                szwLogo3ID[cchBlessData] = *pwch;
            }
            // and terminate
            szLogo3ID[cchBlessData] = '\0';
            szwLogo3ID[cchBlessData] = L'\0';
        
            // Before well haul in shdocvw, we'll sneak a peak at our Logo3 reg goo 
            if (!(dwResolveFlags & SLR_NO_UI) && FLogo3RegPeek(szLogo3ID))
            {
                // stuff stolen from shdocvw\util.cpp's CheckSoftwareUpdateUI
                BOOL fLaunchUpdate = FALSE;
                SOFTDISTINFO sdi = { 0 };
                sdi.cbSize = sizeof(sdi);

                int nRes = SoftwareUpdateMessageBox(hwnd, szwLogo3ID, 0, &sdi);

                if (nRes != IDABORT)
                {
                    if (nRes == IDYES)
                    {
                        // NOTE: This differ's from Shdocvw in that we don't
                        // have the cool internal navigation stuff to play with.
                        // Originally, this was done with ShellExecEx. This failed
                        // because the http hook wasn't 100% reliable on Win95.
                        //ShellExecuteW(NULL, NULL, sdi.szHREF, NULL, NULL, 0);
                        hr = HlinkNavigateString(NULL, sdi.szHREF);

                    } // if user wants update

                    if (sdi.szTitle != NULL)
                        SHFree(sdi.szTitle);
                    if (sdi.szAbstract != NULL)
                        SHFree(sdi.szAbstract);
                    if (sdi.szHREF != NULL)
                        SHFree(sdi.szHREF);
    
                    fLaunchUpdate = nRes == IDYES && SUCCEEDED(hr);
                } // if no message box abort (error)

                if (fLaunchUpdate)
                {
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

BOOL _TryRestoreConnection(HWND hwnd, LPCTSTR pszPath)
{
    BOOL bRet = FALSE;
    if (!PathIsUNC(pszPath) && IsDisconnectedNetDrive(DRIVEID(pszPath)))
    {
        TCHAR szDrive[4];
        szDrive[0] = *pszPath;
        szDrive[1] = TEXT(':');
        szDrive[2] = 0;
        bRet = WNetRestoreConnection(hwnd, szDrive) == WN_SUCCESS;
    }
    return bRet;
}

//
// updates then resolves LinkInfo associated with a CShellLink instance
// if the resolve results in a new path updates the pidl to the new path
//
// in:
//      hwnd    to post resolve UI on (if dwFlags indicates UI)
//      dwResolveFlags  IShellLink::Resolve() flags
//
// in/out:
//      pszPath     may be updated with new path to use in case of failure
//
// returns:
//      FAILED()    we failed the update, either UI cancel or memory failure, 
//                  be sure to respect ERROR_CANCELLED
//      S_OK        we have a valid pli and pidl read to be used OR
//                  we should search for this path using the link search code

HRESULT CShellLink::_ResolveLinkInfo(HWND hwnd, DWORD dwResolveFlags, LPTSTR pszPath, DWORD *pfifFlags)
{
    HRESULT hr;
    if (SHRestricted(REST_LINKRESOLVEIGNORELINKINFO))
    {
        _TryRestoreConnection((dwResolveFlags & SLR_NO_UI) ? NULL : hwnd, pszPath);
        hr = _SetPIDLPath(NULL, pszPath, TRUE);
    } 
    else
    {
        ASSERTMSG(_pli != NULL, "_ResolveLinkInfo should only be called when _pli != NULL");

        DWORD dwLinkInfoFlags = (RLI_IFL_CONNECT | RLI_IFL_TEMPORARY);

        if (!PathIsRoot(pszPath))
            dwLinkInfoFlags |= RLI_IFL_LOCAL_SEARCH;

        if (!(dwResolveFlags & SLR_NO_UI))
            dwLinkInfoFlags |= RLI_IFL_ALLOW_UI;

        ASSERT(!(dwLinkInfoFlags & RLI_IFL_UPDATE));

        TCHAR szResolvedPath[MAX_PATH];
        DWORD dwOutFlags;
        if (ResolveLinkInfo(_pli, szResolvedPath, dwLinkInfoFlags, hwnd, &dwOutFlags, NULL))
        {
            ASSERT(!(dwOutFlags & RLI_OFL_UPDATED));

            PathRemoveBackslash(szResolvedPath);    // remove extra trailing slashes
            StrCpyN(pszPath, szResolvedPath, MAX_PATH);       // in case of failure, use this

            // net connection might have been re-established, try again
            hr = _SetPIDLPath(NULL, pszPath, TRUE);
        }
        else 
        {
            // don't try searching this drive/volume again
            *pfifFlags |= FIF_NODRIVE;
            hr = GetLastHRESULT();
        }
    }
    return hr;
}

DWORD TimeoutDeltaFromResolveFlags(DWORD dwResolveFlags)
{
    DWORD dwTimeOutDelta;
    if (SLR_NO_UI & dwResolveFlags)
    {
        dwTimeOutDelta = HIWORD(dwResolveFlags);
        if (dwTimeOutDelta == 0)
        {
            dwTimeOutDelta = NOUI_SEARCH_TIMEOUT;
        }
        else if (dwTimeOutDelta == 0xFFFF)
        {
            TCHAR szTimeOut[10];
            DWORD cbTimeOut = sizeof(szTimeOut);
    
            if (ERROR_SUCCESS == SHRegGetValue(HKEY_LOCAL_MACHINE,
                                               TEXT("Software\\Microsoft\\Tracking\\TimeOut"),
                                               NULL,
                                               SRRF_RT_REG_SZ,
                                               NULL,
                                               szTimeOut,
                                               &cbTimeOut))
            {
                dwTimeOutDelta = StrToInt(szTimeOut);
            }
            else
            {
                dwTimeOutDelta = NOUI_SEARCH_TIMEOUT;
            }
        }
    }
    else
    {
        dwTimeOutDelta = UI_SEARCH_TIMEOUT;
    }
    return dwTimeOutDelta;
}


// allows the name space to be able to hook the resolve process and thus
// provide custom behavior. this is used for reg items and shortcuts to the 
// MyDocs folder
//
// this also resolves by re-parsing the relative parsing name as the optimal way
// to run the success case of ::Resolve()
//
// returns:
//      S_OK    this resolution was taken care of
//      HRESULT_FROM_WIN32(ERROR_CANCELLED) UI cancel
//      HRESULT_FROM_WIN32(ERROR_TIMEOUT) timeout on the parse
//      other FAILED() codes (implies name space did not resolve for you)

HRESULT CShellLink::_ResolveIDList(HWND hwnd, DWORD dwResolveFlags)
{
    ASSERT(!(_sld.dwFlags & SLDF_HAS_DARWINID));
    
    HRESULT hr = E_FAIL;   // generic failure, we did not handle this
    IShellFolder* psf;
    LPCITEMIDLIST pidlChild;
    if (_pidl && SUCCEEDED(SHBindToIDListParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        IResolveShellLink *prl = NULL;
        
        // 2 ways to get the link resolve object
        // 1. ask the folder for the resolver for the item
        if (FAILED(psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_PPV_ARG_NULL(IResolveShellLink, &prl))))
        {
            // 2. bind to the object directly and ask it (CreateViewObject)
            IShellFolder *psfItem;
            if (SUCCEEDED(psf->BindToObject(pidlChild, NULL, IID_PPV_ARG(IShellFolder, &psfItem))))
            {
                psfItem->CreateViewObject(NULL, IID_PPV_ARG(IResolveShellLink, &prl));
                psfItem->Release();
            }
        }
        
        if (prl)
        {
            hr = prl->ResolveShellLink(SAFECAST(this, IShellLink*), hwnd, dwResolveFlags);
            prl->Release();
        }
        else
        {
            // perf short circuit: avoid the many net round trips that happen in 
            // _SetPIDLPath() in the common success case where the file is there
            // we validate the target based on reparsing the relative name
            //
            // this is a universal way to "resolve" an object in the name space
            
            // note, code here is very similart to SHGetRealIDL() but this version
            // does not mask the error cases that we need to detect
            
            TCHAR szName[MAX_PATH];
            if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
            {
                // we limit this to file system items for compat with some name spaces
                // (WinCE) that support parse, but do a bad job of it
                if (SHGetAttributes(psf, pidlChild, SFGAO_FILESYSTEM))
                {
                    IBindCtx *pbcTimeout;
                    BindCtx_CreateWithTimeoutDelta(TimeoutDeltaFromResolveFlags(dwResolveFlags), &pbcTimeout);

                    if (dwResolveFlags & SLR_NO_UI)
                    {
                        hwnd = NULL;    // make sure parse does not get this
                    }
                    
                    LPITEMIDLIST pidlChildNew;
                    hr = psf->ParseDisplayName(hwnd, pbcTimeout, szName, NULL, &pidlChildNew, NULL);
                    if (SUCCEEDED(hr))
                    {
                        // no construct the new full IDList and set that
                        // note many pidls here, make sure we don't leak any
                        
                        LPITEMIDLIST pidlParent = ILCloneParent(_pidl);
                        if (pidlParent)
                        {
                            LPITEMIDLIST pidlFull = ILCombine(pidlParent, pidlChildNew);
                            if (pidlFull)
                            {
                                // we set this as the new target of this link, 
                                // with FALSE for bUpdateTrackingData to avoid the cost of that
                                hr = _SetPIDLPath(pidlFull, NULL, FALSE);
                                ILFree(pidlFull);
                            }
                            ILFree(pidlParent);
                        }
                        ILFree(pidlChildNew);
                    }
                    
                    if (pbcTimeout)
                        pbcTimeout->Release();
                }
            }
        }
        psf->Release();
    }
    return hr;
}

BOOL CShellLink::_ResolveDarwin(HWND hwnd, DWORD dwResolveFlags, HRESULT *phr)
{
    // check to see if this is a Darwin link
    BOOL bIsDrawinLink = _sld.dwFlags & SLDF_HAS_DARWINID;
    if (bIsDrawinLink)
    {
        HRESULT hr = S_OK;
        // we only envoke darwin if they are passing the correct SLR_INVOKE_MSI
        // flag. This prevents poor apps from going and calling resolve and
        // faulting in a bunch of darwin apps.
        if ((dwResolveFlags & SLR_INVOKE_MSI) && IsDarwinEnabled())
        {
            LPEXP_DARWIN_LINK pdl = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, EXP_DARWIN_ID_SIG);
            if (pdl)
            {
                TCHAR szDarwinCommand[MAX_PATH];

                hr = ParseDarwinID(pdl->szwDarwinID, szDarwinCommand, SIZECHARS(szDarwinCommand));
                if (FAILED(hr) || 
                    HRESULT_CODE(hr) == ERROR_SUCCESS_REBOOT_REQUIRED || 
                    HRESULT_CODE(hr) == ERROR_SUCCESS_REBOOT_INITIATED)
                {
                    switch (HRESULT_CODE(hr))
                    {
                    case ERROR_INSTALL_USEREXIT:            // User pressed cancel. They don't need UI.
                    case ERROR_SUCCESS_REBOOT_INITIATED:    // Machine is going to reboot
                    case ERROR_SUCCESS_REBOOT_REQUIRED:
                        // dont run the darwin app in all of the above cases,
                        // ERROR_CANCELLED suppresses further error UI
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        break;

                    default:
                        if (!(dwResolveFlags & SLR_NO_UI))
                        {
                            TCHAR szTemp[MAX_PATH];
                            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hr), 0, szTemp, ARRAYSIZE(szTemp), NULL);

                            ShellMessageBox(HINST_THISDLL, hwnd, szTemp,
                                            MAKEINTRESOURCE(IDS_LINKERROR),
                                            MB_OK | MB_ICONSTOP, NULL, NULL);
                            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        }
                        break;
                    }
                }
                else
                {
                    // We want to fire an event for the product code, not the path. Do this here since we've got the product code.
                    if (_pcbDarwin)
                    {
                        _pcbDarwin->SetProductCodeFromDarwinID(pdl->szwDarwinID);
                    }

                    PathUnquoteSpaces(szDarwinCommand);
                    hr = _SetPIDLPath(NULL, szDarwinCommand, FALSE);
                }
            }
        }
        *phr = hr;
    }
    return bIsDrawinLink;
}

// if the link has encoded env vars we will set them now, possibly updating _pidl

void CShellLink::_SetIDListFromEnvVars()
{
    TCHAR szPath[MAX_PATH];

    // check to see whether this link has expandable environment strings
    if (_GetExpandedPath(szPath, ARRAYSIZE(szPath)))
    {
        if (FAILED(_SetPIDLPath(NULL, szPath, TRUE)))
        {
            // The target file is no longer valid so we should dump the EXP_SZ section before
            // we continue.  Note that we don't set bDirty here, that is only set later if
            // we actually resolve this link to a new path or pidl.  The result is we'll only
            // save this modification if a new target is found and accepted by the user.
            _sld.dwFlags &= ~SLDF_HAS_EXP_SZ;

            _SetSimplePIDL(szPath);
        }
    } 
}

HRESULT CShellLink::_ResolveRemovable(HWND hwnd, LPCTSTR pszPath)
{
    HANDLE hfind;
    WIN32_FIND_DATA fd;
    HRESULT hr = FindFirstRetryRemovable(hwnd, _punkSite, pszPath, &fd, &hfind);
    if (S_OK == hr)
    {
        FindClose(hfind);   // throw that out
        hr = _SetPIDLPath(NULL, pszPath, TRUE);
    }
    return hr;
}

_inline BOOL FAILED_AND_NOT_STOP_ERROR(HRESULT hr)
{
    return FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) && (HRESULT_FROM_WIN32(ERROR_TIMEOUT) != hr);
}

//
//  implementation for IShellLink::Resolve and IShellLinkTracker::Resolve
//
//  Inputs:     hwnd
//                  -   The parent window (which could be the desktop).
//              dwResolveFlags
//                  -   Flags from the SLR_FLAGS enumeration.
//              dwTracker
//                  -   Restrict CTracker::Resolve from the
//                      TrkMendRestrictions enumeration
//
//  Outputs:    S_OK    resolution was successful
//
//  Algorithm:  Look for the link target and update the link path and IDList.
//              Check IPersistFile::IsDirty after calling this to see if the
//              link info has changed as a result.
//

HRESULT CShellLink::_Resolve(HWND hwnd, DWORD dwResolveFlags, DWORD dwTracker)
{
    if (S_OK == _ResolveLogo3Link(hwnd, dwResolveFlags))
    {
        // the link is being updated or the user canceled
        // either case we bail
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    HRESULT hr = S_OK;

    if (!_ResolveDarwin(hwnd, dwResolveFlags, &hr))
    {
        _SetIDListFromEnvVars();    // possibly sets _pidl via env vars

        // normal link resolve sequence starts here

        hr = _ResolveIDList(hwnd, dwResolveFlags);

        if (FAILED_AND_NOT_STOP_ERROR(hr))
        {
            TCHAR szPath[MAX_PATH];

            if (_pidl == NULL)
            {
                // APP COMPAT! Inso Quick View Plus demands S_OK on empty .lnk
                hr = S_OK;  
            }
            else if (SHGetPathFromIDList(_pidl, szPath) && !PathIsRoot(szPath))
            {
                DWORD fifFlags = 0;

                // file system specific link tracking kicks in now
                // see if it is where it was before...

                // see if it there is a UNC or net path alias, if so try that
                if (!(dwResolveFlags & SLR_NOLINKINFO) && _pli)
                {
                    hr = _ResolveLinkInfo(hwnd, dwResolveFlags, szPath, &fifFlags);
                }
                else
                {
                    hr = E_FAIL;
                }

                if (FAILED_AND_NOT_CANCELED(hr))
                {
                    // use the relative path info if that is available
                    TCHAR szNew[MAX_PATH];
                    if (_GetRelativePath(szNew))
                    {
                        if (StrCmpI(szNew, szPath))
                        {
                            StringCchCopy(szPath, ARRAYSIZE(szPath), szNew); // use this in case of failure
                            hr = _SetPIDLPath(NULL, szPath, TRUE);
                        }
                    }
                }

                if (FAILED_AND_NOT_CANCELED(hr) && !(dwResolveFlags & SLR_NO_UI) && 
                    PathRetryRemovable(hr, szPath))
                {
                    // do prompt for removable media if approprate
                    hr = _ResolveRemovable(hwnd, szPath);
                    fifFlags &= ~FIF_NODRIVE; // now it is back
                }

                if (FAILED_AND_NOT_CANCELED(hr))
                {
                    WIN32_FIND_DATA fd;
                    _GetFindData(&fd);  // fd input to search

                    // standard places failed, now do the search/track stuff
                    CLinkResolver *prs = new CLinkResolver(_ptracker, &fd, dwResolveFlags, dwTracker, fifFlags);
                    if (prs)
                    {
                        int id = prs->Resolve(hwnd, szPath, _pszCurFile);
                        if (IDOK == id)
                        {
                            // get fully qualified result
                            prs->GetResult(szPath, ARRAYSIZE(szPath));
                            hr = _SetPIDLPath(NULL, szPath, TRUE);
                            ASSERT(SUCCEEDED(hr) ? _bDirty : TRUE)  // must be dirty on success
                        }
                        else
                        {
                            ASSERT(!_bDirty);      // should not be dirty now
                            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        }
                        prs->Release();
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
            {
                // non file system target, validate it. this is another way to "resolve" name space
                // objects. the other method is inside of _ResolveIDList() where we do the
                // name -> pidl round trip via parse calls. that version is restricted to
                // file system parts of the name space to avoid compat issues so we end up
                // here for all other name spaces

                ULONG dwAttrib = SFGAO_VALIDATE;     // to check for existance
                hr = SHGetNameAndFlags(_pidl, SHGDN_NORMAL, szPath, ARRAYSIZE(szPath), &dwAttrib);
                if (FAILED(hr))
                {
                    if (!(dwResolveFlags & SLR_NO_UI))
                    {
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CANTFINDORIGINAL), NULL,
                                    MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND, szPath);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    }
                }
            }
        }
    }

    // if the link is dirty update it (if it was loaded from a file)
    if (SUCCEEDED(hr) && _bDirty && (dwResolveFlags & SLR_UPDATE))
        Save((LPCOLESTR)NULL, TRUE);

    ASSERT(SUCCEEDED(hr) ? S_OK == hr : TRUE);  // make sure no S_FALSE values get through

    return hr;
}


// This will just add a section to the end of the extra data -- it does
// not check to see if the section already exists, etc.
void CShellLink::_AddExtraDataSection(DATABLOCK_HEADER *peh)
{
    if (SHAddDataBlock(&_pExtraData, peh))
    {
        _bDirty = TRUE;
    }
}

// This will remove the extra data section with the given signature.
void CShellLink::_RemoveExtraDataSection(DWORD dwSig)
{
    if (SHRemoveDataBlock(&_pExtraData, dwSig))
    {
        _bDirty = TRUE;
    }
}

// Darwin and Logo3 blessings share the same structure
HRESULT CShellLink::BlessLink(LPCTSTR *ppszPath, DWORD dwSignature)
{
    EXP_DARWIN_LINK expLink;
    TCHAR szBlessID[MAX_PATH];
    int   cchBlessData;
    TCHAR *pch;

    // Copy the blessing data and advance *ppszPath to the end of the data.
    for (pch = szBlessID, cchBlessData = 0; **ppszPath != ':' && **ppszPath != '\0' && cchBlessData < MAX_PATH; pch++, (*ppszPath)++, cchBlessData++)
    {
        *pch = **ppszPath;
    }

    // Terminate the blessing data
    *pch = 0;
    
    // Set the magic flag
    if (dwSignature == EXP_DARWIN_ID_SIG)
    {
        _sld.dwFlags |= SLDF_HAS_DARWINID;
    }
    else if (dwSignature == EXP_LOGO3_ID_SIG)
    {
        _sld.dwFlags |= SLDF_HAS_LOGO3ID;
    }
    else
    {
        TraceMsg(TF_WARNING, "BlessLink was passed a bad data block signature.");
        return E_INVALIDARG;
    }

    // locate the old block, if it's there
    LPEXP_DARWIN_LINK lpNew = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, dwSignature);
    // if not, use our stack var
    if (!lpNew)
    {
        lpNew = &expLink;
        expLink.dbh.cbSize = 0;
        expLink.dbh.dwSignature = dwSignature;
    }

    SHTCharToAnsi(szBlessID, lpNew->szDarwinID, ARRAYSIZE(lpNew->szDarwinID));
    SHTCharToUnicode(szBlessID, lpNew->szwDarwinID, ARRAYSIZE(lpNew->szwDarwinID));

    // See if this is a new entry that we need to add
    if (lpNew->dbh.cbSize == 0)
    {
        lpNew->dbh.cbSize = sizeof(*lpNew);
        _AddExtraDataSection((DATABLOCK_HEADER *)lpNew);
    }

    return S_OK;
}

// in/out:
//      ppszPathIn

HRESULT CShellLink::_CheckForLinkBlessing(LPCTSTR *ppszPathIn)
{
    HRESULT hr = S_FALSE; // default to no-error, no blessing

    while (SUCCEEDED(hr) && (*ppszPathIn)[0] == ':' && (*ppszPathIn)[1] == ':')
    {
        // identify type of link blessing and perform
        if (StrCmpNI(*ppszPathIn, DARWINGUID_TAG, ARRAYSIZE(DARWINGUID_TAG) - 1) == 0)
        {
            *ppszPathIn = *ppszPathIn + ARRAYSIZE(DARWINGUID_TAG) - 1;
            hr = BlessLink(ppszPathIn, EXP_DARWIN_ID_SIG);
        }
        else if (StrCmpNI(*ppszPathIn, LOGO3GUID_TAG, ARRAYSIZE(LOGO3GUID_TAG) - 1) == 0)
        {
            *ppszPathIn = *ppszPathIn + ARRAYSIZE(LOGO3GUID_TAG) - 1;
            HRESULT hrBless = BlessLink(ppszPathIn, EXP_LOGO3_ID_SIG);
            // if the blessing failed, report the error, otherwise keep the
            // default hr == S_FALSE or the result of the Darwin blessing.
            if (FAILED(hrBless))
                hr = hrBless;
        }
        else
        {
            break;
        }
    }
        
    return hr;
}

// TODO: Remove OLD_DARWIN stuff once we have transitioned Darwin to
//       the new link blessing syntax.
#define OLD_DARWIN

int CShellLink::_IsOldDarwin(LPCTSTR pszPath)
{
#ifdef OLD_DARWIN
    int iLength = lstrlen(pszPath);
    if ((pszPath[0] == TEXT('[')) && (pszPath[iLength - 1] == TEXT(']')))
    {
        return iLength;
    }
#endif
    return 0;
}

// we have a path that is enclosed in []'s,
// so this must be a Darwin link.

HRESULT CShellLink::_SetPathOldDarwin(LPCTSTR pszPath)
{
    TCHAR szDarwinID[MAX_PATH];

    // strip off the []'s
    StringCchCopy(szDarwinID, ARRAYSIZE(szDarwinID), &pszPath[1]);
    szDarwinID[lstrlen(pszPath) - 1] = 0;

    _sld.dwFlags |= SLDF_HAS_DARWINID;

    EXP_DARWIN_LINK expLink;
    LPEXP_DARWIN_LINK pedl = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, EXP_DARWIN_ID_SIG);
    if (!pedl)
    {
        pedl = &expLink;
        expLink.dbh.cbSize = 0;
        expLink.dbh.dwSignature = EXP_DARWIN_ID_SIG;
    }

    SHTCharToAnsi(szDarwinID, pedl->szDarwinID, ARRAYSIZE(pedl->szDarwinID));
    SHTCharToUnicode(szDarwinID, pedl->szwDarwinID, ARRAYSIZE(pedl->szwDarwinID));

    // See if this is a new entry that we need to add
    if (pedl->dbh.cbSize == 0)
    {
        pedl->dbh.cbSize = sizeof(*pedl);
        _AddExtraDataSection((DATABLOCK_HEADER *)pedl);
    }

    // For darwin links, we ignore the path and pidl for now. We would
    // normally call _SetPIDLPath and SetIDList but we skip these
    // steps for darwin links because all _SetPIDLPath does is set the pidl
    // and all SetIDList does is set fd (the WIN32_FIND_DATA)
    // for the target, and we dont have a target since we are a darwin link.
    return S_OK;
}

// IShellLink::SetPath()

STDMETHODIMP CShellLink::SetPath(LPCWSTR pszPathW)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszPath;

    // NOTE: all the other Set* functions allow NULL pointer to be passed in, but this
    // one does not because it would AV. 
    if (!pszPathW)
    {
        return E_INVALIDARG;
    }
    else if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {
        return S_FALSE; // a darwin link already, then we dont allow the path to change
    }

    SHUnicodeToTChar(pszPathW, szPath, ARRAYSIZE(szPath));

    pszPath = szPath;

    int iLength = _IsOldDarwin(pszPath);
    if (iLength)
    {
        hr = _SetPathOldDarwin(pszPath);
    }
    else
    {
        // Check for ::<guid>:<data>: prefix, which signals us to bless the
        // the lnk with extra data. NOTE: we pass the &pszPath here so that this fn can 
        // advance the string pointer past the ::<guid>:<data>: sections and point to 
        // the path, if there is one.
        hr = _CheckForLinkBlessing(&pszPath);
        if (S_OK != hr)
        {
            // Check to see if the target has any expandable environment strings
            // in it.  If so, set the appropriate information in the CShellLink
            // data.
            TCHAR szExpPath[MAX_PATH];
            SHExpandEnvironmentStrings(pszPath, szExpPath, ARRAYSIZE(szExpPath));

            if (lstrcmp(szExpPath, pszPath)) 
            {
                _sld.dwFlags |= SLDF_HAS_EXP_SZ;    // link has expandable strings

                EXP_SZ_LINK expLink;
                LPEXP_SZ_LINK pel = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_LINK_SIG);
                if (!pel) 
                {
                    pel = &expLink;
                    expLink.cbSize = 0;
                    expLink.dwSignature = EXP_SZ_LINK_SIG;
                }

                // store both A and W version (for no good reason!)
                SHTCharToAnsi(pszPath, pel->szTarget, ARRAYSIZE(pel->szTarget));
                SHTCharToUnicode(pszPath, pel->swzTarget, ARRAYSIZE(pel->swzTarget));

                // See if this is a new entry that we need to add
                if (pel->cbSize == 0)
                {
                    pel->cbSize = sizeof(*pel);
                    _AddExtraDataSection((DATABLOCK_HEADER *)pel);
                }
                hr = _SetPIDLPath(NULL, szExpPath, TRUE);
            }
            else 
            {
                _sld.dwFlags &= ~SLDF_HAS_EXP_SZ;
                _RemoveExtraDataSection(EXP_SZ_LINK_SIG);

                hr = _SetPIDLPath(NULL, pszPath, TRUE);
            }

            if (FAILED(hr))
            {
                PathResolve(szExpPath, NULL, PRF_TRYPROGRAMEXTENSIONS);
                hr = _SetSimplePIDL(szExpPath);
            }
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ShellLink;
    return S_OK;
}

STDMETHODIMP CShellLink::IsDirty()
{
    return _bDirty ? S_OK : S_FALSE;
}

HRESULT LinkInfo_LoadFromStream(IStream *pstm, PLINKINFO *ppli, DWORD cbMax)
{
    DWORD dwSize;
    ULONG cbBytesRead;

    if (*ppli)
    {
        LocalFree((HLOCAL)*ppli);
        *ppli = NULL;
    }

    HRESULT hr = pstm->Read(&dwSize, sizeof(dwSize), &cbBytesRead);     // size of data
    if (SUCCEEDED(hr) && (cbBytesRead == sizeof(dwSize)))
    {
        if (dwSize <= cbMax)
        {
            if (dwSize >= sizeof(dwSize))   // must be at least this big
            {
                /* Yes.  Read remainder of LinkInfo into local memory. */
                PLINKINFO pli = (PLINKINFO)LocalAlloc(LPTR, dwSize);
                if (pli)
                {
                    *(DWORD *)pli = dwSize;         // Copy size

                    dwSize -= sizeof(dwSize);       // Read remainder of LinkInfo

                    hr = pstm->Read(((DWORD *)pli) + 1, dwSize, &cbBytesRead);
                    // Note that if the linkinfo is invalid, we still return S_OK
                    // because linkinfo is not essential to the shortcut
                    if (SUCCEEDED(hr) && (cbBytesRead == dwSize) && IsValidLinkInfo(pli))
                       *ppli = pli; // LinkInfo read successfully
                    else
                       LocalFree((HLOCAL)pli);
                }
            }
        }
        else
        {
            // This will happen if the .lnk is corrupted and the size in the stream
            // is larger than the physical file on disk.
            hr = E_FAIL;
        }
    }
    return hr;
}

// Decodes the CSIDL_ relative target pidl

void CShellLink::_DecodeSpecialFolder()
{
    LPEXP_SPECIAL_FOLDER pData = (LPEXP_SPECIAL_FOLDER)SHFindDataBlock(_pExtraData, EXP_SPECIAL_FOLDER_SIG);
    if (pData)
    {
        LPITEMIDLIST pidlFolder = SHCloneSpecialIDList(NULL, pData->idSpecialFolder, FALSE);
        if (pidlFolder)
        {
            ASSERT(IS_VALID_PIDL(_pidl));

            LPITEMIDLIST pidlTarget = _ILSkip(_pidl, pData->cbOffset);
            LPITEMIDLIST pidlSanityCheck = _pidl;

            while (!ILIsEmpty(pidlSanityCheck) && (pidlSanityCheck < pidlTarget))
            {
                // We go one step at a time until pidlSanityCheck == pidlTarget.  If we reach the end
                // of pidlSanityCheck, or if we go past pidlTarget, before this condition is met then
                // we have an invalid pData->cbOffset.
                pidlSanityCheck = _ILNext(pidlSanityCheck);
            }

            if (pidlSanityCheck == pidlTarget)
            {
                LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlTarget);
                if (pidlNew)
                {
                    _SetPIDLPath(pidlNew, NULL, FALSE);
                    ILFree(pidlNew);
                }
            }
            ILFree(pidlFolder);
        }

        // in case above stuff fails for some reason
        _RemoveExtraDataSection(EXP_SPECIAL_FOLDER_SIG);
    }
}


HRESULT CShellLink::_UpdateIconFromExpIconSz()
{
    HRESULT hr = S_FALSE;
    
    // only try once per link instance
    if (!_bExpandedIcon)
    {
        TCHAR szExpIconPath[MAX_PATH];

        if (_sld.dwFlags & SLDF_HAS_EXP_ICON_SZ)
        {
            LPEXP_SZ_LINK pszl = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_ICON_SIG);
            if (pszl)
            {
                if (SHExpandEnvironmentStringsW(pszl->swzTarget, szExpIconPath, ARRAYSIZE(szExpIconPath)) &&
                    PathFileExists(szExpIconPath))
                {
                    hr = S_OK;
                }
            }
            else
            {
                ASSERTMSG(FALSE, "CShellLink::_UpdateIconAtLoad - lnk has SLDF_HAS_EXP_ICON_SZ but no actual datablock!!");
                hr = E_FAIL;
            }
        }

        if (hr == S_OK)
        {
            // update _pszIconLocation if its different from the expanded string
            if (lstrcmpi(_pszIconLocation, szExpIconPath) != 0)
            {
                _SetField(&_pszIconLocation, szExpIconPath);
                _bDirty = TRUE;
            }
        }

        _bExpandedIcon = TRUE;
    }

    return hr;
}

STDMETHODIMP CShellLink::Load(IStream *pstm)
{
    ULONG cbBytes;
    DWORD cbSize;

    TraceMsg(TF_DEBUGLINKCODE, "Loading link from stream.");

    _ResetPersistData();        // clear out our state

    HRESULT hr = pstm->Read(&cbSize, sizeof(cbSize), &cbBytes);
    if (SUCCEEDED(hr))
    {
        if (cbBytes == sizeof(cbSize))
        {
            if (cbSize == sizeof(_sld))
            {
                hr = pstm->Read((LPBYTE)&_sld + sizeof(cbSize), sizeof(_sld) - sizeof(cbSize), &cbBytes);
                if (SUCCEEDED(hr) && cbBytes == (sizeof(_sld) - sizeof(cbSize)) && IsEqualGUID(_sld.clsid, CLSID_ShellLink))
                {
                    _sld.cbSize = sizeof(_sld);

                    switch (_sld.iShowCmd) 
                    {
                        case SW_SHOWNORMAL:
                        case SW_SHOWMINNOACTIVE:
                        case SW_SHOWMAXIMIZED:
                        break;

                        default:
                            DebugMsg(DM_TRACE, TEXT("Shortcut Load, mapping bogus ShowCmd: %d"), _sld.iShowCmd);
                            _sld.iShowCmd = SW_SHOWNORMAL;
                        break;
                    }

                    // save so we can generate notify on save
                    _wOldHotkey = _sld.wHotkey;   

                    // read all of the members

                    if (_sld.dwFlags & SLDF_HAS_ID_LIST)
                    {
                        // ILLoadFromStream() verifies the integrity of the pidl
                        // so that even if the file has been corrupted we dont fault here
                        hr = ILLoadFromStream(pstm, &_pidl);
                        if (FAILED(hr))
                        {
                            // In theory this will only happen due to file corruption, but I've seen this too
                            // often not to suspect that we might be doing something wrong.
                            // turn off the flag, which we know is on to start with

                            _sld.dwFlags &= ~SLDF_HAS_ID_LIST;
                            Pidl_Set(&_pidl, NULL);
                            _bDirty = TRUE;

                            // continue as though there was no SLDF_HAS_ID_LIST flag to start with
                            // REVIEW: should we only continue if certain other sections are also included
                            // in the link?  What will happen if SLDF_HAS_ID_LIST was the only data set for
                            // this link file?  We would get a null link. 
                        }
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_LINK_INFO))
                    {
                        DWORD cbMaxRead;
                        // We need to worry about link files that are corrupt.  So read the link
                        // size so we don't keep reading for ever in case the stream has an invalid
                        // size in it.
                        // We need to check if it is a valid pidl because hackers will
                        // try to create invalid pidls to crash the system or run buffer
                        // over run attacks.  -BryanSt 

                        STATSTG stat;
                        if (SUCCEEDED(pstm->Stat(&stat, STATFLAG_NONAME)))
                            cbMaxRead = stat.cbSize.LowPart;
                        else
                            cbMaxRead = 0xFFFFFFFF;

                        hr = LinkInfo_LoadFromStream(pstm, &_pli, cbMaxRead);
                        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_FORCE_NO_LINKINFO))
                        {
                            _FreeLinkInfo();    // labotimizing link
                        }
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_NAME))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Name...");
                        hr = Str_SetFromStream(pstm, &_pszName, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_RELPATH))
                    {
                        hr = Str_SetFromStream(pstm, &_pszRelPath, _sld.dwFlags & SLDF_UNICODE);
                        if (!_pidl && SUCCEEDED(hr))
                        {
                            TCHAR szTmp[MAX_PATH];
                            if (_GetRelativePath(szTmp))
                                _SetPIDLPath(NULL, szTmp, TRUE);
                        }
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_WORKINGDIR))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Working Dir...");
                        hr = Str_SetFromStream(pstm, &_pszWorkingDir, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ARGS))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Arguments...");
                        hr = Str_SetFromStream(pstm, &_pszArgs, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ICONLOCATION))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Icon Location...");
                        hr = Str_SetFromStream(pstm, &_pszIconLocation, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Data Block...");
                        hr = SHReadDataBlockList(pstm, &_pExtraData);
                    }

                    // reset the darwin info on load
                    if (_sld.dwFlags & SLDF_HAS_DARWINID)
                    {
                        // since darwin links rely so heavily on the icon, do this now
                        _UpdateIconFromExpIconSz();

                        // we should never have a darwin link that is missing
                        // the icon path
                        if (_pszIconLocation)
                        {
                            // we always put back the icon path as the pidl at
                            // load time since darwin could change the path or
                            // to the app (eg: new version of the app)
                            TCHAR szPath[MAX_PATH];
                            
                            // expand any env. strings in the icon path before
                            // creating the pidl.
                            SHExpandEnvironmentStrings(_pszIconLocation, szPath, ARRAYSIZE(szPath));
                            _SetPIDLPath(NULL, szPath, FALSE);
                        }
                    }
                    else
                    {
                        // The Darwin stuff above creates a new pidl, which
                        // would cause this stuff to blow up. We should never
                        // get both at once, but let's be extra robust...
                        //
                        // Since we store the offset into the pidl here, and
                        // the pidl can change for various reasons, we can
                        // only do this once at load time. Do it here.
                        //
                        if (_pidl)
                        {
                            _DecodeSpecialFolder();
                        }
                    }

                    if (SUCCEEDED(hr) && _ptracker)
                    {
                        // load the tracker from extra data
                        EXP_TRACKER *pData = (LPEXP_TRACKER)SHFindDataBlock(_pExtraData, EXP_TRACKER_SIG);
                        if (pData) 
                        {
                            hr = _ptracker->Load(pData->abTracker, pData->cbSize - sizeof(EXP_TRACKER));
                            if (FAILED(hr))
                            {
                                // Failure of the Tracker isn't just cause to make
                                // the shortcut unusable.  So just re-init it and move on.
                                _ptracker->InitNew();
                                hr = S_OK;
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                        _bDirty = FALSE;
                }
                else
                {
                    DebugMsg(DM_TRACE, TEXT("failed to read link struct"));
                    hr = E_FAIL;      // invalid file size
                }
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("invalid length field in link:%d"), cbBytes);
                hr = E_FAIL;  // invalid file size
            }
        }
        else if (cbBytes == 0)
        {
            _sld.cbSize = 0;   // zero length file is ok
        }
        else
        {
            hr = E_FAIL;      // invalid file size
        }
    }
    return hr;
}

// set the relative path
// in:
//      pszRelSource    fully qualified path to a file (must be file, not directory)
//                      to be used to find a relative path with the link target.
//
// returns:
//      S_OK            relative path is set
//      S_FALSE         pszPathRel is not relative to the destination or the
//                      destionation is not a file (could be link to a pidl only)
// notes:
//      set the dirty bit if this is a new relative path
//

HRESULT CShellLink::_SetRelativePath(LPCTSTR pszRelSource)
{
    TCHAR szPath[MAX_PATH], szDest[MAX_PATH];

    ASSERT(!PathIsRelative(pszRelSource));

    if (_pidl == NULL || !SHGetPathFromIDList(_pidl, szDest))
    {
        DebugMsg(DM_TRACE, TEXT("SetRelative called on non path link"));
        return S_FALSE;
    }

    // assume pszRelSource is a file, not a directory
    if (PathRelativePathTo(szPath, pszRelSource, 0, szDest, _sld.dwFileAttributes))
    {
        pszRelSource = szPath;
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("paths are not relative"));
        pszRelSource = NULL;    // clear the stored relative path below
    }

    _SetField(&_pszRelPath, pszRelSource);

    return S_OK;
}

BOOL CShellLink::_EncodeSpecialFolder()
{
    BOOL bRet = FALSE;

    if (_pidl)
    {
        // make sure we don't already have a EXP_SPECIAL_FOLDER_SIG data block, otherwise we would
        // end up with two of these and the first one would win on read.
        // If you hit this ASSERT in a debugger, contact ToddB with a remote.  We need to figure out
        // why we are corrupting our shortcuts.
        ASSERT(NULL == SHFindDataBlock(_pExtraData, EXP_SPECIAL_FOLDER_SIG));

        EXP_SPECIAL_FOLDER exp;
        exp.idSpecialFolder = GetSpecialFolderParentIDAndOffset(_pidl, &exp.cbOffset);
        if (exp.idSpecialFolder)
        {
            exp.cbSize = sizeof(exp);
            exp.dwSignature = EXP_SPECIAL_FOLDER_SIG;

            _AddExtraDataSection((DATABLOCK_HEADER *)&exp);
            bRet = TRUE;
        }
    }

    return bRet;
}

HRESULT LinkInfo_SaveToStream(IStream *pstm, PCLINKINFO pcli)
{
    ULONG cbBytes;
    DWORD dwSize = *(DWORD *)pcli;    // Get LinkInfo size

    HRESULT hr = pstm->Write(pcli, dwSize, &cbBytes);
    if (SUCCEEDED(hr) && (cbBytes != dwSize))
        hr = E_FAIL;
    return hr;
}


//
// Replaces the tracker extra data with current tracker state
//
HRESULT CShellLink::_UpdateTracker()
{
    ULONG ulSize = _ptracker->GetSize();

    if (!_ptracker->IsLoaded())
    {
        _RemoveExtraDataSection(EXP_TRACKER_SIG);
        return S_OK;
    }

    if (!_ptracker->IsDirty())
    {
        return S_OK;
    }

    HRESULT hr = E_FAIL;
    // Make sure the Tracker size is a multiple of DWORDs.
    // If we hit this assert then we would have mis-aligned stuff stored in the extra data.
    //
    if (EVAL(0 == (ulSize & 3)))
    {
        EXP_TRACKER *pExpTracker = (EXP_TRACKER *)LocalAlloc(LPTR, ulSize + sizeof(DATABLOCK_HEADER));
        if (pExpTracker)
        {
            _RemoveExtraDataSection(EXP_TRACKER_SIG);
        
            pExpTracker->cbSize = ulSize + sizeof(DATABLOCK_HEADER);
            pExpTracker->dwSignature = EXP_TRACKER_SIG;
            _ptracker->Save(pExpTracker->abTracker, ulSize);
        
            _AddExtraDataSection((DATABLOCK_HEADER *)&pExpTracker->cbSize);
            DebugMsg(DM_TRACE, TEXT("_UpdateTracker: EXP_TRACKER at %08X."), &pExpTracker->cbSize);

            LocalFree(pExpTracker);
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CShellLink::Save(IStream *pstm, BOOL fClearDirty)
{
    ULONG cbBytes;
    BOOL fEncode;

    _sld.cbSize = sizeof(_sld);
    _sld.clsid = CLSID_ShellLink;
    //  _sld.dwFlags = 0;
    // We do the following & instead of zeroing because the SLDF_HAS_EXP_SZ and
    // SLDF_RUN_IN_SEPARATE and SLDF_RUNAS_USER and SLDF_HAS_DARWINID are passed to us and are valid,
    // the others can be reconstructed below, but these three can not, so we need to
    // preserve them!

    _sld.dwFlags &= (SLDF_HAS_EXP_SZ        | 
                     SLDF_HAS_EXP_ICON_SZ   |
                     SLDF_RUN_IN_SEPARATE   |
                     SLDF_HAS_DARWINID      |
                     SLDF_HAS_LOGO3ID       |
                     SLDF_RUNAS_USER        |
                     SLDF_RUN_WITH_SHIMLAYER);

    if (_pszRelSource)
    {
        _SetRelativePath(_pszRelSource);
    }

    _sld.dwFlags |= SLDF_UNICODE;

    fEncode = FALSE;
    
    if (_pidl)
    {
        _sld.dwFlags |= SLDF_HAS_ID_LIST;

        // we dont want to have special folder tracking for darwin links
        if (!(_sld.dwFlags & SLDF_HAS_DARWINID))
            fEncode = _EncodeSpecialFolder();
    }

    if (_pli)
        _sld.dwFlags |= SLDF_HAS_LINK_INFO;

    if (_pszName && _pszName[0])
        _sld.dwFlags |= SLDF_HAS_NAME;
    if (_pszRelPath && _pszRelPath[0])
        _sld.dwFlags |= SLDF_HAS_RELPATH;
    if (_pszWorkingDir && _pszWorkingDir[0])
        _sld.dwFlags |= SLDF_HAS_WORKINGDIR;
    if (_pszArgs && _pszArgs[0])
        _sld.dwFlags |= SLDF_HAS_ARGS;
    if (_pszIconLocation && _pszIconLocation[0])
        _sld.dwFlags |= SLDF_HAS_ICONLOCATION;

    HRESULT hr = pstm->Write(&_sld, sizeof(_sld), &cbBytes);

    if (SUCCEEDED(hr) && (cbBytes == sizeof(_sld)))
    {
        if (_pidl)
            hr = ILSaveToStream(pstm, _pidl);

        if (SUCCEEDED(hr) && _pli)
            hr = LinkInfo_SaveToStream(pstm, _pli);

        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_NAME))
            hr = Stream_WriteString(pstm, _pszName, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_RELPATH))
            hr = Stream_WriteString(pstm, _pszRelPath, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_WORKINGDIR))
            hr = Stream_WriteString(pstm, _pszWorkingDir, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ARGS))
            hr = Stream_WriteString(pstm, _pszArgs, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ICONLOCATION))
            hr = Stream_WriteString(pstm, _pszIconLocation, _sld.dwFlags & SLDF_UNICODE);

        if (SUCCEEDED(hr) && _ptracker && _ptracker->WasLoadedAtLeastOnce())
            hr = _UpdateTracker();

        if (SUCCEEDED(hr))
        {
            hr = SHWriteDataBlockList(pstm, _pExtraData);
        }

        if (SUCCEEDED(hr) && fClearDirty)
            _bDirty = FALSE;
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("Failed to write link"));
        hr = E_FAIL;
    }

    if (fEncode)
    {
        _RemoveExtraDataSection(EXP_SPECIAL_FOLDER_SIG);
    }

    return hr;
}

STDMETHODIMP  CShellLink::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    pcbSize->LowPart = 16 * 1024;       // 16k?  who knows...
    pcbSize->HighPart = 0;
    return S_OK;
}

BOOL PathIsPif(LPCTSTR pszPath)
{
    return lstrcmpi(PathFindExtension(pszPath), TEXT(".pif")) == 0;
}

HRESULT CShellLink::_LoadFromPIF(LPCTSTR pszPath)
{
    HANDLE hPif = PifMgr_OpenProperties(pszPath, NULL, 0, 0);
    if (hPif == 0)
        return E_FAIL;

    PROPPRG ProgramProps = {0};

    if (!PifMgr_GetProperties(hPif, (LPSTR)MAKEINTATOM(GROUP_PRG), &ProgramProps, sizeof(ProgramProps), 0))
    {
        return E_FAIL;
    }

    SetDescription(ProgramProps.achTitle);
    SetWorkingDirectory(ProgramProps.achWorkDir);
    SetArguments(PathGetArgsA(ProgramProps.achCmdLine));
    SetHotkey(ProgramProps.wHotKey);
    SetIconLocation(ProgramProps.achIconFile, ProgramProps.wIconIndex);

    TCHAR szTemp[MAX_PATH];
    SHAnsiToTChar(ProgramProps.achCmdLine, szTemp, ARRAYSIZE(szTemp));

    PathRemoveArgs(szTemp);

    // If this is a network path, we want to create a simple pidl
    // instead of a full pidl to circumvent net hits
    if (PathIsNetworkPath(szTemp))
    {
        _SetSimplePIDL(szTemp);
    }
    else
    {
        _SetPIDLPath(NULL, szTemp, FALSE);
    }

    if (ProgramProps.flPrgInit & PRGINIT_MINIMIZED)
    {
        SetShowCmd(SW_SHOWMINNOACTIVE);
    }
    else if (ProgramProps.flPrgInit & PRGINIT_MAXIMIZED)
    {
        SetShowCmd(SW_SHOWMAXIMIZED);
    }
    else
    {
        SetShowCmd(SW_SHOWNORMAL);
    }

    PifMgr_CloseProperties(hPif, 0);

    _bDirty = FALSE;

    return S_OK;
}


HRESULT CShellLink::_LoadFromFile(LPCTSTR pszPath)
{
    HRESULT hr;

    if (PathIsPif(pszPath))
    {
        hr = _LoadFromPIF(pszPath);
    }
    else
    {
        IStream *pstm;
        hr = SHCreateStreamOnFile(pszPath, STGM_READ | STGM_SHARE_DENY_WRITE, &pstm);
        if (SUCCEEDED(hr))
        {
            hr = Load(pstm);
            pstm->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];

        if (_pidl && SHGetPathFromIDList(_pidl, szPath) && !lstrcmpi(szPath, pszPath))
        {
            DebugMsg(DM_TRACE, TEXT("Link points to itself, aaahhh!"));
            hr = E_FAIL;
        }
        else
        {
            Str_SetPtr(&_pszCurFile, pszPath);
        }
    }
    else if (IsFolderShortcut(pszPath))
    {
        // this support here is a hack to make Office file open work. that code
        // depends on loading folder shortcuts using CLSID_ShellLink. this is because
        // we lie about the attributes of folder shortcuts to office to make other
        // stuff work.

        TCHAR szPath[MAX_PATH];
        PathCombine(szPath, pszPath, TEXT("target.lnk"));

        IStream *pstm;
        hr = SHCreateStreamOnFile(szPath, STGM_READ | STGM_SHARE_DENY_WRITE, &pstm);
        if (SUCCEEDED(hr))
        {
            hr = Load(pstm);
            pstm->Release();
        }
    }

    ASSERT(!_bDirty);

    return hr;
}

STDMETHODIMP CShellLink::Load(LPCOLESTR pwszFile, DWORD grfMode)
{
    HRESULT hr = E_INVALIDARG;
    
    TraceMsg(TF_DEBUGLINKCODE, "Loading link from file %ls.", pwszFile);

    if (pwszFile) 
    {
        hr = _LoadFromFile(pwszFile);

        // convert the succeeded code to S_OK so that THOSE DUMB apps like HitNrun 
        // who do hr == 0 don't fail miserably.

        if (SUCCEEDED(hr))
            hr = S_OK;
    }
    
    return hr;
}

HRESULT CShellLink::_SaveAsLink(LPCTSTR pszPath)
{
    TraceMsg(TF_DEBUGLINKCODE, "Save link to file %s.", pszPath);

    IStream *pstm;
    HRESULT hr = SHCreateStreamOnFile(pszPath, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstm);
    if (SUCCEEDED(hr))
    {
        if (_pszRelSource == NULL)
            _SetRelativePath(pszPath);

        hr = Save(pstm, TRUE);

        if (SUCCEEDED(hr))
        {
            hr = pstm->Commit(0);
        }

        pstm->Release();

        if (FAILED(hr))
        {
            DeleteFile(pszPath);
        }
    }

    return hr;
}

BOOL RenameChangeExtension(LPTSTR pszPathSave, LPCTSTR pszExt, BOOL fMove)
{
    TCHAR szPathSrc[MAX_PATH];

    StrCpyN(szPathSrc, pszPathSave, ARRAYSIZE(szPathSrc));
    PathRenameExtension(pszPathSave, pszExt);

    // this may fail because the source file does not exist, but we dont care
    if (fMove && lstrcmpi(szPathSrc, pszPathSave) != 0)
    {
        DWORD dwAttrib;

        PathYetAnotherMakeUniqueName(pszPathSave, pszPathSave, NULL, NULL);
        dwAttrib = GetFileAttributes(szPathSrc);
        if ((dwAttrib == 0xFFFFFFFF) || (dwAttrib & FILE_ATTRIBUTE_READONLY))
        {
            // Source file is read only, don't want to change the extension
            // because we won't be able to write any changes to the file...
            return FALSE;
        }
        Win32MoveFile(szPathSrc, pszPathSave, FALSE);
    }

    return TRUE;
}


// out:
//      pszDir  MAX_PATH path to get directory, maybe with env expanded
//
// returns:
//      TRUE    has a working directory, pszDir filled in.
//      FALSE   no working dir, if the env expands to larger than the buffer size (MAX_PATH)
//              this will be returned (FALSE)
//

BOOL CShellLink::_GetWorkingDir(LPTSTR pszDir)
{
    *pszDir = 0;

    if (_pszWorkingDir && _pszWorkingDir[0])
    {
        return (SHExpandEnvironmentStrings(_pszWorkingDir, pszDir, MAX_PATH) != 0);
    }

    return FALSE;
}

HRESULT CShellLink::_SaveAsPIF(LPCTSTR pszPath, BOOL fPath)
{
    HANDLE hPif;
    PROPPRG ProgramProps;
    HRESULT hr;
    TCHAR szDir[MAX_PATH];
    TCHAR achPath[MAX_PATH];

    //
    // get filename and convert it to a short filename
    //
    if (fPath)
    {
        hr = GetPath(achPath, ARRAYSIZE(achPath), NULL, 0);
        PathGetShortPath(achPath);
        
        ASSERT(!PathIsPif(achPath));
        ASSERT(LOWORD(GetExeType(achPath)) == 0x5A4D);
        ASSERT(PathIsPif(pszPath));
        ASSERT(hr == S_OK);
    }
    else
    {
        StrCpyN(achPath, pszPath, ARRAYSIZE(achPath));
    }

    DebugMsg(DM_TRACE, TEXT("_SaveAsPIF(%s,%s)"), achPath, pszPath);

#if 0
    //
    // we should use OPENPROPS_INHIBITPIF to prevent PIFMGR from making a
    // temp .pif file in \windows\pif but it does not work now.
    //
    hPif = PifMgr_OpenProperties(achPath, pszPath, 0, OPENPROPS_INHIBITPIF);
#else
    hPif = PifMgr_OpenProperties(achPath, pszPath, 0, 0);
#endif

    if (hPif == 0)
    {
        return E_FAIL;
    }

    if (!PifMgr_GetProperties(hPif,(LPSTR)MAKEINTATOM(GROUP_PRG), &ProgramProps, sizeof(ProgramProps), 0))
    {
        DebugMsg(DM_TRACE, TEXT("_SaveToPIF: PifMgr_GetProperties *failed*"));
        hr = E_FAIL;
        goto Error1;
    }

    // Set a title based on the link name.
    if (_pszName && _pszName[0])
    {
        SHTCharToAnsi(_pszName, ProgramProps.achTitle, sizeof(ProgramProps.achTitle));
    }

    // if no work dir. is given default to the dir of the app.
    if (_GetWorkingDir(szDir))
    {

        TCHAR szTemp[PIFDEFPATHSIZE];

        GetShortPathName(szDir, szTemp, ARRAYSIZE(szTemp));
        SHTCharToAnsi(szTemp, ProgramProps.achWorkDir, ARRAYSIZE(ProgramProps.achWorkDir));
    }
    else if (fPath && !PathIsUNC(achPath))
    {
        TCHAR szTemp[PIFDEFPATHSIZE];
        StrCpyN(szTemp, achPath, ARRAYSIZE(szTemp));
        PathRemoveFileSpec(szTemp);
        SHTCharToAnsi(szTemp, ProgramProps.achWorkDir, ARRAYSIZE(ProgramProps.achWorkDir));
    }

    // And for those network share points we need to quote blanks...
    PathQuoteSpaces(achPath);

    // add the args to build the full command line
    if (_pszArgs && _pszArgs[0])
    {
        StringCchCat(achPath, ARRAYSIZE(achPath), c_szSpace);
        StringCchCat(achPath, ARRAYSIZE(achPath), _pszArgs);
    }

    if (fPath)
    {
        SHTCharToAnsi(achPath, ProgramProps.achCmdLine, ARRAYSIZE(ProgramProps.achCmdLine));
    }

    if (_sld.iShowCmd == SW_SHOWMAXIMIZED)
    {
        ProgramProps.flPrgInit |= PRGINIT_MAXIMIZED;
    }
    if ((_sld.iShowCmd == SW_SHOWMINIMIZED) || (_sld.iShowCmd == SW_SHOWMINNOACTIVE))
    {    
        ProgramProps.flPrgInit |= PRGINIT_MINIMIZED;
    }

    if (_sld.wHotkey)
    {
        ProgramProps.wHotKey = _sld.wHotkey;
    }

    if (_pszIconLocation && _pszIconLocation[0])
    {
        SHTCharToAnsi(_pszIconLocation, ProgramProps.achIconFile, ARRAYSIZE(ProgramProps.achIconFile));
        ProgramProps.wIconIndex = (WORD) _sld.iIcon;
    }

    if (!PifMgr_SetProperties(hPif, (LPSTR)MAKEINTATOM(GROUP_PRG), &ProgramProps, sizeof(ProgramProps), 0))
    {
        DebugMsg(DM_TRACE, TEXT("_SaveToPIF: PifMgr_SetProperties *failed*"));
        hr = E_FAIL;
    } 
    else 
    {
        hr = S_OK;
    }

    _bDirty = FALSE;

Error1:
    PifMgr_CloseProperties(hPif, 0);
    return hr;
}

// This will allow global hotkeys to be available immediately instead
// of having to wait for the StartMenu to pick them up.
// Similarly this will remove global hotkeys immediately if req.

const UINT c_rgHotKeyFolders[] = {
    CSIDL_PROGRAMS,
    CSIDL_COMMON_PROGRAMS,
    CSIDL_STARTMENU,
    CSIDL_COMMON_STARTMENU,
    CSIDL_DESKTOPDIRECTORY,
    CSIDL_COMMON_DESKTOPDIRECTORY,
};

void HandleGlobalHotkey(LPCTSTR pszFile, WORD wHotkeyOld, WORD wHotkeyNew)
{
    if (PathIsEqualOrSubFolderOf(pszFile, c_rgHotKeyFolders, ARRAYSIZE(c_rgHotKeyFolders)))
    {
        // Find tray?
        HWND hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), 0);
        if (hwndTray)
        {
            // Yep.
            if (wHotkeyOld)
                SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wHotkeyOld, 0);
            if (wHotkeyNew)
            {
                ATOM atom = GlobalAddAtom(pszFile);
                if (atom)
                {
                    SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wHotkeyNew, (LPARAM)atom);
                    GlobalDeleteAtom(atom);
                }
            }
        }
    }
}

HRESULT CShellLink::_SaveToFile(LPTSTR pszPathSave, BOOL fRemember)
{
    HRESULT hr = E_FAIL;
    BOOL fDosApp;
    BOOL fFile;
    TCHAR szPathSrc[MAX_PATH];
    BOOL fWasSameFile = _pszCurFile && (lstrcmpi(pszPathSave, _pszCurFile) == 0);
    BOOL bFileExisted = PathFileExistsAndAttributes(pszPathSave, NULL);

    // when saving darwin links we dont want to resolve the path
    if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {
        fRemember = FALSE;
        hr = _SaveAsLink(pszPathSave);
        goto Update;
    }

    GetPath(szPathSrc, ARRAYSIZE(szPathSrc), NULL, 0);

    fFile = !(_sld.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
    fDosApp = fFile && LOWORD(GetExeType(szPathSrc)) == 0x5A4D;

    // handle a link to link case. (or link to pif)
    //
    // NOTE: we loose all new attributes, including icon, but it's been this way since Win95.
    if (fFile && (PathIsPif(szPathSrc) || PathIsLnk(szPathSrc)))
    {
        if (RenameChangeExtension(pszPathSave, PathFindExtension(szPathSrc), fWasSameFile))
        {
            if (CopyFile(szPathSrc, pszPathSave, FALSE))
            {
                if (PathIsPif(pszPathSave))
                    hr = _SaveAsPIF(pszPathSave, FALSE);
                else
                    hr = S_OK;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else if (fDosApp)
    {
        //  if the linked to file is a DOS app, we need to write a .PIF file
        if (RenameChangeExtension(pszPathSave, TEXT(".pif"), fWasSameFile))
        {
            hr = _SaveAsPIF(pszPathSave, TRUE);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        //  else write a link file
        if (PathIsPif(pszPathSave))
        {
            if (!RenameChangeExtension(pszPathSave, TEXT(".lnk"), fWasSameFile))
            {
                hr = E_FAIL;
                goto Update;
            }
        }
        hr = _SaveAsLink(pszPathSave);
    }

Update:
    if (SUCCEEDED(hr))
    {
        // Knock out file close
        SHChangeNotify(bFileExisted ? SHCNE_UPDATEITEM : SHCNE_CREATE, SHCNF_PATH, pszPathSave, NULL);
        SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, pszPathSave, NULL);

        if (_wOldHotkey != _sld.wHotkey)
        {
            HandleGlobalHotkey(pszPathSave, _wOldHotkey, _sld.wHotkey);
        }

        if (fRemember)
        {
            Str_SetPtr(&_pszCurFile, pszPathSave);
        }
    }

    return hr;
}

STDMETHODIMP CShellLink::Save(LPCOLESTR pwszFile, BOOL fRemember)
{
    TCHAR szSavePath[MAX_PATH];

    if (pwszFile == NULL)
    {
        if (_pszCurFile == NULL)
        {
            // fail
            return E_FAIL;
        }

        StringCchCopy(szSavePath, ARRAYSIZE(szSavePath), _pszCurFile);
    }
    else
    {
        SHUnicodeToTChar(pwszFile, szSavePath, ARRAYSIZE(szSavePath));
    }

    return _SaveToFile(szSavePath, fRemember);
}

STDMETHODIMP CShellLink::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

STDMETHODIMP CShellLink::GetCurFile(LPOLESTR *ppszFile)
{
    if (_pszCurFile == NULL)
    {
        *ppszFile = NULL;
        return S_FALSE;
    }
    return SHStrDup(_pszCurFile, ppszFile);
}

STDMETHODIMP CShellLink::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    HRESULT hr;

    ASSERT(_sld.iShowCmd == SW_SHOWNORMAL);

    if (pdtobj)
    {
        STGMEDIUM medium = {0};
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pdtobj->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath));
            hr = _LoadFromFile(szPath);

            ReleaseStgMedium(&medium);
        }
        else
        {
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                IShellFolder *psf;
                hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, IDA_GetIDListPtr(pida, -1), &psf));
                if (SUCCEEDED(hr))
                {
                    IStream *pstm;
                    hr = psf->BindToStorage(IDA_GetIDListPtr(pida, 0), NULL, IID_PPV_ARG(IStream, &pstm));
                    if (SUCCEEDED(hr))
                    {
                        hr = Load(pstm);
                        pstm->Release();
                    }
                    psf->Release();
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI CDarwinContextMenuCB::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU:
        // S_FALSE indicates no need to get verbs from extensions.

        hr = S_FALSE;
        break;

    case DFM_MERGECONTEXTMENU_TOP:
    {
        UINT uFlags = (UINT)wParam;
        LPQCMINFO pqcm = (LPQCMINFO)lParam;

        CDefFolderMenu_MergeMenu(HINST_THISDLL,
                                 (uFlags & CMF_EXTENDEDVERBS) ? MENU_GENERIC_CONTROLPANEL_VERBS : MENU_GENERIC_OPEN_VERBS,  // if extended verbs then add "Run as..."
                                 0,
                                 pqcm);

        SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);
        break;
    }

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    // NTRAID94991-2000/03/16-MikeSh- DFM_MAPCOMMANDNAME DFM_GETVERB[A|W] not implemented

    case DFM_INVOKECOMMANDEX:
        switch (wParam)
        {
        case FSIDM_OPENPRN:
        case FSIDM_RUNAS:
            hr = PidlFromDataObject(pdtobj, &pidl);
            if (SUCCEEDED(hr))
            {
                CMINVOKECOMMANDINFOEX iciex;
                SHELLEXECUTEINFO sei;
                DFMICS* pdfmics = (DFMICS *)lParam;
                LPVOID pvFree;

                ICI2ICIX(pdfmics->pici, &iciex, &pvFree);
                ICIX2SEI(&iciex, &sei);
                sei.fMask |= SEE_MASK_IDLIST;
                sei.lpIDList = pidl;

                if (wParam == FSIDM_RUNAS)
                {
                    // we only set the verb in the "Run As..." case since we want
                    // the "open" verb for darwin links to really execute the default action.
                    sei.lpVerb = TEXT("runas");
                }

                if (ShellExecuteEx(&sei))
                {
                    // Tell UEM that we ran a Darwin app
                    if (_szProductCode[0])
                    {
                        UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)_szProductCode);
                    }
                }
                
                ILFree(pidl);
                if (pvFree)
                {
                    LocalFree(pvFree);
                }
            }
            // Never return E_NOTIMPL or defcm will try to do a default thing
            if (hr == E_NOTIMPL)
                hr = E_FAIL;
            break;


        default:
            // This is common menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break; // DFM_INVOKECOMMANDEX

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

//
// CShellLink::CreateDarwinContextMenuForPidl (non-virtual)
//
// Worker function for CShellLink::CreateDarwinContextMenu that tries
// to create the context menu for the specified pidl.

HRESULT CShellLink::_CreateDarwinContextMenuForPidl(HWND hwnd, LPCITEMIDLIST pidlTarget, IContextMenu **pcmOut)
{
    LPITEMIDLIST pidlFolder, pidlItem;

    HRESULT hr = SHILClone(pidlTarget, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        if (ILRemoveLastID(pidlFolder) &&
            (pidlItem = ILFindLastID(pidlTarget)))
        {
            IShellFolder *psf;
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));
            if (SUCCEEDED(hr))
            {
                if (!_pcbDarwin)
                {
                    _pcbDarwin = new CDarwinContextMenuCB();
                }
                if (_pcbDarwin)
                {
                    HKEY ahkeys[1] = { NULL };
                    RegOpenKey(HKEY_CLASSES_ROOT, TEXT("MSILink"), &ahkeys[0]);
                    hr = CDefFolderMenu_Create2Ex(
                                pidlFolder,
                                hwnd,
                                1, (LPCITEMIDLIST *)&pidlItem, psf, _pcbDarwin,
                                ARRAYSIZE(ahkeys), ahkeys, pcmOut);

                    SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                psf->Release();
            }
        }
        else
        {
            // Darwin shortcut to the desktop?  I don't think so.
            hr = E_FAIL;
        }
        ILFree(pidlFolder);
    }
    return hr;
}

//
// CShellLink::CreateDarwinContextMenu (non-virtual)
//
// Creates a context menu for a Darwin shortcut.  This is special because
// the ostensible target is an .EXE file, but in reality it could be
// anything.  (It's just an .EXE file until the shortcut gets resolved.)
// Consequently, we can't create a real context menu for the item because
// we don't know what kind of context menu to create.  We just cook up
// a generic-looking one.
//
// Bonus annoyance: _pidl might be invalid, so you need to have
// a fallback plan if it's not there.  We will use c_idlDrives as our
// fallback.  That's a pidl guaranteed actually to exist.
//
// Note that this means you can't invoke a command on the fallback object,
// but that's okay because ShellLink will always resolve the object to
// a real file and create a new context menu before invoking.
//

HRESULT CShellLink::_CreateDarwinContextMenu(HWND hwnd, IContextMenu **pcmOut)
{
    HRESULT hr;

    *pcmOut = NULL;

    if (_pidl == NULL ||
        FAILED(hr = _CreateDarwinContextMenuForPidl(hwnd, _pidl, pcmOut)))
    {
        // The link target is busted for some reason - use the fallback pidl
        hr = _CreateDarwinContextMenuForPidl(hwnd, (LPCITEMIDLIST)&c_idlDrives, pcmOut);
    }

    return hr;
}

BOOL CShellLink::_GetExpandedPath(LPTSTR psz, DWORD cch)
{
    if (_sld.dwFlags & SLDF_HAS_EXP_SZ)
    {
        LPEXP_SZ_LINK pesl = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_LINK_SIG);
        if (pesl) 
        {
            TCHAR sz[MAX_PATH];
            sz[0] = 0;
        
            // prefer the UNICODE version...
            if (pesl->swzTarget[0])
                SHUnicodeToTChar(pesl->swzTarget, sz, SIZECHARS(sz));

            if (!sz[0] && pesl->szTarget[0])
                SHAnsiToTChar(pesl->szTarget, sz, SIZECHARS(sz));

            if (sz[0])
            {
                return SHExpandEnvironmentStrings(sz, psz, cch);
            }
        }
        else
        {
            _sld.dwFlags &= ~SLDF_HAS_EXP_SZ;
        }
    }

    return FALSE;
}

#define DEFAULT_TIMEOUT      7500   // 7 1/2 seconds...

DWORD g_dwNetLinkTimeout = (DWORD)-1;

DWORD _GetNetLinkTimeout()
{
    if (g_dwNetLinkTimeout == -1)
    {
        DWORD cb = sizeof(g_dwNetLinkTimeout);
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("NetLinkTimeout"), NULL, &g_dwNetLinkTimeout, &cb)))
            g_dwNetLinkTimeout = DEFAULT_TIMEOUT;
    }
    return g_dwNetLinkTimeout;
}

DWORD CShellLink::_VerifyPathThreadProc(void *pv)
{
    LPTSTR psz = (LPTSTR)pv;
    
    PathStripToRoot(psz);
    BOOL bFoundRoot = PathFileExistsAndAttributes(psz, NULL);   // does WNet stuff for us
    
    LocalFree(psz);     // this thread owns this buffer
    return bFoundRoot;  // retrieved via GetExitCodeThread()
}

// since net timeouts can be very long this is a manual way to timeout
// an operation explictly rather than waiting for the net layers to do their
// long timeouts

HRESULT CShellLink::_ShortNetTimeout()
{
    HRESULT hr = S_OK;      // assume good
    
    TCHAR szPath[MAX_PATH];
    if (_pidl && SHGetPathFromIDList(_pidl, szPath) && PathIsNetworkPath(szPath))
    {
        hr = E_OUTOFMEMORY;     // assume failure (2 cases below)
        
        LPTSTR psz = StrDup(szPath);    // give thread a copy of string to avoid buffer liftime issues
        if (psz)
        {
            DWORD dwID;
            HANDLE hThread = CreateThread(NULL, 0, _VerifyPathThreadProc, psz, 0, &dwID);
            if (hThread)
            {
                // assume timeout...
                hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT); // timeout return value
                
                if (WAIT_OBJECT_0 == WaitForSingleObject(hThread, _GetNetLinkTimeout()))
                {
                    // thread finished
                    DWORD dw;
                    if (GetExitCodeThread(hThread, &dw) && dw)
                    {
                        hr = S_OK;  // bool thread result maps to S_OK
                    }
                }
                CloseHandle(hThread);
            }
            else
            {
                LocalFree(psz);
            }
        }
    }
    return hr;
}


//
// This function returns the specified UI object from the link source.
//
// Parameters:
//  hwnd   -- optional hwnd for UI (for drop target)
//  riid   -- Specifies the interface (IID_IDropTarget, IID_IExtractIcon, IID_IContextMenu, ...)
//  ppv    -- Specifies the place to return the pointer.
//
// Notes:
//  Don't put smart-resolving code here. Such a thing should be done
//  BEFORE calling this function.
//

HRESULT CShellLink::_GetUIObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;     // Do this once and for all
    HRESULT hr = E_FAIL;

    if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {
        // We commandeer a couple of IIDs if this is a Darwin link.
        // Must do this before any pseudo-resolve goo because Darwin
        // shortcuts don't resolve the normal way.

        if (IsEqualIID(riid, IID_IContextMenu))
        {
            // Custom Darwin context menu.
            hr = _CreateDarwinContextMenu(hwnd, (IContextMenu **)ppv);
        }
        else if (!IsEqualIID(riid, IID_IDropTarget) && _pidl)
        {
            hr = SHGetUIObjectFromFullPIDL(_pidl, hwnd, riid, ppv);
        }
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        if (!_pidl && _GetExpandedPath(szPath, SIZECHARS(szPath)))
        {
            _SetSimplePIDL(szPath);
        } 

        if (_pidl)
        {
            hr = SHGetUIObjectFromFullPIDL(_pidl, hwnd, riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr;

    if (_cmTarget == NULL)
    {
        hr = _GetUIObject(NULL, IID_PPV_ARG(IContextMenu, _cmTarget.GetOutputPtr()));
        if (FAILED(hr))
            return hr;

        ASSERT(_cmTarget);
    }

    // save these if in case we need to rebuild the cm because the resolve change the
    // target of the link

    _indexMenuSave = indexMenu;
    _idCmdFirstSave = idCmdFirst;
    _idCmdLastSave = idCmdLast;
    _uFlagsSave = uFlags;

    uFlags |= CMF_VERBSONLY;

    if (_sld.dwFlags & SLDF_RUNAS_USER)
    {
        // "runas" for exe's is an extenede verb, so we have to ask for those as well.
        uFlags |= CMF_EXTENDEDVERBS;
    }

    hr = _cmTarget.QueryContextMenu(this, hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);

    // set default verb to "runas" if the "Run as different user" checkbox is checked
    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_RUNAS_USER))
    {
        int i = _cmTarget.GetMenuIndexForCanonicalVerb(this, hmenu, idCmdFirst, L"runas");

        if (i != -1)
        {
            // we found runas, so set it as the default
            SetMenuDefaultItem(hmenu, i, MF_BYPOSITION);
        }
        else
        {
            // the checkbox was enabled and checked, which means that the "runas" verb was supposed
            // to be in the context menu, but we couldnt find it.
            ASSERTMSG(FALSE, "CSL::QueryContextMenu - failed to set 'runas' as default context menu item!");
        }
    }

    return hr;
}

HRESULT CShellLink::_InvokeCommandAsync(LPCMINVOKECOMMANDINFO pici)
{
    TCHAR szWorkingDir[MAX_PATH];
    CHAR szVerb[32];
    CHAR szWorkingDirAnsi[MAX_PATH];
    WCHAR szVerbW[32];

    szVerb[0] = 0;

    // if needed, get the canonical name in case the IContextMenu changes as
    // a result of the resolve call BUT only do this for folders (to be safe)
    // as that is typically the only case where this happens
    // sepcifically we resolve from a D:\ -> \\SERVER\SHARE

    if (IS_INTRESOURCE(pici->lpVerb) && (_sld.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        _cmTarget.GetCommandString(this, LOWORD(pici->lpVerb), GCS_VERBA, NULL, szVerb, ARRAYSIZE(szVerb));
    }

    ASSERT(!_bDirty);

    // we pass SLR_ENVOKE_MSI since we WANT to invoke darwin since we are
    // really going to execute the link now
    DWORD slrFlags = SLR_INVOKE_MSI;
    if (pici->fMask & CMIC_MASK_FLAG_NO_UI)
    {
        slrFlags |= SLR_NO_UI;
    }
        
    HRESULT hr = _Resolve(pici->hwnd, slrFlags, 0);
    if (hr == S_OK)
    {
        if (_bDirty)
        {
            // the context menu we have for this link is out of date - recreate it
            _cmTarget.AtomicRelease();

            hr = _GetUIObject(NULL, IID_PPV_ARG(IContextMenu, _cmTarget.GetOutputPtr()));
            if (SUCCEEDED(hr))
            {
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    hr = _cmTarget.QueryContextMenu(this, hmenu, _indexMenuSave, _idCmdFirstSave, _idCmdLastSave, _uFlagsSave | CMF_VERBSONLY);
                    DestroyMenu(hmenu);
                }
            }
            Save((LPCOLESTR)NULL, TRUE);    // don't care if this fails...
        }
        else
        {
            szVerb[0] = 0;
            ASSERT(SUCCEEDED(hr));
        }

        if (SUCCEEDED(hr))
        {
            TCHAR szArgs[MAX_PATH];
            TCHAR szExpArgs[MAX_PATH];
            CMINVOKECOMMANDINFOEX ici = {0};
            CHAR szArgsAnsi[MAX_PATH];

            // copy to local ici
            memcpy(&ici, pici, min(sizeof(ici), pici->cbSize));
            ici.cbSize = sizeof(ici);

            if (szVerb[0])
            {
                ici.lpVerb = szVerb;
                SHAnsiToUnicode(szVerb, szVerbW, ARRAYSIZE(szVerbW));
                ici.lpVerbW = szVerbW;
            }
            // build the args from those passed in cated on the end of the the link args

            StrCpyN(szArgs, _pszArgs ? _pszArgs : c_szNULL, ARRAYSIZE(szArgs));
            if (ici.lpParameters)
            {
                int nArgLen = lstrlen(szArgs);
                LPCTSTR lpParameters;
                WCHAR szParameters[MAX_PATH];

                if (ici.cbSize < CMICEXSIZE_NT4
                    || (ici.fMask & CMIC_MASK_UNICODE) != CMIC_MASK_UNICODE)
                {
                    SHAnsiToUnicode(ici.lpParameters, szParameters, ARRAYSIZE(szParameters));
                    lpParameters = szParameters;
                }
                else
                {
                    lpParameters = ici.lpParametersW;
                }
                StrCpyN(szArgs + nArgLen, c_szSpace, ARRAYSIZE(szArgs) - nArgLen - 1);
                StrCpyN(szArgs + nArgLen + 1, lpParameters, ARRAYSIZE(szArgs) - nArgLen - 2);
            }

            // Expand environment strings in szArgs
            SHExpandEnvironmentStrings(szArgs, szExpArgs, ARRAYSIZE(szExpArgs));

            SHTCharToAnsi(szExpArgs, szArgsAnsi, ARRAYSIZE(szArgsAnsi));
            ici.lpParameters = szArgsAnsi;
            ici.lpParametersW = szExpArgs;
            ici.fMask |= CMIC_MASK_UNICODE;

            // if we have a working dir in the link over ride what is passed in

            if (_GetWorkingDir(szWorkingDir))
            {
                LPCTSTR pszDir = PathIsDirectory(szWorkingDir) ? szWorkingDir : NULL;
                if (pszDir)
                {
                    SHTCharToAnsi(pszDir, szWorkingDirAnsi, ARRAYSIZE(szWorkingDirAnsi));
                    ici.lpDirectory = szWorkingDirAnsi;
                    ici.lpDirectoryW = pszDir;
                }
            }

            // set RUN IN SEPARATE VDM if needed
            if (_sld.dwFlags & SLDF_RUN_IN_SEPARATE)
            {
                ici.fMask |= CMIC_MASK_FLAG_SEP_VDM;
            }
            // and of course use our hotkey
            if (_sld.wHotkey)
            {
                ici.dwHotKey = _sld.wHotkey;
                ici.fMask |= CMIC_MASK_HOTKEY;
            }

            // override normal runs, but let special show cmds through
            if (ici.nShow == SW_SHOWNORMAL)
            {
                DebugMsg(DM_TRACE, TEXT("using shorcut show cmd"));
                ici.nShow = _sld.iShowCmd;
            }

            //
            // On NT we want to pass the title to the
            // thing that we are about to start.
            //
            // CMIC_MASK_HASLINKNAME means that the lpTitle is really
            // the full path to the shortcut.  The console subsystem
            // sees the bit and reads all his properties directly from
            // the LNK file.
            //
            // ShellExecuteEx also uses the path to the shortcut so it knows
            // what to set in the SHCNEE_SHORTCUTINVOKE notification.
            //
            if (!(ici.fMask & CMIC_MASK_HASLINKNAME) && !(ici.fMask & CMIC_MASK_HASTITLE))
            {
                if (_pszCurFile)
                {
                    ici.lpTitle = NULL;     // Title is one or the other...
                    ici.lpTitleW = _pszCurFile;
                    ici.fMask |= CMIC_MASK_HASLINKNAME | CMIC_MASK_HASTITLE;
                }
            }
            ASSERT((ici.nShow > SW_HIDE) && (ici.nShow <= SW_MAX));

            IBindCtx *pbc;
            hr = _MaybeAddShim(&pbc);
            if (SUCCEEDED(hr))
            {
                hr = _cmTarget.InvokeCommand(this, (LPCMINVOKECOMMANDINFO)&ici);
                if (pbc)
                {
                    pbc->Release();
                }
            }
        }
    }
    return hr;
}


// Structure which encapsulates the paramters needed for InvokeCommand (so
// that we can pass both parameters though a single LPARAM in CreateThread)

typedef struct
{
    CShellLink *psl;
    CMINVOKECOMMANDINFOEX ici;
} ICMPARAMS;

#define ICM_BASE_SIZE (sizeof(ICMPARAMS) - sizeof(CMINVOKECOMMANDINFOEX))

// Runs as a separate thread, does the actual work of calling the "real"
// InvokeCommand

DWORD CALLBACK CShellLink::_InvokeThreadProc(void *pv)
{
    ICMPARAMS * pParams = (ICMPARAMS *) pv;
    CShellLink *psl = pParams->psl;
    IBindCtx *pbcRelease;

    HRESULT hr = TBCRegisterObjectParam(TBCDIDASYNC, SAFECAST(psl, IShellLink *), &pbcRelease);
    if (SUCCEEDED(hr))
    {
        //  since we are ASYNC, this hwnd may now go bad.  we just assume it has.
        //  we will make sure it doesnt by giving a chance for it to go bad
        if (IsWindow(pParams->ici.hwnd))
        {
            Sleep(100);
        }
        if (!IsWindow(pParams->ici.hwnd))
            pParams->ici.hwnd = NULL;
        
        hr = psl->_InvokeCommandAsync((LPCMINVOKECOMMANDINFO)&pParams->ici);
        pbcRelease->Release();
    }

    psl->Release();

    LocalFree(pParams);
    return (DWORD) hr;
}


// CShellLink::InvokeCommand
//
// Function that spins a thread to do the real work, which has been moved into
// CShellLink::InvokeCommandASync.

HRESULT CShellLink::InvokeCommand(LPCMINVOKECOMMANDINFO piciIn)
{
    HRESULT hr = S_OK;
    DWORD cchVerb, cchParameters, cchDirectory;
    DWORD cchVerbW, cchParametersW, cchDirectoryW;
    LPCMINVOKECOMMANDINFOEX   pici = (LPCMINVOKECOMMANDINFOEX) piciIn;
    const BOOL fUnicode = pici->cbSize >= CMICEXSIZE_NT4 &&
                                         (pici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE;

    if (_cmTarget == NULL)
        return E_FAIL;

    if (0 == (piciIn->fMask & CMIC_MASK_ASYNCOK))
    {
        // Caller didn't indicate that Async startup was OK, so we call
        // InvokeCommandAync SYNCHRONOUSLY
        return _InvokeCommandAsync(piciIn);
    }

    // Calc how much space we will need to duplicate the INVOKECOMMANDINFO
    DWORD cbBaseSize = (DWORD)(ICM_BASE_SIZE + max(piciIn->cbSize, sizeof(CMINVOKECOMMANDINFOEX)));


    //   One byte slack in case of Unicode roundup for pPosW, below
    DWORD cbSize = cbBaseSize + 1;

    if (HIWORD(pici->lpVerb))
    {
        cbSize += (cchVerb   = pici->lpVerb       ? (lstrlenA(pici->lpVerb) + 1)       : 0) * sizeof(CHAR);
    }
    cbSize += (cchParameters = pici->lpParameters ? (lstrlenA(pici->lpParameters) + 1) : 0) * sizeof(CHAR);
    cbSize += (cchDirectory  = pici->lpDirectory  ? (lstrlenA(pici->lpDirectory) + 1)  : 0) * sizeof(CHAR);

    if (HIWORD(pici->lpVerbW))
    {
        cbSize += (cchVerbW  = pici->lpVerbW      ? (lstrlenW(pici->lpVerbW) + 1)       : 0) * sizeof(WCHAR);
    }
    cbSize += (cchParametersW= pici->lpParametersW? (lstrlenW(pici->lpParametersW) + 1) : 0) * sizeof(WCHAR);
    cbSize += (cchDirectoryW = pici->lpDirectoryW ? (lstrlenW(pici->lpDirectoryW) + 1)  : 0) * sizeof(WCHAR);

    ICMPARAMS *pParams = (ICMPARAMS *) LocalAlloc(LPTR, cbSize);
    if (NULL == pParams)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // Text data will start going in right after the structure
    CHAR *pPos = (CHAR *)((LPBYTE)pParams + cbBaseSize);

    // Start with a copy of the static fields
    CopyMemory(&pParams->ici, pici, min(sizeof(pParams->ici), pici->cbSize));

    // Walk along and dupe all of the string pointer fields
    if (HIWORD(pici->lpVerb))
    {
        pPos += cchVerb   ? lstrcpyA(pPos, pici->lpVerb), pParams->ici.lpVerb = pPos, cchVerb   : 0;
    }
    pPos += cchParameters ? lstrcpyA(pPos, pici->lpParameters), pParams->ici.lpParameters = pPos, cchParameters : 0;
    pPos += cchDirectory  ? lstrcpyA(pPos, pici->lpDirectory),  pParams->ici.lpDirectory  = pPos, cchDirectory  : 0;

    WCHAR *pPosW = (WCHAR *) ((DWORD_PTR)pPos & 0x1 ? pPos + 1 : pPos);   // Ensure Unicode alignment
    if (HIWORD(pici->lpVerbW))
    {
        pPosW += cchVerbW  ? lstrcpyW(pPosW, pici->lpVerbW), pParams->ici.lpVerbW = pPosW, cchVerbW : 0;
    }
    pPosW += cchParametersW? lstrcpyW(pPosW, pici->lpParametersW),pParams->ici.lpParametersW= pPosW, cchParametersW : 0;
    pPosW += cchDirectoryW ? lstrcpyW(pPosW, pici->lpDirectoryW), pParams->ici.lpDirectoryW = pPosW, cchDirectoryW  : 0;

    // Pass all of the info off to the worker thread that will call the actual
    // InvokeCommand API for us

    //Set the object pointer to this object
    pParams->psl  = this;
    pParams->psl->AddRef();
    
    //  need to be able to be refcounted, 
    //  so that the dataobject we create 
    //  will stick around as long as needed.
    if (!SHCreateThread(_InvokeThreadProc, pParams, CTF_COINIT | CTF_REF_COUNTED, NULL))
    {
        // Couldn't start the thread, so the onus is on us to clean up
        pParams->psl->Release();
        LocalFree(pParams);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CShellLink::GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pmf, LPSTR pszName, UINT cchMax)
{
    if (_cmTarget)
    {
        return _cmTarget.GetCommandString(this, idCmd, wFlags, pmf, pszName, cchMax);
    }
    else
    {
        return E_FAIL;
    }
}

//
//  Note that we do not do a SetSite around the call to the inner HandleMenuMsg
//  It isn't necessary (yet)
//
HRESULT CShellLink::TargetContextMenu::HandleMenuMsg2(IShellLink *outer, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    return SHForwardContextMenuMsg(_pcmTarget, uMsg, wParam, lParam, plResult, NULL==plResult);
}

STDMETHODIMP CShellLink::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    if (_cmTarget)
    {
        return _cmTarget.HandleMenuMsg2(this, uMsg, wParam, lParam, plResult);
    }

    return E_NOTIMPL;
}

STDMETHODIMP CShellLink::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

HRESULT CShellLink::_InitDropTarget()
{
    if (_pdtSrc)
    {
        return S_OK;
    }

    HWND hwnd;
    IUnknown_GetWindow(_punkSite, &hwnd);
    return _GetUIObject(hwnd, IID_PPV_ARG(IDropTarget, &_pdtSrc));
}

STDMETHODIMP CShellLink::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        _grfKeyStateLast = grfKeyState;
        hr = _pdtSrc->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }
    return hr;
}

STDMETHODIMP CShellLink::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        _grfKeyStateLast = grfKeyState;
        hr = _pdtSrc->DragOver(grfKeyState, pt, pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }
    return hr;
}

STDMETHODIMP CShellLink::DragLeave()
{
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        hr = _pdtSrc->DragLeave();
    }
    return hr;
}

STDMETHODIMP CShellLink::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HWND hwnd = NULL;
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        IUnknown_GetWindow(_punkSite, &hwnd);

        _pdtSrc->DragLeave();       // leave from the un-resolved drop target.

        hr = _Resolve(hwnd, 0, 0);  // track the target
        if (S_OK == hr)
        {
            IDropTarget *pdtgtResolved;
            if (SUCCEEDED(_GetUIObject(hwnd, IID_PPV_ARG(IDropTarget, &pdtgtResolved))))
            {
                IUnknown_SetSite(pdtgtResolved, SAFECAST(this, IShellLink *));

                SHSimulateDrop(pdtgtResolved, pdtobj, _grfKeyStateLast, &pt, pdwEffect);

                IUnknown_SetSite(pdtgtResolved, NULL);

                pdtgtResolved->Release();
            }
        }
    }

    if (FAILED_AND_NOT_CANCELED(hr))
    {
        TCHAR szLinkSrc[MAX_PATH];
        if (_pidl && SHGetPathFromIDList(_pidl, szLinkSrc))
        {
            ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_ENUMERR_PATHNOTFOUND),
                        MAKEINTRESOURCE(IDS_LINKERROR),
                        MB_OK | MB_ICONEXCLAMATION, NULL, szLinkSrc);
        }
    }

    if (hr != S_OK)
    {
        // make sure nothing happens (if we failed)
        *pdwEffect = DROPEFFECT_NONE;
    }

    return hr;
}

STDMETHODIMP CShellLink::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    TCHAR szTip[INFOTIPSIZE];
    TCHAR szDesc[INFOTIPSIZE];

    StrCpyN(szTip, _pszPrefix ? _pszPrefix : TEXT(""), ARRAYSIZE(szTip));

    // QITIPF_USENAME could be replaced with ICustomizeInfoTip::SetPrefixText()

    if ((dwFlags & QITIPF_USENAME) && _pszCurFile)
    {
        SHFILEINFO sfi;
        if (SHGetFileInfo(_pszCurFile, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES))
        {
            if (szTip[0])
                StrCatBuff(szTip, TEXT("\n"), ARRAYSIZE(szTip));
            StrCatBuff(szTip, sfi.szDisplayName, ARRAYSIZE(szTip));
        }
    }
        
    GetDescription(szDesc, ARRAYSIZE(szDesc));

    //  if there is no comment, then we create one based on 
    //  the target's location.  only do this if we are not
    //  a darwin link, since the location has no meaning there
    if (!szDesc[0] && !(_sld.dwFlags & SLDF_HAS_DARWINID) && !(dwFlags & QITIPF_LINKNOTARGET))
    {
        if (dwFlags & QITIPF_LINKUSETARGET)
        {
            SHMakeDescription(_pidl, -1, szDesc, ARRAYSIZE(szDesc));
        }
        else
        {
            _MakeDescription(_pidl, szDesc, ARRAYSIZE(szDesc));
        }
    }
    else if (szDesc[0] == TEXT('@'))
    {
        WCHAR sz[INFOTIPSIZE];

        if (SUCCEEDED(SHLoadIndirectString(szDesc, sz, ARRAYSIZE(sz), NULL)))
        {
            StrCpyN(szDesc, sz, ARRAYSIZE(szDesc));
        }
    }
    

    if (szDesc[0])
    {
        if (szTip[0])
        {
            StrCatBuff(szTip, TEXT("\n"), ARRAYSIZE(szTip));
        }

        StrCatBuff(szTip, szDesc, ARRAYSIZE(szTip));
    }

    if (*szTip)
    {
        return SHStrDup(szTip, ppwszTip);
    }
    else
    {
        *ppwszTip = NULL;
        return S_FALSE;
    }
}

STDMETHODIMP CShellLink::GetInfoFlags(DWORD *pdwFlags)
{
    pdwFlags = 0;
    return E_NOTIMPL;
}

HRESULT CShellLink::_GetExtractIcon(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (_pszIconLocation && _pszIconLocation[0])
    {
        TCHAR szPath[MAX_PATH];
        
        // update our _pszIconLocation if we have a EXP_SZ_ICON_SIG datablock
        _UpdateIconFromExpIconSz();
        
        if (_pszIconLocation[0] == TEXT('.'))
        {
            TCHAR szBogusFile[MAX_PATH];
            
            // We allow people to set ".txt" for an icon path. In this case 
            // we cook up a simple pidl and use it to get to the IExtractIcon for 
            // whatever extension the user has specified.
            
            hr = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, szBogusFile);
            if (SUCCEEDED(hr))
            {
                PathAppend(szBogusFile, TEXT("*"));
                lstrcatn(szBogusFile, _pszIconLocation, ARRAYSIZE(szBogusFile));
                
                LPITEMIDLIST pidl = SHSimpleIDListFromPath(szBogusFile);
                if (pidl)
                {
                    hr = SHGetUIObjectFromFullPIDL(pidl, NULL, riid, ppv);
                    ILFree(pidl);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
            }
        }
        else if ((_sld.iIcon == 0)                  &&
                 _pidl                              &&
                 SHGetPathFromIDList(_pidl, szPath) &&
                 (lstrcmpi(szPath, _pszIconLocation) == 0))
        {
            // IExtractIconA/W
            hr = _GetUIObject(NULL, riid, ppv);
        }
        else
        {
            hr = SHCreateDefExtIcon(_pszIconLocation, _sld.iIcon, _sld.iIcon, GIL_PERINSTANCE, -1, riid, ppv);
        }
    }
    else
    {
        // IExtractIconA/W
        hr = _GetUIObject(NULL, riid, ppv);
    }

    return hr;
}

HRESULT CShellLink::_InitExtractIcon()
{
    if (_pxi || _pxiA)
        return S_OK;

    HRESULT hr = _GetExtractIcon(IID_PPV_ARG(IExtractIconW, &_pxi));
    if (FAILED(hr))
    {
        hr = _GetExtractIcon(IID_PPV_ARG(IExtractIconA, &_pxiA));
    }

    return hr;
}

// IExtractIconW::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(UINT uFlags, LPWSTR pszIconFile, 
                                         UINT cchMax, int *piIndex, UINT *pwFlags)
{
    // If we are in a situation where a shortcut points to itself (or LinkA <--> LinkB), then break the recursion here...
    if (uFlags & GIL_FORSHORTCUT)
    {
        RIPMSG(uFlags & GIL_FORSHORTCUT,"CShellLink::GIL called with GIL_FORSHORTCUT (uFlags=%x)",uFlags);
        return E_INVALIDARG;
    }

    HRESULT hr = _InitExtractIcon();

    if (SUCCEEDED(hr))
    {
        uFlags |= GIL_FORSHORTCUT;

        if (_pxi)
        {
            hr = _pxi->GetIconLocation(uFlags, pszIconFile, cchMax, piIndex, pwFlags);
        }
        else if (_pxiA)
        {
            CHAR sz[MAX_PATH];
            hr = _pxiA->GetIconLocation(uFlags, sz, ARRAYSIZE(sz), piIndex, pwFlags);
            if (SUCCEEDED(hr) && hr != S_FALSE)
                SHAnsiToUnicode(sz, pszIconFile, cchMax);
        }
        if (SUCCEEDED(hr))
        {
            _gilFlags = *pwFlags;
        }
    }
    return hr;
}

// IExtractIconA::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    WCHAR szFile[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szFile, ARRAYSIZE(szFile), piIndex, pwFlags);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(szFile, pszIconFile, cchMax);
    }
    return hr;
}

// IExtractIconW::Extract
STDMETHODIMP CShellLink::Extract(LPCWSTR pszFile, UINT nIconIndex, 
                                 HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = _InitExtractIcon();
    if (SUCCEEDED(hr))
    {
        // GIL_PERCLASS, GIL_PERINSTANCE
        if ((_gilFlags & GIL_PERINSTANCE) || !(_gilFlags & GIL_PERCLASS))
        {
            hr = _ShortNetTimeout();    // probe the net path
        }

        if (SUCCEEDED(hr))  // check again for _ShortNetTimeout() above case
        {
            if (_pxi)
            {
                hr = _pxi->Extract(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
            }
            else if (_pxiA)
            {
                CHAR sz[MAX_PATH];
                SHUnicodeToAnsi(pszFile, sz, ARRAYSIZE(sz));
                hr = _pxiA->Extract(sz, nIconIndex, phiconLarge, phiconSmall, nIconSize);
            }
        }
    }
    return hr;
}

// IExtractIconA::Extract
STDMETHODIMP CShellLink::Extract(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    WCHAR szFile[MAX_PATH];
    SHAnsiToUnicode(pszFile, szFile, ARRAYSIZE(szFile));
    return Extract(szFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}    

STDMETHODIMP CShellLink::AddDataBlock(void *pdb)
{
    _AddExtraDataSection((DATABLOCK_HEADER *)pdb);
    return S_OK;
}

STDMETHODIMP CShellLink::CopyDataBlock(DWORD dwSig, void **ppdb)
{
    DATABLOCK_HEADER *peh = (DATABLOCK_HEADER *)SHFindDataBlock(_pExtraData, dwSig);
    if (peh)
    {
        *ppdb = LocalAlloc(LPTR, peh->cbSize);
        if (*ppdb)
        {
            CopyMemory(*ppdb, peh, peh->cbSize);
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }
    *ppdb = NULL;
    return E_FAIL;
}

STDMETHODIMP CShellLink::RemoveDataBlock(DWORD dwSig)
{
    _RemoveExtraDataSection(dwSig);
    return S_OK;
}

STDMETHODIMP CShellLink::GetFlags(DWORD *pdwFlags)
{
    *pdwFlags = _sld.dwFlags;
    return S_OK;
}

STDMETHODIMP CShellLink::SetFlags(DWORD dwFlags)
{
    if (dwFlags != _sld.dwFlags)
    {
        _bDirty = TRUE;
        _sld.dwFlags = dwFlags;
        return S_OK;
    }
    return S_FALSE;     // no change made
}

STDMETHODIMP CShellLink::GetPath(LPSTR pszFile, int cchFile, WIN32_FIND_DATAA *pfd, DWORD fFlags)
{
    WCHAR szPath[MAX_PATH];
    WIN32_FIND_DATAW wfd;

    //Call the unicode version
    HRESULT hr = GetPath(szPath, ARRAYSIZE(szPath), &wfd, fFlags);

    if (pszFile)
    {
        SHUnicodeToAnsi(szPath, pszFile, cchFile);
    }
    if (pfd)
    {
        if (szPath[0])
        {
            pfd->dwFileAttributes = wfd.dwFileAttributes;
            pfd->ftCreationTime   = wfd.ftCreationTime;
            pfd->ftLastAccessTime = wfd.ftLastAccessTime;
            pfd->ftLastWriteTime  = wfd.ftLastWriteTime;
            pfd->nFileSizeLow     = wfd.nFileSizeLow;
            pfd->nFileSizeHigh    = wfd.nFileSizeHigh;

            SHUnicodeToAnsi(wfd.cFileName, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
        }
        else
        {
            ZeroMemory(pfd, sizeof(*pfd));
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::SetPath(LPCSTR pszPath)
{
    WCHAR szPath[MAX_PATH];
    LPWSTR pszPathW;
    
    if (pszPath)
    {
        SHAnsiToUnicode(pszPath, szPath, ARRAYSIZE(szPath));
        pszPathW = szPath;
    }
    else
    {
        pszPathW = NULL;
    }

    return SetPath(pszPathW);
}

STDAPI CShellLink_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CShellLink *pshlink = new CShellLink();
    if (pshlink)
    {
        hr = pshlink->QueryInterface(riid, ppv);
        pshlink->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CShellLink::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellLink::InitNew(void)
{
    _ResetPersistData();        // clear out our state
    return S_OK;
}

STDMETHODIMP CShellLink::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    _ResetPersistData();        // clear out our state

    TCHAR szPath[MAX_PATH];

    // TBD: Shortcut key, Run, Icon, Working Dir, Description

    INT iCSIDL;    
    HRESULT hr = SHPropertyBag_ReadInt(pPropBag, L"TargetSpecialFolder", &iCSIDL);
    if (SUCCEEDED(hr))
    {
        hr = SHGetFolderPath(NULL, iCSIDL, NULL, SHGFP_TYPE_CURRENT, szPath);
    }
    else
    {
        szPath[0] = 0;
        hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        WCHAR wsz[MAX_PATH];
        if (SUCCEEDED(SHPropertyBag_ReadStr(pPropBag, L"Target", wsz, ARRAYSIZE(wsz))))
        {
            TCHAR szTempPath[MAX_PATH];
            SHUnicodeToTChar(wsz, szTempPath, ARRAYSIZE(szTempPath));
            // Do we need to append it to the Special path?
            if (szPath[0])
            {
                // Yes
                if (!PathAppend(szPath, szTempPath))
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                // No, there is no special path
                // Maybe we have an Env Var to expand
                if (0 == SHExpandEnvironmentStrings(szTempPath, szPath, ARRAYSIZE(szPath)))
                {
                    hr = E_FAIL;
                }
            }
        }
        else if (0 == szPath[0])
        {
            // make sure not empty
            hr = E_FAIL;
            
        }
        if (SUCCEEDED(hr))
        {
            // FALSE for bUpdateTrackingData as we won't need any tracking data
            // for links loaded via a property bag
            hr = _SetPIDLPath(NULL, szPath, FALSE); 
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_LinkSite)
        return QueryInterface(riid, ppv);
    return IUnknown_QueryService(_punkSite, guidService, riid, ppv);
}

const FULLPROPSPEC c_rgProps[] =
{
    { PSGUID_SUMMARYINFORMATION, {  PRSPEC_PROPID, PIDSI_COMMENTS } },
};

STDMETHODIMP CShellLink::Init(ULONG grfFlags, ULONG cAttributes,
                              const FULLPROPSPEC *rgAttributes, ULONG *pFlags)
{
    *pFlags = 0;

    if (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES)
    {
        // start at the beginning
        _iChunkIndex = 0;
    }
    else
    {
        // indicate EOF
        _iChunkIndex = ARRAYSIZE(c_rgProps);
    }
    _iValueIndex = 0;
    return S_OK;
}
        
STDMETHODIMP CShellLink::GetChunk(STAT_CHUNK *pStat)
{
    HRESULT hr = S_OK;
    if (_iChunkIndex < ARRAYSIZE(c_rgProps))
    {
        pStat->idChunk          = _iChunkIndex + 1;
        pStat->idChunkSource    = _iChunkIndex + 1;
        pStat->breakType        = CHUNK_EOP;
        pStat->flags            = CHUNK_VALUE;
        pStat->locale           = GetSystemDefaultLCID();
        pStat->attribute        = c_rgProps[_iChunkIndex];
        pStat->cwcStartSource   = 0;
        pStat->cwcLenSource     = 0;

        _iValueIndex = 0;
        _iChunkIndex++;
    }
    else
    {
        hr = FILTER_E_END_OF_CHUNKS;
    }
    return hr;
}

STDMETHODIMP CShellLink::GetText(ULONG *pcwcBuffer, WCHAR *awcBuffer)
{
    return FILTER_E_NO_TEXT;
}
        
STDMETHODIMP CShellLink::GetValue(PROPVARIANT **ppPropValue)
{
    HRESULT hr;
    if ((_iChunkIndex <= ARRAYSIZE(c_rgProps)) && (_iValueIndex < 1))
    {
        *ppPropValue = (PROPVARIANT*)CoTaskMemAlloc(sizeof(PROPVARIANT));
        if (*ppPropValue)
        {
            (*ppPropValue)->vt = VT_BSTR;

            if (_pszName)
            {
                (*ppPropValue)->bstrVal = SysAllocStringT(_pszName);
            }
            else
            {
                // since _pszName is null, return an empty bstr
                (*ppPropValue)->bstrVal = SysAllocStringT(TEXT(""));
            }

            if ((*ppPropValue)->bstrVal)
            {
                hr = S_OK;
            }
            else
            {
                CoTaskMemFree(*ppPropValue);
                *ppPropValue = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        _iValueIndex++;
    }
    else
    {
        hr = FILTER_E_NO_MORE_VALUES;
    }
    return hr;
}
        
STDMETHODIMP CShellLink::BindRegion(FILTERREGION origPos, REFIID riid, void **ppunk)
{
    *ppunk = NULL;
    return E_NOTIMPL;
}

// ICustomizeInfoTip

STDMETHODIMP CShellLink::SetPrefixText(LPCWSTR pszPrefix)
{
    Str_SetPtrW(&_pszPrefix, pszPrefix);
    return S_OK;
}

STDMETHODIMP CShellLink::SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid)
{
    return S_OK;
}

HRESULT CShellLink::_MaybeAddShim(IBindCtx **ppbcRelease)
{
    // set the __COMPAT_LAYER environment variable if necessary
    HRESULT hr = S_FALSE;
    *ppbcRelease = 0;
    if ((_sld.dwFlags & SLDF_RUN_WITH_SHIMLAYER))
    {
        EXP_SHIMLAYER* pShimData = (EXP_SHIMLAYER*)SHFindDataBlock(_pExtraData, EXP_SHIMLAYER_SIG);

        if (pShimData && pShimData->wszLayerEnvName[0])
        {
            //  we shouldnt recurse
            ASSERT(FAILED(TBCGetEnvironmentVariable(TEXT("__COMPAT_LAYER"), NULL, 0)));
            hr = TBCSetEnvironmentVariable(L"__COMPAT_LAYER", pShimData->wszLayerEnvName, ppbcRelease);
        }
    }
    return hr;
}

DWORD CALLBACK CLinkResolver::_ThreadStartCallBack(void *pv)
{
    CLinkResolver *prs = (CLinkResolver *)pv;
    prs->_hThread = OpenThread(SYNCHRONIZE, FALSE, GetCurrentThreadId());
    prs->AddRef();
    return 0;
}

DWORD CLinkResolver::_Search()
{
    // Attempt to find the link using the CTracker
    // object (which uses NTFS object IDs and persisted information
    // about link-source moves).
    if (_ptracker)
    {
        HRESULT hr = _ptracker->Search(_dwTimeLimit,            // GetTickCount()-relative timeout
                                       &_ofd,                   // Original WIN32_FIND_DATA
                                       &_fdFound,               // WIN32_FIND_DATA of new location
                                       _dwResolveFlags,         // SLR_ flags
                                       _TrackerRestrictions);   // TrkMendRestriction flags
        if (SUCCEEDED(hr))
        {
           // We've found the link source, and we're certain it's correct.
           // So set the score to the highest possible value, and
           // return.
 
           _iScore = MIN_NO_UI_SCORE;
           _bContinue = FALSE;
        }
        else if (HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND) == hr)
        {
            // We've found "a" link source, but we're not certain it's correct.
            // Allow the search algorithm below to run and see if it finds
            // a better match.

            _iScore = MIN_NO_UI_SCORE - 1;
        }
        else if (HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT) == hr)
        {
            // The CTracker search stopped because we've timed out.
            _bContinue = FALSE;
        }
    }

    // Attempt to find the link source using an enumerative search
    // (unless the downlevel search has been suppressed by the caller)

    if (_bContinue && !(_fifFlags & FIF_NODRIVE))
    {
        _HeuristicSearch();
    }

    if (_hDlg)
    {
        PostMessage(_hDlg, WM_COMMAND, IDOK, 0);
    }

    return _iScore;
}

DWORD CALLBACK CLinkResolver::_SearchThreadProc(void *pv)
{
    // Sleep(45 * 1000);    // test the network long time out case

    CLinkResolver *prs = (CLinkResolver *)pv;
    DWORD dwRet = prs->_Search();
    prs->Release();  // AddRef in the CallBack while thread creation.
    return dwRet;
}

DWORD CLinkResolver::_GetTimeOut()
{
    if (0 == _dwTimeOutDelta)
    {
        _dwTimeOutDelta = TimeoutDeltaFromResolveFlags(_dwResolveFlags);
    }
    return _dwTimeOutDelta;
}

#define IDT_SHOWME          1
#define IDT_NO_UI_TIMEOUT   2

void CLinkResolver::_InitDlg(HWND hDlg)
{
    _hDlg = hDlg;
    
    if (SHCreateThread(_SearchThreadProc, this, CTF_COINIT | CTF_FREELIBANDEXIT, _ThreadStartCallBack))
    {
        CloseHandle(_hThread);
        _hThread = NULL;

        if (_dwResolveFlags & SLR_NO_UI)
        {
            SetTimer(hDlg, IDT_NO_UI_TIMEOUT, _GetTimeOut(), 0);
        }
        else
        {
            TCHAR szFmt[128], szTemp[MAX_PATH + ARRAYSIZE(szFmt)];
            
            GetDlgItemText(hDlg, IDD_NAME, szFmt, ARRAYSIZE(szFmt));
            wnsprintf(szTemp, ARRAYSIZE(szTemp), szFmt, _ofd.cFileName);
            SetDlgItemText(hDlg, IDD_NAME, szTemp);
            
            HWND hwndAni = GetDlgItem(hDlg, IDD_STATUS);
            
            Animate_Open(hwndAni, MAKEINTRESOURCE(IDA_SEARCH)); // open the resource
            Animate_Play(hwndAni, 0, -1, -1);     // play from start to finish and repeat
        
            // delay showing the dialog for the common case where we quickly
            // find the target (in less than 1/2 a sec)
            _idtDelayedShow = SetTimer(hDlg, IDT_SHOWME, 500, 0);
        }
    }
    else
    {
        EndDialog(hDlg, IDCANCEL);
    }
}

BOOL_PTR CALLBACK CLinkResolver::_DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CLinkResolver *prs = (CLinkResolver *)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (wMsg) 
    {
    case WM_INITDIALOG:
        
        // This Dialog is created in Synchronous to the Worker thread who already has Addref'd prs, so 
        // no need to Addref it here.
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        prs = (CLinkResolver *)lParam;
        prs->_InitDlg(hDlg);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDD_BROWSE:
            prs->_hDlg = NULL;              // don't let the thread close us
            prs->_bContinue = FALSE;         // cancel thread
            
            Animate_Stop(GetDlgItem(hDlg, IDD_STATUS));
            
            if (GetFileNameFromBrowse(hDlg, prs->_sfd.cFileName, ARRAYSIZE(prs->_sfd.cFileName), prs->_pszSearchOriginFirst, prs->_ofd.cFileName, NULL, NULL))
            {
                HANDLE hfind = FindFirstFile(prs->_sfd.cFileName, &prs->_fdFound);
                ASSERT(hfind != INVALID_HANDLE_VALUE);
                FindClose(hfind);
                StringCchCopy(prs->_fdFound.cFileName, ARRAYSIZE(prs->_fdFound.cFileName), prs->_sfd.cFileName);
                
                prs->_iScore = MIN_NO_UI_SCORE;
                wParam = IDOK;
            }
            else
            {
                wParam = IDCANCEL;
            }
            // Fall through...
            
        case IDCANCEL:
            // tell searching thread to stop
            prs->_bContinue = FALSE;
            
            // if the searching thread is currently in the tracker
            // waiting for results, wake it up and tell it to abort
            
            if (prs->_ptracker)
                prs->_ptracker->CancelSearch();
            // Fall through...
            
        case IDOK:
            // thread posts this to us
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;
        }
        break;
        
        case WM_TIMER:
            KillTimer(hDlg, wParam);    // both are one shots
            switch (wParam)
            {
            case IDT_NO_UI_TIMEOUT:
                PostMessage(prs->_hDlg, WM_COMMAND, IDCANCEL, 0);
                break;
                
            case IDT_SHOWME:
                prs->_idtDelayedShow = 0;
                ShowWindow(hDlg, SW_SHOW);
                break;
            }
            break;
            
        case WM_WINDOWPOSCHANGING:
            if ((prs->_dwResolveFlags & SLR_NO_UI) || prs->_idtDelayedShow) 
            {
                WINDOWPOS *pwp = (WINDOWPOS *)lParam;
                pwp->flags &= ~SWP_SHOWWINDOW;
            }
            break;
            
        default:
            return FALSE;
    }
    return TRUE;
}

typedef struct 
{
    LPCTSTR pszLinkName;
    LPCTSTR pszNewTarget;
    LPCTSTR pszCurFile;
} DEADLINKDATA;

BOOL_PTR DeadLinkProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DEADLINKDATA *pdld = (DEADLINKDATA *)GetWindowPtr(hwnd, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pdld = (DEADLINKDATA*)lParam;
        SetWindowPtr(hwnd, DWLP_USER, pdld);

        HWNDWSPrintf(GetDlgItem(hwnd, IDC_DEADTEXT1), PathFindFileName(pdld->pszLinkName));
        if (GetDlgItem(hwnd, IDC_DEADTEXT2)) 
            PathSetDlgItemPath(hwnd, IDC_DEADTEXT2, pdld->pszNewTarget);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDC_DELETE:
            {
                TCHAR szName[MAX_PATH + 1] = {0};
                SHFILEOPSTRUCT fo = {
                    hwnd,
                    FO_DELETE,
                    szName,
                    NULL, 
                    FOF_NOCONFIRMATION
                };

                StrCpyN(szName, pdld->pszCurFile, ARRAYSIZE(szName));
                SHFileOperation(&fo);
            }
            // fall through...
        case IDCANCEL:
        case IDOK:
            EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
            break;
        }
        break;
    }
    
    return FALSE;
}

// in:
//      hwnd            for UI if needed
//
// returns:
//      IDOK            found something
//      IDNO            didn't find it
//      IDCANCEL        user canceled the operation

int CLinkResolver::Resolve(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszCurFile)
{
    StrCpyN(_szSearchStart, pszPath, ARRAYSIZE(_szSearchStart));
    PathRemoveFileSpec(_szSearchStart);
    
    _dwTimeLimit = GetTickCount() + _GetTimeOut();
    
    int id = IDCANCEL;

    if (SLR_NO_UI == (SLR_NO_UI_WITH_MSG_PUMP & _dwResolveFlags))
    {
        if (SHCreateThread(_SearchThreadProc, this, CTF_COINIT | CTF_FREELIBANDEXIT, _ThreadStartCallBack))
        {
            // don't care if it completes or times out. as long as it has a result
            WaitForSingleObject(_hThread, _GetTimeOut());
            CloseHandle(_hThread);
            _hThread = NULL;
            _bContinue = FALSE;    // cancel that thread if it is still running
            id = IDOK;
        }
    }
    else
    {
        id = (int)DialogBoxParam(HINST_THISDLL,
                                 MAKEINTRESOURCE(DLG_LINK_SEARCH), 
                                 hwnd,
                                 _DlgProc,
                                 (LPARAM)this);
    }

    if (IDOK == id) 
    {
        if (_iScore < MIN_NO_UI_SCORE)
        {
            if (_dwResolveFlags & SLR_NO_UI)
            {
                id = IDCANCEL;
            }
            else
            {
                // we must display UI since this file is questionable
                if (_fifFlags & FIF_NODRIVE) 
                {
                    LPCTSTR pszName = pszCurFile ? (LPCTSTR)PathFindFileName(pszCurFile) : c_szNULL;
                    
                    ShellMessageBox(HINST_THISDLL,
                                    hwnd,
                                    MAKEINTRESOURCE(IDS_LINKUNAVAILABLE),
                                    MAKEINTRESOURCE(IDS_LINKERROR),
                                    MB_OK | MB_ICONEXCLAMATION,
                                    pszName);
                    id = IDCANCEL;
                }
                else if (pszCurFile)
                {
                    DEADLINKDATA dld;
                    dld.pszLinkName = pszPath;
                    dld.pszNewTarget = _fdFound.cFileName;
                    dld.pszCurFile = pszCurFile;
                    
                    int idDlg = _iScore <= MIN_SHOW_USER_SCORE ? DLG_DEADSHORTCUT : DLG_DEADSHORTCUT_MATCH;
                    id = (int)DialogBoxParam(HINST_THISDLL,
                                             MAKEINTRESOURCE(idDlg), 
                                             hwnd,
                                             DeadLinkProc,
                                             (LPARAM)&dld);
                }
                else if (_iScore <= MIN_SHOW_USER_SCORE) 
                {
                    ShellMessageBox(HINST_THISDLL,
                                    hwnd,
                                    MAKEINTRESOURCE(IDS_LINKNOTFOUND),
                                    MAKEINTRESOURCE(IDS_LINKERROR),
                                    MB_OK | MB_ICONEXCLAMATION,
                                    PathFindFileName(pszPath));
                    id = IDCANCEL;
                }
                else
                {
                    if (IDYES == ShellMessageBox(HINST_THISDLL,
                                                 hwnd, 
                                                 MAKEINTRESOURCE(IDS_LINKCHANGED),
                                                 MAKEINTRESOURCE(IDS_LINKERROR),
                                                 MB_YESNO | MB_ICONEXCLAMATION,
                                                 PathFindFileName(pszPath),
                                                 _fdFound.cFileName))
                    {
                        id = IDOK;
                    }
                    else
                    {
                        id = IDCANCEL;
                    }
                }
            }
        }
    }
    _ofd = _fdFound;
    return id;
}

void CLinkResolver::GetResult(LPTSTR psz, UINT cch)
{
    // _ofd.cFileName is a fully qualified name (strange for win32_find_data usage)
    StrCpyN(psz, _ofd.cFileName, cch);
}

CLinkResolver::CLinkResolver(CTracker *ptrackerobject, const WIN32_FIND_DATA *pofd, UINT dwResolveFlags, DWORD TrackerRestrictions, DWORD fifFlags) : 
    _dwTimeOutDelta(0), _bContinue(TRUE), _hThread(NULL), _pstw(NULL),
    _ptracker(ptrackerobject), _dwResolveFlags(dwResolveFlags), _TrackerRestrictions(TrackerRestrictions), _fifFlags(fifFlags)
{
    if (_ptracker)
    {
       _ptracker->AddRef();
    }

    _ofd = *pofd;   // original find data
    _pszSearchOriginFirst = _szSearchStart;
    _pszSearchOrigin = _szSearchStart;
    _dwMatch = _ofd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;      // must match bits
}

CLinkResolver::~CLinkResolver()
{
    if (_ptracker)
    {
        _ptracker->Release();
    }

    ATOMICRELEASE(_pstw);

    ASSERT(NULL == _hThread);
}

HRESULT CLinkResolver::_InitWalkObject()
{
    HRESULT hr = _pstw ? S_OK : CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &_pstw));
    if (SUCCEEDED(hr))
    {
        ASSERT(_pwszSearchSpec == NULL);
        // Note: We only search files with the same extension, this saves us a lot
        // of useless work and from the humiliation of coming up with a ridiculous answer
        _dwSearchFlags = WT_NOTIFYFOLDERENTER | WT_EXCLUDEWALKROOT;
        if (_dwMatch & FILE_ATTRIBUTE_DIRECTORY)
        {
            _dwSearchFlags |= WT_FOLDERONLY;
        }
        else
        {
            // Note that this does the right thing if the file has no extension
            LPTSTR pszExt = PathFindExtension(_ofd.cFileName);
            _wszSearchSpec[0] = L'*';
            SHTCharToUnicode(pszExt, &_wszSearchSpec[1], ARRAYSIZE(_wszSearchSpec) - 1);
            _pwszSearchSpec = _wszSearchSpec;

            // Shortcuts to shortcuts are generally not allowed, but the
            // Personal Start Menu uses them for link tracking purposes...
            _fFindLnk = PathIsLnk(_ofd.cFileName);
        }
    }
    return hr;
}

//
// Compare two FileTime structures.  First, see if they're really equal
// (using CompareFileTime).  If not, see if one has 10ms granularity,
// and if the other rounds down to the same value.  This is done
// to handle the case where a file is moved from NTFS to FAT;
// FAT file tiems are 10ms granularity, while NTFS is 100ns.  When
// an NTFS file is moved to FAT, its time is rounded down.
//

#define NTFS_UNITS_PER_FAT_UNIT  100000

BOOL IsEqualFileTimesWithTruncation(const FILETIME *pft1, const FILETIME *pft2)
{
    ULARGE_INTEGER uli1, uli2;
    ULARGE_INTEGER *puliFAT, *puliNTFS;
    FILETIME ftFAT, ftNTFS;

    if (0 == CompareFileTime(pft1, pft2))
        return TRUE;

    uli1.LowPart  = pft1->dwLowDateTime;
    uli1.HighPart = pft1->dwHighDateTime;

    uli2.LowPart  = pft2->dwLowDateTime;
    uli2.HighPart = pft2->dwHighDateTime;

    // Is one of the times 10ms granular?

    if (0 == (uli1.QuadPart % NTFS_UNITS_PER_FAT_UNIT))
    {
        puliFAT = &uli1;
        puliNTFS = &uli2;
    }
    else if (0 == (uli2.QuadPart % NTFS_UNITS_PER_FAT_UNIT))
    {
        puliFAT = &uli2;
        puliNTFS = &uli1;
    }
    else
    {
        // Neither time appears to be FAT, so they're
        // really different.
        return FALSE;
    }

    // If uliNTFS is already 10ms granular, then again the two times
    // are really different.

    if (0 == (puliNTFS->QuadPart % NTFS_UNITS_PER_FAT_UNIT))
    {
        return FALSE;
    }

    // Now see if the FAT time is the same as the NTFS time
    // when the latter is rounded down to the nearest 10ms.

    puliNTFS->QuadPart = (puliNTFS->QuadPart / NTFS_UNITS_PER_FAT_UNIT) * NTFS_UNITS_PER_FAT_UNIT;

    ftNTFS.dwLowDateTime = puliNTFS->LowPart;
    ftNTFS.dwHighDateTime = puliNTFS->HighPart;
    ftFAT.dwLowDateTime = puliFAT->LowPart;
    ftFAT.dwHighDateTime = puliFAT->HighPart;

    return (0 == CompareFileTime(&ftFAT, &ftNTFS));
}

//
// compute a weighted score for a given find
//
int CLinkResolver::_ScoreFindData(const WIN32_FIND_DATA *pfd)
{
    int iScore = 0;

    BOOL bSameName = lstrcmpi(_ofd.cFileName, pfd->cFileName) == 0;

    BOOL bSameExt = lstrcmpi(PathFindExtension(_ofd.cFileName), PathFindExtension(pfd->cFileName)) == 0;

    BOOL bHasCreateDate = !IsNullTime(&pfd->ftCreationTime);

    BOOL bSameCreateDate = bHasCreateDate &&
                      IsEqualFileTimesWithTruncation(&pfd->ftCreationTime, &_ofd.ftCreationTime);

    BOOL bSameWriteTime  = !IsNullTime(&pfd->ftLastWriteTime) &&
                      IsEqualFileTimesWithTruncation(&pfd->ftLastWriteTime, &_ofd.ftLastWriteTime);

    if (bSameName || bSameCreateDate)
    {
        if (bSameName)
            iScore += bHasCreateDate ? 16 : 32;

        if (bSameCreateDate)
        {
            iScore += 32;

            if (bSameExt)
                iScore += 8;
        }

        if (bSameWriteTime)
            iScore += 8;

        if (pfd->nFileSizeLow == _ofd.nFileSizeLow)
            iScore += 4;

        // if it is in the same folder as the original give it a slight bonus
        iScore += _iFolderBonus;
    }
    else
    {
        // doesn't have create date, apply different rules

        if (bSameExt)
            iScore += 8;

        if (bSameWriteTime)
            iScore += 8;

        if (pfd->nFileSizeLow == _ofd.nFileSizeLow)
            iScore += 4;
    }

    return iScore;
}

//
//  Helper function for both EnterFolder and FoundFile
//
HRESULT CLinkResolver::_ProcessFoundFile(LPCTSTR pszPath, WIN32_FIND_DATAW * pwfdw)
{
    HRESULT hr = S_OK;

    if (_fFindLnk || !PathIsLnk(pwfdw->cFileName))
    {
        // both are files or folders, see how it scores
        int iScore = _ScoreFindData(pwfdw);

        if (iScore > _iScore)
        {
            _fdFound = *pwfdw;

            // store the score and fully qualified path
            _iScore = iScore;
            StrCpyN(_fdFound.cFileName, pszPath, ARRAYSIZE(_fdFound.cFileName));
        }
    }

    if ((_iScore >= MIN_NO_UI_SCORE) || (GetTickCount() >= _dwTimeLimit))
    {
        _bContinue = FALSE;
        hr = E_FAIL;
    }
    
    return hr;
}

// IShellTreeWalkerCallBack::FoundFile

HRESULT CLinkResolver::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (!_bContinue)
    {
        return E_FAIL;
    }

    // We should've excluded files if we're looking for a folder
    ASSERT(!(_dwMatch & FILE_ATTRIBUTE_DIRECTORY));

    return _ProcessFoundFile(pwszPath, pwfd);
}

//
// IShellTreeWalkerCallBack::EnterFolder
//
HRESULT CLinkResolver::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hr = S_OK;
    //  Respond quickly to the Cancel button.
    if (!_bContinue)
    {
        return E_FAIL;
    }

    // Once we enter a directory, we lose the "we are still in the starting
    // folder" bonus.
    _iFolderBonus = 0;

    if (PathIsPrefix(pwszPath, _pszSearchOrigin) || IS_SYSTEM_HIDDEN(pwfd->dwFileAttributes))
    {
        // If we're about to enter a directory we've already looked in,
        // or if this is superhidden (implies recycle bin dirs), then skip it.
        return S_FALSE;
    }

    // If our target was a folder, treat this folder as a file found
    if (_dwMatch & FILE_ATTRIBUTE_DIRECTORY)
    {
        hr = _ProcessFoundFile(pwszPath, pwfd);
    }
    return hr;
}

BOOL CLinkResolver::_SearchInFolder(LPCTSTR pszFolder, int cLevels)
{
    int iMaxDepth = 0;

    // cLevels == -1 means inifinite depth
    if (cLevels != -1)
    {
        _dwSearchFlags |= WT_MAXDEPTH;
        iMaxDepth = cLevels;
    }
    else
    {
        _dwSearchFlags &= ~WT_MAXDEPTH;
    }

    // Our folder bonus code lies on the fact that files in the
    // starting folder come before anything else.
    ASSERT(!(_dwSearchFlags & WT_FOLDERFIRST));

    _pstw->WalkTree(_dwSearchFlags, pszFolder, _pwszSearchSpec, iMaxDepth, SAFECAST(this, IShellTreeWalkerCallBack *));
    _iFolderBonus = 0; // You only get one chance at the folder bonus
    return _bContinue;
}

//
// search function for heuristic based link resolution
// the result will be in _fdFound.cFileName
//
void CLinkResolver::_HeuristicSearch()
{
    if (!SHRestricted(REST_NORESOLVESEARCH) &&
        !(SLR_NOSEARCH & _dwResolveFlags) &&
        SUCCEEDED(_InitWalkObject()))
    {
        int cUp = LNKTRACK_HINTED_UPLEVELS;
        BOOL bSearchOrigin = TRUE;
        TCHAR szRealSearchOrigin[MAX_PATH], szFolderPath[MAX_PATH];

        // search up from old location

        // In the olden days pszSearchOriginFirst was verified to be a valid directory
        // (ie it returned TRUE to PathIsDirectory) and _HeuristicSearch was never called
        // if this was not true.  Alas, this is no more.  Why not search the desktop and
        // fixed drives anyway?  In the interest of saving some time the check that used
        // to be in FindInFolder which caused an early out is now here instead.  The rub
        // is that we only skip the downlevel search of the original volume instead of
        // skipping the entire link resolution phase.

        StringCchCopy(szRealSearchOrigin, ARRAYSIZE(szRealSearchOrigin), _pszSearchOriginFirst);
        while (!PathIsDirectory(szRealSearchOrigin))
        {
            if (PathIsRoot(szRealSearchOrigin) || !PathRemoveFileSpec(szRealSearchOrigin))
            {
                DebugMsg(DM_TRACE, TEXT("root path does not exists %s"), szRealSearchOrigin);
                bSearchOrigin = FALSE;
                break;
            }
        }

        if (bSearchOrigin)
        {
            StringCchCopy(szFolderPath, ARRAYSIZE(szFolderPath), szRealSearchOrigin);
            _pszSearchOrigin = szRealSearchOrigin;

            // Files found in the starting folder get a slight bonus.
            // _iFolderBonus is set to zero by
            // CLinkResolver::EnterFolder when we leave
            // the starting folder and enter a new one.

            _iFolderBonus = 2;

            while (cUp-- != 0 && _SearchInFolder(szFolderPath, LNKTRACK_HINTED_DOWNLEVELS))
            {
                if (PathIsRoot(szFolderPath) || !PathRemoveFileSpec(szFolderPath))
                    break;
            }
        }

        if (_bContinue)
        {
            // search down from desktop
            if (S_OK == SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szFolderPath))
            {
                _pszSearchOrigin = szFolderPath;
                _SearchInFolder(szFolderPath, LNKTRACK_DESKTOP_DOWNLEVELS);
            }
        }

        if (_bContinue)
        {
            // search down from root of fixed drives
            TCHAR szRoot[4];
            _pszSearchOrigin = szRoot;

            for (int i = 0; _bContinue && (i < 26); i++)
            {
                if (GetDriveType(PathBuildRoot(szRoot, i)) == DRIVE_FIXED)
                {
                    StringCchCopy(szFolderPath, ARRAYSIZE(szFolderPath), szRoot);
                    _SearchInFolder(szFolderPath, LNKTRACK_ROOT_DOWNLEVELS);
                }
            }
        }

        if (_bContinue && bSearchOrigin)
        {
            // resume search of last volume (should do an exclude list)
            StringCchCopy(szFolderPath, ARRAYSIZE(szFolderPath), szRealSearchOrigin);
            _pszSearchOrigin = szRealSearchOrigin;

            while (_SearchInFolder(szFolderPath, -1))
            {
                if (PathIsRoot(szFolderPath) || !PathRemoveFileSpec(szFolderPath))
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shell32p.h ===
//
//  This file contains definintions of WINUTIL helper functions that are
// exported from SHELL32.DLL. These functions are used only by WUTILS32
// to deal with 16-bit CPL files. Note that SHELL32.DLL just provide
// thunk layer for those functions whose bodies reside in SHELL.DLL.
//
// History:
//  09-20-93 SatoNa     Created
//

// This file is solely for Win9x 16-bit support
//
#ifndef WINNT

#define ISVALIDHINST16(hinst16) ((UINT_PTR)hinst16 >= (UINT_PTR)32)

//
// protos for thunks.  half is in shell32.dll, half in shell.dll
//
//  Notes: CALLCPLEntry16 is defined in shsemip.h
//
DWORD WINAPI GetModuleFileName16(HINSTANCE hinst, LPTSTR szFileName, DWORD cbMax);
HMODULE WINAPI GetModuleHandle16(LPCTSTR szName);

#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shellprv.h ===
#ifndef _SHELLPRV_H_
#define _SHELLPRV_H_

// We now always rely on Win2k or Millennium at least.
#define OVERRIDE_SHLWAPI_PATH_FUNCTIONS     // see comment in shsemip.h

#define _SHELL32_
#define _WIN32_DCOM     // for COINIT_DISABLE_OLE1DDE

#ifdef __cplusplus
#define NO_INCLUDE_UNION
#endif  /* __cplusplus */

#define NOWINDOWSX
#ifndef STRICT
#define STRICT
#endif
#define OEMRESOURCE // FSMenu needs the menu triangle

#define INC_OLE2
#define CONST_VTABLE

// Disable a few warnings so we can include the system header files at /W4.
#include "w4warn.h"
#pragma warning(disable:4706) // assignment within conditional expression
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4131) // 'CreateInfoFile' : uses old-style declarator
#pragma warning(disable:4221) // nonstandard extension used : 'pFrom' : cannot be initialized using address of automatic variable 'szBBPathToNuke'
#pragma warning(disable:4245) // 'initializing' : conversion from 'const int' to 'const DWORD', signed/unsigned mismatch
#pragma warning(disable:4057) // '=' : 'CHAR *' differs in indirection to slightly different base types from 'PBYTE '
#pragma warning(disable:4189) // 'fWrite' : local variable is initialized but not referenced
#pragma warning(disable:4701) // local variable 'lListIndex' may be used without having been initialized
#pragma warning(disable:4213) // nonstandard extension used : cast on l-value
#pragma warning(disable:4702) // unreachable code
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4210) // nonstandard extension used : function given file scope
#pragma warning(disable:4055) // 'type cast' : from data pointer 'IDataObject *' to function pointer 'FARPROC '
#pragma warning(disable:4267) // '=' : conversion from 'size_t' to 'UINT', possible loss of data
#pragma warning(disable:4328) // indirection alignment of formal parameter 4 (2) is greater than the actual argument alignment (1)

//  These NT headers must come before <windows.h> or you get redefinition
//  errors!  It's a miracle the system builds at all...
#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */
#include <nt.h>         // Some of the NT specific code needs Rtl functions
#include <ntrtl.h>      // which requires all of these header files...
#include <nturtl.h>
#include <ntseapi.h>
#include <dfsfsctl.h>

#ifdef __cplusplus
}       /* End of extern "C" */
#endif  /* __cplusplus */

#define CC_INTERNAL   // this is because docfind uses the commctrl internal prop sheet structures

//--------------------------------------------------------------------------
//
//  The order of these is critical for ATL.
//
//  1.  ATL has its own definition of InlineIsEqualGUID that conflicts with
//      the definition in <objbase.h>, so we must explicitly include
//      <ole2.h> to get the <objbase.h> definition, then use a hacky macro
//      to disable the ATL version so it doesn't conflict with the OLE one.
//
//  2.  ATL has methods called SubclassWindow, which conflicts with a
//      macro in <windowsx.h>, so we must include <windowsx.h> after ATL.
//
//  3.  We want ATL to use the shell debug macros, so we must include
//      <debug.h> before ATL so it can see the shell debug macros.
//
//  4.  VariantInit is such a trivial function that we inline it in order
//      to avoid pulling in OleAut32.
//
//  5.  We want ATL to use the shell version of the ANSI/UNICODE conversion
//      functions (because the shell versions can be called from C).
//

#include <oaidl.h>
#include <docobj.h>

#include <windows.h>
#include "shfusion.h"
#include <ole2.h>           // Get the real InlineIsEqualGUID
#define _ATL_NO_DEBUG_CRT   // Use the shell debug macros
#include <stddef.h>
#include <debug.h>          // Get the shell debug macros
#include <shconv.h>         // Shell version of <atlconv.h>
 

#define VariantInit(p) memset(p, 0, sizeof(*(p)))

#ifdef __cplusplus

#define _ATL_APARTMENT_THREADED

#ifndef _SYS_GUID_OPERATORS_
// Re-route the ATL version of InlineIsEqualGUID
#define InlineIsEqualGUID ATL_InlineIsEqualGUID
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>
#include <atliface.h>
#include <atlwin.h>

#ifndef _SYS_GUID_OPERATORS_
#undef InlineIsEqualGUID    // Return InlineIsEqualGUID to its normal state
#endif

#include <memt.h>

#endif  /* __cplusplus */

// end of ATL Stuff
//--------------------------------------------------------------------------
#ifndef _SYS_GUID_OPERATORS_
#ifdef _OLE32_ // {
// turning on _OLE32_ (which we did for delay load stuff) gives us f-a-t
// versions of IsEqualGUID.  undo that here (hack on top of a hack...)
#undef IsEqualGUID
#ifdef __cplusplus
__inline BOOL IsEqualGUID(IN REFGUID rguid1, IN REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
#else   //  ! __cplusplus
#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#endif  //  __cplusplus
#endif // }
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// This flag indicates that we are on a system where data alignment is a concern

#if (defined(UNICODE) && (defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)))
#define ALIGNMENT_SCENARIO
#endif

#include <windowsx.h>
#include <winnetp.h>

//  Dependencies among header files:
//
//      <oaidl.h> must come before <shlwapi.h> if you want to have
//      OLE command target helper functions.
//
#include <hlink.h> // must include before shellp in order to get IBrowserService2!
#include <commctrl.h>
#include <shellapi.h>
#include <wininet.h>
#include <shlobj.h>

#include <shlwapi.h>
#include <commdlg.h>
#include <port32.h>         // in    shell\inc
#define DISALLOW_Assert
#include <linkinfo.h>
#include <shlobjp.h>
#include <shsemip.h>
#include <docobj.h>
#include <shguidp.h>
#include <ieguidp.h>
#include <shellp.h>
#include <shdocvw.h>
#include <iethread.h>
#include "browseui.h"
#include <ccstock.h>
#include <ccstock2.h>
#include <objidl.h>
#include "apithk.h"
#define SECURITY_WIN32
#include <security.h>
#include <mlang.h>
#include <regapix.h>        // MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH
#include <heapaloc.h>
#include <fmifs.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "util.h"
#include "varutil.h"
#include "cstrings.h"
#include "securent.h"
#include "winprtp.h"

#include "qistub.h"
#ifdef DEBUG
#include "dbutil.h"
#endif

#define CP_HEBREW        1255
#define CP_ARABIC        1256

EXTERN_C const ITEMIDLIST c_idlDesktop;   // NULL IDList

#undef CharNext
#undef CharPrev

#define CharNext(x) ((x)+1)
#define CharPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)

// these functions are not available on NT
#undef ReinitializeCriticalSection
#undef LoadLibrary16
#undef FreeLibrary16
#undef GetProcAddress16
#define ReinitializeCriticalSection #error_ReinitializeCriticalSection_not_available_on_NT
#define LoadLibrary16 #error_LoadLibrary16_not_available_on_NT
#define FreeLibrary16 #error_FreeLibrary16_not_available_on_NT
#define GetProcAddress16 #error_GetProcAddress16_not_available_on_NT
#define GetModuleHandle16(sz) (0)
#define GetModuleFileName16(hinst, buf, cch) buf[0]='\0'

DWORD
SetPrivilegeAttribute(
    IN  LPCTSTR PrivilegeName,
    IN  DWORD   NewPrivilegeAttributes,
    OUT DWORD   *OldPrivilegeAttribute
    );


// drivesx.c
BOOL IsUnavailableNetDrive(int iDrive);
BOOL IsDisconnectedNetDrive(int iDrive);
BOOL IsAudioDisc(LPTSTR pszDrive);
BOOL IsDVDDisc(int iDrive);

// futil.c
BOOL  IsShared(LPNCTSTR pszPath, BOOL fUpdateCache);
DWORD GetConnection(LPCTSTR lpDev, LPTSTR lpPath, UINT cbPath, BOOL bConvertClosed);

// rundll32.c
HWND _CreateStubWindow(POINT* ppt, HWND hwndParent);
#define STUBM_SETDATA       (WM_USER)
#define STUBM_GETDATA       (WM_USER + 1)
#define STUBM_SETICONTITLE  (WM_USER + 2)

#define STUBCLASS_PROPSHEET     1
#define STUBCLASS_FORMAT        2

// shlexe.c
BOOL IsDarwinEnabled();
STDAPI ParseDarwinID(LPTSTR pszDarwinDescriptor, LPTSTR pszDarwinCommand, DWORD cchDarwinCommand);

// shprsht.c
typedef struct {
    HWND    hwndStub;
    HANDLE  hClassPidl;
    HICON   hicoStub;
} UNIQUESTUBINFO;
STDAPI_(BOOL) EnsureUniqueStub(LPITEMIDLIST pidl, int iClass, POINT *ppt, UNIQUESTUBINFO *pusi);
STDAPI_(void) FreeUniqueStub(UNIQUESTUBINFO *pusi);
STDAPI_(void) SHFormatDriveAsync(HWND hwnd, UINT drive, UINT fmtID, UINT options);

// bitbuck.c
void  RelayMessageToChildren(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL IsFileInBitBucket(LPCTSTR pszPath);

BOOL CreateWriteCloseFile(HWND hwnd, LPCTSTR pszFileName, void *pv, DWORD cbData);

// idlist.c
STDAPI_(BOOL) SHIsValidPidl(LPCITEMIDLIST pidl);

STDAPI_(BOOL) IsExeTSAware(LPCTSTR pszExe);

// exec stuff

/* common exe code with error handling */
#define SECL_USEFULLPATHDIR     0x00000001
#define SECL_NO_UI              0x00000002
#define SECL_SEPARATE_VDM       0x00000004
#define SECL_LOG_USAGE          0x00000008
BOOL ShellExecCmdLine(HWND hwnd, LPCTSTR lpszCommand, LPCTSTR lpszDir,
        int nShow, LPCTSTR lpszTitle, DWORD dwFlags);
#define ISSHELLEXECSUCCEEDED(hinst) ((UINT_PTR)hinst>32)
#define ISWINEXECSUCCEEDED(hinst)   ((UINT_PTR)hinst>=32)
void _ShellExecuteError(LPSHELLEXECUTEINFO pei, LPCTSTR lpTitle, DWORD dwErr);

// fsnotify.c (private stuff) ----------------------

BOOL SHChangeNotifyInit();
STDAPI_(void) SHChangeNotifyTerminate(BOOL bLastTerm, BOOL bProcessShutdown);
void SHChangeNotifyReceiveEx(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime);
LRESULT SHChangeNotify_OnNotify(WPARAM wParam, LPARAM lParam);
LRESULT SHChangeNotify_OnChangeRegistration(WPARAM wParam, LPARAM lParam);
LRESULT SHChangeNotify_OnNotifySuspendResume(WPARAM wParam, LPARAM lParam);
LRESULT SHChangeNotify_OnDeviceChange(ULONG_PTR code, struct _DEV_BROADCAST_HDR *pbh);
void    SHChangeNotify_DesktopInit();
void    SHChangeNotify_DesktopTerm();
STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);

void _Shell32ThreadAddRef(BOOL fLeaveSuspended);
void _Shell32ThreadRelease(UINT nClients);
void _Shell32ThreadAwake(void);

// Entry points for managing registering name to IDList translations.
void NPTRegisterNameToPidlTranslation(LPCTSTR pszPath, LPCITEMIDLIST pidl);
LPWSTR NPTMapNameToPidl(LPCWSTR pszPath, LPCITEMIDLIST *ppidl);

// path.c (private stuff) ---------------------

#define PQD_NOSTRIPDOTS 0x00000001

STDAPI_(void) PathQualifyDef(LPTSTR psz, LPCTSTR szDefDir, DWORD dwFlags);

STDAPI_(BOOL) PathIsRemovable(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsRemote(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsTemporary(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsWild(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsLnk(LPCTSTR pszFile);
STDAPI_(BOOL) PathIsSlow(LPCTSTR pszFile, DWORD dwFileAttr);
STDAPI_(BOOL) PathIsInvalid(LPCTSTR pPath);
STDAPI_(BOOL) PathIsBinaryExe(LPCTSTR szFile);
STDAPI_(BOOL) PathMergePathName(LPTSTR pPath, LPCTSTR pName);
STDAPI_(BOOL) PathGetMountPointFromPath(LPCTSTR pcszPath, LPTSTR pszMountPoint, int cchMountPoint);
STDAPI_(BOOL) PathIsShortcutToProgram(LPCTSTR pszFile);

#if (defined(UNICODE) && (defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)))

#else

#define uaPathFindExtension PathFindExtension

#endif

void SpecialFolderIDTerminate();
void ReleaseRootFolders();
extern HINSTANCE g_hinst;

// get the desktop HWND if it is this process...
HWND GetInProcDesktop();

// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
extern BOOL g_bMirroredOS;

// Is DATE_LTRREADING supported by GetDateFormat() API?  (it is supported in all the BiDi platforms.)
extern BOOL g_bBiDiPlatform;

// for control panel and printers folder:
extern TCHAR const c_szNull[];
extern TCHAR const c_szDotDot[];
extern TCHAR const c_szRunDll[];
extern TCHAR const c_szNewObject[];


// lang platform
extern UINT g_uCodePage;


// other stuff
#define HINST_THISDLL   g_hinst

//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in shellp.h)
//

// Trace flags
#define TF_IMAGE            0x00000010      // Image/icon related stuff
#define TF_PROPERTY         0x00000020      // Property traces
#define TF_PATH             0x00000040      // Path whacking traces
#define TF_MENU             0x00000080      // Menu stuff
#define TF_ALLOC            0x00000100      // Allocation traces
#define TF_REG              0x00000200      // Registry traces
#define TF_DDE              0x00000400      // Shell progman DDE message tracing
#define TF_HASH             0x00000800      // Hash table stuff
#define TF_ASSOC            0x00001000      // File/URL Association traces
#define TF_FILETYPE         0x00002000      // File Type stuff
#define TF_SHELLEXEC        0x00004000      // ShellExecute stuff
#define TF_OLE              0x00008000      // OLE-specific stuff
#define TF_DEFVIEW          0x00010000      // Defview
#define TF_PERF             0x00020000      // Performance timings
#define TF_FSNOTIFY         0x00040000      // FSNotify stuff
#define TF_LIFE             0x00080000      // Object lifetime traces
#define TF_IDLIST           0x00100000      // "PIDLy" things
#define TF_FSTREE           0x00200000      // FSTree traces
#define TF_PRINTER          0x00400000      // Printer traces
//#define TF_QISTUB          0x00800000      // defined in unicpp\shellprv.h
#define TF_DOCFIND          0x01000000      // DocFind
#define TF_MENUBAND         0x02000000      // menubands
#define TF_CPANEL           0x10000000      // Control Panel
#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2


// "Olde names"
#define DM_ALLOC            TF_ALLOC
#define DM_REG              TF_REG

// Function trace flags
#define FTF_DEFVIEW         0x00000004      // DefView calls
#define FTF_DDE             0x00000008      // DDE functions
#define FTF_CPANEL          0x00000010      // Control Panel

// Dump flags
#define DF_INTSHCUT         0x00000001      // Internet shortcut structures
#define DF_HASH             0x00000002      // Hash table
#define DF_FSNPIDL          0x00000004      // Pidl for FSNotify
#define DF_URLPROP          0x00000008      // URL property structures
#define DF_DEBUGQI          0x00000010
#define DF_DEBUGQINOREF     0x00000020
#define DF_ICONCACHE        0x00000040      // Icon cache
#define DF_CLASSFLAGS       0x00000080      // File class cache
#define DF_DELAYLOADDLL     0x00000100      // Delay load

// Break flags
#define BF_ONLOADED         0x00000010      // Stop when loaded
#define BF_COCREATEINSTANCE 0x10000000      // On CoCreateInstance failure

// Debugging strings
#define GEN_DEBUGSTRW(str)  ((str) ? (str) : L"<Null Str>")
#define GEN_DEBUGSTRA(str)  ((str) ? (str) : "<Null Str>")

#ifdef UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRW
#else // UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRA
#endif // UNICODE

// Note:  raymondc - ATOMICRELEASE isn't particularly atomic.  There is a race
// condition if two people try to ATOMICRELEASE the same thing simultaneously.

// shorthand
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#   ifdef __cplusplus
#       define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#   else
#       define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#   endif
#endif
#endif //ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif
#define SAFERELEASE(p) ATOMICRELEASE(p)


// fileicon.c
void    FileIconTerm(void);


#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

void ReplaceParams(LPTSTR szDst, LPCTSTR szFile);


#ifdef __IPropertyStorage_INTERFACE_DEFINED__
WINSHELLAPI HRESULT SHPropVariantClear(PROPVARIANT * ppropvar);
WINSHELLAPI HRESULT SHFreePropVariantArray(ULONG cel, PROPVARIANT * ppropvar);
WINSHELLAPI HRESULT SHPropVariantCopy(PROPVARIANT * ppropvar, const PROPVARIANT * ppropvarFrom);
#endif


//
// fsassoc.c
//

#define GCD_MUSTHAVEOPENCMD     0x0001
#define GCD_ADDEXETODISPNAME    0x0002  // must be used with GCD_MUSTHAVEOPENCMD
#define GCD_ALLOWPSUDEOCLASSES  0x0004  // .ext type extensions

// Only valid when used with FillListWithClasses
#define GCD_MUSTHAVEEXTASSOC    0x0008  // There must be at least one extension assoc

BOOL GetClassDescription(HKEY hkClasses, LPCTSTR pszClass, LPTSTR szDisplayName, int cbDisplayName, UINT uFlags);

//
// Registry key handles
//
extern HKEY g_hklmApprovedExt;      // For approved shell extensions

// always zero, see init.c
extern const LARGE_INTEGER g_li0;
extern const ULARGE_INTEGER g_uli0;


// from fstree.cpp and drives.cpp

STDAPI SFVCB_OnAddPropertyPages(IN DWORD pv, IN SFVM_PROPPAGE_DATA * ppagedata);

//
// this used to be in shprst.c
//

#define MAX_FILE_PROP_PAGES 32

HKEY NetOpenProviderClass(HDROP);
void OpenNetResourceProperties(HWND, HDROP);

// msgbox.c
// Constructs strings like ShellMessagebox "xxx %1%s yyy %2%s..."
LPTSTR WINCAPI ShellConstructMessageString(HINSTANCE hAppInst, LPCTSTR lpcText, ...);

//  Copy.c
#define SPEED_SLOW  400
DWORD GetPathSpeed(LPCTSTR pszPath);


// SharedFldr.cpp
STDAPI_(BOOL) SHShowSharedFolders();


// mulprsht.c

STDAPI_(BOOL) SHEncryptFile(LPCTSTR pszPath, BOOL fEncrypt);
// wuutil.c
void cdecl SetFolderStatusText(HWND hwndStatus, int iField, UINT ids,...);

#ifdef DEBUG
extern BOOL  g_bInDllEntry;

#undef SendMessage
#define SendMessage  SendMessageD
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

//
//  The DEBUG build validates that every class we register is in the
//  unregister list so we don't leak classes at unload.
//
#undef RegisterClass
#undef RegisterClassEx
#define RegisterClass       RegisterClassD
#define RegisterClassEx     RegisterClassExD
ATOM WINAPI RegisterClassD(CONST WNDCLASS *lpWndClass);
ATOM WINAPI RegisterClassExD(CONST WNDCLASSEX *lpWndClass);
#endif // DEBUG

#ifdef UNICODE
#define RealRegisterClass   RegisterClassW
#define RealRegisterClassEx RegisterClassExW
#else
#define RealRegisterClass   RegisterClassA
#define RealRegisterClassEx RegisterClassExA
#endif

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow sends interthreadmessages,
//  which is not obvious.
//
#ifdef DEBUG
#undef  FindWindow
#undef  FindWindowEx
#define FindWindow              FindWindowD
#define FindWindowEx            FindWindowExD

STDAPI_(HWND) FindWindowD  (LPCTSTR lpClassName, LPCTSTR lpWindowName);
STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName);
#ifdef UNICODE
#define RealFindWindowEx        FindWindowExW
#else
#define RealFindWindowEx        FindWindowExA
#endif // UNICODE
#endif // DEBUG

// our wrapper for GetCompressedFileSize, which is NT only
STDAPI_(DWORD) SHGetCompressedFileSizeW(LPCWSTR pszFileName, LPDWORD pFileSizeHigh);

#undef GetCompressedFileSize
#define GetCompressedFileSize SHGetCompressedFileSize

#ifdef UNICODE
#define SHGetCompressedFileSize SHGetCompressedFileSizeW
#else
#define SHGetCompressedFileSize #error // not implemented, because its an nt only API
#endif // UNICODE

#define ASSERTDLLENTRY      ASSERT(g_bInDllEntry);

//
// STATIC macro
//
#ifndef STATIC
#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif
#endif

//
// Debug helper functions
//


//
// Validation functions
//

BOOL IsValidPSHELLEXECUTEINFO(LPSHELLEXECUTEINFO pei);


#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = SIZEOF(SHELLEXECUTEINFO);

#ifdef DEBUG
#if 1
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}
#else
    __inline DWORD clockrate() {return 1000;}
    __inline DWORD clock()     {return GetTickCount();}
#endif

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEIN(t)     t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) TraceMsg(TF_PERF, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEIN(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

// in extract.c
STDAPI_(DWORD) GetExeType(LPCTSTR pszFile);
STDAPI_(UINT)  ExtractIcons(LPCTSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);

/*
in pickicon.c
Return Values for PickIconDlgWithTitle()

User Operation       Return Values
Cancel            -> HRESULT_FROM_WIN32(ERROR_CANCELLED) 
Ok                -> S_OK
RestoreDefault    -> S_FALSE
*/
STDAPI PickIconDlgWithTitle(HWND hwnd, LPCTSTR pszTitle, BOOL bShowRestoreButton, LPTSTR pszIconPath, UINT cbIconPath, int *piIconIndex);


// defxicon.c

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCTSTR pszModule, int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags, REFIID riid, void **pxiconOut);
STDAPI SHCreateDefExtIcon(LPCTSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, int iDefIcon, REFIID riid, void **pxiconOut);


STDAPI_(UINT) SHSysErrorMessageBox(HWND hwnd, LPCTSTR pszTitle, UINT idTemplate, DWORD err, LPCTSTR pszParam, UINT dwFlags);

//======Hash Item=============================================================
typedef struct _HashTable **HHASHTABLE;
#define PHASHITEM LPCTSTR

typedef void (CALLBACK *HASHITEMCALLBACK)(HHASHTABLE hht, LPCTSTR sz, UINT wUsage, DWORD_PTR param);

STDAPI_(LPCTSTR) FindHashItem  (HHASHTABLE hht, LPCTSTR lpszStr);
STDAPI_(LPCTSTR) AddHashItem   (HHASHTABLE hht, LPCTSTR lpszStr);
STDAPI_(LPCTSTR) DeleteHashItem(HHASHTABLE hht, LPCTSTR lpszStr);
STDAPI_(LPCTSTR) PurgeHashItem (HHASHTABLE hht, LPCTSTR lpszStr);

#define     GetHashItemName(pht, sz, lpsz, cch)  StringCchCopy(lpsz, cch, sz)

HHASHTABLE  WINAPI CreateHashItemTable(UINT wBuckets, UINT wExtra);
void        WINAPI DestroyHashItemTable(HHASHTABLE hht);

void        WINAPI SetHashItemData(HHASHTABLE hht, LPCTSTR lpszStr, int n, DWORD_PTR dwData);
DWORD_PTR   WINAPI GetHashItemData(HHASHTABLE hht, LPCTSTR lpszStr, int n);
void *      WINAPI GetHashItemDataPtr(HHASHTABLE hht, LPCTSTR lpszStr);

void        WINAPI EnumHashItems(HHASHTABLE hht, HASHITEMCALLBACK callback, DWORD_PTR dwParam);

#ifdef DEBUG
void        WINAPI DumpHashItemTable(HHASHTABLE hht);
#endif


//======== Text thunking stuff ===========================================================
typedef struct _THUNK_TEXT_
{
    LPTSTR m_pStr[1];
} ThunkText;

#ifdef UNICODE
    typedef CHAR        XCHAR;
    typedef LPSTR       LPXSTR;
    typedef const XCHAR * LPCXSTR;
    #define lstrlenX(r) lstrlenA(r)
#else // unicode
    typedef WCHAR       XCHAR;
    typedef LPWSTR      LPXSTR;
    typedef const XCHAR * LPCXSTR;
    #define lstrlenX(r) lstrlenW(r)
#endif // unicode

ThunkText * ConvertStrings(UINT cCount, ...);

#include "uastrfnc.h"
#ifdef __cplusplus
}       /* End of extern "C" { */
#endif /* __cplusplus */

#include <help.h>


//======== Discriminate inclusion ========================================

#ifndef NO_INCLUDE_UNION        // define this to avoid including all
                                // of the extra files that were not
                                // previously included in shellprv.h
#include <wchar.h>
#include <tchar.h>

#include <process.h>
#include <wowshlp.h>
#include <vdmapi.h>
#include "shell.h"
#include "dde.h"
#include <regstr.h>
#include "findhlp.h"
#include <dlgs.h>
#include <msprintx.h>
#include <pif.h>
#include <windisk.h>
#include <brfcasep.h>
#include <trayp.h>
#include <brfcasep.h>
#include <wutilsp.h>
#include "bitbuck.h"
#include "drawpie.h"
#include "fileop.h"
#include "pidl.h"
#include "ids.h"
#include <newexe.h>
#include "ole2dup.h"
#include "os.h"
#include "privshl.h"
#include "reglist.h"
#include "shell32p.h"
#include "shitemid.h"
#include "undo.h"
#include "views.h"

// NT shell uses 32-bit version of this pifmgr code.
#ifndef NO_PIF_HDRS
#include "pifmgrp.h"
#include "piffntp.h"
#include "pifinfp.h"
#include "doshelp.h"
#include "machinep.h"   // Japanese domestic machine (NEC) support
#endif

#endif // NO_INCLUDE_UNION

#include "shdguid.h"

#define SetWindowBits SHSetWindowBits
#define IsSameObject SHIsSameObject
#define IsChildOrSelf SHIsChildOrSelf
#define MenuIndexFromID  SHMenuIndexFromID
#define _GetMenuFromID  SHGetMenuFromID
#define GetCurColorRes SHGetCurColorRes
#define WaitForSendMessageThread SHWaitForSendMessageThread

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

// Stack allocated BSTR (to avoid calling SysAllocString)
typedef struct _SA_BSTR {
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))

//
//  The cb field of a BSTR is the count of bytes, not including the
//  terminating L('\0').
//
//
//  DECLARE_CONST_BSTR - Goes into header file (if any)
//  DEFINE_CONST_BSTR  - Creates the variable, must already be declared
//  MAKE_CONST_BSTR    - Combines DECLARE and DEFINE
//
#define DECLARE_CONST_BSTR(name, str) \
 extern const struct BSTR##name { ULONG cb; WCHAR wsz[sizeof(str)/sizeof(WCHAR)]; } name

#define DEFINE_CONST_BSTR(name, str) \
        const struct BSTR##name name = { sizeof(str) - sizeof(WCHAR), str }

#define MAKE_CONST_BSTR(name, str) \
        const struct BSTR##name { ULONG cb; WCHAR wsz[sizeof(str)/sizeof(WCHAR)]; } \
                                name = { sizeof(str) - sizeof(WCHAR), str }

DECLARE_CONST_BSTR(s_sstrIDMember,         L"id");
DECLARE_CONST_BSTR(s_sstrSubSRCMember,     L"subscribed_url");
DECLARE_CONST_BSTR(s_sstrSRCMember,        L"src");

//======== Header file hacks =============================================================

//
//  The compiler will tell us if we are defining these NT5-only parameters
//  incorrectly.  If you get "invalid redefinition" errors, it means that
//  the definition in windows.h changed and we need to change to match.
//

#define ASFW_ANY    ((DWORD)-1)

#define CMIDM_LINK      0x0001
#define CMIDM_COPY      0x0002
#define CMIDM_MOVE      0x0003

// Downlevel shutdown dialog function
DWORD DownlevelShellShutdownDialog(HWND hwndParent, DWORD dwItems, LPCTSTR szUsername);

// from shell32\unicode\format.c
STDAPI_(DWORD) SHChkDskDriveEx(HWND hwnd, LPWSTR pszDrive);

//
// On NT, sometimes CreateDirectory succeeds in creating the directory, but, you can not do
// anything with it that directory. This happens if the directory name being created does
// not have room for an 8.3 name to be tagged onto the end of it,
// i.e., lstrlen(new_directory_name)+12 must be less or equal to MAX_PATH.
//
// the magic # "12" is 8 + 1 + 3 for and 8.3 name.
// 
// The following macro is used in places where we need to detect this to make
// MoveFile to be consistent with CreateDir(files  os.c and copy.c use this)
//

#define  IsDirPathTooLongForCreateDir(pszDir)    ((lstrlen(pszDir) + 12) > MAX_PATH)

// call the shlwapi version of this, note we have an export from shell32 that forwards to this
#define ShellMessageBoxW    ShellMessageBoxWrapW

#define REGSTR_EXPLORER_ADVANCED (REGSTR_PATH_EXPLORER TEXT("\\Advanced"))

#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define RECTWIDTH(rc) ((rc).right - (rc).left)

STDAPI_(BOOL) IsGuimodeSetupRunning();

#endif // _SHELLPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shlexec.h ===
//
//  shlexec.h
//  routines and macros shared between the different shell exec files
//


#ifndef SHLEXEC_H
#define SHLEXEC_H

#ifdef __cplusplus
extern "C" {
#endif

typedef LPSTR LPSZ;
#include "wowshlp.h"

extern LPVOID lpfnWowShellExecCB;

#define CH_GUIDFIRST TEXT('{') // '}'

// These fake ERROR_ values are used to display non-winerror.h available error
// messages. They are mapped to valid winerror.h values in _ShellExecuteError.
#define ERROR_RESTRICTED_APP ((UINT)-1)

#define SEE_MASK_CLASS (SEE_MASK_CLASSNAME|SEE_MASK_CLASSKEY)
#define _UseClassName(_mask) (((_mask)&SEE_MASK_CLASS) == SEE_MASK_CLASSNAME)
#define _UseClassKey(_mask)  (((_mask)&SEE_MASK_CLASS) == SEE_MASK_CLASSKEY)
#define _UseTitleName(_mask) (((_mask)&SEE_MASK_HASTITLE) || ((_mask)&SEE_MASK_HASLINKNAME))

#define SEE_MASK_PIDL (SEE_MASK_IDLIST|SEE_MASK_INVOKEIDLIST)
#define _UseIDList(_mask)     (((_mask)&SEE_MASK_PIDL) == SEE_MASK_IDLIST)
#define _InvokeIDList(_mask)  (((_mask)&SEE_MASK_PIDL) == SEE_MASK_INVOKEIDLIST)
#define _UseHooks(_mask)      (!(pei->fMask & SEE_MASK_NO_HOOKS))

void ActivateHandler(HWND hwnd, DWORD_PTR dwHotKey);
BOOL Window_IsLFNAware(HWND hwnd);

//  routines that need to be moved to CShellExecute
BOOL DoesAppWantUrl(LPCTSTR lpszFullPathToApp);
HWND _FindPopupFromExe(LPTSTR lpExe);
HINSTANCE Window_GetInstance(HWND hwnd);
BOOL RestrictedApp(LPCTSTR pszApp);
BOOL DisallowedApp(LPCTSTR pszApp);
HRESULT TryShellExecuteHooks(LPSHELLEXECUTEINFO pei);
void RegGetValue(HKEY hkRoot, LPCTSTR lpKey, LPTSTR lpValue);
UINT ReplaceParameters(LPTSTR lpTo, UINT cchTo, LPCTSTR lpFile,
        LPCTSTR lpFrom, LPCTSTR lpParms, int nShow, DWORD * pdwHotKey, BOOL fLFNAware,
        LPCITEMIDLIST lpID, LPITEMIDLIST *ppidlGlobal);


DWORD ShellExecuteNormal(LPSHELLEXECUTEINFO pei);
void _DisplayShellExecError(ULONG fMask, HWND hwnd, LPCTSTR pszFile, LPCTSTR pszTitle, DWORD dwErr);
BOOL InRunDllProcess(void);

#ifdef __cplusplus
}
#endif

#endif // SHLEXEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shitemid.h ===
#ifndef _WINNETWK_
#include <winnetwk.h>
#endif // _WINNETWK_

// NOTE: these values can never change. they define the format of IDLIST that
// may be persisted in .lnk files and elsewhere.

#define SHID_JUNCTION           0x80

#define SHID_GROUPMASK          0x70
#define SHID_TYPEMASK           0x7f
#define SHID_INGROUPMASK        0x0f

#define SHID_ROOT               0x10
#define SHID_ROOT_REGITEM       0x1f    // MyDocuments, Internet, etc

#if ((DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK) != 0x07)
#error Definitions of DRIVE_* are changed!
#endif

#define SHID_COMPUTER           0x20
#define SHID_COMPUTER_1         0x21    // free
#define SHID_COMPUTER_REMOVABLE (0x20 | DRIVE_REMOVABLE)  // 2
#define SHID_COMPUTER_FIXED     (0x20 | DRIVE_FIXED)      // 3
#define SHID_COMPUTER_REMOTE    (0x20 | DRIVE_REMOTE)     // 4
#define SHID_COMPUTER_CDROM     (0x20 | DRIVE_CDROM)      // 5
#define SHID_COMPUTER_RAMDISK   (0x20 | DRIVE_RAMDISK)    // 6
#define SHID_COMPUTER_7         0x27    // free
#define SHID_COMPUTER_DRIVE525  0x28    // 5.25 inch floppy disk drive
#define SHID_COMPUTER_DRIVE35   0x29    // 3.5 inch floppy disk drive
#define SHID_COMPUTER_NETDRIVE  0x2a    // Network drive
#define SHID_COMPUTER_NETUNAVAIL 0x2b   // Network drive that is not restored.
#define SHID_COMPUTER_C         0x2c    // free
#define SHID_COMPUTER_D         0x2d    // free
#define SHID_COMPUTER_REGITEM   0x2e    // Controls, Printers, ...
#define SHID_COMPUTER_MISC      0x2f    // Unknown drive type

#define SHID_FS                   0x30  // base simple IDList, we don't generate these anymore
#define SHID_FS_TYPEMASK          0x37
#define SHID_FS_DIRECTORY         0x31  // WINDOWS (a folder)
#define SHID_FS_FILE              0x32  // FOO.TXT (a file)
#define SHID_FS_UNICODE           0x34  // unicode (this is a bitmask)
#define SHID_FS_DIRUNICODE        0x35  // Folder with a unicode name
#define SHID_FS_FILEUNICODE       0x36  // File with a unicode name
#define SHID_FS_COMMONITEM        0x38  // Common item ("8" is the bit)
#define SHID_FS_COMMONDIRECTORY   0x39  // Common directory (ansi)
#define SHID_FS_COMMONFILE        0x3a  // Common file (ansi)
#define SHID_FS_COMMONDIRUNICODE  0x3d  // Common folder with a unicode name
#define SHID_FS_COMMONFILEUNICODE 0x3e  // Common file with a unicode name


#define SHID_NET                0x40
#define SHID_NET_DOMAIN         (SHID_NET | RESOURCEDISPLAYTYPE_DOMAIN)         // 0x41
#define SHID_NET_SERVER         (SHID_NET | RESOURCEDISPLAYTYPE_SERVER)         // 0x42
#define SHID_NET_SHARE          (SHID_NET | RESOURCEDISPLAYTYPE_SHARE)          // 0x43
#define SHID_NET_FILE           (SHID_NET | RESOURCEDISPLAYTYPE_FILE)           // 0x44
#define SHID_NET_GROUP          (SHID_NET | RESOURCEDISPLAYTYPE_GROUP)          // 0x45
#define SHID_NET_NETWORK        (SHID_NET | RESOURCEDISPLAYTYPE_NETWORK)        // 0x46
#define SHID_NET_RESTOFNET      (SHID_NET | RESOURCEDISPLAYTYPE_ROOT)           // 0x47
#define SHID_NET_SHAREADMIN     (SHID_NET | RESOURCEDISPLAYTYPE_SHAREADMIN)     // 0x48
#define SHID_NET_DIRECTORY      (SHID_NET | RESOURCEDISPLAYTYPE_DIRECTORY)      // 0x49
#define SHID_NET_TREE           (SHID_NET | RESOURCEDISPLAYTYPE_TREE)           // 0x4A
#define SHID_NET_NDSCONTAINER   (SHID_NET | RESOURCEDISPLAYTYPE_NDSCONTAINER)   // 0x4B
#define SHID_NET_REGITEM        0x4d    // RegItem in either Entire Net, or the Root
#define SHID_NET_REMOTEREGITEM  0x4e    // Remote Computer items
#define SHID_NET_PRINTER        0x4f    // \\PYREX\LASER1

#ifndef SHID_LOC
// this group is for location items.
// they are defined in inc\shellp.h
#define SHID_LOC                0x50
#define SHID_LOC_TYPEMASK       0x5F
#endif

#define SHID_CONTROLPANEL_REGITEM       0x70
#define SHID_CONTROLPANEL_REGITEM_EX    0x71

#define SIL_GetType(pidl)       (ILIsEmpty(pidl) ? 0 : (pidl)->mkid.abID[0])
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shlnot.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <trayp.h>

TCHAR const c_szTrayClass[] = TEXT(WNDCLASS_TRAYNOTIFY);

STDAPI_(BOOL) Shell_NotifyIcon(DWORD dwMessage, NOTIFYICONDATA *pnid)
{
    HWND hwndTray;

    SetLastError(0);        // Clean any previous last error (code to help catch another bug)

    hwndTray = FindWindow(c_szTrayClass, NULL);
    if (hwndTray)
    {
        COPYDATASTRUCT cds;
        TRAYNOTIFYDATA tnd = {0};
        DWORD_PTR dwRes = FALSE;
        DWORD dwValidFlags;

        int cbSize = pnid->cbSize;

        if (cbSize == sizeof(*pnid))
        {
            dwValidFlags = NIF_VALID;
        }
        // Win2K checked for size of this struct
        else if (cbSize == NOTIFYICONDATA_V2_SIZE)
        {
            dwValidFlags = NIF_VALID_V2;
        }
        else
        {
            // This will RIP if the app was buggy and passed stack
            // garbage as cbSize.  Apps got away with this on Win95
            // and NT4 because those versions didn't validate cbSize.
            // So if we see a strange cbSize, assume it's the V1 size.
            RIP(cbSize == NOTIFYICONDATA_V1_SIZE);
            cbSize = NOTIFYICONDATA_V1_SIZE;

            dwValidFlags = NIF_VALID_V1;
        }

#ifdef  _WIN64
        // Thunking NOTIFYICONDATA to NOTIFYICONDATA32 is annoying
        // on Win64 due to variations in the size of HWND and HICON
        // We have to copy each field individually.
        tnd.nid.dwWnd            = PtrToUlong(pnid->hWnd);
        tnd.nid.uID              = pnid->uID;
        tnd.nid.uFlags           = pnid->uFlags;
        tnd.nid.uCallbackMessage = pnid->uCallbackMessage;
        tnd.nid.dwIcon           = PtrToUlong(pnid->hIcon);

        // The rest of the fields don't change size between Win32 and
        // Win64, so just block copy them over

        // Toss in an assertion to make sure
        COMPILETIME_ASSERT(
            sizeof(NOTIFYICONDATA  ) - FIELD_OFFSET(NOTIFYICONDATA  , szTip) ==
            sizeof(NOTIFYICONDATA32) - FIELD_OFFSET(NOTIFYICONDATA32, szTip));

        memcpy(&tnd.nid.szTip, &pnid->szTip, cbSize - FIELD_OFFSET(NOTIFYICONDATA, szTip));

#else
        // On Win32, the two structures are the same
        COMPILETIME_ASSERT(sizeof(NOTIFYICONDATA) == sizeof(NOTIFYICONDATA32));
        memcpy(&tnd.nid, pnid, cbSize);
#endif

        tnd.nid.cbSize = sizeof(NOTIFYICONDATA32);

        // This will RIP if the app was really buggy and passed stack
        // garbage as uFlags.
        RIP(!(pnid->uFlags & ~dwValidFlags));
        tnd.nid.uFlags &= dwValidFlags;

        // Toss in an extra NULL to ensure that the tip is NULL terminated...
        if (tnd.nid.uFlags & NIF_TIP)
        {
            tnd.nid.szTip[ARRAYSIZE(tnd.nid.szTip)-1] = TEXT('\0');
        }

        if ( (cbSize == sizeof(*pnid)) || (cbSize == NOTIFYICONDATA_V2_SIZE) )
        {
            if (tnd.nid.uFlags & NIF_INFO)
            {
                tnd.nid.szInfo[ARRAYSIZE(tnd.nid.szInfo)-1] = TEXT('\0');
                tnd.nid.szInfoTitle[ARRAYSIZE(tnd.nid.szInfoTitle)-1] = TEXT('\0');
            }
        }

        if (dwMessage == NIM_SETFOCUS)
        {
            DWORD dwProcId;
            GetWindowThreadProcessId(hwndTray, &dwProcId);
            AllowSetForegroundWindow(dwProcId);
        }
        
        tnd.dwSignature = NI_SIGNATURE;
        tnd.dwMessage = dwMessage;

        cds.dwData = TCDM_NOTIFY;
        cds.cbData = sizeof(tnd);
        cds.lpData = &tnd;

        if (SendMessageTimeout(hwndTray, WM_COPYDATA, (WPARAM)pnid->hWnd, (LPARAM)&cds,
            SMTO_ABORTIFHUNG | SMTO_BLOCK, 4000, &dwRes))
        {
            return (BOOL) dwRes;
        }
    }

    return FALSE;
}

#ifdef UNICODE
STDAPI_(BOOL) Shell_NotifyIconA(DWORD dwMessage, NOTIFYICONDATAA *pnid)
{
    NOTIFYICONDATAW tndw = {0};
    
    tndw.cbSize           = sizeof(tndw);
    tndw.hWnd             = pnid->hWnd;
    tndw.uID              = pnid->uID;
    tndw.uFlags           = pnid->uFlags;
    tndw.uCallbackMessage = pnid->uCallbackMessage;
    tndw.hIcon            = pnid->hIcon;

    if (pnid->cbSize == sizeof(*pnid))
    {
        tndw.dwState        = pnid->dwState;
        tndw.dwStateMask    = pnid->dwStateMask;
        tndw.uTimeout       = pnid->uTimeout;
        tndw.dwInfoFlags    = pnid->dwInfoFlags;
    }
    // Transfer those fields we are aware of as of this writing
    else if (pnid->cbSize == NOTIFYICONDATAA_V2_SIZE) 
    {
        tndw.cbSize         = NOTIFYICONDATAW_V2_SIZE;
        tndw.dwState        = pnid->dwState;
        tndw.dwStateMask    = pnid->dwStateMask;
        tndw.uTimeout       = pnid->uTimeout;
        tndw.dwInfoFlags    = pnid->dwInfoFlags;

        // This will RIP if the app was really buggy and passed stack
        // garbage as uFlags.  We have to clear out bogus flags to
        // avoid accidentally trying to read from invalid data.
        RIP(!(pnid->uFlags & ~NIF_VALID_V2));
        tndw.uFlags &= NIF_VALID_V2;
    }
    else 
    {
        // This will RIP if the app was buggy and passed stack
        // garbage as cbSize.  Apps got away with this on Win95
        // and NT4 because those versions didn't validate cbSize.
        // So if we see a strange cbSize, assume it's the V1 size.
        RIP(pnid->cbSize == (DWORD)NOTIFYICONDATAA_V1_SIZE);
        tndw.cbSize = NOTIFYICONDATAW_V1_SIZE;

        // This will RIP if the app was really buggy and passed stack
        // garbage as uFlags.  We have to clear out bogus flags to
        // avoid accidentally trying to read from invalid data.
        RIP(!(pnid->uFlags & ~NIF_VALID_V1));
        tndw.uFlags &= NIF_VALID_V1;
    }

    if (tndw.uFlags & NIF_TIP)
        SHAnsiToUnicode(pnid->szTip, tndw.szTip, ARRAYSIZE(tndw.szTip));

    if (tndw.uFlags & NIF_INFO)
    {
        SHAnsiToUnicode(pnid->szInfo, tndw.szInfo, ARRAYSIZE(tndw.szInfo));
        SHAnsiToUnicode(pnid->szInfoTitle, tndw.szInfoTitle, ARRAYSIZE(tndw.szInfoTitle));
    }

    if (tndw.uFlags & NIF_GUID)
    {
        memcpy(&(tndw.guidItem), &(pnid->guidItem), sizeof(pnid->guidItem));
    }

    return Shell_NotifyIconW(dwMessage, &tndw);
}
#else
STDAPI_(BOOL) Shell_NotifyIconW(DWORD dwMessage, NOTIFYICONDATAW *pnid)
{
    return FALSE;
}
#endif

//***   CopyIn -- copy app data in to shared region (and create shared)
// ENTRY/EXIT
//  return      handle on success, NULL on failure
//  pvData      app buffer
//  cbData      count
//  dwProcId    ...
// NOTES
//  should make it handle pvData=NULL for cases where param is OUT not INOUT.
//
HANDLE CopyIn(void *pvData, int cbData, DWORD dwProcId)
{
    HANDLE hShared = SHAllocShared(NULL, cbData, dwProcId);
    if (hShared) 
    {
        void *pvShared = SHLockShared(hShared, dwProcId);
        if (pvShared == NULL) 
        {
            SHFreeShared(hShared, dwProcId);
            hShared = NULL;
        }
        else 
        {
            memcpy(pvShared, pvData, cbData);
            SHUnlockShared(pvShared);
        }
    }
    return hShared;
}

// copy out to app data from shared region (and free shared)
// ENTRY/EXIT
//  return      TRUE on success, FALSE on failure.
//  hShared     shared data, freed when done
//  pvData      app buffer
//  cbData      count
BOOL CopyOut(HANDLE hShared, void *pvData, int cbData, DWORD dwProcId)
{
    void *pvShared = SHLockShared(hShared, dwProcId);
    if (pvShared)
    {
        memcpy(pvData, pvShared, cbData);
        SHUnlockShared(pvShared);
    }
    SHFreeShared(hShared, dwProcId);
    return (pvShared != 0);
}

STDAPI_(UINT_PTR) SHAppBarMessage(DWORD dwMessage, APPBARDATA *pabd)
{
    TRAYAPPBARDATA tabd;
    UINT_PTR fret = FALSE;
    HWND hwndTray = FindWindow(c_szTrayClass, NULL);
    if (hwndTray && (pabd->cbSize <= sizeof(*pabd)))
    {
        COPYDATASTRUCT cds;

        RIP(pabd->cbSize == sizeof(*pabd));

#ifdef _WIN64
        tabd.abd.dwWnd = PtrToUlong(pabd->hWnd);
        tabd.abd.uCallbackMessage = pabd->uCallbackMessage;
        tabd.abd.uEdge = pabd->uEdge;
        tabd.abd.rc = pabd->rc;
#else
        // Sadly, the Win32 compiler doesn't realize that the code
        // sequence above can be optimized into a single memcpy, so
        // we need to spoon-feed it...
        memcpy(&tabd.abd.dwWnd, &pabd->hWnd,
               FIELD_OFFSET(APPBARDATA, lParam) - FIELD_OFFSET(APPBARDATA, hWnd));
#endif
        tabd.abd.cbSize = sizeof(tabd.abd);
        tabd.abd.lParam = pabd->lParam;

        tabd.dwMessage = dwMessage;
        tabd.hSharedABD = PtrToUlong(NULL);
        tabd.dwProcId = GetCurrentProcessId();

        cds.dwData = TCDM_APPBAR;
        cds.cbData = sizeof(tabd);
        cds.lpData = &tabd;

        //
        //  These are the messages that return data back to the caller.
        //
        switch (dwMessage)
        {
        case ABM_QUERYPOS:
        case ABM_SETPOS:
        case ABM_GETTASKBARPOS:
            tabd.hSharedABD = PtrToUlong(CopyIn(&tabd.abd, sizeof(tabd.abd), tabd.dwProcId));
            if (tabd.hSharedABD == PtrToUlong(NULL))
                return FALSE;

            break;
        }

        fret = SendMessage(hwndTray, WM_COPYDATA, (WPARAM)pabd->hWnd, (LPARAM)&cds);
        if (tabd.hSharedABD) 
        {
            if (CopyOut(UlongToPtr(tabd.hSharedABD), &tabd.abd, sizeof(tabd.abd), tabd.dwProcId))
            {
#ifdef _WIN64
                pabd->hWnd = (HWND)UIntToPtr(tabd.abd.dwWnd);
                pabd->uCallbackMessage = tabd.abd.uCallbackMessage;
                pabd->uEdge = tabd.abd.uEdge;
                pabd->rc = tabd.abd.rc;
#else
                // Sadly, the Win32 compiler doesn't realize that the code
                // sequence above can be optimized into a single memcpy, so
                // we need to spoon-feed it...
                memcpy(&pabd->hWnd, &tabd.abd.dwWnd,
                       FIELD_OFFSET(APPBARDATA, lParam) - FIELD_OFFSET(APPBARDATA, hWnd));
#endif
                pabd->lParam = (LPARAM)tabd.abd.lParam;
            }
            else
                fret = FALSE;
        }
    }
    return fret;
}

HRESULT _TrayLoadInProc(REFCLSID rclsid, DWORD dwFlags)
{
    HWND hwndTray = FindWindow(c_szTrayClass, NULL);
    if (hwndTray)
    {
        COPYDATASTRUCT cds;
        LOADINPROCDATA lipd;
        lipd.clsid = rclsid;
        lipd.dwFlags = dwFlags;

        cds.dwData = TCDM_LOADINPROC;
        cds.cbData = sizeof(lipd);
        cds.lpData = &lipd;

        return (HRESULT)SendMessage(hwndTray, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&cds);
    }
    else
    {
        return E_FAIL;
    }
}

STDAPI SHLoadInProc(REFCLSID rclsid)
{
    return _TrayLoadInProc(rclsid, LIPF_ENABLE);
}

STDAPI SHEnableServiceObject(REFCLSID rclsid, BOOL fEnable)
{
    DWORD dwFlags = fEnable ? LIPF_ENABLE | LIPF_HOLDREF : LIPF_HOLDREF;

    return _TrayLoadInProc(rclsid, dwFlags);
}

// used to implement a per process reference count for the main thread
// the browser msg loop and the proxy desktop use this to let other threads
// extend their lifetime. 
// there is a thread level equivelent of this, shlwapi SHGetThreadRef()/SHSetThreadRef()

IUnknown *g_punkProcessRef = NULL;

STDAPI_(void) SHSetInstanceExplorer(IUnknown *punk)
{
    g_punkProcessRef = punk;
}

// This should be thread safe since we grab the punk locally before
// checking/using it, plus it never gets freed since it is not actually
// alloced in Explorer so we can always use it

STDAPI SHGetInstanceExplorer(IUnknown **ppunk)
{
    *ppunk = g_punkProcessRef;
    if (*ppunk)
    {
        (*ppunk)->AddRef();
        return NOERROR;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shprsht.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "datautil.h"

//
//  This function is a callback function from property sheet page extensions.
//
BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_FILE_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }

    return FALSE;
}

//
//  This function enumerates all the property sheet page extensions for
// specified class and let them add pages.
//
//
int DCA_AppendClassSheetInfo(HDCA hdca, HKEY hkeyProgID, LPPROPSHEETHEADER ppsh, IDataObject *pdtobj)
{
    int i, iStart = -1;
    for (i = 0; i < DCA_GetItemCount(hdca); i++)
    {
        IShellExtInit *psei;
        // These came from HKCR hence need to go through administrator approval
        if (DCA_ExtCreateInstance(hdca, i, &IID_IShellExtInit, &psei) == NOERROR)
        {
            IShellPropSheetExt *pspse;
            if (SUCCEEDED(psei->lpVtbl->Initialize(psei, NULL, pdtobj, hkeyProgID))
              && SUCCEEDED(psei->lpVtbl->QueryInterface(psei, &IID_IShellPropSheetExt, &pspse)))
            {
                int nPagesSave = ppsh->nPages;
                HRESULT hres = pspse->lpVtbl->AddPages(pspse, _AddPropSheetPage, (LPARAM)ppsh);
                if (SUCCEEDED(hres) && hres != S_OK)
                {
                    // Some shell extensions get confused and return S_FALSE when
                    // they didn't add anything, unaware that S_FALSE means "Please
                    // take the page I added and make it the default".  So ignore
                    // the return value if it is out of range.
                    DWORD nPagesAdded = ppsh->nPages - nPagesSave;
                    DWORD nPageWanted = hres - 1;
                    if (nPageWanted < nPagesAdded)
                        iStart = nPagesSave + nPageWanted;
                }
                pspse->lpVtbl->Release(pspse);
            }
            psei->lpVtbl->Release(psei);
        }
    }
    return iStart;
}

HWND FindStubForPidlClass(LPCITEMIDLIST pidl, int iClass)
{
    HWND hwnd;

    if (!pidl)
        return NULL;

    for (hwnd = FindWindow(c_szStubWindowClass, NULL); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        TCHAR szClass[80];

        // find stub windows only
        GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
        if (lstrcmpi(szClass, c_szStubWindowClass) == 0)
        {
            HANDLE hClassPidl;
            DWORD dwProcId;
            DWORD_PTR dwResult;

            GetWindowThreadProcessId(hwnd, &dwProcId);

            // since a propsheet could be doing work & not pumping messages, use a timeout
            // we can almost just do this: hClassPidl = GetWindowLongPtr(hwnd, 0)
            if (!SendMessageTimeout(hwnd, STUBM_GETDATA, 0, 0, SMTO_BLOCK, 3000, &dwResult))
                continue;
            hClassPidl = (HANDLE)dwResult;
            if (hClassPidl)
            {
                LPBYTE lpb = (LPBYTE)SHLockShared(hClassPidl, dwProcId);
                if (lpb)
                {
                    int iClassFound = *(int *)lpb;

                    if (iClassFound == iClass &&
                        ILIsEqual(pidl, (LPITEMIDLIST)(lpb + sizeof(int))) )
                    {
                        SHUnlockShared(lpb);
                        return hwnd;
                    }
                    SHUnlockShared(lpb);
                }
            }
        }
    }
    return NULL;
}

HANDLE _StuffStubWindow(HWND hwnd, LPITEMIDLIST pidlT, int iClass)
{
    DWORD dwProcId;
    HANDLE  hSharedClassPidl;
    UINT uidlSize;

    uidlSize = ILGetSize(pidlT);
    GetWindowThreadProcessId(hwnd, &dwProcId);

    hSharedClassPidl = SHAllocShared(NULL, sizeof(int) + uidlSize, dwProcId);
    if (hSharedClassPidl)
    {
        LPBYTE lpb = SHLockShared(hSharedClassPidl, dwProcId);
        if (lpb)
        {
            *((int *)lpb) = iClass;
            memcpy(lpb + sizeof(int), pidlT, uidlSize);
            SHUnlockShared(lpb);
            SendMessage(hwnd, STUBM_SETDATA, (WPARAM)hSharedClassPidl, 0);
            return hSharedClassPidl;
        }
        SHFreeShared(hSharedClassPidl, dwProcId);
    }

    return NULL;
}

//
//  Make sure we are the only stub window for this pidl/class.
//
//  If so, saves information in the UNIQUESTUBINFO structure which keeps
//  track of the uniqueness key.  After you are done, you must pass the
//  UNIQUESTUBINFO structure to FreeUniqueStub() to clean up the uniqueness
//  key and destroy the stub window.  Returns TRUE.
//
//  If a stub window already exists for this pidl/class, then sets focus
//  to the existing window that matches our uniqueness key and returns FALSE.
//
//  In low memory conditions, plays it safe and declares the pidl/class
//  unique.
//
//
//  Example:
//
//      UNIQUESTUBINFO usi;
//      if (EnsureUniqueStub(pidl, STUBCLASS_PROPSHEET, NULL, &usi)) {
//          DoStuff(usi.hwndStub, pidl);
//          FreeUniqueStub(&usi);
//      }
//

STDAPI_(BOOL)
EnsureUniqueStub(LPITEMIDLIST pidl, int iClass, POINT* ppt, UNIQUESTUBINFO* pusi)
{
    HWND hwndOther;

    ZeroMemory(pusi, sizeof(UNIQUESTUBINFO));

    hwndOther = FindStubForPidlClass(pidl, iClass);
    if (hwndOther)
    {
        SwitchToThisWindow(GetLastActivePopup(hwndOther), TRUE);
        return FALSE;
    }
    else
    {   // Tag ourselves as the unique stub for this pidl/class
        pusi->hwndStub = _CreateStubWindow(ppt, NULL);

        // If no pidl, then nothing to tag *with*
        // If no stub window, then nothing to attach the tag *to*
        // But they are both still considered success.

        if (pusi->hwndStub && pidl)
        {
            SHFILEINFO sfi;

            pusi->hClassPidl = _StuffStubWindow(pusi->hwndStub, pidl, iClass);

            if (SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_PIDL)) {
                pusi->hicoStub = sfi.hIcon;

                // Cannot stuff the title because the window might belong to another process
                SendMessage(pusi->hwndStub, STUBM_SETICONTITLE, (WPARAM)pusi->hicoStub, 0);

            }
        }
        return TRUE;
    }
}

STDAPI_(void) FreeUniqueStub(UNIQUESTUBINFO *pusi)
{
    if (pusi->hwndStub)
        DestroyWindow(pusi->hwndStub);
    if (pusi->hClassPidl)
        SHFreeShared(pusi->hClassPidl, GetCurrentProcessId());
    if (pusi->hicoStub)
        DestroyIcon(pusi->hicoStub);
}

BOOL _IsAnyDuplicatedKey(HKEY ahkeys[], UINT ckeys, HKEY hkey)
{
    UINT ikey;
    for (ikey=0; ikey<ckeys; ikey++)
    {
        if (ahkeys[ikey]==hkey) {
            return TRUE;
        }
    }
    return FALSE;
}

STDAPI_(BOOL) SHOpenPropSheet(
    LPCTSTR pszCaption,
    HKEY ahkeys[],
    UINT ckeys,
    const CLSID * pclsidDef,    OPTIONAL
    IDataObject *pdtobj,
    IShellBrowser * psb,
    LPCTSTR pStartPage)         OPTIONAL
{
    BOOL fSuccess = FALSE;
    BOOL fUnique;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE ahpage[MAX_FILE_PROP_PAGES];
    HWND hwndStub = NULL;
    STGMEDIUM medium;
    HDCA hdca = NULL;
    HICON hicoStuff = NULL;
    UNIQUESTUBINFO usi;

    ASSERT(IS_VALID_STRING_PTR(pszCaption, -1));
    ASSERT(NULL == pclsidDef || IS_VALID_READ_PTR(pclsidDef, CLSID));
    ASSERT(IS_VALID_CODE_PTR(pdtobj, DATAOBJECT));
    ASSERT(NULL == psb || IS_VALID_CODE_PTR(psb, IShellBrowser));
    ASSERT(NULL == pStartPage || IS_VALID_STRING_PTR(pStartPage, -1));

    // Create the stub window
    {
        POINT pt;
        POINT * ppt = NULL;
        LPITEMIDLIST pidl = NULL;

        if (SUCCEEDED(DataObj_GetOFFSETs(pdtobj, &pt)))
            ppt = &pt;

        if (DataObj_GetHIDA(pdtobj, &medium))
        {
            HIDA hida = medium.hGlobal;
            if (hida && (HIDA_GetCount(hida) == 1))
            {
                pidl = HIDA_ILClone(hida, 0);
            }
            HIDA_ReleaseStgMedium(NULL, &medium);
        }


        fUnique = EnsureUniqueStub(pidl, STUBCLASS_PROPSHEET, ppt, &usi);
        ILFree(pidl);
    }

    // If there's already a property sheet up for this guy, then our job is done
    if (!fUnique) {
        return TRUE;
    }

    psh.hwndParent = usi.hwndStub;
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hInstance = HINST_THISDLL;
    psh.pszCaption = pszCaption;
    psh.nPages = 0;     // incremented in callback
    psh.nStartPage = 0;   // set below if specified
    psh.phpage = ahpage;
    if (pStartPage)
    {
        psh.dwFlags |= PSH_USEPSTARTPAGE;
        psh.pStartPage = pStartPage;
    }

    hdca = DCA_Create();
    if (hdca)
    {
        UINT ikey;
        int nStartPage;
        //
        // Always add this default extention at the top, if any.
        //
        if (pclsidDef)
        {
            DCA_AddItem(hdca, pclsidDef);
        }

        for (ikey = 0; ikey < ckeys; ikey++)
        {
            if (ahkeys[ikey] && !_IsAnyDuplicatedKey(ahkeys, ikey, ahkeys[ikey]))
            {
                DCA_AddItemsFromKey(hdca, ahkeys[ikey], STRREG_SHEX_PROPSHEET);
            }
        }

        // Notes: ahkeys[ckeys-1] as hkeyProgID
        nStartPage = DCA_AppendClassSheetInfo(hdca, ckeys > 0 ? ahkeys[ckeys-1] : NULL, &psh, pdtobj);

        // If a shell extension requested to be the default and the caller didn't
        // specify a preferred initial page, then let the shell extension win.
        if (!pStartPage && nStartPage >= 0)
            psh.nStartPage = nStartPage;
        DCA_Destroy(hdca);
    }

    // Open the property sheet, only if we have some pages.
    if (psh.nPages > 0)
    {
        _try
        {
            if (PropertySheet(&psh) >= 0)   // IDOK or IDCANCEL (< 0 is error)
                fSuccess = TRUE;
        }
        _except(UnhandledExceptionFilter(GetExceptionInformation()))
        {
            DebugMsg(DM_ERROR, TEXT("PRSHT: Fault in property sheet"));
        }
    }
    else
    {
        ShellMessageBox(HINST_THISDLL, NULL,
                        MAKEINTRESOURCE(IDS_NOPAGE),
                        MAKEINTRESOURCE(IDS_DESKTOP),
                        MB_OK|MB_ICONHAND);
    }

    // clean up the stub window and data
    FreeUniqueStub(&usi);

    return fSuccess;
}


#ifdef UNICODE

STDAPI_(BOOL) SHOpenPropSheetA(
    LPCSTR pszCaption,
    HKEY ahkeys[],
    UINT ckeys,
    const CLSID * pclsidDef,
    IDataObject *pdtobj,
    IShellBrowser * psb,
    LPCSTR pszStartPage)       OPTIONAL
{
    BOOL bRet = FALSE;

    if (IS_VALID_STRING_PTRA(pszCaption, MAX_PATH))
    {
        WCHAR wszCaption[MAX_PATH];
        WCHAR wszStartPage[MAX_PATH];

        SHAnsiToUnicode(pszCaption, wszCaption, SIZECHARS(wszCaption));

        if (pszStartPage)
        {
            ASSERT(IS_VALID_STRING_PTRA(pszStartPage, MAX_PATH));

            SHAnsiToUnicode(pszStartPage, wszStartPage, SIZECHARS(wszStartPage));
            pszStartPage = (LPCSTR)wszStartPage;
        }

        bRet = SHOpenPropSheet(wszCaption, ahkeys, ckeys, pclsidDef, pdtobj, psb, (LPCWSTR)pszStartPage);
    }

    return bRet;
}

#else

STDAPI_(BOOL) SHOpenPropSheetW(
    LPCWSTR pszCaption,
    HKEY ahkeys[],
    UINT ckeys,
    const CLSID * pclsidDef,
    IDataObject *pdtobj,
    IShellBrowser * psb,
    LPCWSTR pszStartPage)       OPTIONAL
{
    BOOL bRet = FALSE;

    if (IS_VALID_STRING_PTRW(pszCaption, MAX_PATH))
    {
        char szCaption[MAX_PATH];
        char szStartPage[MAX_PATH];

        SHUnicodeToAnsi(pszCaption, szCaption, SIZECHARS(szCaption));

        if (pszStartPage)
        {
            ASSERT(IS_VALID_STRING_PTRW(pszStartPage, MAX_PATH));

            SHUnicodeToAnsi(pszStartPage, szStartPage, SIZECHARS(szStartPage));
            pszStartPage = (LPCWSTR)szStartPage;
        }

        bRet = SHOpenPropSheet(szCaption, ahkeys, ckeys, pclsidDef, pdtobj, psb, (LPCSTR)pszStartPage);
    }

    return bRet;
}

#endif // UNICODE

//
//  Async version of SHFormatDrive - creates a separate thread to do the
//  format and returns immediately.
//

typedef struct {
    HWND hwnd;
    UINT drive;
    UINT fmtID;
    UINT options;
} FORMATTHREADINFO;

STDAPI_(DWORD) _FormatThreadProc(LPVOID lpParam)
{
    FORMATTHREADINFO* pfi = (FORMATTHREADINFO*)lpParam;
    LPITEMIDLIST pidl;
    TCHAR szDrive[4];

    if (SUCCEEDED(StringCchCopy(szDrive, ARRAYSIZE(szDrive), TEXT("A:\\"))))
    {
        ASSERT(pfi->drive < 26);
        szDrive[0] += (TCHAR)pfi->drive;

        pidl = ILCreateFromPath(szDrive);
        if (pidl)
        {
            UNIQUESTUBINFO usi;
            LPPOINT ppt = NULL;
            RECT rcWindow;
            if (pfi->hwnd)
            {
                GetWindowRect(pfi->hwnd, &rcWindow);
                ppt = (LPPOINT)&rcWindow;
            }

            if (EnsureUniqueStub(pidl, STUBCLASS_FORMAT, ppt, &usi))
            {
                SHFormatDrive(usi.hwndStub, pfi->drive, pfi->fmtID, pfi->options);
                FreeUniqueStub(&usi);
            }

            ILFree(pidl);
        }
    }

    LocalFree(pfi);

    return 0;
}

STDAPI_(void) SHFormatDriveAsync(
    HWND hwnd,
    UINT drive,
    UINT fmtID,
    UINT options
)
{
    FORMATTHREADINFO* pfi = (FORMATTHREADINFO*)LocalAlloc(LPTR, sizeof(FORMATTHREADINFO));
    if (pfi)
    {
        pfi->hwnd = hwnd;
        pfi->drive = drive;
        pfi->fmtID = fmtID;
        pfi->options = options;
        SHCreateThread(_FormatThreadProc, pfi, CTF_INSIST | CTF_PROCESS_REF, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shlobjs.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <dpa.h>
#include "ids.h"
#include "idlcomm.h"
#include "recdocs.h"
#include "datautil.h"
#include "mtpt.h"
#include <cowsite.h>

typedef struct _DKAITEM {       // dkai
    HKEY hk;
    TCHAR    sz[CCH_KEYMAX];
} DKAITEM, *PDKAITEM;
typedef const DKAITEM * PCDKAITEM;

class CDKA : public CDSA<DKAITEM>
{
public:
    ~CDKA();
    UINT AddKeys(HKEY hk, LPCTSTR pszSubKey, PCTSTR pszDefaultOrder);

    PCTSTR ExposeName(int id)
        {   return GetItemPtr(id)->sz; }
        
    HKEY ExposeKey(int id)
        {   return GetItemPtr(id)->hk; }
        
    HRESULT GetValue(int id, 
        PCTSTR pszSubKey, 
        PCTSTR pszValue, 
        DWORD *pdwType, 
        void *pvData, 
        DWORD *pcbData);

    BOOL DeleteItem(int id);
    BOOL DeleteAllItems();
    void Reset()
        { if ((HDSA)this) DestroyCallback(_ReleaseItem, NULL); }
    BOOL HasDefault(HKEY hkProgid);

protected:
    BOOL _AppendItem(HKEY hk, PDKAITEM pdkai);
    void _AddOrderedKeys(HKEY hk, PCTSTR pszDefOrder);
    void _AddEnumKeys(HKEY hk);
    static int CALLBACK _ReleaseItem(PDKAITEM pdkai, void *pv);

protected:
    TRIBIT _tbHasDefault;
};

BOOL CDKA::_AppendItem(HKEY hk, PDKAITEM pdkai)
{
    BOOL fRet = FALSE;
    // Verify that the key exists before adding it to the list
    if (RegOpenKeyEx(hk, pdkai->sz, 0L, KEY_READ, &pdkai->hk) == ERROR_SUCCESS)
    {
        fRet = (AppendItem(pdkai) >= 0);

        if (!fRet)
            RegCloseKey(pdkai->hk);
    }
    return fRet;
}

void CDKA::_AddOrderedKeys(HKEY hk, PCTSTR pszDefOrder)
{
    // First, add the subkeys from the value of the specified key
    // This should never fail, since we just opened this key
    DKAITEM dkai;
    TCHAR szOrder[CCH_KEYMAX * 5];
    LONG cbOrder = CbFromCch(ARRAYSIZE(szOrder));
    *szOrder = 0;
    RegQueryValue(hk, NULL, szOrder, &cbOrder);
    if (*szOrder)
    {
        //  now we must find something in this string in order to have a default
        _tbHasDefault = TRIBIT_FALSE;
    }
    else if (pszDefOrder)
    {
        // If there is no value, use the order requested
        //  typically "Open" or "Explore Open" in explorer mode
        StrCpyN(szOrder, pszDefOrder, ARRAYSIZE(szOrder));
    }

    PTSTR psz = szOrder;
    while (psz && *psz)
    {
        // skip the space or comma characters
        while(*psz==TEXT(' ') || *psz==TEXT(','))
            psz++;          // NLS Notes: OK to ++

        if (*psz)
        {
            // Search for the space or comma character
            LPTSTR pszNext = psz + StrCSpn(psz, TEXT(" ,"));
            if (*pszNext) {
                *pszNext++=0;    // NLS Notes: OK to ++
            }
            StrCpyN(dkai.sz, psz, ARRAYSIZE(dkai.sz));

            if (_AppendItem(hk, &dkai))
                _tbHasDefault = TRIBIT_TRUE;

            psz = pszNext;
        }
    } 
}

void CDKA::_AddEnumKeys(HKEY hk)
{
    DKAITEM dkai;
    // Then, append the rest if they are not in the list yet.
    for (int i = 0; RegEnumKey(hk, i, dkai.sz, ARRAYSIZE(dkai.sz)) == ERROR_SUCCESS; i++)
    {
        // Check if the key is already in the list.
        for (int idsa = 0; idsa < GetItemCount(); idsa++)
        {
            PDKAITEM pdkai = GetItemPtr(idsa);
            if (lstrcmpi(dkai.sz, pdkai->sz)==0)
                break;
        }

        //  we made it throug our array
        //  so this isnt in there
        if (idsa == GetItemCount())
            _AppendItem(hk, &dkai);
    }
}

UINT CDKA::AddKeys(HKEY hkRoot, LPCTSTR pszSubKey, PCTSTR pszDefaultOrder)
{
    UINT cKeys = GetItemCount();
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(hkRoot, pszSubKey, 0L, KEY_READ, &hk))
    {
        _AddOrderedKeys(hk, pszDefaultOrder);
        _AddEnumKeys(hk);
        RegCloseKey(hk);
    }
    return GetItemCount() - cKeys;
}

int CALLBACK CDKA::_ReleaseItem(PDKAITEM pdkai, void *pv)
{
    if (pdkai->hk)
    {
        RegCloseKey(pdkai->hk);
        pdkai->hk = NULL;        
    }
    return 1;
}

CDKA::~CDKA()
{
    Reset();
}

//  override this DSA methods to get release
BOOL CDKA::DeleteItem(int id)
{
    PDKAITEM p = GetItemPtr(id);
    if (p)
    {
        _ReleaseItem(p, NULL);
        return CDSA<DKAITEM>::DeleteItem(id);
    }
    return FALSE;
}

//  override this DSA methods to get release
BOOL CDKA::DeleteAllItems()
{
    EnumCallback(_ReleaseItem, NULL);
    return CDSA<DKAITEM>::DeleteAllItems();
}

HRESULT CDKA::GetValue(int id, 
    PCTSTR pszSubKey, 
    PCTSTR pszValue, 
    DWORD *pdwType, 
    void *pvData, 
    DWORD *pcbData)
{
    DWORD err = SHGetValue(GetItemPtr(id)->hk, pszSubKey, pszValue, pdwType, pvData, pcbData);
    return HRESULT_FROM_WIN32(err);
}

BOOL CDKA::HasDefault(HKEY hkProgid)
{
    if (_tbHasDefault == TRIBIT_UNDEFINED)
    {
        HKEY hk;
        if (ERROR_SUCCESS== RegOpenKeyEx(hkProgid, L"ShellFolder", 0, MAXIMUM_ALLOWED, &hk))
        {
            //  APPCOMPAT - regitems need to have the open verb - ZekeL - 30-JAN-2001
            //  so that the IQA and ICM will behave the same,
            //  and regitem folders will always default to 
            //  folder\shell\open unless they implement open 
            //  or specify default verbs.
            //
            _tbHasDefault = TRIBIT_FALSE;
            RegCloseKey(hk);
        }
        else
        {
            _tbHasDefault = TRIBIT_TRUE;
        }
    }
    return _tbHasDefault == TRIBIT_TRUE;
}

            
typedef HRESULT (__stdcall *LPFNADDPAGES)(IDataObject *, LPFNADDPROPSHEETPAGE, LPARAM);

class CShellExecMenu : public IShellExtInit, public IContextMenu, public IShellPropSheetExt, CObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);        
    STDMETHODIMP_(ULONG) Release(void);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pwRes, LPSTR pszName, UINT cchMax);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    CShellExecMenu(LPFNADDPAGES pfnAddPages);

protected:  // methods
    ~CShellExecMenu();
    void _Cleanup();
    HRESULT _InsureVerbs(UINT idVerb = 0);
    UINT _VerbCount();
    LPCTSTR _GetVerb(UINT id);
    UINT _FindIndex(LPCTSTR pszVerb);
    DWORD _BrowseFlagsFromVerb(UINT idVerb);
    BOOL _GetMenuString(UINT id, BOOL fExtended, LPTSTR pszMenu, UINT cchMax);
    BOOL _IsExplorerMode();
    BOOL _SupportsType(UINT idVerb);
    BOOL _IsRestricted(UINT idVerb);
    BOOL _IsVisible(BOOL fExtended, UINT idVerb);
    BOOL _RemoveVerb(UINT idVerb);
    BOOL _VerbCanDrop(UINT idVerb, CLSID *pclsid);
    HRESULT _DoDrop(REFCLSID clsid, UINT idVerb, LPCMINVOKECOMMANDINFOEX pici);

    HRESULT _MapVerbForInvoke(CMINVOKECOMMANDINFOEX *pici, UINT *pidVerb);
    HRESULT _TryBrowseObject(LPCITEMIDLIST pidl, DWORD uFlags);
    void _DoRecentStuff(LPCITEMIDLIST pidl, LPCTSTR pszPath);
    HRESULT _InvokeOne(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPCITEMIDLIST pidl);
    HRESULT _InvokeMany(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida);
    HRESULT _InvokeEach(LPCITEMIDLIST pidl, CMINVOKECOMMANDINFOEX *pici);
    HRESULT _PromptUser(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida);

    HRESULT _MapVerbForGCS(UINT_PTR idCmd, UINT uType, UINT *pidVerb);
    HRESULT _GetHelpText(UINT idVerb, UINT uType, LPSTR pszName, UINT cchMax);

private:  // members
    LONG _cRef;
    IDataObject *_pdtobj;
    HKEY _hkeyProgID;
    CDKA _dka;
    LPFNADDPAGES _pfnAddPages;
    UINT _uFlags;
};

CShellExecMenu::CShellExecMenu(LPFNADDPAGES pfnAddPages) : _pfnAddPages(pfnAddPages), _cRef(1)
{
}

CShellExecMenu::~CShellExecMenu()
{
    _Cleanup();
}

void CShellExecMenu::_Cleanup()
{
    _dka.Reset();
    
    if (_hkeyProgID) 
    {
        RegCloseKey(_hkeyProgID);
        _hkeyProgID = NULL;
    }

    ATOMICRELEASE(_pdtobj);
}

STDMETHODIMP CShellExecMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellExecMenu, IShellExtInit),
        QITABENT(CShellExecMenu, IContextMenu),
        QITABENT(CShellExecMenu, IShellPropSheetExt),
        QITABENT(CShellExecMenu, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShellExecMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellExecMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CShellExecMenu::_InsureVerbs(UINT idVerb)
{
    //  the idVerb is the minimum verb that we need to succeed
    if (!(HDSA)_dka && _hkeyProgID)
    {
        // create either "open" or "explore open"
        if (_dka.Create(4))
        {
            _dka.AddKeys(_hkeyProgID, c_szShell, _IsExplorerMode() ? TEXT("Explore open") : TEXT("open"));

            //  WARNING - some verbs are not valid and need to be removed
            for (int id = 0; id < _dka.GetItemCount(); id++)
            {
                if (_RemoveVerb(id))
                    _dka.DeleteItem(id);
            }
        }

    }
    
    return ((HDSA)_dka && idVerb < (UINT)_dka.GetItemCount()) ? S_OK : E_FAIL;
}

// Descriptions:
//   This function generates appropriate menu string from the given
//  verb key string. This function is called if the verb key does
//  not have the value.

BOOL _MenuString(LPCTSTR pszVerbKey, LPTSTR pszMenuString, UINT cchMax)
{
    // Table look-up (verb key -> menu string mapping)
    const static struct 
    {
        LPCTSTR pszVerb;
        UINT  id;
    } sVerbTrans[] = {
        c_szOpen,    IDS_MENUOPEN,
        c_szExplore, IDS_MENUEXPLORE,
        TEXT("edit"),IDS_MENUEDIT,
        c_szFind,    IDS_MENUFIND,
        c_szPrint,   IDS_MENUPRINT,
        c_szOpenAs,  IDS_MENUOPEN,
        TEXT("runas"),IDS_MENURUNAS
    };

    for (int i = 0; i < ARRAYSIZE(sVerbTrans); i++)
    {
        if (lstrcmpi(pszVerbKey, sVerbTrans[i].pszVerb) == 0)
        {
            if (LoadString(HINST_THISDLL, sVerbTrans[i].id, pszMenuString, cchMax))
                return TRUE;
            break;
        }
    }

    // Worst case: Just put '&' on the top.
    pszMenuString[0] = TEXT('&');
    pszMenuString++;
    cchMax--;
    lstrcpyn(pszMenuString, pszVerbKey, cchMax);

    return TRUE;
}

// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)

BOOL CShellExecMenu::_IsRestricted(UINT idVerb)
{
    RESTRICTIONS rest;
    BOOL fRestrict = FALSE;
    if (0 == lstrcmpi(TEXT("runas"), _dka.ExposeName(idVerb)))
    {
        rest = REST_HIDERUNASVERB;
        fRestrict = TRUE;
    }
    else
    {
        DWORD cb = sizeof(rest);
        fRestrict = SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("SuppressionPolicy"), NULL, &rest, &cb));
    }
    return fRestrict && SHRestricted(rest);
}

HRESULT _GetAppSource(HKEY hk, PCWSTR pszVerb, IQuerySource **ppqs)
{
    CComPtr<IAssociationElement> spae;
    HRESULT hr = AssocElemCreateForKey(&CLSID_AssocShellElement, hk, &spae);
    if (SUCCEEDED(hr))
    {
        CComPtr<IObjectWithQuerySource> spowqsApp;
        hr = spae->QueryObject(AQVO_APPLICATION_DELEGATE, pszVerb, IID_PPV_ARG(IObjectWithQuerySource, &spowqsApp));
        if (SUCCEEDED(hr))
        {
            hr = spowqsApp->GetSource(IID_PPV_ARG(IQuerySource, ppqs));
        }
    }
    return hr;
}

BOOL CShellExecMenu::_SupportsType(UINT idVerb)
{
    BOOL fRet = TRUE;
    if (SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("CheckSupportedTypes"), NULL, NULL, NULL)))
    {
        //  need to check the supported types for this application
        // get the first item and then check it against SupportedFileExtensions
        CComPtr<IShellItem> spsi;
        if (SUCCEEDED(DataObj_GetIShellItem(_pdtobj, &spsi)))
        {
            SFGAOF sfgao;
            if (S_OK == spsi->GetAttributes(SFGAO_STREAM, &sfgao))
            {
                CSmartCoTaskMem<OLECHAR> spszName;
                if (SUCCEEDED(spsi->GetDisplayName(SIGDN_PARENTRELATIVEPARSING, &spszName)))
                {
                    PWSTR pszExt = PathFindExtension(spszName);
                    if (*pszExt)
                    {
                        CComPtr<IQuerySource> spqs;
                        if (SUCCEEDED(_GetAppSource(_hkeyProgID, _dka.ExposeName(idVerb), &spqs)))
                        {
                            fRet = SUCCEEDED(spqs->QueryValueExists(L"SupportedTypes", pszExt));
                        }
                    }
                }
            }
        }
    }
    return fRet;
}
                            
//                       
//      LegacyDisable 
//  LegacyDisable is set, then the verb exists only for legacy reasons, and 
//  is actually superceded by a context menu extension or some other behavior
//  it there only to retain legacy behavior for external clients that require
//  the existence of a verb.
//
BOOL CShellExecMenu::_RemoveVerb(UINT idVerb)
{
    if (SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("LegacyDisable"), NULL, NULL, NULL)))
        return TRUE;

    if (!_SupportsType(idVerb))
        return TRUE;
        
    return (_IsRestricted(idVerb));
}

BOOL CShellExecMenu::_IsVisible(BOOL fExtended, UINT idVerb)
{
    //  this is not an extended verb, or
    //  the request includes extended verbs
    if (!fExtended && SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("Extended"), NULL, NULL, NULL)))
        return FALSE;

    static const struct {
        LPCTSTR pszVerb;
    } sVerbIgnore[] = {
        c_szPrintTo
    };

    for (int i = 0; i < ARRAYSIZE(sVerbIgnore); i++)
    {
        if (lstrcmpi(_dka.ExposeName(idVerb), sVerbIgnore[i].pszVerb) == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

    
BOOL CShellExecMenu::_GetMenuString(UINT id, BOOL fExtended, LPTSTR pszMenu, UINT cchMax)
{
    BOOL bRet = FALSE;
    //  other verbs are hidden and just shouldnt be shown.
    if (SUCCEEDED(_InsureVerbs(id)) && _IsVisible(fExtended, id))
    {
        DWORD cbVerb = CbFromCch(cchMax);
        *pszMenu = 0;
        //  try the MUIVerb value first
        //  if that fails use the default value
        //  either of these can actually have an MUI string
        if (FAILED(_dka.GetValue(id, NULL, TEXT("MUIVerb"), NULL, pszMenu, &cbVerb)))
        {
            cbVerb = CbFromCch(cchMax);
            _dka.GetValue(id, NULL, NULL, NULL, pszMenu, &cbVerb);
        }

        if (!*pszMenu || FAILED(SHLoadIndirectString(pszMenu, pszMenu, cchMax, NULL)))
        {
            // If it does not have the value, generate it.
            bRet = _MenuString(_dka.ExposeName(id), pszMenu, cchMax);
        }
        else
        {
            //  use the value
            bRet = TRUE;
        }
        ASSERT(!bRet || *pszMenu);
    }
    return bRet;
}

STDMETHODIMP CShellExecMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    // new behavior: good context menus should interpret a NULL pidlFolder/hkeyProgID on a re-init
    // as meaning they should use the ones they already have.
    if (hkeyProgID)
    {
        _Cleanup(); // cleans up hkey and hdka, pdtobj too but that's ok
        _hkeyProgID = SHRegDuplicateHKey(hkeyProgID);   // make a copy
    }
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

UINT CShellExecMenu::_VerbCount()
{
    return SUCCEEDED(_InsureVerbs()) ? _dka.GetItemCount() : 0;
}

UINT CShellExecMenu::_FindIndex(LPCTSTR pszVerb)
{
    for (UINT i = 0; i < _VerbCount(); i++)
    {
        if (!lstrcmpi(pszVerb, _dka.ExposeName(i)))
            return i;       // found it!
    }
    return -1;
}

STDMETHODIMP CShellExecMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT cVerbs = 0;
    _uFlags = uFlags;   // caller may force explorer mode (CMF_EXPLORE) here

    TCHAR szMenu[CCH_MENUMAX];
    for (UINT idCmd = idCmdFirst;
         idCmd <= idCmdLast && (idCmd - idCmdFirst) < _VerbCount(); idCmd++)
    {
        UINT uMenuFlags = MF_BYPOSITION | MF_STRING;
        if (_GetMenuString(idCmd - idCmdFirst, uFlags & CMF_EXTENDEDVERBS, szMenu, ARRAYSIZE(szMenu)))
        {
            InsertMenu(hmenu, indexMenu + cVerbs, uMenuFlags, idCmd, szMenu);
            cVerbs++;
        }
    }

    if (cVerbs && (GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1))
    {
        if (_dka.HasDefault(_hkeyProgID))
        {
            //  if there is a default verb on this key,
            //  trust that it was the first one that the CDKA added
            SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);
        }
    }

    return ResultFromShort(_VerbCount());
}

LPCTSTR CShellExecMenu::_GetVerb(UINT id)
{
    return SUCCEEDED(_InsureVerbs()) ? _dka.ExposeName(id) : NULL;
}

STATIC BOOL s_fAbortInvoke = FALSE;

// This private export allows the folder code a way to cause the main invoke
// loops processing several different files to abort.

STDAPI_(void) SHAbortInvokeCommand()
{
    DebugMsg(DM_TRACE, TEXT("AbortInvokeCommand was called"));
    s_fAbortInvoke = TRUE;
}

// Call shell exec (for the folder class) using the given file and the
// given pidl. The file will be passed as %1 in the dde command and the pidl
// will be passed as %2.

STDAPI _InvokePidl(LPCMINVOKECOMMANDINFOEX pici, DWORD dwAttribs, LPCTSTR pszPath, LPCITEMIDLIST pidl, HKEY hkClass)
{
    SHELLEXECUTEINFO ei;
    HRESULT hr = ICIX2SEI(pici, &ei);
    pszPath = (dwAttribs & SFGAO_FILESYSTEM) ? pszPath : NULL;
    if (SUCCEEDED(hr))
    {
        ei.fMask |= SEE_MASK_IDLIST;

        ei.lpFile = pszPath;
        ei.lpIDList = (void *)pidl;

        // if a directory is specifed use that, else make the current
        // directory be the folder it self. UNLESS it is a AUDIO CDRom, it
        // should never be the current directory (causes CreateProcess errors)
        if (!ei.lpDirectory && (dwAttribs & SFGAO_FOLDER))
            ei.lpDirectory = pszPath;

        if (pszPath && ei.lpDirectory)
        {
            INT iDrive = PathGetDriveNumber(ei.lpDirectory);

            CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive);

            if (pmtpt)
            {
                if (pmtpt->IsAudioCDNoData())
                {
                    ei.lpDirectory = NULL;
                }

                pmtpt->Release();
            }
        }

        if (hkClass)
        {
            ei.hkeyClass = hkClass;
            ei.fMask |= SEE_MASK_CLASSKEY;
        }
        else 
            ei.fMask |= SEE_MASK_INVOKEIDLIST;
    
        if (ShellExecuteEx(&ei))
            hr = S_OK;
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

BOOL _QuitInvokeLoop()
{
    MSG msg;

    // Try to give the user a way to escape out of this
    if (s_fAbortInvoke || GetAsyncKeyState(VK_ESCAPE) < 0)
        return TRUE;

    // And the next big mondo hack to handle CAD of our window
    // because the user thinks it is hung.
    if (PeekMessage(&msg, NULL, WM_CLOSE, WM_CLOSE, PM_NOREMOVE))
        return TRUE;  // Lets also bail..

    return FALSE;
}

#define CMINVOKE_VERBT(pici) (pici)->lpVerbW

HRESULT CShellExecMenu::_MapVerbForInvoke(CMINVOKECOMMANDINFOEX *pici, UINT *pidVerb)
{
    LPCTSTR pszVerbKey;
    // is pici->lpVerb specifying the verb index (0-based).
    if (IS_INTRESOURCE(pici->lpVerb))
    {
        // find it in the CDKA
        *pidVerb = LOWORD((ULONG_PTR)pici->lpVerb);
        pszVerbKey = _GetVerb(*pidVerb);
        CMINVOKE_VERBT(pici) = pszVerbKey;  // alias into the CDKA
        RIPMSG(pszVerbKey != NULL, "CShellExecMenu::InvokeCommand() passed an invalid verb id");
    }
    else
    {
        pszVerbKey = CMINVOKE_VERBT(pici);
        if (pszVerbKey)
        {  
            *pidVerb = _FindIndex(pszVerbKey);
            if (-1 == *pidVerb)
                pszVerbKey = NULL;  // not in our list
        }
    }

    ASSERT(!pszVerbKey || *pidVerb != -1);
    return pszVerbKey ? S_OK : E_INVALIDARG;
}

BOOL CShellExecMenu::_IsExplorerMode()
{
    BOOL bRet = (_uFlags & CMF_EXPLORE);
    if (!bRet)
    {
        bRet = IsExplorerModeBrowser(_punkSite);
        if (bRet)
            _uFlags |= CMF_EXPLORE;
    }
    return bRet;
}

DWORD CShellExecMenu::_BrowseFlagsFromVerb(UINT idVerb)
{
    DWORD dwFlags = 0;
    DWORD cbFlags = sizeof(dwFlags);
    _dka.GetValue(idVerb, NULL, _IsExplorerMode() ? TEXT("ExplorerFlags") : TEXT("BrowserFlags"), NULL, &dwFlags, &cbFlags);
    return dwFlags;
}

HRESULT CShellExecMenu::_TryBrowseObject(LPCITEMIDLIST pidl, DWORD uFlags)
{
    HRESULT hr = S_FALSE;

    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        hr = psb->BrowseObject(pidl, (UINT) uFlags);
        psb->Release();
    }
    return hr;
}

HRESULT _CanTryBrowseObject(DWORD dwAttribs, CMINVOKECOMMANDINFOEX* pici)
{
    HRESULT hr = S_FALSE;

    if (dwAttribs & SFGAO_FOLDER)
    {
        // we need to sniff the iciex here to see if there is anything special in it
        // that cannot be conveyed to IShellBrowser::BrowseObject() (eg the nShow parameter)
        if ((pici->nShow == SW_SHOWNORMAL)  ||
            (pici->nShow == SW_SHOW))
        {
            // nothing special in the ICIEX, should be safe to discard it and use 
            // IShellBrowser::BrowseObject() instead of ShellExecuteEx
            hr = S_OK;
        }
    }

    return hr;
}

BOOL CShellExecMenu::_VerbCanDrop(UINT idVerb, CLSID *pclsid)
{
    TCHAR sz[GUIDSTR_MAX];
    DWORD cb = sizeof(sz);
    return (SUCCEEDED(_dka.GetValue(idVerb, L"DropTarget", L"Clsid", NULL, sz, &cb))
            && GUIDFromString(sz, pclsid));
}

HRESULT CShellExecMenu::_DoDrop(REFCLSID clsid, UINT idVerb, LPCMINVOKECOMMANDINFOEX pici)
{
    //  i think i need to persist the pici into the _pdtobj
    //  and probably add some values under the pqs
    //  we assume that the app will do something appropriate 
    //  QueryService(_punkSite, clsid) might be useful
    return SHSimulateDropOnClsid(clsid, _punkSite, _pdtobj);
}

STDMETHODIMP CShellExecMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    CMINVOKECOMMANDINFOEX ici;
    void *pvFree;
    HRESULT hr = ICI2ICIX(pici, &ici, &pvFree); // thunk incomming params
    if (SUCCEEDED(hr))
    {   
        UINT idVerb;
        hr = _MapVerbForInvoke(&ici, &idVerb);
        if (SUCCEEDED(hr))
        {
            CLSID clsid;
            if (_VerbCanDrop(idVerb, &clsid))
            {
                hr = _DoDrop(clsid, idVerb, &ici);
            }
            else
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(_pdtobj, &medium);
                if (pida)
                {
                    if (pida->cidl == 1)
                    {
                        LPITEMIDLIST pidl = IDA_FullIDList(pida, 0);
                        if (pidl)
                        {
                            hr = _InvokeOne(&ici, idVerb, pidl);
                            ILFree(pidl);
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = _InvokeMany(&ici, idVerb, pida);
                    }

                    HIDA_ReleaseStgMedium(pida, &medium);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }

        if (pvFree)
            LocalFree(pvFree);
    }

    return hr;
}

HRESULT CShellExecMenu::_InvokeOne(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    DWORD dwAttrib = SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_LINK;

    hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &dwAttrib);
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;

        if (S_OK == _CanTryBrowseObject(dwAttrib, pici))
        {
            DWORD uFlags = _BrowseFlagsFromVerb(idVerb);
            if (uFlags)
            {
                // if we did the site based navigation, we are done
                hr = _TryBrowseObject(pidl, uFlags);
            }
        }

        if (hr != S_OK)
        {
            hr = _InvokePidl(pici, dwAttrib, szPath, pidl, _hkeyProgID);

            //  only set recent on non-folders (SFGAO_STREAM?)
            //  and non-link since we know those should never be added
            if (SUCCEEDED(hr) && !(dwAttrib & (SFGAO_FOLDER | SFGAO_LINK)))
            {
                AddToRecentDocs(pidl, szPath);
            }
        }
    }

    return hr;
}

BOOL _ShouldPrompt(DWORD cItems)
{
    DWORD dwMin, cb = sizeof(dwMin);
    if (SHRegGetUSValue(REGSTR_PATH_EXPLORER, TEXT("MultipleInvokePromptMinimum"), NULL, &dwMin, &cb, FALSE, NULL, 0) != ERROR_SUCCESS)
        dwMin = 15;

    return cItems > dwMin;
}

HRESULT CShellExecMenu::_PromptUser(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida)
{
    HRESULT hr = S_FALSE;
    if (pici->hwnd && !(pici->fMask & CMIC_MASK_FLAG_NO_UI)
    && _ShouldPrompt(pida->cidl))
    {
        //  prompt the user with the verb and count
        //  we make a better experience if we keyed off 
        //  homo/hetero types and had different behaviors
        //  but its not worth it.  instead we should 
        //  switch to using AutoPlay sniffing and dialog.
        TCHAR szVerb[64];
        TCHAR szNum[10];
        wnsprintf(szNum, ARRAYSIZE(szNum), TEXT("%d"), pida->cidl);
        hr = _GetHelpText(idVerb, GCS_HELPTEXT, (PSTR)szVerb, ARRAYSIZE(szVerb));
        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            PTSTR pszTitle = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_MULTIINVOKEPROMPT_TITLE), szVerb);
            if (pszTitle)
            {
                PTSTR pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_MULTIINVOKEPROMPT_MESSAGE), szVerb, szNum);
                if (pszMsg)
                {
                    int iRet = SHMessageBoxCheck(pici->hwnd, pszMsg, pszTitle, (MB_OKCANCEL | MB_ICONEXCLAMATION), IDOK, TEXT("MultipleInvokePrompt"));
                    hr = iRet == IDOK ? S_OK : HRESULT_FROM_WIN32(ERROR_CANCELLED);

                    LocalFree(pszMsg);
                }
                LocalFree(pszTitle);
            }
        }
    }
    return hr;
}

HRESULT CShellExecMenu::_InvokeEach(LPCITEMIDLIST pidl, CMINVOKECOMMANDINFOEX *pici)
{
    HRESULT hr = E_OUTOFMEMORY;
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        CComPtr<IContextMenu> spcm;
        hr = SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IContextMenu, &spcm));
        if (SUCCEEDED(hr))
        {
            if (_punkSite)
                IUnknown_SetSite(spcm, _punkSite);

            hr = spcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, _uFlags);
            if (SUCCEEDED(hr)) 
            {
                hr = spcm->InvokeCommand((CMINVOKECOMMANDINFO *)pici);
            }

            if (_punkSite)
                IUnknown_SetSite(spcm, NULL);
        }

        DestroyMenu(hmenu);
    }
    return hr;
}

HRESULT CShellExecMenu::_InvokeMany(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida)
{
    HRESULT hr = _PromptUser(pici, idVerb, pida);
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        s_fAbortInvoke = FALSE; // reset this global for this run...
        //  we want to alter the pici
        //  so that each item is handled individually
        pici->hwnd = NULL;
        pici->fMask |= CMIC_MASK_FLAG_NO_UI;

        //  NTBUG #502223 - MSI apps with DDE start multiple copies - ZekeL 2001-DEC-07
        //  ShellExec() will create a new thread for MSI apps to 
        //  avoid a deadlock with the MSI APIs calling SHChangeNotify().
        //  this is described in NTBUG #200961
        //  however in the multiple invoke case we create one thread
        //  for each item in the invoke, which results in several processes
        //  contending for the DDE conversation.
        //  
        //  this is a half fix.  we prefer to have the buggy behavior in 502223 
        //  over the deadlock behavior in 200961 (a definite PSS call).  
        //  since the deadlock case should only occur for the desktop, 
        //  the rest of the time we will force a synchronous invoke.
        IBindCtx *pbcRelease = NULL;
        if (!IsDesktopBrowser(_punkSite))
        {
            TBCRegisterObjectParam(TBCDIDASYNC, SAFECAST(this, IContextMenu *), &pbcRelease);
        }

        pici->lpVerb = T2A(_dka.ExposeName(idVerb));
        pici->lpVerbW = _dka.ExposeName(idVerb);
        
        for (UINT iItem = 0; !_QuitInvokeLoop() && (iItem < pida->cidl); iItem++)
        {
            LPITEMIDLIST pidl = IDA_FullIDList(pida, iItem);
            if (pidl)
            {
                hr = _InvokeEach(pidl, pici);
                ILFree(pidl);
            }
            else 
                hr = E_OUTOFMEMORY;

            if (hr == E_OUTOFMEMORY)
                break;

        }

        ATOMICRELEASE(pbcRelease);
    }
    return hr;
}

HRESULT CShellExecMenu::_GetHelpText(UINT idVerb, UINT uType, LPSTR pszName, UINT cchMax)
{
    //  TODO - shouldnt we let the registry override?
    HRESULT hr = E_OUTOFMEMORY;
    TCHAR szMenuString[CCH_MENUMAX];
    if (_GetMenuString(idVerb, TRUE, szMenuString, ARRAYSIZE(szMenuString)))
    {
        SHStripMneumonic(szMenuString);
        //  NOTE on US, IDS_VERBHELP is the same as "%s"
        //  do we want some better description?
        LPTSTR pszHelp = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_VERBHELP), szMenuString);
        if (pszHelp)
        {
            if (uType == GCS_HELPTEXTA)
                SHTCharToAnsi(pszHelp, pszName, cchMax);
            else
                SHTCharToUnicode(pszHelp, (LPWSTR)pszName, cchMax);
            LocalFree(pszHelp);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CShellExecMenu::_MapVerbForGCS(UINT_PTR idCmd, UINT uType, UINT *pidVerb)
{
    HRESULT hr = _InsureVerbs();
    if (SUCCEEDED(hr))
    {
        if (IS_INTRESOURCE(idCmd))
            *pidVerb = (UINT)idCmd;
        else
        {
            *pidVerb = -1;
            if (!(uType & GCS_UNICODE))
            {
                USES_CONVERSION;
                *pidVerb = _FindIndex(A2W((LPCSTR)idCmd));
            }

            // we fall back to the TCHAR version regardless
            // of what the caller passed in uType
            if (*pidVerb == -1)
            {
                if (!IsBadStringPtrW((LPCWSTR)idCmd, (UINT)-1))
                    *pidVerb = _FindIndex((LPCWSTR)idCmd);
            }
        }
        hr = *pidVerb < _VerbCount() ? S_OK : E_INVALIDARG;
    }

    //  VALIDATE returns S_FALSE for bad verbs
    if (FAILED(hr) && (uType == GCS_VALIDATEA || uType == GCS_VALIDATEW))
        hr = S_FALSE;
        
    return hr;
}
    
STDMETHODIMP CShellExecMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
{
    UINT idVerb;
    HRESULT hr = _MapVerbForGCS(idCmd, uType, &idVerb);
    if (SUCCEEDED(hr))
    {
        //  the verb is good!
        switch (uType)
        {
        case GCS_HELPTEXTA:
        case GCS_HELPTEXTW:
            hr = _GetHelpText(idVerb, uType, pszName, cchMax);
            break;
            
        case GCS_VERBA:
        case GCS_VERBW:
            {
                if (uType == GCS_VERBA)
                    SHTCharToAnsi(_dka.ExposeName(idVerb), pszName, cchMax);
                else
                    SHTCharToUnicode(_dka.ExposeName(idVerb), (LPWSTR)pszName, cchMax);
                hr = S_OK;
            }
            break;

        case GCS_VALIDATEA:
        case GCS_VALIDATEW:
            //  the hr from MapVerb is good enough
            break;
            
        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    
    return hr;
}

STDMETHODIMP CShellExecMenu::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    return _pfnAddPages(_pdtobj, pfnAddPage, lParam);
}

STDMETHODIMP CShellExecMenu::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}    

STDAPI CShellExecMenu_CreateInstance(LPFNADDPAGES pfnAddPages, REFIID riid, void **ppv)
{
    HRESULT hr;
    CShellExecMenu *pdext = new CShellExecMenu(pfnAddPages); 
    if (pdext)
    {
        hr = pdext->QueryInterface(riid, ppv);
        pdext->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// these handlers slime off of CShellExecMenu's IShellPropSheetExt implementation

STDAPI FileSystem_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

STDAPI CShellFileDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CShellExecMenu_CreateInstance(FileSystem_AddPages, riid, ppv);
}

STDAPI CDrives_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

STDAPI CShellDrvDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CShellExecMenu_CreateInstance(CDrives_AddPages, riid, ppv);
}

#ifdef _X86_
STDAPI PIF_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

STDAPI CProxyPage_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CShellExecMenu_CreateInstance(PIF_AddPages, riid, ppv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\shtdndlg.c ===
/*************************************************************************
 Private shell shutdown dialog implementation

  The shell needs a shutdown dialog implementation independent of MSGINA's
  implementation to ensure it will function on NT4 and Win9x machines.

  This version of shutdown should only be called if the LoadLib and
  GetProcAddress for the MSGINA version fail.

  This code should be kept in some type of sync with the code in 
  win/gina/msgina/shtdndlg.c

  -dsheldon 10/27/98
*************************************************************************/

#include "shellprv.h"

#include <windowsx.h>
#include <help.h>

#define MAX_SHTDN_OPTIONS               7

#define MAX_CCH_NAME 64
#define MAX_CCH_DESC 256

typedef struct _SHUTDOWNOPTION
{
    DWORD dwOption;
    TCHAR szName[MAX_CCH_NAME + 1];
    TCHAR szDesc[MAX_CCH_DESC + 1];
} SHUTDOWNOPTION, *PSHUTDOWNOPTION;

typedef struct _SHUTDOWNDLGDATA
{
    SHUTDOWNOPTION rgShutdownOptions[MAX_SHTDN_OPTIONS];
    int cShutdownOptions;
    DWORD dwFlags;
    DWORD dwItemSelect;
    BOOL fEndDialogOnActivate;
} SHUTDOWNDLGDATA, *PSHUTDOWNDLGDATA;

// Internal function prototypes
void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc, 
                               PSHUTDOWNOPTION pOption);

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata);

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

DWORD GetOptionSelection(HWND hwndCombo);

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

BOOL_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam);

// Copied function implementations and constants
// A function copied from gina that shutdown dialog needs.
/*-----------------------------------------------------------------------------
/ MoveControls
/ ------------
/   Load the image and add the control to the dialog.
/
/ In:
/   hWnd = window to move controls in
/   aID, cID = array of control ids to be moved
/   dx, dy = deltas to apply to controls
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MoveControls(HWND hWnd, UINT* aID, INT cID, INT dx, INT dy, BOOL fSizeWnd)
{
    RECT rc;

    while ( --cID >= 0 )
    {
        HWND hWndCtrl = GetDlgItem(hWnd, aID[cID]);

        if ( hWndCtrl )
        {
            GetWindowRect(hWndCtrl, &rc);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);
            OffsetRect(&rc, dx, dy);
            SetWindowPos(hWndCtrl, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
        }
    }

    if ( fSizeWnd )
    {
        GetWindowRect(hWnd, &rc);
        MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT)&rc, 2);
        SetWindowPos(hWnd, NULL,
                     0, 0, (rc.right-rc.left)+dx, (rc.bottom-rc.top)+dy,
                     SWP_NOZORDER|SWP_NOMOVE);
    }
}

/****************************************************
 Option flags (dwFlags)
 ----------------------
****************************************************/
#define SHTDN_NOHELP                    0x000000001
#define SHTDN_NOPALETTECHANGE           0x000000002

// Shutdown reg value name
#define SHUTDOWN_SETTING TEXT("Shutdown Setting")

// Da code
// -------

BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc, 
                               PSHUTDOWNOPTION pOption)
{
    BOOL fSuccess = (LoadString(HINST_THISDLL, idStringName, pOption->szName,
        ARRAYSIZE(pOption->szName)) != 0);

    fSuccess &= (LoadString(HINST_THISDLL, idStringDesc, pOption->szDesc,
        ARRAYSIZE(pOption->szDesc)) != 0);

    return fSuccess;
}

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata)
{
    BOOL fSuccess = TRUE;
    pdata->cShutdownOptions = 0;

    if (dwItems & SHTDN_LOGOFF)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_LOGOFF;

        // Note that logoff is a special case: format using a user name ala
        // "log off <username>".
        fSuccess &= LoadShutdownOptionStrings(IDS_LOGOFF_NAME, 
            IDS_LOGOFF_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions]));

        if (fSuccess)
        {
            TCHAR szTemp[ARRAYSIZE(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName)];

            if (szUsername != NULL)
            {
                StringCchPrintf(szTemp,
                                ARRAYSIZE(szTemp),
                                pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                                szUsername);
            }
            else
            {
                StringCchPrintf(szTemp,
                                ARRAYSIZE(szTemp),
                                pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                                TEXT(""));
            }

            // Now we have the real logoff title in szTemp; copy is back
            StringCchCopy(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                          ARRAYSIZE(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName),
                          szTemp); 

            // Success!
            pdata->cShutdownOptions ++;
        }

    }

    if (dwItems & SHTDN_SHUTDOWN)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SHUTDOWN;
        fSuccess &= LoadShutdownOptionStrings(IDS_SHUTDOWN_NAME, 
            IDS_SHUTDOWN_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_RESTART)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART;
        fSuccess &= LoadShutdownOptionStrings(IDS_RESTART_NAME, 
            IDS_RESTART_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_RESTART_DOS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART_DOS;
        fSuccess &= LoadShutdownOptionStrings(IDS_RESTARTDOS_NAME, 
            IDS_RESTARTDOS_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_SLEEP)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP;
        fSuccess &= LoadShutdownOptionStrings(IDS_SLEEP_NAME, 
            IDS_SLEEP_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_SLEEP2)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP2;
        fSuccess &= LoadShutdownOptionStrings(IDS_SLEEP2_NAME, 
            IDS_SLEEP2_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_HIBERNATE)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_HIBERNATE;
        fSuccess &= LoadShutdownOptionStrings(IDS_HIBERNATE_NAME, 
            IDS_HIBERNATE_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    return fSuccess;
}

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) lParam;
    HWND hwndCombo;
    int iOption;
    int iComboItem;
    
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);

    // Hide the help button and move over OK and Cancel if applicable
    if (pdata->dwFlags & SHTDN_NOHELP)
    {
        static UINT rgidNoHelp[] = {IDOK, IDCANCEL};
        RECT rc1, rc2;
        int dx;
        HWND hwndHelp = GetDlgItem(hwnd, IDHELP);

        EnableWindow(hwndHelp, FALSE);
        ShowWindow(hwndHelp, SW_HIDE);

        GetWindowRect(hwndHelp, &rc1);
        GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc2);

        dx = rc1.left - rc2.left;

        MoveControls(hwnd, rgidNoHelp, ARRAYSIZE(rgidNoHelp), dx, 0, FALSE);
    }

    // Add the items specified to the combo box
    hwndCombo = GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO);

    for (iOption = 0; iOption < pdata->cShutdownOptions; iOption ++)
    {
        // Add the option
        iComboItem = ComboBox_AddString(hwndCombo, 
            pdata->rgShutdownOptions[iOption].szName);

        if (iComboItem != (int) CB_ERR)
        {
            // Store a pointer to the option
            ComboBox_SetItemData(hwndCombo, iComboItem, 
                &(pdata->rgShutdownOptions[iOption]));

            // See if we should select this option
            if (pdata->rgShutdownOptions[iOption].dwOption == pdata->dwItemSelect)
            {
                ComboBox_SetCurSel(hwndCombo, iComboItem);
            }
        }
    }

    // If we don't have a selection in the combo, do a default selection
    if (ComboBox_GetCurSel(hwndCombo) == CB_ERR)
    {
        ComboBox_SetCurSel(hwndCombo, 0);
    }

    SetShutdownOptionDescription(hwndCombo, 
        GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));

    // If we get an activate message, dismiss the dialog, since we just lost
    // focus
    pdata->fEndDialogOnActivate = TRUE;

    return TRUE;
}

DWORD GetOptionSelection(HWND hwndCombo)
{
    DWORD dwResult;
    PSHUTDOWNOPTION pOption;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != (int) CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);
        dwResult = pOption->dwOption;
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    return dwResult;
}

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic)
{
    int iItem;
    PSHUTDOWNOPTION pOption;

    iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);

        SetWindowText(hwndStatic, pOption->szDesc);
    }
}

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL fHandled = FALSE;
    DWORD dwDlgResult;
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) 
        GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (id)
    {
    case IDOK:
        dwDlgResult = GetOptionSelection(GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO));
        if (dwDlgResult != SHTDN_NONE)
        {
            pdata->fEndDialogOnActivate = FALSE;
            fHandled = TRUE;
            EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
    case IDCANCEL:
        pdata->fEndDialogOnActivate = FALSE;
        EndDialog(hwnd, (int) SHTDN_NONE);
        fHandled = TRUE;
        break;
    case IDC_EXITOPTIONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetShutdownOptionDescription(hwndCtl, 
                GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));
            fHandled = TRUE;
        }
        break;
    case IDHELP:
        WinHelp(hwnd, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
        break;
    }
    return fHandled;
}

BOOL_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Shutdown_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Shutdown_OnCommand);
        case WM_INITMENUPOPUP:
        {
            EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        }
        break;
        case WM_SYSCOMMAND:
            // Blow off moves (only really needed for 32bit land).
            if ((wParam & ~0x0F) == SC_MOVE)
                return TRUE;
            break;
        case WM_ACTIVATE:
            // If we're loosing the activation for some other reason than
            // the user click OK/CANCEL then bail.
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

                if (pdata->fEndDialogOnActivate)
                {
                    pdata->fEndDialogOnActivate = FALSE;
                    EndDialog(hwnd, SHTDN_NONE);
                }
            }
            break;
    }

    return FALSE;
}

/****************************************************************************
 ShutdownDialog
 --------------

  Launches the shutdown dialog. 
  
  hWlx and pfnWlxDialogBoxParam MUST be null for this shell-only version

  Other flags are listed in shtdnp.h.
****************************************************************************/
DWORD ShutdownDialog(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect,
                     LPCTSTR szUsername, DWORD dwFlags, void* hWlx, 
                     void* pfnWlxDialogBoxParam)
{
    // Array of shutdown options - the dialog data
    SHUTDOWNDLGDATA data;
    DWORD dwResult;

    // Set the flags
    data.dwFlags = dwFlags;

    // Set the initially selected item
    data.dwItemSelect = dwItemSelect;

    // Read in the strings for the shutdown option names and descriptions
    if (BuildShutdownOptionArray(dwItems, szUsername, &data))
    {
        // Display the dialog and return the user's selection

        // ..if the caller wants, use a Wlx dialog box function
        if ((hWlx != NULL) || (pfnWlxDialogBoxParam != NULL))
        {
            // Error; winlogon should never call this
            // cheesy shell version of shutdown
            dwResult = SHTDN_NONE;
        }
        else
        {
            // Use standard dialog box
            dwResult = (DWORD) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_EXITWINDOWS_DIALOG), hwndParent,
                Shutdown_DialogProc, (LPARAM) &data);
        }
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    return dwResult;
}

DWORD DownlevelShellShutdownDialog(HWND hwndParent, DWORD dwItems, LPCTSTR szUsername)
{
    DWORD dwSelect = SHTDN_NONE;
    DWORD dwDialogResult;
    HKEY hkeyShutdown;
    DWORD dwType;
    DWORD dwDisposition;
    LONG lResult;

    // get the User's last selection.
    lResult = RegCreateKeyEx(HKEY_CURRENT_USER,
                             REGSTR_PATH_EXPLORER,
                             0,
                             0,
                             0,
                             KEY_QUERY_VALUE,
                             NULL,
                             &hkeyShutdown,
                             &dwDisposition);

    if (lResult == ERROR_SUCCESS) 
    {
        DWORD cbData = sizeof(dwSelect);
        lResult = SHQueryValueEx(hkeyShutdown,
                                 SHUTDOWN_SETTING,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwSelect,
                                 &cbData);

        RegCloseKey(hkeyShutdown);
    }

    if (dwSelect == SHTDN_NONE)
    {
        dwSelect = SHTDN_SHUTDOWN;
    }

    dwDialogResult = ShutdownDialog(hwndParent,
                                    dwItems, 
                                    dwSelect,
                                    szUsername,
                                    SHTDN_NOPALETTECHANGE,
                                    NULL,
                                    NULL);

    if (dwDialogResult != SHTDN_NONE)
    {
        // Save back the user's choice to the registry
        if (RegCreateKeyEx(HKEY_CURRENT_USER,
                           REGSTR_PATH_EXPLORER,
                           0,
                           0,
                           0,
                           KEY_SET_VALUE,
                           NULL,
                           &hkeyShutdown,
                           &dwDisposition) == ERROR_SUCCESS) 
        {
            RegSetValueEx(hkeyShutdown,
                          SHUTDOWN_SETTING,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dwDialogResult,
                          sizeof(dwDialogResult));

            RegCloseKey(hkeyShutdown);
        }
    }

    return dwDialogResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\srcc.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

BUILD_PRIVLIB   = 1
SELFREGNAME     = $(O)\selfreg_shell32.inf
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

MSC_WARNING_LEVEL=/W4

!include $(CCSHELL_DIR)\shell32\shell32.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shell32\shell32.inc

SYNCHRONIZE_DRAIN=1

TARGETNAME      = shell32
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

PASS1_PUBLISH= \
    {$(O)\shell32.lib=$(SDK_LIB_PATH)\shell32.lib}  \
    {$(O)\shell32p.lib=$(SHELL_LIB_PATH)\shell32p.lib}

TARGETLIBS      = $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib          \
                  $(LIBRARY_PLATFORM_PATH)\*\user32.lib         \
                  $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib       \
                  ..\sdspatch\$(O)\sdspatch.lib                 \
                  ..\menuband\$(O)\menuband.lib                 \
                  $(SDK_LIB_PATH)\advapip.lib                  \
                  $(SDK_LIB_PATH)\adsiid.lib                    \
                  $(SHELL_LIB_PATH)\shlwapip.lib                \
                  $(SDK_LIB_PATH)\winmm.lib                     \
                  $(SDK_LIB_PATH)\msi.lib                       \
                  $(SDK_LIB_PATH)\devmgr.lib                    \
                  $(SDK_LIB_PATH)\urlmon.lib                    \
                  $(SDK_LIB_PATH)\wininet.lib                   \
                  $(SDK_LIB_PATH)\secur32.lib                   \
                  $(SDK_LIB_PATH)\winspool.lib                  \
                  $(SDK_LIB_PATH)\userenv.lib                   \
                  $(SDK_LIB_PATH)\ole32.lib                     \
                  $(SDK_LIB_PATH)\oleaut32.lib                  \
                  $(SDK_LIB_PATH)\oleacc.lib                    \
                  $(SDK_LIB_PATH)\version.lib                   \
                  $(NET_LIB_PATH)\mprp.lib                      \
                  $(SDK_LIB_PATH)\mprapi.lib                    \
                  $(SDK_LIB_PATH)\netapi32.lib                  \
                  $(SDK_LIB_PATH)\cscdll.lib                    \
                  $(SDK_LIB_PATH)\ntdsapi.lib                   \
                  $(SDK_LIB_PATH)\activeds.lib                  \
                  $(SDK_LIB_PATH)\msdasc.lib                    \
                  $(SHELL_LIB_PATH)\uxthemep.lib                \
                  $(DS_LIB_PATH)\creduip.lib                    \
                  $(SDK_LIB_PATH)\rasapi32.lib                  \
                  $(DS_LIB_PATH)\msgina.lib                     \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib            \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib           \
                  $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib           \
                  $(SDK_LIB_PATH)\uuid.lib                      \
                  $(SDK_LIB_PATH)\wiaguid.lib                   \
                  $(SDK_LIB_PATH)\powrprof.lib                  \
                  $(SHELL_LIB_PATH)\shdocvwp.lib                \
                  $(PROJECT_ROOT)\lib\$(O)\browseui.lib         \
                  $(PROJECT_LIB_PATH)\shdocvw.lib               \
                  $(PROJECT_ROOT)\lib\$(O)\secutil.lib          \
                  $(SHELL_LIB_PATH)\efsadu.lib                  \
                  $(SHELL_LIB_PATH)\linkinfo.lib                \
                  $(CCSHELL_DIR)\lib\$(O)\shfusion.lib          \
                  $(SDK_LIB_PATH)\msimg32.lib                   \
                  $(WINDOWS_LIB_PATH)\obj\duser.lib             \
!if $(FREEBUILD)
                  $(WINDOWS_LIB_PATH)\directui.lib              \
!else
                  $(WINDOWS_LIB_PATH)\directuid.lib             \
!endif
                  $(PRINTSCAN_LIB_PATH)\printui.lib             \
                  $(SDK_LIB_PATH)\htmlhelp.lib                  \
                  $(CCSHELL_DIR)\ext\cdfview\dll\$(O)\cdfview.lib \
                  $(SDK_LIB_PATH)\setupapi.lib                  \
                  $(SDK_LIB_PATH)\dxguid.lib                    \
                  $(WINDOWS_LIB_PATH)\apphelp.lib

# Remember - only things that are listed in the DEF file go into LINKLIBS
LINKLIBS        = ..\ntcpp\$(O)\srccpp.lib                      \
                  ..\unicpp\ntcpp\$(O)\unicpp.lib               \
                  $(PROJECT_ROOT)\lib\$(O)\stock.lib

TARGETLIBS      = $(TARGETLIBS)                                 \
                  $(SDK_LIB_PATH)\ntdll.lib                     \
                  $(SDK_LIB_PATH)\rpcrt4.lib                    \
                  $(SDK_LIB_PATH)\query.lib                     \
                  $(WINDOWS_LIB_PATH)\user32p.lib               \
                  $(SDK_LIB_PATH)\gdiplus.lib                   \
                  $(SDK_LIB_PATH)\imm32.lib

# shlwapip.lib is weird.
#
# We want to put shlwapip.lib into the LINKLIBS because we have old
# exports from shell32.lib that have moved to shlwapi (which we forward to)
# and we can't remove them since people link to them by ordinal.
#
# However, LINKLIBS are linked before TARGETLIBS, which is a problem
# because shlwapip contains overrides for standard Win32 functions
# which we do not want to use.  (The overrides come from the Trident
# people, who apparently rely on them.)
#
# The secret is IMPLIB_OBJS.  We list shlwapip.lib there to indicate
# that we need it built in order to link, and also list it in TARGETLIBS
# to indicate the link order.

IMPLIB_OBJS     = $(IMPLIB_OBJS)                                \
                  $(SHELL_LIB_PATH)\shlwapip.lib


DELAYLOAD       = query.dll;winmm.dll;msi.dll;\
                  urlmon.dll;wininet.dll;devmgr.dll;winspool.drv;userenv.dll;\
                  ole32.dll;oleaut32.dll;secur32.dll;oleacc.dll;\
                  version.dll;mpr.dll;netapi32.dll;cscdll.dll;linkinfo.dll;\
                  shdocvw.dll;browseui.dll;uxtheme.dll;\
                  credui.dll;msgina.dll;efsadu.dll;powrprof.dll;rasapi32.dll;\
                  printui.dll;cdfview.dll;msimg32.dll;duser.dll;setupapi.dll;\
                  imm32.dll;gdiplus.dll;apphelp.dll

DLOAD_ERROR_HANDLER = kernel32

DLLDEF          = $(O)\shell32.def

PRIVDEFSRC      = ..\shell32.src
PRIVDEF         = $(O)\shell32p.def
PRIVLIB         = shell32p.lib

INCLUDES        = $(INCLUDES);$(PROJECT_ROOT)\lib\$(O);$(O);$(TERMSRV_INC_PATH)

USE_MSVCRT      = 1

DLLENTRY        = _DllMainCRTStartup

NTTARGETFILES   =

# for historical reasons we include some GUIDs in the shell32 import library
DLLLIBOBJECTS   = $(CCSHELL_DIR)\lib\$(O)\shguid.lib

SOURCES         = \
                  ..\shell32.rc  \
                  ..\about.c     \
                  ..\bitbuck.c   \
                  ..\bookmk.c    \
                  ..\cabstate.c  \
                  ..\clsobj.c    \
                  ..\control1.c  \
                  ..\copy.c      \
                  ..\copyhook.c  \
                  ..\cplobj.c    \
                  ..\cstrings.c  \
                  ..\debug.c     \
                  ..\defclsf.c   \
                  ..\drawpie.c   \
                  ..\exec.c      \
                  ..\extract.c   \
                  ..\expenv.c    \
                  ..\futil.c     \
                  ..\hash.c      \
                  ..\help.c      \
                  ..\init.c      \
                  ..\lvutil.c    \
                  ..\malloc.c    \
                  ..\msgbox.c    \
                  ..\ole2def.c   \
                  ..\ole2dup.c   \
                  ..\ole2dup2.c  \
                  ..\os.c        \
                  ..\path.c      \
                  ..\fldsets.c   \
                  ..\pickicon.c  \
                  ..\printer1.c  \
                  ..\prtprop.c   \
                  ..\psxa.c      \
                  ..\rdrag.c     \
                  ..\reglist.c   \
                  ..\restart.c   \
                  ..\rundll32.c  \
                  ..\shared.c    \
                  ..\shprsht.c   \
                  ..\shtdndlg.c  \
                  ..\stream.c    \
                  ..\undo.c      \
                  ..\version.c   \
                  ..\viewcomm.c  \
                  ..\ynlist.c    \
                  ..\exec2nt.c   \
                  ..\argvw.c     \
                  ..\lstrfns.c   \
                  ..\psdocurd.c  \
                  ..\regenv.c    \
                  ..\nothunk.c   \
                  ..\thunktxt.c  \
                  ..\pifdat.c    \
                  ..\piffnt.c    \
                  ..\pifhot.c    \
                  ..\pifinf.c    \
                  ..\piflib.c    \
                  ..\pifmem.c    \
                  ..\pifmgr.c    \
                  ..\pifmsc.c    \
                  ..\pifprg.c    \
                  ..\pifsub.c    \
                  ..\pifvid.c    \
                  ..\lnkcon.c    \
                  ..\lnkfnt.c    \
                  ..\lnkprev.c   \
                  ..\lnkmisc.c   \
                  ..\dbcs.c      \
                  ..\proxynt.c   \
                  ..\apithk.c    \
                  ..\utilnt.c

PRECOMPILED_INCLUDE = ..\shellprv.h

#
#
# Con-fusion
#
# we can't use 123 because rundll32 will activate it, rendering all CPLs manifested
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\stgenum.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "filefldr.h"
#include "stgenum.h"

// Construction / Destruction

CFSFolderEnumSTATSTG::CFSFolderEnumSTATSTG(CFSFolder* psf) :
    _cRef(1),
    _pfsf(psf),
    _cIndex(0)
{
    _pfsf->AddRef();

    _pfsf->_GetPath(_szSearch, ARRAYSIZE(_szSearch));

    // ok if this fails, it will prevent us from enumerating, which is good
    PathAppend(_szSearch, TEXT("*"));  // we're looking for everything.

    _hFindFile = INVALID_HANDLE_VALUE;

    DllAddRef();
}

CFSFolderEnumSTATSTG::~CFSFolderEnumSTATSTG()
{
    _pfsf->Release();

    if (_hFindFile != INVALID_HANDLE_VALUE)
        FindClose(_hFindFile);

    DllRelease();
}

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFSFolderEnumSTATSTG::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFSFolderEnumSTATSTG::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFSFolderEnumSTATSTG::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CFSFolderEnumSTATSTG, IEnumSTATSTG), // IEnumSTATSTG
        { 0 },
    };    
    return QISearch(this, qit, riid, ppv);
}

// IEnumSTATSTG
STDMETHODIMP CFSFolderEnumSTATSTG::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;   // assume end of the enum
    
    ASSERT(rgelt);

    ZeroMemory(rgelt, sizeof(STATSTG));  // per COM conventions

    if (pceltFetched)
        *pceltFetched = 0;

    WIN32_FIND_DATA fd;
    BOOL fFound = FALSE;
    BOOL fGotFD = FALSE;

    do
    { 
        if (_cIndex == 0)
        {
            // this is the first file we look at.
            fGotFD = S_OK == SHFindFirstFile(_szSearch, &fd, &_hFindFile);
        }
        else
        {
            fGotFD = FindNextFile(_hFindFile, &fd);
        }
        _cIndex++;

        if (fGotFD)
        {
            ASSERT(fd.cFileName[0]);
            if (!PathIsDotOrDotDot(fd.cFileName))
                fFound = TRUE;
        }
    } while (fGotFD && !fFound);

    if (fFound)
    {
        hr = StatStgFromFindData(&fd, STATFLAG_DEFAULT, rgelt);
        if (SUCCEEDED(hr))
        {
            if (pceltFetched)
                *pceltFetched = 1;
        }
    }
    else if (_hFindFile != INVALID_HANDLE_VALUE)
    {
        // we'll be nice and close the handle as early as possible.
        FindClose(_hFindFile);
        _hFindFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}

STDMETHODIMP CFSFolderEnumSTATSTG::Reset()
{
    HRESULT hr = S_OK;

    _cIndex = 0;

    if (_hFindFile != INVALID_HANDLE_VALUE)
    {
        FindClose(_hFindFile);
        _hFindFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\srccpp.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

!include $(CCSHELL_DIR)\shell32\shell32.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shell32\shell32.inc
INCLUDES        = $(INCLUDES); $(COM_INC_PATH);

NO_BROWSER_FILE = 1

PRECOMPILED_CXX = 1

TARGETNAME      = srccpp
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = \
                  ..\apdlg.cpp     \
                  ..\apdlglog.cpp  \
                  ..\apprmdlg.cpp  \
                  ..\assocarray.cpp \
                  ..\autocm.cpp    \
                  ..\balmsg.cpp    \
                  ..\basedlg.cpp   \
                  ..\bbckfldr.cpp  \
                  ..\brffldr.cpp   \
                  ..\browse.cpp    \
                  ..\category.cpp  \
                  ..\cdburn.cpp    \
                  ..\cdburnfldr.cpp \
                  ..\clientxi.cpp  \
                  ..\colhndlr.cpp  \
                  ..\combview.cpp  \
                  ..\confirmationui.cpp \
                  ..\contextmenu.cpp \
                  ..\copyfgd.cpp   \
                  ..\cpaction.cpp \
                  ..\cpduihlp.cpp \
                  ..\cpguids.cpp \
                  ..\cplnkele.cpp \
                  ..\cpnamespc.cpp \
                  ..\cpuiele.cpp \
                  ..\cputil.cpp \
                  ..\cpview.cpp \
                  ..\ctrlfldr.cpp  \
                  ..\ctrlxicon.cpp \
                  ..\dataprv.cpp   \
                  ..\datautil.cpp  \
                  ..\defcm.cpp     \
                  ..\defview.cpp   \
                  ..\defviewcoldlg.cpp \
                  ..\defviewlegacy.cpp \
                  ..\defvphst.cpp  \
                  ..\defxicon.cpp  \
                  ..\deskfldr.cpp  \
                  ..\dlglogic.cpp  \
                  ..\dll.cpp       \
                  ..\dragdrop.cpp  \
                  ..\drivfldr.cpp  \
                  ..\drivxicon.cpp \
                  ..\drvx.cpp      \
                  ..\duidrag.cpp   \
                  ..\duihost.cpp   \
                  ..\duiinfo.cpp   \
                  ..\duilist.cpp   \
                  ..\duisec.cpp    \
                  ..\duitask.cpp   \
                  ..\duiview.cpp   \
                  ..\dvmenu.cpp    \
                  ..\dvtasks.cpp   \
                  ..\dvthumbnail.cpp \
                  ..\dynastg.cpp   \
                  ..\eballoon.cpp  \
                  ..\enumidlist.cpp \
                  ..\enumuicommand.cpp \
                  ..\execute.cpp   \
                  ..\executil.cpp  \
                  ..\exedrop.cpp   \
                  ..\fassoc.cpp    \
                  ..\findband.cpp  \
                  ..\finddlg.cpp   \
                  ..\findfilter.cpp \
                  ..\findfldr.cpp  \
                  ..\filefldr.cpp  \
                  ..\fileenum.cpp  \
                  ..\fileicon.cpp  \
                  ..\filetbl.cpp   \
                  ..\filetype.cpp  \
                  ..\filtgrep.cpp  \
                  ..\findcmd.cpp   \
                  ..\findfldr.cpp  \
                  ..\fldrcust.cpp  \
                  ..\fldrscut.cpp  \
                  ..\folder.cpp    \
                  ..\foldertip.cpp \
                  ..\folderviewhost.cpp \
                  ..\format.cpp    \
                  ..\fsassoc.cpp   \
                  ..\fsdata.cpp    \
                  ..\fsdrptgt.cpp  \
                  ..\fsmenu.cpp    \
                  ..\fstree.cpp    \
                  ..\folderthumb.cpp \
                  ..\ftaction.cpp  \
                  ..\ftadv.cpp     \
                  ..\ftascstr.cpp  \
                  ..\ftassoc.cpp   \
                  ..\ftdlg.cpp     \
                  ..\ftedit.cpp    \
                  ..\ftenum.cpp    \
                  ..\ftprop.cpp    \
                  ..\hwcmmn.cpp    \
                  ..\hwshlexc.cpp  \
                  ..\idldata.cpp   \
                  ..\idldrop.cpp   \
                  ..\idltree.cpp   \
                  ..\idlist.cpp    \
                  ..\infotip.cpp   \
                  ..\inistg.cpp    \
                  ..\isproc.cpp    \
                  ..\item.cpp      \
                  ..\itemhelp.cpp  \
                  ..\limitinput.cpp   \
                  ..\linkwnd.cpp   \
                  ..\linkprop.cpp  \
                  ..\lowdisk.cpp   \
                  ..\mergfldr.cpp  \
                  ..\mixctnt.cpp   \
                  ..\mkhelp.cpp    \
                  ..\mountvol.cpp  \
                  ..\mtpt2.cpp     \
                  ..\mtptarun2.cpp \
                  ..\mtptevnt.cpp  \
                  ..\mtptis2.cpp   \
                  ..\mtptl2.cpp    \
                  ..\mtptlis.cpp   \
                  ..\mtptr2.cpp    \
                  ..\mtptris.cpp   \
                  ..\mtptmgmt2.cpp \
                  ..\mulprsht.cpp  \
                  ..\mydocsfldr.cpp \
                  ..\nametrans.cpp \
                  ..\netapi.cpp    \
                  ..\netcrawl.cpp  \
                  ..\netfind.cpp   \
                  ..\netfldr.cpp   \
                  ..\nswalk.cpp    \
                  ..\openwith.cpp  \
                  ..\ovrlaymn.cpp  \
                  ..\prndrop.cpp   \
                  ..\prnfldr.cpp   \
                  ..\prop.cpp	   \
                  ..\prshtcpp.cpp  \
                  ..\recclean.cpp  \
                  ..\recdocs.cpp   \
                  ..\regfldr.cpp   \
                  ..\regsprtb.cpp  \
                  ..\regsuprt.cpp  \
                  ..\regtreeitems.cpp \
                  ..\reminder.cpp  \
                  ..\rundlg.cpp    \
                  ..\scffile.cpp   \
                  ..\scnotify.cpp  \
                  ..\securent.cpp  \
                  ..\security.cpp  \
                  ..\sencrypt.cpp  \
                  ..\sfstorage.cpp \
                  ..\sfvcmpt.cpp   \
                  ..\sfvext.cpp    \
                  ..\shapi.cpp     \
                  ..\sharedfldr.cpp \
                  ..\shcombox.cpp  \
                  ..\shelllnk.cpp  \
                  ..\shlnot.cpp    \
                  ..\shlobjs.cpp   \
                  ..\startpin.cpp  \
                  ..\stgenum.cpp   \
                  ..\stgutil.cpp   \
                  ..\stg2stgx.cpp  \
                  ..\storage.cpp   \
                  ..\SwitchUserDialog.cpp \
                  ..\thumbnailgen.cpp \
                  ..\thumbutil.cpp \
                  ..\Tooltip.cpp \
                  ..\tracker.cpp   \
                  ..\treewalk.cpp  \
                  ..\treewkcb.cpp  \
                  ..\uevttmr.cpp   \
                  ..\userpict.cpp  \
                  ..\util.cpp      \
                  ..\viewstate.cpp \
                  ..\websvc.cpp    \
                  ..\xiconwrap.cpp \


PRECOMPILED_INCLUDE = ..\shellprv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\stg2stgx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File: Stg2StgX.cpp
//
//  Contents: Wrapper object that takes an IStorage and makes it act like and ITransferDest
//
//  History:  18-July-2000 ToddB
//
//--------------------------------------------------------------------------

#include "shellprv.h"
#include "ids.h"
#pragma hdrstop

#include "isproc.h"
#include "ConfirmationUI.h"
#include "clsobj.h"

class CShellItem2TransferDest : public ITransferDest
{
public:
    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);

    // ITransferDest
    STDMETHOD(Advise)(ITransferAdviseSink *pAdvise, DWORD *pdwCookie);

    STDMETHOD(Unadvise)(DWORD dwCookie);

    STDMETHOD(OpenElement)(
        const WCHAR *pwcsName,
        STGXMODE      grfMode,
        DWORD       *pdwType,
        REFIID        riid,
        void       **ppunk);

    STDMETHOD(CreateElement)(
        const WCHAR *pwcsName,
        IShellItem *psiTemplate,
        STGXMODE      grfMode,
        DWORD         dwType,
        REFIID        riid,
        void       **ppunk);

    STDMETHOD(MoveElement)(
        IShellItem *psiItem,
        WCHAR       *pwcsNewName,    // Pointer to new name of element in destination
        STGXMOVE      grfOptions);    // Options (STGMOVEEX_ enum)

    STDMETHOD(DestroyElement)(
        const WCHAR *pwcsName,
        STGXDESTROY grfOptions);

    // commented out in the interface declaration
    STDMETHOD(RenameElement)(
        const WCHAR *pwcsOldName,
        const WCHAR *pwcsNewName);

    // CShellItem2TransferDest
    CShellItem2TransferDest();
    STDMETHOD(Init)(IShellItem *psi, IStorageProcessor *pEngine);

protected:
    LONG _cRef;
    IShellItem *_psi;
    ITransferAdviseSink  *_ptas;
    IStorageProcessor   *_pEngine;
    BOOL _fWebFolders;
    
    ~CShellItem2TransferDest();
    HRESULT _OpenHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD *pdwType, REFIID riid, void **ppunk);
    HRESULT _CreateHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD dwType, REFIID riid, void **ppunk);
    HRESULT _GetItemType(IShellItem *psi, DWORD *pdwType);
    HRESULT _BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv);
    BOOL _CanHardLink(LPCWSTR pszSourceName, LPCWSTR pszDestName);
    HRESULT _CopyStreamHardLink(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName);
    HRESULT _CopyStreamBits(IShellItem *psiSource, IShellItem *psiDest);
    HRESULT _CopyStreamWithOptions(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName, STGXMOVE grfOptions);
    BOOL _HasMultipleStreams(IShellItem *psiItem);
};

STDAPI CreateStg2StgExWrapper(IShellItem *psi, IStorageProcessor *pEngine, ITransferDest **pptd)
{
    if (!psi || !pptd)
        return E_INVALIDARG;

    *pptd = NULL;

    CShellItem2TransferDest *pobj = new CShellItem2TransferDest();
    if (!pobj)
        return E_OUTOFMEMORY;

    HRESULT hr = pobj->Init(psi, pEngine);
    if (SUCCEEDED(hr))
    {
        hr = pobj->QueryInterface(IID_PPV_ARG(ITransferDest, pptd));
    }

    pobj->Release();

    return hr;
}

CShellItem2TransferDest::CShellItem2TransferDest() : _cRef(1)
{
}

CShellItem2TransferDest::~CShellItem2TransferDest()
{
    if (_psi)
        _psi->Release();
        
    if (_pEngine)
        _pEngine->Release();
    
    if (_ptas)
        _ptas->Release();
}

HRESULT CShellItem2TransferDest::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CShellItem2TransferDest, ITransferDest),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItem2TransferDest::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItem2TransferDest::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

BOOL _IsWebfolders(IShellItem *psi);

STDMETHODIMP CShellItem2TransferDest::Init(IShellItem *psi, IStorageProcessor *pEngine)
{
    if (!psi)
        return E_INVALIDARG;

    if (_psi)
        return E_FAIL;

    _psi = psi;
    _psi->AddRef();
    _fWebFolders = _IsWebfolders(_psi);

    if (pEngine)
    {
        _pEngine = pEngine;
        _pEngine->AddRef();
    }

    return S_OK;
}

// ITransferDest
STDMETHODIMP CShellItem2TransferDest::Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie)
{
    if (!pAdvise || !pdwCookie)
        return E_INVALIDARG;

    if (_ptas)
        return E_FAIL;

    _ptas = pAdvise;
    *pdwCookie = 1;
    _ptas->AddRef();

    return S_OK;
}

STDMETHODIMP CShellItem2TransferDest::Unadvise(DWORD dwCookie)
{
    if (dwCookie != 1)
        return E_INVALIDARG;

    ATOMICRELEASE(_ptas);

    return S_OK;
}

HRESULT CShellItem2TransferDest::_GetItemType(IShellItem *psi, DWORD *pdwType)
{
    *pdwType = STGX_TYPE_ANY;
    
    SFGAOF flags = SFGAO_STORAGE | SFGAO_STREAM;
    if (SUCCEEDED(psi->GetAttributes(flags, &flags)) && (flags & (SFGAO_STORAGE | SFGAO_STREAM)))
        *pdwType = flags & SFGAO_STREAM ? STGX_TYPE_STREAM : STGX_TYPE_STORAGE;

    return S_OK;
}

HRESULT CShellItem2TransferDest::_OpenHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD *pdwType, REFIID riid, void **ppunk)
{
    *ppunk = NULL;

    IShellItem *psiTemp = NULL;
    HRESULT hr = SHCreateShellItemFromParent(_psi, pwcsName, &psiTemp);
    if (SUCCEEDED(hr))
    {
        // make sure this actually exists

        SFGAOF flags = SFGAO_VALIDATE;
        hr = psiTemp->GetAttributes(flags, &flags);
    }
    
    if (SUCCEEDED(hr))
    {
        DWORD dwTemp;
        if (!pdwType)
            pdwType = &dwTemp;
        
        _GetItemType(psiTemp, pdwType);

        hr = psiTemp->QueryInterface(riid, ppunk);
        if (FAILED(hr))
        {
            hr = _BindToHandlerWithMode(psiTemp, grfMode, riid, ppunk);
            if (FAILED(hr) && IsEqualIID(riid, IID_ITransferDest) && *pdwType == STGX_TYPE_STORAGE)
                hr = CreateStg2StgExWrapper(psiTemp, _pEngine, (ITransferDest**)ppunk);
        }
    }

    if (psiTemp)
        psiTemp->Release();
    
    return hr;
}

HRESULT CShellItem2TransferDest::_CreateHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD dwType, REFIID riid, void **ppunk)
{ 
    *ppunk = NULL;

    IStorage *pstg;
    HRESULT hr = _BindToHandlerWithMode(_psi, grfMode, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        if (STGX_TYPE_STORAGE == dwType)
        {
            IStorage *pstgTemp;
            hr = pstg->CreateStorage(pwcsName, grfMode, 0, 0, &pstgTemp);
            if (SUCCEEDED(hr))
            {
                hr = pstgTemp->Commit(STGC_DEFAULT);
                if (SUCCEEDED(hr))
                {
                    hr = pstgTemp->QueryInterface(riid, ppunk);
                    ATOMICRELEASE(pstgTemp); //need to close first in case someone has exclusive lock.  Do we need to worry about delete on release?
                    if (FAILED(hr))
                        hr = _OpenHelper(pwcsName, grfMode, &dwType, riid, ppunk);
                }

                if (pstgTemp)
                    pstgTemp->Release();
            }
        }
        else if (STGX_TYPE_STREAM == dwType)
        {
            IStream *pstm;
            hr = pstg->CreateStream(pwcsName, grfMode, 0, 0, &pstm);
            if (SUCCEEDED(hr))
            {
                hr = pstm->Commit(STGC_DEFAULT);
                if (SUCCEEDED(hr))
                {
                    hr = pstm->QueryInterface(riid, ppunk);
                    ATOMICRELEASE(pstm); //need to close first in case someone has exclusive lock.  Do we need to worry about delete on release?
                    if (FAILED(hr))
                        hr = _OpenHelper(pwcsName, grfMode, &dwType, riid, ppunk);
                }

                if (pstm)
                    pstm->Release();
            }
        }
        pstg->Release();
    }

    return hr;
}

STDMETHODIMP CShellItem2TransferDest::OpenElement(const WCHAR *pwcsName, STGXMODE grfMode, DWORD *pdwType, REFIID riid, void **ppunk)
{
    if (!pwcsName || !pdwType || !ppunk)
        return E_INVALIDARG;

    if (!_psi)
        return E_FAIL;

    DWORD dwFlags = grfMode & ~(STGX_MODE_CREATIONMASK);
    return _OpenHelper(pwcsName, dwFlags, pdwType, riid, ppunk);
}

STDMETHODIMP CShellItem2TransferDest::CreateElement(const WCHAR *pwcsName, IShellItem *psiTemplate, STGXMODE grfMode, DWORD dwType, REFIID riid, void **ppunk)
{
    if (!ppunk)
        return E_INVALIDARG;

    *ppunk = NULL;
    
    if (!pwcsName)
        return E_INVALIDARG;

    if (!_psi)
        return E_FAIL;
    
    DWORD dwFlags = grfMode & ~(STGX_MODE_CREATIONMASK);
    DWORD dwExistingType = STGX_TYPE_ANY;
    IShellItem *psi;
    HRESULT hr = _OpenHelper(pwcsName, dwFlags, &dwExistingType, IID_PPV_ARG(IShellItem, &psi));
    
    if (grfMode & STGX_MODE_FAILIFTHERE)
        dwFlags |= STGM_FAILIFTHERE;
    else
        dwFlags |= STGM_CREATE;

    if (SUCCEEDED(hr))
    {
        if (grfMode & STGX_MODE_OPENEXISTING)
        {
            ATOMICRELEASE(psi);
            hr = _OpenHelper(pwcsName, dwFlags, &dwType, riid, ppunk);
            if (FAILED(hr))
                hr = STGX_E_INCORRECTTYPE;
        }
        else if (grfMode & STGX_MODE_FAILIFTHERE)
        {
            hr = STG_E_FILEALREADYEXISTS;
        }
        else
        {
            // release the open handle on the element
            ATOMICRELEASE(psi);
            // destroy the element
            DestroyElement(pwcsName, grfMode & STGX_MODE_FORCE ? STGX_DESTROY_FORCE : 0);
            // dont keep hr from destroyelement because in certain storages (mergedfolder
            // for cd burning) the destroy will try to delete the one on the cd, that'll
            // fail, but the create will still succeed in the staging area.  at this point
            // we're already committed to overwriting the element so if _CreateHelper can
            // succeed with the STGM_CREATE flag if destroy fails, then more power to it.
            hr = _CreateHelper(pwcsName, dwFlags, dwType, riid, ppunk);
        }

        if (psi)
            psi->Release();
    }
    else
    {
        hr = _CreateHelper(pwcsName, dwFlags, dwType, riid, ppunk);
    }

    return hr;
}

HRESULT CShellItem2TransferDest::_BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv)
{
    IBindCtx *pbc;
    HRESULT hr = BindCtx_CreateWithMode(grfMode, &pbc); // need to translate mode flags?
    if (SUCCEEDED(hr))
    {
        GUID bhid;

        if (IsEqualGUID(riid, IID_IStorage))
            bhid = BHID_Storage;
        else if (IsEqualGUID(riid, IID_IStream))
            bhid = BHID_Stream;
        else
            bhid = BHID_SFObject;
        
        hr = psi->BindToHandler(pbc, bhid, riid, ppv);
        pbc->Release();
    }

    return hr;
}

#define NT_FAILED(x) NT_ERROR(x)   // More consistent name for this macro

BOOL CShellItem2TransferDest::_HasMultipleStreams(IShellItem *psiItem)
{
    BOOL fReturn = FALSE;
    LPWSTR pszPath;
    if (SUCCEEDED(psiItem->GetDisplayName(SIGDN_FILESYSPATH, &pszPath)))
    {
        DWORD dwType;
        _GetItemType(psiItem, &dwType);

        BOOL fIsADir = (STGX_TYPE_STORAGE == dwType);

        // Covert the conventional paths to UnicodePath descriptors
        
        UNICODE_STRING UnicodeSrcObject;
        if (NT_SUCCESS(RtlInitUnicodeStringEx(&UnicodeSrcObject, pszPath)))
        {
            if (RtlDosPathNameToNtPathName_U(pszPath, &UnicodeSrcObject, NULL, NULL))
            {
                // Build an NT object descriptor from the UnicodeSrcObject

                OBJECT_ATTRIBUTES SrcObjectAttributes;
                InitializeObjectAttributes(&SrcObjectAttributes,  &UnicodeSrcObject, OBJ_CASE_INSENSITIVE, NULL, NULL);

                // Open the file for generic read, and the dest path for attribute read

                IO_STATUS_BLOCK IoStatusBlock;
                HANDLE SrcObjectHandle = INVALID_HANDLE_VALUE;
                NTSTATUS NtStatus = NtOpenFile(&SrcObjectHandle, FILE_GENERIC_READ, &SrcObjectAttributes,
                                      &IoStatusBlock, FILE_SHARE_READ, (fIsADir ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE));
                if (NT_SUCCESS(NtStatus))
                {
                    // pAttributeInfo will point to enough stack to hold the
                    // FILE_FS_ATTRIBUTE_INFORMATION and worst-case filesystem name

                    size_t cbAttributeInfo = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + MAX_PATH * sizeof(TCHAR);
                    PFILE_FS_ATTRIBUTE_INFORMATION  pAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) _alloca(cbAttributeInfo);

                    NtStatus = NtQueryVolumeInformationFile(
                                    SrcObjectHandle,
                                    &IoStatusBlock,
                                    (BYTE *) pAttributeInfo,
                                    cbAttributeInfo,
                                    FileFsAttributeInformation
                                   );

                    if (NT_SUCCESS(NtStatus))
                    {
                        // If the source filesystem isn't NTFS, we can just bail now

                        pAttributeInfo->FileSystemName[ (pAttributeInfo->FileSystemNameLength / sizeof(WCHAR)) ] = L'\0';
                        if (0 != StrStrIW(pAttributeInfo->FileSystemName, L"NTFS"))
                        {
                            // Incrementally try allocation sizes for the ObjectStreamInformation,
                            // then retrieve the actual stream info

                            size_t cbBuffer = sizeof(FILE_STREAM_INFORMATION) + MAX_PATH * sizeof(WCHAR);
                            BYTE *pBuffer = (BYTE *) LocalAlloc(LPTR, cbBuffer);
                            if (pBuffer)
                            {
                                NtStatus = STATUS_BUFFER_OVERFLOW;
       
                                while (STATUS_BUFFER_OVERFLOW == NtStatus)
                                {
                                    BYTE * pOldBuffer = pBuffer;
                                    pBuffer = (BYTE *) LocalReAlloc(pBuffer, cbBuffer, LMEM_MOVEABLE);
                                    if (NULL == pBuffer)
                                    {
                                        pBuffer = pOldBuffer;  //we will free it at the end of the function
                                        break;
                                    }

                                    NtStatus = NtQueryInformationFile(SrcObjectHandle, &IoStatusBlock, pBuffer, cbBuffer, FileStreamInformation);
                                    cbBuffer *= 2;
                                }
                                
                                if (NT_SUCCESS(NtStatus))
                                {
                                    FILE_STREAM_INFORMATION * pStreamInfo = (FILE_STREAM_INFORMATION *) pBuffer;
                                    
                                    if (fIsADir)
                                    {
                                        // From experimentation, it seems that if there's only one stream on a directory and
                                        // it has a zero-length name, its a vanilla directory

                                        fReturn = ((0 != pStreamInfo->NextEntryOffset) && (0 == pStreamInfo->StreamNameLength));
                                    }
                                    else // File
                                    {
                                        // Single stream only if first stream has no next offset

                                        fReturn = ((0 != pStreamInfo->NextEntryOffset) && (pBuffer == (BYTE *) pStreamInfo));
                                    }
                                }
                                LocalFree(pBuffer);
                            }
                        }
                    }
                    NtClose(SrcObjectHandle);
                }
                RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
            }
        }
        CoTaskMemFree(pszPath);
    }
    return fReturn;
}

// needs to implement new name functionality
STDMETHODIMP CShellItem2TransferDest::MoveElement(IShellItem *psiItem, WCHAR *pwcsNewName, STGXMOVE grfOptions)
{
    if (!psiItem)
        return E_INVALIDARG;

    if (!_psi)
        return E_FAIL;

    HRESULT hr = STRESPONSE_CONTINUE;
    DWORD dwType;
    _GetItemType(psiItem, &dwType);

    if (_HasMultipleStreams(psiItem) && _ptas)
    {
        hr = _ptas->ConfirmOperation(psiItem, NULL, (STGX_TYPE_STORAGE == dwType) ? STCONFIRM_STREAM_LOSS_STORAGE : STCONFIRM_STREAM_LOSS_STREAM, NULL);
    }

    if (STRESPONSE_CONTINUE == hr)
    {
        LPWSTR pszOldName;
        hr = psiItem->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszOldName);
        if (SUCCEEDED(hr))
        {
            // we want to merge folders and replace files
            STGXMODE grfMode = STGX_TYPE_STORAGE == dwType ? STGX_MODE_WRITE | STGX_MODE_OPENEXISTING : STGX_MODE_WRITE | STGX_MODE_FAILIFTHERE;
            LPWSTR pszName = pwcsNewName ? pwcsNewName : pszOldName;
            BOOL fRepeat;
            do
            {
                fRepeat = FALSE;
                
                IShellItem *psiTarget;
                hr = CreateElement(pszName, psiItem, grfMode, dwType, IID_PPV_ARG(IShellItem, &psiTarget));
                if (SUCCEEDED(hr))
                {
                    if (STGX_TYPE_STORAGE == dwType)
                    {
                        if (!(grfOptions & STGX_MOVE_NORECURSION))
                        {
                            if (_pEngine)
                            {
                                IEnumShellItems *penum;
                                hr = psiItem->BindToHandler(NULL, BHID_StorageEnum, IID_PPV_ARG(IEnumShellItems, &penum));
                                if (SUCCEEDED(hr))
                                {
                                    STGOP stgop;
                                    if (grfOptions & STGX_MOVE_PREFERHARDLINK)
                                    {
                                        stgop = STGOP_COPY_PREFERHARDLINK;
                                    }
                                    else
                                    {
                                        stgop = (grfOptions & STGX_MOVE_COPY) ? STGOP_COPY : STGOP_MOVE;
                                    }
                                    hr = _pEngine->Run(penum, psiTarget, stgop, STOPT_NOSTATS);
                                    penum->Release();
                                }
                            }
                            else
                            {
                                hr = STGX_E_CANNOTRECURSE;
                            }
                        }
                    }
                    else if (STGX_TYPE_STREAM == dwType)
                    {
                        // this one is easy, create the destination stream and then call our stream copy helper function
                        // Use the stream copy helper that gives us progress
                        hr = _CopyStreamWithOptions(psiItem, psiTarget, pszName, grfOptions);

                        // in the failure case, delete the file we just created (it might be 0 bytes or incomplete).
                        // if we moved a tree of files, leave it since we're just worried about incomplete streams.
                        if (FAILED(hr))
                        {
                            DestroyElement(pszName, STGX_DESTROY_FORCE);
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }

                if (SUCCEEDED(hr) && !(grfOptions & STGX_MOVE_COPY))
                {
                    // in order to do a move we "copy" and then "delete"
                    IShellItem *psiSource;
                    hr = psiItem->GetParent(&psiSource);
                    if (SUCCEEDED(hr))
                    {
                        IStorage *pstgSource;
                        hr = _BindToHandlerWithMode(psiSource, STGX_MODE_WRITE, IID_PPV_ARG(IStorage, &pstgSource));
                        if (SUCCEEDED(hr))
                        {
                            hr = pstgSource->DestroyElement(pszName);
                            pstgSource->Release();
                        }
                        psiSource->Release();
                    }
                }

                if (FAILED(hr) && _ptas)
                {
                    HRESULT hrConfirm = E_FAIL;
                    CUSTOMCONFIRMATION cc = {sizeof(cc)};
                    STGTRANSCONFIRMATION stc = GUID_NULL;
                    UINT idDesc = 0, idTitle = 0;
                    BOOL fConfirm = FALSE;
                    
                    switch (hr)
                    {
                    case STG_E_FILEALREADYEXISTS:
                        ASSERT(STGX_TYPE_STREAM == dwType);
                        hrConfirm = _OpenHelper(pszName, STGX_MODE_READ, NULL, IID_PPV_ARG(IShellItem, &psiTarget));
                        if (SUCCEEDED(hrConfirm))
                        {
                            hrConfirm = _ptas->ConfirmOperation(psiItem, psiTarget, STCONFIRM_REPLACE_STREAM, NULL);
                        }
                        break;

                    case STRESPONSE_CANCEL:
                        break;

                    case STG_E_MEDIUMFULL:
                        fConfirm = TRUE;
                        cc.dwButtons = CCB_OK;
                        idDesc = IDS_REASONS_NODISKSPACE;
                        break;

                    // this is just for CD burning case
                    case HRESULT_FROM_WIN32(E_ACCESSDENIED):
                    case STG_E_ACCESSDENIED:
                        stc = STCONFIRM_ACCESS_DENIED;
                        // fall through, so that we can have some kind of error in non CD case
                    default:
                        fConfirm = TRUE;
                        cc.dwFlags |= CCF_SHOW_SOURCE_INFO;
                        cc.dwButtons = CCB_RETRY_SKIP_CANCEL;
                        idTitle = (grfOptions & STGX_MOVE_COPY ? IDS_UNKNOWN_COPY_TITLE : IDS_UNKNOWN_MOVE_TITLE);
                        if (STGX_TYPE_STORAGE == dwType)
                        {
                            if (grfOptions & STGX_MOVE_COPY)
                            {
                                idDesc = IDS_UNKNOWN_COPY_FOLDER;
                            }
                            else
                            {
                                idDesc = IDS_UNKNOWN_MOVE_FOLDER;
                            }
                        }
                        else
                        {
                            if (grfOptions & STGX_MOVE_COPY)
                            {
                                idDesc = IDS_UNKNOWN_COPY_FILE;
                            }
                            else
                            {
                                idDesc = IDS_UNKNOWN_MOVE_FILE;
                            }
                        }
                        break;
                    }

                    if (fConfirm)
                    {
                        if (idTitle == 0)
                            idTitle = IDS_DEFAULTTITLE;
                            
                        ASSERT(idDesc != 0);
                        cc.pwszDescription = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idDesc);
                        if (cc.pwszDescription)
                        {
                            cc.pwszTitle = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idTitle);
                            if (cc.pwszTitle)
                            {
                                cc.dwFlags |= CCF_USE_DEFAULT_ICON;
                                hrConfirm = _ptas->ConfirmOperation(psiItem, psiTarget, stc, &cc);
                                LocalFree(cc.pwszTitle);
                            }
                            LocalFree(cc.pwszDescription);
                        }
                    }

                    switch (hrConfirm)
                    {
                    case STRESPONSE_CONTINUE:
                    case STRESPONSE_RETRY:
                        if (STRESPONSE_RETRY == hrConfirm || STG_E_FILEALREADYEXISTS == hr)
                        {
                            grfMode = STGX_MODE_WRITE | STGX_MODE_FORCE;
                            fRepeat = TRUE;
                        }
                        break;

                    case STRESPONSE_SKIP:
                        hr = S_FALSE;
                        break;

                    default:
                        // let hr propagate out of the function
                        break;
                    }
                }

                if (psiTarget)
                    psiTarget->Release();
            }
            while (fRepeat);

            CoTaskMemFree(pszOldName);
        }
    }

    return hr;
}

STDMETHODIMP CShellItem2TransferDest::DestroyElement(const WCHAR *pwcsName, STGXDESTROY grfOptions)
{
    if (!_psi)
        return E_FAIL;

    // TODO: Pre and post op, confirmations
    HRESULT hr = STRESPONSE_CONTINUE;
    
    if (!(grfOptions & STGX_DESTROY_FORCE) && _ptas)
    {
        DWORD dwType = STGX_TYPE_ANY;
        IShellItem *psi;
        hr = _OpenHelper(pwcsName, STGX_MODE_READ, &dwType, IID_PPV_ARG(IShellItem, &psi));
        if (SUCCEEDED(hr))
        {
            hr = _ptas->ConfirmOperation(psi, NULL,
                                      (STGX_TYPE_STORAGE == dwType) ? STCONFIRM_DELETE_STORAGE : STCONFIRM_DELETE_STREAM,
                                      NULL);
            psi->Release();
        }
    }

    if (STRESPONSE_CONTINUE == hr)
    {
        IStorage *pstg;
        hr = _BindToHandlerWithMode(_psi, STGX_MODE_WRITE, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            hr = pstg->DestroyElement(pwcsName);
            pstg->Release();
        }
    }

    return hr;
}

STDMETHODIMP CShellItem2TransferDest::RenameElement(const WCHAR *pwcsOldName, const WCHAR *pwcsNewName)
{
    if (!_psi)
        return E_FAIL;

    // TODO: Pre and post op, confirmations
    IStorage *pstg;
    HRESULT hr = _BindToHandlerWithMode(_psi, STGX_MODE_WRITE, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        hr = pstg->RenameElement(pwcsOldName, pwcsNewName);
        pstg->Release();
    }

    return hr;
}

STDAPI_(BOOL) IsFileDeletable(LPCTSTR pszFile); // bitbuck.c

BOOL CShellItem2TransferDest::_CanHardLink(LPCWSTR pszSourceName, LPCWSTR pszDestName)
{
    // this is not intended to catch invalid situations where we could be hard linking --
    // CreateHardLink already takes care of all removable media, non-NTFS, etc.
    // this is just to do a quick check before taking the cost of destroying and
    // recreating the file.
    // unfortunately due to architecture cleanliness we can't keep state of whether hard
    // links are possible for the whole copy, so we check on each element.
    BOOL fRet = FALSE;
    if (PathGetDriveNumber(pszSourceName) == PathGetDriveNumber(pszDestName))
    {
        TCHAR szRoot[MAX_PATH];
        StrCpyN(szRoot, pszSourceName, ARRAYSIZE(szRoot));
        TCHAR szFileSystem[20];
        if (PathStripToRoot(szRoot) &&
            GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, NULL, szFileSystem, ARRAYSIZE(szFileSystem)))
        {
            if (lstrcmpi(szFileSystem, TEXT("NTFS")) == 0)
            {
                // check if we have delete access on the file.  this will aid the user later
                // if they want to manage the files in the staging area for cd burning.
                // if not, then make a normal copy.
                if (IsFileDeletable(pszSourceName))
                {
                    fRet = TRUE;
                }
            }
        }
    }
    return fRet;
}

HRESULT CShellItem2TransferDest::_CopyStreamHardLink(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName)
{
    // sell out and go to filesystem
    LPWSTR pszSourceName;
    HRESULT hr = psiSource->GetDisplayName(SIGDN_FILESYSPATH, &pszSourceName);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszDestName;
        hr = psiDest->GetDisplayName(SIGDN_FILESYSPATH, &pszDestName);
        if (SUCCEEDED(hr))
        {
            if (_CanHardLink(pszSourceName, pszDestName))
            {
                // need to destroy the 0-byte file we created during our confirm overwrite probing
                DestroyElement(pszName, STGX_DESTROY_FORCE);        
                hr = CreateHardLink(pszDestName, pszSourceName, NULL) ? S_OK : E_FAIL;
                if (SUCCEEDED(hr))
                {
                    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszDestName, NULL);
                    _ptas->OperationProgress(STGOP_COPY, psiSource, psiDest, 1, 1);
                }
                else
                {
                    // we deleted it above and need to recreate it for the fallback of doing a normal copy
                    IUnknown *punkDummy;
                    if (SUCCEEDED(_CreateHelper(pszName, STGX_MODE_WRITE | STGX_MODE_FORCE, STGX_TYPE_STREAM, IID_PPV_ARG(IUnknown, &punkDummy))))
                    {
                        punkDummy->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
            CoTaskMemFree(pszDestName);
        }
        CoTaskMemFree(pszSourceName);
    }
    return hr;
}

HRESULT CShellItem2TransferDest::_CopyStreamWithOptions(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName, STGXMOVE grfOptions)
{
    HRESULT hr = E_FAIL;
    if (grfOptions & STGX_MOVE_PREFERHARDLINK)
    {
        hr = _CopyStreamHardLink(psiSource, psiDest, pszName);
    }

    if (FAILED(hr))
    {
        hr = _CopyStreamBits(psiSource, psiDest);
    }
    return hr;
}

HRESULT CShellItem2TransferDest::_CopyStreamBits(IShellItem *psiSource, IShellItem *psiDest)
{
    const ULONG maxbuf  = 1024*1024;    // max size we will ever use for a buffer
    const ULONG minbuf  = 1024;         // smallest buffer we will use

    void *pv = LocalAlloc(LPTR, minbuf);
    if (!pv)
        return E_OUTOFMEMORY;

    IStream *pstrmSource;
    HRESULT hr = _BindToHandlerWithMode(psiSource, STGM_READ | STGM_SHARE_DENY_WRITE, IID_PPV_ARG(IStream, &pstrmSource));
    if (SUCCEEDED(hr))
    {
        IStream *pstrmDest;
        hr = _BindToHandlerWithMode(psiDest, STGM_READWRITE, IID_PPV_ARG(IStream, &pstrmDest));
        if (SUCCEEDED(hr))
        {
            // we need the source size info so we can show progress
            STATSTG statsrc;
            hr = pstrmSource->Stat(&statsrc, STATFLAG_NONAME);
            if (SUCCEEDED(hr))
            {
                ULONG cbSizeToAlloc = minbuf;
                ULONG cbSizeAlloced = 0;
                ULONG cbToRead      = 0;
                ULONGLONG ullCurr   = 0;
                const ULONG maxms   = 2500;         // max time, in ms, we'd like between progress updates
                const ULONG minms   = 750;          // min time we'd like to be doing work between updates


                cbSizeAlloced       = cbSizeToAlloc;
                cbToRead            = cbSizeAlloced;
                DWORD dwmsBefore    = GetTickCount();

                // Read from source, write to dest, and update progress.  We start doing 1K at a time, and
                // so long as its taking us less than (minms) milliseconds per pass, we'll double the buffer
                // size.  If we go longer than (maxms) milliseconds, we'll cut our work in half.

                ULONG cbRead;
                ULONGLONG ullCur = 0;
                while (SUCCEEDED(hr = pstrmSource->Read(pv, cbToRead, &cbRead)) && cbRead)
                {
                    // Update the progress based on the bytes read so far

                    ullCur += cbRead;
                    hr = _ptas->OperationProgress(STGOP_COPY, psiSource, psiDest, statsrc.cbSize.QuadPart, ullCur);
                    if (FAILED(hr))
                        break;

                    // Write the bytes to the output stream

                    ULONG cbWritten = 0;
                    hr = pstrmDest->Write(pv, cbRead, &cbWritten);
                    if (FAILED(hr))
                        break;

                    DWORD dwmsAfter = GetTickCount();

                    // If we're going to fast or too slow, adjust the size of the buffer.  If we paused for user
                    // intervention we'll think we're slow, but we'll correct next pass

                    if (dwmsAfter - dwmsBefore < minms && cbSizeAlloced < maxbuf)
                    {
                        // We completed really quickly, so we should try to do more work next time.
                        // Try to grow the buffer.  If it fails, just go with the existing buffer.

                        if (cbToRead < cbSizeAlloced)
                        {
                            // Buffer already larger than work we're doing, so just bump up scheduled work

                            cbToRead = __min(cbToRead *2, cbSizeAlloced);
                        }
                        else
                        {
                            // Buffer maxed by current scheduled work, so increase its size

                            void *pvOld = pv;
                            cbSizeToAlloc = __min(cbSizeAlloced *2, maxbuf);
                            pv = LocalReAlloc((HLOCAL)pv, cbSizeToAlloc, LPTR);
                            if (!pv)
                                pv = pvOld; // Old pointer still valid
                            else
                                cbSizeAlloced = cbSizeToAlloc;
                            cbToRead = cbSizeAlloced;
                        }
                    }
                    else if (dwmsAfter - dwmsBefore > maxms && cbToRead > minbuf)
                    {   
                        cbToRead = __max(cbToRead / 2, minbuf);
                    }

                    dwmsBefore = GetTickCount();
                }
            }

            if (SUCCEEDED(hr))
                hr = pstrmDest->Commit(STGC_DEFAULT);
            
            pstrmDest->Release();
        }    
        pstrmSource->Release();
    }
    LocalFree(pv);
    
    // eventually we will read to the end of the file and get an S_FALSE, return S_OK
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\startpin.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "datautil.h"

#include "resource.h"       // main symbols
#include "cowsite.h"        // CObjectWithSite
#include "dpa.h"            // CDPA

class CStartMenuPin;

//
//  PINENTRY - A single entry in the pin list
//
//  The _liPos/_cbLink point back into the CPinList._pstmLink
//
class PINENTRY {
public:
    LPITEMIDLIST    _pidl;
    IShellLink *    _psl;           // a live IShellLink
    LARGE_INTEGER   _liPos;         // location of the shell link inside the stream
    DWORD           _cbSize;        // size of the buffer pointed to by _liPos

    HRESULT UpdateShellLink();

    void FreeShellLink()
    {
        _cbSize = 0;
        ATOMICRELEASE(_psl);
    }

    void Destruct()
    {
        ILFree(_pidl);
        FreeShellLink();
    }

    static BOOL DestroyCallback(PINENTRY *self, LPVOID)
    {
        self->Destruct();
        return TRUE;
    }
};

//
//  CPinList
//

class CPinList
{
public:
    CPinList() : _dsaEntries(NULL), _pstmLink(NULL) { }

    ~CPinList()
    {
        ATOMICRELEASE(_pstmLink);
        if (_dsaEntries)
        {
            _dsaEntries.DestroyCallbackEx(PINENTRY::DestroyCallback, (void *)NULL);
        }
    }

    BOOL    Initialize() { return _dsaEntries.Create(4); }
    HRESULT Load(CStartMenuPin *psmpin);
    HRESULT Save(CStartMenuPin *psmpin);

    int AppendPidl(LPITEMIDLIST pidl)
    {
        PINENTRY entry = { pidl };
        return _dsaEntries.AppendItem(&entry);
    }

    PINENTRY *GetItemPtr(int i) { return _dsaEntries.GetItemPtr(i); }


    HRESULT SaveShellLink(PINENTRY *pentry, IStream *pstm);
    HRESULT LoadShellLink(PINENTRY *pentry, IShellLink **ppsl);
    HRESULT UpdateShellLink(PINENTRY *pentry) { return pentry->UpdateShellLink(); }

    PINENTRY *FindPidl(LPCITEMIDLIST pidl, int *pi);
    HRESULT ReplacePidl(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew);

private:
    struct ILWRITEINFO {
        IStream *pstmPidlWrite;
        IStream *pstmLinkWrite;
        CPinList *ppl;
        HRESULT hr;
        LPITEMIDLIST rgpidl[20];    // Must match ARRAYSIZE(c_rgcsidlRelative)
    };
    static BOOL ILWriteCallback(PINENTRY *pentry, ILWRITEINFO *pwi);

    CDSA<PINENTRY>  _dsaEntries;    // The items themselves
    IStream *       _pstmLink;      // PINENTRY._liPos points into this stream

};

class ATL_NO_VTABLE CStartMenuPin
    : public IShellExtInit
    , public IContextMenu
    , public IStartMenuPin
    , public CObjectWithSite
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CStartMenuPin, &CLSID_StartMenuPin>
{
public:
    ~CStartMenuPin();

BEGIN_COM_MAP(CStartMenuPin)
    COM_INTERFACE_ENTRY(IShellExtInit)
    // Need to use COM_INTERFACE_ENTRY_IID for the interfaces
    // that don't have an idl
    COM_INTERFACE_ENTRY_IID(IID_IContextMenu, IContextMenu)
    COM_INTERFACE_ENTRY(IStartMenuPin)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

DECLARE_NO_REGISTRY()

    // *** IShellExtInit ***
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdto, HKEY hkProgID);

    // *** IContextMenu ***
    STDMETHODIMP  QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax);

    // *** IStartMenuPin ***
    STDMETHODIMP EnumObjects(IEnumIDList **ppenum);
    STDMETHODIMP Modify(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);
    STDMETHODIMP GetChangeCount(ULONG *pulOut);
    STDMETHODIMP IsPinnable(IDataObject *pdtobj, DWORD dwFlags, OPTIONAL LPITEMIDLIST *ppidl);
    STDMETHODIMP Resolve(HWND hwnd, DWORD dwFlags, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlResolved);

    // *** IObjectWithSite ***
    // Inherited from CObjectWithSite

public:
    HRESULT SetChangeCount(ULONG ul);

protected:

    BOOL _IsAcceptableTarget(LPCTSTR pszPath, DWORD dwAttrib, DWORD dwFlags);

    enum {
        IDM_PIN =   0,
        IDM_UNPIN = 1,
        IDM_MAX,
    };

    // These "seem" backwards, but remember: If the item is pinned,
    // then the command is "unpin".  If the item is unpinned, then
    // the command is "pin".
    inline void _SetPinned() { _idmPinCmd = IDM_UNPIN; }
    inline void _SetUnpinned() { _idmPinCmd = IDM_PIN; }
    inline BOOL _IsPinned() const { return _idmPinCmd != IDM_PIN; }
    inline BOOL _DoPin() const { return _idmPinCmd == IDM_PIN; }
    inline BOOL _DoUnpin() const { return _idmPinCmd != IDM_PIN; }
    inline UINT _GetMenuStringID() const
    {
        COMPILETIME_ASSERT(IDS_STARTPIN_UNPINME == IDS_STARTPIN_PINME + IDM_UNPIN);
        return IDS_STARTPIN_PINME + _idmPinCmd;
    }

    static BOOL ILFreeCallback(LPITEMIDLIST pidl, void *)
        { ILFree(pidl); return TRUE; }

    HRESULT _ShouldAddMenu(UINT uFlags);
    HRESULT _InitPinRegStream();
    BOOL _AddPathToDefaultPinList(CPinList *ppl, LPCTSTR pszPath);

protected:
    IDataObject *_pdtobj;
    UINT        _idmPinCmd;         // Which command did we add?

    LPITEMIDLIST _pidl;             // IContextMenu identity
};

#define REGSTR_PATH_STARTFAVS       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")
#define REGSTR_VAL_STARTFAVS        TEXT("Favorites")
#define REGSTR_VAL_STARTFAVCHANGES  TEXT("FavoritesChanges")
#define REGSTR_VAL_STARTFAVLINKS    TEXT("FavoritesResolve")

IStream *_OpenPinRegStream(DWORD grfMode)
{
    return SHOpenRegStream2(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_STARTFAVS, grfMode);
}

IStream *_OpenLinksRegStream(DWORD grfMode)
{
    return SHOpenRegStream2(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_STARTFAVLINKS, grfMode);
}

const LARGE_INTEGER c_li0 = { 0, 0 };
const ULARGE_INTEGER& c_uli0 = (ULARGE_INTEGER&)c_li0;

HRESULT IStream_GetPos(IStream *pstm, LARGE_INTEGER *pliPos)
{
    return pstm->Seek(c_li0, STREAM_SEEK_CUR, (ULARGE_INTEGER*)pliPos);
}

HRESULT IStream_Copy(IStream *pstmFrom, IStream *pstmTo, DWORD cb)
{
    ULARGE_INTEGER uliToCopy, uliCopied;
    uliToCopy.QuadPart = cb;
    HRESULT hr = pstmFrom->CopyTo(pstmTo, uliToCopy, NULL, &uliCopied);
    if (SUCCEEDED(hr) && uliToCopy.QuadPart != uliCopied.QuadPart)
    {
        hr = E_FAIL;
    }
    return hr;
}

class ATL_NO_VTABLE CStartMenuPinEnum
    : public IEnumIDList
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CStartMenuPinEnum>
{
public:
    ~CStartMenuPinEnum()
    {
        ATOMICRELEASE(_pstm);
    }

BEGIN_COM_MAP(CStartMenuPinEnum)
    COM_INTERFACE_ENTRY(IEnumIDList)
END_COM_MAP()

    /// *** IEnumIDList ***
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

private:
    HRESULT _NextPidlFromStream(LPITEMIDLIST *ppidl);
    HRESULT _InitPinRegStream();

private:
    HRESULT     _hrLastEnum;        // Result of last IEnumIDList::Next
    IStream *   _pstm;
};

CStartMenuPin::~CStartMenuPin()
{
    ILFree(_pidl);
    if (_pdtobj)
        _pdtobj->Release();
}

BOOL _IsLocalHardDisk(LPCTSTR pszPath)
{
    //  Reject CDs, floppies, network drives, etc.
    //
    int iDrive = PathGetDriveNumber(pszPath);
    if (iDrive < 0 ||                   // reject UNCs
        RealDriveType(iDrive, /* fOkToHitNet = */ FALSE) != DRIVE_FIXED) // reject slow media
    {
        return FALSE;
    }
    return TRUE;
}

BOOL CStartMenuPin::_IsAcceptableTarget(LPCTSTR pszPath, DWORD dwAttrib, DWORD dwFlags)
{
    //  Regitems ("Internet" or "Email" for example) are acceptable
    //  provided we aren't restricted to EXEs only.
    if (!(dwAttrib & SFGAO_FILESYSTEM))
    {
        return !(dwFlags & SMPINNABLE_EXEONLY);
    }

    //  Otherwise, it's a file.

    //  If requested, reject non-EXEs.
    //  (Like the Start Menu, we treat MSC files as if they were EXEs)
    if (dwFlags & SMPINNABLE_EXEONLY)
    {
        LPCTSTR pszExt = PathFindExtension(pszPath);
        if (StrCmpIC(pszExt, TEXT(".EXE")) != 0 &&
            StrCmpIC(pszExt, TEXT(".MSC")) != 0)
        {
            return FALSE;
        }
    }

    //  If requested, reject slow media
    if (dwFlags & SMPINNABLE_REJECTSLOWMEDIA)
    {
        if (!_IsLocalHardDisk(pszPath))
        {
            return FALSE;
        }

        // If it's a shortcut, then apply the same rule to the shortcut.
        if (PathIsLnk(pszPath))
        {
            BOOL fLocal = TRUE;
            IShellLink *psl;
            if (SUCCEEDED(LoadFromFile(CLSID_ShellLink, pszPath, IID_PPV_ARG(IShellLink, &psl))))
            {
                // IShellLink::GetPath returns S_FALSE if target is not a path
                TCHAR szPath[MAX_PATH];
                if (S_OK == psl->GetPath(szPath, ARRAYSIZE(szPath), NULL, 0))
                {
                    fLocal = _IsLocalHardDisk(szPath);
                }
                psl->Release();
            }
            if (!fLocal)
            {
                return FALSE;
            }
        }
    }

    //  All tests pass!

    return TRUE;

}

BOOL IsStartPanelOn()
{
    SHELLSTATE ss = { 0 };
    SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);

    return ss.fStartPanelOn;
}

HRESULT CStartMenuPin::IsPinnable(IDataObject *pdtobj, DWORD dwFlags, OPTIONAL LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_FALSE;

    LPITEMIDLIST pidlRet = NULL;

    if (pdtobj &&                                   // must have a data object
        !SHRestricted(REST_NOSMPINNEDLIST) &&       // cannot be restricted
        IsStartPanelOn())                           // start panel must be on
    {
        STGMEDIUM medium = {0};
        LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
        if (pida)
        {
            if (pida->cidl == 1)
            {
                pidlRet = IDA_FullIDList(pida, 0);
                if (pidlRet)
                {
                    DWORD dwAttr = SFGAO_FILESYSTEM;            // only SFGAO_FILESYSTEM is valid
                    TCHAR szPath[MAX_PATH];

                    if (SUCCEEDED(SHGetNameAndFlags(pidlRet, SHGDN_FORPARSING,
                                        szPath, ARRAYSIZE(szPath), &dwAttr)) &&
                        _IsAcceptableTarget(szPath, dwAttr, dwFlags))
                    {
                        hr = S_OK;
                    }
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }

    // Return pidlRet only if the call succeeded and the caller requested it
    if (hr != S_OK || !ppidl)
    {
        ILFree(pidlRet);
        pidlRet = NULL;
    }

    if (ppidl)
    {
        *ppidl = pidlRet;
    }

    return hr;

}

// Returns S_OK if should add, S_FALSE if not

HRESULT CStartMenuPin::_ShouldAddMenu(UINT uFlags)
{
    // "Pin" is never a default verb
    if (uFlags & CMF_DEFAULTONLY)
        return S_FALSE;

    HRESULT hr;

    // The context menu appears only for fast media
    //
    // If extended verbs are disabled, then show the menu only for EXEs

    DWORD dwFlags = SMPINNABLE_REJECTSLOWMEDIA;
    if (!(uFlags & CMF_EXTENDEDVERBS))
    {
        dwFlags |= SMPINNABLE_EXEONLY;
    }

    hr = IsPinnable(_pdtobj, dwFlags, &_pidl);

    if (S_OK == hr)
    {
        //  If we are enclosed inside a shortcut, change our identity to the
        //  enclosing shortcut.

        IPersistFile *ppf;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_LinkSite, IID_PPV_ARG(IPersistFile, &ppf))))
        {
            LPOLESTR pszFile = NULL;
            if (ppf->GetCurFile(&pszFile) == S_OK && pszFile)
            {
                // ILCreateFromPathEx turns %USERPROFILE%\Desktop\foo.lnk
                // into CSIDL_DESKTOP\foo.lnk for us.
                LPITEMIDLIST pidl;
                if (SUCCEEDED(ILCreateFromPathEx(pszFile, NULL, ILCFP_FLAG_NORMAL, &pidl, NULL)))
                if (pidl)
                {
                    ILFree(_pidl);
                    _pidl = pidl;
                    hr = S_OK;
                }
                CoTaskMemFree(pszFile);
            }
            ppf->Release();
        }
    }

    return hr;
}

// IShellExtInit::Initialize
HRESULT CStartMenuPin::Initialize(LPCITEMIDLIST, IDataObject *pdtobj, HKEY)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);    // just grab this guy
    return S_OK;
}

// IContextMenu::QueryContextMenu

HRESULT CStartMenuPin::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = _ShouldAddMenu(uFlags);
    if (S_OK == hr)
    {
        _SetUnpinned();

        //  Determine whether this item is already on the Start Page or not.
        IEnumIDList *penum;
        hr = EnumObjects(&penum);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            while (penum->Next(1, &pidl, NULL) == S_OK)
            {
                BOOL bSame = ILIsEqual(pidl, _pidl);
                ILFree(pidl);
                if (bSame)
                {
                    _SetPinned();
                    break;
                }
            }
            penum->Release();

            TCHAR szCommand[MAX_PATH];
            if (LoadString(g_hinst, _GetMenuStringID(), szCommand, ARRAYSIZE(szCommand)))
            {
                InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION,
                           idCmdFirst + _idmPinCmd, szCommand);
            }

            hr = ResultFromShort(IDM_MAX);
        }
    }
    return hr;
}

const LPCTSTR c_rgpszVerb[] =
{
    TEXT("pin"),                    // IDM_PIN
    TEXT("unpin"),                  // IDM_UNPIN
};

// *** IContextMenu::InvokeCommand

HRESULT CStartMenuPin::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    LPCMINVOKECOMMANDINFOEX picix = reinterpret_cast<LPCMINVOKECOMMANDINFOEX>(pici);
    HRESULT hr = E_INVALIDARG;
    UINT idmCmd;

    if (IS_INTRESOURCE(pici->lpVerb))
    {
        idmCmd = PtrToInt(pici->lpVerb);
    }
    else
    {
        // Convert the string to an ID (or out of range if invalid)
        LPCTSTR pszVerb;
#ifdef UNICODE
        WCHAR szVerb[MAX_PATH];
        if (pici->cbSize >= CMICEXSIZE_NT4 &&
            (pici->fMask & CMIC_MASK_UNICODE) &&
            picix->lpVerbW)
        {
            pszVerb = picix->lpVerbW;
        }
        else
        {
            SHAnsiToTChar(pici->lpVerb, szVerb, ARRAYSIZE(szVerb));
            pszVerb = szVerb;
        }
#else
        pszVerb = pici->lpVerb;
#endif
        for (idmCmd = 0; idmCmd < ARRAYSIZE(c_rgpszVerb); idmCmd++)
        {
            if (lstrcmpi(pszVerb, c_rgpszVerb[idmCmd]) == 0)
            {
                break;
            }
        }
    }

    if (idmCmd == _idmPinCmd)
    {
        if (_idmPinCmd == IDM_PIN)
        {
            hr = Modify(NULL, _pidl);
        }
        else
        {
            hr = Modify(_pidl, NULL);
        }
    }

    return hr;
}

// *** IContextMenu::GetCommandString

HRESULT CStartMenuPin::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
{
    TCHAR szBuf[MAX_PATH];
    LPCTSTR pszResult = NULL;

    switch (uType & ~GCS_UNICODE)
    {
    case GCS_VERBA:
        if (idCmd < ARRAYSIZE(c_rgpszVerb))
        {
            pszResult = c_rgpszVerb[idCmd];
        }
        break;

    case GCS_HELPTEXTA:
        if (idCmd < ARRAYSIZE(c_rgpszVerb))
        {
            COMPILETIME_ASSERT(IDS_STARTPIN_PINME_HELP + IDM_UNPIN == IDS_STARTPIN_UNPINME_HELP);
            if (LoadString(g_hinst, IDS_STARTPIN_PINME_HELP + (UINT)idCmd, szBuf, ARRAYSIZE(szBuf)))
            {
                pszResult = szBuf;
            }
        }
        break;
    }

    if (pszResult)
    {
        if (uType & GCS_UNICODE)
        {
            SHTCharToUnicode(pszResult, (LPWSTR)pszName, cchMax);
        }
        else
        {
            SHTCharToAnsi(pszResult, pszName, cchMax);
        }
        return S_OK;
    }

    return E_NOTIMPL;
}

PINENTRY *CPinList::FindPidl(LPCITEMIDLIST pidl, int *pi)
{
    for (int i = _dsaEntries.GetItemCount() - 1; i >= 0; i--)
    {
        PINENTRY *pentry = _dsaEntries.GetItemPtr(i);
        if (ILIsEqual(pentry->_pidl, pidl))
        {
            if (pi)
            {
                *pi = i;
            }
            return pentry;
        }
    }
    return NULL;
}

HRESULT CPinList::ReplacePidl(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew)
{
    int i;
    PINENTRY *pentry = FindPidl(pidlOld, &i);
    if (pentry)
    {
        if (pidlNew == NULL)            // Delete
        {
            pentry->Destruct();
            _dsaEntries.DeleteItem(i);
            return S_OK;
        }
        else
        if (IS_INTRESOURCE(pidlNew))    // Move
        {
            // Move the pidl from i to iPos
            PINENTRY entry = *pentry;
            int iPos = ((int)(INT_PTR)pidlNew) - 1;
            if (i < iPos)
            {
                // Moving down; others move up
                iPos--;
                // Must use MoveMemory because the memory blocks overlap
                MoveMemory(_dsaEntries.GetItemPtr(i),
                           _dsaEntries.GetItemPtr(i+1),
                           sizeof(PINENTRY) * (iPos-i));
            }
            else if (i > iPos)
            {
                // Moving up; others move down
                // Must use MoveMemory because the memory blocks overlap
                MoveMemory(_dsaEntries.GetItemPtr(iPos+1),
                           _dsaEntries.GetItemPtr(iPos),
                           sizeof(PINENTRY) * (i-iPos));
            }
            _dsaEntries.SetItem(iPos, &entry);
            return S_OK;
        }
        else                            // Replace
        {
            if (Pidl_Set(&pentry->_pidl, pidlNew))
            {
                // Failure to update the shell link is not fatal;
                // it just means we won't be able to repair the
                // shortcut if it breaks.
                pentry->UpdateShellLink();
                return S_OK;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
    }
    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

HRESULT CStartMenuPin::Modify(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo)
{
    HRESULT hr;

    if(SHRestricted(REST_NOSMPINNEDLIST))
        return E_ACCESSDENIED;

    // Remap pidls to logical pidls (change CSIDL_DESKTOPDIRECTORY
    // to CSIDL_DESKTOP, etc.) so we don't get faked out when people
    // access objects sometimes directly on the desktop and sometimes
    // via their full filesystem name.

    LPITEMIDLIST pidlFromFree = NULL;
    LPITEMIDLIST pidlToFree = NULL;

    if (!IS_INTRESOURCE(pidlFrom))
    {
        pidlFromFree = SHLogILFromFSIL(pidlFrom);
        if (pidlFromFree) {
            pidlFrom = pidlFromFree;
        }
    }

    if (!IS_INTRESOURCE(pidlTo))
    {
        pidlToFree = SHLogILFromFSIL(pidlTo);
        if (pidlToFree) {
            pidlTo = pidlToFree;
        }
    }

    CPinList pl;
    hr = pl.Load(this);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            if (pidlFrom)
            {
                hr = pl.ReplacePidl(pidlFrom, pidlTo);
            }
            else if (pidlTo)
            {
                LPITEMIDLIST pidl = ILClone(pidlTo);
                if (pidl)
                {
                    int iPos = pl.AppendPidl(pidl);
                    if (iPos >= 0)
                    {
                        // Failure to update the shell link is not fatal;
                        // it just means we won't be able to repair the
                        // shortcut if it breaks.
                        pl.GetItemPtr(iPos)->UpdateShellLink();
                    }
                    else
                    {
                        ILFree(pidl);
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // pidlFrom == pidlTo == NULL?  What does that mean?
                hr = E_INVALIDARG;
            }

            if (SUCCEEDED(hr))
            {
                hr = pl.Save(this);
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;             // could not create dpa
    }

    ILFree(pidlFromFree);
    ILFree(pidlToFree);

    return hr;
}

//
//  Find the pidl on the pin list and resolve the shortcut that
//  tracks it.
//
//  Returns S_OK if the pidl changed and was resolved.
//  Returns S_FALSE if the pidl did not change.
//  Returns an error if the Resolve failed.
//

HRESULT CStartMenuPin::Resolve(HWND hwnd, DWORD dwFlags, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlResolved)
{
    *ppidlResolved = NULL;

    if(SHRestricted(REST_NOSMPINNEDLIST))
        return E_ACCESSDENIED;

    // Remap pidls to logical pidls (change CSIDL_DESKTOPDIRECTORY
    // to CSIDL_DESKTOP, etc.) so we don't get faked out when people
    // access objects sometimes directly on the desktop and sometimes
    // via their full filesystem name.

    LPITEMIDLIST pidlFree = SHLogILFromFSIL(pidl);
    if (pidlFree) {
        pidl = pidlFree;
    }

    CPinList pl;
    HRESULT hr = pl.Load(this);
    if (SUCCEEDED(hr))
    {
        PINENTRY *pentry = pl.FindPidl(pidl, NULL);
        if (pentry)
        {
            IShellLink *psl;
            hr =  pl.LoadShellLink(pentry, &psl);
            if (SUCCEEDED(hr))
            {
                hr = psl->Resolve(hwnd, dwFlags);
                if (hr == S_OK)
                {
                    IPersistStream *pps;
                    hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
                    if (SUCCEEDED(hr))
                    {
                        if (pps->IsDirty() == S_OK)
                        {
                            LPITEMIDLIST pidlNew;
                            hr = psl->GetIDList(&pidlNew);
                            if (SUCCEEDED(hr) && hr != S_OK)
                            {
                                // GetIDList returns S_FALSE on failure...
                                hr = E_FAIL;
                            }
                            if (SUCCEEDED(hr))
                            {
                                ILFree(pentry->_pidl);
                                pentry->_pidl = pidlNew;
                                hr = SHILClone(pidlNew, ppidlResolved);
                            }
                        }
                        pps->Release();
                    }
                }
                else if (SUCCEEDED(hr))
                {
                    // S_FALSE means "cancelled by user"
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }
                psl->Release();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }

        if (hr == S_OK)
        {
            pl.Save(this); // if this fails, tough
        }

    }

    ILFree(pidlFree);

    return hr;
}

//
//  The target pidl has changed (or it's brand new).  Create an IShellLink
//  around it so we can resolve it later.
//
HRESULT PINENTRY::UpdateShellLink()
{
    ASSERT(_pidl);

    // Pitch the old link; it's useless now.
    FreeShellLink();

    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &_psl));
    if (SUCCEEDED(hr))
    {
        hr = _psl->SetIDList(_pidl);
        if (FAILED(hr))
        {
            FreeShellLink();        // pitch it; it's no good
        }
    }
    return hr;
}

HRESULT CPinList::SaveShellLink(PINENTRY *pentry, IStream *pstm)
{
    HRESULT hr;
    if (pentry->_psl)
    {
        // It's still in the form of an IShellLink.
        // Save it to the stream, then go back and update the size information.
        LARGE_INTEGER liPos, liPosAfter;
        DWORD cbSize = 0;
        IPersistStream *pps = NULL;
        if (SUCCEEDED(hr = IStream_GetPos(pstm, &liPos)) &&
            // Write a dummy DWORD; we will come back and patch it up later
            SUCCEEDED(hr = IStream_Write(pstm, &cbSize, sizeof(cbSize))) &&
            SUCCEEDED(hr = pentry->_psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps))))
        {
            if (SUCCEEDED(hr = pps->Save(pstm, TRUE)) &&
                SUCCEEDED(hr = IStream_GetPos(pstm, &liPosAfter)) &&
                SUCCEEDED(hr = pstm->Seek(liPos, STREAM_SEEK_SET, NULL)))
            {
                cbSize = liPosAfter.LowPart - liPos.LowPart - sizeof(DWORD);
                if (SUCCEEDED(hr = IStream_Write(pstm, &cbSize, sizeof(cbSize))) &&
                    SUCCEEDED(hr = pstm->Seek(liPosAfter, STREAM_SEEK_SET, NULL)))
                {
                    // Hooray!  All got saved okay
                }
            }
            pps->Release();
        }
    }
    else
    {
        // It's just a reference back into our parent stream; copy it
        if (SUCCEEDED(hr = IStream_Write(pstm, &pentry->_cbSize, sizeof(pentry->_cbSize))))
        {
            // If _cbSize == 0 then _pstmLink might be NULL, so guard against it
            if (pentry->_cbSize)
            {
                if (SUCCEEDED(hr = _pstmLink->Seek(pentry->_liPos, STREAM_SEEK_SET, NULL)) &&
                    SUCCEEDED(hr = IStream_Copy(_pstmLink, pstm, pentry->_cbSize)))
                {
                    // Hooray! All got saved okay
                }
            }
            else
            {
                // Entry was blank - nothing to do, vacuous success
            }
        }
    }
    return hr;
}

HRESULT CPinList::LoadShellLink(PINENTRY *pentry, IShellLink **ppsl)
{
    HRESULT hr;
    if (pentry->_psl)
    {
        hr = S_OK;              // We already have the link
    }
    else if (pentry->_cbSize == 0)
    {
        hr = E_FAIL;            // no link available
    }
    else
    {                           // gotta make it
        IPersistStream *pps;
        hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistStream, &pps));
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr = _pstmLink->Seek(pentry->_liPos, STREAM_SEEK_SET, NULL)) &&
                SUCCEEDED(hr = pps->Load(_pstmLink)) &&
                SUCCEEDED(hr = pps->QueryInterface(IID_PPV_ARG(IShellLink, &pentry->_psl))))
            {
                // woo-hoo! All got loaded okay
            }
            pps->Release();
        }
    }

    *ppsl = pentry->_psl;

    if (SUCCEEDED(hr))
    {
        pentry->_psl->AddRef();
        hr = S_OK;
    }

    return hr;
}


HRESULT CStartMenuPin::GetChangeCount(ULONG *pulOut)
{
    DWORD cb = sizeof(*pulOut);
    if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS,
                   REGSTR_VAL_STARTFAVCHANGES, NULL, pulOut, &cb) != ERROR_SUCCESS)
    {
        *pulOut = 0;
    }

    return S_OK;
}

HRESULT CStartMenuPin::SetChangeCount(ULONG ulChange)
{
    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS,
               REGSTR_VAL_STARTFAVCHANGES, REG_DWORD, &ulChange,
               sizeof(ulChange));

    return S_OK;
}

//
//  We scan this list in order, so if there is a CSIDL that is a subdirectory
//  of another CSIDL, we must put the subdirectory first.  For example,
//  CSIDL_PROGRAMS is typically a subdirectory of CSIDL_STARTMENU, so we
//  must put CSIDL_PROGRAMS first so we get the best match.
//
//  Furthermore, directories pinned items are more likely to be found in
//  should come before less popular directories.
//
const int c_rgcsidlRelative[] = {
    // Most common: Start Menu stuff
    CSIDL_PROGRAMS,                 // Programs must come before StartMenu
    CSIDL_STARTMENU,                // Programs must come before StartMenu

    // Next most common: My Documents stuff
    CSIDL_MYPICTURES,               // MyXxx must come before Personal
    CSIDL_MYMUSIC,                  // MyXxx must come before Personal
    CSIDL_MYVIDEO,                  // MyXxx must come before Personal
    CSIDL_PERSONAL,                 // MyXxx must come before Personal
    CSIDL_COMMON_PROGRAMS,          // Programs must come before StartMenu
    CSIDL_COMMON_STARTMENU,         // Programs must come before StartMenu

    // Next most common: Desktop stuff
    CSIDL_DESKTOPDIRECTORY,
    CSIDL_COMMON_DESKTOPDIRECTORY,

    // Next most common: Program files stuff
    CSIDL_PROGRAM_FILES_COMMON,     // ProgramFilesCommon must come before ProgramFiles
    CSIDL_PROGRAM_FILES,            // ProgramFilesCommon must come before ProgramFiles
    CSIDL_PROGRAM_FILES_COMMONX86,  // ProgramFilesCommon must come before ProgramFiles
    CSIDL_PROGRAM_FILESX86,         // ProgramFilesCommon must come before ProgramFiles

    // Other stuff (less common)
    CSIDL_APPDATA,
    CSIDL_COMMON_APPDATA,
    CSIDL_SYSTEM,
    CSIDL_SYSTEMX86,
    CSIDL_WINDOWS,
    CSIDL_PROFILE,                  // Must come after all other profile-relative directories
};

BOOL CPinList::ILWriteCallback(PINENTRY *pentry, ILWRITEINFO *pwi)
{
    BYTE csidl = CSIDL_DESKTOP;     // Assume nothing interesting
    LPITEMIDLIST pidlWrite = pentry->_pidl;  // Assume nothing interesting

    for (int i = 0; i < ARRAYSIZE(pwi->rgpidl); i++)
    {
        LPITEMIDLIST pidlT;
        if (pwi->rgpidl[i] &&
            (pidlT = ILFindChild(pwi->rgpidl[i], pentry->_pidl)))
        {
            csidl = (BYTE)c_rgcsidlRelative[i];
            pidlWrite = pidlT;
            break;
        }
    }

    if (SUCCEEDED(pwi->hr = IStream_Write(pwi->pstmPidlWrite, &csidl, sizeof(csidl))) &&
        SUCCEEDED(pwi->hr = IStream_WritePidl(pwi->pstmPidlWrite, pidlWrite)) &&
        SUCCEEDED(pwi->hr = pwi->ppl->SaveShellLink(pentry, pwi->pstmLinkWrite)))
    {
        // woo-hoo, all written successfully
    }

    return SUCCEEDED(pwi->hr);
}

#define CSIDL_END ((BYTE)0xFF)

HRESULT CPinList::Save(CStartMenuPin *psmpin)
{
    ILWRITEINFO wi;

    COMPILETIME_ASSERT(ARRAYSIZE(c_rgcsidlRelative) == ARRAYSIZE(wi.rgpidl));

    for (int i = 0; i < ARRAYSIZE(c_rgcsidlRelative); i++)
    {
        SHGetSpecialFolderLocation(NULL, c_rgcsidlRelative[i], &wi.rgpidl[i]);
    }

    wi.pstmPidlWrite = _OpenPinRegStream(STGM_WRITE);
    if (wi.pstmPidlWrite)
    {
        wi.pstmLinkWrite = _OpenLinksRegStream(STGM_WRITE);
        if (wi.pstmLinkWrite)
        {
            wi.hr = S_OK;
            wi.ppl = this;
            _dsaEntries.EnumCallbackEx(ILWriteCallback, &wi);

            if (SUCCEEDED(wi.hr))
            {
                BYTE csidlEnd = CSIDL_END;
                wi.hr = IStream_Write(wi.pstmPidlWrite, &csidlEnd, sizeof(csidlEnd));
            }

            if (FAILED(wi.hr))
            {
                wi.pstmPidlWrite->SetSize(c_uli0);
                wi.pstmLinkWrite->SetSize(c_uli0);
            }
            wi.pstmLinkWrite->Release();
        }
        wi.pstmPidlWrite->Release();
    }
    else
    {
        wi.hr = E_ACCESSDENIED; // Most common reason is lack of write permission
    }

    for (i = 0; i < ARRAYSIZE(c_rgcsidlRelative); i++)
    {
        ILFree(wi.rgpidl[i]);
    }

    // Bump the change count so people can detect and refresh
    ULONG ulChange;
    psmpin->GetChangeCount(&ulChange);
    psmpin->SetChangeCount(ulChange + 1);

    // Notify everyone that the pin list changed
    SHChangeDWORDAsIDList dwidl;
    dwidl.cb      = SIZEOF(dwidl) - SIZEOF(dwidl.cbZero);
    dwidl.dwItem1 = SHCNEE_PINLISTCHANGED;
    dwidl.dwItem2 = 0;
    dwidl.cbZero  = 0;

    SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH, (LPCITEMIDLIST)&dwidl, NULL);

    return wi.hr;
}

HRESULT CPinList::Load(CStartMenuPin *psmpin)
{
    HRESULT hr;

    if (Initialize())
    {
        IEnumIDList *penum;

        hr = psmpin->EnumObjects(&penum);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            while (penum->Next(1, &pidl, NULL) == S_OK)
            {
                if (AppendPidl(pidl) < 0)
                {
                    ILFree(pidl);
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            penum->Release();
        }

        if (SUCCEEDED(hr))
        {
            //
            //  Now read the persisted shortcuts.
            //
            _pstmLink = _OpenLinksRegStream(STGM_READ);
            if (_pstmLink)
            {
                for (int i = 0; i < _dsaEntries.GetItemCount(); i++)
                {
                    PINENTRY *pentry = _dsaEntries.GetItemPtr(i);
                    LARGE_INTEGER liSeek = { 0, 0 };
                    if (SUCCEEDED(hr = IStream_Read(_pstmLink, &liSeek.LowPart, sizeof(liSeek.LowPart))) && // read size
                        SUCCEEDED(hr = IStream_GetPos(_pstmLink, &pentry->_liPos)) &&  // read current pos
                        SUCCEEDED(hr = _pstmLink->Seek(liSeek, STREAM_SEEK_CUR, NULL))) // skip over link
                    {
                        pentry->_cbSize = liSeek.LowPart; // set this only on success
                    }
                    else
                    {
                        break;
                    }
                }
            }

            // If we encountered an error,
            // then throw all the shortcuts away because they are
            // probably corrupted.
            if (FAILED(hr))
            {
                for (int i = 0; i < _dsaEntries.GetItemCount(); i++)
                {
                    _dsaEntries.GetItemPtr(i)->FreeShellLink();
                }
            }

            // Problems reading the persisted shortcuts are ignored
            // since they are merely advisory.
            hr = S_OK;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//
//  Reading a pidl from a stream is a dangerous proposition because
//  a corrupted pidl can cause a shell extension to go haywire.
//
//  A pinned item is stored in the stream in the form
//
//  [byte:csidl] [dword:cbPidl] [size_is(cbPidl):pidl]
//
//  With the special csidl = -1 indicating the end of the list.
//
//  We use a byte for the csidl so a corrupted stream won't accidentally
//  pass "CSIDL_FLAG_CREATE" as a csidl to SHGetSpecialFolderLocation.

HRESULT CStartMenuPinEnum::_NextPidlFromStream(LPITEMIDLIST *ppidl)
{
    BYTE csidl;
    HRESULT hr = IStream_Read(_pstm, &csidl, sizeof(csidl));
    if (SUCCEEDED(hr))
    {
        if (csidl == CSIDL_END)
        {
            hr = S_FALSE;     // end of enumeration
        }
        else
        {
            LPITEMIDLIST pidlRoot;
            hr = SHGetSpecialFolderLocation(NULL, csidl, &pidlRoot);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = IStream_ReadPidl(_pstm, &pidl);
                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidlRoot, pidl, ppidl);
                    ILFree(pidl);
                }
                ILFree(pidlRoot);
            }
        }
    }

    return hr;
}

// *** IEnumIDList::Next

HRESULT CStartMenuPinEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr;

    ASSERT(celt > 0);

    // If there was an error or EOF on the last call to IEnumIDList::Next,
    // then that result is sticky.  Once an enumeration has errored, it stays
    // in the error state; once it has reached EOF, it stays at EOF.  The
    // only way to clear the state is to perform a Reset().

    if (_hrLastEnum != S_OK)
    {
        return _hrLastEnum;
    }

    if (!_pstm)
    {
        _pstm = _OpenPinRegStream(STGM_READ);
    }

    if (_pstm)
    {
        rgelt[0] = NULL;
        hr = _NextPidlFromStream(rgelt);
    }
    else
    {
        hr = S_FALSE;   // No stream therefore no items
    }

    if (pceltFetched)
    {
        *pceltFetched = hr == S_OK ? 1 : 0;
    }

    // Remember the return code for next time.  If an error occured or EOF,
    // then free the memory used for enumeration.
    _hrLastEnum = hr;
    if (_hrLastEnum != S_OK)
    {
        ATOMICRELEASE(_pstm);
    }
    return hr;
}

// *** IEnumIDList::Skip

HRESULT CStartMenuPinEnum::Skip(ULONG)
{
    return E_NOTIMPL;
}

// *** IEnumIDList::Reset

HRESULT CStartMenuPinEnum::Reset()
{
    _hrLastEnum = S_OK;
    ATOMICRELEASE(_pstm);
    return S_OK;
}


// *** IEnumIDList::Clone

STDMETHODIMP CStartMenuPinEnum::Clone(IEnumIDList **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

// *** IStartMenuPin::EnumObjects

STDMETHODIMP CStartMenuPin::EnumObjects(IEnumIDList **ppenum)
{
    _InitPinRegStream();

    *ppenum = NULL;
    return CStartMenuPinEnum::CreateInstance(ppenum);
}

STDAPI CStartMenuPin_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppunk)
{
    return CStartMenuPin::_CreatorClass::CreateInstance(punkOuter, riid, ppunk);
}

BOOL CStartMenuPin::_AddPathToDefaultPinList(CPinList *ppl, LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
    LPITEMIDLIST pidl;
    if (pszPath[0] && SUCCEEDED(SHParseDisplayName(pszPath, NULL, &pidl, 0, NULL)))
    {
        if(ppl->AppendPidl(pidl) >= 0)
        {
            fRet = TRUE;  // Success
        }
        else
        {
            ILFree(pidl);
        }
    }
    return fRet;
}

// *** IStartMenuPin::_InitPinRegStream
//
// If the pin list has not yet been created, then create a default one.
//

static LPCTSTR c_rgszDefaultPin[] = {
    TEXT("shell:::{2559a1f4-21d7-11d4-bdaf-00c04f60b9f0}"), // CLSID_AutoCMClientInet
    TEXT("shell:::{2559a1f5-21d7-11d4-bdaf-00c04f60b9f0}"), // CLSID_AutoCMClientMail
};

static LPCTSTR c_rgszDefaultServerPin[] = {
    TEXT("%ALLUSERSPROFILE%\\Start Menu\\Programs\\Administrative Tools\\Manage Your Server.lnk"),
    TEXT("%ALLUSERSPROFILE%\\Start Menu\\Programs\\Administrative Tools\\Server Management.lnk"),
    TEXT("%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Command Prompt.lnk"),
    TEXT("%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Windows Explorer.lnk")
};

HRESULT CStartMenuPin::_InitPinRegStream()
{
    HRESULT hr = S_OK;

    if(SHRestricted(REST_NOSMPINNEDLIST))
        return hr;  //Nothing to initialize.

    IStream *pstm = _OpenPinRegStream(STGM_READ);

    BOOL fEmpty = pstm == NULL || SHIsEmptyStream(pstm);
    ATOMICRELEASE(pstm);

    if (fEmpty)
    {
        //  Create a default pin list
        CPinList pl;

        // Do not call pl.Load() because that will recurse back into us!

        if (pl.Initialize())
        {
            if (IsOS(OS_SERVERADMINUI))
            {
                for (UINT ids = IDS_MSFT_SRVPIN_0; ids <= IDS_MSFT_SRVPIN_3; ids++)
                {

                    // Small business server is replacing the Manage Your Server link with a special
                    // Server Management link, just for SBS
                    if (IsOS(OS_SMALLBUSINESSSERVER))
                    {
                        if (ids == IDS_MSFT_SRVPIN_0)
                        {
                            continue;  // skip this one, we are using IDS_MSFT_SRVPIN_1 for SBS
                        }
                    }
                    else if (ids == IDS_MSFT_SRVPIN_1)
                    {
                        continue;  // This is the special SBS link, we don't use it for normal servers
                    }


                    // Special hack!  If running at less than 800x600, then skip the middle item (cmd.exe)
                    // This ensure that the Start Menu does not get truncated at low resolutions.
                    if (ids == IDS_MSFT_SRVPIN_2 && GetSystemMetrics(SM_CYSCREEN) < 600)
                    {
                        continue;       // skip it, screen res is too small
                    }

                    TCHAR szPath[MAX_PATH], szPathExpanded[MAX_PATH];
                    if (LoadString(HINST_THISDLL, ids, szPath, ARRAYSIZE(szPath)))
                    {
                        SHExpandEnvironmentStrings(szPath, szPathExpanded, ARRAYSIZE(szPathExpanded));
                        if (!_AddPathToDefaultPinList(&pl, szPathExpanded))
                        {
                            // FAILED with localized name. In the case of MUI, the file names are not translated,
                            // so we need to bind to the english names. Let's try that now
                            ASSERT(ids - IDS_MSFT_SRVPIN_0 < ARRAYSIZE(c_rgszDefaultServerPin));
                            if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), c_rgszDefaultServerPin[ids - IDS_MSFT_SRVPIN_0])))
                            {
                                SHExpandEnvironmentStrings(szPath, szPathExpanded, ARRAYSIZE(szPathExpanded));
                                _AddPathToDefaultPinList(&pl, szPathExpanded);
                            }
                        }
                    }
                }
            }
            else
            {
                for (int i = 0; i < ARRAYSIZE(c_rgszDefaultPin); i++)
                {
                    _AddPathToDefaultPinList(&pl, c_rgszDefaultPin[i]);
                }
            }

            hr = pl.Save(this);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\stgutil.h ===
#ifndef _STGUTIL_H_
#define _STGUTIL_H_

STDAPI StgCopyFileToStream(LPCTSTR pszSrc, IStream *pStream);
STDAPI StgBindToObject(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv);
STDAPI StgOpenStorageOnFolder(LPCTSTR pszFolder, DWORD grfFlags, REFIID riid, void **ppv);

#endif // _STGUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\stgenum.h ===
#ifndef __STGENUM_H__
#define __STGENUM_H__


// IEnumSTATSTG for CFSFolder's IStorage implementation.

class CFSFolderEnumSTATSTG : public IEnumSTATSTG
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumSTATSTG
    STDMETHOD(Skip)(ULONG celt)
        { return E_NOTIMPL; };
    STDMETHOD(Clone)(IEnumSTATSTG **ppenum)
        { return E_NOTIMPL; };
    STDMETHOD(Next)(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);
    STDMETHOD(Reset)();

protected:
    CFSFolderEnumSTATSTG(CFSFolder* psf);
    ~CFSFolderEnumSTATSTG();

private:
    LONG         _cRef;
    CFSFolder*   _pfsf;          // fs folder

    int          _cIndex;
    TCHAR        _szSearch[MAX_PATH];
    HANDLE       _hFindFile;

    friend CFSFolder;
};


#endif // __STGENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\thumbutil.h ===
STDAPI_(void) CalculateAspectRatio(const SIZE *prgSize, RECT *pRect);
STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits,
                                const SIZE *prgSize, RECT rect,
                                DWORD dwClrDepth, HPALETTE hPal, BOOL fOrigSize,
                                COLORREF clrBk, HBITMAP *phBmpThumbnail);
STDAPI_(BOOL) ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                           HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                           DWORD dwClrDepth, HPALETTE hpal, UINT uiSharpPct, BOOL fOrigImage);
STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal,
                                    const BITMAPINFO *pCurInfo, HBITMAP *phbmp, BITMAPINFO **pBMI, void **ppBits);
STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\stgutil.cpp ===
#include "shellprv.h"
#include "util.h"
#include "datautil.h"
#include "idlcomm.h"
#include "stgutil.h"
#include "ole2dup.h"


STDAPI StgCopyFileToStream(LPCTSTR pszSrc, IStream *pStream)
{
    IStream *pStreamSrc;
    DWORD grfModeSrc = STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE;
    HRESULT hr = SHCreateStreamOnFileEx(pszSrc, grfModeSrc, 0, FALSE, NULL, &pStreamSrc);

    if (SUCCEEDED(hr))
    {
        ULARGE_INTEGER ulMax = {-1, -1};
        hr = pStreamSrc->CopyTo(pStream, ulMax, NULL, NULL);
        pStreamSrc->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pStream->Commit(STGC_DEFAULT);
    }

    return hr;
}


STDAPI StgBindToObject(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv)
{
    IBindCtx *pbc;
    HRESULT hr = BindCtx_CreateWithMode(grfMode, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObjectEx(NULL, pidl, pbc, riid, ppv);

        pbc->Release();
    }
    return hr;
}


typedef HRESULT (WINAPI * PSTGOPENSTORAGEONHANDLE)(HANDLE,DWORD,void*,void*,REFIID,void**);

STDAPI SHStgOpenStorageOnHandle(HANDLE h, DWORD grfMode, void *res1, void *res2, REFIID riid, void **ppv)
{
    static PSTGOPENSTORAGEONHANDLE pfn = NULL;
    
    if (pfn == NULL)
    {
        HMODULE hmodOle32 = LoadLibraryA("ole32.dll");

        if (hmodOle32)
        {
            pfn = (PSTGOPENSTORAGEONHANDLE)GetProcAddress(hmodOle32, "StgOpenStorageOnHandle");
        }
    }

    if (pfn)
    {
        return pfn(h, grfMode, res1, res2, riid, ppv);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


STDAPI StgOpenStorageOnFolder(LPCTSTR pszFolder, DWORD grfFlags, REFIID riid, void **ppv)
{
    *ppv = NULL;

    DWORD dwDesiredAccess, dwShareMode, dwCreationDisposition;
    HRESULT hr = ModeToCreateFileFlags(grfFlags, FALSE, &dwDesiredAccess, &dwShareMode, &dwCreationDisposition);
    if (SUCCEEDED(hr))
    {
		// For IPropertySetStorage, we don't want to unnecessarily tie up access to the folder, if all
		// we're doing is dealing with property sets. The implementation of IPropertySetStorage for
		// NTFS files is defined so that the sharing/access only applies to the property set stream, not
		// it's other streams. So it makes sense to do a CreateFile on a folder with full sharing, while perhaps specifying
		// STGM_SHARE_EXCLUSIVE for the property set storage.
        if (riid == IID_IPropertySetStorage)
            dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        // FILE_FLAG_BACKUP_SEMANTICS to get a handle on the folder
        HANDLE h = CreateFile(pszFolder, dwDesiredAccess, dwShareMode, NULL, 
            dwCreationDisposition, FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE);
        if (INVALID_HANDLE_VALUE != h)
        {
            hr = SHStgOpenStorageOnHandle(h, grfFlags, NULL, NULL, riid, ppv);
            CloseHandle(h);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}


// various helper classes removed for security push -- if it gets RI'd back into Lab06 somehow
// and they're needed, just put em back.
// this includes a wrapper for docfile IStorages to make them play nice and a shortcut-storage
// which dereferences links on the fly.
// 
// gpease  05-MAR-2003
// If you do put them back, make sure the Release implementation is correct!
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\stream.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: stream.c
//
//  This file contains some of the stream support code that is used by
// the shell.  It also contains the shells implementation of a memory
// stream that is used by the cabinet to allow views to be serialized.
//
// History:
//  08-20-93 KurtE      Added header block and memory stream.
//
//---------------------------------------------------------------------------
#include "shellprv.h"


STDAPI_(IStream *) 
OpenRegStream(
    HKEY hkey, 
    LPCTSTR pszSubkey, 
    LPCTSTR pszValue, 
    DWORD grfMode)
{
    return SHOpenRegStream(hkey, pszSubkey, pszValue, grfMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\switchuserdialog.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: SwitchUserDialog.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements presentation of the Switch User dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

#include "shellprv.h"
#include "SwitchUserDialog.h"

#include <msginaexports.h>
#include <shlwapi.h>

#include "ids.h"
#include "tooltip.h"

#define DISPLAYMSG(x)   ASSERTMSG(false, x)

EXTERN_C    HINSTANCE   g_hinst;

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::CSwitchUserDialog
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process/DLL.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CSwitchUserDialog. This initializes member
//              variables and loads resources used by the dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

CSwitchUserDialog::CSwitchUserDialog (HINSTANCE hInstance) :
    _hInstance(hInstance),
    _hbmBackground(NULL),
    _hbmFlag(NULL),
    _hbmButtons(NULL),
    _hfntTitle(NULL),
    _hfntButton(NULL),
    _hpltShell(NULL),
    _lButtonHeight(0),
    _uiHoverID(0),
    _uiFocusID(0),
    _fSuccessfulInitialization(false),
    _fDialogEnded(false),
    _pTooltip(NULL)

{
    bool        fUse8BitDepth;
    HDC         hdcScreen;
    LOGFONT     logFont;
    char        szPixelSize[10];
    BITMAP      bitmap;

    TBOOL(SetRect(&_rcBackground, 0, 0, 0, 0));
    TBOOL(SetRect(&_rcFlag, 0, 0, 0, 0));
    TBOOL(SetRect(&_rcButtons, 0, 0, 0, 0));

    hdcScreen = GetDC(NULL);

    //  8-bit color?

    fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);

    //  Load the bitmaps.

    _hbmBackground = static_cast<HBITMAP>(LoadImage(_hInstance,
                                                    MAKEINTRESOURCE(fUse8BitDepth ? IDB_BACKGROUND_8 : IDB_BACKGROUND_24),
                                                    IMAGE_BITMAP,
                                                    0,
                                                    0,
                                                    LR_CREATEDIBSECTION));
    if ((_hbmBackground != NULL) && (GetObject(_hbmBackground, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcBackground, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
    }
    _hbmFlag = static_cast<HBITMAP>(LoadImage(_hInstance,
                                              MAKEINTRESOURCE(fUse8BitDepth ? IDB_FLAG_8 : IDB_FLAG_24),
                                              IMAGE_BITMAP,
                                              0,
                                              0,
                                              LR_CREATEDIBSECTION));
    if ((_hbmFlag != NULL) && (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcFlag, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
    }
    _hbmButtons = static_cast<HBITMAP>(LoadImage(_hInstance,
                                                 MAKEINTRESOURCE(IDB_BUTTONS),
                                                 IMAGE_BITMAP,
                                                 0,
                                                 0,
                                                 LR_CREATEDIBSECTION));
    if ((_hbmButtons != NULL) && (GetObject(_hbmButtons, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcButtons, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
        _lButtonHeight = bitmap.bmHeight / (BUTTON_GROUP_MAX * BUTTON_STATE_MAX);
    }

    //  Create fonts. Load the font name and size from resources.

    ZeroMemory(&logFont, sizeof(logFont));
    if (LoadStringA(_hInstance,
                    IDS_SWITCHUSER_TITLE_FACESIZE,
                    szPixelSize,
                    ARRAYSIZE(szPixelSize)) != 0)
    {
        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);
        if (LoadString(_hInstance,
                       IDS_SWITCHUSER_TITLE_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_MEDIUM;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntTitle = CreateFontIndirect(&logFont);
        }
    }

    ZeroMemory(&logFont, sizeof(logFont));
    if (LoadStringA(_hInstance,
                    IDS_SWITCHUSER_BUTTON_FACESIZE,
                    szPixelSize,
                    ARRAYSIZE(szPixelSize)) != 0)
    {
        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);
        if (LoadString(_hInstance,
                       IDS_SWITCHUSER_BUTTON_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_BOLD;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntButton = CreateFontIndirect(&logFont);
        }
    }

    //  Load the shell palette.

    _hpltShell = SHCreateShellPalette(hdcScreen);

    TBOOL(ReleaseDC(NULL, hdcScreen));

    //  Check for presence of all required resources.

    _fSuccessfulInitialization = ((_hfntTitle != NULL) &&
                                  (_hfntButton != NULL) &&
                                  (_hpltShell != NULL) &&
                                  (_hbmButtons != NULL) &&
                                  (_hbmFlag != NULL) &&
                                  (_hbmBackground != NULL));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::~CSwitchUserDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CSwitchUserDialog. Release used resources and
//              unregister the window class.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

CSwitchUserDialog::~CSwitchUserDialog (void)

{
    ASSERTMSG(_pTooltip == NULL, "_pTooltip not released in CSwitchUserDialog::~CSwitchUserDialog");

    //  Release everything we allocated/loaded.

    if (_hpltShell != NULL)
    {
        TBOOL(DeleteObject(_hpltShell));
        _hpltShell = NULL;
    }
    if (_hfntButton != NULL)
    {
        TBOOL(DeleteObject(_hfntButton));
        _hfntButton = NULL;
    }
    if (_hfntTitle != NULL)
    {
        TBOOL(DeleteObject(_hfntTitle));
        _hfntTitle = NULL;
    }
    if (_hbmButtons != NULL)
    {
        TBOOL(DeleteObject(_hbmButtons));
        _hbmButtons = NULL;
    }
    if (_hbmFlag != NULL)
    {
        TBOOL(DeleteObject(_hbmFlag));
        _hbmFlag = NULL;
    }
    if (_hbmBackground != NULL)
    {
        TBOOL(DeleteObject(_hbmBackground));
        _hbmBackground = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Show
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Presents the "Switch User" dialog to the user and returns the
//              result of the dialog back to the caller.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

DWORD   CSwitchUserDialog::Show (HWND hwndParent)

{
    INT_PTR     iResult;

    if (_fSuccessfulInitialization)
    {
        IUnknown    *pIUnknown;

        //  If no parent was given the create our own dimmed window.

        if (hwndParent == NULL)
        {
            if (FAILED(ShellDimScreen(&pIUnknown, &hwndParent)))
            {
                pIUnknown = NULL;
                hwndParent = NULL;
            }
        }
        else
        {
            pIUnknown = NULL;
        }

        //  Show the dialog and get a result.

        iResult = DialogBoxParam(_hInstance,
                                 MAKEINTRESOURCE(DLG_SWITCHUSER),
                                 hwndParent,
                                 CB_DialogProc,
                                 reinterpret_cast<LPARAM>(this));
        if (pIUnknown != NULL)
        {
            pIUnknown->Release();
        }
    }
    else
    {
        iResult = 0;
    }
    return(static_cast<DWORD>(iResult));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::PaintBitmap
//
//  Arguments:  hdcDestination  =   HDC to paint into.
//              prcDestination  =   RECT in HDC to paint into.
//              hbmSource       =   HBITMAP to paint.
//              prcSource       =   RECT from HBITMAP to paint from.
//
//  Returns:    <none>
//
//  Purpose:    Wraps blitting a bitmap.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//              2001-03-17  vtan        added source RECT for strip blitting
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::PaintBitmap (HDC hdcDestination, const RECT *prcDestination, HBITMAP hbmSource, const RECT *prcSource)

{
    HDC     hdcBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap != NULL)
    {
        bool        fEqualWidthAndHeight;
        int         iWidthSource, iHeightSource, iWidthDestination, iHeightDestination;
        int         iStretchBltMode;
        DWORD       dwLayout;
        HBITMAP     hbmSelected;
        RECT        rcSource;
        BITMAP      bitmap;

        if (prcSource == NULL)
        {
            if (GetObject(hbmSource, sizeof(bitmap), &bitmap) == 0)
            {
                bitmap.bmWidth = prcDestination->right - prcDestination->left;
                bitmap.bmHeight = prcDestination->bottom - prcDestination->top;
            }
            TBOOL(SetRect(&rcSource, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
            prcSource = &rcSource;
        }
        hbmSelected = static_cast<HBITMAP>(SelectObject(hdcBitmap, hbmSource));
        iWidthSource = prcSource->right - prcSource->left;
        iHeightSource = prcSource->bottom - prcSource->top;
        iWidthDestination = prcDestination->right - prcDestination->left;
        iHeightDestination = prcDestination->bottom - prcDestination->top;
        fEqualWidthAndHeight = (iWidthSource == iWidthDestination) && (iHeightSource == iHeightDestination);
        if (!fEqualWidthAndHeight)
        {
            iStretchBltMode = SetStretchBltMode(hdcDestination, HALFTONE);
        }
        else
        {
            iStretchBltMode = 0;
        }
        dwLayout = SetLayout(hdcDestination, LAYOUT_BITMAPORIENTATIONPRESERVED);
        TBOOL(TransparentBlt(hdcDestination,
                             prcDestination->left,
                             prcDestination->top,
                             iWidthDestination,
                             iHeightDestination,
                             hdcBitmap,
                             prcSource->left,
                             prcSource->top,
                             iWidthSource,
                             iHeightSource,
                             RGB(255, 0, 255)));
        (DWORD)SetLayout(hdcDestination, dwLayout);
        if (!fEqualWidthAndHeight)
        {
            (int)SetStretchBltMode(hdcDestination, iStretchBltMode);
        }
        (HGDIOBJ)SelectObject(hdcBitmap, hbmSelected);
        TBOOL(DeleteDC(hdcBitmap));
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::RemoveTooltip
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Removes the tooltip if present. This can be accessed from two
//              different threads so make sure that it's serialized.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::RemoveTooltip (void)

{
    CTooltip    *pTooltip;

    pTooltip = static_cast<CTooltip*>(InterlockedExchangePointer(reinterpret_cast<void**>(&_pTooltip), NULL));
    if (pTooltip != NULL)
    {
        delete pTooltip;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::FilterMetaCharacters
//
//  Arguments:  pszText     =   String to filter.
//
//  Returns:    <none>
//
//  Purpose:    Filters meta-characters from the given string.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::FilterMetaCharacters (TCHAR* pszText)

{
    TCHAR* pszSrc;
    TCHAR* pszDest = StrChr(pszText, TEXT('&'));

    if (pszDest)
    {
        pszSrc = pszDest + 1;

        // remove any '&' characters from the string
        while (*pszSrc != TEXT('\0'))
        {
            if (*pszDest != TEXT('&'))
            {
                *pszDest++ = *pszSrc++;
            }
            else
            {
                pszSrc++;
            }
        }

        pszDest = TEXT('\0');
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::EndDialog
//
//  Arguments:  hwnd        =   HWND of dialog.
//              iResult     =   Result to end dialog with.
//
//  Returns:    <none>
//
//  Purpose:    Removes the tool tip if present. Ends the dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::EndDialog (HWND hwnd, INT_PTR iResult)

{
    RemoveTooltip();

    //  Set the dialog end member variable here. This will cause the WM_ACTIVATE
    //  handler to ignore the deactivation associated with ending the dialog. If
    //  it doesn't ignore it then it thinks the dialog is being deactivated
    //  because another dialog is activating and ends the dialog with SHTDN_NONE.

    _fDialogEnded = true;
    TBOOL(::EndDialog(hwnd, iResult));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_BN_CLICKED
//
//  Arguments:  hwnd    =   HWND of dialog.
//              wID     =   ID of control.
//
//  Returns:    <none>
//
//  Purpose:    Handles clicks in the bitmap buttons and sets the return
//              result according to the button pressed.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_BN_CLICKED (HWND hwnd, WORD wID)

{
    switch (wID)
    {
        case IDCANCEL:
            EndDialog(hwnd, SHTDN_NONE);
            break;
        case IDC_BUTTON_SWITCHUSER:
            EndDialog(hwnd, SHTDN_DISCONNECT);
            break;
        case IDC_BUTTON_LOGOFF:
            EndDialog(hwnd, SHTDN_LOGOFF);
            break;
        default:
            break;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of this window.
//
//  Returns:    <none>
//
//  Purpose:    Handles WM_INITDIALOG message. Centre the dialog on the main
//              monitor. Subclass the buttons so that we can get hover state
//              correctly implemented.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_INITDIALOG (HWND hwnd)

{
    RECT    rc;

    //  Center the dialog on the main monitor.

    TBOOL(GetClientRect(hwnd, &rc));
    TBOOL(SetWindowPos(hwnd,
                       HWND_TOP,
                       (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2,
                       (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 3,
                       0,
                       0,
                       SWP_NOSIZE));

    //  Subclass buttons for tooltips and cursor control.

    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_SWITCHUSER), ButtonSubClassProc, IDC_BUTTON_SWITCHUSER, reinterpret_cast<DWORD_PTR>(this)));
    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_LOGOFF), ButtonSubClassProc, IDC_BUTTON_LOGOFF, reinterpret_cast<DWORD_PTR>(this)));

    //  Set the focus to the "Switch User" button.

    (HWND)SetFocus(GetDlgItem(hwnd, IDC_BUTTON_SWITCHUSER));
    _uiFocusID = IDC_BUTTON_SWITCHUSER;
    (LRESULT)SendMessage(hwnd, DM_SETDEFID, _uiFocusID, 0);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_DESTROY
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Removes the subclassing of the button windows and can do any
//              other clean up required in WM_DESTROY.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_DESTROY (HWND hwnd)

{
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_LOGOFF), ButtonSubClassProc, IDC_BUTTON_LOGOFF));
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_SWITCHUSER), ButtonSubClassProc, IDC_BUTTON_SWITCHUSER));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_ERASEBKGND
//
//  Arguments:  hwnd        =   HWND to erase.
//              hdcErase    =   HDC to paint.
//
//  Returns:    <none>
//
//  Purpose:    Erases the background.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_ERASEBKGND (HWND hwnd, HDC hdcErase)

{
    RECT    rc;

    TBOOL(GetClientRect(hwnd, &rc));
    PaintBitmap(hdcErase, &rc, _hbmBackground, &_rcBackground);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_PRINTCLIENT
//
//  Arguments:  hwnd        =   HWND to erase.
//              hdcErase    =   HDC to paint.
//              dwOptions   =   Options for drawing.
//
//  Returns:    <none>
//
//  Purpose:    Handles painting the client area for WM_PRINTCLIENT.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_PRINTCLIENT (HWND hwnd, HDC hdcPrint, DWORD dwOptions)

{
    if ((dwOptions & (PRF_ERASEBKGND | PRF_CLIENT)) != 0)
    {
        Handle_WM_ERASEBKGND(hwnd, hdcPrint);
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_ACTIVATE
//
//  Arguments:  hwnd        =   HWND to erase.
//              dwState     =   Activate state.
//
//  Returns:    <none>
//
//  Purpose:    Detects if this window is becoming inactive. In this case
//              end the dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_ACTIVATE (HWND hwnd, DWORD dwState)

{
    if ((WA_INACTIVE == dwState) && !_fDialogEnded)
    {
        EndDialog(hwnd, SHTDN_NONE);
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_DRAWITEM
//
//  Arguments:  hwnd    =   HWND of the parent window.
//              pDIS    =   DRAWITEMSTRUCT defining what to draw.
//
//  Returns:    <none>
//
//  Purpose:    Draws several aspects of the turn off dialog. It handles the
//              title text, the owner draw bitmap buttons, the text for the
//              bitmap buttons and the separator line.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_DRAWITEM (HWND hwnd, const DRAWITEMSTRUCT *pDIS)

{
    HPALETTE    hPaletteOld;
    HFONT       hfntSelected;
    int         iBkMode;
    COLORREF    colorText;
    RECT        rc;
    SIZE        size;
    TCHAR       szText[256];

    hPaletteOld = SelectPalette(pDIS->hDC, _hpltShell, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
    switch (pDIS->CtlID)
    {
        case IDC_BUTTON_SWITCHUSER:
        case IDC_BUTTON_LOGOFF:
        {
            int     iState, iGroup;

            //  Select the correct state index to use. Check for ODS_SELECTED first.
            //  Then check for hover or ODS_FOCUS. Otherwise use the rest state.

            if ((pDIS->itemState & ODS_SELECTED) != 0)
            {
                iState = BUTTON_STATE_DOWN;
            }
            else if ((_uiHoverID == pDIS->CtlID) || ((pDIS->itemState & ODS_FOCUS) != 0))
            {
                iState = BUTTON_STATE_HOVER;
            }
            else
            {
                iState = BUTTON_STATE_REST;
            }

            //  Now select the correct bitmap based on the state index.

            switch (pDIS->CtlID)
            {
                case IDC_BUTTON_SWITCHUSER:
                    iGroup = BUTTON_GROUP_SWITCHUSER;
                    break;
                case IDC_BUTTON_LOGOFF:
                    iGroup = BUTTON_GROUP_LOGOFF;
                    break;
                default:
                    iGroup = -1;
                    DISPLAYMSG("This should never be executed");
                    break;
            }
            if (iGroup >= 0)
            {
                RECT    rc;

                //  Calculate which part of the background to blit into the DC.
                //  Only blit the amount that's necessary to avoid excessive
                //  blitting. Once blitted then blit the button BMP. The blit
                //  uses msimg32!TransparentBlt with the magical magenta color.

                TBOOL(CopyRect(&rc, &_rcBackground));
                (int)MapWindowPoints(pDIS->hwndItem, hwnd, reinterpret_cast<POINT*>(&rc), sizeof(RECT) / sizeof(POINT));
                rc.right = rc.left + (_rcButtons.right - _rcButtons.left);
                rc.bottom = rc.top + _lButtonHeight;
                PaintBitmap(pDIS->hDC, &pDIS->rcItem, _hbmBackground, &rc);
                TBOOL(CopyRect(&rc, &_rcButtons));
                rc.top = ((iGroup * BUTTON_STATE_MAX) + iState) * _lButtonHeight;
                rc.bottom = rc.top + _lButtonHeight;
                PaintBitmap(pDIS->hDC, &pDIS->rcItem, _hbmButtons, &rc);
            }
            break;
        }
        case IDC_TITLE_FLAG:
        {
            BITMAP      bitmap;

            TBOOL(GetClientRect(pDIS->hwndItem, &rc));
            if (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) != 0)
            {
                rc.left += ((rc.right - rc.left) - bitmap.bmWidth) / 2;
                rc.right = rc.left + bitmap.bmWidth;
                rc.top += ((rc.bottom - rc.top) - bitmap.bmHeight) / 2;
                rc.bottom = rc.top + bitmap.bmHeight;
            }
            PaintBitmap(pDIS->hDC, &rc, _hbmFlag, &_rcFlag);
            break;
        }
        case IDC_TITLE_SWITCHUSER:
        {

            //  Draw the title of the dialog "Log Off Windows".

            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC, _hfntTitle));
            colorText = SetTextColor(pDIS->hDC, 0x00FFFFFF);
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, pDIS->CtlID), szText, ARRAYSIZE(szText));
            TBOOL(GetTextExtentPoint(pDIS->hDC, szText, lstrlen(szText), &size));
            TBOOL(CopyRect(&rc, &pDIS->rcItem));
            TBOOL(InflateRect(&rc, 0, -((rc.bottom - rc.top - size.cy) / 2)));
            (int)DrawText(pDIS->hDC, szText, -1, &rc, 0);
            (int)SetBkMode(pDIS->hDC, iBkMode);
            (COLORREF)SetTextColor(pDIS->hDC, colorText);
            (HGDIOBJ)SelectObject(pDIS->hDC, hfntSelected);
            break;
        }
        case IDC_TEXT_SWITCHUSER:
        case IDC_TEXT_LOGOFF:
        {
            int     iPixelHeight, iButtonID;
            RECT    rcText;

            //  The text to display is based on the button title. Map the static
            //  text ID to a "parent" button ID. Special case IDC_TEXT_STANDBY.

            switch (pDIS->CtlID)
            {
                case IDC_TEXT_SWITCHUSER:
                    iButtonID = IDC_BUTTON_SWITCHUSER;
                    break;
                case IDC_TEXT_LOGOFF:
                    iButtonID = IDC_BUTTON_LOGOFF;
                    break;
                default:
                    iButtonID = 0;
                    DISPLAYMSG("This should never be executed");
                    break;
            }
            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC, _hfntButton));
            colorText = SetTextColor(pDIS->hDC, RGB(255, 255, 255));
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, iButtonID), szText, ARRAYSIZE(szText));
            TBOOL(CopyRect(&rcText, &pDIS->rcItem));
            iPixelHeight = DrawText(pDIS->hDC, szText, -1, &rcText, DT_CALCRECT);
            TBOOL(CopyRect(&rc, &pDIS->rcItem));
            TBOOL(InflateRect(&rc, -((rc.right - rc.left - (rcText.right - rcText.left)) / 2), -((rc.bottom - rc.top - iPixelHeight) / 2)));
            (int)DrawText(pDIS->hDC, szText, -1, &rc, ((pDIS->itemState & ODS_NOACCEL ) != 0) ? DT_HIDEPREFIX : 0);
            (int)SetBkMode(pDIS->hDC, iBkMode);
            (COLORREF)SetTextColor(pDIS->hDC, colorText);
            (HGDIOBJ)SelectObject(pDIS->hDC, hfntSelected);
            break;
        }
        default:
        {
            DISPLAYMSG("Unknown control ID passed to CSwitchUserDialog::Handle_WM_DRAWITEM");
            break;
        }
    }
    (HGDIOBJ)SelectPalette(pDIS->hDC, hPaletteOld, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_COMMAND
//
//  Arguments:  hwnd    =   HWND of dialog.
//              wParam  =   WPARAM (see platform SDK under WM_COMMAND).
//
//  Returns:    <none>
//
//  Purpose:    Handles clicks in the bitmap buttons and sets the return
//              result according to the button pressed.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_COMMAND (HWND hwnd, WPARAM wParam)

{
    switch (HIWORD(wParam))
    {
        case BN_CLICKED:
            Handle_BN_CLICKED(hwnd, LOWORD(wParam));
            break;
        default:
            break;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_MOUSEMOVE
//
//  Arguments:  hwnd    =   HWND of the control.
//              uiID    =   ID of the control.
//
//  Returns:    <none>
//
//  Purpose:    Sets the cursor to a hand and tracks mouse movement in the
//              control. Refresh the control to show the hover state.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_MOUSEMOVE (HWND hwnd, UINT uiID)

{
    (HCURSOR)SetCursor(LoadCursor(NULL, IDC_HAND));
    if (uiID != _uiHoverID)
    {
        TRACKMOUSEEVENT     tme;

        _uiHoverID = uiID;
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_HOVER | TME_LEAVE;
        tme.hwndTrack = hwnd;
        tme.dwHoverTime = HOVER_DEFAULT;
        TBOOL(TrackMouseEvent(&tme));
        TBOOL(InvalidateRect(hwnd, NULL, FALSE));
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_MOUSEHOVER
//
//  Arguments:  hwnd    =   HWND of the control.
//              uiID    =   ID of the control.
//
//  Returns:    <none>
//
//  Purpose:    Handles hovering over the control. Determine which tooltip to
//              bring up and show it.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_MOUSEHOVER (HWND hwnd, UINT uiID)

{
    int     iTextID;

    switch (uiID)
    {
        case IDC_BUTTON_SWITCHUSER:
            iTextID = IDS_SWITCHUSER_TOOLTIP_TEXT_SWITCHUSER;
            break;
        case IDC_BUTTON_LOGOFF:
            iTextID = IDS_SWITCHUSER_TOOLTIP_TEXT_LOGOFF;
            break;
        default:
            iTextID = 0;
            break;
    }

    //  Construct the tooltip and show it.

    if (iTextID != 0)
    {
        TCHAR* pszCaption;
        DWORD cchCaption;

        cchCaption = GetWindowTextLength(hwnd) + 1; // +1 for null terminator
        pszCaption = (TCHAR*)LocalAlloc(LMEM_FIXED, cchCaption * sizeof(TCHAR));
        if (pszCaption)
        {
            if (GetWindowText(hwnd, pszCaption, cchCaption) != 0)
            {
                _pTooltip = new CTooltip(_hInstance, hwnd);
                if (_pTooltip != NULL)
                {
                    TCHAR szText[256];

                    if (LoadString(_hInstance, iTextID, szText + 2, ARRAYSIZE(szText) - 2) != 0)    // 2 for "\r\n"
                    {
                        FilterMetaCharacters(pszCaption);
                        szText[0] = TEXT('\r');
                        szText[1] = TEXT('\n');
                        _pTooltip->SetPosition();
                        _pTooltip->SetCaption(0, pszCaption);
                        _pTooltip->SetText(szText);
                        _pTooltip->Show();
                    }
                }
            }
            
            LocalFree(pszCaption);
        }
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_MOUSELEAVE
//
//  Arguments:  hwnd    =   HWND of the control.
//
//  Returns:    <none>
//
//  Purpose:    Removes the tooltip and clears the hover ID.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_MOUSELEAVE (HWND hwnd)

{
    RemoveTooltip();
    _uiHoverID = 0;
    TBOOL(InvalidateRect(hwnd, NULL, FALSE));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::CB_DialogProc
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    See the platform SDK under DialogProc.
//
//  Purpose:    Main DialogProc dispatch entry point for the turn off dialog.
//              To keep this simple it calls member functions.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CSwitchUserDialog::CB_DialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR             iResult;
    CSwitchUserDialog   *pThis;

    pThis = reinterpret_cast<CSwitchUserDialog*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CSwitchUserDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pThis));
            pThis->Handle_WM_INITDIALOG(hwnd);
            iResult = FALSE;
            break;
        case WM_DESTROY:
            pThis->Handle_WM_DESTROY(hwnd);
            iResult = 0;
            break;
        case WM_ERASEBKGND:
            pThis->Handle_WM_ERASEBKGND(hwnd, reinterpret_cast<HDC>(wParam));
            iResult = 1;
            break;
        case WM_PRINTCLIENT:
            pThis->Handle_WM_PRINTCLIENT(hwnd, reinterpret_cast<HDC>(wParam), static_cast<DWORD>(lParam));
            iResult = 1;        //  This tells the button that it was handled.
            break;
        case WM_ACTIVATE:
            pThis->Handle_WM_ACTIVATE(hwnd, static_cast<DWORD>(wParam));
            iResult = 1;
            break;
        case WM_DRAWITEM:
            pThis->Handle_WM_DRAWITEM(hwnd, reinterpret_cast<DRAWITEMSTRUCT*>(lParam));
            iResult = TRUE;
            break;
        case WM_COMMAND:
            pThis->Handle_WM_COMMAND(hwnd, wParam);
            iResult = 0;
            break;
        default:
            iResult = 0;
            break;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::ButtonSubClassProc
//
//  Arguments:  hwnd        =   See the platform SDK under WindowProc.
//              uMsg        =   See the platform SDK under WindowProc.
//              wParam      =   See the platform SDK under WindowProc.
//              lParam      =   See the platform SDK under WindowProc.
//              uiID        =   ID assigned at subclass time.
//              dwRefData   =   reference data assigned at subclass time.
//
//  Returns:    LRESULT
//
//  Purpose:    comctl32 subclass callback function. This allows the bitmap
//              buttons to hover and track accordingly. This also allows our
//              BS_OWNERDRAW buttons to be pushed when the keyboard is used.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    CSwitchUserDialog::ButtonSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData)

{
    LRESULT             lResult;
    CSwitchUserDialog   *pThis;

    pThis = reinterpret_cast<CSwitchUserDialog*>(dwRefData);
    switch (uMsg)
    {

        //  Do NOT allow BM_SETSTYLE to go thru to the default handler. This is
        //  because DLGC_UNDEFPUSHBUTTON is returned for WM_GETDLGCODE. When the
        //  dialog manager sees this it tries to set the focus style on the button.
        //  Even though it's owner drawn the button window proc still draws the
        //  focus state (because we returned DLGC_UNDEFPUSHBUTTON). Therefore to
        //  ensure the bitmap isn't over-painted by the button window proc blow off
        //  the BM_SETSTYLE and don't let it get to the button window proc.

        case BM_SETSTYLE:
            if (wParam == BS_DEFPUSHBUTTON)
            {
                pThis->_uiFocusID = static_cast<UINT>(uiID);
            }
            if (uiID != IDCANCEL)
            {
                lResult = 0;
                break;
            }
            //  Fall thru
        default:

            //  Otherwise in the default case let the default handler at the message
            //  first. This implements tail-patching.

            lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            switch (uMsg)
            {
                case DM_GETDEFID:
                    lResult = (DC_HASDEFID << 16) | static_cast<WORD>(pThis->_uiFocusID);
                    break;
                case WM_GETDLGCODE:
                    if (uiID == pThis->_uiFocusID)
                    {
                        lResult |= DLGC_DEFPUSHBUTTON;
                    }
                    else
                    {
                        lResult |= DLGC_UNDEFPUSHBUTTON;
                    }
                    break;
                case WM_MOUSEMOVE:
                    pThis->Handle_WM_MOUSEMOVE(hwnd, static_cast<UINT>(uiID));
                    break;
                case WM_MOUSEHOVER:
                    pThis->Handle_WM_MOUSEHOVER(hwnd, static_cast<UINT>(uiID));
                    break;
                case WM_MOUSELEAVE:
                    pThis->Handle_WM_MOUSELEAVE(hwnd);
                    break;
                default:
                    break;
            }
    }
    return(lResult);
}

EXTERN_C    DWORD   SwitchUserDialog_Show (HWND hwndParent)

{
    CSwitchUserDialog   switchUserDialog(g_hinst);

    return(switchUserDialog.Show(hwndParent));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\switchuserdialog.h ===
//  --------------------------------------------------------------------------
//  Module Name: SwitchUserDialog.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements presentation of the Switch User dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

#ifndef     _SwitchUserDialog_
#define     _SwitchUserDialog_

#ifdef      __cplusplus

#include "Tooltip.h"

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::CSwitchUserDialog
//
//  Purpose:    Implements the "Switch User Dialog" feature.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

class   CSwitchUserDialog
{
    private:
        enum
        {
            BUTTON_STATE_REST           =   0,
            BUTTON_STATE_DOWN,
            BUTTON_STATE_HOVER,
            BUTTON_STATE_MAX,

            BUTTON_GROUP_SWITCHUSER     =   0,
            BUTTON_GROUP_LOGOFF,
            BUTTON_GROUP_MAX
        };
    private:
                                            CSwitchUserDialog (void);
                                            CSwitchUserDialog (const CSwitchUserDialog& copyObject);
                const CSwitchUserDialog&    operator = (const CSwitchUserDialog& assignObject);
    public:
                                            CSwitchUserDialog (HINSTANCE hInstance);
                                            ~CSwitchUserDialog (void);

                DWORD                       Show (HWND hwndParent);
    private:
                void                        PaintBitmap (HDC hdcDestination, const RECT *prcDestination, HBITMAP hbmSource, const RECT *prcSource);
                void                        RemoveTooltip (void);
                void                        FilterMetaCharacters (TCHAR *pszText);
                void                        EndDialog (HWND hwnd, INT_PTR iResult);
                void                        Handle_BN_CLICKED (HWND hwnd, WORD wID);
                void                        Handle_WM_INITDIALOG (HWND hwnd);
                void                        Handle_WM_DESTROY (HWND hwnd);
                void                        Handle_WM_ERASEBKGND (HWND hwnd, HDC hdcErase);
                void                        Handle_WM_PRINTCLIENT (HWND hwnd, HDC hdcPrint, DWORD dwOptions);
                void                        Handle_WM_ACTIVATE (HWND hwnd, DWORD dwState);
                void                        Handle_WM_DRAWITEM (HWND hwnd, const DRAWITEMSTRUCT *pDIS);
                void                        Handle_WM_COMMAND (HWND hwnd, WPARAM wParam);
                void                        Handle_WM_MOUSEMOVE (HWND hwnd, UINT uiID);
                void                        Handle_WM_MOUSEHOVER (HWND hwnd, UINT uiID);
                void                        Handle_WM_MOUSELEAVE (HWND hwnd);
        static  INT_PTR     CALLBACK        CB_DialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  LRESULT     CALLBACK        ButtonSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData);
    private:
                const HINSTANCE             _hInstance;
                HBITMAP                     _hbmBackground;
                HBITMAP                     _hbmFlag;
                HBITMAP                     _hbmButtons;
                HFONT                       _hfntTitle;
                HFONT                       _hfntButton;
                HPALETTE                    _hpltShell;
                RECT                        _rcBackground;
                RECT                        _rcFlag;
                RECT                        _rcButtons;
                LONG                        _lButtonHeight;
                UINT                        _uiHoverID;
                UINT                        _uiFocusID;
                bool                        _fSuccessfulInitialization;
                bool                        _fDialogEnded;
                CTooltip*                   _pTooltip;
};

#endif  /*  __cplusplus     */

EXTERN_C    DWORD   SwitchUserDialog_Show (HWND hwndParent);

#endif  /*  _SwitchUserDialog_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\thumbnailgen.cpp ===
#include "shellprv.h"
#include "runtask.h"
#include "prop.h"
#include "thumbutil.h"
#include <cowsite.h>

static const GUID TOID_Thumbnail = { 0xadec3450, 0xe907, 0x11d0, {0xa5, 0x7b, 0x00, 0xc0, 0x4f, 0xc2, 0xf7, 0x6a} };

class CThumbnail : public IThumbnail2, public IParentAndItem, public CObjectWithSite
{
public:
    CThumbnail(void);

    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);

    // IThumbnail
    STDMETHODIMP Init(HWND hwnd, UINT uMsg);
    STDMETHODIMP GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight);

    // IThumbnail2
    STDMETHODIMP GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

private:
    ~CThumbnail(void);
    HRESULT _CreateTask(IShellFolder *psf, LPCITEMIDLIST pidlLast, DWORD dwItem, SIZE rgSize, IExtractImage *pei, IRunnableTask **pprt);
    HRESULT _BitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight);
    HRESULT _InitTaskCancelItems();

    LONG _cRef;
    HWND _hwnd;
    UINT _uMsg;
    IShellTaskScheduler *_pScheduler;
    IShellFolder *_psf;
    LPITEMIDLIST _pidl;
};

class CGetThumbnailTask : public CRunnableTask
{
public:
    CGetThumbnailTask(IShellFolder *psf, LPCITEMIDLIST pidl, IExtractImage *pei, HWND hwnd, UINT uMsg, DWORD dwItem, SIZE rgSize);
    STDMETHODIMP RunInitRT(void);

private:
    ~CGetThumbnailTask();
    HRESULT _PrepImage(HBITMAP *phBmp);
    HRESULT _BitmapReady(HBITMAP hImage);
    
    IShellFolder *_psf;
    IExtractImage *_pei;
    HWND _hwnd;
    UINT _uMsg;
    DWORD _dwItem;
    SIZE _rgSize;
    LPITEMIDLIST _pidlFolder;   // folder where we test the cache
    LPITEMIDLIST _pidlLast;
    WCHAR _szPath[MAX_PATH];    // the item in that in folder parsing name for cache test
};

CThumbnail::CThumbnail(void) : _cRef(1)
{
    DllAddRef();
}

CThumbnail::~CThumbnail(void)
{
    if (_pScheduler)
    {
        _pScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
        _pScheduler->Release();
        _pScheduler = NULL;
    }

    if (_psf)
        _psf->Release();

    ILFree(_pidl);

    DllRelease();
}

STDAPI CThumbnail_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CThumbnail *pThumb = new CThumbnail();
    if (pThumb)
    {
        hr = pThumb->QueryInterface(riid, ppv);
        pThumb->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CThumbnail::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CThumbnail, IThumbnail2), 
        QITABENTMULTI(CThumbnail, IThumbnail, IThumbnail2), 
        QITABENT(CThumbnail, IParentAndItem),
        QITABENT(CThumbnail, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CThumbnail::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CThumbnail::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IThumbnail
HRESULT CThumbnail::Init(HWND hwnd, UINT uMsg)
{
    _hwnd = hwnd;
    _uMsg = uMsg;
    ASSERT(NULL == _pScheduler);

    return S_OK;
}

HRESULT CThumbnail::_InitTaskCancelItems()
{
    if (!_pScheduler)
    {
        if (!_punkSite || FAILED(IUnknown_QueryService(_punkSite, SID_ShellTaskScheduler,
                    IID_PPV_ARG(IShellTaskScheduler, &_pScheduler))))
        {
            CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IShellTaskScheduler, &_pScheduler));
        }
        
        if (_pScheduler)
        {
            // make sure RemoveTasks() actually kills old tasks even if they're not done yet
            _pScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, ITSS_THREAD_TIMEOUT_NO_CHANGE);
        }
    }

    if (_pScheduler)
    {
        // Kill any old tasks in the scheduler.
        _pScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
    }
    return _pScheduler ? S_OK : E_FAIL;
}

HRESULT CThumbnail::_CreateTask(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwItem, SIZE rgSize, IExtractImage *pei, IRunnableTask **pprt)
{
    *pprt = new CGetThumbnailTask(psf, pidl, pei, _hwnd, _uMsg, dwItem, rgSize);
    return *pprt ? S_OK : E_OUTOFMEMORY;
}

HRESULT CThumbnail::_BitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    LPCITEMIDLIST pidlLast;
    IShellFolder *psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        IExtractImage *pei;
        hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_PPV_ARG_NULL(IExtractImage, &pei));
        if (SUCCEEDED(hr))
        {
            DWORD dwPriority = 0;
            DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
            SIZEL rgSize = {lWidth, lHeight};

            WCHAR szLocation[MAX_PATH];
            hr = pei->GetLocation(szLocation, ARRAYSIZE(szLocation), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    HBITMAP hbm;
                    hr = pei->Extract(&hbm);
                    if (SUCCEEDED(hr))
                    {
                        if (!PostMessage(_hwnd, _uMsg, dwItem, (LPARAM)hbm))
                        {
                            DeleteObject(hbm);
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            else if (E_PENDING == hr)
            {
                IRunnableTask *prt;
                hr = _CreateTask(psf, pidlLast, dwItem, rgSize, pei, &prt);
                if (SUCCEEDED(hr))
                {
                    // Add the task to the scheduler.
                    hr = _pScheduler->AddTask(prt, TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, dwPriority);
                    prt->Release();
                }
            }
            pei->Release();
        }
        psf->Release();
    }
    return hr;
}

STDMETHODIMP CThumbnail::GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();
    if (pszFile)
    {
        LPITEMIDLIST pidl = ILCreateFromPathW(pszFile);
        if (pidl)
        {
            hr = _BitmapFromIDList(pidl, dwItem, lWidth, lHeight);
            ILFree(pidl);
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

// IThumbnail2
STDMETHODIMP CThumbnail::GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();
    if (pidl)
    {
        hr = _BitmapFromIDList(pidl, dwItem, lWidth, lHeight);
    }
    return hr;
}

// IParentAndItem
STDMETHODIMP CThumbnail::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf, LPCITEMIDLIST pidlChild) 
{ 
    return E_NOTIMPL;
}

STDMETHODIMP CThumbnail::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    return E_NOTIMPL;
}

CGetThumbnailTask::CGetThumbnailTask(IShellFolder *psf, LPCITEMIDLIST pidl, IExtractImage *pei, HWND hwnd, UINT uMsg, DWORD dwItem, SIZE rgSize)
    : CRunnableTask(RTF_DEFAULT), _pei(pei), _hwnd(hwnd), _uMsg(uMsg), _dwItem(dwItem), _psf(psf), _rgSize(rgSize)
{
    SHGetIDListFromUnk(psf, &_pidlFolder);  // failure handled later
    _pidlLast = ILClone(pidl);  // failure handled later
    DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, _szPath, ARRAYSIZE(_szPath));
    _pei->AddRef();
    _psf->AddRef();
}

CGetThumbnailTask::~CGetThumbnailTask()
{
    ILFree(_pidlLast);
    ILFree(_pidlFolder);
    _pei->Release();
    _psf->Release();
}

HRESULT CGetThumbnailTask::_PrepImage(HBITMAP *phBmp)
{
    HRESULT hr = E_FAIL;
    DIBSECTION ds;
    if (GetObject(*phBmp, sizeof(ds), &ds))
    {
        // the disk cache only supports 32 Bpp DIBS now, so we can ignore the palette issue...
        ASSERT(ds.dsBm.bmBitsPixel == 32);
    
        HPALETTE hPal = (SHGetCurColorRes() == 8) ? SHCreateShellPalette(NULL) : NULL;

        HBITMAP hBmpNew;
        if (ConvertDIBSECTIONToThumbnail((BITMAPINFO *)&ds.dsBmih, ds.dsBm.bmBits, &hBmpNew, &_rgSize, 
                                         SHGetCurColorRes(), hPal, 0, FALSE))
        {
            DeleteObject(*phBmp);
            *phBmp = hBmpNew;
        }

        if (hPal)
            DeletePalette(hPal);
    }
    return hr;
}

HRESULT CGetThumbnailTask::_BitmapReady(HBITMAP hImage)
{
    if (!PostMessage(_hwnd, _uMsg, _dwItem, (LPARAM)hImage))
    {
        DeleteObject(hImage);
    }
    return S_OK;
}

STDMETHODIMP CGetThumbnailTask::RunInitRT()
{
    HRESULT hr = E_FAIL;
    
    // now get the date stamp and check the disk cache....
    FILETIME ftImageTimeStamp = {0,0};

    // do they support date stamps....
    IExtractImage2 *pei2;
    if (SUCCEEDED(_pei->QueryInterface(IID_PPV_ARG(IExtractImage2, &pei2))))
    {
        pei2->GetDateStamp(&ftImageTimeStamp);
        pei2->Release();
    }

    IShellFolder2 *psf2;
    if (IsNullTime(&ftImageTimeStamp) && _pidlLast && SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        // fall back to this (most common case)
        GetDateProperty(psf2, _pidlLast, &SCID_WRITETIME, &ftImageTimeStamp);
        psf2->Release();
    }

    IShellImageStore *pStore;
    if (_pidlFolder &&
        SUCCEEDED(LoadFromIDList(CLSID_ShellThumbnailDiskCache, _pidlFolder, IID_PPV_ARG(IShellImageStore, &pStore))))
    {
        DWORD dwStoreLock;
        if (SUCCEEDED(pStore->Open(STGM_READ, &dwStoreLock)))
        {
            FILETIME ftCacheDateStamp;
            if ((S_OK == pStore->IsEntryInStore(_szPath, &ftCacheDateStamp)) && 
                ((0 == CompareFileTime(&ftCacheDateStamp, &ftImageTimeStamp)) || IsNullTime(&ftImageTimeStamp)))
            {
                HBITMAP hBmp;
                if (SUCCEEDED(pStore->GetEntry(_szPath, STGM_READ, &hBmp)))
                {
                    _PrepImage(&hBmp);
                    hr = _BitmapReady(hBmp);
                }
            }
            pStore->Close(&dwStoreLock);
        }
        pStore->Release();
    }

    if (FAILED(hr))
    {
        HBITMAP hbm;
        if (SUCCEEDED(_pei->Extract(&hbm)))
        {
            hr = _BitmapReady(hbm);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\storage.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include "debug.h"
#include "stgutil.h"
#include "ids.h"
#include "tlist.h"
#include "thumbutil.h"
#include <gdiplus\gdiplus.h>
using namespace Gdiplus;

#define THUMBNAIL_QUALITY 90

__inline HRESULT HR_FROM_STATUS(Status status)
{
    return ((status) == Ok) ? S_OK : E_FAIL;
}

class CGraphicsInit
{    
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        _token = 0;        
        GdiplusStartupInput gsi;            
        GdiplusStartup(&_token, &gsi, NULL);        
    };
    ~CGraphicsInit()
    {
        if (_token != 0)
        {
            GdiplusShutdown(_token);
        }           
    };
};

void SHGetThumbnailSizeForThumbsDB(SIZE *psize);

STDAPI CThumbStore_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);

class CThumbStore : public IShellImageStore,
                    public IPersistFolder,
                    public IPersistFile,
                    public CComObjectRootEx<CComMultiThreadModel>,
                    public CComCoClass< CThumbStore,&CLSID_ShellThumbnailDiskCache >
{
    struct CATALOG_ENTRY
    {
        DWORD     cbSize;
        DWORD     dwIndex;
        FILETIME  ftTimeStamp;
        WCHAR     szName[1];
    };

    struct CATALOG_HEADER
    {
        WORD      cbSize;
        WORD      wVersion;
        DWORD     dwEntryCount;
        SIZE      szThumbnailExtent;
    };

public:
    BEGIN_COM_MAP(CThumbStore)
        COM_INTERFACE_ENTRY_IID(IID_IShellImageStore,IShellImageStore)
        COM_INTERFACE_ENTRY(IPersistFolder)
        COM_INTERFACE_ENTRY(IPersistFile)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CThumbStore)

    CThumbStore();
    ~CThumbStore();

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFile
    STDMETHOD (IsDirty)(void);
    STDMETHOD (Load)(LPCWSTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCWSTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCWSTR pszFileName);
    STDMETHOD (GetCurFile)(LPWSTR *ppszFileName);

    // IImageCache
    STDMETHOD (Open)(DWORD dwMode, DWORD *pdwLock);
    STDMETHOD (Create)(DWORD dwMode, DWORD *pdwLock);
    STDMETHOD (Close)(DWORD const *pdwLock);
    STDMETHOD (Commit)(DWORD const *pdwLock);
    STDMETHOD (ReleaseLock)(DWORD const *pdwLock);
    STDMETHOD (IsLocked)(THIS);
    
    STDMETHOD (GetMode)(DWORD *pdwMode);
    STDMETHOD (GetCapabilities)(DWORD *pdwCapMask);

    STDMETHOD (AddEntry)(LPCWSTR pszName, const FILETIME *pftTimeStamp, DWORD dwMode, HBITMAP hImage);
    STDMETHOD (GetEntry)(LPCWSTR pszName, DWORD dwMode, HBITMAP *phImage);
    STDMETHOD (DeleteEntry)(LPCWSTR pszName);
    STDMETHOD (IsEntryInStore)(LPCWSTR pszName, FILETIME *pftTimeStamp);

    STDMETHOD (Enum)(IEnumShellImageStore ** ppEnum);
   
protected:
    friend class CEnumThumbStore;
    
    HRESULT LoadCatalog(void);
    HRESULT SaveCatalog(void);
    
    HRESULT FindStreamID(LPCWSTR pszName, DWORD *pdwStream, CATALOG_ENTRY **ppEntry);
    HRESULT GetEntryStream(DWORD dwStream, DWORD dwMode, IStream **ppStream);
    DWORD GetAccessMode(DWORD dwMode, BOOL fStream);

    DWORD AcquireLock(void);
    void ReleaseLock(DWORD dwLock);

    HRESULT DecompressImage(IStream *pStream, HBITMAP *phBmp);
    HRESULT CompressImage(IStream *pStream, HBITMAP hBmp);

    HRESULT WriteImage(IStream *pStream, HBITMAP hBmp);
    HRESULT ReadImage(IStream *pStream, HBITMAP *phBmp);
    BOOL _MatchNodeName(CATALOG_ENTRY *pNode, LPCWSTR pszName);

    HRESULT _InitFromPath(LPCTSTR pszPath, DWORD dwMode);
    void _SetAttribs(BOOL bForce);

    CATALOG_HEADER m_rgHeader;
    CList<CATALOG_ENTRY> m_rgCatalog;
    IStorage *_pStorageThumb;
    DWORD _dwModeStorage;

    DWORD m_dwModeAllow;
    WCHAR m_szPath[MAX_PATH];
    DWORD m_dwMaxIndex;
    DWORD m_dwCatalogChange;

    // Crit section used to protect the internals
    CRITICAL_SECTION m_csInternals;
    BOOL m_bCSInternalsInited;
    
    // needed for this object to be free-threaded... so that 
    // we can query the catalog from the main thread whilst icons are
    // being read and written from the main thread.
    CRITICAL_SECTION m_csLock;
    BOOL m_bCSLockInited;

    DWORD m_dwLock;
    int m_fLocked;
    
    // gdi+ jpg decoder variables
    CGraphicsInit m_cgi;        // initializes gdi+
    int m_iThumbnailQuality;    // jpg image quality with valid range [0 to 100]
};

HRESULT CEnumThumbStore_Create(CThumbStore * pThis, IEnumShellImageStore ** ppEnum);

class CEnumThumbStore : public IEnumShellImageStore,
                        public CComObjectRoot
{
public:
    BEGIN_COM_MAP(CEnumThumbStore)
        COM_INTERFACE_ENTRY_IID(IID_IEnumShellImageStore,IEnumShellImageStore)
    END_COM_MAP()

    CEnumThumbStore();
    ~CEnumThumbStore();

    STDMETHOD (Reset)(void);
    STDMETHOD (Next)(ULONG celt, PENUMSHELLIMAGESTOREDATA *prgElt, ULONG *pceltFetched);
    STDMETHOD (Skip)(ULONG celt);
    STDMETHOD (Clone)(IEnumShellImageStore ** pEnum);
    
protected:
    friend HRESULT CEnumThumbStore_Create(CThumbStore *pThis, IEnumShellImageStore **ppEnum);

    CThumbStore * m_pStore;
    CLISTPOS m_pPos;
    DWORD m_dwCatalogChange;
};


#define THUMB_FILENAME      L"Thumbs.db"
#define CATALOG_STREAM      L"Catalog"

#define CATALOG_VERSION     0x0007
#define CATALOG_VERSION_XPGOLD 0x0005
#define STREAMFLAGS_JPEG    0x0001
#define STREAMFLAGS_DIB     0x0002

struct STREAM_HEADER
{
    DWORD cbSize;
    DWORD dwFlags;
    ULONG ulSize;
};

void GenerateStreamName(LPWSTR pszBuffer, DWORD cchSize, DWORD dwNumber);

CThumbStore::CThumbStore()
{
    m_szPath[0] = 0;
    m_rgHeader.dwEntryCount = 0;
    m_rgHeader.wVersion = CATALOG_VERSION;
    m_rgHeader.cbSize = sizeof(m_rgHeader);
    SHGetThumbnailSizeForThumbsDB(&m_rgHeader.szThumbnailExtent);

    m_dwMaxIndex = 0;
    m_dwModeAllow = STGM_READWRITE;

    // this counter is inc'd everytime the catalog changes so that we know when it
    // must be committed and so enumerators can detect the list has changed...
    m_dwCatalogChange = 0;

    m_fLocked = 0;
    m_bCSLockInited = InitializeCriticalSectionAndSpinCount(&m_csLock, 0);
    m_bCSInternalsInited = InitializeCriticalSectionAndSpinCount(&m_csInternals, 0);

    m_iThumbnailQuality = THUMBNAIL_QUALITY;    
    int qual = 0;
    DWORD cb = sizeof(qual);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                                TEXT("ThumbnailQuality"), NULL, &qual, &cb, FALSE, NULL, 0);
    if (qual >= 50 && qual <= 100)    // constrain to reason
    {
        m_iThumbnailQuality = qual;
    }
}

CThumbStore::~CThumbStore()
{
    CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
    while (pCur != NULL)
    {
        CATALOG_ENTRY *pNode = m_rgCatalog.GetNext(pCur);
        ASSERT(pNode != NULL);

        LocalFree((void *) pNode);
    }

    m_rgCatalog.RemoveAll();

    if (_pStorageThumb)
    {
        _pStorageThumb->Release();
    }

    // assume these are free, we are at ref count zero, no one should still be calling us...
    if (m_bCSLockInited)
    {
        DeleteCriticalSection(&m_csLock);
    }
    if (m_bCSInternalsInited)
    {
        DeleteCriticalSection(&m_csInternals);
    }
}

STDAPI CThumbStore_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    return CComCreator< CComObject< CThumbStore > >::CreateInstance((void *)punkOuter, riid, (void **)ppv);
}

DWORD CThumbStore::AcquireLock(void)
{
    ASSERT(m_bCSLockInited);
    
    EnterCriticalSection(&m_csLock);

    // inc the lock (we use a counter because we may reenter this on the same thread)
    m_fLocked++;

    // Never return a lock signature of zero, because that means "not locked".
    if (++m_dwLock == 0)
        ++m_dwLock;
    return m_dwLock;
}

void CThumbStore::ReleaseLock(DWORD dwLock)
{
    ASSERT(m_bCSLockInited);
    
    if (dwLock) 
    {
        ASSERT(m_fLocked);
        m_fLocked--;
        LeaveCriticalSection(&m_csLock);
    }
}

// the structure of the catalog is simple, it is a just a header stream
HRESULT CThumbStore::LoadCatalog()
{
    HRESULT hr;
    if (_pStorageThumb == NULL)
    {
        hr = E_UNEXPECTED;
    } 
    else if (m_rgHeader.dwEntryCount != 0)
    {
        // it is already loaded....
        hr = S_OK;
    }
    else
    {
        // open the catalog stream...
        IStream *pCatalog;
        hr = _pStorageThumb->OpenStream(CATALOG_STREAM, NULL, GetAccessMode(STGM_READ, TRUE), NULL, &pCatalog);
        if (SUCCEEDED(hr))
        {
            EnterCriticalSection(&m_csInternals);

            // now read in the catalog from the stream ...
            hr = IStream_Read(pCatalog, &m_rgHeader, sizeof(m_rgHeader));
            if (SUCCEEDED(hr))
            {
                SIZE szCurrentSize;
                SHGetThumbnailSizeForThumbsDB(&szCurrentSize);
                if ((m_rgHeader.cbSize != sizeof(m_rgHeader)) || (m_rgHeader.wVersion != CATALOG_VERSION) ||
                    (m_rgHeader.szThumbnailExtent.cx != szCurrentSize.cx) || (m_rgHeader.szThumbnailExtent.cy != szCurrentSize.cy))
                {
                    if (m_rgHeader.wVersion == CATALOG_VERSION_XPGOLD)
                    {
                        hr = STG_E_DOCFILECORRUPT; // SECURITY: Many issues encrypting XPGOLD thumbnail databases, just delete it
                        _pStorageThumb->Release();
                        _pStorageThumb = NULL;
                    }
                    else
                    {
                        _SetAttribs(TRUE); // SECURITY: Old formats can't be encrypted
                        hr = STG_E_OLDFORMAT;
                    }
                }
                else
                {
                    for (UINT iEntry = 0; (iEntry < m_rgHeader.dwEntryCount) && SUCCEEDED(hr); iEntry++)
                    {
                        DWORD cbSize;
                        hr = IStream_Read(pCatalog, &cbSize, sizeof(cbSize));
                        if (SUCCEEDED(hr))
                        {
                            if (cbSize <= sizeof(CATALOG_ENTRY) + sizeof(WCHAR) * MAX_PATH)
                            {
                                CATALOG_ENTRY *pEntry = (CATALOG_ENTRY *)LocalAlloc(LPTR, cbSize);
                                if (pEntry)
                                {
                                    pEntry->cbSize = cbSize;

                                    // read the rest with out the size on the front...
                                    hr = IStream_Read(pCatalog, ((BYTE *)pEntry + sizeof(cbSize)), cbSize - sizeof(cbSize));
                                    if (SUCCEEDED(hr))
                                    {
                                        CLISTPOS pCur = m_rgCatalog.AddTail(pEntry);
                                        if (pCur)
                                        {
                                            if (m_dwMaxIndex < pEntry->dwIndex)
                                            {
                                                m_dwMaxIndex = pEntry->dwIndex;
                                            }
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                hr = E_UNEXPECTED; // Corrupted header information
                            }
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                // reset the catalog header...
                m_rgHeader.wVersion = CATALOG_VERSION;
                m_rgHeader.cbSize = sizeof(m_rgHeader);
                SHGetThumbnailSizeForThumbsDB(&m_rgHeader.szThumbnailExtent);
                m_rgHeader.dwEntryCount = 0;
            }

            m_dwCatalogChange = 0;
            LeaveCriticalSection(&m_csInternals);

            pCatalog->Release();
        }
    }

    return hr;
}

HRESULT CThumbStore::SaveCatalog()
{
    HRESULT hr = E_UNEXPECTED;
    if (_pStorageThumb)
    {
        _pStorageThumb->DestroyElement(CATALOG_STREAM);

        IStream *pCatalog;
        hr = _pStorageThumb->CreateStream(CATALOG_STREAM, GetAccessMode(STGM_WRITE, TRUE), NULL, NULL, &pCatalog);
        if (SUCCEEDED(hr))
        {
            EnterCriticalSection(&m_csInternals);

            // now write the catalog to the stream ...
            hr = IStream_Write(pCatalog, &m_rgHeader, sizeof(m_rgHeader));
            if (SUCCEEDED(hr))
            {
                CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
                while (pCur && SUCCEEDED(hr))
                {
                    CATALOG_ENTRY *pEntry = m_rgCatalog.GetNext(pCur);
                    if (pEntry)
                    {
                        hr = IStream_Write(pCatalog, pEntry, pEntry->cbSize);
                    }
                }
            }

            if (SUCCEEDED(hr))
                m_dwCatalogChange = 0;

            LeaveCriticalSection(&m_csInternals);
            pCatalog->Release();
        }
    }
    return hr;
}

void GenerateStreamName(LPWSTR pszBuffer, DWORD cchSize, DWORD dwNumber)
{
    UINT cPos = 0;
    while ((dwNumber > 0) && (cPos < cchSize))
    {
        DWORD dwRem = dwNumber % 10;

        // based the fact that UNICODE chars 0-9 are the same as the ANSI chars 0 - 9
        pszBuffer[cPos++] = (WCHAR)(dwRem + '0');
        dwNumber /= 10;
    }
    pszBuffer[cPos] = 0;
}

// IPersist methods

STDMETHODIMP CThumbStore::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_ShellThumbnailDiskCache;
    return S_OK;
}

// IPersistFolder

STDMETHODIMP CThumbStore::Initialize(LPCITEMIDLIST pidl)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = E_UNEXPECTED;
    
    if (m_bCSInternalsInited && m_bCSLockInited)
    {
        hr = SHGetPathFromIDList(pidl, szPath) ? S_OK : E_FAIL;
        if (SUCCEEDED(hr))
        {
            if (PathAppend(szPath, THUMB_FILENAME))
                hr = _InitFromPath(szPath, STGM_READWRITE);
            else
                hr = E_INVALIDARG;
        }
    }
    
    return hr;
}

// IPersistFile

STDMETHODIMP CThumbStore::IsDirty(void)
{
    return m_dwCatalogChange ? S_OK : S_FALSE;
}

HRESULT CThumbStore::_InitFromPath(LPCTSTR pszPath, DWORD dwMode)
{
    if (PathIsRemovable(pszPath))
        dwMode = STGM_READ;

    m_dwModeAllow = dwMode;
    return StringCchCopyW(m_szPath, ARRAYSIZE(m_szPath), pszPath);
}

STDMETHODIMP CThumbStore::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = E_UNEXPECTED;
    if (PathCombine(szPath, pszFileName, THUMB_FILENAME))
    {
        hr = _InitFromPath(szPath, dwMode);
    }
    return hr;
}

STDMETHODIMP CThumbStore::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CThumbStore::SaveCompleted(LPCWSTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CThumbStore::GetCurFile(LPWSTR *ppszFileName)
{
    return SHStrDupW(m_szPath, ppszFileName);
}

// IShellImageStore methods
void CThumbStore::_SetAttribs(BOOL bForce)
{
    // reduce spurious changenotifies by checking file attribs first
    DWORD dwAttrib = GetFileAttributes(m_szPath);
    if (bForce || 
        ((dwAttrib != 0xFFFFFFFF) &&
         (dwAttrib & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)))
    {
        SetFileAttributes(m_szPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        
        WCHAR szStream[MAX_PATH];
        if (SUCCEEDED(StringCchCopyW(szStream, ARRAYSIZE(szStream), m_szPath)))
        {
            if (SUCCEEDED(StringCchCatW(szStream, ARRAYSIZE(szStream), TEXT(":encryptable"))))
            {
                HANDLE hStream = CreateFile(szStream, GENERIC_WRITE, NULL, NULL, CREATE_NEW, NULL, NULL);
                if (hStream != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hStream);
                }
            }
        }

        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_szPath, NULL);   // suppress the update dir        
    }
}

STDMETHODIMP CThumbStore::Open(DWORD dwMode, DWORD *pdwLock)
{
    if (m_szPath[0] == 0)
    {
        return E_UNEXPECTED;
    }

    if ((m_dwModeAllow == STGM_READ) && (dwMode != STGM_READ))
        return STG_E_ACCESSDENIED;

    // at this point we have the lock if we need it, so we can close and reopen if we
    // don't have it open with the right permissions...
    if (_pStorageThumb)
    {
        if (_dwModeStorage == dwMode)
        {
            // we already have it open in this mode...
            *pdwLock = AcquireLock();
            return S_FALSE;
        }
        else
        {
            // we are open and the mode is different, so close it. Note, no lock is passed, we already
            // have it
            HRESULT hr = Close(NULL);
            if (FAILED(hr))
            {
                return hr;
            }
        }
    }

    DWORD dwLock = AcquireLock();

    DWORD dwFlags = GetAccessMode(dwMode, FALSE);

    // now open the DocFile
    HRESULT hr = StgOpenStorage(m_szPath, NULL, dwFlags, NULL, NULL, &_pStorageThumb);
    if (SUCCEEDED(hr))
    {
        _dwModeStorage = dwMode & (STGM_READ | STGM_WRITE | STGM_READWRITE);
        _SetAttribs(FALSE);
        hr = LoadCatalog();
        *pdwLock = dwLock;
    }

    if (STG_E_DOCFILECORRUPT == hr)
    {
        DeleteFile(m_szPath);
    }

    if (FAILED(hr))
    {
        ReleaseLock(dwLock);
    }

    return hr;
}

STDMETHODIMP CThumbStore::Create(DWORD dwMode, DWORD *pdwLock)
{
    if (m_szPath[0] == 0)
    {
        return E_UNEXPECTED;
    }

    if (_pStorageThumb)
    {
        // we already have it open, so we can't create it ...
        return STG_E_ACCESSDENIED;
    }

    if ((m_dwModeAllow == STGM_READ) && (dwMode != STGM_READ))
        return STG_E_ACCESSDENIED;

    DWORD dwLock = AcquireLock();

    DWORD dwFlags = GetAccessMode(dwMode, FALSE);
    
    HRESULT hr = StgCreateDocfile(m_szPath, dwFlags, NULL, &_pStorageThumb);
    if (SUCCEEDED(hr))
    {
        _dwModeStorage = dwMode & (STGM_READ | STGM_WRITE | STGM_READWRITE);
        _SetAttribs(FALSE);
        *pdwLock = dwLock;
    }

    if (FAILED(hr))
    {
        ReleaseLock(dwLock);
    }
    return hr;
}

STDMETHODIMP CThumbStore::ReleaseLock(DWORD const *pdwLock)
{
    ReleaseLock(*pdwLock);
    return S_OK;
}

STDMETHODIMP CThumbStore::IsLocked()
{
    return (m_fLocked > 0 ? S_OK : S_FALSE);
}

// pdwLock can be NULL indicating close the last opened lock

STDMETHODIMP CThumbStore::Close(DWORD const *pdwLock)
{
    DWORD dwLock;
    DWORD const *pdwRel = pdwLock;

    if (!pdwLock)
    {
        dwLock = AcquireLock();
        pdwRel = &dwLock;
    }

    HRESULT hr = S_FALSE;
    if (_pStorageThumb)
    {
        if (_dwModeStorage != STGM_READ)
        {
            // write out the new catalog...
            hr = Commit(NULL);
            _pStorageThumb->Commit(0);

            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_szPath, NULL);   // suppress the update dir
        }

        _pStorageThumb->Release();
        _pStorageThumb = NULL;
    }

    ReleaseLock(*pdwRel);

    return hr;
}

// pdwLock can be NULL meaning use the current lock

STDMETHODIMP CThumbStore::Commit(DWORD const *pdwLock)
{
    DWORD dwLock;
    if (!pdwLock)
    {
        dwLock = AcquireLock();
        pdwLock = &dwLock;
    }

    HRESULT hr = S_FALSE;

    if (_pStorageThumb && _dwModeStorage != STGM_READ)
    {
        if (m_dwCatalogChange)
        {
            SaveCatalog();
        }
        hr = S_OK;
    }

    ReleaseLock(*pdwLock);

    return hr;
}

STDMETHODIMP CThumbStore::GetMode(DWORD *pdwMode)
{
    if (!pdwMode)
    {
        return E_INVALIDARG;
    }

    if (_pStorageThumb)
    {
        *pdwMode = _dwModeStorage;
        return S_OK;
    }

    *pdwMode = 0;
    return S_FALSE;
}


STDMETHODIMP CThumbStore::GetCapabilities(DWORD *pdwMode)
{
    ASSERT(pdwMode);

    // right now, both are needed/supported for thumbs.db
    *pdwMode = SHIMSTCAPFLAG_LOCKABLE | SHIMSTCAPFLAG_PURGEABLE;

    return S_OK;
}

STDMETHODIMP CThumbStore::AddEntry(LPCWSTR pszName, const FILETIME *pftTimeStamp, DWORD dwMode, HBITMAP hImage)
{
    ASSERT(pszName);

    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    if (_dwModeStorage == STGM_READ)
    {
        // can't modify in this mode...
        return E_ACCESSDENIED;
    }

    // this will block unless we already have the lock on this thread...
    DWORD dwLock = AcquireLock();

    DWORD dwStream = 0;
    CLISTPOS pCur = NULL;
    CATALOG_ENTRY *pNode = NULL;

    EnterCriticalSection(&m_csInternals);

    if (FindStreamID(pszName, &dwStream, &pNode) != S_OK)
    {
        // needs adding to the catalog...
        UINT cchName = lstrlenW(pszName) + 1;
        UINT cbSize = sizeof(*pNode) + (cchName - 1) * sizeof(WCHAR); // subtract 1 since *pNode has a WCHAR[1]

        pNode = (CATALOG_ENTRY *)LocalAlloc(LPTR, cbSize);
        if (pNode == NULL)
        {
            LeaveCriticalSection(&m_csInternals);
            ReleaseLock(dwLock);
            return E_OUTOFMEMORY;
        }

        pNode->cbSize = cbSize;
        if (pftTimeStamp)
        {
            pNode->ftTimeStamp = *pftTimeStamp;
        }
        dwStream = pNode->dwIndex = ++m_dwMaxIndex;

        if (SUCCEEDED(StringCchCopyW(pNode->szName, cchName, pszName)))
        {
            pCur = m_rgCatalog.AddTail(pNode);
        }
        
        if (pCur == NULL)
        {
            LocalFree(pNode);
            LeaveCriticalSection(&m_csInternals);
            ReleaseLock(dwLock);
            return E_OUTOFMEMORY;
        }

        m_rgHeader.dwEntryCount++;
    }
    else if (pftTimeStamp)
    {
        // update the timestamp .....
        pNode->ftTimeStamp = *pftTimeStamp;
    }

    LeaveCriticalSection(&m_csInternals);

    IStream *pStream = NULL;
    HRESULT hr = THR(GetEntryStream(dwStream, dwMode, &pStream));
    if (SUCCEEDED(hr))
    {
        hr = THR(WriteImage(pStream, hImage));
        pStream->Release();
    }

    if (FAILED(hr) && pCur)
    {
        // take it back out of the list if we added it...
        EnterCriticalSection(&m_csInternals);
        m_rgCatalog.RemoveAt(pCur);
        m_rgHeader.dwEntryCount--;
        LeaveCriticalSection(&m_csInternals);
        LocalFree(pNode);
    }

    if (SUCCEEDED(hr))
    {
        // catalog change....
        m_dwCatalogChange++;
    }

    ReleaseLock(dwLock);

    return hr;
}

STDMETHODIMP CThumbStore::GetEntry(LPCWSTR pszName, DWORD dwMode, HBITMAP *phImage)
{
    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;
    DWORD dwStream;
    if (FindStreamID(pszName, &dwStream, NULL) != S_OK)
    {
        hr = E_FAIL;
    }
    else
    {
        IStream *pStream;
        hr = GetEntryStream(dwStream, dwMode, &pStream);
        if (SUCCEEDED(hr))
        {
            hr = ReadImage(pStream, phImage);
            pStream->Release();
        }
    }

    return hr;
}

BOOL CThumbStore::_MatchNodeName(CATALOG_ENTRY *pNode, LPCWSTR pszName)
{
    return (StrCmpIW(pNode->szName, pszName) == 0) || 
           (StrCmpIW(PathFindFileName(pNode->szName), pszName) == 0);   // match old thumbs.db files
}

STDMETHODIMP CThumbStore::DeleteEntry(LPCWSTR pszName)
{
    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    if (_dwModeStorage == STGM_READ)
    {
        // can't modify in this mode...
        return E_ACCESSDENIED;
    }

    DWORD dwLock = AcquireLock();

    EnterCriticalSection(&m_csInternals);

    // check to see if it already exists.....
    CATALOG_ENTRY *pNode = NULL;

    CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
    while (pCur != NULL)
    {
        CLISTPOS pDel = pCur;
        pNode = m_rgCatalog.GetNext(pCur);
        ASSERT(pNode != NULL);

        if (_MatchNodeName(pNode, pszName))
        {
            m_rgCatalog.RemoveAt(pDel);
            m_rgHeader.dwEntryCount--;
            m_dwCatalogChange++;
            if (pNode->dwIndex == m_dwMaxIndex)
            {
                m_dwMaxIndex--;
            }
            LeaveCriticalSection(&m_csInternals);

            WCHAR szStream[30];
            GenerateStreamName(szStream, ARRAYSIZE(szStream), pNode->dwIndex);
            _pStorageThumb->DestroyElement(szStream);

            LocalFree(pNode);
            ReleaseLock(dwLock);
            return S_OK;
        }
    }

    LeaveCriticalSection(&m_csInternals);
    ReleaseLock(dwLock);

    return E_INVALIDARG;
}


STDMETHODIMP CThumbStore::IsEntryInStore(LPCWSTR pszName, FILETIME *pftTimeStamp)
{
    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    DWORD dwStream = 0;
    CATALOG_ENTRY *pNode = NULL;
    EnterCriticalSection(&m_csInternals);
    HRESULT hr = FindStreamID(pszName, &dwStream, &pNode);
    if (pftTimeStamp && SUCCEEDED(hr))
    {
        ASSERT(pNode);
        *pftTimeStamp = pNode->ftTimeStamp;
    }
    LeaveCriticalSection(&m_csInternals);

    return (hr == S_OK) ? S_OK : S_FALSE;
}

STDMETHODIMP CThumbStore::Enum(IEnumShellImageStore **ppEnum)
{
    return CEnumThumbStore_Create(this, ppEnum);
}

HRESULT CThumbStore::FindStreamID(LPCWSTR pszName, DWORD *pdwStream, CATALOG_ENTRY ** ppNode)
{
    // check to see if it already exists in the catalog.....
    CATALOG_ENTRY *pNode = NULL;

    CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
    while (pCur != NULL)
    {
        pNode = m_rgCatalog.GetNext(pCur);
        ASSERT(pNode != NULL);

        if (_MatchNodeName(pNode, pszName))
        {
            *pdwStream = pNode->dwIndex;

            if (ppNode != NULL)
            {
                *ppNode = pNode;
            }
            return S_OK;
        }
    }

    return E_FAIL;
}

CEnumThumbStore::CEnumThumbStore()
{
    m_pStore = NULL;
    m_pPos = 0;
    m_dwCatalogChange = 0;
}

CEnumThumbStore::~CEnumThumbStore()
{
    if (m_pStore)
    {
        SAFECAST(m_pStore, IPersistFile *)->Release();
    }
}


STDMETHODIMP CEnumThumbStore::Reset(void)
{
    m_pPos = m_pStore->m_rgCatalog.GetHeadPosition();
    m_dwCatalogChange = m_pStore->m_dwCatalogChange;
    return S_OK;
}

STDMETHODIMP CEnumThumbStore::Next(ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched)
{
    if ((celt > 1 && !pceltFetched) || !celt)
    {
        return E_INVALIDARG;
    }

    if (m_dwCatalogChange != m_pStore->m_dwCatalogChange)
    {
        return E_UNEXPECTED;
    }

    ULONG celtFetched = 0;
    HRESULT hr = S_OK;

    while (celtFetched < celt && m_pPos)
    {
        CThumbStore::CATALOG_ENTRY *pNode = m_pStore->m_rgCatalog.GetNext(m_pPos);

        ASSERT(pNode);
        PENUMSHELLIMAGESTOREDATA pElt = (PENUMSHELLIMAGESTOREDATA) CoTaskMemAlloc(sizeof(ENUMSHELLIMAGESTOREDATA));
        if (!pElt)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = StringCchCopyW(pElt->szPath, ARRAYSIZE(pElt->szPath), pNode->szName);
        if (FAILED(hr))
        {
            CoTaskMemFree(pElt);
            break;
        }
        pElt->ftTimeStamp = pNode->ftTimeStamp;

        prgElt[celtFetched] = pElt;

        celtFetched++;
    }

    if (FAILED(hr) && celtFetched)
    {
        // cleanup
        for (ULONG celtCleanup = 0; celtCleanup < celtFetched; celtCleanup++)
        {
            CoTaskMemFree(prgElt[celtCleanup]);
            prgElt[celtCleanup] = NULL;
        }
        celtFetched = 0;
    }

    if (pceltFetched)
    {
        *pceltFetched = celtFetched;
    }

    if (FAILED(hr))
        return hr;
    if (!celtFetched)
        return E_FAIL;
    return (celtFetched < celt) ? S_FALSE : S_OK;
}

STDMETHODIMP CEnumThumbStore::Skip(ULONG celt)
{
    if (!celt)
    {
        return E_INVALIDARG;
    }

    if (m_dwCatalogChange != m_pStore->m_dwCatalogChange)
    {
        return E_UNEXPECTED;
    }

    ULONG celtSkipped = 0;
    while (celtSkipped < celt &&m_pPos)
    {
        m_pStore->m_rgCatalog.GetNext(m_pPos);
    }

    if (!celtSkipped)
    {
        return E_FAIL;
    }

    return (celtSkipped < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CEnumThumbStore::Clone(IEnumShellImageStore ** ppEnum)
{
    CEnumThumbStore * pEnum = new CComObject<CEnumThumbStore>;
    if (!pEnum)
    {
        return E_OUTOFMEMORY;
    }

    ((IPersistFile *)m_pStore)->AddRef();

    pEnum->m_pStore = m_pStore;
    pEnum->m_dwCatalogChange = m_dwCatalogChange;

    // created with zero ref count....
    pEnum->AddRef();

    *ppEnum = SAFECAST(pEnum, IEnumShellImageStore *);

    return S_OK;
}

HRESULT CEnumThumbStore_Create(CThumbStore * pThis, IEnumShellImageStore ** ppEnum)
{
    CEnumThumbStore * pEnum = new CComObject<CEnumThumbStore>;
    if (!pEnum)
    {
        return E_OUTOFMEMORY;
    }

    ((IPersistFile *)pThis)->AddRef();

    pEnum->m_pStore = pThis;

    // created with zero ref count....
    pEnum->AddRef();

    *ppEnum = SAFECAST(pEnum, IEnumShellImageStore *);

    return S_OK;
}

HRESULT Version1ReadImage(IStream *pStream, DWORD cbSize, HBITMAP *phImage)
{
    *phImage = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    BITMAPINFO *pbi = (BITMAPINFO *) LocalAlloc(LPTR, cbSize);
    if (pbi)
    {
        hr = IStream_Read(pStream, pbi, cbSize);
        if (SUCCEEDED(hr))
        {
            HDC hdc = GetDC(NULL);
            if (hdc)
            {
                *phImage = CreateDIBitmap(hdc, &(pbi->bmiHeader), CBM_INIT, CalcBitsOffsetInDIB(pbi), pbi, DIB_RGB_COLORS);
                ReleaseDC(NULL, hdc);
                hr = S_OK;
            }
        }
        LocalFree(pbi);
    }
    return hr;
}

HRESULT CThumbStore::ReadImage(IStream *pStream, HBITMAP *phImage)
{
    STREAM_HEADER rgHead;
    HRESULT hr = IStream_Read(pStream, &rgHead, sizeof(rgHead));
    if (SUCCEEDED(hr))
    {
        if (rgHead.cbSize == sizeof(rgHead))
        {
            if (rgHead.dwFlags == STREAMFLAGS_DIB)
            {
                hr = Version1ReadImage(pStream, rgHead.ulSize, phImage);
            }
            else if (rgHead.dwFlags == STREAMFLAGS_JPEG)
            {
                // gdi+ will only accept the jpg stream if it's at the start of the
                // stream. We copy the jpeg into its own stream.
                IStream *pstmMem;
                hr = CreateStreamOnHGlobal(NULL, TRUE, &pstmMem);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER ulSize = { rgHead.ulSize };
                    hr = pStream->CopyTo(pstmMem, ulSize, NULL, NULL);
                    if (SUCCEEDED(hr))
                    {
                        LARGE_INTEGER liSeek = {0, 0};
                        hr = pstmMem->Seek(liSeek, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = DecompressImage(pstmMem, phImage);
                        }
                    }
                    pstmMem->Release();
                }     
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CThumbStore::WriteImage(IStream *pStream, HBITMAP hImage)
{
    STREAM_HEADER rgHead;
    
    // skip past the header. It will be writen when we know the image size.
    LARGE_INTEGER liSeek = { sizeof(rgHead) };
    HRESULT hr = pStream->Seek(liSeek, STREAM_SEEK_SET, NULL);
    if (SUCCEEDED(hr))
    {
        hr = CompressImage(pStream, hImage);
        if (SUCCEEDED(hr))
        {
            STATSTG stat;
            hr = pStream->Stat(&stat, STATFLAG_NONAME);
            if (SUCCEEDED(hr))
            {
                //now write the header
                rgHead.cbSize = sizeof(rgHead);
                rgHead.dwFlags = STREAMFLAGS_JPEG;
                rgHead.ulSize = stat.cbSize.QuadPart - sizeof(rgHead);
        
                //move to the beginning of the stream to write the header
                liSeek.QuadPart = 0;
                hr = pStream->Seek(liSeek, STREAM_SEEK_SET, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = IStream_Write(pStream, &rgHead, sizeof(rgHead));  
                }
            }
        }
    }
    return hr;
}

HRESULT CThumbStore::GetEntryStream(DWORD dwStream, DWORD dwMode, IStream **ppStream)
{
    WCHAR szStream[30];

    GenerateStreamName(szStream, ARRAYSIZE(szStream), dwStream);

    // leave only the STG_READ | STGM_READWRITE | STGM_WRITE modes
    dwMode &= STGM_READ | STGM_WRITE | STGM_READWRITE;

    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    if (_dwModeStorage != STGM_READWRITE && dwMode != _dwModeStorage)
    {
        return E_ACCESSDENIED;
    }

    DWORD dwFlags = GetAccessMode(dwMode, TRUE);
    if (dwFlags & STGM_WRITE)
    {
        _pStorageThumb->DestroyElement(szStream);
        return _pStorageThumb->CreateStream(szStream, dwFlags, NULL, NULL, ppStream);
    }
    else
    {
        return _pStorageThumb->OpenStream(szStream, NULL, dwFlags, NULL, ppStream);
    }
}

DWORD CThumbStore::GetAccessMode(DWORD dwMode, BOOL fStream)
{
    dwMode &= STGM_READ | STGM_WRITE | STGM_READWRITE;

    DWORD dwFlags = dwMode;

    // the root only needs Deny_Write, streams need exclusive....
    if (dwMode == STGM_READ && !fStream)
    {
        dwFlags |= STGM_SHARE_DENY_WRITE;
    }
    else
    {
        dwFlags |= STGM_SHARE_EXCLUSIVE;
    }

    return dwFlags;
}

const CLSID CLSID_JPEGCodec = { 0x557cf401, 0x1a04, 0x11d3, {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}};

HRESULT CThumbStore::CompressImage(IStream *pStream, HBITMAP hBmp)
{
    HRESULT hr = E_FAIL;
    
    // create the gdi+ bitmap
    Bitmap* pBitmap = new Bitmap(hBmp, NULL);
    if (pBitmap)
    {
        // Set the JPG Quailty
        EncoderParameters ep;

        ep.Parameter[0].Guid = EncoderQuality;
        ep.Parameter[0].Type = EncoderParameterValueTypeLong;
        ep.Parameter[0].NumberOfValues = 1;
        ep.Parameter[0].Value = &m_iThumbnailQuality;
        ep.Count = 1;

        // Save the Bitmap to the stream in JPG format
        hr = HR_FROM_STATUS(pBitmap->Save(pStream, &CLSID_JPEGCodec, &ep));
        delete pBitmap;
    } 
    return hr;
}

HRESULT CThumbStore::DecompressImage(IStream *pStream, HBITMAP *phBmp)
{
    HRESULT hr = E_FAIL;
  
    // Create gdi+ Bitmap from image stream
    Bitmap* pBitmap = new Bitmap(pStream, true);
    if (pBitmap)
    {   
        hr = HR_FROM_STATUS(pBitmap->GetHBITMAP(Color::Black, phBmp));
        delete pBitmap;
    }
    return hr;
}

HRESULT DeleteFileThumbnail(LPCWSTR szFilePath)
{
    WCHAR szFolder[MAX_PATH];
    WCHAR *szFile;
    HRESULT hr = E_FAIL;

    hr = StringCchCopyW(szFolder, ARRAYSIZE(szFolder), szFilePath);
    if (SUCCEEDED(hr))
    {
        szFile = PathFindFileName(szFolder);
        if (szFile != szFolder)
        {
            *(szFile - 1) = 0; // NULL terminates folder
            
            IShellImageStore *pDiskCache = NULL;
            hr = LoadFromFile(CLSID_ShellThumbnailDiskCache, szFolder, IID_PPV_ARG(IShellImageStore, &pDiskCache));
            if (SUCCEEDED(hr))
            {
                IPersistFile *pPersist = NULL;
                hr = pDiskCache->QueryInterface(IID_PPV_ARG(IPersistFile, &pPersist));
                if (SUCCEEDED(hr))
                {
                    hr = pPersist->Load(szFolder, STGM_READWRITE);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwLock;
                        hr = pDiskCache->Open(STGM_READWRITE, &dwLock);
                        if (SUCCEEDED(hr))
                        {
                            hr = pDiskCache->DeleteEntry(szFile);
                            pDiskCache->Close(&dwLock);
                        }
                    }
                    pPersist->Release();
                }
                pDiskCache->Release();
            }      

        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\tlist.h ===
/* Template class for doing a simple linked list ...
 */
 
#ifndef _TLIST_H
#define _TLIST_H

// the enum marker that remembers the current position
typedef void * CLISTPOS;

// template class for providing a doubly linked of pointers to nodes
template< class NODETYPE >
class CList
{
    protected:
        struct CNode
        {
            NODETYPE * m_pData;
            CNode * m_pPrev;
            CNode * m_pNext;
        };
        
    public:
    CList();
    ~CList();


    CLISTPOS GetHeadPosition();
    NODETYPE * GetNext( CLISTPOS & rpCurPos );
    int GetCount();
    void RemoveAt( CLISTPOS pPos );
    void RemoveAll( void );
    CLISTPOS FindIndex( int iIndex );
    CLISTPOS AddTail( NODETYPE * pData );
    CLISTPOS AddBefore( CLISTPOS pPos, NODETYPE * pData );

#ifdef DEBUG
    void ValidateList();
#define VALIDATELIST()    ValidateList()
#else
#define VALIDATELIST()
#endif
    
    protected:
        CNode * m_pHead;
        CNode * m_pTail;
};

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CList<NODETYPE>::CList()
{
    m_pHead = NULL;
    m_pTail = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CList<NODETYPE>::~CList()
{
    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::GetHeadPosition( )
{
    return (CLISTPOS) m_pHead;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
NODETYPE * CList<NODETYPE>::GetNext( CLISTPOS & rpCurPos )
{
    ASSERT( rpCurPos != NULL );
    CNode * pCur = (CNode *) rpCurPos;

    NODETYPE * pData = pCur->m_pData;
    rpCurPos = (CLISTPOS) pCur->m_pNext;
        
    return pData;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
int CList<NODETYPE>::GetCount()
{
    int iLength = 0;
    CNode * pCur = m_pHead;

    while ( pCur != NULL )
    {
        pCur = pCur->m_pNext;
        iLength ++;
    }

    return iLength;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
void CList<NODETYPE>::RemoveAt( CLISTPOS pPos )
{
    ASSERT( pPos != NULL );
    
#ifdef _DEBUG
    // scan the list to ensure the marker is valid....
    CNode * pCur = m_pHead;

    while ( pCur != NULL )
    {
        if ( pCur == (CNode *) pPos )
        {
            break;
        }
        pCur = pCur->m_pNext;
    }
    ASSERT( pCur != NULL )
#endif

    CNode * pRealPos = (CNode *) pPos;
    if ( pRealPos->m_pPrev == NULL )
    {
        // we are at the start of the list
        m_pHead = pRealPos->m_pNext;
    }
    else
    {
        // link the prev one to the next one (bypassing this one)
        pRealPos->m_pPrev->m_pNext = pRealPos->m_pNext;
    }
    
    if ( pRealPos->m_pNext == NULL )
    {
        // we are at the end of the list
        m_pTail = pRealPos->m_pPrev;
    }
    else
    {
        // link the next to the prev (bypassing this one)
        pRealPos->m_pNext->m_pPrev = pRealPos->m_pPrev;
    }

    LocalFree( pRealPos );

    VALIDATELIST();
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::FindIndex( int iIndex )
{
    ASSERT( iIndex >= 0 );

    CNode * pCur = m_pHead;
    while ( iIndex > 0 && pCur != NULL )
    {
        pCur = pCur->m_pNext;
        iIndex --;
    }

    return (CLISTPOS)(iIndex == 0 ? pCur : NULL );
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
void CList<NODETYPE>::RemoveAll( void )
{
    // note we will not free the data elements, the client must do this...
    CNode * pCur = m_pHead;

    while (pCur != NULL )
    {
        CNode * pTmp = pCur->m_pNext;

        LocalFree( pCur );
        pCur = pTmp;
    }

    m_pHead = m_pTail = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::AddTail( NODETYPE * pData )
{
    CNode * pCurTail = m_pTail;
    CNode * pNewNode = (CNode * ) LocalAlloc( GPTR, sizeof( CNode ));

    if ( pNewNode == NULL )
    {
        return NULL;
    }

    pNewNode->m_pData = pData;
    pNewNode->m_pPrev = pCurTail;
    pNewNode->m_pNext = NULL;
    
    m_pTail = pNewNode;
    
    if ( pCurTail != NULL )
    {
        // we are not an empty list
        pCurTail->m_pNext = pNewNode;
    }
    else
    {
        m_pHead = pNewNode;
    }

    VALIDATELIST();
    
    return (CLISTPOS) pNewNode;
}


/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::AddBefore( CLISTPOS pPos, NODETYPE * pData )
{
    if ( !pPos )
    {
        return NULL;
    }

    CNode * pPrev = (CNode *) pPos;
    CNode * pNewNode = (CNode * ) LocalAlloc( GPTR, sizeof( CNode ));
    if ( pNewNode == NULL )
    {
        return NULL;
    }

    pNewNode->m_pData = pData;
    pNewNode->m_pPrev = pPrev->m_pPrev;
    pNewNode->m_pNext = pPrev;

    if ( pPrev->m_pPrev != NULL )
    {
        pPrev->m_pPrev->m_pNext = pNewNode;
    }
    else
    {
        // must be at the start of the list...
        m_pHead = pNewNode;
    }
    
    pPrev->m_pPrev = pNewNode;

    VALIDATELIST();
    
    return (CLISTPOS) pNewNode;
}

/////////////////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
template< class NODETYPE >
void CList<NODETYPE>::ValidateList( )
{
    CNode * pPos = m_pHead;
    while ( pPos )
    {
        ASSERT( pPos->m_pData );
        if ( pPos != m_pHead )
        {
            ASSERT( pPos->m_pPrev );
        }
        pPos = pPos->m_pNext;
    }

    pPos = m_pTail;
    while ( pPos )
    {
        ASSERT( pPos->m_pData );
        if ( pPos != m_pTail )
        {
            ASSERT( pPos->m_pNext );
        }
        pPos = pPos->m_pPrev;
    }
    if ( m_pHead || m_pTail )
    {
        ASSERT( !m_pHead->m_pPrev );
        ASSERT( m_pTail );
        ASSERT( m_pHead );
        ASSERT( !m_pTail->m_pNext );
    }
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\thumbutil.cpp ===
#include "shellprv.h"
#include "ocmm.h"
#include "thumbutil.h"

typedef UCHAR BGR3[3];

class CThumbnailMaker
{
public:
    CThumbnailMaker();
    ~CThumbnailMaker();

    void Scale(BGR3 *pDst, UINT uiDstWidth, int iDstStep, const BGR3 *pSrc, UINT uiSrcWidth, int iSrcStep);
    HRESULT Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight);
    HRESULT AddScanline(UCHAR *pucSrc, UINT uiY);
    HRESULT AddDIBSECTION(BITMAPINFO *pBMI, void *pBits);
    HRESULT GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize);
    HRESULT GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize);

private:
    UINT _uiDstWidth, _uiDstHeight;
    UINT _uiSrcWidth, _uiSrcHeight;
    BGR3 *_pImH;
};

CThumbnailMaker::CThumbnailMaker()
{
    _pImH = NULL;
}

CThumbnailMaker::~CThumbnailMaker()
{
    if (_pImH)
        delete[] _pImH;
}

HRESULT CThumbnailMaker::Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight)
{
    _uiDstWidth = uiDstWidth;
    _uiDstHeight = uiDstHeight;
    _uiSrcWidth = uiSrcWidth;
    _uiSrcHeight = uiSrcHeight;

    if (_uiDstWidth < 1 || _uiDstHeight < 1 ||
        _uiSrcWidth < 1 || _uiSrcHeight < 1)
        return E_INVALIDARG;

    if (_pImH)
        delete[] _pImH;

    _pImH = new BGR3[_uiDstWidth * _uiSrcHeight];
    if (_pImH == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

void CThumbnailMaker::Scale(      BGR3 *pDst, UINT dxDst, int iDstBytStep, 
                            const BGR3 *pSrc, UINT dxSrc, int iSrcBytStep)
{
    int mnum = dxSrc;
    int mden = dxDst;

    // Scaling up, use a triangle filter.
    if (mden >= mnum)
    {
        int frac = 0;

        // Adjust the slope so that we calculate the fraction of the
        // "next" pixel to use (i.e. should be 0 for the first and
        // last dst pixel).
        --mnum;
        if (--mden == 0)
            mden = 0; // avoid div by 0

        BGR3 *pSrc1 = (BGR3 *)(((UCHAR *)pSrc) + iSrcBytStep);

        for (UINT x = 0; x < dxDst; x++)
        {
            if (frac == 0)
            {
                (*pDst)[0] = (*pSrc)[0];
                (*pDst)[1] = (*pSrc)[1];
                (*pDst)[2] = (*pSrc)[2];
            }
            else
            {
                (*pDst)[0] = ((mden - frac) * (*pSrc)[0] + frac * (*pSrc1)[0]) / mden;
                (*pDst)[1] = ((mden - frac) * (*pSrc)[1] + frac * (*pSrc1)[1]) / mden;
                (*pDst)[2] = ((mden - frac) * (*pSrc)[2] + frac * (*pSrc1)[2]) / mden;
            }

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);

            frac += mnum;
            if (frac >= mden)
            {
                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
                pSrc1 = (BGR3 *)((UCHAR *)pSrc1 + iSrcBytStep);
            }
        }
    }
    // Scaling down, use a box filter.
    else
    {
        int frac = 0;

        for (UINT x = 0; x < dxDst; x++)
        {
            UINT uiSum[3] = {0, 0, 0};
            UINT uiCnt = 0;

            frac += mnum;
            while (frac >= mden)
            {
                uiSum[0] += (*pSrc)[0];
                uiSum[1] += (*pSrc)[1];
                uiSum[2] += (*pSrc)[2];
                uiCnt++;

                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
            }

            (*pDst)[0] = uiSum[0] / uiCnt;
            (*pDst)[1] = uiSum[1] / uiCnt;
            (*pDst)[2] = uiSum[2] / uiCnt;

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);
        }
    }
}

//
// For AddScanline, we scale the input horizontally into our temporary
// image buffer.
//
HRESULT CThumbnailMaker::AddScanline(UCHAR *pSrc, UINT uiY)
{
    if (pSrc == NULL || uiY >= _uiSrcHeight)
        return E_INVALIDARG;

    Scale(_pImH + uiY * _uiDstWidth, _uiDstWidth, sizeof(BGR3), (BGR3 *)pSrc, _uiSrcWidth, sizeof(BGR3));

    return S_OK;
}

// For GetBITMAPINFO, we complete the scaling vertically and return the
// result as a DIB.
HRESULT CThumbnailMaker::GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
    *ppBMInfo = NULL;

    DWORD dwBPL = (((_uiDstWidth * 24) + 31) >> 3) & ~3;
    DWORD dwTotSize = sizeof(BITMAPINFOHEADER) + dwBPL * _uiDstHeight;

    BITMAPINFO *pBMI = (BITMAPINFO *)CoTaskMemAlloc(dwTotSize);
    if (pBMI == NULL)
        return E_OUTOFMEMORY;

    BITMAPINFOHEADER *pBMIH = &pBMI->bmiHeader;
    pBMIH->biSize = sizeof(*pBMIH);
    pBMIH->biWidth = _uiDstWidth;
    pBMIH->biHeight = _uiDstHeight;
    pBMIH->biPlanes = 1;
    pBMIH->biBitCount = 24;
    pBMIH->biCompression = BI_RGB;
    pBMIH->biXPelsPerMeter = 0;
    pBMIH->biYPelsPerMeter = 0;
    pBMIH->biSizeImage = dwBPL * _uiDstHeight;
    pBMIH->biClrUsed = 0;
    pBMIH->biClrImportant = 0;

    UCHAR *pDst = (UCHAR *)pBMIH + pBMIH->biSize + (_uiDstHeight - 1) * dwBPL;

    for (UINT x = 0; x < _uiDstWidth; x++)
    {
        Scale((BGR3 *)pDst + x, _uiDstHeight, -(int)dwBPL,
              _pImH + x, _uiSrcHeight, _uiDstWidth * sizeof(BGR3));
    }

    *ppBMInfo = pBMI;
    *pdwSize = dwTotSize;

    return S_OK;
}

HRESULT CThumbnailMaker::GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
#define SCALE 10000

    if (uiSharpPct > 100)
        return E_INVALIDARG;

    // Get the unsharpened bitmap.
    DWORD dwSize;
    HRESULT hr = GetBITMAPINFO(ppBMInfo, &dwSize);
    if (FAILED(hr))
        return hr;

    *pdwSize = dwSize;

    // Create a duplicate to serve as the original.
    BITMAPINFO *pBMISrc = (BITMAPINFO *)new UCHAR[dwSize];
    if (pBMISrc == NULL)
    {
        delete *ppBMInfo;
        return E_OUTOFMEMORY;
    }
    memcpy(pBMISrc, *ppBMInfo, dwSize);

    int bpl = (pBMISrc->bmiHeader.biWidth * 3 + 3) & ~3;

    //
    // Sharpen inside a 1 pixel border
    //
    UCHAR *pucDst = (UCHAR *)*ppBMInfo + sizeof(BITMAPINFOHEADER);
    UCHAR *pucSrc[3];
    pucSrc[0] = (UCHAR *)pBMISrc + sizeof(BITMAPINFOHEADER);
    pucSrc[1] = pucSrc[0] + bpl;
    pucSrc[2] = pucSrc[1] + bpl;

    int wdiag = (10355 * uiSharpPct) / 100;
    int wadj = (14645 * uiSharpPct) / 100;
    int wcent = 4 * (wdiag + wadj);

    for (int y = 1; y < pBMISrc->bmiHeader.biHeight-1; ++y)
    {
        for (int x = 3*(pBMISrc->bmiHeader.biWidth-2); x >= 3; --x)
        {
            int v = pucDst[x] +
                (pucSrc[1][x] * wcent -
                 ((pucSrc[0][x - 3] +
                   pucSrc[0][x + 3] +
                   pucSrc[2][x - 3] +
                   pucSrc[2][x + 3]) * wdiag +
                  (pucSrc[0][x] +
                   pucSrc[1][x - 3] +
                   pucSrc[1][x + 3] +
                   pucSrc[2][x]) * wadj)) / SCALE;

            pucDst[x] = v < 0 ? 0 : v > 255 ? 255 : v;
        }

        pucDst += bpl;
        pucSrc[0] = pucSrc[1];
        pucSrc[1] = pucSrc[2];
        pucSrc[2] += bpl;
    }

    delete[] pBMISrc;

    return S_OK;
#undef SCALE
}

HRESULT ThumbnailMaker_Create(CThumbnailMaker **ppThumbMaker)
{
    *ppThumbMaker  = new CThumbnailMaker;
    return *ppThumbMaker ? S_OK : E_OUTOFMEMORY;
}

HRESULT CThumbnailMaker::AddDIBSECTION(BITMAPINFO *pBMI, void *pBits)
{
    RGBQUAD *pRGBQ, *pQ;
    UCHAR *pucBits0, *pucBits, *pB, *pucBits240, *pucBits24, *pB24;
    int bpl;
    int x, y, ncolors;
    ULONG rmask, gmask, bmask;
    int rshift, gshift, bshift;
    HRESULT hr;

    //
    // Make sure that thumbnail maker has been properly initialized.
    //
    if (pBMI == NULL)
        return E_INVALIDARG;

    if (pBMI->bmiHeader.biWidth != (LONG)_uiSrcWidth ||
        pBMI->bmiHeader.biHeight != (LONG)_uiSrcHeight)
        return E_INVALIDARG;

    //
    // Don't handle RLE.
    //
    if (pBMI->bmiHeader.biCompression != BI_RGB &&
        pBMI->bmiHeader.biCompression != BI_BITFIELDS)
        return E_INVALIDARG;

    pRGBQ = (RGBQUAD *)&pBMI->bmiColors[0];

    ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;

    //
    // Decode 16/32bpp with masks.
    //
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            rmask = ((ULONG *)pRGBQ)[0];
            gmask = ((ULONG *)pRGBQ)[1];
            bmask = ((ULONG *)pRGBQ)[2];
            ncolors = 3;
        }
        else if (pBMI->bmiHeader.biBitCount == 16)
        {
            rmask = 0x7c00;
            gmask = 0x03e0;
            bmask = 0x001f;
        }
        else /* 32 */
        {
            rmask = 0xff0000;
            gmask = 0x00ff00;
            bmask = 0x0000ff;
        }

        for (rshift = 0; (rmask & 1) == 0; rmask >>= 1, ++rshift);
        if (rmask == 0)
            rmask = 1;
        for (gshift = 0; (gmask & 1) == 0; gmask >>= 1, ++gshift);
        if (gmask == 0)
            gmask = 1;
        for (bshift = 0; (bmask & 1) == 0; bmask >>= 1, ++bshift);
        if (bmask == 0)
            bmask = 1;
    }

    bpl = ((pBMI->bmiHeader.biBitCount * _uiSrcWidth + 31) >> 3) & ~3;

    pucBits0 = (UCHAR *) pBits;
    pucBits = pucBits0;

    if (pBMI->bmiHeader.biBitCount == 24)
        pucBits240 = pucBits;
    else
    {
        int bpl24 = (_uiSrcWidth * 3 + 3) & ~3;

        pucBits240 = new UCHAR[bpl24];
        if (pucBits240 == NULL)
            return E_OUTOFMEMORY;
    }
    pucBits24 = pucBits240;

    hr = S_OK;

    for (y = 0; y < (int)_uiSrcHeight; ++y)
    {
        pB = pucBits;
        pB24 = pucBits24;

        switch (pBMI->bmiHeader.biBitCount)
        {
        case 1:
            for (x = _uiSrcWidth; x >= 8; x -= 8)
            {
                pQ = &pRGBQ[(*pB >> 7) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 6) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 5) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 4) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 3) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 2) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 1) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB++) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                int shf = 8;

                do
                {
                    pQ = &pRGBQ[(*pB >> --shf) & 1];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
                while (--x);
            }

            break;

        case 4:
            for (x = _uiSrcWidth; x >= 2; x -= 2)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[*pB++ & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                if (x > 1)
                {
                    pQ = &pRGBQ[*pB & 0xf];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
            }

            break;

        case 8:
            for (x = _uiSrcWidth; x--;)
            {
                pQ = &pRGBQ[*pB++];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            break;

        case 16:
        {
            USHORT *pW = (USHORT *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG w = *pW++;

                *pB24++ = (UCHAR)
                     ((((w >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((w >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((w >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        case 24:
            pucBits24 = pucBits;
            break;

        case 32:
        {
            ULONG *pD;

            pD = (ULONG *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG d = *pD++;

                *pB24++ = (UCHAR)
                     ((((d >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((d >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((d >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        default:
            delete[] pucBits24;
            return E_INVALIDARG;
        }

        hr = AddScanline(pucBits24, (_uiSrcHeight-1) - y);
        if (FAILED(hr))
            break;

        pucBits += bpl;
    }

    if (pucBits240 != pucBits0)
        delete[] pucBits240;

    return hr;
}

UINT CalcImageSize(const SIZE *prgSize, DWORD dwClrDepth)
{
    UINT uSize = prgSize->cx * dwClrDepth;
    
    uSize *= (prgSize->cy < 0) ? (- prgSize->cy) : prgSize->cy;
    // divide by 8
    UINT uRetVal = uSize >> 3;

    if (uSize & 7)
    {
        uRetVal++;
    }

    return uRetVal;
}

BOOL ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                  HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                  DWORD dwRecClrDepth, HPALETTE hpal, UINT uiSharpPct, BOOL fOrigSize)
{
    BITMAPINFO *pbiScaled = pbi, *pbiUsed = pbi;
    BITMAPINFOHEADER *pbih = (BITMAPINFOHEADER *)pbi;
    BOOL bRetVal = FALSE, bInverted = FALSE;
    RECT rect;
    HRESULT hr;
    void *pScaledBits = pBits;

    // the scaling code doesn't handle inverted bitmaps, so we treat
    // them as if they were normal, by inverting the height here and
    // then setting it back before doing a paint.
    if (pbi->bmiHeader.biHeight < 0)
    {
        pbi->bmiHeader.biHeight *= -1;
        bInverted = TRUE;
    }

    rect.left = 0;
    rect.top = 0;
    rect.right = pbih->biWidth;
    rect.bottom = pbih->biHeight;
    
    CalculateAspectRatio(prgSize, &rect);

    // only bother with the scaling and sharpening if we are messing with the size...
    if ((rect.right - rect.left != pbih->biWidth) || (rect.bottom - rect.top != pbih->biHeight))
    {
        CThumbnailMaker *pThumbMaker;
        hr = ThumbnailMaker_Create(&pThumbMaker);
        if (SUCCEEDED(hr))
        {
            // initialize thumbnail maker. 
            hr = pThumbMaker->Init(rect.right - rect.left, rect.bottom - rect.top, 
                                    pbi->bmiHeader.biWidth, abs(pbi->bmiHeader.biHeight));
            if (SUCCEEDED(hr))
            {
                // scale image.
                hr = pThumbMaker->AddDIBSECTION(pbiUsed, pBits);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSize;
                    hr = pThumbMaker->GetSharpenedBITMAPINFO(uiSharpPct, &pbiScaled, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        pScaledBits = (LPBYTE)pbiScaled + sizeof(BITMAPINFOHEADER);
                    }
                }
            }
            delete pThumbMaker;
        }

        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    // set the height back to negative if that's the way it was before.
    if (bInverted == TRUE)
        pbiScaled->bmiHeader.biHeight *= -1;

    // now if they have asked for origsize rather than the boxed one, and the colour depth is OK, then 
    // return it...
    if (fOrigSize && pbiScaled->bmiHeader.biBitCount <= dwRecClrDepth)
    {
        SIZE rgCreateSize = { pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight };
        void *pNewBits;
        
        // turn the PbiScaled DIB into a HBITMAP...., note we pass the old biInfo so that it can get the palette form
        // it if need be.
        bRetVal = CreateSizedDIBSECTION(&rgCreateSize, pbiScaled->bmiHeader.biBitCount, NULL, pbiScaled, phBmpThumbnail, NULL, &pNewBits);

        if (bRetVal)
        {
            // copy the image data accross...
            CopyMemory(pNewBits, pScaledBits, CalcImageSize(&rgCreateSize, pbiScaled->bmiHeader.biBitCount)); 
        }
        
        return bRetVal;
    }
    
    bRetVal = FactorAspectRatio(pbiScaled, pScaledBits, prgSize, rect,
                                 dwRecClrDepth, hpal, fOrigSize, GetSysColor(COLOR_WINDOW), phBmpThumbnail);

    if (pbiScaled != pbi)
    {
        // free the allocated image...
        CoTaskMemFree(pbiScaled);
    }

    return bRetVal;
}

// This function makes no assumption about whether the thumbnail is square, so 
// it calculates the scaling ratio for both dimensions and the uses that as
// the scaling to maintain the aspect ratio.
//
void CalcAspectScaledRect(const SIZE *prgSize, RECT *pRect)
{
    ASSERT(pRect->left == 0);
    ASSERT(pRect->top == 0);

    int iWidth = pRect->right;
    int iHeight = pRect->bottom;
    int iXRatio = MulDiv(iWidth, 1000, prgSize->cx);
    int iYRatio = MulDiv(iHeight, 1000, prgSize->cy);

    if (iXRatio > iYRatio)
    {
        pRect->right = prgSize->cx;
        
        // work out the blank space and split it evenly between the top and the bottom...
        int iNewHeight = MulDiv(iHeight, 1000, iXRatio); 
        if (iNewHeight == 0)
        {
            iNewHeight = 1;
        }
        
        int iRemainder = prgSize->cy - iNewHeight;

        pRect->top = iRemainder / 2;
        pRect->bottom = iNewHeight + pRect->top;
    }
    else
    {
        pRect->bottom = prgSize->cy;

        // work out the blank space and split it evenly between the left and the right...
        int iNewWidth = MulDiv(iWidth, 1000, iYRatio);
        if (iNewWidth == 0)
        {
            iNewWidth = 1;
        }
        int iRemainder = prgSize->cx - iNewWidth;
        
        pRect->left = iRemainder / 2;
        pRect->right = iNewWidth + pRect->left;
    }
}
    
void CalculateAspectRatio(const SIZE *prgSize, RECT *pRect)
{
    int iHeight = abs(pRect->bottom - pRect->top);
    int iWidth = abs(pRect->right - pRect->left);

    // check if the initial bitmap is larger than the size of the thumbnail.
    if (iWidth > prgSize->cx || iHeight > prgSize->cy)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = iWidth;
        pRect->bottom = iHeight;

        CalcAspectScaledRect(prgSize, pRect);
    }
    else
    {
        // if the bitmap was smaller than the thumbnail, just center it.
        pRect->left = (prgSize->cx - iWidth) / 2;
        pRect->top = (prgSize->cy- iHeight) / 2;
        pRect->right = pRect->left + iWidth;
        pRect->bottom = pRect->top + iHeight;
    }
}

LPBYTE g_pbCMAP = NULL;

STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits, 
                                const SIZE *prgSize, RECT rect, DWORD dwClrDepth, 
                                HPALETTE hpal, BOOL fOrigSize, COLORREF clrBk, HBITMAP *phBmpThumbnail)
{
    HDC                 hdc = CreateCompatibleDC(NULL);
    BITMAPINFOHEADER    *pbih = (BITMAPINFOHEADER *)pbiScaled;
    BOOL                bRetVal = FALSE;
    int                 iRetVal = GDI_ERROR;
    BITMAPINFO *        pDitheredInfo = NULL;
    void *              pDitheredBits = NULL;
    HBITMAP             hbmpDithered = NULL;
    
    if (hdc)
    {
        if (dwClrDepth == 8)
        {
            RGBQUAD *pSrcColors = NULL;
            LONG nSrcPitch = pbiScaled->bmiHeader.biWidth;
            
            // we are going to 8 bits per pixel, we had better dither everything 
            // to the same palette.
            GUID guidType = CLSID_NULL;
            switch(pbiScaled->bmiHeader.biBitCount)
            {
            case 32:
                guidType = BFID_RGB_32;
                nSrcPitch *= sizeof(DWORD);
                break;
                
            case 24:
                guidType = BFID_RGB_24;
                nSrcPitch *= 3;
                break;
                
            case 16:
                // default is 555
                guidType = BFID_RGB_555;
                
                // 5-6-5 bitfields has the second DWORD (the green component) as 0x7e00
                if (pbiScaled->bmiHeader.biCompression == BI_BITFIELDS && 
                    pbiScaled->bmiColors[1].rgbGreen == 0x7E)
                {
                    guidType = BFID_RGB_565;
                }
                nSrcPitch *= sizeof(WORD);
                break;
                
            case 8:
                guidType = BFID_RGB_8;
                pSrcColors = pbiScaled->bmiColors;
                
                // nSrcPitch is already in bytes...
                break;
            };
            
            if (nSrcPitch % 4)
            {
                // round up to the nearest DWORD...
                nSrcPitch = nSrcPitch + 4 - (nSrcPitch %4);
            }
            
            // we are going to 8bpp
            LONG nDestPitch = pbiScaled->bmiHeader.biWidth;
            if (nDestPitch % 4)
            {
                // round up to the nearest DWORD...
                nDestPitch = nDestPitch + 4 - (nDestPitch % 4);
            }
            
            if (guidType != CLSID_NULL)
            {
                if (g_pbCMAP == NULL)
                {
                    // we are always going to the shell halftone palette right now, otherwise
                    // computing this inverse colour map consumes a lot of time (approx 2 seconds on
                    // a p200)
                    if (FAILED(SHGetInverseCMAP((BYTE *)&g_pbCMAP, sizeof(g_pbCMAP))))
                    {
                        return FALSE;
                    }
                }   
                
                SIZE rgDithered = {pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight};
                if (rgDithered.cy < 0)
                {
                    // invert it
                    rgDithered.cy = -rgDithered.cy;
                }
                
                if (CreateSizedDIBSECTION(&rgDithered, dwClrDepth, hpal, NULL, &hbmpDithered, &pDitheredInfo, &pDitheredBits))
                {
                    ASSERT(pDitheredInfo && pDitheredBits);
                    
                    // dither....
                    IIntDitherer *pDither;
                    HRESULT hr = CoCreateInstance(CLSID_IntDitherer, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IIntDitherer, &pDither));
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = pDither->DitherTo8bpp((LPBYTE) pDitheredBits, nDestPitch, 
                            (LPBYTE) pScaledBits, nSrcPitch, guidType, 
                            pDitheredInfo->bmiColors, pSrcColors,
                            g_pbCMAP, 0, 0, rgDithered.cx, rgDithered.cy,
                            -1, -1);
                        
                        pDither->Release();
                    }
                    if (SUCCEEDED(hr))
                    {
                        // if the height was inverted, then invert it in the destination bitmap
                        if (rgDithered.cy != pbiScaled->bmiHeader.biHeight)
                        {
                            pDitheredInfo->bmiHeader.biHeight = - rgDithered.cy;
                        }
                        
                        // switch to the new image .....
                        pbiScaled = pDitheredInfo;
                        pScaledBits = pDitheredBits;
                    }
                }
            }
        }
        
        // create thumbnail bitmap and copy image into it.
        if (CreateSizedDIBSECTION(prgSize, dwClrDepth, hpal, NULL, phBmpThumbnail, NULL, NULL))
        {
            HBITMAP hBmpOld = (HBITMAP) SelectObject(hdc, *phBmpThumbnail);
            
            SetStretchBltMode(hdc, COLORONCOLOR);
            
            HGDIOBJ hBrush = CreateSolidBrush(clrBk);
            HGDIOBJ hPen = GetStockObject(WHITE_PEN);
            
            HGDIOBJ hOldBrush = SelectObject(hdc, hBrush);
            HGDIOBJ hOldPen = SelectObject(hdc, hPen);
            
            HPALETTE hpalOld;
            if (hpal)
            {
                hpalOld = SelectPalette(hdc, hpal, TRUE);
                RealizePalette(hdc);
            }
            
            SetMapMode(hdc, MM_TEXT);
            
            Rectangle(hdc, 0, 0, prgSize->cx, prgSize->cy);
            
            int iDstHt = rect.bottom - rect.top;
            int iDstTop = rect.top, iSrcTop = 0;
            if (pbih->biHeight < 0)
            {
                iDstHt *= -1;
                iDstTop = rect.bottom;
                iSrcTop = abs(pbih->biHeight);
            }
            
            iRetVal = StretchDIBits(hdc, rect.left, iDstTop, rect.right - rect.left, iDstHt, 
                0, iSrcTop, pbih->biWidth, pbih->biHeight, 
                pScaledBits, pbiScaled, DIB_RGB_COLORS,  SRCCOPY);
            
            SelectObject(hdc, hOldBrush);
            DeleteObject(hBrush);
            SelectObject(hdc, hOldPen);
            if (hpal)
            {
                SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }
            
            SelectObject(hdc, hBmpOld);
        }
        
        DeleteDC(hdc);
    }
    
    if (hbmpDithered)
    {
        DeleteObject(hbmpDithered);
    }
    if (pDitheredInfo)
    {
        LocalFree(pDitheredInfo);
    }
    
    return (iRetVal != GDI_ERROR);
}


STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal, 
                                    const BITMAPINFO *pCurInfo, HBITMAP *phBmp, BITMAPINFO **ppBMI, void **ppBits)
{
    *phBmp = NULL;
    
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HDC hdcBmp = CreateCompatibleDC(hdc);
        if (hdcBmp)
        {
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(dib.bi);
            dib.bi.biWidth           = prgSize->cx;
            dib.bi.biHeight          = prgSize->cy;
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) dwClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = CalcImageSize(prgSize, dwClrDepth);
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = (dwClrDepth <= 8) ? (1 << dwClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            HPALETTE hpalOld = NULL;
            BOOL bDIB = TRUE;
        
            if (dwClrDepth <= 8)
            {
                // if they passed us the old structure with colour info, and we are the same bit depth, then copy it...
                if (pCurInfo && pCurInfo->bmiHeader.biBitCount == dwClrDepth)
                {
                    // use the passed in colour info to generate the DIBSECTION
                    int iColours = pCurInfo->bmiHeader.biClrUsed;

                    if (!iColours)
                    {
                        iColours = dib.bi.biClrUsed;
                    }

                    // copy the data accross...
                    if (iColours <= 256)
                    {
                        CopyMemory(dib.ct, pCurInfo->bmiColors, sizeof(RGBQUAD) * iColours);
                    }
                    else
                    {
                        bDIB = FALSE;
                    }
                }
                else
                {
                    // need to get the right palette....
                    hpalOld = SelectPalette(hdcBmp, hpal, TRUE);
                    RealizePalette(hdcBmp);
            
                    int n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);

                    ASSERT(n >= (int) dib.bi.biClrUsed);

                    // now convert the PALETTEENTRY to RGBQUAD
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                    {
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                    }
                }
            }

            if (bDIB)
            {
                void *pbits;
                *phBmp = CreateDIBSection(hdcBmp, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &pbits, NULL, 0);
                if (*phBmp)
                {
                    if (ppBMI)
                    {
                        *ppBMI = (BITMAPINFO *)LocalAlloc(LPTR, sizeof(dib));
                        if (*ppBMI)
                        {
                            CopyMemory(*ppBMI, &dib, sizeof(dib));
                        }
                    }
                    if (ppBits)
                    {
                        *ppBits = pbits;
                    }
                }
            }
            DeleteDC(hdcBmp);
        }
        ReleaseDC(NULL, hdc);
    }
    return (*phBmp != NULL);
}

STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }
    return (void *)((UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\tooltip.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Tooltip.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements displaying a tooltip balloon.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

#include "shellprv.h"
#include "Tooltip.h"

BOOL IsBiDiLocalizedSystem( void );

//  --------------------------------------------------------------------------
//  CTooltip::CTooltip
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process/DLL.
//              hwndParent  =   HWND of the parenting window.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CTooltip. Creates a tooltip window and
//              prepares it for display.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

CTooltip::CTooltip (HINSTANCE hInstance, HWND hwndParent) :
    _hwnd(NULL),
    _hwndParent(hwndParent)

{
    DWORD   dwExStyle;

    if (((GetWindowLongA(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) != 0) || IsBiDiLocalizedSystem())
    {
        dwExStyle = WS_EX_LAYOUTRTL;
    }
    else
    {
        dwExStyle = 0;
    }
    _hwnd = CreateWindowEx(dwExStyle,
                           TOOLTIPS_CLASS,
                           NULL,
                           WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           hwndParent,
                           NULL,
                           hInstance,
                           NULL);
    if (_hwnd != NULL)
    {
        TBOOL(SetWindowPos(_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE));
        (LRESULT)SendMessage(_hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);

        TOOLINFO toolInfo = { 0 };

        toolInfo.cbSize = sizeof(toolInfo);
        toolInfo.uFlags = TTF_TRANSPARENT | TTF_TRACK;
        toolInfo.uId = PtrToUint(_hwnd);
        (LRESULT)SendMessage(_hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(&toolInfo));
        (LRESULT)SendMessage(_hwnd, TTM_SETMAXTIPWIDTH, 0, 300);
    }
}

//  --------------------------------------------------------------------------
//  CTooltip::~CTooltip
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CTooltip class. This destroys the tooltip
//              window created. If the parent of the tooltip window is
//              destroyed before this is invoked user32!DestroyWindow will
//              cause the trace to fire. The object's lifetime must be
//              carefully managed by the user of this class.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

CTooltip::~CTooltip (void)

{
    if (_hwnd != NULL)
    {
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CTooltip::SetPosition
//
//  Arguments:  lPosX   =   X position of the balloon tip window (screen).
//              lPosY   =   Y position of the balloon tip window (screen).
//
//  Returns:    <none>
//
//  Purpose:    Positions the tooltip window at the given screen co-ordinates.
//              If the parameters are defaulted then this positions the
//              tooltip relative to the parent.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetPosition (LONG lPosX, LONG lPosY)  const

{
    if ((lPosX == LONG_MIN) && (lPosY == LONG_MIN))
    {
        RECT    rc;

        TBOOL(GetWindowRect(_hwndParent, &rc));
        lPosX = (rc.left + rc.right) / 2;
        lPosY = rc.bottom;
    }
    (LRESULT)SendMessage(_hwnd, TTM_TRACKPOSITION, 0, MAKELONG(lPosX, lPosY));
}

//  --------------------------------------------------------------------------
//  CTooltip::SetCaption
//
//  Arguments:  dwIcon      =   Icon type to set for the tooltip caption.
//              pszCaption  =   Caption of the tooltip.
//
//  Returns:    <none>
//
//  Purpose:    Sets the tooltip caption.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetCaption (DWORD dwIcon, const TCHAR *pszCaption)          const

{
    (LRESULT)SendMessage(_hwnd, TTM_SETTITLE, dwIcon, reinterpret_cast<LPARAM>(pszCaption));
}

//  --------------------------------------------------------------------------
//  CTooltip::SetText
//
//  Arguments:  pszText     =   Content of the actual tooltip.
//
//  Returns:    <none>
//
//  Purpose:    Sets the tooltip text.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetText (const TCHAR *pszText)                              const

{
    TOOLINFO toolInfo = { 0 };

    toolInfo.cbSize = sizeof(toolInfo);
    toolInfo.uId = PtrToUint(_hwnd);
    toolInfo.lpszText = const_cast<TCHAR*>(pszText);
    (LRESULT)SendMessage(_hwnd, TTM_UPDATETIPTEXT, 0, reinterpret_cast<LPARAM>(&toolInfo));
}

//  --------------------------------------------------------------------------
//  CTooltip::Show
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the tooltip window.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::Show (void)                                                 const

{
    TOOLINFO toolInfo = { 0 };

    toolInfo.cbSize = sizeof(toolInfo);
    toolInfo.uId = PtrToUint(_hwnd);
    (LRESULT)SendMessage(_hwnd, TTM_TRACKACTIVATE, TRUE, reinterpret_cast<LPARAM>(&toolInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\thunktxt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       thunktxt.c
//
//  Contents:   Support routines to thunk API parameters ANSI <-> UNICODE
//
//  Functions:  ConvertStrings()
//
//  History:    2-03-95   davepl   Created
//
//--------------------------------------------------------------------------

#include <shellprv.h>
#pragma  hdrstop

//+-------------------------------------------------------------------------
//
//  Function:   ConvertStrings
//
//  Synopsis:   Converts a series of XCHAR strings into TCHAR strings,
//              packed as a series of pointers followed by a contiguous
//              block of memory where the output strings are stored.
//
//              Eg: ConvertStrings(4, "Hello", "", NULL, "World");
//
//              Returns a pointer to a block of memory as follows:
//
//              4  bytes         <address of L"Hello">
//              4  bytes         <address of L"">
//              4  bytes         NULL
//              4  bytes         <address of L"World">
//              12 bytes         L"Hello\0"
//              2  bytes         L"\0"
//              12 bytes         L"World\0"
//              ---------------------------------------------------
//              42 bytes
//
//              The strings may then be referenced as ThunkText.m_pStr[0],
//              [1], [2], and [3], where [2] is a NULL pointer.
//
//              When the caller is finished with the strings, the entire
//              block should be freed via LocalAlloc().
//
//  Arguments:  [cCount]            -- Number of strings passed, incl NULs
//              [pszOriginalString] -- The strings to convert
//              (... etc ...)
//
//  Returns:    Pointer to a ThunkText structure
//
//  History:    2-03-95   davepl   Created
//
//  Notes:      In UNICODE builds, converts ANSI to UNICODE.  In ANSI
//              builds, converts to UNICODE (if present).
//
//--------------------------------------------------------------------------

#ifdef UNICODE

ThunkText * ConvertStrings(UINT cCount, ...)
{
    ThunkText *  pThunkText   = NULL;
    UINT         cTmp;
    LPXSTR       pXChar;
    UINT         cchResult;

    va_list     vaListMarker;

    //
    // Byte count is size of fixed members plus cCount pointers.  cbOffset
    // is the offset at which we will begin dumping strings into the struct
    //

    UINT cbStructSize =  SIZEOF(ThunkText) + (cCount - 1) * SIZEOF(LPTSTR);
    UINT cbOffset     =  cbStructSize;

    //
    // Scan the list of input strings, and add their lengths (in bytes, once
    // converted to TCHARs, incl NUL) to the output structure size
    //

    cTmp = 0;
    va_start(vaListMarker, cCount);
    do
    {
        pXChar = va_arg(vaListMarker, LPXSTR);
        if (pXChar)
        {
            #ifdef UNICODE

            cchResult = MultiByteToWideChar(CP_ACP,      // code page
                                            0,           // flags
                                            pXChar,      // source XCHAR
                                            -1,          // assume NUL term
                                            NULL,        // no buffer yet, computing size
                                            0 );         // no buffer yet, computing size
            #else

            cchResult = WideCharToMultiByte(CP_ACP,      // code page
                                            0,           // flags
                                            pXChar,      // source XCHAR
                                            -1,          // assume NUL term
                                            NULL,        // no buffer yet, computing size
                                            0,           // no buffer yet, computing size
                                            NULL,        // default char
                                            NULL);       // &fDefUsed
            #endif

            //
            // Even a NUL string returns a 1 character conversion, so 0 means
            // the conversion failed.  Cleanup and bail.
            //

            if (0 == cchResult)
            {
                SetLastError((DWORD)E_FAIL);
                return NULL;
            }

            cbStructSize += cchResult * SIZEOF(TCHAR);
        }
        cTmp++;
    }
    while (cTmp < cCount);

    //
    // Allocate the output structure.
    //

    pThunkText = (ThunkText *) LocalAlloc(LMEM_FIXED, cbStructSize);
    if (NULL == pThunkText)
    {
        SetLastError((DWORD)E_OUTOFMEMORY);
        return NULL;
    }

    //
    // Convert each of the input strings into the allocated output
    // buffer.
    //

    cTmp = 0;
    va_start(vaListMarker, cCount);
    do
    {
        INT cchResult;
        
        pXChar = va_arg(vaListMarker, LPXSTR);      // grab next src XSTR

        if (NULL == pXChar)
        {
            pThunkText->m_pStr[cTmp] = NULL;
        }
        else
        {
            pThunkText->m_pStr[cTmp] = (LPTSTR)(((LPBYTE)pThunkText) + cbOffset);

        

            #ifdef UNICODE

            cchResult = MultiByteToWideChar(CP_ACP,      // code page
                                            0,           // flags
                                            pXChar,      // source XCHAR
                                            -1,          // assume NUL term
                                            pThunkText->m_pStr[cTmp],  //outbuf
                                            (cbStructSize - cbOffset) / sizeof(WCHAR) ); //buflen
            #else

            cchResult = WideCharToMultiByte(CP_ACP,      // code page
                                            0,           // flags
                                            pXChar,      // source XCHAR
                                            -1,          // assume NUL term
                                            pThunkText->m_pStr[cTmp], //outbuf
                                            (cbStructSize - cbOffset) / sizeof(CHAR),  //buflen
                                            NULL,        // default char
                                            NULL);       // &fDefUsed
            #endif

            //
            // Even a NUL string returns a 1 character conversion, so 0 means
            // the conversion failed.  Cleanup and bail.
            //

            if (0 == cchResult)
            {
                LocalFree(pThunkText);
                SetLastError((DWORD)E_FAIL);
                return NULL;
            }

            cbOffset += cchResult * SIZEOF(TCHAR);
         }
         cTmp++;
    } while (cTmp < cCount);

    return pThunkText;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\tooltip.h ===
//  --------------------------------------------------------------------------
//  Module Name: Tooltip.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements displaying a tooltip balloon.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _Tooltip_
#define     _Tooltip_

#include <limits.h>

//  --------------------------------------------------------------------------
//  CTooltip
//
//  Purpose:    A class that displays a tool tip balloon. It does all the
//              creation and positioning work if required. Control the life
//              span of the balloon with the object's life span.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

class   CTooltip
{
    private:
                        CTooltip (void);
    public:
                        CTooltip (HINSTANCE hInstance, HWND hwndParent);
                        ~CTooltip (void);

                void    SetPosition (LONG lPosX = LONG_MIN, LONG lPosY = LONG_MIN)  const;
                void    SetCaption (DWORD dwIcon, const TCHAR *pszCaption)          const;
                void    SetText (const TCHAR *pszText)                              const;
                void    Show (void)                                                 const;
    private:
                HWND    _hwnd;
                HWND    _hwndParent;
};

#endif  /*  _Tooltip_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\tracker.cpp ===
//
//  History:    1-Mar-95   BillMo      Created.
//              ...
//              01-Dec-96  MikeHill    Converted to new NT5 implementation.
#include "shellprv.h"
#pragma hdrstop

#define LINKDATA_AS_CLASS
#include <linkdata.hxx>
#include "shelllnk.h"

// NTRAID95363-2000-03-19:  These four inlines are copied from private\net\svcdlls\trksvcs\common\trklib.hxx
// They should be moved to linkdata.hxx

inline
CDomainRelativeObjId::operator == (const CDomainRelativeObjId &Other) const
{
    return(_volume == Other._volume && _object == Other._object);
}

inline
CDomainRelativeObjId::operator != (const CDomainRelativeObjId &Other) const
{
    return !(*this == Other);
}

inline
CVolumeId:: operator == (const CVolumeId & Other) const
{
    return(0 == memcmp(&_volume, &Other._volume, sizeof(_volume)));
}

inline
CVolumeId:: operator != (const CVolumeId & Other) const
{
    return ! (Other == *this);
}

//+----------------------------------------------------------------------------
//
//  Function:   RPC free/alloc routines
//
//  Synopsis:   CTracker uses MIDL-generated code to call an RPC server,
//              and MIDL-generated code assumes that the following routines
//              be provided.
//
//+----------------------------------------------------------------------------

void __RPC_USER MIDL_user_free(void __RPC_FAR *pv) 
{ 
    LocalFree(pv); 
}


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t s) 
{ 
    return (void __RPC_FAR *) LocalAlloc(LMEM_FIXED, s); 
}

//+----------------------------------------------------------------------------
//
//  Method:     IUnknown methods
//
//  Synopsis:   IUnknown methods for the ISLTracker interface.
//
//+----------------------------------------------------------------------------

STDMETHODIMP CTracker::QueryInterface(REFIID riid, void **ppvObj)
{
    return _psl->QueryInterface(riid, ppvObj);
}

STDMETHODIMP_(ULONG) CTracker::AddRef()
{
    return _psl->AddRef();
}

STDMETHODIMP_(ULONG) CTracker::Release()
{
    return _psl->Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     ISLTracker custom methods
//
//  Synopsis:   This interface is private and is only used for testing.
//              This provides test programs the ability to specify the
//              TrackerRestrictions (from the TrkMendRestrictions enum)
//              and the ability to get the internal IDs.
//
//+----------------------------------------------------------------------------

HRESULT CTracker::Resolve(HWND hwnd, DWORD dwResolveFlags, DWORD dwTracker)
{
    return _psl->_Resolve(hwnd, dwResolveFlags, dwTracker);
}

HRESULT CTracker::GetIDs(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid)
{
    if (!_fLoaded)
        return E_UNEXPECTED;

    *pdroidBirth = _droidBirth;
    *pdroidLast = _droidLast;
    *pmcid = _mcidLast;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  Synopsis:   Initializes the data members used for RPC.  This should be
//              called either by InitNew or Load.
//
//  Arguments:  None
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------


HRESULT CTracker::InitRPC()
{
    HRESULT hr = S_OK;

    if (!_fCritsecInitialized)
    {
        if (!InitializeCriticalSectionAndSpinCount(&_cs, 0))
        {
            hr = E_FAIL;
            goto Exit;
        }        
        _fCritsecInitialized = TRUE;
    }

    if (NULL == _pRpcAsyncState)
    {
        _pRpcAsyncState = new RPC_ASYNC_STATE;
        if (NULL == _pRpcAsyncState)
        {
            hr = HRESULT_FROM_WIN32(E_OUTOFMEMORY);
            goto Exit;
        }
    }

    if (NULL == _hEvent)
    {
        _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); // Auto-reset, not initially signaled
        if (NULL == _hEvent)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

Exit:

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Synopsis:   Initializes the CTracker object.  This method may be called
//              repeatedly, i.e. it may be called to clear/reinit the object.
//              This method need not be called before calling the Load method.
//
//  Arguments:  None
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------

HRESULT CTracker::InitNew()
{
    HRESULT hr = InitRPC();
    if (SUCCEEDED(hr)) 
    {
        _mcidLast = CMachineId();
        _droidLast = CDomainRelativeObjId();
        _droidBirth = CDomainRelativeObjId();

        _fDirty = FALSE;
        _fLoaded = FALSE;
        _fMendInProgress = FALSE;
        _fUserCancelled = FALSE;
    }
    return hr;
}   // CTracker::InitNew()


//+----------------------------------------------------------------------------
//
//  Synopsis:   Get tracking state from the given file handle.  Note that this
//              is expected to fail if the referrent file isn't on an
//              NTFS5 volume.
//          
//
//  Arguments:  [hFile]
//                  The file to track
//              [ptszFile]
//                  The name of the file
//
//  Returns:    [HRESULT]
//
//-----------------------------------------------------------------------------

HRESULT CTracker::InitFromHandle(const HANDLE hFile, const TCHAR* ptszFile)
{
    NTSTATUS status = STATUS_SUCCESS;

    FILE_OBJECTID_BUFFER fobOID = {0};
    DWORD cbReturned;

    CDomainRelativeObjId droidLast;
    CDomainRelativeObjId droidBirth;
    CMachineId           mcidLast;

    // Initialize the RPC members

    HRESULT hr = InitRPC();
    if (FAILED(hr)) 
        goto Exit;

    //  -----------------------------------
    //  Get the Object ID Buffer (64 bytes)
    //  -----------------------------------

    // Use the file handle to get the file's Object ID.  Tell the filesystem to give us the
    // existing object ID if the file already has one, or to create a new one otherwise.

    if (!DeviceIoControl(hFile, FSCTL_CREATE_OR_GET_OBJECT_ID,
                          NULL, 0,                      // No input buffer
                          &fobOID, sizeof(fobOID),      // Output buffer
                          &cbReturned, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //  ----------------------
    //  Load the Droids & MCID
    //  ----------------------

    status = droidLast.InitFromFile(hFile, fobOID);
    if (!NT_SUCCESS(status))
    {
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));
        goto Exit;
    }

    droidBirth.InitFromFOB(fobOID);
    droidBirth.GetVolumeId().Normalize();

    if (FAILED(mcidLast.InitFromPath(ptszFile, hFile)))
        mcidLast = CMachineId();

    //  ----
    //  Exit
    //  ----

    if (_mcidLast   != mcidLast
        ||
        _droidLast  != droidLast
        ||
        _droidBirth != droidBirth
     )
    {
        _mcidLast   = mcidLast;
        _droidLast  = droidLast;
        _droidBirth = droidBirth;
        _fDirty = TRUE;
    }

    _fLoaded = TRUE;            // Cleared in InitNew
    _fLoadedAtLeastOnce = TRUE; // Not cleared in InitNew

    hr = S_OK;

Exit:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Synopsis:   Load the tracker from the memory buffer.  The InitNew
//              method need not be called before calling this method.
//
//  Arguments:  [pb] -- buffer to load from
//              [cb] -- size of pb buffer
//
//  Returns:    [HRESULT]
//
//--------------------------------------------------------------------

#define CTRACKER_VERSION    0

HRESULT CTracker::Load(BYTE *pb, ULONG cb)
{
    DWORD dwLength;

    // Initialize RPC if it hasn't been already.

    HRESULT hr = InitRPC();
    if (FAILED(hr)) 
        goto Exit;

    // Check the length

    dwLength = *reinterpret_cast<DWORD*>(pb);
    if (dwLength < GetSize())
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    pb += sizeof(dwLength);

    // Check the version number

    if (CTRACKER_VERSION != *reinterpret_cast<DWORD*>(pb))
    {
        hr = HRESULT_FROM_WIN32(ERROR_REVISION_MISMATCH);
        goto Exit;
    }

    pb += sizeof(DWORD);    // Skip past the version

    // Get the machine ID & droids

    _mcidLast = *reinterpret_cast<CMachineId*>(pb);
    pb += sizeof(_mcidLast);

    _droidLast = *reinterpret_cast<CDomainRelativeObjId*>(pb);
    pb += sizeof(_droidLast);

    _droidBirth = *reinterpret_cast<CDomainRelativeObjId*>(pb);
    pb += sizeof(_droidBirth);

    _fLoaded = TRUE;            // Cleared in InitNew
    _fLoadedAtLeastOnce = TRUE; // Not cleared in InitNew


    hr = S_OK;

Exit:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CTracker::Save
//
//  Synopsis:   Save tracker to the given buffer.
//
//  Arguments:  [pb]     -- buffer for tracker.
//              [cbSize] -- size of buffer in pb
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID CTracker::Save(BYTE *pb, ULONG cbSize)
{
    // Save the length
    *reinterpret_cast<DWORD*>(pb) = GetSize();
    pb += sizeof(DWORD);

    // Save a version number
    *reinterpret_cast<DWORD*>(pb) = CTRACKER_VERSION;
    pb += sizeof(DWORD);

    // Save the machine & DROIDs

    *reinterpret_cast<CMachineId*>(pb) = _mcidLast;
    pb += sizeof(_mcidLast);

    *reinterpret_cast<CDomainRelativeObjId*>(pb) = _droidLast;
    pb += sizeof(_droidLast);

    *reinterpret_cast<CDomainRelativeObjId*>(pb) = _droidBirth;
    pb += sizeof(_droidBirth);

    _fDirty = FALSE;

}   // CTracker::Save()


//+-------------------------------------------------------------------
//
//  Synopsis:   Search for the object referred to by the tracker.
//
//  Arguments:  [dwTickCountDeadline] -- absolute tick count for deadline
//              [pfdIn]               -- may not be NULL
//              [pfdOut]              -- may not be NULL
//                                       will contain updated data on success
//              [uShlinkFlags]       -- SLR_ flags
//              [TrackerRestrictions] -- TrkMendRestrictions enumeration
//
//  Returns:    [HRESULT]
//               S_OK
//                  found (pfdOut contains new info)
//              E_UNEXPECTED
//                  CTracker::InitNew hasn't bee called.
//              HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED)
//                  Restrictions (set in registry) are set such that
//                  this operation isn't to be performed.
//
//--------------------------------------------------------------------


HRESULT CTracker::Search(const DWORD dwTickCountDeadline,
                         const WIN32_FIND_DATA *pfdIn,
                         WIN32_FIND_DATA *pfdOut,
                         UINT  uShlinkFlags,
                         DWORD TrackerRestrictions)
{
    HRESULT hr = S_OK;
    TCHAR ptszError = NULL;
    WIN32_FILE_ATTRIBUTE_DATA fadNew;
    WIN32_FIND_DATA fdNew = *pfdIn;
    DWORD cbFileName;
    BOOL fPotentialFileFound = FALSE;
    BOOL fLocked = FALSE;
    DWORD dwCurrentTickCount = 0;

    RPC_TCHAR          *ptszStringBinding = NULL;
    RPC_BINDING_HANDLE  BindingHandle;
    RPC_STATUS          rpcstatus;

    CDomainRelativeObjId droidBirth, droidLast, droidCurrent;
    CMachineId mcidCurrent;

    // Initialize the output

    ZeroMemory(pfdOut, sizeof(*pfdOut));

    // Abort if restrictions don't allow this operation

    if (SHRestricted(REST_NORESOLVETRACK) ||
        (SLR_NOTRACK & uShlinkFlags))
    {
        hr = HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED);
        goto Exit;
    }

    // Ensure that we've been loaded first

    else if (!_fLoaded)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Capture the current tick count

    dwCurrentTickCount = GetTickCount();

    if ((long) dwTickCountDeadline <= (long) dwCurrentTickCount)
    {
        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
        goto Exit;
    }


    //
    // Create an RPC binding
    //

    rpcstatus = RpcStringBindingCompose(NULL,
                                        TEXT("ncalrpc"),
                                        NULL,
                                        TRKWKS_LRPC_ENDPOINT_NAME,
                                        NULL,
                                        &ptszStringBinding);

    if (RPC_S_OK == rpcstatus)
        rpcstatus = RpcBindingFromStringBinding(ptszStringBinding, &BindingHandle);

    if (RPC_S_OK != rpcstatus)
    {
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    //
    // Initialize an RPC Async handle
    //

    //  Take the lock
    EnterCriticalSection(&_cs);  
    fLocked = TRUE;

    // Verify that we were initialized properly
    if (NULL == _hEvent || NULL == _pRpcAsyncState)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }
    
    rpcstatus = RpcAsyncInitializeHandle(_pRpcAsyncState, RPC_ASYNC_VERSION_1_0);
    if (RPC_S_OK != rpcstatus)
    {
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    _pRpcAsyncState->NotificationType = RpcNotificationTypeEvent;
    _pRpcAsyncState->u.hEvent = _hEvent;
    _pRpcAsyncState->UserInfo = NULL;


    //
    // Call the tracking service to find the file
    //

    __try
    {
        SYSTEMTIME stNow;
        FILETIME ftDeadline;
        DWORD dwDeltaMillisecToDeadline;

        // NOTE:  The following four assignments used to be above the
        // __try.  But that appears to trigger a compiler problem, where
        // some of the assignments do not make it to the .obj in an optimized
        // build (bug 265255).

        droidLast = _droidLast;
        droidBirth = _droidBirth;
        mcidCurrent = _mcidLast;

        cbFileName = sizeof(fdNew.cFileName);

        // Convert the tick-count deadline into a UTC filetime.

        dwDeltaMillisecToDeadline = (DWORD)((long)dwTickCountDeadline - (long)dwCurrentTickCount);
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &ftDeadline);
        *reinterpret_cast<LONGLONG*>(&ftDeadline) += (dwDeltaMillisecToDeadline * 10*1000);

        // Start the async RPC call to the tracking service

        _fMendInProgress = TRUE;
        LnkMendLink(_pRpcAsyncState,
                     BindingHandle,
                     ftDeadline,
                     TrackerRestrictions,
                     const_cast<CDomainRelativeObjId*>(&droidBirth),
                     const_cast<CDomainRelativeObjId*>(&droidLast),
                     const_cast<CMachineId*>(&_mcidLast),
                     &droidCurrent,
                     &mcidCurrent,
                     &cbFileName,
                     fdNew.cFileName);

        // Wait for the call to return.  Release the lock first, though, so that
        // the UI thread can come in and cancel.

        LeaveCriticalSection(&_cs); 
        fLocked = FALSE;
        
        DWORD dwWaitReturn = WaitForSingleObject(_hEvent, dwDeltaMillisecToDeadline);

        // Now take the lock back and see what happenned.

        EnterCriticalSection(&_cs); fLocked = TRUE;
        _fMendInProgress = FALSE;

        if ((WAIT_TIMEOUT == dwWaitReturn) || _fUserCancelled)
        {
            // We timed out waiting for a response.  Cancel the call.
            // If the call should complete between the time
            // we exited the WaitForSingleObject and the cancel call below,
            // then the cancel will be ignored by RPC.
            
            rpcstatus = RpcAsyncCancelCall(_pRpcAsyncState, TRUE); // fAbort

            if (_fUserCancelled)
            {
                _fUserCancelled = FALSE;
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                __leave;
            }
            else if (RPC_S_OK != rpcstatus)
            {
                hr = HRESULT_FROM_WIN32(rpcstatus);
                __leave;
            }
        }
        else if (WAIT_OBJECT_0 != dwWaitReturn)
        {
            // There was an error of some kind.
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        // Now we find out how the LnkMendLink call completed.  If we get
        // RPC_S_OK, then it completed normally, and the result is
        // in hr.

        rpcstatus = RpcAsyncCompleteCall(_pRpcAsyncState, &hr);
        if (RPC_S_OK != rpcstatus)
        {
            // The call either failed or was cancelled (the reason for the
            // cancel would be that the UI thread called CTracker::CancelSearch,
            // or because we timed out above and called RpcAsyncCancelCall).

            hr = HRESULT_FROM_WIN32(rpcstatus);
            __leave;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _fMendInProgress = FALSE;
        _fUserCancelled = FALSE;
        hr = HRESULT_FROM_WIN32(RpcExceptionCode());
    }


    // free the binding
    RpcBindingFree(&BindingHandle);

    if (HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND) == hr)
    {
        fPotentialFileFound = TRUE;
        hr = S_OK;
    }

    if (FAILED(hr)) goto Exit;

    //
    // See if this is in the recycle bin
    //

    if (IsFileInBitBucket(fdNew.cFileName))
    {
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Now that we know what the new filename is, let's get all
    // the FindData info.
    //

    if (!GetFileAttributesEx(fdNew.cFileName, GetFileExInfoStandard, &fadNew))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Ensure that the file we found has the same "directory-ness"
    // as the last known link source (either they're both a directory
    // or they're both a file).  Also ensure that the file we found
    // isn't itself a link client (a shell shortcut).

    if (((fadNew.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ^ (pfdIn->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            || PathIsLnk(fdNew.cFileName))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    // Copy the file attributes into the WIN32_FIND_DATA structure.

    fdNew.dwFileAttributes = fadNew.dwFileAttributes;
    fdNew.ftCreationTime = fadNew.ftCreationTime;
    fdNew.ftLastAccessTime = fadNew.ftLastAccessTime;
    fdNew.ftLastWriteTime = fadNew.ftLastWriteTime;
    fdNew.nFileSizeLow = fadNew.nFileSizeLow;

    // Return the new finddata to the caller.

    *pfdOut = fdNew;

    // Update our local state

    if ((_droidLast != droidCurrent) || (_droidBirth != droidBirth) || (_mcidLast != mcidCurrent))
    {
        _droidLast = droidCurrent;
        _droidBirth = droidBirth;
        _mcidLast = mcidCurrent;
        _fDirty = TRUE;
    }

Exit:

    if (fLocked)
        LeaveCriticalSection(&_cs);

    if (ptszStringBinding)
        RpcStringFree(&ptszStringBinding);

    if (FAILED(hr))
        DebugMsg(DM_TRACE, TEXT("CTracker::Search failed (hr=0x%08X)"), hr);
    else if (fPotentialFileFound)
        hr = HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND);

    return(hr);

}   // CTracker::Search()

//+----------------------------------------------------------------------------
//
//  Synopsis:   This method is called on a thread signal another thread
//              which is in CTracker::Search to abort the LnkMendLink
//              call.
//
//  Returns:    [HRESULT]
//
//-----------------------------------------------------------------------------

STDMETHODIMP CTracker::CancelSearch()
{
    EnterCriticalSection(&_cs);
    
    // If a search is in progress, cancel it.

    if (_fMendInProgress && NULL != _pRpcAsyncState)
    {
        _fUserCancelled = TRUE;
        SetEvent(_hEvent);  // SetEvent so as to unblock the Tracker Worker thread.         
    }

    LeaveCriticalSection(&_cs);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Look at a path and determine the computer name of the host machine.
//  In the future, we should remove this code, and add the capbility to query
//  handles for their computer name.
//
//  GetServerComputer name uses ScanForComputerName and ConvertDfsPath
//  as helper functions.
//
//  The name can only be obtained for NetBios paths - if the path is IP or DNS
//  an error is returned.  (If the NetBios name has a "." in it, it will
//  cause an error because it will be misinterpreted as a DNS path.  This case
//  becomes less and less likely as the NT5 UI doesn't allow such computer names.)
//  For DFS paths, the leaf server's name is returned, as long as it wasn't
//  joined to its parent with an IP or DNS path name.
//
//+----------------------------------------------------------------------------

const UNICODE_STRING NtUncPathNamePrefix = { 16, 18, L"\\??\\UNC\\"};
#define cchNtUncPathNamePrefix  8

const UNICODE_STRING NtDrivePathNamePrefix = { 8, 10, L"\\??\\" };
#define cchNtDrivePathNamePrefix  4

const WCHAR RedirectorMappingPrefix[] = { L"\\Device\\LanmanRedirector\\;" };
const WCHAR LocalVolumeMappingPrefix[] = { L"\\Device\\Volume" };
const WCHAR CDRomMappingPrefix[] = { L"\\Device\\CDRom" };
const WCHAR FloppyMappingPrefix[] = { L"\\Device\\Floppy" };
const WCHAR DfsMappingPrefix[] = { L"\\Device\\WinDfs\\" };


//
//  ScanForComputerName:
//
//  Scan the path in ServerFileName (which is a UNICODE_STRING with
//  a full NT path name), searching for the computer name.  If it's
//  found, point to it with UnicodeComputerName.Buffer, and set
//  *AvailableLength to show how much readable memory is after that
//  point.
//

HRESULT ScanForComputerName(HANDLE hFile, const UNICODE_STRING &ServerFileName,
                            UNICODE_STRING *UnicodeComputerName, ULONG *AvailableLength,
                            WCHAR *DosDeviceMapping, ULONG cchDosDeviceMapping,
                            PFILE_NAME_INFORMATION FileNameInfo, ULONG cbFileNameInfo,
                            BOOL *CheckForDfs)
{

    HRESULT hr = S_OK;

    // Is this a UNC path?

    if (RtlPrefixString((PSTRING)&NtUncPathNamePrefix, (PSTRING)&ServerFileName, TRUE)) 
    {
        // Make sure there's some more to this path than just the prefix
        if (ServerFileName.Length <= NtUncPathNamePrefix.Length)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

        // It appears to be a valid UNC path.  Point to the beginning of the computer
        // name, and calculate how much room is left in ServerFileName after that.

        UnicodeComputerName->Buffer = &ServerFileName.Buffer[ NtUncPathNamePrefix.Length/sizeof(WCHAR) ];
        *AvailableLength = ServerFileName.Length - NtUncPathNamePrefix.Length;
    }
    else if (RtlPrefixString((PSTRING)&NtDrivePathNamePrefix, (PSTRING)&ServerFileName, TRUE)
             &&
             ServerFileName.Buffer[ cchNtDrivePathNamePrefix + 1 ] == L':') 
    {
        // Get the correct, upper-cased, drive letter into DosDevice.

        WCHAR DosDevice[3] = { L"A:" };

        DosDevice[0] = ServerFileName.Buffer[ cchNtDrivePathNamePrefix ];
        if (L'a' <= DosDevice[0] && DosDevice[0] <= L'z')
            DosDevice[0] = L'A' + (DosDevice[0] - L'a');

        // Map the drive letter to its symbolic link under \??.  E.g., say D: & R:
        // are DFS/rdr drives, you would then see something like:
        //
        //   D: => \Device\WinDfs\G
        //   R: => \Device\LanmanRedirector\;R:0\scratch\scratch

        if (!QueryDosDevice(DosDevice, DosDeviceMapping, cchDosDeviceMapping))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        // Now that we have the DosDeviceMapping, we can check ... Is this a rdr drive?

        if (// Does it begin with "\Device\LanmanRedirector\;" ?
            0 == wcsncmp(DosDeviceMapping, RedirectorMappingPrefix, lstrlenW(RedirectorMappingPrefix))
            &&
            // Are the next letters the correct drive letter, a colon, and a whack?
            (DosDevice[0] == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) - 1 ]
              &&
              L':' == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) ]
              &&
              (UnicodeComputerName->Buffer = StrChrW(&DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) + 1 ], L'\\'))
           ))
        {
            // We have a valid rdr drive.  Point to the beginning of the computer
            // name, and calculate how much room is availble in DosDeviceMapping after that.

            UnicodeComputerName->Buffer += 1;
            *AvailableLength = sizeof(DosDeviceMapping) - sizeof(DosDeviceMapping[0]) * (ULONG)(UnicodeComputerName->Buffer - DosDeviceMapping);

            // We know now that it's not a DFS path
            *CheckForDfs = FALSE;
        }
        else if (0 == wcsncmp(DosDeviceMapping, DfsMappingPrefix, lstrlenW(DfsMappingPrefix)))
        {

            // Get the full UNC name of this DFS path.  Later, we'll call the DFS
            // driver to find out what the actual server name is.

            IO_STATUS_BLOCK IoStatusBlock;
            NTSTATUS NtStatus = NtQueryInformationFile(hFile,
                        &IoStatusBlock, FileNameInfo, cbFileNameInfo,  FileNameInformation);
            if (!NT_SUCCESS(NtStatus)) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
                goto Exit;
            }

            UnicodeComputerName->Buffer = FileNameInfo->FileName + 1;
            *AvailableLength = FileNameInfo->FileNameLength;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

    }   // else if (RtlPrefixString((PSTRING)&NtDrivePathNamePrefix, (PSTRING)&ServerFileName, TRUE) ...
    else 
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }
Exit:
    return hr;
}


//
//  Try to convert the path name pointed to by UnicodeComputerName.Buffer
//  into a DFS path name.  The caller provides DfsServerPathName as a buffer
//  for the converted name.  If it's a DFS path, then update UnicodeComputerName.Buffer
//  to point to the conversion, otherwise leave it unchanged.
//

HRESULT ConvertDfsPath(HANDLE hFile, UNICODE_STRING *UnicodeComputerName, 
                       ULONG *AvailableLength, WCHAR *DfsServerPathName, ULONG cbDfsServerPathName)
{
    HRESULT hr = S_OK;
    HANDLE hDFS = INVALID_HANDLE_VALUE;
    UNICODE_STRING DfsDriverName;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    WCHAR *DfsPathName = UnicodeComputerName->Buffer - 1;    // Back up to the whack
    ULONG DfsPathNameLength = *AvailableLength + sizeof(WCHAR);

    // Open the DFS driver

    RtlInitUnicodeString(&DfsDriverName, L"\\Dfs");
    InitializeObjectAttributes(&ObjectAttributes,
                                &DfsDriverName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                           );

    NtStatus = NtCreateFile(
                    &hDFS,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
               );

    if (!NT_SUCCESS(NtStatus)) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    // Query DFS's cache for the server name.  The name is guaranteed to
    // remain in the cache as long as the file is open.

    if (L'\\' != DfsPathName[0]) 
    {
        NtClose(hDFS);
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    NtStatus = NtFsControlFile(
                    hDFS,
                    NULL,       // Event,
                    NULL,       // ApcRoutine,
                    NULL,       // ApcContext,
                    &IoStatusBlock,
                    FSCTL_DFS_GET_SERVER_NAME,
                    DfsPathName,
                    DfsPathNameLength,
                    DfsServerPathName,
                    cbDfsServerPathName);
    NtClose(hDFS);

    // STATUS_OBJECT_NAME_NOT_FOUND means that it's not a DFS path
    if (!NT_SUCCESS(NtStatus)) 
    {

        if (STATUS_OBJECT_NAME_NOT_FOUND != NtStatus ) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }
    }
    else if (L'\0' != DfsServerPathName[0]) 
    {

        // The previous DFS call returns the server-specific path to the file in UNC form.
        // Point UnicodeComputerName to just past the two whacks.

        *AvailableLength = lstrlenW(DfsServerPathName) * sizeof(WCHAR);
        if (3*sizeof(WCHAR) > *AvailableLength
            ||
            L'\\' != DfsServerPathName[0]
            ||
            L'\\' != DfsServerPathName[1])
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

        UnicodeComputerName->Buffer = DfsServerPathName + 2;
        *AvailableLength -= 2 * sizeof(WCHAR);
    }

Exit:
    return hr;
}

//  Take pwszFile, which is a path to a remote machine, and get the 
//  server machine's computer name.

HRESULT GetRemoteServerComputerName(LPCWSTR pwszFile, HANDLE hFile, WCHAR *pwszComputer)
{
    HRESULT hr = S_OK;
    ULONG cbComputer = 0;
    ULONG AvailableLength = 0;
    PWCHAR PathCharacter = NULL;
    BOOL CheckForDfs = TRUE;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    WCHAR FileNameInfoBuffer[MAX_PATH+sizeof(FILE_NAME_INFORMATION)];
    PFILE_NAME_INFORMATION FileNameInfo = (PFILE_NAME_INFORMATION)FileNameInfoBuffer;
    WCHAR DfsServerPathName[ MAX_PATH + 1 ];
    WCHAR DosDeviceMapping[ MAX_PATH + 1 ];

    UNICODE_STRING UnicodeComputerName;
    UNICODE_STRING ServerFileName;

    // Canonicalize the file name into the NT object directory namespace.

    RtlInitUnicodeString(&UnicodeComputerName, NULL);
    RtlInitUnicodeString(&ServerFileName, NULL);
    if (!RtlDosPathNameToNtPathName_U(pwszFile, &ServerFileName, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    // Point UnicodeComputerName.Buffer at the beginning of the computer name.

    hr = ScanForComputerName(hFile, ServerFileName, &UnicodeComputerName, &AvailableLength,
                              DosDeviceMapping, ARRAYSIZE(DosDeviceMapping),
                              FileNameInfo, sizeof(FileNameInfoBuffer), &CheckForDfs);
    if (FAILED(hr)) 
        goto Exit;

    // If there was no error but we don't have a computer name, then the file is on 
    // the local computer.

    if (NULL == UnicodeComputerName.Buffer)
    {
        DWORD cchName = MAX_COMPUTERNAME_LENGTH + 1;
        hr = S_OK;

        if (!GetComputerNameW(pwszComputer, &cchName))
            hr = HRESULT_FROM_WIN32(GetLastError());

        goto Exit;
    }

    // If we couldn't determine above whether or not this is a DFS path, let the
    // DFS driver decide now.

    if (CheckForDfs && INVALID_HANDLE_VALUE != hFile) 
    {
        // On return, UnicodeComputerName.Buffer points to the leaf machine's
        // UNC name if it's a DFS path.  If it's not a DFS path, 
        // .Buffer is left unchanged.

        hr = ConvertDfsPath(hFile, &UnicodeComputerName, &AvailableLength,
                             DfsServerPathName, sizeof(DfsServerPathName));
        if (FAILED(hr))
            goto Exit;
    }

    // If we get here, then the computer name\share is pointed to by UnicodeComputerName.Buffer.
    // But the Length is currently zero, so we search for the whack that separates
    // the computer name from the share, and set the Length to include just the computer name.

    PathCharacter = UnicodeComputerName.Buffer;

    while(((ULONG) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer) < AvailableLength)
           &&
           *PathCharacter != L'\\') 
    {
        // If we found a '.', we fail because this is probably a DNS or IP name.
        if (L'.' == *PathCharacter) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

        PathCharacter++;
    }

    // Set the computer name length

    UnicodeComputerName.Length = UnicodeComputerName.MaximumLength
        = (USHORT) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer);

    // Fail if the computer name exceeded the length of the input ServerFileName,
    // or if the length exceeds that allowed.

    if (UnicodeComputerName.Length >= AvailableLength
        ||
        UnicodeComputerName.Length > MAX_COMPUTERNAME_LENGTH*sizeof(WCHAR)) 
    {
        goto Exit;
    }

    // Copy the computer name into the caller's buffer, as long as there's enough
    // room for the name & a terminating '\0'.

    if (UnicodeComputerName.Length + sizeof(WCHAR) > (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR)) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    CopyMemory(pwszComputer, UnicodeComputerName.Buffer, UnicodeComputerName.Length);
    pwszComputer[UnicodeComputerName.Length / sizeof(WCHAR)] = L'\0';

    hr = S_OK;

Exit:

    RtlFreeHeap(RtlProcessHeap(), 0, ServerFileName.Buffer);
    return hr;
}

//  Give a file's path & handle, determine the computer name of the server
//  on which that file resides (which could just be this machine).

HRESULT GetServerComputerName(LPCWSTR pwszFile, HANDLE hFile, WCHAR *pwszComputer)
{
    // pwszFile may be a local path name. Convert it into an absolute name.
    HRESULT hr;
    WCHAR wszAbsoluteName[ MAX_PATH + 1 ], *pwszFilePart;
    if (GetFullPathName(pwszFile, ARRAYSIZE(wszAbsoluteName), wszAbsoluteName, &pwszFilePart))
    {
        if (pwszFilePart)
            *pwszFilePart = 0;
        // Check to see if this points to a local or remote drive.  Terminate
        // the path at the beginning of the file name, so that the path ends in
        // a whack.  This allows GetDriveType to determine the type without being
        // give a root path.

        UINT DriveType = GetDriveType(wszAbsoluteName);

        if (DRIVE_REMOTE == DriveType)
        {
            // We have a remote drive (could be a UNC path or a redirected drive).
            hr = GetRemoteServerComputerName(wszAbsoluteName, hFile, pwszComputer);
        }
        else if (DRIVE_UNKNOWN == DriveType ||
                 DRIVE_NO_ROOT_DIR == DriveType)
        {
            // We have an unsupported type
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        }
        else
        {
            // We have a path to the local machine.

            DWORD cchName = MAX_COMPUTERNAME_LENGTH + 1;
            if (!GetComputerNameW(pwszComputer, &cchName))
                hr = HRESULT_FROM_WIN32(GetLastError());
            else
                hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\treewkcb.h ===
#include "treewalk.h" // for IShellTreeWalkerCallBack

class CBaseTreeWalkerCB : public IShellTreeWalkerCallBack
{
public:
    CBaseTreeWalkerCB();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd); 
    STDMETHODIMP LeaveFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws);
    STDMETHODIMP HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT hrError);

protected:
    virtual ~CBaseTreeWalkerCB();
    LONG _cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\treewalk.h ===
/*
 * TREEWALK.h -- Shell Icon Overlay Manager
 */

#ifndef _TREEWALK_H_
#define _TREEWALK_H_

//
// Prototypes for all modules
//
#ifdef __cplusplus
extern "C" {
#endif
    
STDAPI CShellTreeWalker_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID *  ppvOut);
#ifdef __cplusplus
};
#endif

BOOL   BeenThereDoneThat(LPCTSTR pszOriginal, LPCTSTR pszPath);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\uevttmr.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include <shguidp.h>
#include "uevttmr.h"

// 1. Use dpa callback system to delete the entire hdpa array

EXTERN_C const TCHAR c_szUserEventWindow[] = TEXT("UserEventWindow");

// *** IUnknown methods ***
STDMETHODIMP CUserEventTimer::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CUserEventTimer, IUserEventTimer),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CUserEventTimer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CUserEventTimer::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// *** Constructor and Destructor ***

CUserEventTimer::CUserEventTimer() : m_cRef(1)
{
}

CUserEventTimer::~CUserEventTimer()
{
    _Destroy();
}

// *** IUserEventTimer methods ***
HRESULT CUserEventTimer::SetUserEventTimer( 
    HWND hWnd,
    UINT uCallbackMessage,
    UINT uTimerElapse, 
    IUserEventTimerCallback * pUserEventTimerCallback,
    ULONG * puUserEventTimerID
)
{
    RIP(puUserEventTimerID != NULL);

    HRESULT hr;

    // Argument Validation
    if (!m_hWnd)
        hr = E_FAIL; 
    else if (!_dpaUserEventInfo)
        hr = E_OUTOFMEMORY;
    else if (!hWnd && !pUserEventTimerCallback)
        hr = E_INVALIDARG;
    else if (!puUserEventTimerID || uTimerElapse <= 0)
        hr = E_INVALIDARG;
    else if (hWnd)
    {
        int nIndex = _GetTimerDetailsIndex(hWnd, *puUserEventTimerID);
        if (nIndex >= 0)
            hr = _ResetUserEventTimer(hWnd, uCallbackMessage, uTimerElapse, nIndex);
        else
            hr = _SetUserEventTimer(hWnd, uCallbackMessage, uTimerElapse, pUserEventTimerCallback, puUserEventTimerID);
    }
    else 
    {
        ASSERT(pUserEventTimerCallback != NULL);
        hr = _SetUserEventTimer(hWnd, uCallbackMessage, uTimerElapse, pUserEventTimerCallback, puUserEventTimerID);
    }
    
    return hr;
}

HRESULT CUserEventTimer::InitTimerTickInterval(UINT uTimerTickIntervalMs)
{
    // If there is more than one registered client to the user event timer,
    // then we cannot change the timer tick interval
    if (_dpaUserEventInfo.GetPtrCount() > 0)
        return E_FAIL;
    
    if (uTimerTickIntervalMs > 0)
        m_uTimerTickInterval = uTimerTickIntervalMs;
    else
        m_uTimerTickInterval = TIMER_ELAPSE;

    return S_OK;
}

HRESULT CUserEventTimer::_SetUserEventTimer( 
    HWND hWnd,
    UINT uCallbackMessage,
    UINT uTimerElapse, 
    IUserEventTimerCallback * pUserEventTimerCallback,
    ULONG * puUserEventTimerID
)
{
    ASSERT(puUserEventTimerID);
    ASSERT(m_uTimerTickInterval > 0);

    HRESULT hr = E_OUTOFMEMORY;
    
    USEREVENTINFO * pUserEventInfo = new USEREVENTINFO;

    if (pUserEventInfo)
    {
        pUserEventInfo->hWnd = hWnd;
        if (hWnd)
        {
            pUserEventInfo->uCallbackMessage = uCallbackMessage;
            pUserEventInfo->uUserEventTimerID = *puUserEventTimerID;
        }
        else
        {
            pUserEventInfo->pUserEventTimerCallback = pUserEventTimerCallback;
        }

        // Timer ID cannot be zero..
        if (!pUserEventInfo->uUserEventTimerID)
        {
            ULONG uTimerID = _GetNextInternalTimerID(hWnd);
            if (uTimerID != -1)
                pUserEventInfo->uUserEventTimerID = uTimerID;
        }

        int nRetInsert = -1;
        if (pUserEventInfo->uUserEventTimerID)
        {
            pUserEventInfo->uTimerElapse = uTimerElapse;
            pUserEventInfo->uIntervalCountdown = _CalcNumIntervals(uTimerElapse);
            pUserEventInfo->bFirstTime = TRUE;

            nRetInsert = _dpaUserEventInfo.AppendPtr(pUserEventInfo);

            if (nRetInsert != -1)
            {
                *puUserEventTimerID = pUserEventInfo->uUserEventTimerID;
                if (!_uUserTimerID)
                {
                    _uUserTimerID = SetTimer(m_hWnd, TIMER_ID, m_uTimerTickInterval, NULL);
                }
            
                if (!_uUserTimerID)
                {
                    _dpaUserEventInfo.DeletePtr(_dpaUserEventInfo.GetPtrCount()-1);
                }
            }
        }

        hr = S_OK;
        if (nRetInsert == -1 || _uUserTimerID == 0)
        {
            *puUserEventTimerID = 0;
            delete (pUserEventInfo);
            hr = E_FAIL;
        }
        else if (NULL == hWnd)
        {
            IUnknown_SetSite(pUserEventTimerCallback, this);
            pUserEventTimerCallback->AddRef();
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!m_dwUserStartTime && _dpaUserEventInfo.GetPtrCount() == 1)
            m_dwUserStartTime = GetTickCount();
    }
        
    return hr;
}

HRESULT CUserEventTimer::_ResetUserEventTimer(
    HWND hWnd,
    UINT uCallbackMessage,
    UINT uTimerElapse, 
    int nIndex
)
{
    ASSERT(m_hWnd != NULL);
    ASSERT(_dpaUserEventInfo != NULL);
    ASSERT(hWnd != NULL);
    ASSERT(nIndex >= 0);

    USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(nIndex);

    ASSERT(pUserEventInfo);
    ASSERT(pUserEventInfo->hWnd == hWnd);

    pUserEventInfo->uTimerElapse = uTimerElapse;
    pUserEventInfo->uIntervalCountdown = _CalcNumIntervals(uTimerElapse);
    pUserEventInfo->bFirstTime = TRUE;

    return S_OK;
}

int DeleteCB(USEREVENTINFO * lpData1, LPVOID lpData2)
{
    USEREVENTINFO * pUserEventInfo = lpData1;
    ASSERT(pUserEventInfo);

#ifdef DEBUG
    BOOL bErrorCheck = (lpData2 ? (*(BOOL *)lpData2) : FALSE);
    if (bErrorCheck)
        TraceMsg(TF_WARNING, "CUserEventTimer::s_DeleteCB App hasnt killed timer hwnd = %u, timerID = %u",
            pUserEventInfo->hWnd, pUserEventInfo->uUserEventTimerID);
#endif

    IUserEventTimerCallback * pUserEventTimerCallback = 
        (pUserEventInfo->hWnd == NULL) ? pUserEventInfo->pUserEventTimerCallback : NULL;
    ASSERT(pUserEventInfo->hWnd || pUserEventTimerCallback);

    if (pUserEventTimerCallback)
    {
        IUnknown_SetSite(pUserEventTimerCallback, NULL);
        pUserEventTimerCallback->Release();
    }

    // Dangerous to delete pUserEventInfo here, but this function is called as the
    // DPA DestroyCallback, as well as from KillUserEventTimer
    // In KillUserEventTimer, we remove the event from the dpa, while in the callback,
    // we dont need to explicitly remove the event from the queue...
    delete pUserEventInfo;

    return TRUE;
}

HRESULT CUserEventTimer::GetUserEventTimerElapsed(
    HWND hWnd, 
    ULONG uUserEventTimerID, 
    UINT * puTimerElapsed)
{
    HRESULT hr = E_FAIL;

    if (!puTimerElapsed || !hWnd || !m_hWnd || !_dpaUserEventInfo)
        return hr;

    int nIndex = _GetTimerDetailsIndex(hWnd, uUserEventTimerID);
    if (nIndex >= 0)
    {
        USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(nIndex);

        *puTimerElapsed = _CalcMilliSeconds(
            _CalcNumIntervals(pUserEventInfo->uTimerElapse) - pUserEventInfo->uIntervalCountdown
        );
        hr = S_OK;
    }
    else
        *puTimerElapsed = 0;

    return hr;
}

HRESULT CUserEventTimer::KillUserEventTimer(HWND hWnd, ULONG uUserEventTimerID)
{
    HRESULT hr = E_FAIL;
    
    if (!m_hWnd || !_dpaUserEventInfo)
        return hr;

    int nIndex = _GetTimerDetailsIndex(hWnd, uUserEventTimerID);
    if (nIndex >= 0)
    {
        DeleteCB(_dpaUserEventInfo.GetPtr(nIndex), NULL);
        _dpaUserEventInfo.DeletePtr(nIndex);
        _KillIntervalTimer();
        
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    if (0 == _dpaUserEventInfo.GetPtrCount())
        m_dwUserStartTime = 0;

    return hr;
}

// Private helpers
HRESULT CUserEventTimer::Init()
{
    if (!_CreateWindow())
        return E_FAIL;

    if (!_dpaUserEventInfo.Create(4))
        return E_OUTOFMEMORY;

    m_uTimerTickInterval = TIMER_ELAPSE;

    ASSERT(!_uUserTimerID);
    ASSERT(!m_dwUserStartTime);

    return S_OK;
}

BOOL CUserEventTimer::_CreateWindow()
{
    if (!m_hWnd)
    {
        WNDCLASSEX wc;
        DWORD dwExStyle = WS_EX_STATICEDGE;

        ZeroMemory(&wc, sizeof(wc));
        wc.cbSize = sizeof(WNDCLASSEX);

        if (!GetClassInfoEx(HINST_THISDLL, c_szUserEventWindow, &wc))
        {
            wc.lpszClassName = c_szUserEventWindow;
            wc.style = CS_DBLCLKS;
            wc.lpfnWndProc = s_WndProc;
            wc.hInstance = HINST_THISDLL;
            wc.hCursor = LoadCursor(NULL, IDC_ARROW);
            wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
            wc.cbWndExtra = sizeof(CUserEventTimer *);

            if (!RegisterClassEx(&wc))
            {
                return FALSE;
            }
        }

        m_hWnd = CreateWindowEx(dwExStyle, c_szUserEventWindow,
                NULL, WS_POPUP, 0, 0, 0, 0,
                HWND_MESSAGE, NULL, HINST_THISDLL, (void *)this);

        if (!m_hWnd)
            return FALSE;
    }
    
    return TRUE;
}

void CUserEventTimer::_Destroy()
{   
    if (_dpaUserEventInfo)
    {
        BOOL bErrorCheck = TRUE;
        _dpaUserEventInfo.DestroyCallback(DeleteCB, &bErrorCheck);
    }
    
    _KillIntervalTimer();

    DestroyWindow(m_hWnd);
}

void CUserEventTimer::_KillIntervalTimer()
{
    if (_uUserTimerID)
    {
        if (_dpaUserEventInfo && _dpaUserEventInfo.GetPtrCount() == 0)
        {
            KillTimer(m_hWnd, _uUserTimerID);
            _uUserTimerID = 0;
        }
    }
}

ULONG CUserEventTimer::_GetNextInternalTimerID(HWND hWnd)
{
    ULONG uStartTimerID = MIN_TIMER_ID;

    for (; uStartTimerID <= MAX_TIMER_ID; uStartTimerID++)
    {
        if (!_IsAssignedTimerID(hWnd, uStartTimerID))
            break;
    }

    if (uStartTimerID > MAX_TIMER_ID)
        uStartTimerID = -1;
        
    return uStartTimerID;
}

int CUserEventTimer::_GetTimerDetailsIndex(HWND hWnd, ULONG uUserEventTimerID)
{
    if (!_dpaUserEventInfo || !uUserEventTimerID)
        return -1;

    for (int i = _dpaUserEventInfo.GetPtrCount()-1; i >= 0; i--)
    {
        USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(i);
        ASSERT(pUserEventInfo);

        if (pUserEventInfo->hWnd == hWnd && pUserEventInfo->uUserEventTimerID == uUserEventTimerID)
        {
            return i;
        }
    }

    return -1;
}

LRESULT CALLBACK CUserEventTimer::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUserEventTimer *puet = (CUserEventTimer *)GetWindowLongPtr(hwnd, 0);

    if (WM_CREATE == uMsg)
    {
        CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
        puet = (CUserEventTimer *)pcs->lpCreateParams;
        puet->m_hWnd = hwnd;
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)puet);
    }

    return puet ? puet->v_WndProc(uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CUserEventTimer::v_WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_TIMER:
        ASSERT(wParam == TIMER_ID);
        _OnTimer();
        return 0;
        
    default:
        return (DefWindowProc(m_hWnd, uMsg, wParam, lParam));
    }
}

void CUserEventTimer::_OnTimer()
{
    ASSERT(m_hWnd);

    if (_dpaUserEventInfo)
    {
        LONG uTimerDifference = -1;
        LASTINPUTINFO lii = {0};

        lii.cbSize = sizeof(LASTINPUTINFO);
        if (GetLastInputInfo(&lii))
        {
            if (lii.dwTime < m_dwUserStartTime)
                uTimerDifference = 0;
            else
                uTimerDifference = lii.dwTime - m_dwUserStartTime;
        }

        LONG uMinTimerDifferenceThreshold = (LONG) (m_uTimerTickInterval * (float)(1-MIN_TIMER_THRESHOLD));
        LONG uMaxTimerDifferenceThreshold = (LONG) (m_uTimerTickInterval * (float)(1+MAX_TIMER_THRESHOLD));

        for (int i = _dpaUserEventInfo.GetPtrCount()-1; i >= 0; i--)
        {
            USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(i);

            ASSERT(pUserEventInfo);

            if (uTimerDifference != 0)
            {
                if ( (uTimerDifference == -1) || 
                     (pUserEventInfo->bFirstTime && uTimerDifference > uMinTimerDifferenceThreshold && 
                                uTimerDifference <= uMaxTimerDifferenceThreshold) || 
                     (!pUserEventInfo->bFirstTime && uTimerDifference <= uMaxTimerDifferenceThreshold)
                )
                {
                    pUserEventInfo->uIntervalCountdown --;
                    if (pUserEventInfo->uIntervalCountdown == 0)
                    {
                        // Reset the countdown
                        pUserEventInfo->uIntervalCountdown = _CalcNumIntervals(pUserEventInfo->uTimerElapse);
                    
                        if (pUserEventInfo->hWnd)
                        {
                            PostMessage(pUserEventInfo->hWnd, 
                                pUserEventInfo->uCallbackMessage, 
                                (WPARAM) pUserEventInfo->uTimerElapse, 
                                (LPARAM) pUserEventInfo->uUserEventTimerID);
                        }
                        else
                        {
                            pUserEventInfo->pUserEventTimerCallback->UserEventTimerProc(
                                pUserEventInfo->uUserEventTimerID,
                                pUserEventInfo->uTimerElapse); 
                        }
                    }
                }
            }
            
            pUserEventInfo->bFirstTime = FALSE;
        }
        
        m_dwUserStartTime = GetTickCount();
    }
}


STDAPI CUserEventTimer_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CUserEventTimer * pUserEventTimer = new CUserEventTimer();
    if (!pUserEventTimer || FAILED(hr = pUserEventTimer->Init()))
    {
        *ppv = NULL;
    }
    else
    {
        hr = pUserEventTimer->QueryInterface(riid, ppv);
        pUserEventTimer->Release();  // Already have a ref count from new
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\treewkcb.cpp ===
#include "shellprv.h"
#include "treewkcb.h"
#include "propsht.h"

CBaseTreeWalkerCB::CBaseTreeWalkerCB(): _cRef(1)
{
}

CBaseTreeWalkerCB::~CBaseTreeWalkerCB()
{
}

HRESULT CBaseTreeWalkerCB::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBaseTreeWalkerCB, IShellTreeWalkerCallBack),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CBaseTreeWalkerCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CBaseTreeWalkerCB::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CBaseTreeWalkerCB::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    return E_NOTIMPL;
}

HRESULT CBaseTreeWalkerCB::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    return E_NOTIMPL;
}

HRESULT CBaseTreeWalkerCB::LeaveFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws)
{
    return E_NOTIMPL;
}

HRESULT CBaseTreeWalkerCB::HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT ErrorCode)
{
    return E_NOTIMPL;
}

//
// Folder size computation tree walker callback class
//
class CFolderSizeTreeWalkerCB : public CBaseTreeWalkerCB
{
public:
    CFolderSizeTreeWalkerCB(FOLDERCONTENTSINFO * pfci);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

protected:
    FOLDERCONTENTSINFO * _pfci;
    TREEWALKERSTATS _twsInitial;
}; 

CFolderSizeTreeWalkerCB::CFolderSizeTreeWalkerCB(FOLDERCONTENTSINFO * pfci): _pfci(pfci)
{
    // set the starting values for the twsInitial so we can have cumulative results
    _twsInitial.nFiles = _pfci->cFiles;
    _twsInitial.nFolders = _pfci->cFolders;
    _twsInitial.ulTotalSize = _pfci->cbSize;
    _twsInitial.ulActualSize = _pfci->cbActualSize;
}

HRESULT CFolderSizeTreeWalkerCB::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (_pfci->bContinue)
    {
        _pfci->cbSize = _twsInitial.ulTotalSize + ptws->ulTotalSize;
        _pfci->cbActualSize = _twsInitial.ulActualSize + ptws->ulActualSize;
        _pfci->cFiles = _twsInitial.nFiles + ptws->nFiles;
    }
    return _pfci->bContinue ? S_OK : E_FAIL;
}

HRESULT CFolderSizeTreeWalkerCB::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (_pfci->bContinue)
    {
        _pfci->cFolders = _twsInitial.nFolders + ptws->nFolders;
    }
    return _pfci->bContinue ? S_OK : E_FAIL;
}

//
//  Main function for folder size computation
//
STDAPI FolderSize(LPCTSTR pszDir, FOLDERCONTENTSINFO *pfci)
{
    HRESULT hrInit = SHCoInitialize();  // in case our caller did not do this

    HRESULT hr = E_FAIL;
    CFolderSizeTreeWalkerCB *pfstwcb = new CFolderSizeTreeWalkerCB(pfci);
    if (pfstwcb)
    {
        IShellTreeWalker *pstw;
        hr = CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &pstw));
        if (SUCCEEDED(hr))
        {
            hr = pstw->WalkTree(WT_NOTIFYFOLDERENTER, pszDir, NULL, 0, SAFECAST(pfstwcb, IShellTreeWalkerCallBack *));
            pstw->Release();
        }
        pfstwcb->Release();
    }

    SHCoUninitialize(hrInit);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\treewalk.cpp ===
// This file contains the implementation of CShellTreeWalker, a COM object
// that inherits IShellTreeWalker, and it will recursively enumerate all the
// files (or directories or both) starting from a root directory that match a
// certain spec. 
// 1. The tree walker is reparse point aware, it does not traverse into reparse 
// point folders by default, but will if specified
// 2. It keeps track of the number of files, directories, depth, and total
// size of all files encountered.
// 3. It will stop the traversal right away if any error message is returned
// from the callback functions except for E_NOTIMPL
// 4. It will jump out of the current working directory if S_FALSE is returned from callback
// functions.
//
// History:
//         12-5-97  by dli

#include "shellprv.h"
#include "validate.h"

#define IS_FILE_DIRECTORY(pwfd)     ((pwfd)->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
#define IS_FILE_REPARSE_POINT(pwfd) ((pwfd)->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

// Call back flags for _CallCallBack
#define STWCB_FILE     1
#define STWCB_ERROR    2
#define STWCB_ENTERDIR 3
#define STWCB_LEAVEDIR 4

#define TF_TREEWALKER 0

STDAPI_(DWORD) PathGetClusterSize(LPCTSTR pszPath);

class CShellTreeWalker : public IShellTreeWalker
{
public:
    CShellTreeWalker();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellTreeWalker
    STDMETHODIMP WalkTree(DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxPath, IShellTreeWalkerCallBack * pstwcb);

private:
    LONG _cRef;
    
    DWORD _dwFlags;     // Flags indicating the search status
    UINT _nMaxDepth;    // Maximum depth we walk into
    UINT _nDepth;       // Current depth
    UINT _nFiles;       // Number of files we have seen so far
    UINT _nDirs;        // Number of directories we have seen

    BOOL _bFolderFirst; // Do the folders first
    DWORD _dwClusterSize;    // the size of a cluster
    ULONGLONG _ulTotalSize;  // total size of all files we have seen
    ULONGLONG _ulActualSize; // total size on disk, taking into account compression, sparse files, and cluster slop

    TCHAR _szWalkBuf[MAX_PATH];         // The path buffer used in the walk
    LPCTSTR _pszWalkSpec;               // The spec we use in FindFirstFile and FindNextFile

    IShellTreeWalkerCallBack * _pstwcb; // The call back interface pointer
    
    WIN32_FIND_DATA  _wfd;              // The temp storage of WIN32_FIND_DATA 

    WIN32_FIND_DATA _fdTopLevelFolder;  // The top level folder info
    
    HRESULT _CallCallBacks(DWORD dwCallReason, WIN32_FIND_DATA * pwfd);
    HRESULT _ProcessAndRecurse(WIN32_FIND_DATA * pwfd);
    HRESULT _TreeWalkerHelper();
    BOOL _PathAppend(LPTSTR pszPath, LPCTSTR pszMore); // we have our own PatAppend that dosen't whack pszPath in failure cases
}; 

CShellTreeWalker::CShellTreeWalker() : _cRef(1) 
{
    ASSERT(_dwFlags == 0);
    ASSERT(_bFolderFirst == FALSE);
    ASSERT(_nMaxDepth == 0);
    ASSERT(_nDepth == 0);
    ASSERT(_nDirs == 0);
    ASSERT(_ulTotalSize == 0);
    ASSERT(_ulActualSize == 0);
    ASSERT(_pszWalkSpec == NULL);
    ASSERT(_pstwcb == NULL);
    ASSERT(_szWalkBuf[0] == 0);
}

// _CallCallBack: convert the TCHARs to WCHARs and call the callback functions
HRESULT CShellTreeWalker::_CallCallBacks(DWORD dwReason, WIN32_FIND_DATA * pwfd)
{
    HRESULT hr;
    WCHAR wszDir[MAX_PATH];
    WCHAR wszFileName[MAX_PATH];

    WIN32_FIND_DATAW wfdw = {0};
    WIN32_FIND_DATAW* pwfdw = NULL;
    TREEWALKERSTATS tws = {0};

    tws.nFiles = _nFiles;
    tws.nFolders     = _nDirs;
    tws.nDepth       = _nDepth;
    tws.ulTotalSize  = _ulTotalSize;
    tws.ulActualSize = _ulActualSize;
    tws.dwClusterSize = _dwClusterSize;

    // _szWalkBuf to wszDir
    StringCchCopy(wszDir, ARRAYSIZE(wszDir), _szWalkBuf);
    StringCchCopy(wszFileName, ARRAYSIZE(wszFileName), wszDir);
    PathCombine(wszFileName, wszFileName, pwfd->cFileName);

    if (pwfd && ((dwReason == STWCB_FILE) || (dwReason == STWCB_ENTERDIR)))
    {
        // WIN32_FIND_DATAA to WIN32_FIND_DATAW
        memcpy(&wfdw, pwfd, sizeof(wfdw));
        pwfdw = &wfdw;
    }

    switch (dwReason) 
    {
    case STWCB_FILE:
        hr = _pstwcb->FoundFile(wszFileName, &tws, pwfdw);
        TraceMsg(TF_TREEWALKER, "TreeWalker Callback FoundFile: %s\\%s dwReason: %x  nFiles: %d  nDepth: %d  nDirs: %d",
                 _szWalkBuf, pwfd->cFileName, dwReason, _nFiles, _nDepth, _nDirs);
        break;

    case STWCB_ENTERDIR:
        hr = _pstwcb->EnterFolder(wszDir, &tws, pwfdw);
        TraceMsg(TF_TREEWALKER, "TreeWalker Callback EnterFolder: %s dwReason: %x  nFiles: %d  nDepth: %d  nDirs: %d",
                 _szWalkBuf, dwReason, _nFiles, _nDepth, _nDirs);
        break;

    case STWCB_LEAVEDIR:
        hr = _pstwcb->LeaveFolder(wszDir, &tws);
        break;

//  case STWCB_ERROR:
//      hr = _pstwcb->HandleError(S_OK, wszDir, &tws);
//      break;

    default:
        hr = S_OK;
        break;
    }

    // Error messages are significant to us, all E_ messages are interpreted as "Stop right now!!"
    if (hr == E_NOTIMPL)
        hr = S_OK;
    
    return hr;
}


// Call call back funtions on directories and files, recurse on directories if there is no objection
// from the callback object
HRESULT CShellTreeWalker::_ProcessAndRecurse(WIN32_FIND_DATA * pwfd)
{
    HRESULT hr = S_OK;

    // Don't recurse on reparse points by default
    if (IS_FILE_DIRECTORY(pwfd) && (!IS_FILE_REPARSE_POINT(pwfd) || (_dwFlags & WT_GOINTOREPARSEPOINT)))
    {
        // NTRAID94635 15mar00: If we are in a symbolic link, we need to detect cycles, 
        // the common prefix method in BeenThereDoneThat will work as long as we
        // keep track of all junction point targets we ran into. 

        // use _szWalkBuf since we dont want any stack variables, because we are a recursive function
        if (_PathAppend(_szWalkBuf, pwfd->cFileName))
        {
            // We remember the total number of sub directories we have seen
            // doesn't matter if the client approves or not(call back returns S_OK or S_FALSE or E_FAIL)
            _nDirs++;

            // Let the CallBack object know that we are about to enter a directory 
            if (_dwFlags & WT_NOTIFYFOLDERENTER)
                hr = _CallCallBacks(STWCB_ENTERDIR, pwfd);

            if ((hr == S_OK) && (_nDepth < _nMaxDepth))
            {
                _nDepth++;
                hr = _TreeWalkerHelper();
                _nDepth--;
            }
            else if (hr == S_FALSE)
                hr = S_OK;

            // Let the CallBack object know that we are about to leave a directory 
            if (_dwFlags & WT_NOTIFYFOLDERLEAVE)
                _CallCallBacks(STWCB_LEAVEDIR, NULL);
            
            // Peel off the subdirectory we tagged on in the above PathCombine Ex:"c:\bin\fun --> c:\bin" 
            PathRemoveFileSpec(_szWalkBuf);
        }
    }
    else
    {
        // use _szWalkBuf since we dont want any stack variables, because we are a recursive function
        if (_PathAppend(_szWalkBuf, pwfd->cFileName))
        {
            // Count the number of files and compute the total size before calling the
            // call back object. 
            ULARGE_INTEGER ulTemp;
            _nFiles++;

            ulTemp.LowPart  = pwfd->nFileSizeLow;
            ulTemp.HighPart = pwfd->nFileSizeHigh;
            _ulTotalSize += ulTemp.QuadPart;

            // when calculating the total size, we need to find out if the file is compressed or sparse (NTFS only case)
            if (pwfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE))
            {
                // eithe the file is compressed or sparse, we need to call GetCompressedFileSize to get the real
                // size on disk for this file (NOTE: GetCompressedFileSize takes into account cluster slop, except
                // for files < 1 cluster, and we take care of that below)
                ulTemp.LowPart = SHGetCompressedFileSize(_szWalkBuf, &ulTemp.HighPart);

                _ulActualSize += ulTemp.QuadPart;
            }
            else
            {
                // (reinerf) the cluster size could change if we started on one volume and have now
                // walked onto another mounted volume
                //
                // PathGetClusterSize caches the last request, so this check will be fast in the common case
                //
                _dwClusterSize = PathGetClusterSize(_szWalkBuf);

                // if its not compressed, we just round up to the drive's cluster size. ulTemp was setup
                // already for us above, so just round it to the cluster and add it in
                _ulActualSize += ROUND_TO_CLUSTER(ulTemp.QuadPart, _dwClusterSize);
            }

            // Peel off the subdirectory we tagged on in the above PathCombine Ex:"c:\bin\fun --> c:\bin" 
            PathRemoveFileSpec(_szWalkBuf);

            hr = _CallCallBacks(STWCB_FILE, pwfd);
        }
    }

    return hr;
}

#define DELAY_ARRAY_GROW  32

// Recursive function that does the real work on the traversal,
HRESULT CShellTreeWalker::_TreeWalkerHelper()
{
    HRESULT hr = S_OK;
    TraceMsg(TF_TREEWALKER, "TreeWalkerHelper started on: %s flags: %x  nFiles: %d  nDepth: %d  nDirs: %d",
             _szWalkBuf, _dwFlags, _nFiles, _nDepth, _nDirs);

    // Let the CallBack object know that we are about to start the walk
    // provided he cares about the root
    if (_nDepth == 0 && !(_dwFlags & WT_EXCLUDEWALKROOT) &&
        (_dwFlags & WT_NOTIFYFOLDERENTER))
    {
        // Get the info for the TopLevelFolder
        HANDLE hTopLevelFolder = FindFirstFile(_szWalkBuf, &_fdTopLevelFolder);

        if (hTopLevelFolder == INVALID_HANDLE_VALUE)
        {
            LPTSTR pszFileName;
            DWORD dwAttribs = -1; // assume failure

            // We could have failed if we tried to do a FindFirstFile on the root (c:\)
            // or if something is really wrong, to test for this we do a GetFileAttributes (GetFileAttributesEx on NT)
            // on NT we can use GetFileAttributesEx to get both the attribs and part of the win32fd
            if (GetFileAttributesEx(_szWalkBuf, GetFileExInfoStandard, (LPVOID)&_fdTopLevelFolder))
            {
                // success!
                dwAttribs = _fdTopLevelFolder.dwFileAttributes;
                pszFileName = PathFindFileName(_szWalkBuf);
                StringCchCopy(_fdTopLevelFolder.cFileName, ARRAYSIZE(_fdTopLevelFolder.cFileName), pszFileName);
                StringCchCopy(_fdTopLevelFolder.cAlternateFileName, ARRAYSIZE(_fdTopLevelFolder.cAlternateFileName), pszFileName);
            }
            else
            {
                // fall back to the ole GetFileAttrbutes
                dwAttribs = GetFileAttributes(_szWalkBuf);

                if (dwAttribs != -1)
                {
                    // success!

                    // On win95 we steal a bunch of the find data from our first child, and fake the rest.
                    // Its the best we can do.
                    memcpy(&_fdTopLevelFolder, &_wfd, sizeof(_fdTopLevelFolder));

                    _fdTopLevelFolder.dwFileAttributes = dwAttribs;

                    pszFileName = PathFindFileName(_szWalkBuf);
                    StringCchCopy(_fdTopLevelFolder.cFileName, ARRAYSIZE(_fdTopLevelFolder.cFileName), pszFileName);
                    StringCchCopy(_fdTopLevelFolder.cAlternateFileName, ARRAYSIZE(_fdTopLevelFolder.cAlternateFileName), pszFileName);
                }
            }

            if (dwAttribs == -1)
            {
                // this is very bad, so we bail
                TraceMsg(TF_TREEWALKER, "Tree Walker: GetFileAttributes/Ex(%s) failed. Stopping the walk.", _szWalkBuf);
                return E_FAIL;
            }

        }
        else
        {
            // We sucessfully got the find data, good.
            FindClose(hTopLevelFolder);
        }

        // call the callback for the first enterdir
        hr = _CallCallBacks(STWCB_ENTERDIR, &_fdTopLevelFolder);
    }

    // Do the real tree walk here
    if (hr == S_OK)
    {
        // always use *.* to search when we are not at our maximum level because
        // we need the sub directories
        // PERF: this can be changed on NT by using FindFirstFileEx if WT_FOLDERONLY
        LPCTSTR pszSpec = (_pszWalkSpec && (_nDepth == _nMaxDepth)) ? _pszWalkSpec : c_szStarDotStar;
        if (_PathAppend(_szWalkBuf, pszSpec))
        {
            HDSA hdsaDelayed = NULL;  // array of found items that will be delayed and processed later
            HANDLE hFind;

            // Start finding the sub folders and files 
            hFind = FindFirstFile(_szWalkBuf, &_wfd);

            // Peel off the find spec Ex:"c:\bin\*.* --> c:\bin" 
            PathRemoveFileSpec(_szWalkBuf);

            if (hFind != INVALID_HANDLE_VALUE)
            {
                BOOL bDir = FALSE;

                do
                {
                    //  Skip over the . and .. entries.
                    if (PathIsDotOrDotDot(_wfd.cFileName))
                        continue;

                    bDir = BOOLIFY(IS_FILE_DIRECTORY(&_wfd));

                    // If this is a file, and we are not interested in files or this file spec does not match the one we were
                    // looking for. 
                    if ((!bDir) && ((_dwFlags & WT_FOLDERONLY) ||
                                    (_pszWalkSpec && (_nDepth < _nMaxDepth) && !PathMatchSpec(_wfd.cFileName, _pszWalkSpec))))
                        continue;

                    //  The following EQUAL determines whether we want to process
                    //  the data found or save it in the HDSA array and process them later. 

                    // Enumerate the folder or file now? (determined by the WT_FOLDERFIRST flag)
                    if (bDir == BOOLIFY(_bFolderFirst))
                    {
                        // Yes
                        hr = _ProcessAndRecurse(&_wfd);

                        // if hr is failure code someone said "stop right now"
                        // if hr is S_FALSE some one said "quit this directory and start with next one"
                        if (hr != S_OK)
                            break;
                    }
                    else 
                    {
                        // No; enumerate it once we're finished with the opposite.
                        if (!hdsaDelayed)
                            hdsaDelayed = DSA_Create(sizeof(WIN32_FIND_DATA), DELAY_ARRAY_GROW);
                        if (!hdsaDelayed)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        DSA_AppendItem(hdsaDelayed, &_wfd);

                    }
                } while (FindNextFile(hFind, &_wfd));

                FindClose(hFind);
            }
            else
            {
               // find first file failed, this is a good place to report error 
               DWORD dwErr = GetLastError();
               TraceMsg(TF_TREEWALKER, "***WARNING***: FindFirstFile faied on %s%s with error = %d", _szWalkBuf, _pszWalkSpec, dwErr);
            }

            // Process the delayed items, these are either directories or files
            if (hdsaDelayed)
            {
                // we should have finished everything in the above do while loop in folderonly case
                ASSERT(!(_dwFlags & WT_FOLDERONLY));

                // if hr is failure code someone said "stop right now"
                // if hr is S_FALSE some one said "quit this directory and start with next one"
                if (hr == S_OK)   
                {
                    int ihdsa;
                    for (ihdsa = 0; ihdsa < DSA_GetItemCount(hdsaDelayed); ihdsa++)
                    {
                        WIN32_FIND_DATA * pwfd = (WIN32_FIND_DATA *)DSA_GetItemPtr(hdsaDelayed, ihdsa);
                        hr = _ProcessAndRecurse(pwfd);
                        if (hr != S_OK)
                            break;
                    }
                }
                DSA_Destroy(hdsaDelayed);
            }

            // Let the CallBack object know that we are finishing the walk
            if (_nDepth == 0 && !(_dwFlags & WT_EXCLUDEWALKROOT) &&
                (_dwFlags & WT_NOTIFYFOLDERLEAVE) && (S_OK == hr))
                hr = _CallCallBacks(STWCB_LEAVEDIR, &_fdTopLevelFolder);

            // hr was S_FALSE because someone wanted us to jump out of this current directory
            // but don't pass it back to our parent directory  
            if (hr == S_FALSE)
                hr = S_OK;
        }
        else
            TraceMsg(TF_TREEWALKER, "***WARNING***: PathCombine failed!!!!");
    }
    
    return hr;
}

// we need our own version of PathAppend that doesn't whack pszPath to '\0' in failure cases
BOOL CShellTreeWalker::_PathAppend(LPTSTR pszPath, LPCTSTR pszMore)
{
    BOOL bRet;
    TCHAR szTemp[MAX_PATH];

    // save off pszPath in case of failure so that we can restore it
    lstrcpyn(szTemp, pszPath, ARRAYSIZE(szTemp));

    bRet = PathAppend(pszPath, pszMore);

    if (!bRet)
    {
        // we failed, so restore pszPath
        lstrcpy(pszPath, szTemp);
    }

    return bRet;
}


// IShellTreeWalker::WalkTree is the main function for the IShellTreeWalker interface 
HRESULT CShellTreeWalker::WalkTree(DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxDepth, IShellTreeWalkerCallBack * pstwcb)
{
    HRESULT hr = E_FAIL;
    TCHAR szWalkSpec[64];

    // must have a call back object to talk to
    ASSERT(IS_VALID_CODE_PTR(pstwcb, IShellTreeWalkerCackBack));
    if (pstwcb == NULL)
        return E_INVALIDARG;

    // make sure we have a valid directory to start with
    ASSERT(IS_VALID_STRING_PTRW(pwszWalkRoot, -1));
    if ((pwszWalkRoot != NULL) && (pwszWalkRoot[0] != L'\0'))
    {
        SHUnicodeToTChar(pwszWalkRoot, _szWalkBuf, ARRAYSIZE(_szWalkBuf));
        // call back 
        _pstwcb = pstwcb;

        // copy the search flags and fix it up  
        _dwFlags = dwFlags & WT_ALL;
        
        // this will save us from using the hdsa array to hold the directories
        if (_dwFlags & WT_FOLDERONLY)
        {
            _dwFlags |= WT_FOLDERFIRST;

            // It will be pretty meanless if the below flags are not set, because
            // we don't call FoundFile in the FolderOnly case. 
            ASSERT(_dwFlags & (WT_NOTIFYFOLDERENTER | WT_NOTIFYFOLDERLEAVE));
        }

        if (_dwFlags & WT_FOLDERFIRST)
            _bFolderFirst = TRUE;
        
        if ((pwszWalkSpec != NULL) && (pwszWalkSpec[0] != L'\0'))
        {
            SHUnicodeToTChar(pwszWalkSpec, szWalkSpec, ARRAYSIZE(szWalkSpec));
            _pszWalkSpec = szWalkSpec;
        }
        
        _nMaxDepth = (dwFlags & WT_MAXDEPTH) ? iMaxDepth : 256;
        _dwClusterSize = PathGetClusterSize(_szWalkBuf);
        hr = _TreeWalkerHelper();
    }
    else
        TraceMsg(TF_WARNING, "CShellTreeWalker::WalkTree Failed! due to bad _szWalkBuf");
    
    return hr;
}

// IShellTreeWalker::QueryInterface
HRESULT CShellTreeWalker::QueryInterface(REFIID riid, void ** ppv)
{ 
    static const QITAB qit[] = {
        QITABENT(CShellTreeWalker, IShellTreeWalker),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// IShellTreeWalker::AddRef
ULONG CShellTreeWalker::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

// IShellTreeWalker::Release
ULONG CShellTreeWalker::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI CShellTreeWalker_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT void **ppvOut)
{
    HRESULT hr;
    
    *ppvOut = NULL;                     

    CShellTreeWalker *pstw = new CShellTreeWalker;
    if (!pstw)
        return E_OUTOFMEMORY;
    
    hr = pstw->QueryInterface(riid, ppvOut);
    pstw->Release();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\undo.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1994
//
// File: undo.h
//
// History:
//  There is no history.  This file doesn't exist
//
//---------------------------------------------------------------------------

#ifndef _UNDO_INC
#define _UNDO_INC
typedef struct _UNDOATOM * LPUNDOATOM;              
              
typedef struct _UNDOATOM {
    UINT uType;
    HWND hwnd;
    LPVOID lpData;
    FILEOP_FLAGS  foFlags;  //Misc flags.
    
    void (CALLBACK* GetText)(LPUNDOATOM lpua, TCHAR * buffer, UINT cchBuffer, int type);
    void (CALLBACK* Release)(LPUNDOATOM lpua);
    void (CALLBACK* Invoke)(LPUNDOATOM lpua);
    
} UNDOATOM;

EXTERN_C LPUNDOATOM s_lpuaUndoHistory;

#define UNDO_MENUTEXT    1
#define UNDO_STATUSTEXT  2

STDAPI_(void) GetUndoText(LPTSTR lpszBuffer, UINT cchBuffer, int type);
void FreeUndoList();

STDAPI_(void) AddUndoAtom(LPUNDOATOM lpua);
STDAPI_(void) Undo(HWND hwnd);
STDAPI_(void) NukeUndoAtom(LPUNDOATOM lpua);
STDAPI_(BOOL) IsUndoAvailable();

STDAPI_(void) EnumUndoAtoms(int (CALLBACK* lpfn)(LPUNDOATOM lpua, LPARAM lParam), LPARAM lParam);
#define EUA_DONOTHING   0x00 
#define EUA_DELETE      0x01
#define EUA_ABORT       0x02
#define EUA_DELETEABORT 0x03  // or of abort and delete

STDAPI_(void) SuspendUndo(BOOL f);

#endif // _UNDO_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\undo.c ===
#include "shellprv.h"
#pragma  hdrstop
#include <shellp.h>

// use a linked list because we're going to be pulling things off the top
// and bottom all the time.
HDPA s_hdpaUndo = NULL;
BOOL s_fUndoSuspended = FALSE;

#define MAX_UNDO  10

void NukeUndoAtom(LPUNDOATOM lpua)
{
    lpua->Release( lpua );
    LocalFree( lpua );
}

void SuspendUndo(BOOL f)
{
    if (f)
        s_fUndoSuspended++;
    else
        s_fUndoSuspended--;
    
    ASSERT(s_fUndoSuspended >= 0);
    // sanity check
    if (s_fUndoSuspended < 0)
        s_fUndoSuspended = 0;
}


void AddUndoAtom(LPUNDOATOM lpua)
{
    int i;

    ENTERCRITICAL;
    ASSERT(lpua);
    if (!s_hdpaUndo) {
        s_hdpaUndo = DPA_Create(MAX_UNDO + 1);
    }

    if (s_hdpaUndo) {
        i = DPA_AppendPtr(s_hdpaUndo, lpua);
        if (i != -1) {
            if (i >= MAX_UNDO) {
                lpua = DPA_FastGetPtr(s_hdpaUndo, 0);
                NukeUndoAtom(lpua);
                DPA_DeletePtr(s_hdpaUndo, 0);
            }
        } else {
            NukeUndoAtom(lpua);
        }
    }
    LEAVECRITICAL;
}

LPUNDOATOM _PeekUndoAtom(LPINT lpi)
{
    int i = -1;
    LPUNDOATOM lpua = NULL;

    ASSERTCRITICAL;

    if (s_hdpaUndo) {
        i = DPA_GetPtrCount(s_hdpaUndo) - 1;
        if (i >= 0) {
            lpua = DPA_FastGetPtr(s_hdpaUndo, i);

        }
    }
    if (lpi)
        *lpi = i;
    return lpua;
}

void EnumUndoAtoms(int (CALLBACK* lpfn)(LPUNDOATOM lpua, LPARAM lParam), LPARAM lParam)
{
    int i;

    if (!s_hdpaUndo) {
        return;
    }

    ENTERCRITICAL;
    for (i = DPA_GetPtrCount(s_hdpaUndo) - 1; i >= 0; i--) {
        LPUNDOATOM lpua;
        int iRet;
        lpua = DPA_FastGetPtr(s_hdpaUndo, i);
        iRet = lpfn(lpua, lParam);

        if (iRet &  EUA_DELETE) {
            DPA_DeletePtr(s_hdpaUndo, i);
            NukeUndoAtom(lpua);
        }

        if (iRet & EUA_ABORT) {
            break;
        }
    }

    LEAVECRITICAL;
}

#define DoUndoAtom(lpua) ((lpua)->Invoke((lpua)))

void Undo(HWND hwnd)
{
    int i;
    LPUNDOATOM lpua;
    DECLAREWAITCURSOR;

    if (!IsUndoAvailable()) {
        MessageBeep(0);
        return;
    }
    
    SetWaitCursor();

    ENTERCRITICAL;
    ASSERT(s_hdpaUndo);
    lpua = _PeekUndoAtom(&i);
    if (lpua)
        DPA_DeletePtr(s_hdpaUndo, i);
    LEAVECRITICAL;

    if (lpua) {
        lpua->hwnd = hwnd;
        DoUndoAtom(lpua);
    }
    ResetWaitCursor();
}

BOOL IsUndoAvailable()
{
    return s_hdpaUndo && !s_fUndoSuspended &&
        DPA_GetPtrCount(s_hdpaUndo);
}

#define _GetUndoText(lpua, buffer, cchBuffer, type) (lpua)->GetText((lpua), buffer, cchBuffer, type)

// Gets undo information for the first item in the undo buffer
//
void GetUndoText(LPTSTR lpszBuffer, UINT cchBuffer, int type)
{
    TCHAR szTemp[MAX_PATH * 2 + 80];
    TCHAR lpszFormat[MAX_PATH];     // (MAX_PATH is overkill, oh well...)

    ASSERT(cchBuffer > 0);
    lpszBuffer[0] = 0;  // assume failure
    szTemp[0] = 0;

    // While holding onto lpua's from the hdpa, we need to be inside the critical section
    {
        LPUNDOATOM lpua;
        
        ENTERCRITICAL;
        lpua = _PeekUndoAtom(NULL);

        if (lpua)
            _GetUndoText(lpua, szTemp, ARRAYSIZE(szTemp), type);

        LEAVECRITICAL;
    }

    if (LoadString(HINST_THISDLL, (type == UNDO_MENUTEXT)  ? IDS_UNDOACCEL : IDS_UNDO, lpszFormat, ARRAYSIZE(lpszFormat)) != 0)
    {
        if (type == UNDO_STATUSTEXT)
        {
            // Status text shouldn't have ampersand or tab
            ASSERT(StrChr(lpszFormat, TEXT('&')) == NULL);
            ASSERT(StrChr(lpszFormat, TEXT('\t')) == NULL);
        }
        wnsprintf(lpszBuffer, cchBuffer, lpszFormat, szTemp);
    }
}

void FreeUndoList()
{
    HDPA hdpa;
    int i;
    
    ENTERCRITICAL;
    hdpa = s_hdpaUndo;
    s_hdpaUndo = NULL;
    LEAVECRITICAL;

    if (hdpa)
    {
        for (i = DPA_GetPtrCount(hdpa) - 1; i >= 0; i--)
        {
            NukeUndoAtom(DPA_FastGetPtr(hdpa, i));
        }
        DPA_DeleteAllPtrs(hdpa);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\uevttmr.h ===
#ifndef _UEVTTMR_H
#define _UEVTTMR_H

#include "dpa.h"

typedef struct
{
    HWND                        hWnd;
    UINT                        uCallbackMessage;
    ULONG                       uUserEventTimerID;
    UINT                        uTimerElapse;
    UINT                        uIntervalCountdown;
    IUserEventTimerCallback *   pUserEventTimerCallback;
    BOOL                        bFirstTime;
} 
USEREVENTINFO;

#define         MIN_TIMER_THRESHOLD         0.1
#define         MAX_TIMER_THRESHOLD         0.01
    
class CUserEventTimer : public IUserEventTimer
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    // *** IUserEventTimer ***
    STDMETHODIMP SetUserEventTimer( HWND hWnd, 
        UINT uCallbackMessage, 
        UINT uTimerElapse,
        IUserEventTimerCallback * pUserEventTimerCallback, 
        ULONG * puUserEventTimerID);

    STDMETHODIMP KillUserEventTimer(HWND hWnd, ULONG uUserEventTimerID);

    STDMETHODIMP GetUserEventTimerElapsed(HWND hWnd, ULONG uUserEventTimerID, UINT * puTimerElapsed);

    STDMETHODIMP InitTimerTickInterval(UINT uTimerTickIntervalMs);

    CUserEventTimer();
    virtual ~CUserEventTimer();
    HRESULT Init();
    static STDMETHODIMP_(int) s_DeleteCB(LPVOID pData1, LPVOID pData2);

    LRESULT v_WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    static const UINT_PTR   TIMER_ID            = 1000;
    static const UINT       TIMER_ELAPSE        = 5000;        // 5 seconds

    static const ULONG      MIN_TIMER_ID        = 0x00001000;
    static const ULONG      MAX_TIMER_ID        = 0xDDDD1000;

    // static const DWORD      MIN_TIMER_LENGTH     = 4500;     // 4.5 seconds
    // static const DWORD      MAX_TIMER_LENGTH     = 5002;     // 5 seconds + 2 milliseconds

    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    _CreateWindow();
    void    _Destroy();
    void    _OnTimer();
    void    _KillIntervalTimer();
    int     _GetTimerDetailsIndex(HWND hWnd, ULONG uUserEventTimerID);
    HRESULT  _SetUserEventTimer( HWND hWnd, UINT uCallbackMessage, 
        UINT uNumIntervals, IUserEventTimerCallback * pUserEventTimerCallback, 
        ULONG * puUserEventTimerID);
    HRESULT _ResetUserEventTimer(HWND hWnd, UINT uCallbackMessage, UINT uNumIntervals,
        int nIndex);

    ULONG   _GetNextInternalTimerID(HWND hWnd);
    inline BOOL _IsAssignedTimerID(HWND hWnd, ULONG uUserEventTimerID)
    {
        return (_GetTimerDetailsIndex(hWnd, uUserEventTimerID) >= 0);
    }

    inline UINT _CalcNumIntervals(UINT uTimerElapse)
    {
        return (UINT)(uTimerElapse/m_uTimerTickInterval);
    }

    inline UINT _CalcMilliSeconds(UINT uIntervalCountdown)
    {
        return (UINT) (uIntervalCountdown*m_uTimerTickInterval);
    }

    LONG                    m_cRef;

    CDPA<USEREVENTINFO>     _dpaUserEventInfo;

    UINT_PTR                _uUserTimerID;
    HWND                    m_hWnd;
    DWORD                   m_dwUserStartTime;
    UINT                    m_uTimerTickInterval;
};

#endif  // _UEVTTMR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\utilnt.c ===
#include "shellprv.h"
#pragma  hdrstop

LPWSTR APIENTRY
SheRemoveQuotesW(
   LPWSTR sz)
{
   LPWSTR lpT;

   if (WCHAR_QUOTE == *sz) {
      for (lpT = sz+1; *lpT && WCHAR_QUOTE != *lpT; lpT++) {
         *(lpT-1) = *lpT;
      }
      if (WCHAR_QUOTE == *lpT) {
         *(lpT-1) = WCHAR_NULL;
      }
   }
   return(sz);
}

LPSTR APIENTRY
SheRemoveQuotesA(
   LPSTR sz)
{
   LPSTR lpT;

   if (CHAR_QUOTE == *sz) {
      for (lpT = sz+1; *lpT && CHAR_QUOTE != *lpT; lpT++) {
         *(lpT-1) = *lpT;
#if (defined(DBCS) || defined(FE_SB))
         if (IsDBCSLeadByte(*lpT)) {
         lpT++;
            *(lpT-1) = *lpT;
       }
#endif
      }
      if (CHAR_QUOTE == *lpT) {
         *(lpT-1) = CHAR_NULL;
      }
   }
   return(sz);
}


/////////////////////////////////////////////////////////////////////
//
// Name:     SheShortenPathA
//
// Synopsis: Thunk to ShortenPathW
//
/////////////////////////////////////////////////////////////////////

BOOL APIENTRY
SheShortenPathA(LPSTR pPath, BOOL bShorten)
{
   WCHAR pPathW[MAX_PATH];
   BOOL bRetVal;

   MultiByteToWideChar(CP_ACP, 0, pPath, -1, pPathW, MAX_PATH);

   bRetVal = SheShortenPathW(pPathW, bShorten);

   WideCharToMultiByte(CP_ACP, 0, pPathW, -1, pPath, MAX_PATH,
      NULL, NULL);

   return bRetVal;
}



/////////////////////////////////////////////////////////////////////
//
// Name:     SheShortenPath
//
// Synopsis: Takes a pathname and converts all dirs to shortnames/longnames
//
// INOUT:    lpszPath  -- Path to shorten/lengthen (May be in DQUOTES)
//                        Must not be a commandline!
//
//           bShorten  -- T=shorten, F=Lengthen
//
// Return:   BOOL  T=Converted,
//                 F=ran out of space, buffer left alone
//
//
// Assumes:  lpszPath takes the form {"}?:\{f\}*f{"}  or {"}\\f\f\{f\}*f{"}
//           COUNTOF pSrc buffer >= MAXPATHELN
//
// Effects:  Strips quotes out of pPath, if any
//
//
// Notes:
//
/////////////////////////////////////////////////////////////////////

BOOL APIENTRY
SheShortenPathW(LPWSTR pPath, BOOL bShorten)
{
   WCHAR szDest[MAX_PATH];
   LPWSTR pSrcNextSpec, pReplaceSpec;
   LPWSTR pDest, pNewName, p;
   LPWSTR pSrc;
   DWORD cchPathOffset;
   HANDLE hFind;
   WIN32_FIND_DATA FindData;

   UINT i;
   INT nSpaceLeft = MAX_PATH-1;

   pSrc = pPath;

   //
   // Eliminate d-quotes
   //
   for (p = pDest =  pSrc; *p; p++, pDest++) {
      if (WCHAR_QUOTE == *p)
         p++;

      *pDest = *p;
   }

   *pDest = WCHAR_NULL;

   //
   // Strip out leading spaces
   //
   while (WCHAR_SPACE == *pSrc)
      pSrc++;

   //
   // Initialize pNewName so it is calculated once.
   //
   pNewName = bShorten ?
      FindData.cAlternateFileName :
      FindData.cFileName;

   //
   // Skip past \\foo\bar or <drive>:
   //
   pDest = szDest;
   pSrcNextSpec = pSrc;

   // reuse shell32 internal api that calculates path
   // offset.  cchPathOffset will be the offset that when
   // added to the pointer will result in a pointer to the
   // backslash before the first part of the path
   cchPathOffset = SheGetPathOffsetW(pSrc);

   // Check to see if it's valid.  If pSrc is not of the \\foo\bar
   // or <drive>: form we just do nothing
   if (0xFFFFFFFF == cchPathOffset) {
      return TRUE;
   }

   // cchPathOffset will then always be atleast 1 and is the
   // number of characters - 1 that we want to copy (that is, if 0
   // was permissible, it would denote 1 character).
   do {

      *pDest++ = *pSrcNextSpec++;

      if (!--nSpaceLeft)
         return FALSE;

   } while (cchPathOffset--);

   //
   // At this point, we have just the filenames that we can shorten:
   // \\foo\bar\it\is\here ->  it\is\here
   // c:\angry\lions       ->  angry\lions
   //

   while(pSrcNextSpec) {

      //
      // pReplaceSpec holds the current spec we need to replace.
      // By default, if we can't find the altname, then just use this.
      //

      pReplaceSpec = pSrcNextSpec;

      //
      // Search for trailing "\"
      // pSrcNextSpec will point to the next spec to fix (*pSrcNextSpec=NULL if done)
      //
      for(;*pSrcNextSpec && WCHAR_BSLASH != *pSrcNextSpec; pSrcNextSpec++)
         ;


      if (*pSrcNextSpec) {

         //
         // If there is more, then pSrcNextSpec should point to it.
         // Also delimit this spec.
         //
         *pSrcNextSpec = WCHAR_NULL;

      } else {

         pSrcNextSpec = NULL;
      }

      hFind = FindFirstFile(pSrc, &FindData);

      //
      // We could exit as soon as this FindFirstFileFails,
      // but there's the special case of having execute
      // without read permission.  This would fail since the lfn
      // is valid for lfn apps.
      //


      if (INVALID_HANDLE_VALUE != hFind) {

         FindClose(hFind);

         if (pNewName[0]) {

            //
            // We have found an altname.
            // Use it instead.
            //
            pReplaceSpec = pNewName;
         }
      }

      i = wcslen(pReplaceSpec);
      nSpaceLeft -= i;

      if (nSpaceLeft <= 0)
         return FALSE;

      if(FAILED(StringCchCopy(pDest, ARRAYSIZE(szDest) - (pDest - szDest), pReplaceSpec)))
      {
          return FALSE;
      }

      pDest+=i;

      //
      // Now replace the WCHAR_NULL with a slash if necessary
      //
      if (pSrcNextSpec) {
         *pSrcNextSpec++ = WCHAR_BSLASH;

         //
         // Also add backslash to dest
         //
         *pDest++ = WCHAR_BSLASH;
         nSpaceLeft--;
      }
   }

   // !! MAX_PATH assumed, the only current (04/09/02) caller is.  Note: this is a public API, so it can't be changed to pass the buffer size
   if(FAILED(StringCchCopy(pPath, MAX_PATH, szDest)))  
   {
       return FALSE;
   }

    return TRUE;

}


/*
 * Reads the list of program strings from win.ini
 */
LPWSTR GetPrograms()
{
   static LPWSTR lpPrograms = WCHAR_NULL;
   LPWSTR lpT,lpS;

   if (lpPrograms) {
      return lpPrograms;
   }

   if (!(lpPrograms = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH+1) * sizeof(WCHAR)))) {
      return(NULL);
   }
   else 
   {
      GetProfileString(L"windows",L"programs",WSTR_BLANK,lpPrograms,MAX_PATH);
      for (lpS = lpT = lpPrograms; *lpT; lpT++) 
      {
            if (*lpT == WCHAR_SPACE) {
                while (*lpT == WCHAR_SPACE) {
                lpT++;
                }
                lpT--;
                *lpS++ = 0;
            } else {
                *lpS++ = *lpT;
            }
        }

        *lpS++ = WCHAR_NULL;
        *lpS++ = WCHAR_NULL;

      return(lpPrograms);
   }
}

/* finds a file along the path. Returns the error code or 0 if success.
 */

static WORD
_SearchForFile(
   LPCWSTR lpDir,
   LPWSTR lpFile,
   LPWSTR lpFullPath,
   DWORD cchFullPath,
   LPWSTR lpExt,
   DWORD cchExt)
{
   LPWSTR lpT;
   LPWSTR lpD;
   LPWSTR lpExts;
   WCHAR szFile[MAX_PATH];
   DWORD cchPath;

   if (*lpFile == WCHAR_QUOTE) {
      lpFile = SheRemoveQuotes(lpFile);
   }
   if (NULL != (lpT=StrRChrW(lpFile, NULL, WCHAR_BSLASH))) {
      ++lpT;
   } else if (NULL != (lpT=StrRChrW(lpFile, NULL, WCHAR_COLON))) {
      ++lpT;
   } else {
      lpT = lpFile;
   }

   if (NULL != (lpT=StrRChrW(lpT, NULL, WCHAR_DOT))) 
   {
        StringCchCopy(lpExt, MAX_PATH, lpT + 1);  // changed the (only one I see) caller to MAX_PATH
   }
   else 
   {
      *lpExt = WCHAR_NULL;
   }

   // If there's no extension then just use programs list don't
   // try searc   hing for the app sans extension. This fixes the bogus
   // file.run stuff.
   if (!*lpExt) {
      goto UseDefExts;
   }

   //
   // NOTE: Do NOT call CharUpper for any of the strings in this routine.
   //       It will cause problems for the Turkish locale.
   //

   cchPath = SearchPath(lpDir, lpFile, NULL, cchFullPath, lpFullPath, &lpT);

   if (!cchPath) {
      cchPath = SearchPath(NULL, lpFile, NULL, cchFullPath, lpFullPath, &lpT);
   }

   if (cchPath >= cchFullPath) {
      return(SE_ERR_OOM);
   }

   if (cchPath == 0) {
      return(SE_ERR_FNF);
   }

   CheckEscapes(lpFullPath, cchFullPath);
   return 0;

UseDefExts:

   if(FAILED(StringCchCopy(szFile, ARRAYSIZE(szFile), lpFile)))
   {
       return SE_ERR_OOM;   
   }

   lpFile = szFile;
   if(FAILED(StringCchCat(lpFile, ARRAYSIZE(szFile), WSTR_DOT)))
   {
       return SE_ERR_OOM;
   }

   lpD = lpFile + wcslen(lpFile);

   if (NULL != (lpExts = GetPrograms())) 
   {
       // We want to pass through the loop twice checking whether the
       // file is in lpDir first, and then if it's in the sysdirs, via SearchPath(NULL, ...)
       // Add some state and extend the while loop
       LPCWSTR lpTempDir = lpDir;
       LPWSTR lpTempExts = lpExts;
       BOOL bCheckedSysDirs = FALSE;

       while (*lpTempExts || !bCheckedSysDirs) 
       {

           // After the first pass, lpTempExts will be NULL
           // Reset it and loop through again with lpTempDir = NULL so that
           // SearchPath looks at the system dirs

           if (!*lpTempExts) {
              bCheckedSysDirs = TRUE;
              lpTempExts = lpExts;
              lpTempDir = NULL;
           }

           if(FAILED(StringCchCopy(lpD, ARRAYSIZE(szFile) - (lpD - szFile), lpTempExts)) ||
               FAILED(StringCchCopy(lpExt, MAX_PATH, lpTempExts)))
           {
               return SE_ERR_OOM;
           }

           cchPath = SearchPath(lpTempDir, lpFile, NULL, cchFullPath, lpFullPath, &lpT);
           if (cchPath >= cchFullPath) 
           {
              return(SE_ERR_OOM);
           }

           if (cchPath != 0) 
           {
              CheckEscapes(lpFullPath, cchFullPath);
              return 0;
           }

           lpTempExts += wcslen(lpTempExts)+1;
       }
   }
   return(SE_ERR_FNF);
}


/////////////////////////////////////////////////////////////////////
//
// Name:     QualifyAppName
//
// Synopsis: Creates a fully qualified path to the app in a commandline
//
// INC       lpCmdLine     Command line to qualify
//                         (Must have DQuotes if has spaces)
// OUT       lpImage       Fully qualified result
// OUT       ppArgs        Pointer to args in lpCmdLine, _incl_ leading space
//                         OPTIONAL
//
// Return:   DWORD length of path, 0 = fail
//
//
// Assumes:  len of executable in lpCmdLine is < MAX_PATH
//           len of exts are < 64
//
// Effects:
//
//
// Notes:
//
/////////////////////////////////////////////////////////////////////

DWORD
QualifyAppName(
   IN LPCWSTR lpCmdLine,
   OUT LPWSTR lpImage,
   OPTIONAL OUT LPCWSTR* ppArgs)
{
   LPWSTR lpAppName;
   BOOL bAppNameInQuotes = FALSE;
   DWORD cch = 0;

   lpAppName = lpImage;

   // sanity check
   if (!lpCmdLine) {
      return(0);
   }

   while (*lpCmdLine &&
         (*lpCmdLine != WCHAR_SPACE || bAppNameInQuotes)) {

      if (*lpCmdLine == WCHAR_QUOTE) {
         bAppNameInQuotes = !bAppNameInQuotes;
         lpCmdLine++;
         continue;
      }

      *lpAppName++ = *lpCmdLine++;
      cch++;
   }

   *lpAppName = WCHAR_NULL;

   //
   // Save the pointer to the argument list
   //
   if (ppArgs) {
      *ppArgs = lpCmdLine;
   }

   if (SheGetPathOffsetW(lpImage) == -1) {
      WCHAR szTemp[MAX_PATH];

      if(FAILED(StringCchCopy((LPWSTR)szTemp, ARRAYSIZE(szTemp), lpImage)))
          return 0;

      if (StrChrW(lpImage, WCHAR_DOT)) {
          LPWSTR lpFileName;

          return(SearchPath(NULL, szTemp, NULL, MAX_PATH, lpImage, &lpFileName));
      }
      else {
         WCHAR  szExt[MAX_PATH];

         *lpImage = WCHAR_NULL;
         if (_SearchForFile(NULL, (LPWSTR)szTemp, lpImage, MAX_PATH, szExt, MAX_PATH)) {
            return(0);
         }

         return(lstrlen(lpImage));
      }
   }

   return(cch);
}


BOOL
SheConvertPathW(
    LPWSTR lpCmdLine,
    LPWSTR lpFile,
    UINT   cchCmdBuf)
/*++

Routine Description:

   Takes a command line and file and shortens both if the app in the
   command line is dos/wow.

Returns: BOOL T=converted

Arguments:

    INOUT     lpCmdLine  Command line to test
                         exe must be in DQuotes if it has spaces,
                         on return, will have DQuotes if necessary
    INOUT     lpFile     Fully qualified file to shorten
                         May be in DQuotes, but on return will not
                         have DQuotes (since single file)

    IN        cchCmdBuf  Size of buffer in characters

Return Value:

    VOID, but lpFile shortened (in place) if lpCmdLine is dos/wow.

    There are pathalogoical "lfns" (Single unicode chars) that can
    actually get longer when they are shortened.  In this case, we
    won't AV, but we will truncate the parms!

    // Qualify path assumes that the second parm is a buffer of
    // size atleast MAX_PATH, which is nicely equivalent to MAX_PATH
    // needs cleanup!

--*/

{
    LPWSTR lpszFullPath;
    LONG lBinaryType;
    BOOL bInQuote = FALSE;
    LPWSTR lpArgs;
    UINT cchNewLen;
    BOOL bRetVal = FALSE;

    lpszFullPath = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                       cchCmdBuf*sizeof(*lpCmdLine));

    if (!lpszFullPath)
       return bRetVal;

    //
    // We must do the swap here since we need to copy the
    // parms back to lpCmdLine.
    //
    if(FAILED(StringCchCopy(lpszFullPath, cchCmdBuf, lpCmdLine)))
    {
        LocalFree(lpszFullPath);
        return FALSE;
    }

    if (QualifyAppName(lpszFullPath, lpCmdLine, &lpArgs)) {

        if (!GetBinaryType(lpCmdLine, &lBinaryType) ||
            lBinaryType == SCS_DOS_BINARY ||
            lBinaryType == SCS_WOW_BINARY) {

            SheShortenPath(lpCmdLine, TRUE);

            if (lpFile) {
                SheShortenPath(lpFile, TRUE);
            }
            bRetVal = TRUE;
        }

        //
        // Must readd quotes
        //
        CheckEscapes(lpCmdLine, cchCmdBuf);

        cchNewLen = lstrlen(lpCmdLine);
        if(FAILED(StringCchCopy(lpCmdLine + cchNewLen, cchCmdBuf - cchNewLen, lpArgs)))
            bRetVal =  FALSE;

    } else 
    {
        //
        // QualifyAppName failed, restore the command line back
        // to the original state.
        //

        if(FAILED(StringCchCopy(lpCmdLine, cchCmdBuf, lpszFullPath)))
            bRetVal = FALSE;
    }

    LocalFree((HLOCAL)lpszFullPath);

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\util.h ===
//---------------------------------------------------------------------------
// This is a desperate attempt to try and track dependancies.

#ifndef _UTIL_H
#define _UTIL_H

#include "unicpp\utils.h"

#define SZ_REGKEY_FILEASSOCIATION TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileAssociation")

STDAPI Stream_WriteString(IStream *pstm, LPCTSTR psz, BOOL bWideInStream);
STDAPI Stream_ReadString(IStream *pstm, LPTSTR pwsz, UINT cchBuf, BOOL bWideInStream);
STDAPI Str_SetFromStream(IStream *pstm, LPTSTR *ppsz, BOOL bWideInStream);

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

// Sizes of various stringized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)

STDAPI_(void)   SHPlaySound(LPCTSTR pszSound);

STDAPI_(BOOL)   TouchFile(LPCTSTR pszFile);
STDAPI_(BOOL)   IsNullTime(const FILETIME *pft);
#ifdef AddCommas
#undef AddCommas
#endif
STDAPI_(LPTSTR) AddCommas(DWORD dw, LPTSTR pszOut, UINT cchOut);
STDAPI_(LPTSTR) AddCommas64(_int64 n, LPTSTR pszOut, UINT cchOut);
#ifdef ShortSizeFormat
#undef ShortSizeFormat
#endif
STDAPI_(LPTSTR) ShortSizeFormat(DWORD dw, LPTSTR szBuf, UINT cchBuf);
STDAPI_(LPTSTR) ShortSizeFormat64(__int64 qwSize, LPTSTR szBuf, UINT cchBuf);

STDAPI_(int)  GetDateString(WORD wDate, LPWSTR pszStr);
STDAPI_(WORD) ParseDateString(LPCWSTR pszStr);
STDAPI_(int)  GetTimeString(WORD wTime, LPTSTR szStr);
#define GetTopLevelAncestor(hwnd) GetAncestor(hwnd, GA_ROOT)
STDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen);
STDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);
STDAPI_(void) SetICIKeyModifiers(DWORD* pfMask);
STDAPI_(void) GetMsgPos(POINT *ppt);

//For use with CreateDesktopComponents
#define DESKCOMP_IMAGE  0x00000001
#define DESKCOMP_URL    0x00000002
#define DESKCOMP_MULTI  0x00000004
#define DESKCOMP_CDF    0x00000008

STDAPI IsDeskCompHDrop(IDataObject * pido);
STDAPI CreateDesktopComponents(LPCSTR pszUrl, IDataObject * pido, HWND hwnd, DWORD fFlags, int x, int y);
STDAPI ExecuteDeskCompHDrop(LPTSTR pszMultipleUrls, HWND hwnd, int x, int y);

STDAPI_(LONG) RegSetString(HKEY hk, LPCTSTR pszSubKey, LPCTSTR pszValue);
STDAPI_(BOOL) RegSetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPCTSTR psz);
STDAPI_(BOOL) RegGetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPTSTR psz, DWORD cb);

STDAPI_(BOOL) GetShellClassInfo(LPCTSTR pszPath, LPTSTR pszKey, LPTSTR pszBuffer, DWORD cchBuffer);
STDAPI        GetShellClassInfoInfoTip(LPCTSTR pszPath, LPTSTR pszBuffer, DWORD cchBuffer);

#define RGS_IGNORECLEANBOOT 0x00000001

#define TrimWhiteSpaceW(psz)        StrTrimW(psz, L" \t")
#define TrimWhiteSpaceA(psz)        StrTrimA(psz, " \t")

#ifdef UNICODE
#define TrimWhiteSpace      TrimWhiteSpaceW
#else
#define TrimWhiteSpace      TrimWhiteSpaceA
#endif

STDAPI_(LPCTSTR) SkipLeadingSlashes(LPCTSTR pszURL);

STDAPI_(LPSTR) ResourceCStrToStrA(HINSTANCE hAppInst, LPCSTR lpcText);
STDAPI_(LPWSTR) ResourceCStrToStrW(HINSTANCE hAppInst, LPCWSTR lpcText);

#ifdef UNICODE
#define ResourceCStrToStr   ResourceCStrToStrW
#else
#define ResourceCStrToStr   ResourceCStrToStrA
#endif


STDAPI_(void) SHRegCloseKeys(HKEY ahkeys[], UINT ckeys);
STDAPI_(void) HWNDWSPrintf(HWND hwnd, LPCTSTR psz);

#define ustrcmp(psz1, psz2) _ustrcmp(psz1, psz2, FALSE)
#define ustrcmpi(psz1, psz2) _ustrcmp(psz1, psz2, TRUE)
int _ustrcmp(LPCTSTR psz1, LPCTSTR psz2, BOOL fCaseInsensitive);

STDAPI StringToStrRet(LPCTSTR pszName, STRRET *pStrRet);
STDAPI ResToStrRet(UINT id, STRRET *pStrRet);

STDAPI_(LPITEMIDLIST) ILCombineParentAndFirst(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNext);
STDAPI_(LPITEMIDLIST) ILCloneUpTo(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlUpTo);
STDAPI_(LPITEMIDLIST) ILResize(LPITEMIDLIST pidl, UINT cbRequired, UINT cbExtra);

typedef struct {
    LPITEMIDLIST pidlParent;
    LPDATAOBJECT pdtobj;
    LPCTSTR pStartPage;
    IShellFolder* psf;

    // keep this last
    LPTHREAD_START_ROUTINE lpStartAddress;
}  PROPSTUFF;

// NOTE (reinerf): the alpha cpp compiler seems to mess up the type "LPITEMIDLIST",
// to work around the compiler we pass the last param as an LPVOID instead of a LPITEMIDLIST
HRESULT SHLaunchPropSheet(LPTHREAD_START_ROUTINE lpStartAddress, LPDATAOBJECT pdtobj, LPCTSTR pStartPage, IShellFolder* psf, LPVOID pidlParent);


// these don't do anything since shell32 does not support unload, but use this
// for code consistancy with dlls that do support this

#define DllAddRef()
#define DllRelease()

//
//  these are functions that moved from shlexec.c.
//  most of them have something to do with locating and identifying applications
//
HWND GetTopParentWindow(HWND hwnd);


// map the PropVariantClear function to our internal wrapper to save loading OleAut32.dll
#define PropVariantClear PropVariantClearLazy
STDAPI PropVariantClearLazy(PROPVARIANT * pvar);

STDAPI GetCurFolderImpl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);
STDAPI GetPathFromLinkFile(LPCTSTR pszLinkPath, LPTSTR pszTargetPath, int cchTargetPath);

STDAPI_(BOOL) GetFileDescription(LPCTSTR pszPath, LPTSTR pszDesc, UINT *pcchDesc);
STDAPI_(BOOL) IsPathInOpenWithKillList(LPCTSTR pszPath);

// calls ShellMessageBox if SHRestricted fails the restriction
STDAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest);
STDAPI_(BOOL) SafePathListAppend(LPTSTR pszDestPath, DWORD cchDestSize, LPCTSTR pszPathToAdd);

STDAPI_(BOOL) ILGetDisplayNameExW(IShellFolder *psfRoot, LPCITEMIDLIST pidl, LPWSTR pszName, DWORD cchSize, int fType);

STDAPI_(BOOL) Priv_Str_SetPtrW(WCHAR *UNALIGNED *ppwzCurrent, LPCWSTR pwzNew);

#define SEARCHNAMESPACEID_FILE_PATH             1   // Go parse it.
#define SEARCHNAMESPACEID_DOCUMENTFOLDERS       2
#define SEARCHNAMESPACEID_LOCALHARDDRIVES       3
#define SEARCHNAMESPACEID_MYNETWORKPLACES       4

STDAPI_(LPTSTR) DumpPidl(LPCITEMIDLIST pidl);

STDAPI_(BOOL) SHTrackPopupMenu(HMENU hmenu, UINT wFlags, int x, int y, int wReserved, HWND hwnd, LPCRECT lprc);
STDAPI_(HMENU) SHLoadPopupMenu(HINSTANCE hinst, UINT id);

STDAPI PathToAppPathKey(LPCTSTR pszPath, LPTSTR pszKey, int cchKey);
STDAPI_(BOOL) PathToAppPath(LPCTSTR pszPath, LPTSTR pszResult);
STDAPI_(BOOL) PathIsRegisteredProgram(LPCTSTR pszPath);

STDAPI_(BOOL) PathRetryRemovable(HRESULT hr, LPCTSTR pszPath);

STDAPI_(HANDLE) SHGetCachedGlobalCounter(HANDLE *phCache, const GUID *pguid);
STDAPI_(void) SHDestroyCachedGlobalCounter(HANDLE *phCache);

#define GPFIDL_DEFAULT      0x0000      // normal Win32 file name, servers and drive roots included
#define GPFIDL_ALTNAME      0x0001      // short file name
#define GPFIDL_UNCPRINTER   0x0002      // include UNC printer names too (non file system item)

STDAPI_(BOOL) SHGetPathFromIDListEx(LPCITEMIDLIST pidl, LPTSTR pszPath, UINT uOpts);

STDAPI_(BOOL) DAD_DragEnterEx3(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtobj);
STDAPI_(BOOL) DAD_DragMoveEx(HWND hwndTarget, const POINTL ptStart);

STDAPI DefaultSearchGUID(GUID *pGuid);

STDAPI SavePersistHistory(IUnknown* punk, IStream* pstm);

#define TBCDIDASYNC L"DidAsyncInvoke"

STDAPI SEI2ICIX(LPSHELLEXECUTEINFO pei, LPCMINVOKECOMMANDINFOEX pici, LPVOID *ppvFree);
STDAPI ICIX2SEI(LPCMINVOKECOMMANDINFOEX pici, LPSHELLEXECUTEINFO pei);
STDAPI ICI2ICIX(LPCMINVOKECOMMANDINFO piciIn, LPCMINVOKECOMMANDINFOEX piciOut, LPVOID *ppvFree);
STDAPI_(BOOL) PathIsEqualOrSubFolderOf(LPCTSTR pszSubFolder, const UINT rgFolders[], DWORD crgFolder);
STDAPI_(BOOL) PathIsSubFolderOf(LPCTSTR pszFolder, const UINT rgFolders[], DWORD crgFolders);
STDAPI_(BOOL) PathIsOneOf(LPCTSTR pszFolder, const UINT rgFolders[], DWORD crgFolders);
STDAPI_(BOOL) PathIsDirectChildOf(LPCTSTR pszParent, LPCTSTR pszChild);


STDAPI_(LPTSTR) PathBuildSimpleRoot(int iDrive, LPTSTR pszDrive);

IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation, HINSTANCE hAnimationInst);

STDAPI_(BOOL) IsWindowInProcess(HWND hwnd);

STDAPI BindCtx_CreateWithMode(DWORD grfMode, IBindCtx **ppbc);
STDAPI_(DWORD) BindCtx_GetMode(IBindCtx *pbc, DWORD grfModeDefault);
STDAPI_(BOOL) BindCtx_ContainsObject(IBindCtx *pbc, LPOLESTR sz);

STDAPI SaveShortcutInFolder(int csidl, LPTSTR pszName, IShellLink *psl);

STDAPI SHCreateFileSysBindCtx(const WIN32_FIND_DATA *pfd, IBindCtx **ppbc);
STDAPI SHCreateFileSysBindCtxEx(const WIN32_FIND_DATA *pfd, DWORD grfMode, DWORD grfFlags, IBindCtx **ppbc);
STDAPI SHIsFileSysBindCtx(IBindCtx *pbc, WIN32_FIND_DATA **ppfd);
STDAPI SHSimpleIDListFromFindData(LPCTSTR pszPath, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);
STDAPI SHSimpleIDListFromFindData2(IShellFolder *psf, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);
STDAPI SHCreateFSIDList(LPCTSTR pszFolder, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);

STDAPI SimulateDropWithPasteSucceeded(IDropTarget * pdrop, IDataObject * pdtobj, DWORD grfKeyState, const POINTL *ppt, DWORD dwEffect, IUnknown * punkSite, BOOL fClearClipboard);
STDAPI DeleteFilesInDataObject(HWND hwnd, UINT uFlags, IDataObject *pdtobj, UINT fOptions);

STDAPI GetCLSIDFromIDList(LPCITEMIDLIST pidl, CLSID *pclsid);
STDAPI GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidl, CLSID *pclsid);

#ifdef DEBUG
STDAPI_(BOOL) AssertIsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid);
#endif

STDAPI_(BOOL) IsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid);

STDAPI_(void) CleanupFileSystem();
SHSTDAPI_(HICON) SHGetFileIcon(HINSTANCE hinst, LPCTSTR pszPath, DWORD dwFileAttribute, UINT uFlags);
STDAPI GetIconLocationFromExt(IN LPTSTR pszExt, OUT LPTSTR pszIconPath, UINT cchIconPath, OUT LPINT piIconIndex);

STDAPI_(BOOL) IsMainShellProcess(); // is this the process that owns the desktop hwnd (eg the main explorer process)
STDAPI_(BOOL) IsProcessAnExplorer();
__inline BOOL IsSecondaryExplorerProcess()
{
    return (IsProcessAnExplorer() && !IsMainShellProcess());
}

STDAPI SHILAppend(LPITEMIDLIST pidlToAppend, LPITEMIDLIST *ppidl);
STDAPI SHILPrepend(LPITEMIDLIST pidlToPrepend, LPITEMIDLIST *ppidl);

//
// IDList macros and other stuff needed by the COFSFolder project
//
typedef enum {
    ILCFP_FLAG_NORMAL           = 0x0000,
    ILCFP_FLAG_SKIPJUNCTIONS    = 0x0001,  //  implies ILCFP_FLAG_NO_MAP_ALIAS
    ILCFP_FLAG_NO_MAP_ALIAS     = 0x0002,
} ILCFP_FLAGS;

STDAPI ILCreateFromCLSID(REFCLSID clsid, LPITEMIDLIST *ppidl);
STDAPI ILCreateFromPathEx(LPCTSTR pszPath, IUnknown *punkToSkip, ILCFP_FLAGS dwFlags, LPITEMIDLIST *ppidl, DWORD *rgfInOut);
STDAPI_(BOOL) ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);

STDAPI_(BOOL) SHSkipJunctionBinding(IBindCtx *pbc, const CLSID *pclsidSkip);
STDAPI SHCreateSkipBindCtx(IUnknown *punkToSkip, IBindCtx **ppbc);

STDAPI_(void) SetUnknownOnSuccess(HRESULT hres, IUnknown *punk, IUnknown **ppunkToSet);
STDAPI SHCacheTrackingFolder(LPCITEMIDLIST pidlRoot, int csidlTarget, IShellFolder2 **ppsfCache);
#define MAKEINTIDLIST(csidl)    (LPCITEMIDLIST)MAKEINTRESOURCE(csidl)

STDAPI_(BOOL) PathIsShortcut(LPCTSTR psz, DWORD dwFileAttributes);

typedef struct _ICONMAP
{
    UINT uType;                  // SHID_ type
    UINT indexResource;          // Resource index (of SHELL232.DLL)
} ICONMAP, *LPICONMAP;

STDAPI_(UINT) SILGetIconIndex(LPCITEMIDLIST pidl, const ICONMAP aicmp[], UINT cmax);

HMONITOR GetPrimaryMonitor();
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork);
#define GetMonitorRect(hMon, prc) \
        GetMonitorRects((hMon), (prc), FALSE)
#define GetMonitorWorkArea(hMon, prc) \
        GetMonitorRects((hMon), (prc), TRUE)
#define IsMonitorValid(hMon) \
        GetMonitorRects((hMon), NULL, TRUE)
#define GetNumberOfMonitors() \
        GetSystemMetrics(SM_CMONITORS)

BOOL IsSelf(UINT cidl, LPCITEMIDLIST *apidl);

#ifdef __cplusplus
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#else
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID(&((a).fmtid),&((b).fmtid)))
#endif
//
//  Helper function for defview callbacks.
//
STDAPI SHFindFirstFile(LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind);
STDAPI SHFindFirstFileRetry(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind, DWORD dwFlags);
STDAPI FindFirstRetryRemovable(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind);
STDAPI_(UINT) SHEnumErrorMessageBox(HWND hwnd, UINT idTemplate, DWORD err, LPCTSTR pszParam, BOOL fNet, UINT dwFlags);

LPSTR _ConstructMessageStringA(HINSTANCE hInst, LPCSTR pszMsg, va_list *ArgList);
LPWSTR _ConstructMessageStringW(HINSTANCE hInst, LPCWSTR pszMsg, va_list *ArgList);
#ifdef UNICODE
#define _ConstructMessageString _ConstructMessageStringW
#else
#define _ConstructMessageString _ConstructMessageStringA
#endif

// TransferDelete() fOptions flags
#define SD_USERCONFIRMATION      0x0001
#define SD_SILENT                0x0002
#define SD_NOUNDO                0x0004
#define SD_WARNONNUKE            0x0008 // we pass this for drag-drop on recycle bin in case something is really going to be deleted

STDAPI TransferDelete(HWND hwnd, HDROP hDrop, UINT fOptions);

STDAPI_(BOOL) App_IsLFNAware(LPCTSTR pszFile);

STDAPI_(void) ReplaceDlgIcon(HWND hDlg, UINT id, HICON hIcon);
STDAPI_(LONG) GetOfflineShareStatus(LPCTSTR pcszPath);

HRESULT SHGetSetFolderSetting(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
        LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize);
HRESULT SHGetSetFolderSettingPath(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
        LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize);

HRESULT ExpandOtherVariables(LPTSTR pszFile, int cch);
HRESULT SubstituteWebDir(LPTSTR pszFile, int cch);

STDAPI_(BOOL) IsExplorerBrowser(IShellBrowser *psb);
STDAPI_(BOOL) IsExplorerModeBrowser(IUnknown *psite);
STDAPI_(HWND) ShellFolderViewWindow(HWND hwnd);     // evil that should be gone
STDAPI InvokeFolderPidl(LPCITEMIDLIST pidl, int nCmdShow);
STDAPI IUnknown_HTMLBackgroundColor(IUnknown *punk, COLORREF *pclr);

STDAPI_(int) MapSCIDToColumn(IShellFolder2* psf2, const SHCOLUMNID* pscid);

#ifdef COLUMNS_IN_DESKTOPINI
STDAPI _GetNextCol(LPTSTR* ppszText, DWORD* pnCol);
#endif

// IDLIST.C
STDAPI ILCompareRelIDs(IShellFolder *psfParent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPARAM lParam);
STDAPI ILGetRelDisplayName(IShellFolder *psf, STRRET *psr, LPCITEMIDLIST pidlRel, LPCTSTR pszName, LPCTSTR pszTemplate, DWORD dwFlags);

STDAPI SHGetIconFromPIDL(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, int *piImage);

STDAPI_(int) SHRenameFileEx(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszDir, LPCTSTR pszOldName, LPCTSTR pszNewName);

#define MAX_ASSOC_KEYS      7
STDAPI AssocKeyFromElement(IAssociationElement *pae, HKEY *phk);
STDAPI_(DWORD) SHGetAssocKeys(IQueryAssociations *pqa, HKEY *rgKeys, DWORD cKeys);
STDAPI_(DWORD) SHGetAssocKeysEx(IAssociationArray *paa, ASSOCELEM_MASK mask, HKEY *rgKeys, DWORD cKeys);
STDAPI_(DWORD) SHGetAssocKeysForIDList(LPCITEMIDLIST pidlFull, HKEY *rgKeys, DWORD cKeys);
STDAPI AssocElemCreateForClass(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae);
STDAPI AssocElemCreateForKey(const CLSID *pclsid, HKEY hk, IAssociationElement **ppae);
STDAPI AssocGetDetailsOfSCID(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv, BOOL *pfFoundScid);

STDAPI_(HKEY)  SHOpenShellFolderKey(const CLSID *pclsid);
STDAPI_(BOOL)  SHQueryShellFolderValue(const CLSID *pclsid, LPCTSTR pszValueName);
STDAPI_(DWORD) SHGetAttributesFromCLSID2(const CLSID *pclsid, DWORD dwDefAttrs, DWORD dwRequested);

STDAPI SHGetUIObjectOf(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv);


STDAPI_(UINT) QueryCancelAutoPlayMsg();

STDAPI_(void) EnableAndShowWindow(HWND hWnd, BOOL bShow);

STDAPI_(void) DPA_FreeIDArray(HDPA hdpa);

STDAPI DetailsOf(IShellFolder2 *psf2, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch);

// Disk Cleanup launch flags
#define DISKCLEANUP_NOFLAG          0x00000000
#define DISKCLEANUP_DEFAULT         0x00000001
#define DISKCLEANUP_LOWDISK         0x00000002
#define DISKCLEANUP_VERYLOWDISK     0x00000004
#define DISKCLEANUP_MODAL           0x00000008

STDAPI_(void) LaunchDiskCleanup(HWND hwnd, int idDrive, UINT uFlags);
STDAPI_(BOOL) GetDiskCleanupPath(LPTSTR pszBuf, UINT cbSize);

STDAPI ParsePrinterName(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl);
STDAPI ParsePrinterNameEx(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl, BOOL bValidated, DWORD dwType, USHORT uFlags);
STDAPI GetVariantFromRegistryValue(HKEY hkey, LPCTSTR pszValueName, VARIANT *pv);

STDAPI_(UINT) GetControlCharWidth(HWND hwnd);

STDAPI_(BOOL) ShowSuperHidden();
STDAPI_(BOOL) IsSuperHidden(DWORD dwAttribs);

STDAPI_(void) PathComposeWithArgs(LPTSTR pszPath, LPTSTR pszArgs);
STDAPI PathSeperateArgs(LPTSTR pszPath, LPTSTR pszArgs, UINT cchArgs, BOOL *pfExists);

STDAPI_(int) CompareIDsAlphabetical(IShellFolder2 *psf, UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

// folder.cpp
enum 
{
    XLATEALIAS_MYDOCS           = 0x00000001,    
    XLATEALIAS_DESKTOP          = 0x00000002,    
    XLATEALIAS_COMMONDOCS       = 0x00000003,   // REVIEW: XLATEALIAS_DESKTOP & XLATEALIAS_MYDOCS ?
//  XLATEALIAS_MYPICS,    
//  XLATEALIAS_NETHOOD,
};
#define XLATEALIAS_ALL  ((DWORD)0x0000ffff)

STDAPI SHILAliasTranslate(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlAlias, DWORD dwXlateAliases);

STDAPI StatStgFromFindData(const WIN32_FIND_DATA * pfd, DWORD dwFlags, STATSTG * pstat);

STDAPI_(BOOL) IsDesktopBrowser(IUnknown *punkSite);

STDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd);

STDAPI GetCCHMaxFromPath(LPCTSTR szFullPath, UINT *pcchMax, BOOL fShowExtension);

STDAPI ViewModeFromSVID(const SHELLVIEWID *pvid, FOLDERVIEWMODE *pViewMode);
STDAPI SVIDFromViewMode(FOLDERVIEWMODE uViewMode, SHELLVIEWID *psvid);

STDAPI_(DWORD) SetLinkFlags(IShellLink *psl, DWORD dwFlags, DWORD dwMask);

STDAPI TBCGetBindCtx(BOOL fCreate, IBindCtx **ppbc);
STDAPI TBCGetObjectParam(LPCOLESTR pszKey, REFIID riid, void **ppv);
STDAPI TBCRegisterObjectParam(LPCOLESTR pszKey, IUnknown *punk, IBindCtx **ppbcLifetime);
STDAPI TBCSetEnvironmentVariable(LPCWSTR pszVar, LPCWSTR pszValue, IBindCtx **ppbcLifetime);
STDAPI TBCGetEnvironmentVariable(LPCWSTR pszVar, LPWSTR pszValue, DWORD cchValue);

STDAPI_(int) CompareVariants(VARIANT va1, VARIANT va2);
STDAPI_(int) CompareBySCID(IShellFolder2 *psf, const SHCOLUMNID *pscid, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
STDAPI_(int) CompareFolderness(IShellFolder *psf, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

STDAPI_(BOOL) IsRegItemName(LPCTSTR pszName, CLSID* pclsid);

STDAPI SHCreateShellItemFromParent(IShellItem *psiParent, LPCWSTR pszName, IShellItem **ppsi);

STDAPI GetMyDocumentsDisplayName(LPTSTR pszPath, UINT cch);

STDAPI BSTRFromCLSID(REFCLSID clsid, BSTR *pbstr);

typedef struct {
    LPCWSTR pszCmd;   // verbW
    LPCSTR  pszCmdA;  // verbA
    WPARAM  idDFMCmd; // id to map to
    UINT    idDefCmd; // extra info defcm uses
} ICIVERBTOIDMAP;
HRESULT SHMapICIVerbToCmdID(LPCMINVOKECOMMANDINFO pici, const ICIVERBTOIDMAP* pmap, UINT cmap, UINT *pid);
HRESULT SHMapCmdIDToVerb(UINT_PTR idCmd, const ICIVERBTOIDMAP* pmap, UINT cmap, LPSTR pszName, UINT cchMax, BOOL bUnicode);

STDAPI SHPropertiesForUnk(HWND hwnd, IUnknown *punk, LPCTSTR psz);
STDAPI SHFullIDListFromFolderAndItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);

STDAPI_(BOOL) IsWindowClass(HWND hwndTest, LPCTSTR pszClass);

STDAPI DCA_ExtCreateInstance(HDCA hdca, int iItem, REFIID riid, LPVOID FAR* ppv);

STDAPI WrapInfotip(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, IUnknown *punk);

STDAPI CloneIDListArray(UINT cidl, const LPCITEMIDLIST rgpidl[], UINT *pcidl, LPITEMIDLIST **papidl);

typedef BOOL (CALLBACK* ENUMSHELLWINPROC)(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam);
STDAPI EnumShellWindows(ENUMSHELLWINPROC pEnumFunc, LPARAM lParam);

// Infotip Helper Functions
BOOL    SHShowInfotips();
HRESULT SHCreateInfotipWindow(HWND hwndParent, LPWSTR pszInfotip, HWND *phwndInfotip);
HRESULT SHShowInfotipWindow(HWND hwndInfotip, BOOL bShow);
HRESULT SHDestroyInfotipWindow(HWND *phwndInfotip);

BOOL PolicyNoActiveDesktop(void);

// should we should wizards as icons in defview of this object?
STDAPI SHShouldShowWizards(IUnknown *punksite);

STDAPI SplitIDList(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFolder, LPCITEMIDLIST *ppidlChild);
STDAPI SHSimulateDropWithSite(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                              const POINTL *ppt, DWORD *pdwEffect, IUnknown *punkSite);
STDAPI FindAppForFileInUse(PCWSTR pszFile, PWSTR *ppszApp);

HRESULT InitializeDirectUI();
void UnInitializeDirectUI();

BOOL IsForceGuestModeOn(void);
BOOL IsFolderSecurityModeOn(void);

STDAPI_(int) StrCmpLogicalRestricted(PCWSTR psz1, PCWSTR psz2);
    
HRESULT HavePreviousVersionsAt(IShellItemArray *psiItemArray, DWORD dwIndex, BOOL fOkToBeSlow, BOOL* pfAvailable);
HRESULT ShowPreviousVersionsAt(IShellItemArray *psiItemArray, DWORD dwIndex, HWND hwndOwner);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\userpict.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: UserPict.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Functions that implement user picture manipulation.
//
//  History:    2000-03-24  vtan        created
//              2000-05-03  jeffreys    reworked using DIB sections
//              2000-10-26  jeffreys    switched from %ALLUSERSPROFILE%\Pictures
//                                      to CSIDL_COMMON_APPDATA\User Account Pictures
//  --------------------------------------------------------------------------

#include "shellprv.h"

#include <lmcons.h>
#include <shimgdata.h>
#include <aclapi.h>     // for SetNamedSecurityInfo
#include <shgina.h>     // for ILogonUser
#include <strsafe.h>

#pragma warning(push,4)

//  --------------------------------------------------------------------------
//  SaveDIBSectionToFile
//
//  Arguments:  hbm             =   Source image (DIB section) to save
//              hdc             =   Device Context containing hbm. May be NULL
//                                    if hbm is not selected in any DC or hbm
//                                    is known to have no color table.
//              pszFile         =   Target image file.
//
//  Returns:    BOOL
//
//  Purpose:    Write a DIB to disk in the proper format
//
//  History:    2000-05-03  jeffreys    created
//  --------------------------------------------------------------------------

#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

// SECURITY: caller is responsible for pszFile being valid
BOOL SaveDIBSectionToFile(HBITMAP hbm, HDC hdc, LPCTSTR pszFile)
{
    BOOL bResult;
    DIBSECTION ds;
    HANDLE hFile;
    BITMAPFILEHEADER bf;
    DWORD cbWritten;

    bResult = FALSE;

    // Get the details about the bitmap. This also validates hbm.

    if (GetObject(hbm, sizeof(ds), &ds) == 0)
        return FALSE;

    // Fill in a couple of optional fields if necessary

    if (ds.dsBmih.biSizeImage == 0)
        ds.dsBmih.biSizeImage = ds.dsBmih.biHeight * ds.dsBm.bmWidthBytes;

    if (ds.dsBmih.biBitCount <= 8 && ds.dsBmih.biClrUsed == 0)
        ds.dsBmih.biClrUsed = 1 << ds.dsBmih.biBitCount;

    // Open the target file. This also validates pszFile.

    hFile = CreateFile(pszFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile)
        return FALSE;

    // Prepare the BITMAPFILEHEADER for writing

    bf.bfType = DIB_HEADER_MARKER;
    bf.bfReserved1 = 0;
    bf.bfReserved2 = 0;

    // The bit offset is the cumulative size of all of the header stuff

    bf.bfOffBits = sizeof(bf) + sizeof(ds.dsBmih) + (ds.dsBmih.biClrUsed*sizeof(RGBQUAD));
    if (ds.dsBmih.biCompression == BI_BITFIELDS)
        bf.bfOffBits += sizeof(ds.dsBitfields);

    // Round up to the next 16-byte boundary. This isn't strictly necessary,
    // but it makes the file layout cleaner. (You can create a file mapping
    // and pass it to CreateDIBSection this way.)

    bf.bfOffBits = ((bf.bfOffBits + 15) & ~15);

    // The file size is the bit offset + the size of the bits

    bf.bfSize = bf.bfOffBits + ds.dsBmih.biSizeImage;

    // Write the BITMAPFILEHEADER first

    bResult = WriteFile(hFile, &bf, sizeof(bf), &cbWritten, NULL);

    if (bResult)
    {
        // Next is the BITMAPINFOHEADER

        bResult = WriteFile(hFile, &ds.dsBmih, sizeof(ds.dsBmih), &cbWritten, NULL);
        if (bResult)
        {
            // Then the 3 bitfields, if necessary

            if (ds.dsBmih.biCompression == BI_BITFIELDS)
            {
                bResult = WriteFile(hFile, &ds.dsBitfields, sizeof(ds.dsBitfields), &cbWritten, NULL);
            }

            if (bResult)
            {
                // Now the color table, if any

                if (ds.dsBmih.biClrUsed != 0)
                {
                    RGBQUAD argb[256];
                    HDC hdcDelete;
                    HBITMAP hbmOld;

                    // Assume failure here
                    bResult = FALSE;

                    hdcDelete = NULL;
                    if (!hdc)
                    {
                        hdcDelete = CreateCompatibleDC(NULL);
                        if (hdcDelete)
                        {
                            hbmOld = (HBITMAP)SelectObject(hdcDelete, hbm);
                            hdc = hdcDelete;
                        }
                    }

                    if (hdc &&
                        GetDIBColorTable(hdc, 0, ARRAYSIZE(argb), argb) == ds.dsBmih.biClrUsed)
                    {
                        bResult = WriteFile(hFile, argb, ds.dsBmih.biClrUsed*sizeof(RGBQUAD), &cbWritten, NULL);
                    }

                    if (hdcDelete)
                    {
                        SelectObject(hdcDelete, hbmOld);
                        DeleteDC(hdcDelete);
                    }
                }

                // Finally, write the bits

                if (bResult)
                {
                    SetFilePointer(hFile, bf.bfOffBits, NULL, FILE_BEGIN);
                    bResult = WriteFile(hFile, ds.dsBm.bmBits, ds.dsBmih.biSizeImage, &cbWritten, NULL);
                    SetEndOfFile(hFile);
                }
            }
        }
    }

    CloseHandle(hFile);

    if (!bResult)
    {
        // Something failed, clean up
        DeleteFile(pszFile);
    }

    return bResult;
}


//  --------------------------------------------------------------------------
//  MakeDIBSection
//
//  Arguments:  pImage          =   Source image
//
//  Returns:    HBITMAP
//
//  Purpose:    Create a DIB section containing the given image
//              on a white background
//
//  History:    2000-05-03  jeffreys    created
//  --------------------------------------------------------------------------

HBITMAP MakeDIBSection(IShellImageData *pImage, ULONG cx, ULONG cy)
{
    HBITMAP hbm;
    HDC hdc;
    BITMAPINFO dib;

    hdc = CreateCompatibleDC(NULL);
    if (hdc == NULL)
        return NULL;

    dib.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    dib.bmiHeader.biWidth           = cx;
    dib.bmiHeader.biHeight          = cy;
    dib.bmiHeader.biPlanes          = 1;
    dib.bmiHeader.biBitCount        = 24;
    dib.bmiHeader.biCompression     = BI_RGB;
    dib.bmiHeader.biSizeImage       = 0;
    dib.bmiHeader.biXPelsPerMeter   = 0;
    dib.bmiHeader.biYPelsPerMeter   = 0;
    dib.bmiHeader.biClrUsed         = 0;
    dib.bmiHeader.biClrImportant    = 0;

    hbm = CreateDIBSection(hdc, &dib, DIB_RGB_COLORS, NULL, NULL, 0);

    if (hbm)
    {
        HBITMAP hbmOld;
        RECT rc;

        hbmOld = (HBITMAP)SelectObject(hdc, hbm);

        // Initialize the entire image with white

        PatBlt(hdc, 0, 0, cx, cy, WHITENESS);

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        // Draw the source image into the DIB section

        HRESULT hr = pImage->Draw(hdc, &rc, NULL);

        SelectObject(hdc, hbmOld);

        if (FAILED(hr))
        {
            DeleteObject(hbm);
            hbm = NULL;
            SetLastError(hr);
        }
    }

    DeleteDC(hdc);

    return hbm;
}


//  --------------------------------------------------------------------------
//  ConvertAndResizeImage
//
//  Arguments:  pszFileSource   =   Source image file.
//              pszFileTarget   =   Target image file (resized).
//
//  Returns:    HRESULT
//
//  Purpose:    Uses GDI+ via COM interfaces to convert the given image file
//              to a bmp sized at 96x96.
//
//  History:    2000-03-24  vtan        created
//              2000-05-03  jeffreys    reworked using DIB sections
//  --------------------------------------------------------------------------

HRESULT ConvertAndResizeImage (LPCTSTR pszFileSource, LPCTSTR pszFileTarget)

{
    HRESULT hr;
    IShellImageDataFactory *pImagingFactory;

    hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &pImagingFactory));
    if (SUCCEEDED(hr))
    {
        IShellImageData *pImage;

        hr = pImagingFactory->CreateImageFromFile(pszFileSource, &pImage);
        if (SUCCEEDED(hr))
        {
            hr = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);

            if (SUCCEEDED(hr))
            {
                SIZE    sizeImg;
                ULONG   cxDest, cyDest;
                HDC     hdc;
                HBITMAP hbm;
                DWORD   dwErr;

                // The default dimensions are based on the screen resolution

                hdc = GetDC(NULL);
                if (hdc != NULL)
                {
                    // Make it 1/2 inch square by default
                    cxDest = GetDeviceCaps(hdc, LOGPIXELSX) / 2;
                    cyDest = GetDeviceCaps(hdc, LOGPIXELSY) / 2;
                    ReleaseDC(NULL, hdc);
                }
                else
                {
                    // Most common display modes run at 96dpi ("small fonts")
                    cxDest = cyDest = 48;
                }

                // Get the current image dimensions so we can maintain aspect ratio
                if ( SUCCEEDED(pImage->GetSize(&sizeImg)) )
                {
                    // Don't want to make small images bigger
                    cxDest = min(cxDest, (ULONG)sizeImg.cx);
                    cyDest = min(cyDest, (ULONG)sizeImg.cy);

                    // If it's not square, scale the smaller dimension
                    // to maintain the aspect ratio.
                    if (sizeImg.cx > sizeImg.cy)
                    {
                        cyDest = MulDiv(cxDest, sizeImg.cy, sizeImg.cx);
                    }
                    else if (sizeImg.cx < sizeImg.cy)
                    {
                        cxDest = MulDiv(cyDest, sizeImg.cx, sizeImg.cy);
                    }
                }

                // Resize the image

                // Note that this gives better results than scaling while drawing
                // into the DIB section (see MakeDIBSection).
                //
                // However, it doesn't always work. For example, animated images
                // result in E_NOTVALIDFORANIMATEDIMAGE.  So ignore the return
                // value and the scaling will be done in MakeDIBSection if necessary.

                pImage->Scale(cxDest, cyDest, 0);

                hbm = MakeDIBSection(pImage, cxDest, cyDest);

                if (hbm)
                {
                    // Save the DIB section to disk
                    if (!SaveDIBSectionToFile(hbm, NULL, pszFileTarget))
                    {
                        dwErr = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwErr);
                    }

                    DeleteObject(hbm);
                }
                else
                {
                    dwErr = GetLastError();
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }

            pImage->Release();
        }

        pImagingFactory->Release();
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  SetExplicitAccessToObject
//
//  Arguments:  pszTarget   =   Target object
//              seType      =   Type of object
//              pszUser     =   User to grant access to
//              dwMask      =   Permissions granted
//              dwFlags     =   Inheritance flags
//
//  Returns:    BOOL
//
//  Purpose:    Grants Read/Write/Execute/Delete access to the 
//              specified user on the specified file.
//
//              Note that this stomps existing explicit entries in the DACL.
//              Multiple calls are not cumulative.
//
//  History:    2000-05-19  jeffreys    created
//  --------------------------------------------------------------------------

DWORD SetExplicitAccessToObject(LPTSTR pszTarget, SE_OBJECT_TYPE seType, LPCTSTR pszUser, DWORD dwMask, DWORD dwFlags)
{
    BOOL bResult;

    // 84 bytes
    BYTE rgAclBuffer[sizeof(ACL)
                        + (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))
                        + (sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG))];

    PACL pDacl = (PACL)rgAclBuffer;
    if (!InitializeAcl(pDacl, sizeof(rgAclBuffer), ACL_REVISION)) return FALSE;
    pDacl->AceCount = 1;

    PACCESS_ALLOWED_ACE pAce = (PACCESS_ALLOWED_ACE)(pDacl+1);
    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = (UCHAR)(dwFlags & 0xFF);
    pAce->Mask = dwMask;

    SID_NAME_USE snu;
    TCHAR szDomainName[MAX_PATH];
    DWORD cbDomainName = ARRAYSIZE(szDomainName);
    DWORD cbSid = sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG);

    bResult = LookupAccountName(
                    NULL,
                    pszUser,
                    (PSID)&(pAce->SidStart),
                    &cbSid,
                    szDomainName,
                    &cbDomainName,
                    &snu);
    if (bResult)
    {
        DWORD dwErr;

        // LookupAccountName doesn't return the SID length on success
        cbSid = GetLengthSid((PSID)&(pAce->SidStart));

        // Update the ACE size
        pAce->Header.AceSize = (USHORT)(sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) + cbSid);

        dwErr = SetNamedSecurityInfo(
                    pszTarget,
                    seType,
                    DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pDacl,
                    NULL);

        if (ERROR_SUCCESS != dwErr)
        {
            SetLastError(dwErr);
            bResult = FALSE;
        }
    }

    return bResult;
}


//  --------------------------------------------------------------------------
//  SetDefaultUserPicture
//
//  Arguments:  pszUsername     =   Desired user (NULL for current user).
//
//  Returns:    HRESULT
//
//  Purpose:    Picks one of the default user pictures at random and
//              assigns it to the specified user.
//
//  History:    2001-03-27  reinerf    created
//  --------------------------------------------------------------------------

HRESULT SetDefaultUserPicture(LPCTSTR pszUsername)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];

    hr = SHGetUserPicturePath(NULL, SHGUPP_FLAG_DEFAULTPICSPATH, szPath);
    if (SUCCEEDED(hr))
    {
        BOOL bFound = FALSE;    // assume we won't find a picture

        // Assume everything in the dir is a vaild image file
        if (PathAppend(szPath, TEXT("*.*")))
        {
            static DWORD dwSeed = 0;
            WIN32_FIND_DATA fd;
            HANDLE hFind = FindFirstFile(szPath, &fd);

            if (dwSeed == 0)
            {
                dwSeed = GetTickCount();
            }

            if (hFind != INVALID_HANDLE_VALUE)
            {
                DWORD dwCount = 0;
                
                // use a probability collector algorithim (with a limit of 100 files)
                do
                {
                    if (!PathIsDotOrDotDot(fd.cFileName))
                    {
                        dwCount++;

                        // although RtlRandom returns a ULONG it is distributed from 0...MAXLONG
                        if (RtlRandomEx(&dwSeed) <= (MAXLONG / dwCount))
                        {
                            bFound = TRUE;
                            PathRemoveFileSpec(szPath);
                            PathAppend(szPath, fd.cFileName);
                        }
                    }

                } while (FindNextFile(hFind, &fd) && (dwCount < 100));

                FindClose(hFind);
            }
        }
        
        if (bFound)
        {
            hr = SHSetUserPicturePath(pszUsername, 0, szPath);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
}


//  --------------------------------------------------------------------------
//  ::SHGetUserPicturePath
//
//  Arguments:  pszUsername     =   Desired user (NULL for current user).
//              dwFlags         =   Flags.
//              pszPath         =   Path to user picture.
//
//  Returns:    HRESULT
//
//  Purpose:    Returns the user's picture path (absolute). Does parameter
//              validation as well. This function only supports .bmp files.
//
//              Use SHGUPP_FLAG_BASEPATH to return the base to the pictures
//              directory.
//
//              Use SHGUPP_FLAG_DEFAULTPICSPATH to return the path to the
//              default pictures directory.
//
//              Use SHGUPP_FLAG_CREATE to create the user picture directory.
//
//              If neither SHGUPP_FLAG_BASEPATH or SHGUPP_FLAG_DEFAULTPICSPATH
//              is specified, and the user has no picture, SHGUPP_FLAG_CREATE
//              will select one of the default pictures at random.
//
//  History:    2000-02-22  vtan        created
//              2000-03-24  vtan        moved from folder.cpp
//  --------------------------------------------------------------------------

#define UASTR_PATH_PICTURES     TEXT("Microsoft\\User Account Pictures")
#define UASTR_PATH_DEFPICS      UASTR_PATH_PICTURES TEXT("\\Default Pictures")

// SECURITY: Assumes pszPath is MAX_PATH
STDAPI SHGetUserPicturePath (LPCTSTR pszUsername, DWORD dwFlags, LPTSTR pszPath)

{
    HRESULT     hr;
    TCHAR       szPath[MAX_PATH];

    //  Validate dwFlags.

    if ((dwFlags & SHGUPP_FLAG_INVALID_MASK) != 0)
    {
        return(E_INVALIDARG);
    }

    //  Validate pszPath. This must not be NULL.

    if (pszPath == NULL)
    {
        return(E_INVALIDARG);
    }

    //  Start by getting the base picture path

    hr = SHGetFolderPathAndSubDir(NULL,
                                  (dwFlags & SHGUPP_FLAG_CREATE) ? (CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE) : CSIDL_COMMON_APPDATA,
                                  NULL,
                                  SHGFP_TYPE_CURRENT,
                                  (dwFlags & SHGUPP_FLAG_DEFAULTPICSPATH) ? UASTR_PATH_DEFPICS : UASTR_PATH_PICTURES,
                                  szPath);

    //  If the base path is requested this function is done.

    if (S_OK == hr && 0 == (dwFlags & (SHGUPP_FLAG_BASEPATH | SHGUPP_FLAG_DEFAULTPICSPATH)))
    {
        TCHAR szUsername[UNLEN + sizeof('\0')];

        if (pszUsername == NULL)
        {
            DWORD dwUsernameSize;

            dwUsernameSize = ARRAYSIZE(szUsername);
            if (GetUserName(szUsername, &dwUsernameSize) != FALSE)
            {
                pszUsername = szUsername;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        if (pszUsername != NULL)
        {
            //  Append the user name to the picture path. Then look for
            //  <username>.bmp. This function only supports bmp.

            PathAppend(szPath, pszUsername);
            lstrcatn(szPath, TEXT(".bmp"), ARRAYSIZE(szPath));
            if (PathFileExistsAndAttributes(szPath, NULL) != FALSE)
            {
                hr = S_OK;
            }
            else if (dwFlags & SHGUPP_FLAG_CREATE)
            {
                // No picture has been set for this user. Select one
                // of the default pictures at random.
                hr = SetDefaultUserPicture(pszUsername);
                ASSERT(FAILED(hr) || PathFileExistsAndAttributes(szPath, NULL));
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
        }
    }

    if (S_OK == hr)
    {
        hr = StringCchCopy(pszPath, MAX_PATH, szPath);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  ::SHSetUserPicturePath
//
//  Arguments:  pszUsername     =   Desired user (NULL for current user).
//              dwFlags         =   Flags.
//              pszPath         =   Path to NEW user picture.
//
//  Returns:    HRESULT
//
//  Purpose:    Sets the specified user's picture as a copy of the given
//              image file. The image file may be any supported standard image
//              file (.gif / .jpg / .bmp). The file is converted to a 96x96
//              .bmp file in the user picture directory.
//
//  History:    2000-02-22  vtan        created
//              2000-03-24  vtan        moved from folder.cpp
//              2000-04-27  jeffreys    restore old image on conversion failure
//  --------------------------------------------------------------------------

STDAPI SHSetUserPicturePath (LPCTSTR pszUsername, DWORD dwFlags, LPCTSTR pszPath)

{
    HRESULT     hr;
    TCHAR       szPath[MAX_PATH];
    TCHAR       szUsername[UNLEN + sizeof('\0')];
    DWORD       dwUsernameSize;

    hr = E_FAIL;

    //  Validate dwFlags. Currently no valid flags so this must be 0x00000000.

    if ((dwFlags & SHSUPP_FLAG_INVALID_MASK) != 0)
    {
        return(E_INVALIDARG);
    }

    dwUsernameSize = ARRAYSIZE(szUsername);
    if (GetUserName(szUsername, &dwUsernameSize) == FALSE)
    {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (pszUsername != NULL)
    {
        //  Privilege check. Must be an administrator to use this function when
        //  pszUsername is not NULL (i.e. for somebody else).
        if ((lstrcmpi(pszUsername, szUsername) != 0) &&
            (SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS) == FALSE))
        {
            static const SID c_SystemSid = {SID_REVISION,1,SECURITY_NT_AUTHORITY,{SECURITY_LOCAL_SYSTEM_RID}};
            BOOL bSystem = FALSE;

            // One more check.  Allow local system through since we may
            // get called from the logon screen.

            if (!CheckTokenMembership(NULL, (PSID)&c_SystemSid, &bSystem) || !bSystem)
            {
                return(E_ACCESSDENIED);
            }
        }
    }
    else
    {
        pszUsername = szUsername;
    }

    //  Start by getting the base picture path

    hr = SHGetFolderPathAndSubDir(NULL,
                                  CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE,
                                  NULL,
                                  SHGFP_TYPE_CURRENT,
                                  UASTR_PATH_PICTURES,
                                  szPath);
    if (S_OK == hr)
    {
        //  Before attempt to delete what's there try to access the
        //  new file. If this fails deleting what's currently installed
        //  could leave the user without a picture. Fail the API before
        //  anything is lost.

        if ((pszPath == NULL) || (PathFileExistsAndAttributes(pszPath, NULL) != FALSE))
        {
            TCHAR szTemp[MAX_PATH];

            PathAppend(szPath, pszUsername);
            hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), szPath);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(szPath, ARRAYSIZE(szPath), TEXT(".bmp"));
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT(".tmp"));
                    if (SUCCEEDED(hr))
                    {
                        if ((pszPath == NULL) || lstrcmpi(pszPath, szPath) != 0)
                        {
                            //  If present, rename <username>.Bmp to <username>.Tmp.
                            //  First reset the attributes so file ops work. Don't use
                            //  trace macros because failure is expected.

                            (BOOL)SetFileAttributes(szPath, 0);
                            (BOOL)SetFileAttributes(szTemp, 0);
                            (BOOL)MoveFileEx(szPath, szTemp, MOVEFILE_REPLACE_EXISTING);

                            //  Convert the given image to a bmp and resize it
                            //  using the helper function which does all the goo.

                            if (pszPath != NULL)
                            {
                                hr = ConvertAndResizeImage(pszPath, szPath);

                                if (SUCCEEDED(hr))
                                {
                                    // Since this may be an admin setting someone else's
                                    // picture, we need to grant that person access to
                                    // modify/delete the file so they can change it
                                    // themselves later.

                                    (BOOL)SetExplicitAccessToObject(szPath,
                                                                    SE_FILE_OBJECT,
                                                                    pszUsername,
                                                                    GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE | DELETE,
                                                                    0);
                                }
                            }
                            else
                            {
                                hr = S_OK;
                            }

                            if (SUCCEEDED(hr))
                            {
                                // Delete the old picture
                                (BOOL)DeleteFile(szTemp);
                            }
                            else
                            {
                                // Restore the old picture
                                (BOOL)MoveFileEx(szTemp, szPath, MOVEFILE_REPLACE_EXISTING);
                            }
                            // Notify everyone that a user picture has changed
                            SHChangeDWORDAsIDList dwidl;
                            dwidl.cb      = SIZEOF(dwidl) - SIZEOF(dwidl.cbZero);
                            dwidl.dwItem1 = SHCNEE_USERINFOCHANGED;
                            dwidl.dwItem2 = 0;
                            dwidl.cbZero  = 0;

                            SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH, (LPCITEMIDLIST)&dwidl, NULL);
                        }
                        else
                        {
                            // Source and destination are the same, nothing to do.
                            hr = S_FALSE;
                        }
                    }
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

    return(hr);
}

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\viewcomm.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"
#include "idlcomm.h"

// returns SHAlloc() (COM Task Allocator) memory

LPTSTR SHGetCaption(HIDA hida)
{
    UINT idFormat;
    LPTSTR pszCaption = NULL;
    LPITEMIDLIST pidl;
    
    switch (HIDA_GetCount(hida))
    {
    case 0:
        return NULL;
        
    case 1:
        idFormat = IDS_ONEFILEPROP;
        break;
        
    default:
        idFormat = IDS_MANYFILEPROP;
        break;
    }
    
    pidl = HIDA_ILClone(hida, 0);
    if (pidl)
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName), NULL)))
        {
            TCHAR szTemplate[40];
            UINT uLen = LoadString(HINST_THISDLL, idFormat, szTemplate, ARRAYSIZE(szTemplate)) + lstrlen(szName) + 1;
            
            pszCaption = SHAlloc(uLen * SIZEOF(TCHAR));
            if (pszCaption)
            {
                StringCchPrintf(pszCaption, uLen, szTemplate, (LPTSTR)szName);
            }
        }
        ILFree(pidl);
    }
    return pszCaption;
}

// This is not folder specific, and could be used for other background
// properties handlers, since all it does is bind to the parent of a full pidl
// and ask for properties
STDAPI SHPropertiesForPidl(HWND hwndOwner, LPCITEMIDLIST pidlFull, LPCTSTR pszParams)
{
    if (!SHRestricted(REST_NOVIEWCONTEXTMENU)) 
    {
        IContextMenu *pcm;
        HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFull, hwndOwner, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            CHAR szParameters[MAX_PATH];
            CMINVOKECOMMANDINFOEX ici = {
                SIZEOF(CMINVOKECOMMANDINFOEX),
                0L,
                hwndOwner,
                "properties",
                szParameters,
                NULL, SW_SHOWNORMAL
            };

            if (pszParams)
                SHUnicodeToAnsi(pszParams, szParameters, ARRAYSIZE(szParameters));
            else
                ici.lpParameters = NULL;

            ici.fMask |= CMIC_MASK_UNICODE;
            ici.lpVerbW = c_szProperties;
            ici.lpParametersW = pszParams;

            // record if shift or control was being held down
            SetICIKeyModifiers(&ici.fMask);

            hr = pcm->lpVtbl->InvokeCommand(pcm, (LPCMINVOKECOMMANDINFO)&ici);
            pcm->lpVtbl->Release(pcm);
        }

        return hr;
    }
    else 
        return E_ACCESSDENIED;
}

BOOL _LoadErrMsg(UINT idErrMsg, LPTSTR pszErrMsg, size_t cchErrMsg, DWORD err)
{
    TCHAR szTemplate[256];
    if (LoadString(HINST_THISDLL, idErrMsg, szTemplate, ARRAYSIZE(szTemplate)))
    {
        StringCchPrintf(pszErrMsg, cchErrMsg, szTemplate, err);
        return TRUE;
    }
    return FALSE;
}

BOOL _VarArgsFormatMessage( LPTSTR lpBuffer, UINT cchBuffer, DWORD err, ... )
{
    BOOL fSuccess;

    va_list ArgList;

    va_start(ArgList, err);
    fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                NULL, err, 0, lpBuffer, cchBuffer, &ArgList);
    va_end(ArgList);
    return fSuccess;
}

//
// Paremeters:
//  hwndOwner  -- owner window
//  idTemplate -- specifies template (e.g., "Can't open %2%s\n\n%1%s")
//  err        -- specifies the WIN32 error code
//  pszParam   -- specifies the 2nd parameter to idTemplate
//  dwFlags    -- flags for MessageBox
//

STDAPI_(UINT) SHSysErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate,
                                   DWORD err, LPCTSTR pszParam, UINT dwFlags)
{
    BOOL fSuccess;
    UINT idRet = IDCANCEL;
    TCHAR szErrMsg[MAX_PATH * 2];

    //
    // FormatMessage is bogus, we don't know what to pass to it for %1,%2,%3,...
    // For most messages, lets pass the path as %1 and "" as everything else
    // For ERROR_MR_MID_NOT_FOUND (something nobody is ever supposed to see)
    // we will pass the path as %2 and everything else as "".
    //
    if (err == ERROR_MR_MID_NOT_FOUND)
    {
        fSuccess = _VarArgsFormatMessage(szErrMsg,ARRAYSIZE(szErrMsg),
                       err,c_szNULL,pszParam,c_szNULL,c_szNULL,c_szNULL);
    } 
    else 
    {
        fSuccess = _VarArgsFormatMessage(szErrMsg,ARRAYSIZE(szErrMsg),
                       err,pszParam,c_szNULL,c_szNULL,c_szNULL,c_szNULL);
    }

    if (fSuccess || _LoadErrMsg(IDS_ENUMERR_FSGENERIC, szErrMsg, ARRAYSIZE(szErrMsg), err))
    {
        if (idTemplate==IDS_SHLEXEC_ERROR && (pszParam == NULL || StrStr(szErrMsg, pszParam)))
        {
            idTemplate = IDS_SHLEXEC_ERROR2;
        }

        idRet = ShellMessageBox(HINST_THISDLL, hwndOwner,
                MAKEINTRESOURCE(idTemplate),
                pszTitle, dwFlags, szErrMsg, pszParam);
    }

    return idRet;
}


STDAPI_(UINT) SHEnumErrorMessageBox(HWND hwnd, UINT idTemplate, DWORD err, LPCTSTR pszParam, BOOL fNet, UINT dwFlags)
{
    UINT idRet = IDCANCEL;
    TCHAR szErrMsg[MAX_PATH * 3];

    if (hwnd == NULL)
        return idRet;

    switch(err)
    {
    case WN_SUCCESS:
    case WN_CANCEL:
        return IDCANCEL;        // Don't retry

    case ERROR_OUTOFMEMORY:
        return IDABORT;         // Out of memory!
    }

    if (fNet)
    {
        TCHAR* pszMessageString;
        TCHAR szTitle[80];
        TCHAR szProvider[256];  // We don't use it.
        DWORD dwErrSize = ARRAYSIZE(szErrMsg);       // (DavePl) I expect a cch here, but no docs, could be cb
        DWORD dwProvSize = ARRAYSIZE(szProvider);

        szErrMsg[0] = 0;
        MultinetGetErrorText(szErrMsg, &dwErrSize, szProvider, &dwProvSize);

        if (szErrMsg[0] == 0)
            _LoadErrMsg(IDS_ENUMERR_NETGENERIC, szErrMsg, ARRAYSIZE(szErrMsg), err);

        if (GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)))
        {
            pszMessageString = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(idTemplate), szErrMsg, pszParam);

            if (pszMessageString)
            {
                idRet = SHMessageBoxHelp(hwnd, pszMessageString, szTitle, dwFlags, HRESULT_FROM_WIN32(err), NULL, 0);
                LocalFree(pszMessageString);
            }
            else
            {
                // Out of memory!
                return IDABORT;
            }
        }
    }
    else
    {
        idRet = SHSysErrorMessageBox(hwnd, NULL, idTemplate, err, pszParam, dwFlags);
    }
    return idRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\version.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "help.h"

#define DWORDUP(x)              (((x)+3)&~3)
#define VerKeyToValue(lpKey)    (lpKey + DWORDUP(lstrlen(lpKey)+1))

#pragma warning(disable: 4200)   // zero size array in struct

// magic undoced explort from version.dll

STDAPI_(BOOL) VerQueryValueIndexW(const void *pBlock, LPTSTR lpSubBlock, DWORD dwIndex, void **ppBuffer, void **ppValue, PUINT puLen);

#ifdef UNICODE
#define VerQueryValueIndex VerQueryValueIndexW
#endif

typedef struct 
{
    WORD wTotLen;
    WORD wValLen;
    TCHAR szKey[];
} SHELLVERBLOCK, *LPSHELLVERBLOCK;

// Following code is copied from fileman\wfdlgs2.c


//    The following data structure associates a version stamp datum
//    name (which is not localized) with a string ID.  This is so we
//    can show translations of these names to the user.
struct vertbl {
    TCHAR const *pszName;
    short idString;
};

//   Note that version stamp datum names are NEVER internationalized,
//   so the following literal strings are just fine.

const struct vertbl vernames[] = {

    // For the first NUM_SPECIAL_STRINGS, the second column is the dialog ID.

    { TEXT("LegalCopyright"),   IDD_VERSION_COPYRIGHT },
    { TEXT("FileDescription"),  IDD_VERSION_DESCRIPTION },

    // For the rest, the second column is the string ID.

    { TEXT("FileVersion"),              IDS_VN_FILEVERSION },
    { TEXT("Comments"),                 IDS_VN_COMMENTS },
    { TEXT("CompanyName"),              IDS_VN_COMPANYNAME },
    { TEXT("InternalName"),             IDS_VN_INTERNALNAME },
    { TEXT("LegalTrademarks"),  IDS_VN_LEGALTRADEMARKS },
    { TEXT("OriginalFilename"), IDS_VN_ORIGINALFILENAME },
    { TEXT("PrivateBuild"),             IDS_VN_PRIVATEBUILD },
    { TEXT("ProductName"),              IDS_VN_PRODUCTNAME },
    { TEXT("ProductVersion"),           IDS_VN_PRODUCTVERSION },
    { TEXT("SpecialBuild"),             IDS_VN_SPECIALBUILD }
};

#define NUM_SPECIAL_STRINGS     2
#define VERSTR_MANDATORY        TEXT("FileVersion")


typedef struct { // vp
    PROPSHEETPAGE psp;
    HWND hDlg;
    LPTSTR pVerBuffer;          /* pointer to version data */
    TCHAR szVersionKey[60];     /* big enough for anything we need */
    struct _VERXLATE
    {
        WORD wLanguage;
        WORD wCodePage;
    } *lpXlate;                     /* ptr to translations data */
    int cXlate;                 /* count of translations */
    LPTSTR pszXlate;
    int cchXlateString;
    TCHAR szFile[MAX_PATH];
} VERPROPSHEETPAGE, * LPVERPROPSHEETPAGE;


#define VER_KEY_END     25      /* length of "\StringFileInfo\xxxxyyyy\" */
                                /* (not localized) */
#define MAXMESSAGELEN   (50 + MAX_PATH * 2)


/*
    Gets a particular datum about a file.  The file's version info
    should have already been loaded by GetVersionInfo.  If no datum
    by the specified name is available, NULL is returned.  The name
    specified should be just the name of the item itself;  it will
    be concatenated onto "\StringFileInfo\xxxxyyyy\" automatically.

    Version datum names are not localized, so it's OK to pass literals
    such as "FileVersion" to this function.

    Note that since the returned datum is in a global memory block,
    the return value of this function is LPSTR, not PSTR.
*/
LPTSTR GetVersionDatum(LPVERPROPSHEETPAGE pvp, LPCTSTR pszName)
{
    UINT cbValue = 0;
    LPTSTR lpValue;
    HRESULT hr;

    if (!pvp->pVerBuffer)
        return NULL;

    hr = StringCchCopy(pvp->szVersionKey + VER_KEY_END, ARRAYSIZE(pvp->szVersionKey) - VER_KEY_END, pszName);
    if(SUCCEEDED(hr))
    {
        VerQueryValue(pvp->pVerBuffer, pvp->szVersionKey, (void **)&lpValue, &cbValue);
        return (cbValue != 0) ? lpValue : NULL;
    }
    else
    {
        return NULL;
    }
}

/*
    Frees global version data about a file.  After this call, all
    GetVersionDatum calls will return NULL.  To avoid memory leaks,
    always call this before the main properties dialog exits.
*/
void FreeVersionInfo(LPVERPROPSHEETPAGE pvp)
{
    if (pvp->pVerBuffer) 
    {
        GlobalFree(pvp->pVerBuffer);
        pvp->pVerBuffer = NULL;
    }
    if (pvp->pszXlate) 
    {
        LocalFree((HLOCAL)(HANDLE)pvp->pszXlate);
        pvp->pszXlate = NULL;
    }

    pvp->lpXlate = NULL;
}

/*
    Initialize version information for the properties dialog.  The
    above global variables are initialized by this function, and
    remain valid (for the specified file only) until FreeVersionInfo
    is called.

    The first language we try will be the first item in the
    "\VarFileInfo\Translations" section;  if there's nothing there,
    we try the one coded into the IDS_FILEVERSIONKEY resource string.
    If we can't even load that, we just use English (040904E4).  We
    also try English with a null codepage (04090000) since many apps
    were stamped according to an old spec which specified this as
    the required language instead of 040904E4.

    GetVersionInfo returns TRUE if the version info was read OK,
    otherwise FALSE.  If the return is FALSE, the buffer may still
    have been allocated;  always call FreeVersionInfo to be safe.

    pszPath is modified by this call (pszName is appended).
*/
BOOL GetVersionInfo(LPVERPROPSHEETPAGE pvp, LPCTSTR pszPath)
{
    UINT cbValue = 0;
    LPTSTR pszValue = NULL;
    DWORD dwHandle;             /* version subsystem handle */
    DWORD dwVersionSize;        /* size of the version data */

    FreeVersionInfo(pvp);       /* free old version buffer */

    // cast const -> non const for bad API def
    dwVersionSize = GetFileVersionInfoSize((LPTSTR)pszPath, &dwHandle);

    if (dwVersionSize == 0L)
        return FALSE;           /* no version info */

    pvp->pVerBuffer = GlobalAlloc(GPTR, dwVersionSize);
    if (pvp->pVerBuffer == NULL)
        return FALSE;

    // cast const -> non const for bad API def
    
    if (!GetFileVersionInfo((LPTSTR)pszPath, dwHandle, dwVersionSize, pvp->pVerBuffer))
    {
        return FALSE;
    }

    // Look for translations
    if (VerQueryValue(pvp->pVerBuffer, TEXT("\\VarFileInfo\\Translation"), (void **)&pvp->lpXlate, &cbValue)
                && cbValue)
    {
        pvp->cXlate = cbValue / sizeof(DWORD);
        pvp->cchXlateString = pvp->cXlate * 64;  /* figure 64 chars per lang name */
        pvp->pszXlate = (LPTSTR)(void*)LocalAlloc(LPTR, pvp->cchXlateString*sizeof(TCHAR));
        // failure of above will be handled later
    }
    else
    {
        pvp->lpXlate = NULL;
    }

    // Try same language as this program
    if (LoadString(HINST_THISDLL, IDS_VN_FILEVERSIONKEY, pvp->szVersionKey, ARRAYSIZE(pvp->szVersionKey)))
    {
        if (GetVersionDatum(pvp, VERSTR_MANDATORY))
        {
            return TRUE;
        }
    }

    // Try first language this supports
    if (pvp->lpXlate)
    {
        if(FAILED(StringCchPrintf(pvp->szVersionKey, ARRAYSIZE(pvp->szVersionKey), TEXT("\\StringFileInfo\\%04X%04X\\"),
                pvp->lpXlate[0].wLanguage, pvp->lpXlate[0].wCodePage)))
        {
            goto errRet;
        }
        if (GetVersionDatum(pvp, VERSTR_MANDATORY))  /* a required field */
        {
            return TRUE;
        }
    }

    // try English, unicode code page
    if(FAILED(StringCchCopy(pvp->szVersionKey, ARRAYSIZE(pvp->szVersionKey),TEXT("\\StringFileInfo\\040904B0\\"))))
    {
        goto errRet;
    }

    if (GetVersionDatum(pvp, VERSTR_MANDATORY))
    {
        return TRUE;
    }

    // try English
    if(FAILED(StringCchCopy(pvp->szVersionKey, ARRAYSIZE(pvp->szVersionKey), TEXT("\\StringFileInfo\\040904E4\\"))))
    {
        goto errRet;
    }

    if (GetVersionDatum(pvp, VERSTR_MANDATORY))
    {
        return TRUE;
    }

    // try English, null codepage
    if(FAILED(StringCchCopy(pvp->szVersionKey, ARRAYSIZE(pvp->szVersionKey), TEXT("\\StringFileInfo\\04090000\\"))))
    {
        goto errRet;
    }

    if (GetVersionDatum(pvp, VERSTR_MANDATORY))
    {
        return TRUE;
    }

    // Could not find FileVersion info in a reasonable format
errRet:
    GlobalFree(pvp->pVerBuffer);
    pvp->pVerBuffer = NULL;
    LocalFree(pvp->pszXlate);
    pvp->pszXlate = NULL;
    return FALSE;
}


/*
    Fills the version key listbox with all available keys in the
    StringFileInfo block, and sets the version value text to the
    value of the first item.
*/
void FillVersionList(LPVERPROPSHEETPAGE pvp)
{
    LPTSTR pszName;
    LPTSTR pszValue;
    TCHAR szStringBase[VER_KEY_END+1];
    int i, j, idx;
    TCHAR szMessage[MAXMESSAGELEN+1];
    UINT uOffset, cbValue;
    
    HWND hwndLB = GetDlgItem(pvp->hDlg, IDD_VERSION_KEY);
    
    ListBox_ResetContent(hwndLB);
    for (i=0; i<NUM_SPECIAL_STRINGS; ++i)
    {
        SetDlgItemText(pvp->hDlg, vernames[i].idString, szNULL);
    }
    
    pvp->szVersionKey[VER_KEY_END] = 0;        /* don't copy too much */
    StringCchCopy(szStringBase, ARRAYSIZE(szStringBase), pvp->szVersionKey);   /* copy to our buffer */
    szStringBase[VER_KEY_END - 1] = 0; /* strip the backslash */
    
    // Note: The Nt Version of version.dll has other exports.  If/When they are
    // available in Win version then we can remove this section...

    //  Get the binary file version from the VS_FIXEDFILEINFO
    {
        VS_FIXEDFILEINFO *pffi;
        if (VerQueryValue(pvp->pVerBuffer, TEXT("\\"), (void **)&pffi, &cbValue) && cbValue)
        {
            TCHAR szString[128];

            // display the binary version info, not the useless
            // string version (that can be out of sync)

            StringCchPrintf(szString, ARRAYSIZE(szString), TEXT("%d.%d.%d.%d"),
                HIWORD(pffi->dwFileVersionMS),
                LOWORD(pffi->dwFileVersionMS),
                HIWORD(pffi->dwFileVersionLS),
                LOWORD(pffi->dwFileVersionLS));
            SetDlgItemText(pvp->hDlg, IDD_VERSION_FILEVERSION, szString);
        }
    }

    //
    // Now iterate through all of the strings
    //
    for (j = 0; ; j++)
    {
        if (!VerQueryValueIndex(pvp->pVerBuffer, szStringBase, j, &pszName, &pszValue, &cbValue))
            break;
        
        for (i = 0; i < ARRAYSIZE(vernames); i++)
        {
            if (!lstrcmp(vernames[i].pszName, pszName))
            {
                break;
            }
        }
        
        if (i < NUM_SPECIAL_STRINGS)
        {
            SetDlgItemText(pvp->hDlg, vernames[i].idString, pszValue);
        }
        else
        {
            if (i == ARRAYSIZE(vernames) ||
                !LoadString(HINST_THISDLL, vernames[i].idString, szMessage, ARRAYSIZE(szMessage)))
            {
                StringCchCopy(szMessage, ARRAYSIZE(szMessage), pszName);
            }
            
            idx = ListBox_AddString(hwndLB, szMessage);
            if (idx != LB_ERR)
            {
                ListBox_SetItemData(hwndLB, idx, (DWORD_PTR)pszValue);
            }
        }
    }
    
    // Now look at the \VarFileInfo\Translations section and add an
    // item for the language(s) this file supports.
    
    if (pvp->lpXlate == NULL || pvp->pszXlate == NULL)
        return;
    
    if (!LoadString(HINST_THISDLL, (pvp->cXlate == 1) ? IDS_VN_LANGUAGE : IDS_VN_LANGUAGES,
        szMessage, ARRAYSIZE(szMessage)))
        return;
    
    idx = ListBox_AddString(hwndLB, szMessage);
    if (idx == LB_ERR)
        return;
    
    pvp->pszXlate[0] = 0;
    uOffset = 0;
    for (i = 0; i < pvp->cXlate; i++) {
        if (uOffset + 2 > (UINT)pvp->cchXlateString)
            break;
        if (i != 0) {
            StringCchCat(pvp->pszXlate, pvp->cchXlateString, TEXT(", "));
            uOffset += 2;       // skip over ", "
        }
        if (VerLanguageName(pvp->lpXlate[i].wLanguage, pvp->pszXlate + uOffset, pvp->cchXlateString - uOffset) >
            (DWORD)(pvp->cchXlateString - uOffset))
            break;
        uOffset += lstrlen(pvp->pszXlate + uOffset);
    }
    pvp->pszXlate[pvp->cchXlateString - 1] = 0;
    ListBox_SetItemData(hwndLB, idx, (LPARAM)(LPTSTR)pvp->pszXlate);
    ListBox_SetCurSel(hwndLB, 0);
    
    FORWARD_WM_COMMAND(pvp->hDlg, IDD_VERSION_KEY, hwndLB, LBN_SELCHANGE, PostMessage);
}


//
// Function:    _UpdateVersionPrsht, private
//
// Descriptions:
//   This function fills fields of the "version" dialog box (a page of
//  a property sheet) with attributes of the associated file.
//
// Returns:
//  TRUE, if successfully done; FALSE, otherwise.
//
// History:
//  01-06-93 Shrikant   Created
//
BOOL _UpdateVersionPrsht(LPVERPROPSHEETPAGE pvp)
{
    if (GetVersionInfo(pvp, pvp->szFile))           /* changes szPath */
        FillVersionList(pvp);

    return TRUE;
}


void _VersionPrshtCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    LPTSTR pszValue;
    int idx;
    
    switch (id)
    {
    case IDD_VERSION_KEY:
        if (codeNotify != LBN_SELCHANGE)
        {
            break;
        }
        
        idx = ListBox_GetCurSel(hwndCtl);
        pszValue = (LPTSTR)ListBox_GetItemData(hwndCtl, idx);
        if (pszValue)
        {
            SetDlgItemText(hwnd, IDD_VERSION_VALUE, pszValue);
        }
        break;
    }
}

// Array for context help:
static const DWORD aVersionHelpIds[] = {
    IDD_VERSION_FILEVERSION, IDH_FPROP_VER_ABOUT,
    IDD_VERSION_DESCRIPTION, IDH_FPROP_VER_ABOUT,
    IDD_VERSION_COPYRIGHT,   IDH_FPROP_VER_ABOUT,
    IDD_VERSION_FRAME,       IDH_FPROP_VER_INFO,
    IDD_VERSION_KEY,         IDH_FPROP_VER_INFO,
    IDD_VERSION_VALUE,       IDH_FPROP_VER_INFO,

    0, 0
};

BOOL_PTR CALLBACK _VersionPrshtDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LPVERPROPSHEETPAGE pvp = (LPVERPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pvp = (LPVERPROPSHEETPAGE)lParam;
        pvp->hDlg = hDlg;
        break;

    case WM_DESTROY:
        FreeVersionInfo(pvp);   // free anything we created
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP,
            (ULONG_PTR) (LPTSTR) aVersionHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPTSTR) aVersionHelpIds);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            _UpdateVersionPrsht(pvp);
            break;
        }
        break;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, _VersionPrshtCommand);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//
// creates a property sheet for the "version" page which shows version information.
//
STDAPI_(void) AddVersionPage(LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    DWORD dwAttr = GetFileAttributes(pszFile);
    if (0xFFFFFFFF != dwAttr && 0 == (dwAttr & FILE_ATTRIBUTE_OFFLINE) /*avoid HSM recall*/)
    {
        DWORD dwVerLen, dwVerHandle;
        VERPROPSHEETPAGE vp = {0};

        if(SUCCEEDED(StringCchCopy(vp.szFile, ARRAYSIZE(vp.szFile), pszFile)))  // silent failure appears OK from above
        {

            dwVerLen = GetFileVersionInfoSize(vp.szFile, &dwVerHandle);
            if (dwVerLen) 
            {
                HPROPSHEETPAGE hpage;

                vp.psp.dwSize = sizeof(VERPROPSHEETPAGE);     // extra data
                vp.psp.dwFlags = PSP_DEFAULT;
                vp.psp.hInstance = HINST_THISDLL;
                vp.psp.pszTemplate = MAKEINTRESOURCE(DLG_VERSION);
                vp.psp.pfnDlgProc = _VersionPrshtDlgProc;

                hpage = CreatePropertySheetPage(&vp.psp);
                if (hpage)
                    if (!pfnAddPage(hpage, lParam))
                        DestroyPropertySheetPage(hpage);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\views.h ===
#ifndef SHELL32_VIEWS_INC
#define SHELL32_VIEWS_INC

#include "idlcomm.h"
#include "pidl.h"


// Some constants for folder callbacks
#define DEFVIEW_FVM_MANY_CUTOFF 50
#define DEFVIEW_FVM_FEW_CUTOFF  25

// VIEWCOMM.C
STDAPI_(LPTSTR) SHGetCaption(HIDA hida);
STDAPI SHPropertiesForPidl(HWND hwnd, LPCITEMIDLIST pidlFull, LPCTSTR lpParameters);

// RUNDLL32.C
STDAPI_(BOOL) SHRunDLLProcess(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow, UINT idStr, BOOL fRunAsNewUser);
STDAPI_(BOOL) SHRunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow);

// CPLOBJ.C
STDAPI_(BOOL) SHRunControlPanelEx(LPCTSTR pszOrigCmdLine, HWND hwnd, BOOL fRunAsNewUser);


// REGITMS.C

typedef struct
{
    const CLSID * pclsid;
    UINT    uNameID;
    LPCTSTR pszIconFile;
    int     iDefIcon;
    BYTE    bOrder;
    DWORD   dwAttributes;
    LPCTSTR pszCPL;
} REQREGITEM;

#define RIISA_ORIGINAL              0x00000001  // regitems first then rest (desktop)
#define RIISA_FOLDERFIRST           0x00000002  // folders first then the rest (regitems or not)
#define RIISA_ALPHABETICAL          0x00000004  // alphabetical (doesn't care about folder, regitems, ...)

typedef struct
{
    LPCTSTR pszAllow;
    RESTRICTIONS restAllow;
    LPCTSTR pszDisallow;
    RESTRICTIONS restDisallow;
} REGITEMSPOLICY;

typedef struct
{
    LPCTSTR             pszRegKey;      // registry location for this name space
    REGITEMSPOLICY*     pPolicy;        // registry location to look for Restrict and Disallow info
    TCHAR               cRegItem;       // parsing prefix, must be TEXT(':')
    BYTE                bFlags;         // flags field for PIDL construction
    int                 iCmp;           // compare multiplier used to revers the sort order
    DWORD               rgfRegItems;    // default attributes for items
    int                 iReqItems;      // # of required items
    REQREGITEM const *  pReqItems;      // require items array
    DWORD               dwSortAttrib;   // sorting attributes
    LPCTSTR             pszMachine;     // optional remote machine to init items from (\\server)
    DWORD               cbPadding;      // Number of bytes of padding to put between IDREGITEMEX.bOrder and IDREGITEMEX.clsid
    BYTE                bFlagsLegacy;   // legacy "bFlags", so that we can handle previous bFlags (equiv of cbPadding = 0)
                                        // CANNOT be 0, 0 means no bFlagsLegacy
} REGITEMSINFO;

// class factory like entry to create the regitems folder. it only supports the agregatied case

STDAPI CRegFolder_CreateInstance(REGITEMSINFO *pri, IUnknown *punkOutter, REFIID riid, void **ppv);
STDAPI_(BOOL) RegGetsFirstShot(REFIID riid);

// this should be private
#pragma pack(1)
typedef struct
{
    IDREGITEM       idri;
    USHORT          cbNext;
} IDLREGITEM;           // "RegItem" IDList
typedef UNALIGNED IDLREGITEM *LPIDLREGITEM;
typedef const UNALIGNED IDLREGITEM *LPCIDLREGITEM;
#pragma pack()

EXTERN_C const IDLREGITEM c_idlNet;
EXTERN_C const IDLREGITEM c_idlDrives;
EXTERN_C const IDLREGITEM c_idlInetRoot;
EXTERN_C const IDLREGITEM c_idlMyDocs;

#define MAX_REGITEMCCH  128     // for rename in place operations

//--------------------------------------------------------------------------
// Menu offset-IDs for object context menu (CFSMenu)
//  They must be 0-based and not too big (<0x3ff)
//  We are lumping all of the DefView clients in here so that we are
//  sure the ID ranges are separate (making MenuHelp easier)
//---------------------------------------------------------------------------
#define FSIDM_OBJPROPS_FIRST    0x0000
#define FSIDM_PROPERTIESBG      (FSIDM_OBJPROPS_FIRST + 0x0000)

// find extension commands
#define FSIDM_FINDFILES         0x0004
#define FSIDM_FINDCOMPUTER      0x0005
#define FSIDM_SAVESEARCH        0x0006
#define FSIDM_OPENCONTAININGFOLDER 0x0007

#define FSIDM_DRIVES_FIRST      0x0008
#define FSIDM_FORMAT            (FSIDM_DRIVES_FIRST + 0x0000)
#define FSIDM_DISCONNECT        (FSIDM_DRIVES_FIRST + 0x0001)
#define FSIDM_EJECT             (FSIDM_DRIVES_FIRST + 0x0002)
#define FSIDM_DISKCOPY          (FSIDM_DRIVES_FIRST + 0x0003)
#define FSIDM_DRIVES_LAST       (FSIDM_DRIVES_FIRST + 0x0004)

#define FSIDM_NETWORK_FIRST     (FSIDM_DRIVES_LAST + 0x0000)
#define FSIDM_CONNECT           (FSIDM_NETWORK_FIRST + 0x0001)
#define FSIDM_NETPRN_INSTALL    (FSIDM_NETWORK_FIRST + 0x0002)
#define FSIDM_CONNECT_PRN       (FSIDM_NETWORK_FIRST + 0x0003)
#define FSIDM_DISCONNECT_PRN    (FSIDM_NETWORK_FIRST + 0x0004)
#define FSIDM_NETWORK_LAST      (FSIDM_NETWORK_FIRST + 0x0005)

// Command offsets for context menu (verb ids must be mutually exclusive
// from non-verb ids.  Non-verb ids are first for easier menu merging.)
// non-verb ids:
#define FSIDM_CPLPRN_FIRST      (FSIDM_NETWORK_LAST + 0x0000)
#define FSIDM_SETDEFAULTPRN     (FSIDM_CPLPRN_FIRST + 0x0001)
#define FSIDM_SHARING           (FSIDM_CPLPRN_FIRST + 0x0002)
#define FSIDM_DOCUMENTDEFAULTS  (FSIDM_CPLPRN_FIRST + 0x0003)
#define FSIDM_SERVERPROPERTIES  (FSIDM_CPLPRN_FIRST + 0x0004)
#define FSIDM_ADDPRINTERWIZARD  (FSIDM_CPLPRN_FIRST + 0x0005)
#define FSIDM_SENDFAXWIZARD     (FSIDM_CPLPRN_FIRST + 0x0006)
#define FSIDM_SETUPFAXING       (FSIDM_CPLPRN_FIRST + 0x0007)

// verb ids:
#define FSIDM_OPENPRN           (FSIDM_CPLPRN_FIRST + 0x0008)
#define FSIDM_RESUMEPRN         (FSIDM_CPLPRN_FIRST + 0x0009)
#define FSIDM_PAUSEPRN          (FSIDM_CPLPRN_FIRST + 0x000a)
#define FSIDM_WORKONLINE        (FSIDM_CPLPRN_FIRST + 0x000b)
#define FSIDM_WORKOFFLINE       (FSIDM_CPLPRN_FIRST + 0x000c)
#define FSIDM_PURGEPRN          (FSIDM_CPLPRN_FIRST + 0x000d)
#define FSIDM_CREATELOCALFAX    (FSIDM_CPLPRN_FIRST + 0x000e)
#define FSIDM_CPLPRN_LAST       (FSIDM_CPLPRN_FIRST + 0x000e)

#define FSIDM_RUNAS_FIRST       (FSIDM_CPLPRN_LAST + 0x0000)
#define FSIDM_RUNAS             (FSIDM_RUNAS_FIRST + 0x0001)
#define FSIDM_RUNAS_SHARING     (FSIDM_RUNAS_FIRST + 0x0002)
#define FSIDM_RUNAS_ADDPRN      (FSIDM_RUNAS_FIRST + 0x0003)
#define FSIDM_RUNAS_SVRPROP     (FSIDM_RUNAS_FIRST + 0x0004)
#define FSIDM_RUNAS_OPENPRN     (FSIDM_RUNAS_FIRST + 0x0005)
#define FSIDM_RUNAS_RESUMEPRN   (FSIDM_RUNAS_FIRST + 0x0006)
#define FSIDM_RUNAS_PAUSEPRN    (FSIDM_RUNAS_FIRST + 0x0007)
#define FSIDM_RUNAS_WORKONLINE  (FSIDM_RUNAS_FIRST + 0x0008)
#define FSIDM_RUNAS_WORKOFFLINE (FSIDM_RUNAS_FIRST + 0x0009)
#define FSIDM_RUNAS_PURGEPRN    (FSIDM_RUNAS_FIRST + 0x0010)
#define FSIDM_RUNAS_DELETE      (FSIDM_RUNAS_FIRST + 0x0011)
#define FSIDM_RUNAS_PROPERTIES  (FSIDM_RUNAS_FIRST + 0x0012)
#define FSIDM_RUNAS_LAST        (FSIDM_RUNAS_FIRST + 0x001f)


// these need to be in the same order as the ICOL in fstreex.c (chee)
#define FSIDM_SORT_FIRST        (FSIDM_RUNAS_LAST + 0x0000)
#define FSIDM_SORT_LAST         (FSIDM_SORT_FIRST + 0x0010)

#define FSIDM_MENUSENDTO_FIRST  (FSIDM_SORT_LAST + 0x0000)
#define FSIDM_MENU_SENDTO       (FSIDM_MENUSENDTO_FIRST + 0x0001)
#define FSIDM_SENDTOFIRST       (FSIDM_MENUSENDTO_FIRST + 0x0002)
#define FSIDM_SENDTOLAST        (FSIDM_MENUSENDTO_FIRST + 0x0013)
#define FSIDM_MENUSENDTO_LAST   (FSIDM_MENUSENDTO_FIRST + 0x0014)

#define FSIDM_MENUNEW_FIRST     (FSIDM_MENUSENDTO_LAST + 0x0000)
#define FSIDM_MENU_NEW          (FSIDM_MENUNEW_FIRST + 0x0001)
#define FSIDM_NEWFOLDER         (FSIDM_MENUNEW_FIRST + 0x0002)
#define FSIDM_NEWLINK           (FSIDM_MENUNEW_FIRST + 0x0003)
#define FSIDM_NEWOTHER          (FSIDM_MENUNEW_FIRST + 0x0004)
#define FSIDM_NEWLAST           (FSIDM_MENUNEW_FIRST + 0x0027)
#define FSIDM_MENUNEW_LAST      (FSIDM_MENUNEW_FIRST + 0x0028)

// BITBUCKET ids.
#define FSIDM_BITBUCKET_FIRST   (FSIDM_MENUNEW_LAST + 0x0000)
#define FSIDM_RESTORE           (FSIDM_BITBUCKET_FIRST + 0x0001)
#define FSIDM_PURGE             (FSIDM_BITBUCKET_FIRST + 0x0002)
#define FSIDM_PURGEALL          (FSIDM_BITBUCKET_FIRST + 0x0003)
#define FSIDM_BITBUCKET_LAST    (FSIDM_BITBUCKET_FIRST + 0x0004)

// cd burn ids.
#define FSIDM_BURN_FIRST        (FSIDM_BITBUCKET_LAST + 0x0000)
#define FSIDM_BURN              (FSIDM_BURN_FIRST + 0x0001)
#define FSIDM_CLEANUP           (FSIDM_BURN_FIRST + 0x0002)
#define FSIDM_ERASE             (FSIDM_BURN_FIRST + 0x0003)
#define FSIDM_BURN_LAST         (FSIDM_BURN_FIRST + 0x0004)

//---------------------------------------------------------------------------
// Briefcase view specific command IDs
//
#define FSIDM_BRIEFCASE_FIRST   (FSIDM_BURN_LAST + 0x0000)
#define FSIDM_MENU_BRIEFCASE    (FSIDM_BRIEFCASE_FIRST + 0x0001)
#define FSIDM_UPDATEALL         (FSIDM_BRIEFCASE_FIRST + 0x0002)
#define FSIDM_UPDATESELECTION   (FSIDM_BRIEFCASE_FIRST + 0x0003)
#define FSIDM_SPLIT             (FSIDM_BRIEFCASE_FIRST + 0x0004)
#define FSIDM_BRIEFCASE_LAST    (FSIDM_BRIEFCASE_FIRST + 0x00b0)


//---------------------------------------------------------------------------
// Items added by DefCM
//
// HACK: Put these at the same offsets from each other as the SFVIDM
// commands so that we can easily reuse the help strings and the menu
// initialization code
//
#define DCMIDM_LINK             SHARED_FILE_LINK
#define DCMIDM_DELETE           SHARED_FILE_DELETE
#define DCMIDM_RENAME           SHARED_FILE_RENAME
#define DCMIDM_PROPERTIES       SHARED_FILE_PROPERTIES

#define DCMIDM_CUT              SHARED_EDIT_CUT
#define DCMIDM_COPY             SHARED_EDIT_COPY
#define DCMIDM_PASTE            SHARED_EDIT_PASTE

//
// Now for the MenuHelp ID's for the defview client menu commands
//
#define IDS_MH_PROPERTIESBG     (IDS_MH_FSIDM_FIRST + FSIDM_PROPERTIESBG)

#define IDS_MH_FORMAT           (IDS_MH_FSIDM_FIRST + FSIDM_FORMAT)
#define IDS_MH_DISCONNECT       (IDS_MH_FSIDM_FIRST + FSIDM_DISCONNECT)
#define IDS_MH_EJECT            (IDS_MH_FSIDM_FIRST + FSIDM_EJECT)
#define IDS_MH_DISKCOPY         (IDS_MH_FSIDM_FIRST + FSIDM_DISKCOPY)

#define IDS_MH_CONNECT          (IDS_MH_FSIDM_FIRST + FSIDM_CONNECT)

#define IDS_MH_NETPRN_INSTALL   (IDS_MH_FSIDM_FIRST + FSIDM_NETPRN_INSTALL)
#define IDS_MH_CONNECT_PRN      (IDS_MH_FSIDM_FIRST + FSIDM_CONNECT_PRN)
#define IDS_MH_DISCONNECT_PRN   (IDS_MH_FSIDM_FIRST + FSIDM_DISCONNECT_PRN)

#define IDS_MH_SETDEFAULTPRN    (IDS_MH_FSIDM_FIRST + FSIDM_SETDEFAULTPRN)

#define IDS_MH_SERVERPROPERTIES (IDS_MH_FSIDM_FIRST + FSIDM_SERVERPROPERTIES)
#define IDS_MH_ADDPRINTERWIZARD (IDS_MH_FSIDM_FIRST + FSIDM_ADDPRINTERWIZARD)
#define IDS_MH_SENDFAXWIZARD    (IDS_MH_FSIDM_FIRST + FSIDM_SENDFAXWIZARD)
#define IDS_MH_SHARING          (IDS_MH_FSIDM_FIRST + FSIDM_SHARING)
#define IDS_MH_DOCUMENTDEFAULTS (IDS_MH_FSIDM_FIRST + FSIDM_DOCUMENTDEFAULTS )

#define IDS_MH_OPENPRN          (IDS_MH_FSIDM_FIRST + FSIDM_OPENPRN)
#define IDS_MH_RESUMEPRN        (IDS_MH_FSIDM_FIRST + FSIDM_RESUMEPRN)
#define IDS_MH_PAUSEPRN         (IDS_MH_FSIDM_FIRST + FSIDM_PAUSEPRN)
#define IDS_MH_WORKONLINE       (IDS_MH_FSIDM_FIRST + FSIDM_WORKONLINE)
#define IDS_MH_WORKOFFLINE      (IDS_MH_FSIDM_FIRST + FSIDM_WORKOFFLINE)
#define IDS_MH_PURGEPRN         (IDS_MH_FSIDM_FIRST + FSIDM_PURGEPRN)
#define IDS_MH_SETUPFAXING      (IDS_MH_FSIDM_FIRST + FSIDM_SETUPFAXING)
#define IDS_MH_CREATELOCALFAX   (IDS_MH_FSIDM_FIRST + FSIDM_CREATELOCALFAX)

#define IDS_MH_RUNAS            (IDS_MH_FSIDM_FIRST + FSIDM_RUNAS)

#define IDS_MH_MENU_SENDTO      (IDS_MH_FSIDM_FIRST + FSIDM_MENU_SENDTO)
#define IDS_MH_SENDTOFIRST      (IDS_MH_FSIDM_FIRST + FSIDM_SENDTOFIRST)
#define IDS_MH_SENDTOLAST       (IDS_MH_FSIDM_FIRST + FSIDM_SENDTOLAST)

#define IDS_MH_MENU_NEW         (IDS_MH_FSIDM_FIRST + FSIDM_MENU_NEW)
#define IDS_MH_NEWFOLDER        (IDS_MH_FSIDM_FIRST + FSIDM_NEWFOLDER)
#define IDS_MH_NEWLINK          (IDS_MH_FSIDM_FIRST + FSIDM_NEWLINK)
#define IDS_MH_NEWOTHER         (IDS_MH_FSIDM_FIRST + FSIDM_NEWOTHER)

#define IDS_MH_MENU_BRIEFCASE   (IDS_MH_FSIDM_FIRST + FSIDM_MENU_BRIEFCASE)
#define IDS_MH_UPDATEALL        (IDS_MH_FSIDM_FIRST + FSIDM_UPDATEALL)
#define IDS_MH_UPDATESELECTION  (IDS_MH_FSIDM_FIRST + FSIDM_UPDATESELECTION)
#define IDS_MH_SPLIT            (IDS_MH_FSIDM_FIRST + FSIDM_SPLIT)

// bitbucket menu help strings
#define IDS_MH_RESTORE          (IDS_MH_FSIDM_FIRST + FSIDM_RESTORE)
#define IDS_MH_PURGE            (IDS_MH_FSIDM_FIRST + FSIDM_PURGE)
#define IDS_MH_PURGEALL         (IDS_MH_FSIDM_FIRST + FSIDM_PURGEALL)

// find extensions
#define IDS_MH_FINDFILES        (IDS_MH_FSIDM_FIRST + FSIDM_FINDFILES)
#define IDS_MH_FINDCOMPUTER     (IDS_MH_FSIDM_FIRST + FSIDM_FINDCOMPUTER)

#define IDS_TT_UPDATEALL        (IDS_TT_FSIDM_FIRST + FSIDM_UPDATEALL)
#define IDS_TT_UPDATESELECTION  (IDS_TT_FSIDM_FIRST + FSIDM_UPDATESELECTION)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\viewstate.cpp ===
#include "shellprv.h"
#include "defviewp.h"
#include "ViewState.h"


CViewState::CViewState()
{
    ASSERT(_lParamSort == NULL);
    ASSERT(_iDirection == 0);
    ASSERT(_iLastColumnClick == 0);
    ASSERT(_ViewMode == 0);
    ASSERT(_ptScroll.x == 0 && _ptScroll.y == 0);
    ASSERT(_guidGroupID == GUID_NULL);
    ASSERT(_scidDetails.fmtid == GUID_NULL);
    ASSERT(_scidDetails.pid == 0);
    ASSERT(_hdsaColumnOrder == NULL);
    ASSERT(_hdsaColumnWidths == NULL);
    ASSERT(_hdsaColumnStates == NULL);
    ASSERT(_hdpaItemPos == NULL);
    ASSERT(_pbPositionData == NULL);

    _iDirection = 1;

    _fFirstViewed = TRUE;       // Assume this is the first time we are looking at a folder.
}

CViewState::~CViewState()
{
    if (_hdsaColumnOrder)
        DSA_Destroy(_hdsaColumnOrder);

    if (_hdsaColumnWidths)
        DSA_Destroy(_hdsaColumnWidths);

    if (_hdsaColumnStates)
        DSA_Destroy(_hdsaColumnStates);

    if (_hdsaColumns)
        DSA_Destroy(_hdsaColumns);

    ClearPositionData();

    LocalFree(_pbPositionData); // accepts NULL
}



// When initializing a new DefView, see if we can 
// propogate information from the previous one.
void CViewState::InitFromPreviousView(IUnknown* pPrevView)
{
    CDefView *pdsvPrev;
    if (SUCCEEDED(pPrevView->QueryInterface(IID_PPV_ARG(CDefView, &pdsvPrev))))
    {
        // preserve stuff like sort order
        _lParamSort = pdsvPrev->_vs._lParamSort;
        _iDirection = pdsvPrev->_vs._iDirection;
        _iLastColumnClick = pdsvPrev->_vs._iLastColumnClick;
        pdsvPrev->Release();
    }
}

void CViewState::InitFromHeader(DVSAVEHEADER_COMBO* pdv)
{
    _lParamSort = pdv->dvSaveHeader.dvState.lParamSort;
    _iDirection = pdv->dvSaveHeader.dvState.iDirection;
    // Patch this up. I guess at one time we persisted this wrong.
    if (_iDirection == 0)
        _iDirection = 1;
    _iLastColumnClick = pdv->dvSaveHeader.dvState.iLastColumnClick;
    _ViewMode = pdv->dvSaveHeader.ViewMode;
    _ptScroll = pdv->dvSaveHeader.ptScroll;
}

void CViewState::GetDefaults(CDefView* pdv, LPARAM* plParamSort, int* piDirection, int* piLastColumnClick)
{
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SORTCOLUMNS, FALSE);
    if (plParamSort)
        *plParamSort = ss.lParamSort;

    if (piDirection)
        *piDirection = ss.iSortDirection ? ss.iSortDirection : 1;
    if (piLastColumnClick)
        *piLastColumnClick = -1;
    pdv->CallCB(SFVM_GETSORTDEFAULTS, (LPARAM)piDirection, (WPARAM)plParamSort);
}

void CViewState::InitWithDefaults(CDefView* pdv)
{
    GetDefaults(pdv, &_lParamSort, &_iDirection, &_iLastColumnClick);
}

int CALLBACK CViewState::_SavedItemCompare(void *p1, void *p2, LPARAM lParam)
{
    CDefView *pdv = reinterpret_cast<CDefView*>(lParam);

    UNALIGNED VIEWSTATE_POSITION *pdvi1 = (UNALIGNED VIEWSTATE_POSITION *)p1;
    UNALIGNED VIEWSTATE_POSITION *pdvi2 = (UNALIGNED VIEWSTATE_POSITION *)p2;

    // manually terminate these pidls because they are packed together
    // in the save buffer

    LPITEMIDLIST pFakeEnd1 = _ILNext(&pdvi1->idl);
    USHORT uSave1 = pFakeEnd1->mkid.cb;
    pFakeEnd1->mkid.cb = 0;

    LPITEMIDLIST pFakeEnd2 = _ILNext(&pdvi2->idl);
    USHORT uSave2 = pFakeEnd2->mkid.cb;
    pFakeEnd2->mkid.cb = 0;

    int nCmp = pdv->_Compare(&pdvi1->idl, &pdvi2->idl, reinterpret_cast<LPARAM>(pdv));

    pFakeEnd2->mkid.cb = uSave2;
    pFakeEnd1->mkid.cb = uSave1;

    return nCmp;
}

BOOL CViewState::SyncPositions(CDefView* pdv)
{
    if (_ViewMode != pdv->_fs.ViewMode)
    {
        return FALSE;
    }

    if (_hdpaItemPos == NULL || DPA_GetPtrCount(_hdpaItemPos) == 0)
    {
        return FALSE;
    }

    if (DPA_Sort(_hdpaItemPos, _SavedItemCompare, (LPARAM)pdv))
    {
        UNALIGNED VIEWSTATE_POSITION * UNALIGNED * ppDVItem = (UNALIGNED VIEWSTATE_POSITION * UNALIGNED *)DPA_GetPtrPtr(_hdpaItemPos);
        UNALIGNED VIEWSTATE_POSITION * UNALIGNED *ppEndDVItems = ppDVItem + DPA_GetPtrCount(_hdpaItemPos);

        // Turn off auto-arrange and snap-to-grid if it's on at the mo.
        DWORD dwStyle = GetWindowStyle(pdv->_hwndListview);
        if (dwStyle & LVS_AUTOARRANGE)
            SetWindowLong(pdv->_hwndListview, GWL_STYLE, dwStyle & ~LVS_AUTOARRANGE);
            
        DWORD dwLVExStyle = ListView_GetExtendedListViewStyle(pdv->_hwndListview);
        if (dwLVExStyle & LVS_EX_SNAPTOGRID)
            ListView_SetExtendedListViewStyle(pdv->_hwndListview, dwLVExStyle & ~LVS_EX_SNAPTOGRID);

        HDSA hdsaPositionlessItems = NULL;
        int iCount = ListView_GetItemCount(pdv->_hwndListview);
        for (int i = 0; i < iCount; i++)
        {
            LPCITEMIDLIST pidl = pdv->_GetPIDL(i);

            // need to check for pidl because this could be on a background
            // thread and an fsnotify could be coming through to blow it away
            for ( ; pidl ; )
            {
                int nCmp;

                if (ppDVItem < ppEndDVItems)
                {
                    // We terminate the IDList manually after saving
                    // the needed information.  Note we will not GP fault
                    // since we added sizeof(ITEMIDLIST) onto the Alloc
                    LPITEMIDLIST pFakeEnd = _ILNext(&(*ppDVItem)->idl);
                    USHORT uSave = pFakeEnd->mkid.cb;
                    pFakeEnd->mkid.cb = 0;

                    nCmp = pdv->_Compare(&((*ppDVItem)->idl), (void *)pidl, (LPARAM)pdv);

                    pFakeEnd->mkid.cb = uSave;
                }
                else
                {
                    // do this by default.  this prevents overlap of icons
                    //
                    // i.e.  if we've run out of saved positions information,
                    // we need to just loop through and set all remaining items
                    // to position 0x7FFFFFFFF so that when it's really shown,
                    // the listview will pick a new (unoccupied) spot.
                    // breaking out now would leave it were the _Sort
                    // put it, but another item with saved state info could
                    // have come and be placed on top of it.
                    nCmp = 1;
                }

                if (nCmp > 0)
                {
                    // We did not find the item
                    // reset it's position to be recomputed

                    if (NULL == hdsaPositionlessItems)
                        hdsaPositionlessItems = DSA_Create(sizeof(int), 16);

                    if (hdsaPositionlessItems)
                        DSA_AppendItem(hdsaPositionlessItems, (void*)&i);

                    break;
                }
                else if (nCmp == 0) // They are equal
                {
                    UNALIGNED VIEWSTATE_POSITION * pDVItem = *ppDVItem;
                    
                    pdv->_SetItemPosition(i, pDVItem->pt.x, pDVItem->pt.y);

                    ppDVItem++; // move on to the next
                    break;
                }

                ppDVItem++; // move to the next
            }
        }

        if (hdsaPositionlessItems)
        {
            for (i = 0; i < DSA_GetItemCount(hdsaPositionlessItems); i++)
            {
                int* pIndex = (int*)DSA_GetItemPtr(hdsaPositionlessItems, i);
                pdv->_SetItemPosition(*pIndex, 0x7FFFFFFF, 0x7FFFFFFF);
            }

            DSA_Destroy(hdsaPositionlessItems);
        }

        // Turn auto-arrange and snap to grid back on if needed...
        if (dwLVExStyle & LVS_EX_SNAPTOGRID)
            ListView_SetExtendedListViewStyle(pdv->_hwndListview, dwLVExStyle);

        if (dwStyle & LVS_AUTOARRANGE)
            SetWindowLong(pdv->_hwndListview, GWL_STYLE, dwStyle);
    }
    return TRUE;
}

void CViewState::LoadPositionBlob(CDefView* pdv, DWORD cbSizeofStream, IStream* pstm)
{
    // Allocate a blob of memory to hold the position info.
    if (_pbPositionData) 
        LocalFree(_pbPositionData);

    _pbPositionData = (BYTE*)LocalAlloc(LPTR, cbSizeofStream);
    if (_pbPositionData == NULL)
        return;

    // Read into that blob.
    if (SUCCEEDED(pstm->Read(_pbPositionData, cbSizeofStream, NULL)))
    {
        // Walk the blob, and append to the DPA.
        UNALIGNED VIEWSTATE_POSITION *pDVItem = (UNALIGNED VIEWSTATE_POSITION *)(_pbPositionData);
        UNALIGNED VIEWSTATE_POSITION *pDVEnd = (UNALIGNED VIEWSTATE_POSITION *)(_pbPositionData + cbSizeofStream - sizeof(VIEWSTATE_POSITION));

        ClearPositionData();  // destroy _hdpaItemPos

        // Grow every 16 items
        _hdpaItemPos = DPA_Create(16);
        if (_hdpaItemPos)
        {
            for ( ; ; pDVItem = (UNALIGNED VIEWSTATE_POSITION *)_ILNext(&pDVItem->idl))
            {
                if (pDVItem > pDVEnd)
                {
                    break;  // Invalid list
                }

                // End normally when we reach a NULL IDList
                if (pDVItem->idl.mkid.cb == 0)
                {
                    break;
                }

                if (DPA_AppendPtr(_hdpaItemPos, pDVItem) < 0)
                {
                    break;
                }
            }
        }
    }
}

HRESULT CViewState::SavePositionBlob(CDefView* pdv, IStream* pstm)
{
    HRESULT hr = S_FALSE;   // success, but did nothing

    if (pdv->_fUserPositionedItems && pdv->_IsPositionedView())
    {
        VIEWSTATE_POSITION dvitem = {0};
        int iCount = ListView_GetItemCount(pdv->_hwndListview);
        for (int i = 0; SUCCEEDED(hr) && (i < iCount); i++)
        {
            ListView_GetItemPosition(pdv->_hwndListview, i, &dvitem.pt);

            hr = pstm->Write(&dvitem.pt, sizeof(dvitem.pt), NULL);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidl = pdv->_GetPIDL(i);
                if (pidl)
                    hr = pstm->Write(pidl, pidl->mkid.cb, NULL);
                else
                    hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Terminate the list with a NULL IDList
            dvitem.idl.mkid.cb = 0;
            hr = pstm->Write(&dvitem, sizeof(dvitem), NULL);
        }
    }
    return hr;
}

void CViewState::ClearPositionData()
{
    if (_hdpaItemPos)
    {
        DPA_Destroy(_hdpaItemPos);
        _hdpaItemPos = NULL;
    }
}

UINT CViewState::GetColumnCount()       
{ 
    if (!_hdsaColumns) 
        return 0; 

    return DSA_GetItemCount(_hdsaColumns);    
}

DWORD CViewState::GetColumnState(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->csFlags;
    }

    return 0;
}

DWORD CViewState::GetTransientColumnState(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->tsFlags;
    }

    return 0;
}

void CViewState::SetColumnState(UINT uCol, DWORD dwMask, DWORD dwNewBits)
{
    if (_hdsaColumns && uCol < GetColumnCount())
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        pci->csFlags = (pci->csFlags & ~dwMask) | (dwNewBits & dwMask);
    }
}

void CViewState::SetTransientColumnState(UINT uCol, DWORD dwMask, DWORD dwNewBits)
{
    if (_hdsaColumns && uCol < GetColumnCount())
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        pci->tsFlags = (pci->tsFlags & ~dwMask) | (dwNewBits & dwMask);
    }
}

LPTSTR CViewState::GetColumnName(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->szName;
    }

    return NULL;
}

UINT CViewState::GetColumnCharCount(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->cChars;
    }

    return 0;
}

int CViewState::GetColumnFormat(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->fmt;
    }

    return 0;
}


HRESULT CViewState::InitializeColumns(CDefView* pdv)
{
    if (_hdsaColumns != NULL)
        return S_OK;

    _hdsaColumns = DSA_Create(sizeof(COL_INFO), 6);

    if (!_hdsaColumns)
        return E_OUTOFMEMORY;

    for (UINT iReal = 0; ; iReal++)
    {
        DETAILSINFO di = {0};
        di.fmt  = LVCFMT_LEFT;
        di.cxChar = 20;
        di.str.uType = (UINT)-1;

        if (SUCCEEDED(pdv->_GetDetailsHelper(iReal, &di)))
        {
            COL_INFO ci = {0};

            StrRetToBuf(&di.str, NULL, ci.szName, ARRAYSIZE(ci.szName));
            ci.cChars = di.cxChar;
            ci.csFlags = pdv->_DefaultColumnState(iReal);
            ci.fmt = di.fmt;

            DSA_AppendItem(_hdsaColumns, &ci);
        }
        else
            break;
    }

    // Set up saved column state only if the saved state
    // contains information other than "nothing".

    if (_hdsaColumnStates)
    {
        UINT cStates = DSA_GetItemCount(_hdsaColumnStates);
        if (cStates > 0)
        {
            // 99/02/05 vtan: If there is a saved column state then
            // clear all the column "on" states to "off" and only
            // display what columns are specified. Start at 1 so
            // that name is always on.

            for (iReal = 1; iReal < GetColumnCount(); iReal++)
            {
                COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, iReal);
                pci->csFlags &= ~SHCOLSTATE_ONBYDEFAULT;
            }

            for (UINT i = 0; i < cStates; i++)
            {
                DWORD dw;
                DSA_GetItem(_hdsaColumnStates, i, &dw);
                SetColumnState(dw, SHCOLSTATE_ONBYDEFAULT, SHCOLSTATE_ONBYDEFAULT);
            }
        }
    }

    return S_OK;
}

// When Loading or Saving from the View State Stream

HRESULT CViewState::LoadFromStream(CDefView* pdv, IStream* pstm)
{
    ULONG cbRead;
    DVSAVEHEADER_COMBO dv;
    ULARGE_INTEGER libStartPos;
    LARGE_INTEGER dlibMove  = {0};

    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libStartPos);

    // See what format the persisted view is in:
    HRESULT hr = pstm->Read(&dv, sizeof(dv), &cbRead);

    if (SUCCEEDED(hr) &&
        sizeof(DVSAVEHEADER_COMBO) == cbRead &&
        dv.dvSaveHeader.cbSize == sizeof(WIN95HEADER) &&
        dv.dvSaveHeader.cbColOffset == 0 &&
        dv.dvSaveHeaderEx.dwSignature == IE4HEADER_SIGNATURE &&
        dv.dvSaveHeaderEx.cbSize >= sizeof(IE4HEADER))
    {
        InitFromHeader(&dv);

        if (dv.dvSaveHeaderEx.wVersion < IE4HEADER_VERSION)
        {
            // We used to store szExtended in here -- not any more
            dv.dvSaveHeaderEx.dwUnused = 0;
        }

        if (dv.dvSaveHeaderEx.cbColOffset >= sizeof(dv))
        {
            dlibMove.QuadPart = libStartPos.QuadPart + dv.dvSaveHeaderEx.cbColOffset;
            hr = pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hr))
            {
                hr = LoadColumns(pdv, pstm);
            }
        }

        if (SUCCEEDED(hr))
        {
            dlibMove.QuadPart = libStartPos.QuadPart + dv.dvSaveHeader.cbPosOffset;
            hr = pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

            if (SUCCEEDED(hr))
            {
                LoadPositionBlob(pdv, dv.dvSaveHeaderEx.cbStreamSize, pstm);
            }
        }
    }

    return S_OK;
}

void SetSize(ULARGE_INTEGER libCurPosition, IStream* pstm)
{
    LARGE_INTEGER dlibMove;
    
    dlibMove.QuadPart = libCurPosition.QuadPart;
    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    pstm->SetSize(libCurPosition);
}

DWORD CViewState::_GetStreamSize(IStream* pstm)
{
    DWORD dwRet = 0;

    ULARGE_INTEGER uli;
    if (SUCCEEDED(IStream_Size(pstm, &uli)))
    {
        if (0 == uli.HighPart)
        {
            dwRet = uli.LowPart;
        }
    }

    return dwRet;
}

HRESULT CViewState::SaveToStream(CDefView* pdv, IStream* pstm)
{
    ULONG ulWrite;
    DVSAVEHEADER_COMBO dv = {0};
    LARGE_INTEGER dlibMove = {0};
    ULARGE_INTEGER libCurPosition;

    // Get the current info.
    Sync(pdv, FALSE);

    // Position the stream right after the headers, and save the starting
    // position at the same time
    dlibMove.QuadPart = sizeof(dv);
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPosition);

    // Avoid 2 calls to seek by just subtracting
    libCurPosition.QuadPart -= sizeof(dv);

    // Save column order and size info
    HRESULT hr = SaveColumns(pdv, pstm);
    if (SUCCEEDED(hr))
    {
        dv.dvSaveHeader.cbSize = sizeof(dv.dvSaveHeader);

        // We save the view mode to determine if the scroll positions are
        // still valid on restore
        dv.dvSaveHeader.ViewMode = _ViewMode;
        dv.dvSaveHeader.ptScroll.x = _ptScroll.x;
        dv.dvSaveHeader.ptScroll.y = _ptScroll.y;
        dv.dvSaveHeader.dvState.lParamSort = (LONG)_lParamSort;
        dv.dvSaveHeader.dvState.iDirection = _iDirection;
        dv.dvSaveHeader.dvState.iLastColumnClick = _iLastColumnClick;

        // dvSaveHeaderEx.cbColOffset holds the true offset.
        // Win95 gets confused when cbColOffset points to the new
        // format. Zeroing this out tells Win95 to use default widths
        // (after uninstall of ie40).
        //
        // dv.dvSaveHeader.cbColOffset = 0;

        dv.dvSaveHeaderEx.dwSignature = IE4HEADER_SIGNATURE;
        dv.dvSaveHeaderEx.cbSize = sizeof(dv.dvSaveHeaderEx);
        dv.dvSaveHeaderEx.wVersion = IE4HEADER_VERSION;

        ULARGE_INTEGER libPosPosition;

        // Save the Position Information
        dlibMove.QuadPart = 0;
        pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libPosPosition);
        dv.dvSaveHeaderEx.cbColOffset = sizeof(dv);
        dv.dvSaveHeader.cbPosOffset = (USHORT)(libPosPosition.QuadPart - libCurPosition.QuadPart);

        // Save potision info, currently stream is positioned immediately after column info
        hr = SavePositionBlob(pdv, pstm);
        if (SUCCEEDED(hr))
        {
            ULARGE_INTEGER libEndPosition;
            // Win95 expects cbPosOffset to be at the end of the stream --
            // don't change it's value and never store anything after
            // the position information.

            // Calculate size of total information saved.
            // This is needed when we read the stream.
            dlibMove.QuadPart = 0;
            if (SUCCEEDED(pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libEndPosition)))
            {
                dv.dvSaveHeaderEx.cbStreamSize = (DWORD)(libEndPosition.QuadPart - libCurPosition.QuadPart);
            }

            // Now save the header information
            dlibMove.QuadPart = libCurPosition.QuadPart;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
            hr = pstm->Write(&dv, sizeof(dv), &ulWrite);

            if (FAILED(hr) || ulWrite != sizeof(dv))
            {
                SetSize(libCurPosition, pstm);
                hr = S_OK;
            }

            // Make sure we save all information written so far
            libCurPosition.QuadPart += dv.dvSaveHeaderEx.cbStreamSize;
        }
    }

    return hr;
}

HRESULT CViewState::SaveToPropertyBag(CDefView* pdv, IPropertyBag* ppb)
{
    // Get the current info.
    Sync(pdv, FALSE);

    SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_MODE, _ViewMode);
    SHPropertyBag_WritePOINTSScreenRes(ppb, VS_PROPSTR_SCROLL, &_ptScroll);
    SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_SORT, static_cast<DWORD>(_lParamSort)); 
    SHPropertyBag_WriteInt(ppb, VS_PROPSTR_SORTDIR, _iDirection); 
    SHPropertyBag_WriteInt(ppb, VS_PROPSTR_COL, _iLastColumnClick);
    
    IStream* pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        if (S_OK == SaveColumns(pdv, pstm))
        {
            SHPropertyBag_WriteStream(ppb, VS_PROPSTR_COLINFO, pstm);
        }
        else
        {
            SHPropertyBag_Delete(ppb, VS_PROPSTR_COLINFO);
        }
        pstm->Release();
    }

    pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        if (S_OK == SavePositionBlob(pdv, pstm))
        {
            SHPropertyBag_WriteStreamScreenRes(ppb, VS_PROPSTR_ITEMPOS, pstm);
        }
        else
        {
            SHPropertyBag_DeleteScreenRes(ppb, VS_PROPSTR_ITEMPOS);
        }
        pstm->Release();
    }

    return S_OK;
}

HRESULT CViewState::LoadFromPropertyBag(CDefView* pdv, IPropertyBag* ppb)
{
    SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_MODE, &_ViewMode, FVM_ICON);
    SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_SORT, reinterpret_cast<DWORD*>(&_lParamSort), 0);
    SHPropertyBag_ReadIntDef(ppb, VS_PROPSTR_SORTDIR, &_iDirection, 1); 
    SHPropertyBag_ReadIntDef(ppb, VS_PROPSTR_COL, &_iLastColumnClick, -1); 

    if (FAILED(SHPropertyBag_ReadPOINTSScreenRes(ppb, VS_PROPSTR_SCROLL, &_ptScroll)))
    {
        _ptScroll.x = _ptScroll.y = 0;
    }

    IStream* pstm;
    if (SUCCEEDED(SHPropertyBag_ReadStream(ppb, VS_PROPSTR_COLINFO, &pstm)))
    {
        LoadColumns(pdv, pstm);
        pstm->Release();
    }

    if (SUCCEEDED(SHPropertyBag_ReadStreamScreenRes(ppb, VS_PROPSTR_ITEMPOS, &pstm)))
    {
        LoadPositionBlob(pdv, _GetStreamSize(pstm), pstm);
        pstm->Release();
    }

    return S_OK;
}

HDSA DSA_CreateFromStream(DWORD cbSize, int cItems, IStream* pstm)
{
    HDSA hdsa = DSA_Create(cbSize, cItems);
    if (hdsa)
    {
        BYTE* pb = (BYTE*)LocalAlloc(LPTR, cbSize);
        if (pb)
        {
            BOOL fFailedToRead = FALSE;
            ULONG cbRead;
            while (cItems--)
            {
                if (SUCCEEDED(pstm->Read(pb, cbSize, &cbRead) && cbRead == cbSize))
                {
                    DSA_AppendItem(hdsa, pb);
                }
                else
                {
                    fFailedToRead = TRUE;
                }
            }
            LocalFree(pb);

            if (fFailedToRead)
            {
                // The stream is probrably corrupt.
                DSA_Destroy(hdsa);
                hdsa = NULL;
            }
        }
    }

    return hdsa;
}

// When Loading from a View Callback provided stream.
HRESULT CViewState::LoadColumns(CDefView* pdv, IStream* pstm)
{
    // Read the extended View state header
    HRESULT hr;
    ULONG cbRead;
    VIEWSTATEHEADER vsh;
    ULARGE_INTEGER libStartPos;
    LARGE_INTEGER dlibMove  = {0};

    // Store off the current stream pointer. If we are called directly, this is probrably Zero,
    // However this method gets called from ::Load, so this it definitly not zero in that case.
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libStartPos);

    // The VSH struct has many "Substructs" indicating the version of ths struct we are reading.
    // There is probrably a more efficient mechanism of version discovery, but this is easiest to read and understand.
    hr = pstm->Read(&vsh.Version1, sizeof(vsh.Version1), &cbRead);
    
    if (SUCCEEDED(hr) &&
        sizeof(vsh.Version1) == cbRead &&                       // Fail if we didn't read enough
        VIEWSTATEHEADER_SIGNATURE == vsh.Version1.dwSignature)  // Fail if the signature is bogus
    {
        if (vsh.Version1.uVersion >= VIEWSTATEHEADER_VERSION_1)
        {
            if (vsh.Version1.uCols > 0)
            {
                // Load the Column Ordering
                dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version1.uOffsetColOrder;
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                if (_hdsaColumnOrder)   
                    DSA_Destroy(_hdsaColumnOrder);
                _hdsaColumnOrder = DSA_CreateFromStream(sizeof(int), vsh.Version1.uCols, pstm);
                // Load the Column Widths
                dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version1.uOffsetWidths;
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                if (_hdsaColumnWidths) 
                    DSA_Destroy(_hdsaColumnWidths);
                _hdsaColumnWidths = DSA_CreateFromStream(sizeof(USHORT), vsh.Version1.uCols, pstm);
            }


            if (vsh.Version1.uVersion >= VIEWSTATEHEADER_VERSION_2 &&
                vsh.Version1.uCols > 0)
            {
                DWORD dwRead;

                // Seek to read the rest of the header
                dlibMove.QuadPart = libStartPos.QuadPart + sizeof(vsh.Version1);
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                hr = pstm->Read(&vsh.Version2, sizeof(vsh.Version2), &cbRead);
                
                if (SUCCEEDED(hr) &&
                    sizeof(vsh.Version2) == cbRead &&
                    vsh.Version2.uOffsetColStates)
                {
                    // Load the Column States
                    dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version2.uOffsetColStates;
                    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                    // This one is funky: There is a terminating sentinal....
                    if (_hdsaColumnStates) 
                        DSA_Destroy(_hdsaColumnStates);

                    _hdsaColumnStates = DSA_Create(sizeof(DWORD), 5);
                    if (_hdsaColumnStates)
                    {
                        do
                        {
                            if (SUCCEEDED(pstm->Read(&dwRead, sizeof(DWORD), &cbRead)) && 
                                cbRead == sizeof(DWORD) &&
                                dwRead != 0xFFFFFFFF)
                            {
                                DSA_AppendItem(_hdsaColumnStates, &dwRead);
                            }
                            else
                            {
                                break;
                            }
                        }
                        while (dwRead != 0xFFFFFFFF);
                    }
                }
            }

            if (vsh.Version1.uVersion >= VIEWSTATEHEADER_VERSION_3)
            {
                // Seek to read the rest of the header
                dlibMove.QuadPart = libStartPos.QuadPart + sizeof(vsh.Version1) + sizeof(vsh.Version2);
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                hr = pstm->Read(&vsh.Version3, sizeof(vsh.Version3), &cbRead);
                if (SUCCEEDED(hr) &&
                    sizeof(vsh.Version3) == cbRead &&
                    vsh.Version3.uOffsetGroup)
                {
                    GROUP_PERSIST gp;
                    dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version3.uOffsetGroup;
                    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                    hr = pstm->Read(&gp, sizeof(gp), &cbRead);
                    if (SUCCEEDED(hr) &&
                        sizeof(gp) == cbRead)
                    {
                        _guidGroupID = gp.guidGroupID;
                        _scidDetails = gp.scidDetails;
                    }
                }
                
                _fFirstViewed = FALSE;
            }

            /////////////////////////////////////////////////////////////////////////////////////
            //                    *****             NEW Data             *****
            // 1) Add a version to the VIEWSTATEHEADER
            // 2) Add a version to VIEWSTATEHEADER_VERSION_*
            // 3) Check that version here
            /////////////////////////////////////////////////////////////////////////////////////
        }
    }

    return hr;
}

HRESULT CViewState::SaveColumns(CDefView* pdv, IStream* pstm)
{
    HRESULT hr;
    USHORT uOffset;
    VIEWSTATEHEADER vsh = {0};
    ULARGE_INTEGER libStartPos = {0};
    LARGE_INTEGER dlibMove  = {0};

    // No point in persisting, if there aren't any columns around.
    // this is true for folders that are just opened and closed
    if (!pdv->_psd && !pdv->_pshf2 && !pdv->HasCB())
    {
        return S_FALSE;
    }

    // First, we persist a known bad quantity, just in case we wax the stream
    pstm->Seek(g_li0, STREAM_SEEK_CUR, &libStartPos);
    hr = pstm->Write(&vsh, sizeof(vsh), NULL);

    if (SUCCEEDED(hr))
    {
        vsh.Version1.dwSignature = VIEWSTATEHEADER_SIGNATURE;
        vsh.Version1.uVersion = VIEWSTATEHEADER_VERSION_CURRENT;
        vsh.Version1.uCols = _hdsaColumnOrder? (UINT) DSA_GetItemCount(_hdsaColumnOrder) : 0;

        uOffset = sizeof(VIEWSTATEHEADER);

        // No point in persisting if we don't have any columns
        if (vsh.Version1.uCols)
        {

            // Note- dependent on DSA storing data internally as byte-packed.
            if (_hdsaColumnOrder)
            {
                vsh.Version1.uOffsetColOrder = uOffset;
                uOffset += (USHORT)(sizeof(UINT) * DSA_GetItemCount(_hdsaColumnOrder));
                hr = pstm->Write(DSA_GetItemPtr(_hdsaColumnOrder, 0),  sizeof(UINT)   * DSA_GetItemCount(_hdsaColumnOrder), NULL);
            }

            if (_hdsaColumnWidths && SUCCEEDED(hr))
            {
                vsh.Version1.uOffsetWidths = uOffset;
                uOffset += (USHORT)(sizeof(USHORT) * DSA_GetItemCount(_hdsaColumnWidths));
                hr = pstm->Write(DSA_GetItemPtr(_hdsaColumnWidths, 0), sizeof(USHORT) * DSA_GetItemCount(_hdsaColumnWidths), NULL);
            }

            if (_hdsaColumnStates && SUCCEEDED(hr))
            {
                vsh.Version2.uOffsetColStates = uOffset; 
                uOffset += (USHORT)(sizeof(DWORD) *  DSA_GetItemCount(_hdsaColumnStates));
                pstm->Write(DSA_GetItemPtr(_hdsaColumnStates, 0), sizeof(DWORD)  * DSA_GetItemCount(_hdsaColumnStates), NULL);
            }
        }

        if (SUCCEEDED(hr))
        {
            GROUP_PERSIST gp = {0};
            vsh.Version3.uOffsetGroup = uOffset;
            uOffset += sizeof(GROUP_PERSIST);

            if (pdv->_fGroupView)
            {
                gp.guidGroupID = _guidGroupID;
                gp.scidDetails = _scidDetails;
            }

            hr = pstm->Write(&gp, sizeof(gp), NULL);
        }
    
        /////////////////////////////////////////////////////////////////////////////////////
        //                    *****             NEW Data             *****
        // 1) Add a version to the VIEWSTATEHEADER
        // 2) Add a version to VIEWSTATEHEADER_VERSION_*
        // 3) Add a "Loader" for your value
        // 4) Set the offset to uOffset.
        // 5) Write your data.
        // 6) Update the running total of dwOffset.
        /////////////////////////////////////////////////////////////////////////////////////

        dlibMove.QuadPart = libStartPos.QuadPart;

        // Store off the current position
        pstm->Seek(g_li0, STREAM_SEEK_CUR, &libStartPos);

        // Move to the beginning
        pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

        // Write out the correct header
        hr = pstm->Write(&vsh, sizeof(vsh), NULL);
        if (SUCCEEDED(hr))
        {
            // Reset the current pos
            dlibMove.QuadPart = libStartPos.QuadPart;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL); 
        }
    }

    return hr;
}

BOOL CViewState::AppendColumn(UINT uCol, USHORT uWidth, INT uOrder)
{
    if (_hdsaColumnOrder == NULL || 
        _hdsaColumnWidths == NULL)
    {
        return FALSE;
    }

    // Slide every index above this one up
    for (INT u = 0; u < DSA_GetItemCount(_hdsaColumnOrder); u++)
    {
        UINT *p = (UINT *) DSA_GetItemPtr(_hdsaColumnOrder, u);
        if (!p)
            break; // safety...
        if (*p >= uCol)
            (*p)++;
    }

    DSA_AppendItem(_hdsaColumnWidths, &uWidth);
    DSA_AppendItem(_hdsaColumnOrder, &uOrder);
    // maybe we should store column ordering as absolute numbers
    return TRUE;
}

BOOL CViewState::RemoveColumn(UINT uCol)
{
    if (_hdsaColumnWidths == NULL || 
        _hdsaColumnWidths == NULL)
    {
        return FALSE;
    }

    if ((int)uCol >= DSA_GetItemCount(_hdsaColumnWidths))
        return FALSE;
    // Slide every index above this one down
    for (INT u = 0; u < DSA_GetItemCount(_hdsaColumnOrder); u++)
    {
        UINT *p = (UINT *) DSA_GetItemPtr(_hdsaColumnOrder, u);
        if (!p)
            break; // safety...
        if (*p > uCol)
            (*p)--;
    }

    DSA_DeleteItem(_hdsaColumnWidths, uCol);
    DSA_DeleteItem(_hdsaColumnOrder, uCol);
    return TRUE;
}

UINT CViewState::GetColumnWidth(UINT uCol, UINT uDefWid)
{
    if (!_hdsaColumnWidths)
        return uDefWid;

    USHORT uWidth = 0;
    if (uCol < (UINT) DSA_GetItemCount(_hdsaColumnWidths))
    {
        DSA_GetItem(_hdsaColumnWidths, uCol, &uWidth);
    }
    return uWidth ? uWidth : uDefWid;        // disallow zero width columns
}

BOOL CViewState::SyncColumnOrder(CDefView* pdv, BOOL fSetListViewState)
{
    UINT cCols = pdv->_GetHeaderCount();
    if (fSetListViewState)
    {
        if (!_hdsaColumnOrder)
            return FALSE;

        if (cCols != (UINT) DSA_GetItemCount(_hdsaColumnOrder))
        {
            // this is a normal case if a folder is opened and there is no saved state. no need to spew.
            return TRUE;
        }

        UINT *pCols = (UINT *)LocalAlloc(LPTR, cCols * sizeof(*pCols));
        if (pCols)
        {
            for (UINT u = 0; u < cCols; u++)
            {
                DSA_GetItem(_hdsaColumnOrder, u, pCols + u);
            }

            ListView_SetColumnOrderArray(pdv->_hwndListview, cCols, pCols);
            LocalFree(pCols);
        }
    }
    else
    {
        BOOL bDefaultOrder = TRUE;
        if (cCols)
        {
            if (!_hdsaColumnOrder)
                _hdsaColumnOrder = DSA_Create(sizeof(UINT), 6);

            if (_hdsaColumnOrder)
            {
                UINT *pCols = (UINT *)LocalAlloc(LPTR, cCols * sizeof(*pCols));
                if (pCols)
                {
                    ListView_GetColumnOrderArray(pdv->_hwndListview, cCols, pCols);

                    DSA_DeleteAllItems(_hdsaColumnOrder);
                    for (UINT u = 0; u < cCols; u++)
                    {
                        DSA_AppendItem(_hdsaColumnOrder, &pCols[u]);
                        if (pCols[u] != u)
                        {
                            bDefaultOrder = FALSE;
                        }
                    }

                    LocalFree(pCols);
                }
            }
        }
        return bDefaultOrder;
    }

    return TRUE;
}

BOOL CViewState::SyncColumnWidths(CDefView* pdv, BOOL fSetListViewState)
{
    UINT cCols = pdv->_GetHeaderCount();
    if (fSetListViewState)
    {
        return FALSE;
    }
    else
    {
        USHORT us;
        LV_COLUMN lvc;
        BOOL bOk = TRUE;
    
        if (!cCols)
            return TRUE;

        HDSA dsaNewWidths = DSA_Create(sizeof(USHORT), cCols);
        if (!dsaNewWidths)
            return TRUE;

        for (UINT u = 0; u < cCols && bOk; ++u)
        {
            lvc.mask = LVCF_WIDTH;
            bOk = ListView_GetColumn(pdv->_hwndListview, u, &lvc);
            us = (USHORT) lvc.cx;    // make sure its a short
            DSA_AppendItem(dsaNewWidths, &us);
            // TraceMsg(TF_DEFVIEW, "  saving col %d width of %d", u, us);
        }

        if (bOk)
        {
            if (_hdsaColumnWidths)
                DSA_Destroy(_hdsaColumnWidths);
            _hdsaColumnWidths = dsaNewWidths;
        }
        else
            DSA_Destroy(dsaNewWidths);
        return !bOk;
    }
}

BOOL CViewState::SyncColumnStates(CDefView* pdv, BOOL fSetListViewstate)
{
    if (fSetListViewstate)
    {
        return FALSE;
    }
    else
    {
        // Save off Column States
        if (_hdsaColumnStates)
        {
            DSA_Destroy(_hdsaColumnStates);
            _hdsaColumnStates = NULL;
        }

        UINT cCol = GetColumnCount();

        if (cCol)
        {
            DWORD i;
            _hdsaColumnStates = DSA_Create(sizeof(DWORD), 5);
            if (_hdsaColumnStates)
            {
                for (i = 0; i < cCol; i++)
                {
                    if (pdv->_IsDetailsColumn(i))
                        DSA_AppendItem(_hdsaColumnStates, &i);
                }
                i = 0xFFFFFFFF;     // Terminating Sentinal
                DSA_AppendItem(_hdsaColumnStates,&i);
            }
        }
    }

    return TRUE;
}

// Syncronizes ListView with the current View State. 
// TRUE means take the view state object and set it into the listview.
HRESULT CViewState::Sync(CDefView* pdv, BOOL fSetListViewState)
{
    SyncColumnWidths(pdv, fSetListViewState);
    SyncColumnOrder(pdv, fSetListViewState);
    SyncColumnStates(pdv, fSetListViewState);

    if (fSetListViewState)
    {
        // Only do this the first time.
        if (pdv->_pcat == NULL)
        {
            if (_fFirstViewed)
            {
                // See if the desktop.ini specifies one
                pdv->_LoadCategory(&_guidGroupID);

                if (IsEqualGUID(_guidGroupID, GUID_NULL))
                {
                    ICategoryProvider* pcp;
                    if (SUCCEEDED(pdv->_pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp))))
                    {
                        pcp->GetDefaultCategory(&_guidGroupID, &_scidDetails);
                        pcp->Release();
                    }
                }
            }

            if (!IsEqualGUID(_guidGroupID, GUID_NULL) || !IsEqualGUID(_scidDetails.fmtid, GUID_NULL))
                pdv->_CategorizeOnGUID(&_guidGroupID, &_scidDetails);
        }

        // this is only needed to sort the items who's positions are not known
        // it would be nice to optimize this case and only sort then
        pdv->_Sort();

        SyncPositions(pdv);
    }
    else
    {
        // Take what Listview has, and save it to me.

        _ViewMode = pdv->_fs.ViewMode;
        _ptScroll.x = (SHORT) GetScrollPos(pdv->_hwndListview, SB_HORZ);
        _ptScroll.y = (SHORT) GetScrollPos(pdv->_hwndListview, SB_VERT);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\util.cpp ===
#include "shellprv.h"
#include "guids.h"      // for PRINTER_BIND_INFO
#include "printer.h"    // for IPrintersBindInfo
#include "util.h"

#include <advpub.h>     // For REGINSTALL
#include <ntverp.h>
#include <urlmon.h>
#include <shlwapi.h>
#include "shldisp.h"
#include <malloc.h>
#include "shitemid.h"
#include "datautil.h"
#include <perhist.h>    // IPersistHistory is defined here.

#include "ids.h"
#include "views.h"
#include "ole2dup.h"
#include <regstr.h>
#include "unicpp\dutil.h"
#include <stdlib.h>

#include "prop.h"
#include "ftascstr.h"   // for CFTAssocStore
#include "ftcmmn.h"     // for MAX_APPFRIENDLYNAME
#include "ascstr.h"     // for IAssocInfo class
#include "fstreex.h"    // for CFSFolder_CreateFolder
#include "deskfldr.h"
#include "cscuiext.h"
#include "netview.h"    // SHGetNetJoinInformation
#include "mtpt.h"
#include <cscapi.h>     // for CSCQueryFileStatus
#include <winsta.h>
#include <dsgetdc.h>
#include <uxtheme.h>

#include <duithread.h>

//The following is defined in shell32\unicpp\dutil.cpp
void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme);

#define DM_STRICT       TF_WARNING  // audit menus, etc.
#define DM_STRICT2      0           // verbose

//
// We need to put this one in per-instance data section because during log-off
// and log-on, this info needs to be re-read from the registry.
//
// REGSHELLSTATE is the version of the SHELLSTATE that goes into the
// registry.  When loading a REGSHELLSTATE, you have to study the
// cbSize to see if it's a downlevel structure and upgrade it accordingly.
//

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE;

#define REGSHELLSTATE_SIZE_WIN95 (sizeof(UINT)+SHELLSTATE_SIZE_WIN95)  // Win95 Gold
#define REGSHELLSTATE_SIZE_NT4   (sizeof(UINT)+SHELLSTATE_SIZE_NT4)    // Win95 OSR / NT 4
#define REGSHELLSTATE_SIZE_IE4   (sizeof(UINT)+SHELLSTATE_SIZE_IE4)    // IE 4, 4.01
#define REGSHELLSTATE_SIZE_WIN2K (sizeof(UINT)+SHELLSTATE_SIZE_WIN2K)  // ie5, win2k, millennium, whistler

// If the SHELLSTATE size changes, we need to add a new define
// above and new upgrade code in SHRefreshSettings
#ifdef DEBUG
void snafu () {COMPILETIME_ASSERT(REGSHELLSTATE_SIZE_WIN2K == sizeof(REGSHELLSTATE));}
#endif DEBUG

REGSHELLSTATE * g_pShellState = 0;

// detect an "empty" sound scheme key. this deals with the NULL case that returns
// "2" as that is enough space for a NULL char

BOOL NonEmptySoundKey(HKEY, LPCTSTR pszKey)
{
    TCHAR sz[MAX_PATH];
    DWORD cb = sizeof(sz); // in/out
    return ERROR_SUCCESS == SHRegGetValue(HKEY_CURRENT_USER, pszKey, NULL, SRRF_RT_REG_SZ, NULL, sz, &cb) && sz[0] != TCHAR('\0');
}

STDAPI_(void) SHPlaySound(LPCTSTR pszSound)
{
    TCHAR szKey[CCH_KEYMAX];

    // to avoid loading all of the MM system DLLs we check the registry first
    // if there's nothing registered, we blow off the play,

    HRESULT hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("AppEvents\\Schemes\\Apps\\Explorer\\%s\\.current"), pszSound);
    if (SUCCEEDED(hr) && NonEmptySoundKey(HKEY_CURRENT_USER, szKey))
    {
        PlaySound(pszSound, NULL, SND_ALIAS | SND_APPLICATION | SND_ASYNC | SND_NODEFAULT | SND_NOSTOP);
    }
    else
    {
        // support system sounds too
        hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current"), pszSound);
        if (SUCCEEDED(hr) && NonEmptySoundKey(HKEY_CURRENT_USER, szKey))
        {
            PlaySound(pszSound, NULL, SND_ALIAS | SND_APPLICATION | SND_ASYNC | SND_NODEFAULT | SND_NOSTOP);
        }
    }
}


// helper function to set whether shift or control is down at the start of the invoke
// operation, so others down the line can check this instead of calling GetAsyncKeyState themselves
STDAPI_(void) SetICIKeyModifiers(DWORD* pfMask)
{
    ASSERT(pfMask);

    if (GetKeyState(VK_SHIFT) < 0)
    {
        *pfMask |= CMIC_MASK_SHIFT_DOWN;
    }

    if (GetKeyState(VK_CONTROL) < 0)
    {
        *pfMask |= CMIC_MASK_CONTROL_DOWN;
    }
}


// sane way to get the msg pos into a point, mostly needed for win32
void GetMsgPos(POINT *ppt)
{
    DWORD dw = GetMessagePos();

    ppt->x = GET_X_LPARAM(dw);
    ppt->y = GET_Y_LPARAM(dw);
}

/*  This gets the number of consecutive chrs of the same kind.  This is used
 *  to parse the time picture.  Returns 0 on error.
 */

int GetPict(WCHAR ch, LPWSTR wszStr)
{
    int count = 0;
    while (ch == *wszStr++)
        count++;

    return count;
}

DWORD CALLBACK _PropSheetThreadProc(void *ppv)
{
    PROPSTUFF * pps = (PROPSTUFF *)ppv;

    // CoInitializeEx(0, COINIT_MULTITHREADED); // to test stuff in multithread case

    HRESULT hrInit = SHOleInitialize(0);

    DWORD dwRet = pps->lpStartAddress(pps);

    // cleanup
    if (pps->pdtobj)
        pps->pdtobj->Release();

    if (pps->pidlParent)
        ILFree(pps->pidlParent);

    if (pps->psf)
        pps->psf->Release();

    LocalFree(pps);

    SHOleUninitialize(hrInit);

    return dwRet;
}

// reinerf: alpha cpp compiler confused by the type "LPITEMIDLIST", so to work
// around this we pass the last param as an void *instead of a LPITEMIDLIST
//
HRESULT SHLaunchPropSheet(LPTHREAD_START_ROUTINE pStartAddress, IDataObject *pdtobj, LPCTSTR pStartPage, IShellFolder *psf, void *pidl)
{
    LPITEMIDLIST pidlParent = (LPITEMIDLIST)pidl;
    UINT cchStartPage = !IS_INTRESOURCE(pStartPage) ? (lstrlen(pStartPage) + 1) : 0;
    UINT cbStartPage = cchStartPage * sizeof(*pStartPage);
    PROPSTUFF * pps = (PROPSTUFF *)LocalAlloc(LPTR, sizeof(PROPSTUFF) + cbStartPage);
    if (pps)
    {
        pps->lpStartAddress = pStartAddress;

        if (pdtobj)
        {
            pps->pdtobj = pdtobj;
            pdtobj->AddRef();
        }

        if (pidlParent)
            pps->pidlParent = ILClone(pidlParent);

        if (psf)
        {
            pps->psf = psf;
            psf->AddRef();
        }

        pps->pStartPage = pStartPage;
        if (!IS_INTRESOURCE(pStartPage))
        {
            pps->pStartPage = (LPTSTR)(pps + 1);
            StringCchCopy((LPTSTR)(pps->pStartPage), cchStartPage, pStartPage);
        }

        // _PropSheetThreadProc does not do any modality stuff, so we can't CTF_INSIST
        if (SHCreateThread(_PropSheetThreadProc, pps, CTF_PROCESS_REF, NULL))
            return S_OK;
    }
    return E_OUTOFMEMORY;
}

/*  This picks up the values in wValArray, converts them
 *  in a string containing the formatted date.
 *  wValArray should contain Month-Day-Year (in that order).
 */

int CreateDate(WORD *wValArray, LPWSTR wszOutStr)
{
    int     cchPictPart;
    WORD    wDigit;
    WORD    wIndex;
    WORD    wTempVal;
    LPWSTR  pwszPict, pwszInStr;
    WCHAR   wszShortDate[30];      // need more room for LOCALE_SSHORTDATE
    
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, wszShortDate, ARRAYSIZE(wszShortDate));
    pwszPict = wszShortDate;
    pwszInStr = wszOutStr;
    
    for (int i = 0; (i < 5) && (*pwszPict); i++)
    {
        cchPictPart = GetPict(*pwszPict, pwszPict);
        switch (*pwszPict)
        {
        case TEXT('M'):
        case TEXT('m'):
            {
                wIndex = 0;
                break;
            }
            
        case TEXT('D'):
        case TEXT('d'):
            {
                //
                // if short date style && *pszPict is 'd' &&
                // cchPictPart is more than equal 3,
                // then it is the day of the week.
                //
                if (cchPictPart >= 3)
                {
                    pwszPict += cchPictPart;
                    continue;
                }
                wIndex = 1;
                break;
            }
            
        case TEXT('Y'):
        case TEXT('y'):
            {
                wIndex = 2;
                if (cchPictPart == 4)
                {
                    if (wValArray[2] >=100)
                    {
                        *pwszInStr++ = TEXT('2');
                        *pwszInStr++ = TEXT('0');
                        wValArray[2]-= 100;
                    }
                    else
                    {
                        *pwszInStr++ = TEXT('1');
                        *pwszInStr++ = TEXT('9');
                    }
                }
                else if (wValArray[2] >=100)  // handle year 2000
                    wValArray[2]-= 100;
                
                break;
            }
            
        case TEXT('g'):
            {
                // era string
                pwszPict += cchPictPart;
                while (*pwszPict == TEXT(' ')) pwszPict++;
                continue;
            }
            
        case TEXT('\''):
            {
                while (*pwszPict && *++pwszPict != TEXT('\'')) ;
                continue;
            }
            
        default:
            {
                goto CDFillIn;
                break;
            }
        }
        
        /* This assumes that the values are of two digits only. */
        wTempVal = wValArray[wIndex];
        
        wDigit = wTempVal / 10;
        if (wDigit)
            *pwszInStr++ = (TCHAR)(wDigit + TEXT('0'));
        else if (cchPictPart > 1)
            *pwszInStr++ = TEXT('0');
        
        *pwszInStr++ = (TCHAR)((wTempVal % 10) + TEXT('0'));
        
        pwszPict += cchPictPart;
        
CDFillIn:
        /* Add the separator. */
        while ((*pwszPict) &&
            (*pwszPict != TEXT('\'')) &&
            (*pwszPict != TEXT('M')) && (*pwszPict != TEXT('m')) &&
            (*pwszPict != TEXT('D')) && (*pwszPict != TEXT('d')) &&
            (*pwszPict != TEXT('Y')) && (*pwszPict != TEXT('y')))
        {
            *pwszInStr++ = *pwszPict++;
        }
    }
    
    *pwszInStr = 0;
    
    return lstrlenW(wszOutStr);
}


#define DATEMASK        0x001F
#define MONTHMASK       0x01E0
#define MINUTEMASK      0x07E0
#define SECONDSMASK     0x001F

STDAPI_(int) GetDateString(WORD wDate, LPWSTR wszStr)
{
    WORD  wValArray[3];
    
    wValArray[0] = (wDate & MONTHMASK) >> 5;              /* Month */
    wValArray[1] = (wDate & DATEMASK);                    /* Date  */
    wValArray[2] = (wDate >> 9) + 80;                     /* Year  */
    
    return CreateDate(wValArray, wszStr);
}

//
// We need to loop through the string and extract off the month/day/year
// We will do it in the order of the NlS definition...
//
STDAPI_(WORD) ParseDateString(LPCWSTR pszStr)
{
    WORD    wParts[3];
    int     cchPictPart;
    WORD    wIndex;
    WORD    wTempVal;
    WCHAR   szShortDate[30];    // need more room for LOCALE_SSHORTDATE
    
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, szShortDate, ARRAYSIZE(szShortDate));
    LPWSTR pszPict = szShortDate;
    
    while (*pszPict && (*pszPict == *pszStr))
    {
        pszPict++;
        pszStr++;
    }
    
    for (int i = 0; (i < 5) && (*pszPict); i++)
    {
        cchPictPart = GetPict(*pszPict, pszPict);
        switch (*pszPict)
        {
        case TEXT('M'):
        case TEXT('m'):
            wIndex = 0;
            break;
            
        case TEXT('D'):
        case TEXT('d'):
            //
            // if short date style && *pszPict is 'd' &&
            // cchPictPart is more than equal 3,
            // then it is the day of the week.
            if (cchPictPart >= 3)
            {
                pszPict += cchPictPart;
                continue;
            }
            wIndex = 1;
            break;
            
        case TEXT('Y'):
        case TEXT('y'):
            wIndex = 2;
            break;
            
        case TEXT('g'):
            {
                // era string
                pszPict += cchPictPart;
                while (*pszPict == TEXT(' ')) pszPict++;
                continue;
            }
            
        case TEXT('\''):
            {
                while (*pszPict && *++pszPict != TEXT('\'')) ;
                continue;
            }
            
        default:
            return 0;
        }
        
        // We now want to loop through each of the characters while
        // they are numbers and build the number;
        //
        wTempVal = 0;
        while ((*pszStr >= TEXT('0')) && (*pszStr <= TEXT('9')))
        {
            wTempVal = wTempVal * 10 + (WORD)(*pszStr - TEXT('0'));
            pszStr++;
        }
        wParts[wIndex] = wTempVal;
        
        // Now make sure we have the correct separator
        pszPict += cchPictPart;
        if (*pszPict != *pszStr)
        {
            return 0;
        }
        while (*pszPict && (*pszPict == *pszStr))
        {
            //
            //  The separator can actually be more than one character
            //  in length.
            //
            pszPict++;  // align to the next field
            pszStr++;   // Align to next field
        }
    }
    
    //
    // Do some simple checks to see if the date looks half way reasonable.
    //
    if (wParts[2] < 80)
        wParts[2] += (2000 - 1900);  // Wrap to next century but leave as two digits...
    if (wParts[2] >= 1900)
        wParts[2] -= 1900;  // Get rid of Century
    if ((wParts[0] == 0) || (wParts[0] > 12) ||
        (wParts[1] == 0) || (wParts[1] > 31) ||
        (wParts[2] >= 200))
    {
        return 0;
    }
    
    // We now have the three parts so lets construct the date value
    
    // Now construct the date number
    return ((wParts[2] - 80) << 9) + (wParts[0] << 5) + wParts[1];
}


STDAPI_(BOOL) IsNullTime(const FILETIME *pft)
{
    FILETIME ftNull = {0, 0};
    return CompareFileTime(&ftNull, pft) == 0;
}


STDAPI_(BOOL) TouchFile(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING | FILE_FLAG_OPEN_NO_RECALL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME st;
        FILETIME ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        bRet = SetFileTime(hFile, &ft, &ft, &ft);
        CloseHandle(hFile);
    }
    return bRet;
}

void Int64ToStr(LONGLONG n, LPTSTR lpBuffer)
{
    TCHAR szTemp[40];
    LONGLONG iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT GetNLSGrouping(void)
{
    TCHAR szGrouping[32];
    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    UINT grouping = 0;
    LPTSTR psz = szGrouping;
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }
    return grouping;
}

// takes a DWORD add commas etc to it and puts the result in the buffer
STDAPI_(LPTSTR) AddCommas64(LONGLONG n, LPTSTR pszResult, UINT cchResult)
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    nfmt.Grouping = GetNLSGrouping();
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, cchResult) == 0)
    {
        StringCchCopy(pszResult, cchResult, szTemp);    // ok to truncate, for display only
    }

    return pszResult;
}

// takes a DWORD add commas etc to it and puts the result in the buffer
STDAPI_(LPTSTR) AddCommas(DWORD n, LPTSTR pszResult, UINT cchResult)
{
    return AddCommas64(n, pszResult, cchResult);
}


STDAPI_(LPTSTR) ShortSizeFormat64(LONGLONG n, LPTSTR szBuf, UINT cchBuf)
{
    return StrFormatByteSize64(n, szBuf, cchBuf);
}

STDAPI_(LPTSTR) ShortSizeFormat(DWORD n, LPTSTR szBuf, UINT cchBuf)
{
    return StrFormatByteSize64(n, szBuf, cchBuf);
}

// exported w/o cch, so assume it'll fit
STDAPI_(LPWSTR) AddCommasExportW(DWORD n, LPWSTR pszResult)
{
    return AddCommas(n, pszResult, 0x8FFF);
}

STDAPI_(LPTSTR) ShortSizeFormatExportW(DWORD n, LPWSTR szBuf)
{
    return StrFormatByteSize64(n, szBuf, 0x8FFF);
}

//
//    Converts the numeric value of a LONGLONG to a text string.
//    The string may optionally be formatted to include decimal places
//    and commas according to current user locale settings.
//
// ARGUMENTS:
//    n
//       The 64-bit integer to format.
//
//    szOutStr
//       Address of the destination buffer.
//
//    nSize
//       Number of characters in the destination buffer.
//
//    bFormat
//       TRUE  = Format per locale settings.
//       FALSE = Leave number unformatted.
//
//    pFmt
//       Address of a number format structure of type NUMBERFMT.
//       If NULL, the function automatically provides this information
//       based on the user's default locale settings.
//
//    dwNumFmtFlags
//       Encoded flag word indicating which members of *pFmt to use in
//       formatting the number.  If a bit is clear, the user's default
//       locale setting is used for the corresponding format value.  These
//       constants can be OR'd together.
//
//          NUMFMT_IDIGITS
//          NUMFMT_ILZERO
//          NUMFMT_SGROUPING
//          NUMFMT_SDECIMAL
//          NUMFMT_STHOUSAND
//          NUMFMT_INEGNUMBER
//
///////////////////////////////////////////////////////////////////////////////
STDAPI_(int) Int64ToString(LONGLONG n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                           NUMBERFMT *pFmt, DWORD dwNumFmtFlags)
{
    INT nResultSize;
    TCHAR szBuffer[_MAX_PATH + 1];
    NUMBERFMT NumFmt;
    TCHAR szDecimalSep[5];
    TCHAR szThousandSep[5];

    ASSERT(NULL != szOutStr);

    //
    // Use only those fields in caller-provided NUMBERFMT structure
    // that correspond to bits set in dwNumFmtFlags.  If a bit is clear,
    // get format value from locale info.
    //
    if (bFormat)
    {
        TCHAR szInfo[20];

        if (NULL == pFmt)
            dwNumFmtFlags = 0;  // Get all format data from locale info.

        if (dwNumFmtFlags & NUMFMT_IDIGITS)
        {
            NumFmt.NumDigits = pFmt->NumDigits;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDIGITS, szInfo, ARRAYSIZE(szInfo));
            NumFmt.NumDigits = StrToLong(szInfo);
        }

        if (dwNumFmtFlags & NUMFMT_ILZERO)
        {
            NumFmt.LeadingZero = pFmt->LeadingZero;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szInfo, ARRAYSIZE(szInfo));
            NumFmt.LeadingZero = StrToLong(szInfo);
        }

        if (dwNumFmtFlags & NUMFMT_SGROUPING)
        {
            NumFmt.Grouping = pFmt->Grouping;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szInfo, ARRAYSIZE(szInfo));
            NumFmt.Grouping = StrToLong(szInfo);
        }

        if (dwNumFmtFlags & NUMFMT_SDECIMAL)
        {
            NumFmt.lpDecimalSep = pFmt->lpDecimalSep;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimalSep, ARRAYSIZE(szDecimalSep));
            NumFmt.lpDecimalSep = szDecimalSep;
        }

        if (dwNumFmtFlags & NUMFMT_STHOUSAND)
        {
            NumFmt.lpThousandSep = pFmt->lpThousandSep;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandSep, ARRAYSIZE(szThousandSep));
            NumFmt.lpThousandSep = szThousandSep;
        }

        if (dwNumFmtFlags & NUMFMT_INEGNUMBER)
        {
            NumFmt.NegativeOrder = pFmt->NegativeOrder;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER, szInfo, ARRAYSIZE(szInfo));
            NumFmt.NegativeOrder  = StrToLong(szInfo);
        }

        pFmt = &NumFmt;
    }

    Int64ToStr(n, szBuffer);

    //  Format the number string for the locale if the caller wants a
    //  formatted number string.
    if (bFormat)
    {
        nResultSize = GetNumberFormat(LOCALE_USER_DEFAULT, 0, szBuffer, pFmt, szOutStr, nSize);
        if (0 != nResultSize)                      // Chars in output buffer.
        {
            //  Remove nul terminator char from return size count.
            --nResultSize;
        }
    }
    else
    {
        //  GetNumberFormat call failed, so just return the number string
        //  unformatted.
        HRESULT hr = StringCchCopy(szOutStr, nSize, szBuffer);
        if (SUCCEEDED(hr))
        {
            nResultSize = lstrlen(szOutStr);
        }
        else
        {
            nResultSize = 0;
        }
    }

    return nResultSize;
}

///////////////////////////////////////////////////////////////////////////////
//
//    Converts the numeric value of a LARGE_INTEGER to a text string.
//    The string may optionally be formatted to include decimal places
//    and commas according to current user locale settings.
//
// ARGUMENTS:
//    pN
//       Address of the large integer to format.
//
//    See description of Int64ToString for remaining arguments.
//
///////////////////////////////////////////////////////////////////////////////
STDAPI_(int) LargeIntegerToString(LARGE_INTEGER *pN, LPTSTR szOutStr, UINT nSize,
                                  BOOL bFormat, NUMBERFMT *pFmt,
                                  DWORD dwNumFmtFlags)
{
    ASSERT(NULL != pN);
    return Int64ToString(pN->QuadPart, szOutStr, nSize, bFormat, pFmt, dwNumFmtFlags);
}



#define ISSEP(c)   ((c) == TEXT('=')  || (c) == TEXT(','))
#define ISWHITE(c) ((c) == TEXT(' ')  || (c) == TEXT('\t') || (c) == TEXT('\n') || (c) == TEXT('\r'))
#define ISNOISE(c) ((c) == TEXT('"'))

#define QUOTE   TEXT('"')
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')
#define EQUAL   TEXT('=')

/*
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. (1 based)
 *             0 is field before a '=' sign
 * szDataStr : pointer to buffer to hold extracted field
 * iBufLen   : size of buffer to receive extracted field.
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 */
STDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen)
{
    BOOL  fQuote = FALSE;
    LPCTSTR pszInf = szData;
    LPTSTR ptr;
    int   iLen = 1;

    if (!szData || !szBuf)
        return FALSE;

        /*
        * find the first separator
    */
    while (*pszInf && !ISSEP(*pszInf))
    {
        if (*pszInf == QUOTE)
            fQuote = !fQuote;
        pszInf = CharNext(pszInf);
    }

    if (n == 0 && *pszInf != TEXT('='))
        return FALSE;

    if (n > 0 && *pszInf == TEXT('=') && !fQuote)
        // Change szData to point to first field
        szData = ++pszInf; // Ok for DBCS

                           /*
                           *   locate the nth comma, that is not inside of quotes
    */
    fQuote = FALSE;
    while (n > 1)
    {
        while (*szData)
        {
            if (!fQuote && ISSEP(*szData))
                break;

            if (*szData == QUOTE)
                fQuote = !fQuote;

            szData = CharNext(szData);
        }

        if (!*szData)
        {
            szBuf[0] = 0;      // make szBuf empty
            return FALSE;
        }

        szData = CharNext(szData); // we could do ++ here since we got here
        // after finding comma or equal
        n--;
    }

    /*
    * now copy the field to szBuf
    */
    while (ISWHITE(*szData))
        szData = CharNext(szData); // we could do ++ here since white space can
    // NOT be a lead byte
    fQuote = FALSE;
    ptr = szBuf;      // fill output buffer with this
    while (*szData)
    {
        if (*szData == QUOTE)
        {
            //
            // If we're in quotes already, maybe this
            // is a double quote as in: "He said ""Hello"" to me"
            //
            if (fQuote && *(szData+1) == QUOTE)    // Yep, double-quoting - QUOTE is non-DBCS
            {
                if (iLen < iBufLen)
                {
                    *ptr++ = QUOTE;
                    ++iLen;
                }
                szData++;                   // now skip past 1st quote
            }
            else
                fQuote = !fQuote;
        }
        else if (!fQuote && ISSEP(*szData))
            break;
        else
        {
            if (iLen < iBufLen)
            {
                *ptr++ = *szData;                  // Thank you, Dave
                ++iLen;
            }

            if (IsDBCSLeadByte(*szData) && (iLen < iBufLen))
            {
                *ptr++ = szData[1];
                ++iLen;
            }
        }
        szData = CharNext(szData);
    }
    /*
    * remove trailing spaces
    */
    while (ptr > szBuf)
    {
        ptr = CharPrev(szBuf, ptr);
        if (!ISWHITE(*ptr))
        {
            ptr = CharNext(ptr);
            break;
        }
    }
    *ptr = 0;
    return TRUE;
}


// Sets and clears the "wait" cursor.
// REVIEW UNDONE - wait a specific period of time before actually bothering
// to change the cursor.
// REVIEW UNDONE - support for SetWaitPercent();
//    BOOL bSet   TRUE if you want to change to the wait cursor, FALSE if
//                you want to change it back.
STDAPI_(void) SetAppStartingCursor(HWND hwnd, BOOL bSet)
{
    if (hwnd && IsWindow(hwnd)) 
    {
        DWORD dwTargetProcID;
        HWND hwndOwner;
        while((NULL != (hwndOwner = GetParent(hwnd))) || (NULL != (hwndOwner = GetWindow(hwnd, GW_OWNER)))) 
        {
            hwnd = hwndOwner;
        }

        // SendNotify is documented to only work in-process (and can
        // crash if we pass the pnmhdr across process boundaries on
        // NT, because DLLs aren't all shared in one address space).
        // So, if this SendNotify would go cross-process, blow it off.

        GetWindowThreadProcessId(hwnd, &dwTargetProcID);

        if (GetCurrentProcessId() == dwTargetProcID)
            SendNotify(hwnd, NULL, bSet ? NM_STARTWAIT : NM_ENDWAIT, NULL);
    }
}

#ifdef DEBUG // {

//***   IS_* -- character classification routines
// ENTRY/EXIT
//  ch      TCHAR to be checked
//  return  TRUE if in range, FALSE if not
#define IS_LOWER(ch)    InRange(ch, TEXT('a'), TEXT('z'))
#define IS_UPPER(ch)    InRange(ch, TEXT('A'), TEXT('Z'))
#define IS_ALPHA(ch)    (IS_LOWER(ch) || IS_UPPER(ch))
#define IS_DIGIT(ch)    InRange(ch, TEXT('0'), TEXT('9'))
#define TO_UPPER(ch)    ((ch) - TEXT('a') + TEXT('A'))

//***   BMAP_* -- bitmap routines
// ENTRY/EXIT
//  pBits       ptr to bitmap (array of bytes)
//  iBit        bit# to be manipulated
//  return      various...
// DESCRIPTION
//  BMAP_TEST   check bit #iBit of bitmap pBits
//  BMAP_SET    set   bit #iBit of bitmap pBits
// NOTES
//  warning: no overflow checks
#define BMAP_INDEX(iBit)        ((iBit) / 8)
#define BMAP_MASK(iBit)         (1 << ((iBit) % 8))
#define BMAP_BYTE(pBits, iBit)  (((char *)pBits)[BMAP_INDEX(iBit)])

#define BMAP_TEST(pBits, iBit)  (BMAP_BYTE(pBits, iBit) & BMAP_MASK(iBit))
#define BMAP_SET(pBits, iBit)   (BMAP_BYTE(pBits, iBit) |= BMAP_MASK(iBit))

//***   DBGetMnemonic -- get menu mnemonic
// ENTRY/EXIT
//  return  mnemonic if found, o.w. 0
// NOTES
//  we handle and skip escaped-& ('&&')
//
TCHAR DBGetMnemonic(LPTSTR pszName)
{
    for (; *pszName != 0; pszName = CharNext(pszName)) 
    {
        if (*pszName == TEXT('&')) 
        {
            pszName = CharNext(pszName);    // skip '&'
            if (*pszName != TEXT('&'))
                return *pszName;
            ASSERT(0);  // untested! (but should work...)
            pszName = CharNext(pszName);    // skip 2nd '&'
        }
    }
    // this one happens a lot w/ weird things like "", "..", "..."
    return 0;
}

//***   DBCheckMenu -- check menu for 'style' conformance
// DESCRIPTION
//  currently we just check for mnemonic collisions (and only a-z,0-9)
void DBCheckMenu(HMENU hmChk)
{
    long bfAlpha = 0;
    long bfDigit = 0;
    long *pbfMne;
    int nItem;
    int iMne;
    TCHAR chMne;
    TCHAR szName[256]; // 256 characters of the menu name should be plenty...
    MENUITEMINFO miiChk;

    if (!DM_STRICT)
        return;

    for (nItem = GetMenuItemCount(hmChk) - 1; nItem >= 0; nItem--) 
    {
        miiChk.cbSize = sizeof(MENUITEMINFO);
        miiChk.fMask = MIIM_TYPE|MIIM_DATA;
        // We need to reset this every time through the loop in case
        // menus DON'T have IDs
        miiChk.fType = MFT_STRING;
        miiChk.dwTypeData = szName;
        szName[0] = 0;
        miiChk.dwItemData = 0;
        miiChk.cch        = ARRAYSIZE(szName);

        if (!GetMenuItemInfo(hmChk, nItem, TRUE, &miiChk)) 
        {
            TraceMsg(TF_WARNING, "dbcm: fail iMenu=%d (skip)", nItem);
            continue;
        }

        if (! (miiChk.fType & MFT_STRING)) 
        {
            // skip separators, etc.
            continue;
        }

        chMne = DBGetMnemonic(szName);
        if (chMne == 0 || ! (IS_ALPHA(chMne) || IS_DIGIT(chMne))) 
        {
            // this one actually happens a lot w/ chMne==0
            if (DM_STRICT2)
                TraceMsg(TF_WARNING, "dbcm: skip iMenu=%d mne=%c", nItem, chMne ? chMne : TEXT('0'));
            continue;
        }

        if (IS_LOWER(chMne)) 
        {
            chMne = TO_UPPER(chMne);
        }

        if (IS_UPPER(chMne)) 
        {
            iMne = chMne - TEXT('A');
            pbfMne = &bfAlpha;
        }
        else if (IS_DIGIT(chMne)) 
        {
            iMne = chMne - TEXT('0');
            pbfMne = &bfDigit;
        }
        else 
        {
            ASSERT(0);
            continue;
        }

        if (BMAP_TEST(pbfMne, iMne)) 
        {
            TraceMsg(TF_ERROR, "dbcm: mnemonic collision hm=%x iM=%d szMen=%s",
                hmChk, nItem, szName);
        }

        BMAP_SET(pbfMne, iMne);
    }

    return;
}

#else // }{
#define DBCheckMenu(hmChk)  0
#endif // }

// Copy a menu onto the beginning or end of another menu
// Adds uIDAdjust to each menu ID (pass in 0 for no adjustment)
// Will not add any item whose adjusted ID is greater than uMaxIDAdjust
// (pass in 0xffff to allow everything)
// Returns one more than the maximum adjusted ID that is used
//

UINT WINAPI Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags)
{
    int nItem;
    HMENU hmSubMenu;
    BOOL bAlreadySeparated;
    MENUITEMINFO miiSrc;
    TCHAR szName[256];
    UINT uTemp, uIDMax = uIDAdjust;

    if (!hmDst || !hmSrc)
    {
        goto MM_Exit;
    }

    nItem = GetMenuItemCount(hmDst);
    if (uInsert >= (UINT)nItem)
    {
        uInsert = (UINT)nItem;
        bAlreadySeparated = TRUE;
    }
    else
    {
        bAlreadySeparated = _SHIsMenuSeparator(hmDst, uInsert);
    }

    if ((uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated)
    {
        // Add a separator between the menus
        InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        bAlreadySeparated = TRUE;
    }


    // Go through the menu items and clone them
    for (nItem = GetMenuItemCount(hmSrc) - 1; nItem >= 0; nItem--)
    {
        miiSrc.cbSize = sizeof(MENUITEMINFO);
        miiSrc.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;
        // We need to reset this every time through the loop in case
        // menus DON'T have IDs
        miiSrc.fType = MFT_STRING;
        miiSrc.dwTypeData = szName;
        miiSrc.dwItemData = 0;
        miiSrc.cch        = ARRAYSIZE(szName);

        if (!GetMenuItemInfo(hmSrc, nItem, TRUE, &miiSrc))
        {
            continue;
        }

        // If it's a separator, then add it.  If the separator has a
        // submenu, then the caller is smoking crash and needs their butt kicked.
        if ((miiSrc.fType & MFT_SEPARATOR) && EVAL(!miiSrc.hSubMenu))
        {
            // This is a separator; don't put two of them in a row
            if (bAlreadySeparated && miiSrc.wID == -1 && !(uFlags & MM_DONTREMOVESEPS))
            {
                continue;
            }

            bAlreadySeparated = TRUE;
        }
        else if (miiSrc.hSubMenu)
        {
            if (uFlags & MM_SUBMENUSHAVEIDS)
            {
                // Adjust the ID and check it
                miiSrc.wID += uIDAdjust;
                if (miiSrc.wID > uIDAdjustMax)
                {
                    continue;
                }

                if (uIDMax <= miiSrc.wID)
                {
                    uIDMax = miiSrc.wID + 1;
                }
            }
            else
            {
                // Don't set IDs for submenus that didn't have
                // them already
                miiSrc.fMask &= ~MIIM_ID;
            }

            hmSubMenu = miiSrc.hSubMenu;
            miiSrc.hSubMenu = CreatePopupMenu();
            if (!miiSrc.hSubMenu)
            {
                goto MM_Exit;
            }

            uTemp = Shell_MergeMenus(miiSrc.hSubMenu, hmSubMenu, 0, uIDAdjust,
                uIDAdjustMax, uFlags&MM_SUBMENUSHAVEIDS);
            if (uIDMax <= uTemp)
            {
                uIDMax = uTemp;
            }

            bAlreadySeparated = FALSE;
        }
        else
        {
            // Adjust the ID and check it
            miiSrc.wID += uIDAdjust;
            if (miiSrc.wID > uIDAdjustMax)
            {
                continue;
            }

            if (uIDMax <= miiSrc.wID)
            {
                uIDMax = miiSrc.wID + 1;
            }

            bAlreadySeparated = FALSE;
        }

        if (!InsertMenuItem(hmDst, uInsert, TRUE, &miiSrc))
        {
            goto MM_Exit;
        }
    }

    // Ensure the correct number of separators at the beginning of the
    // inserted menu items
    if (uInsert == 0)
    {
        if (bAlreadySeparated && !(uFlags & MM_DONTREMOVESEPS))
        {
            DeleteMenu(hmDst, uInsert, MF_BYPOSITION);
        }
    }
    else
    {
        if (_SHIsMenuSeparator(hmDst, uInsert-1))
        {
            if (bAlreadySeparated && !(uFlags & MM_DONTREMOVESEPS))
            {
                DeleteMenu(hmDst, uInsert, MF_BYPOSITION);
            }
        }
        else
        {
            if ((uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated)
            {
                // Add a separator between the menus
                InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            }
        }
    }

MM_Exit:
#ifdef DEBUG
    DBCheckMenu(hmDst);
#endif
    return uIDMax;
}

#define REG_WINLOGON_KEY     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define REG_PREV_OS_VERSION  TEXT("PrevOsVersion")
#define REG_VAL_PLATFORM_ID  TEXT("PlatformId")
#define REG_VAL_MINORVERSION TEXT("MinorVersion")

//
// The following function is called, when we detect that IE4 was installed in this machine earlier.
// We want to see if that IE4 was there because of Win98 (if so, the ActiveDesktop is OFF by default)
//

BOOL    WasPrevOsWin98()
{
    BOOL    fWin98;
    HKEY    hkeyWinlogon;

    // 99/10/26 Millennium #94983 vtan: When upgrading Win98 to Millennium this
    // will incorrectly detect the system as NT4/IE4 which has Active Desktop
    // set to default to on. Because Windows 2000 setup when upgrading from
    // Windows 98 writes out the previous OS key and Windows Millennium setup
    // when upgrading from Windows 98 does NOT and some Windows NT specific
    // keys and values have never been present on a Windows 98 system it
    // should be adequate to check their presence to determine whether this is
    // an NT4/IE4 upgrade or a Windows 98 upgrade to Millennium.

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_WINLOGON_KEY, 0, KEY_QUERY_VALUE, &hkeyWinlogon))
    {
        HKEY    hk;
        DWORD   dwType;
        DWORD   dwPlatformId, dwMinorVersion;
        DWORD   dwDataLength;

        // 99/04/09 #319056 vtan: We'll assume that previous OS is known on
        // a Win9x upgrade from keys written by setup. If no keys are present
        // we'll assume NT4 upgrade where with IE4 integrated shell the default
        // was ON.

        fWin98 = FALSE;

        // See it the prev OS info is available. Caution: This info gets written in registry by
        // NT setup at the far end of the setup process (after all our DLLs are already registered).
        // So, we use extra care here to see of that key and values really exist or not!
        if (RegOpenKeyEx(hkeyWinlogon, REG_PREV_OS_VERSION, 0, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS)
        {
            dwType = 0;
            dwDataLength = sizeof(dwPlatformId);
            if (RegQueryValueEx(hk, REG_VAL_PLATFORM_ID, NULL, &dwType, (LPBYTE)(&dwPlatformId), &dwDataLength) == ERROR_SUCCESS)
            {
                dwType = 0;
                dwDataLength = sizeof(dwMinorVersion);
                if (RegQueryValueEx(hk, REG_VAL_MINORVERSION, NULL, &dwType, (LPBYTE)(&dwMinorVersion), &dwDataLength) == ERROR_SUCCESS)
                {
                    if ((dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (dwMinorVersion > 0))
                        fWin98 = TRUE;   //This is Win98 for sure!
                    else
                        fWin98 = FALSE;  //The prev OS is NOT win98 for sure!
                }
            }
            RegCloseKey(hk);
        }
        RegCloseKey(hkeyWinlogon);
    }
    else
    {
        fWin98 = TRUE;
    }

    return fWin98;
}


void _SetIE4DefaultShellState(SHELLSTATE *pss)
{
    pss->fDoubleClickInWebView = TRUE;
    pss->fShowInfoTip = TRUE;
    pss->fWebView = TRUE;
    pss->fDesktopHTML = FALSE;

    // IE4 defaulted to fDesktopHTML on, and on NT5 upgrade we don't
    // want to override that (and probably not on Win98 upgrade, but
    // it's too late for that).  To determine this here, check a
    // uniquely IE4 reg-key.  (Note, this will catch the case if the
    // user *modified* their desktop.  If they just went with the
    // defaults, this key won't be there and we'll remove AD.)
    TCHAR   szDeskcomp[MAX_PATH];
    DWORD   dwType = 0, dwDeskHtmlVersion = 0;
    DWORD   dwDataLength = sizeof(dwDeskHtmlVersion);

    GetRegLocation(szDeskcomp, SIZECHARS(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

    SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_VERSION, &dwType, (LPBYTE)(&dwDeskHtmlVersion), &dwDataLength);

    // 99/05/03 #292269: Notice the difference in the order of the
    // bits. The current structure (IE4 and later) has fShowSysFiles
    // between fNoConfirmRecycle and fShowCompColor. Move the bit
    // based on the size of the struct and reset fShowSysFiles to TRUE.

    // WIN95 SHELLSTATE struct bit fields
    //  BOOL fShowAllObjects : 1;
    //  BOOL fShowExtensions : 1;
    //  BOOL fNoConfirmRecycle : 1;
    //  BOOL fShowCompColor  : 1;
    //  UINT fRestFlags : 13;

    // IE4 SHELLSTATE struct bit fields
    //  BOOL fShowAllObjects : 1;
    //  BOOL fShowExtensions : 1;
    //  BOOL fNoConfirmRecycle : 1;
    //  BOOL fShowSysFiles : 1;
    //  BOOL fShowCompColor : 1;
    //  BOOL fDoubleClickInWebView : 1;
    //  BOOL fDesktopHTML : 1;
    //  BOOL fWin95Classic : 1;
    //  BOOL fDontPrettyPath : 1;
    //  BOOL fShowAttribCol : 1;
    //  BOOL fMapNetDrvBtn : 1;
    //  BOOL fShowInfoTip : 1;
    //  BOOL fHideIcons : 1;
    //  BOOL fWebView : 1;
    //  BOOL fFilter : 1;
    //  BOOL fShowSuperHidden : 1;

    // Millennium SHELLSTATE struct bit fields
    //  BOOL fNoNetCrawling : 1;

    // Whistler SHELLSTATE struct bit fields
    //  BOOL fStartPanelOn : 1;
    //  BOOL fShowStartPage : 1;

    if ((g_pShellState->cbSize == REGSHELLSTATE_SIZE_WIN95) || (g_pShellState->cbSize == REGSHELLSTATE_SIZE_NT4))
    {
        pss->fShowCompColor = TRUE;
        pss->fShowSysFiles = TRUE;
    }
    if (dwDeskHtmlVersion == IE4_DESKHTML_VERSION)
        pss->fDesktopHTML = !WasPrevOsWin98();   //This is an upgrade from IE4; but, the registry is not updated yet.
    else
    {
        if (dwDeskHtmlVersion > IE4_DESKHTML_VERSION)
        {
            DWORD   dwOldHtmlVersion = 0;
            dwDataLength = sizeof(dwOldHtmlVersion);
            // This is NT5 or above! Check to see if we have "UpgradedFrom" value.
            // NOTE: The "UpgradedFrom" value is at "...\Desktop" and NOT at "..\Desktop\Components"
            // This is because the "Components" key gets destroyed very often.
            SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP, REG_VAL_COMP_UPGRADED_FROM, &dwType, (LPBYTE)&dwOldHtmlVersion, &dwDataLength);

            // 99/05/17 #333384 vtan: Check for IE5 as an old version too. The current version
            // is now 0x0110 (from 0x010F) and this causes the HKCU\Software\Microsoft\Internet
            // Explorer\Desktop\UpgradedFrom value to get created in CDeskHtmlProp_RegUnReg().
            // This is executed by IE4UINIT.EXE as well as REGSVR32.EXE with the "/U" parameter
            // so this field should be present at the time this executes. Note this only
            // executes the once on upgrade because the ShellState will get written.

            if ((dwOldHtmlVersion == IE4_DESKHTML_VERSION) || (dwOldHtmlVersion == IE5_DESKHTML_VERSION))
                pss->fDesktopHTML = !WasPrevOsWin98();   //This is an upgrade from IE4;
        }
    }
}


//
// This function checks if the caller is running in an explorer process.
//
STDAPI_(BOOL) IsProcessAnExplorer()
{
    return BOOLFROMPTR(GetModuleHandle(TEXT("EXPLORER.EXE")));
}


//
// Is this the main shell process? (eg the one that owns the desktop window)
//
// NOTE: if the desktop window has not been created, we assume that this is NOT the
//       main shell process and return FALSE;
//
STDAPI_(BOOL) IsMainShellProcess()
{
    static int s_fIsMainShellProcess = -1;

    if (s_fIsMainShellProcess == -1)
    {
        HWND hwndDesktop = GetShellWindow();

        if (hwndDesktop)
        {
            s_fIsMainShellProcess = (int)IsWindowInProcess(hwndDesktop);

            if ((s_fIsMainShellProcess != 0) && !IsProcessAnExplorer())
            {
                TraceMsg(TF_WARNING, "IsMainShellProcess: the main shell process (owner of the desktop) is NOT an explorer window?!?");
            }
        }
        else
        {
#ifdef FULL_DEBUG
            // only spew on FULL_DEBUG to cut down on chattyness in normal debug builds
            TraceMsg(TF_WARNING, "IsMainShellProcess: hwndDesktop does not exist, assuming we are NOT the main shell process");
#endif // FULL_DEBUG

            return FALSE;
        }
    }

    return s_fIsMainShellProcess ? TRUE : FALSE;
}

BOOL _ShouldStartPanelBeEnabledByDefault()
{
    DWORD dwDefaultPanelOff;
    DWORD cbSize;

    cbSize = sizeof(dwDefaultPanelOff);
    // We respect a regkey that can be set by an unattend file to default to the classic start menu
    if ((SHRegGetUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartMenu\\StartPanel"),
                         TEXT("DefaultStartPanelOff"),
                         NULL,
                         &dwDefaultPanelOff,
                         &cbSize,
                         FALSE,
                         NULL,
                         0) == ERROR_SUCCESS) && dwDefaultPanelOff)
    {
        return FALSE;
    }

    // Otherwise everybody gets the Start Panel (even server!)
    return TRUE;
}


DWORD GetCurrentSessionID(void)
{
    DWORD dwProcessID = (DWORD) -1;
    ProcessIdToSessionId(GetCurrentProcessId(), &dwProcessID);

    return dwProcessID;
}

typedef struct
{
    LPCWSTR pszRegKey;
    LPCWSTR pszRegValue;
} TSPERFFLAG_ITEM;

const TSPERFFLAG_ITEM s_TSPerfFlagItems[] =
{
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d", L"ActiveDesktop"},              // TSPerFlag_NoADWallpaper
    {L"Control Panel\\Desktop\\Remote\\%d", L"Wallpaper"},                                                  // TSPerFlag_NoWallpaper
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager\\Remote\\%d", L"ThemeActive"},            // TSPerFlag_NoVisualStyles
    {L"Control Panel\\Desktop\\Remote\\%d", L"DragFullWindows"},                                            // TSPerFlag_NoWindowDrag
    {L"Control Panel\\Desktop\\Remote\\%d", L"SmoothScroll"},                                               // TSPerFlag_NoAnimation
};


BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag)
{
    BOOL fIsTSFlagEnabled = FALSE;

    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        TCHAR szTemp[MAX_PATH];
        DWORD dwType;
        DWORD cbSize = sizeof(szTemp);
        TCHAR szRegKey[MAX_PATH];

        StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), s_TSPerfFlagItems[eTSFlag].pszRegKey, GetCurrentSessionID());    // ok to truncate

        if (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szRegKey, s_TSPerfFlagItems[eTSFlag].pszRegValue, &dwType, (void *)szTemp, &cbSize))
        {
            fIsTSFlagEnabled = TRUE;
        }
    }

    return fIsTSFlagEnabled;
}


BOOL PolicyNoActiveDesktop(void)
{
    BOOL fNoActiveDesktop = SHRestricted(REST_NOACTIVEDESKTOP);

    if (!fNoActiveDesktop)
    {
        fNoActiveDesktop = (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) || IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper));
    }

    return fNoActiveDesktop;
}


BOOL _RefreshSettingsFromReg()
{
    BOOL fNeedToUpdateReg = FALSE;
    static REGSHELLSTATE ShellStateBuf = {0,};
    DWORD cbSize;

    ASSERTCRITICAL;

    if (g_pShellState)
    {
        //  reuse the buffer if possible
        cbSize = g_pShellState->cbSize;
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("ShellState"), NULL, g_pShellState, &cbSize)))
        {
            if (&ShellStateBuf != g_pShellState)
            {
                LocalFree(g_pShellState);
            }
            g_pShellState = NULL;
        }
    }

    if (!g_pShellState)
    {
        if (FAILED(SKAllocValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("ShellState"), NULL, (void **)&g_pShellState, NULL)))
        {
            g_pShellState = &ShellStateBuf;
        }
        else
        {
            cbSize = LocalSize(g_pShellState);

            // if we read out an smaller size from the registry, then copy it into our stack buffer and use that.
            // we need a struct at least as big as the current size
            if (cbSize <= sizeof(ShellStateBuf))
            {
                CopyMemory(&ShellStateBuf, g_pShellState, cbSize);
                LocalFree(g_pShellState);
                g_pShellState = &ShellStateBuf;

                // g_pShellState->cbSize will be updated in the below
                fNeedToUpdateReg = TRUE;
            }
        }
    }

    // Upgrade what we read out of the registry

    if ((g_pShellState->cbSize == REGSHELLSTATE_SIZE_WIN95) ||
        (g_pShellState->cbSize == REGSHELLSTATE_SIZE_NT4))
    {
        // Upgrade Win95 bits.  Too bad our defaults weren't
        // FALSE for everything, because whacking these bits
        // breaks roaming.  Of course, if you ever roam to
        // a Win95 machine, it whacks all bits to zero...

        _SetIE4DefaultShellState(&g_pShellState->ss);

        //New bits added for Whistler
        //g_pShellState->ss.fNoNetCrawling = FALSE;
        g_pShellState->ss.fStartPanelOn = _ShouldStartPanelBeEnabledByDefault();
        //g_pShellState->ss.fShowStartPage = FALSE;           // Off by default for now!

        g_pShellState->ss.version = SHELLSTATEVERSION;
        g_pShellState->cbSize = sizeof(REGSHELLSTATE);

        fNeedToUpdateReg = TRUE;
    }
    else if (g_pShellState->cbSize >= REGSHELLSTATE_SIZE_IE4)
    {
        // Since the version field was new to IE4, this should be true:
        ASSERT(g_pShellState->ss.version >= SHELLSTATEVERSION_IE4);

        if (g_pShellState->ss.version < SHELLSTATEVERSION)
        {
            //Since the version # read from the registry is old!
            fNeedToUpdateReg = TRUE;
        }

        // Upgrade to current version here - make sure we don't
        // stomp on bits unnecessarily, as that will break roaming...
        if (g_pShellState->ss.version == SHELLSTATEVERSION_IE4)
        {
            // IE4.0 shipped with verion = 9; The SHELLSTATEVERSION was changed to 10 later.
            // But the structure size or defaults have not changed since IE4.0 shipped. So,
            // the following code treats version 9 as the same as version 10. If we do not do this,
            // the IE4.0 users who upgrade to Memphis or IE4.01 will lose all their settings
            // (Bug #62389).
            g_pShellState->ss.version = SHELLSTATEVERSION_WIN2K;
        }

        // Since this could be an upgrade from Win98, the fWebView bit, which was not used in win98
        // could be zero; We must set the default value of fWebView = ON here and later in
        // _RefreshSettings() functions we read from Advanced\WebView value and reset it (if it is there).
        // If Advanced\WebView is not there, then this must be an upgrade from Win98 and WebView should be
        // turned ON.
        g_pShellState->ss.fWebView = TRUE;

        // Upgrade from Win2K to Millennium/Whistler installs
        if (g_pShellState->ss.version == SHELLSTATEVERSION_WIN2K)
        {
            //g_pShellState->ss.fNoNetCrawling = FALSE;
            //g_pShellState->ss.fShowStartPage = FALSE;
            g_pShellState->ss.version = 11;
        }

        if (g_pShellState->ss.version < 13)
        {
            //This is the new bit added between versions 11 and 12. The default changed for 13.
            g_pShellState->ss.fStartPanelOn = _ShouldStartPanelBeEnabledByDefault();
            g_pShellState->ss.version = 13;
        }
        
        // Ensure that the CB reflects the current size of the structure
        if (fNeedToUpdateReg)
        {
            g_pShellState->cbSize = sizeof(REGSHELLSTATE);
        }

        // Must be saved state from this or an uplevel platform.  Don't touch the bits.
        ASSERT(g_pShellState->ss.version >= SHELLSTATEVERSION);
    }
    else
    {
        // We could not read anything from reg. Initialize all fields.
        // 0 should be the default for *most* everything
        g_pShellState->cbSize = sizeof(REGSHELLSTATE);

        g_pShellState->ss.iSortDirection = 1;

        _SetIE4DefaultShellState(&g_pShellState->ss);

        // New bits added for Whistler.
        // g_pShellState->ss.fNoNetCrawling = FALSE;
        g_pShellState->ss.fStartPanelOn = _ShouldStartPanelBeEnabledByDefault();
        //g_pShellState->ss.fShowStartPage = FALSE;
        
        // New defaults for Whistler.
        g_pShellState->ss.fShowCompColor = TRUE;

        g_pShellState->ss.version = SHELLSTATEVERSION;

        fNeedToUpdateReg = TRUE;
    }

    // Apply restrictions
    //Note: This restriction supercedes the NOACTIVEDESKTOP!
    if (SHRestricted(REST_FORCEACTIVEDESKTOPON))
    {
        g_pShellState->ss.fDesktopHTML = TRUE;
    }
    else
    {
        if (PolicyNoActiveDesktop())
        {
            //Note this restriction is superceded by FORCEACTIVEDESKTOPON!
            g_pShellState->ss.fDesktopHTML = FALSE;
        }
    }

    if (SHRestricted(REST_NOWEBVIEW))
    {
        g_pShellState->ss.fWebView = FALSE;
    }

    // ClassicShell restriction makes all web view off and forces even more win95 behaviours
    // so we still need to fDoubleClickInWebView off.
    if (SHRestricted(REST_CLASSICSHELL))
    {
        g_pShellState->ss.fWin95Classic = TRUE;
        g_pShellState->ss.fDoubleClickInWebView = FALSE;
        g_pShellState->ss.fWebView = FALSE;
        g_pShellState->ss.fDesktopHTML = FALSE;
    }

    if (SHRestricted(REST_DONTSHOWSUPERHIDDEN))
    {
        g_pShellState->ss.fShowSuperHidden = FALSE;
    }

    if (SHRestricted(REST_SEPARATEDESKTOPPROCESS))
    {
        g_pShellState->ss.fSepProcess = TRUE;
    }

    if (SHRestricted(REST_NONETCRAWL))
    {
        g_pShellState->ss.fNoNetCrawling = FALSE;
    }

    if (SHRestricted(REST_NOSTARTPANEL))
    {
        g_pShellState->ss.fStartPanelOn = FALSE;
    }

    if (SHRestricted(REST_NOSTARTPAGE))
    {
        g_pShellState->ss.fShowStartPage = FALSE;
    }
    
    if (fNeedToUpdateReg)
    {
        // There is a need to update ShellState in registry. Do it only if current procees is
        // an Explorer process.
        //
        // Because, only when the explorer process is running, we can be
        // assured that the NT5 setup is complete and all the PrevOsVersion info is available and
        // _SetIE4DefaultShellState() and WasPrevOsWin98() etc, would have set the proper value
        // for fDesktopHHTML. If we don't do the following check, we will end-up updating the
        // registry the first time someone (like setup) called SHGetSettings() and that would be
        // too early to update the ShellState since we don't have all the info needed to decide if
        // fDesktopHTML needs to be ON or OFF based on previous OS, previous IE version etc.,
        fNeedToUpdateReg = IsProcessAnExplorer();
    }

    return (fNeedToUpdateReg);
}

EXTERN_C HANDLE g_hSettings = NULL;     //  global shell settings counter
LONG g_lProcessSettingsCount = -1;      //  current process's count
const GUID GUID_ShellSettingsChanged = { 0x7cb834f0, 0x527b, 0x11d2, {0x9d, 0x1f, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57}}; // 7cb834f0-527b-11d2-9d1f-0000f805ca57

HANDLE _GetSettingsCounter()
{
    return SHGetCachedGlobalCounter(&g_hSettings, &GUID_ShellSettingsChanged);
}

BOOL _QuerySettingsChanged(void)
{
    long lGlobalCount = SHGlobalCounterGetValue(_GetSettingsCounter());
    if (g_lProcessSettingsCount != lGlobalCount)
    {
        g_lProcessSettingsCount = lGlobalCount;
        return TRUE;
    }
    return FALSE;
}

//
//  SHRefreshSettings now just invalidates the settings cache.
//  so that the next time that SHGetSetSettings() is called
//  it will reread all the settings
//
STDAPI_(void) SHRefreshSettings(void)
{
    SHGlobalCounterIncrement(_GetSettingsCounter());
}

// this needs to get called periodically to re-fetch the settings from the
// registry as we no longer store them in a share data segment
BOOL _RefreshSettings(void)
{
    BOOL    fNeedToUpdateReg = FALSE;

    ENTERCRITICAL;

    fNeedToUpdateReg = _RefreshSettingsFromReg();

    // get the advanced options.
    // they are stored as individual values so that policy editor can change it.
    HKEY hkeyAdv = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("Advanced"), FALSE);
    if (hkeyAdv)
    {
        DWORD dwData;
        DWORD dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("Hidden"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            // Map the obsolete value of 0 to 2.
            if (dwData == 0)
                dwData = 2;
            g_pShellState->ss.fShowAllObjects = (dwData == 1);
            g_pShellState->ss.fShowSysFiles = (dwData == 2);
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("ShowCompColor"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowCompColor = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("HideFileExt"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowExtensions = (BOOL)dwData ? FALSE : TRUE;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("DontPrettyPath"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fDontPrettyPath = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("ShowInfoTip"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowInfoTip = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("HideIcons"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fHideIcons = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("MapNetDrvBtn"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fMapNetDrvBtn = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (!SHRestricted(REST_CLASSICSHELL))
        {
            if (SHQueryValueEx(hkeyAdv, TEXT("WebView"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
            {
                g_pShellState->ss.fWebView = (BOOL)dwData;
            }
            else
            {
                //If Advanced/WebView value is not there, then this could be an upgrade from win98/IE4
                // where we stored this info in DEFFOLDERSETTINGS in Explorer\Streams\Settings.
                // See if that info is there; If so, use it!
                DEFFOLDERSETTINGS dfs;
                DWORD dwType, cbData = sizeof(dfs);
                if (SUCCEEDED(SKGetValue(SHELLKEY_HKCU_EXPLORER, TEXT("Streams"), TEXT("Settings"), &dwType, &dfs, &cbData))
                && (dwType == REG_BINARY))
                {
                    //DefFolderSettings is there; Check if this is the correct struct.
                    //Note:In Win98/IE4, we wrongly initialized dwStructVersion to zero.
                    if ((cbData == sizeof(dfs)) &&
                        ((dfs.dwStructVersion == 0) || (dfs.dwStructVersion == DFS_NASH_VER)))
                    {
                        g_pShellState->ss.fWebView = ((dfs.bUseVID) && (dfs.vid == VID_WebView));
                    }
                }
            }
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("Filter"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fFilter = (BOOL)dwData;
        }

        if (SHQueryValueEx(hkeyAdv, TEXT("ShowSuperHidden"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowSuperHidden = (BOOL)dwData;
        }

        if (SHQueryValueEx(hkeyAdv, TEXT("SeparateProcess"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fSepProcess = (BOOL)dwData;
        }

        if (SHQueryValueEx(hkeyAdv, TEXT("NoNetCrawling"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fNoNetCrawling = (BOOL)dwData;
        }

        RegCloseKey(hkeyAdv);
    }
    else
    {
        // Hey, if the advanced key is not there, this must be a Win9x upgrade...
        // Fortunately the SHELLSTATE defaults and the not-in-registry defaults
        // are the same, so we don't need any auto-propogate code here.
    }

    //  this process is now in sync
    g_lProcessSettingsCount = SHGlobalCounterGetValue(_GetSettingsCounter());

    LEAVECRITICAL;

    return fNeedToUpdateReg;
}

// This function moves SHELLSTATE settings into the Advanced Settings
// portion of the registry.  If no SHELLSTATE is passed in, it uses
// the current state stored in the registry.
//
void Install_AdvancedShellSettings(SHELLSTATE * pss)
{
    DWORD dw;
    BOOL fCrit = FALSE;

    if (NULL == pss)
    {
        // Get the current values in the registry or the default values
        // as determined by the following function.
        //
        // we'll be partying on g_pShellState, so grab the critical section here
        //
        ENTERCRITICALNOASSERT;
        fCrit = TRUE;

        // Win95 and NT5 kept the SHELLSTATE bits in the registry up to date,
        // but apparently IE4 only kept the ADVANCED section up to date.
        // It would be nice to call _RefreshSettingsFromReg(); here, but
        // that won't keep IE4 happy.  Call _RefreshSettings() instead.
        _RefreshSettings();

        pss = &g_pShellState->ss;
    }

    HKEY hkeyAdv = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("Advanced"), TRUE);
    if (hkeyAdv)
    {
        DWORD dwData;

        dw = sizeof(dwData);
        dwData = (DWORD)(pss->fShowAllObjects ? 1 : 2);
        RegSetValueEx(hkeyAdv, TEXT("Hidden") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowCompColor ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("ShowCompColor") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowExtensions ? 0 : 1;
        RegSetValueEx(hkeyAdv, TEXT("HideFileExt") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fDontPrettyPath ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("DontPrettyPath") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowInfoTip ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("ShowInfoTip") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fHideIcons ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("HideIcons") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fMapNetDrvBtn ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("MapNetDrvBtn") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fWebView ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("WebView") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fFilter ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("Filter") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowSuperHidden ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("SuperHidden") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fSepProcess ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("SeparateProcess") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        RegCloseKey(hkeyAdv);
    }

    if (fCrit)
    {
        LEAVECRITICALNOASSERT;
    }
}

STDAPI_(void) SHGetSetSettings(LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet)
{
    //Does the ShellState in Reg is old? If so, we need to update it!
    BOOL    fUpdateShellStateInReg = FALSE;  //Assume, no need to update it!

    if (!lpss && !dwMask && bSet)
    {
        // this was a special way to call
        // SHRefreshSettings() from an external module.
        // special case it out now.
        SHRefreshSettings();
        return;
    }

    if (!g_pShellState || _QuerySettingsChanged())
    {
        // if it hasn't been init'd or we are setting the values. We must do it
        // on the save case because it may have changed in the registry since
        // we last fetched it..
        fUpdateShellStateInReg = _RefreshSettings();
    }
    else if (g_pShellState)
    {
        // _RefreshSettingsFromReg sets g_pShellState to non null value
        // and then starts stuffing values into it and all within our
        // glorious critsec, but unless we check for the critsec here,
        // we will start partying on g_pShellState before it is finished
        // loading.
        ENTERCRITICAL;
        LEAVECRITICAL;
    }

    BOOL fSave = FALSE;
    BOOL fSaveAdvanced = FALSE;

    if (bSet)
    {
        if ((dwMask & SSF_SHOWALLOBJECTS) && (g_pShellState->ss.fShowAllObjects != lpss->fShowAllObjects))
        {
            g_pShellState->ss.fShowAllObjects = lpss->fShowAllObjects;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWSYSFILES) && (g_pShellState->ss.fShowSysFiles != lpss->fShowSysFiles))
        {
            g_pShellState->ss.fShowSysFiles = lpss->fShowSysFiles;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWEXTENSIONS) && (g_pShellState->ss.fShowExtensions != lpss->fShowExtensions))
        {
            g_pShellState->ss.fShowExtensions = lpss->fShowExtensions;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWCOMPCOLOR) && (g_pShellState->ss.fShowCompColor != lpss->fShowCompColor))
        {
            g_pShellState->ss.fShowCompColor = lpss->fShowCompColor;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_NOCONFIRMRECYCLE) && (g_pShellState->ss.fNoConfirmRecycle != lpss->fNoConfirmRecycle))
        {
            if (!SHRestricted(REST_BITBUCKCONFIRMDELETE))
            {
                g_pShellState->ss.fNoConfirmRecycle = lpss->fNoConfirmRecycle;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_DOUBLECLICKINWEBVIEW) && (g_pShellState->ss.fDoubleClickInWebView != lpss->fDoubleClickInWebView))
        {
            if (!SHRestricted(REST_CLASSICSHELL))
            {
                g_pShellState->ss.fDoubleClickInWebView = lpss->fDoubleClickInWebView;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_DESKTOPHTML) && (g_pShellState->ss.fDesktopHTML != lpss->fDesktopHTML))
        {
            if (!SHRestricted(REST_NOACTIVEDESKTOP) && !SHRestricted(REST_CLASSICSHELL)
                                                    && !SHRestricted(REST_FORCEACTIVEDESKTOPON))
            {
                g_pShellState->ss.fDesktopHTML = lpss->fDesktopHTML;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_WIN95CLASSIC) && (g_pShellState->ss.fWin95Classic != lpss->fWin95Classic))
        {
            if (!SHRestricted(REST_CLASSICSHELL))
            {
                g_pShellState->ss.fWin95Classic = lpss->fWin95Classic;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_WEBVIEW) && (g_pShellState->ss.fWebView != lpss->fWebView))
        {
            if (!SHRestricted(REST_NOWEBVIEW) && !SHRestricted(REST_CLASSICSHELL))
            {
                g_pShellState->ss.fWebView = lpss->fWebView;
                fSaveAdvanced = TRUE;
            }
        }

        if ((dwMask & SSF_DONTPRETTYPATH) && (g_pShellState->ss.fDontPrettyPath != lpss->fDontPrettyPath))
        {
            g_pShellState->ss.fDontPrettyPath = lpss->fDontPrettyPath;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWINFOTIP) && (g_pShellState->ss.fShowInfoTip != lpss->fShowInfoTip))
        {
            g_pShellState->ss.fShowInfoTip = lpss->fShowInfoTip;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_HIDEICONS) && (g_pShellState->ss.fHideIcons != lpss->fHideIcons))
        {
            g_pShellState->ss.fHideIcons = lpss->fHideIcons;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_MAPNETDRVBUTTON) && (g_pShellState->ss.fMapNetDrvBtn != lpss->fMapNetDrvBtn))
        {
            g_pShellState->ss.fMapNetDrvBtn = lpss->fMapNetDrvBtn;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SORTCOLUMNS) &&
            ((g_pShellState->ss.lParamSort != lpss->lParamSort) || (g_pShellState->ss.iSortDirection != lpss->iSortDirection)))
        {
            g_pShellState->ss.iSortDirection = lpss->iSortDirection;
            g_pShellState->ss.lParamSort = lpss->lParamSort;
            fSave = TRUE;
        }

        if (dwMask & SSF_HIDDENFILEEXTS)
        {
            // Setting hidden extensions is not supported
        }

        if ((dwMask & SSF_FILTER) && (g_pShellState->ss.fFilter != lpss->fFilter))
        {
            g_pShellState->ss.fFilter = lpss->fFilter;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWSUPERHIDDEN) && (g_pShellState->ss.fShowSuperHidden != lpss->fShowSuperHidden))
        {
            g_pShellState->ss.fShowSuperHidden = lpss->fShowSuperHidden;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SEPPROCESS) && (g_pShellState->ss.fSepProcess != lpss->fSepProcess))
        {
            g_pShellState->ss.fSepProcess = lpss->fSepProcess;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_NONETCRAWLING) && (g_pShellState->ss.fNoNetCrawling != lpss->fNoNetCrawling))
        {
            g_pShellState->ss.fNoNetCrawling = lpss->fNoNetCrawling;
            fSaveAdvanced = TRUE;
        }
        
        if ((dwMask & SSF_STARTPANELON) && (g_pShellState->ss.fStartPanelOn != lpss->fStartPanelOn))
        {
            g_pShellState->ss.fStartPanelOn = lpss->fStartPanelOn;
            fSaveAdvanced = TRUE;
        }
        
        if ((dwMask & SSF_SHOWSTARTPAGE) && (g_pShellState->ss.fShowStartPage != lpss->fShowStartPage))
        {
            g_pShellState->ss.fShowStartPage = lpss->fShowStartPage;
            fSaveAdvanced = TRUE;
        }
    }

    if (fUpdateShellStateInReg || fSave || fSaveAdvanced)
    {
        // Write out the SHELLSTATE even if only fSaveAdvanced just to
        // make sure everything stays in sync.
        // We save 8 extra bytes for the ExcludeFileExts stuff.
        // Oh well.
        SKSetValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("ShellState"), REG_BINARY, g_pShellState, g_pShellState->cbSize);
    }

    if (fUpdateShellStateInReg || fSaveAdvanced)
    {
        // SHRefreshSettingsPriv overwrites the SHELLSTATE values with whatever
        // the user specifies in View.FolderOptions.View.AdvancedSettings dialog.
        // These values are stored elsewhere in the registry, so we
        // better migrate SHELLSTATE to that part of the registry now.
        //
        // Might as well only do this if the registry settings we care about change.
        Install_AdvancedShellSettings(&g_pShellState->ss);
    }

    if (fSave || fSaveAdvanced)
    {
        // Let apps know the state has changed.
        SHRefreshSettings();
        SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("ShellState"));
    }

    if (!bSet)
    {
        if (dwMask & SSF_SHOWEXTENSIONS)
        {
            lpss->fShowExtensions = g_pShellState->ss.fShowExtensions;
        }
        
        if (dwMask & SSF_SHOWALLOBJECTS)
        {
            lpss->fShowAllObjects = g_pShellState->ss.fShowAllObjects;  // users "show hidden" setting
        }

        if (dwMask & SSF_SHOWSYSFILES)
        {
            lpss->fShowSysFiles = g_pShellState->ss.fShowSysFiles;  // this is ignored
        }

        if (dwMask & SSF_SHOWCOMPCOLOR)
        {
            lpss->fShowCompColor = g_pShellState->ss.fShowCompColor;
        }

        if (dwMask & SSF_NOCONFIRMRECYCLE)
        {
            lpss->fNoConfirmRecycle = SHRestricted(REST_BITBUCKCONFIRMDELETE) ? FALSE : g_pShellState->ss.fNoConfirmRecycle;
        }

        if (dwMask & SSF_DOUBLECLICKINWEBVIEW)
        {
            lpss->fDoubleClickInWebView = g_pShellState->ss.fDoubleClickInWebView;
        }

        if (dwMask & SSF_DESKTOPHTML)
        {
            lpss->fDesktopHTML = g_pShellState->ss.fDesktopHTML;
        }

        if (dwMask & SSF_WIN95CLASSIC)
        {
            lpss->fWin95Classic = g_pShellState->ss.fWin95Classic;
        }
        if (dwMask & SSF_WEBVIEW)
        {
            lpss->fWebView = g_pShellState->ss.fWebView;
        }

        if (dwMask & SSF_DONTPRETTYPATH)
        {
            lpss->fDontPrettyPath = g_pShellState->ss.fDontPrettyPath;
        }

        if (dwMask & SSF_SHOWINFOTIP)
        {
            lpss->fShowInfoTip = g_pShellState->ss.fShowInfoTip;
        }

        if (dwMask & SSF_HIDEICONS)
        {
            lpss->fHideIcons = g_pShellState->ss.fHideIcons;
        }

        if (dwMask & SSF_MAPNETDRVBUTTON)
        {
            lpss->fMapNetDrvBtn = g_pShellState->ss.fMapNetDrvBtn;
        }

        if (dwMask & SSF_SORTCOLUMNS)
        {
            lpss->iSortDirection = g_pShellState->ss.iSortDirection;
            lpss->lParamSort = g_pShellState->ss.lParamSort;
        }

        if (dwMask & SSF_FILTER)
        {
            lpss->fFilter = g_pShellState->ss.fFilter;
        }

        if (dwMask & SSF_SHOWSUPERHIDDEN)
        {
            lpss->fShowSuperHidden = g_pShellState->ss.fShowSuperHidden;
        }

        if (dwMask & SSF_SEPPROCESS)
        {
            lpss->fSepProcess = g_pShellState->ss.fSepProcess;
        }

        if (dwMask & SSF_NONETCRAWLING)
        {
            lpss->fNoNetCrawling = g_pShellState->ss.fNoNetCrawling;
        }
        
        if (dwMask & SSF_STARTPANELON)
        {
            lpss->fStartPanelOn = g_pShellState->ss.fStartPanelOn;
        }

        if (dwMask & SSF_SHOWSTARTPAGE)
        {
            lpss->fShowStartPage = g_pShellState->ss.fShowStartPage;
        }
    }
}

// A public version of the Get function so ISVs can track the shell flag state
//
STDAPI_(void) SHGetSettings(LPSHELLFLAGSTATE lpsfs, DWORD dwMask)
{
    if (lpsfs)
    {
        SHELLSTATE ss={0};

        // SSF_HIDDENFILEEXTS and SSF_SORTCOLUMNS don't work with
        // the SHELLFLAGSTATE struct, make sure they are off
        // (because the corresponding SHELLSTATE fields don't
        // exist in SHELLFLAGSTATE.)
        //
        dwMask &= ~(SSF_HIDDENFILEEXTS | SSF_SORTCOLUMNS);

        SHGetSetSettings(&ss, dwMask, FALSE);

        // copy the dword of flags out
        *((DWORD *)lpsfs) = *((DWORD *)(&ss));
    }
}


// app compatibility HACK stuff. the following stuff including CheckWinIniForAssocs()
// is used by the new version of SHDOCVW
// and EXPLORER.EXE to patch the registry for old win31 apps.


BOOL _PathIsExe(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    HRESULT hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
    if (SUCCEEDED(hr))
    {
        PathRemoveBlanks(szPath);
        return PathIsExe(szPath);
    }
    else
    {
        return FALSE;
    }
}

// tests to see if pszSubFolder is the same as or a sub folder of pszParent
// in:
//      pszFolder       parent folder to test against
//                      this may be a CSIDL value if the HIWORD() is 0
//      pszSubFolder    possible sub folder
//
// example:
//      TRUE    pszFolder = c:\windows, pszSubFolder = c:\windows\system
//      TRUE    pszFolder = c:\windows, pszSubFolder = c:\windows
//      FALSE   pszFolder = c:\windows, pszSubFolder = c:\winnt
//

SHSTDAPI_(BOOL) PathIsEqualOrSubFolder(LPCTSTR pszFolder, LPCTSTR pszSubFolder)
{
    TCHAR szParent[MAX_PATH], szCommon[MAX_PATH];

    if (!IS_INTRESOURCE(pszFolder))
    {
        HRESULT hr = StringCchCopy(szParent, ARRAYSIZE(szParent), pszFolder);
        if (FAILED(hr))
        {
            return FALSE;
        }
    }
    else
    {
        SHGetFolderPath(NULL, PtrToUlong((void *) pszFolder) | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szParent);
    }

    //  PathCommonPrefix() always removes the slash on common
    return szParent[0] && PathRemoveBackslash(szParent)
        && PathCommonPrefix(szParent, pszSubFolder, szCommon)
        && lstrcmpi(szParent, szCommon) == 0;
}

// pass an array of CSIDL values (-1 terminated)

STDAPI_(BOOL) PathIsEqualOrSubFolderOf(LPCTSTR pszSubFolder, const UINT rgFolders[], DWORD crgFolders)
{
    for (DWORD i = 0; i < crgFolders; i++)
    {
        if (PathIsEqualOrSubFolder(MAKEINTRESOURCE(rgFolders[i]), pszSubFolder))
            return TRUE;
    }
    return FALSE;
}

// pass an array of CSIDL values (-1 terminated)

STDAPI_(BOOL) PathIsOneOf(LPCTSTR pszFolder, const UINT rgFolders[], DWORD crgFolders)
{
    for (DWORD i = 0; i < crgFolders; i++)
    {
        TCHAR szParent[MAX_PATH];
        SHGetFolderPath(NULL, rgFolders[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szParent);

        // the trailing slashes are assumed to match
        if (lstrcmpi(szParent, pszFolder) == 0)
            return TRUE;
    }
    return FALSE;
}

// test pszChild against pszParent to see if
// pszChild is a direct child (one level) of pszParent

STDAPI_(BOOL) PathIsDirectChildOf(LPCTSTR pszParent, LPCTSTR pszChild)
{
    BOOL bDirectChild = FALSE;
    HRESULT hr;
    TCHAR szParent[MAX_PATH];

    if (!IS_INTRESOURCE(pszParent))
    {
        hr = StringCchCopy(szParent, ARRAYSIZE(szParent), pszParent);

        if (FAILED(hr))
        {
            return FALSE;
        }
    }
    else
    {
        SHGetFolderPath(NULL, PtrToUlong((void *)pszParent) | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szParent);
    }

    if (PathIsRoot(szParent) && (-1 != PathGetDriveNumber(szParent)))
    {
        szParent[2] = 0;    // trip D:\ -> D: to make code below work
    }

    INT cchParent = lstrlen(szParent);
    INT cchChild = lstrlen(pszChild);

    if (cchParent <= cchChild)
    {
        TCHAR szChild[MAX_PATH];
        hr = StringCchCopy(szChild, ARRAYSIZE(szChild), pszChild);
        if (FAILED(hr))
        {
            return FALSE;
        }

        LPTSTR pszChildSlice = szChild + cchParent;
        if (TEXT('\\') == *pszChildSlice)
        {
            *pszChildSlice = 0;
        }

        if (lstrcmpi(szChild, szParent) == 0)
        {
            if (cchParent < cchChild)
            {
                LPTSTR pTmp = pszChildSlice + 1;

                while (*pTmp && *pTmp != TEXT('\\'))
                {
                    pTmp++; // find second level path segments
                }

                if (!(*pTmp))
                {
                    bDirectChild = TRUE;
                }
            }
        }
    }

    return bDirectChild;
}


// many net providers (Vines and PCNFS) don't
// like "C:\" frormat volumes names, this code returns "C:" format
// for use with WNet calls

STDAPI_(LPTSTR) PathBuildSimpleRoot(int iDrive, LPTSTR pszDrive)
{
    pszDrive[0] = iDrive + TEXT('A');
    pszDrive[1] = TEXT(':');
    pszDrive[2] = 0;
    return pszDrive;
}


// Return TRUE for exe, com, bat, pif and lnk.
BOOL ReservedExtension(LPCTSTR pszExt)
{
    TCHAR szExt[5];  // Dot+ext+null.

    HRESULT hr = StringCchCopy(szExt, ARRAYSIZE(szExt), pszExt);
    if (FAILED(hr))
    {
        return FALSE;
    }

    PathRemoveBlanks(szExt);
    if (PathIsExe(szExt) || (lstrcmpi(szExt, TEXT(".lnk")) == 0))
    {
        return TRUE;
    }

    return FALSE;
}

TCHAR const c_szRegPathIniExtensions[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Extensions");

STDAPI_(LONG) RegSetString(HKEY hk, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    return RegSetValue(hk, pszSubKey, REG_SZ, pszValue, (lstrlen(pszValue) + 1) * sizeof(TCHAR));
}


STDAPI_(BOOL) RegSetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPCTSTR psz)
{
    return (S_OK == SHSetValue(hkey, pszSubKey, pszValue, REG_SZ, psz, CbFromCch(lstrlen(psz) + 1)));
}


STDAPI_(BOOL) RegGetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPTSTR psz, DWORD cb)
{
    return (!GetSystemMetrics(SM_CLEANBOOT)
    &&  (S_OK == SHGetValue(hkey, pszSubKey, pszValue, NULL, psz, &cb)));
}


// Returns TRUE if there is a proper shell\open\command for the given
// extension that matches the given command line.
// NB This is for MGX Designer which registers an extension and commands for
// printing but relies on win.ini extensions for Open. We need to detect that
// there's no open command and add the appropriate entries to the registry.
// If the given extension maps to a type name we return that in pszTypeName
// otherwise it will be null.
// FMH This also affects Asymetric Compel which makes a new .CPL association.
// We need to merge it up into our Control Panel .CPL association.  We depend
// on Control Panels NOT having a proper Open so users can see both verb sets.
// NB pszLine is the original line from win.ini eg foo.exe /bar ^.fred, see
// comments below...
BOOL Reg_ShellOpenForExtension(LPCTSTR pszExt, LPTSTR pszCmdLine,
    int cchCmdLine, LPTSTR pszTypeName, int cchTypeName, LPCTSTR pszLine)
{
    TCHAR sz[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    DWORD cb;
    HRESULT hr;

    if (pszTypeName)
        pszTypeName[0] = 0;

    // Is the extension registed at all?
    cb = sizeof(sz);
    sz[0] = 0;
    if (SHRegGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, SRRF_RT_REG_SZ, NULL, sz, &cb) == ERROR_SUCCESS)
    {
        // Is there a file type?
        if (*sz)
        {
            // Yep, check there.
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension has a file type name %s.", sz);
            hr = StringCchCopy(szExt, ARRAYSIZE(szExt), sz);
            if (FAILED(hr))
            {
                return FALSE;
            }

            if (pszTypeName)
            {
                hr = StringCchCopy(pszTypeName, cchTypeName, sz);
                if (FAILED(hr))
                {
                    return FALSE;
                }
            }
        }
        else
        {
            // No, check old style associations.
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension has no file type name.", pszExt);
            hr = StringCchCopy(szExt, ARRAYSIZE(szExt), pszExt);
            if (FAILED(hr))
            {
                return FALSE;
            }
        }

        // See if there's an open command.
        hr = StringCchCat(szExt, ARRAYSIZE(szExt), TEXT("\\shell\\open\\command"));
        if (FAILED(hr))
        {
            return FALSE;
        }

        cb = sizeof(sz);
        if (SHRegGetValue(HKEY_CLASSES_ROOT, szExt, NULL, SRRF_RT_REG_SZ, NULL, sz, &cb) == ERROR_SUCCESS)
        {
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension %s already registed with an open command.", pszExt);
            // NB We want to compare the paths only, not the %1 stuff.
            if (PathIsRelative(pszCmdLine))
            {
                int cch;
                // If a relative path was passed in, we may have a fully qualifed
                // one that is now in the registry... In that case we should
                // say that it matches...
                LPTSTR pszT = PathGetArgs(sz);

                if (pszT)
                {
                    *(pszT-1) = 0;
                }

                PathUnquoteSpaces(sz);

                PathRemoveBlanks(pszCmdLine);

                cch = lstrlen(sz) - lstrlen(pszCmdLine);

                if ((cch >= 0) && (lstrcmpi(sz+cch, pszCmdLine) == 0))
                {
                    // DebugMsg(DM_TRACE, "c.r_rofe: Open commands match.");
                    return TRUE;
                }

                hr = StringCchCat(pszCmdLine, cchCmdLine, TEXT(" "));    // Append blank back on...
                if (FAILED(hr))
                {
                    return FALSE;
                }
            }
            else
            {
                // If absolute path we can cheat for matches
                *(sz+lstrlen(pszCmdLine)) = 0;
                if (lstrcmpi(sz, pszCmdLine) == 0)
                {
                    // DebugMsg(DM_TRACE, "c.r_rofe: Open commands match.");
                    return TRUE;
                }
            }

            // DebugMsg(DM_TRACE, "c.r_rofe: Open commands don't match.");

            // Open commands don't match, check to see if it's because the ini
            // changed (return FALSE so the change is reflected in the registry) or
            // if the registry changed (return TRUE so we keep the registry the way
            // it is.
            if (RegGetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, pszExt, sz, ARRAYSIZE(sz)))
            {
                if (lstrcmpi(sz, pszLine) == 0)
                    return TRUE;
            }

            return FALSE;
        }
        else
        {
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension %s already registed but with no open command.", pszExt);
            return FALSE;
        }
    }

    // DebugMsg(DM_TRACE, "c.r_rofe: No open command for %s.", pszExt);

    return FALSE;
}


// This function will read in the extensions section of win.ini to see if
// there are any old style associations that we have not accounted for.
// NB Some apps mess up if their extensions magically disappear from the
// extensions section so DON'T DELETE the old entries from win.ini.
//
// Since this is for win3.1 compat, CWIFA_SIZE should be enough (it has been so far...)
//
#define CWIFA_SIZE  4096

STDAPI_(void) CheckWinIniForAssocs(void)
{
    LPTSTR pszBuf;
    int cchRet;
    LPTSTR pszLine;
    TCHAR szExtension[MAX_PATH];
    TCHAR szTypeName[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
    LPTSTR pszExt;
    LPTSTR pszT;
    BOOL fAssocsMade = FALSE;
    HRESULT hr;

    szExtension[0]=TEXT('.');
    szExtension[1]=0;
        
    pszBuf = (LPTSTR)LocalAlloc(LPTR, CWIFA_SIZE*sizeof(TCHAR));
    if (!pszBuf)
        return; // Could not allocate the memory
    cchRet = (int)GetProfileSection(TEXT("Extensions"), pszBuf, CWIFA_SIZE);

    if (cchRet >= CWIFA_SIZE - 2)    // believe it or not, it truncates and returns n-2
    {
        goto Punt;
    }
        
    //
    // We now walk through the list to find any items that is not
    // in the registry.
    //
    for (pszLine = pszBuf; *pszLine; pszLine += lstrlen(pszLine)+1)
    {
                // Get the extension for this file into a buffer.
                pszExt = StrChr(pszLine, TEXT('='));
                if (pszExt == NULL)
                        continue;   // skip this line
                
                szExtension[0]=TEXT('.');
                // lstrcpyn will put the null terminator for us.
                // We should now have something like .xls in szExtension.
                hr = StringCchCopyN(szExtension+1, ARRAYSIZE(szExtension) - 1, pszLine, (int)(pszExt-pszLine));
                if (FAILED(hr))
                {
                        continue;
                }
                
                // Ignore extensions bigger than dot + 3 chars.
                if (lstrlen(szExtension) > 4)
                {
                        DebugMsg(DM_ERROR, TEXT("CheckWinIniForAssocs: Invalid extension, skipped."));
                        continue;
                }
                
                pszLine = pszExt+1;     // Points to after the =;
                while (*pszLine == TEXT(' '))
                        pszLine++;  // skip blanks
                
                // Now find the ^ in the command line.
                pszExt = StrChr(pszLine, TEXT('^'));
                if (pszExt == NULL)
                        continue;       // dont process
                
                // Now setup  the command line
                // WARNING: This assumes only 1 ^ and it assumes the extension...
                hr = StringCchCopyN(szCmdLine, ARRAYSIZE(szCmdLine), pszLine, (int)(pszExt-pszLine));
                if (FAILED(hr))
                {
                        continue;
                }
                // Don't bother moving over invalid entries (like the busted .hlp
                // entry VB 3.0 creates).
                if (!_PathIsExe(szCmdLine))
                {
                        DebugMsg(DM_ERROR, TEXT("c.cwia: Invalid app, skipped."));
                        continue;
                }
                
                if (ReservedExtension(szExtension))
                {
                        DebugMsg(DM_ERROR, TEXT("c.cwia: Invalid extension (%s), skipped."), szExtension);
                        continue;
                }
                
                // Now see if there is already a mapping for this extension.
                if (Reg_ShellOpenForExtension(szExtension, szCmdLine, ARRAYSIZE(szCmdLine), szTypeName, ARRAYSIZE(szTypeName), pszLine))
                {
                        // Yep, Setup the initial list of ini extensions in the registry if they are
                        // not there already.
                        if (!RegGetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, szExtension, szTypeName, sizeof(szTypeName)))
                        {
                                RegSetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, szExtension, pszLine);
                        }
                        continue;
                }
                
                // No mapping.
                
                // HACK for Expert Home Design. They put an association in win.ini
                // (which we propagate as typeless) but then register a type and a
                // print command the first time they run - stomping on our propagated
                // Open command. The fix is to put their open command under the proper
                // type instead of leaving it typeless.
                if (lstrcmpi(szExtension, TEXT(".dgw")) == 0)
                {
                        if (lstrcmpi(PathFindFileName(szCmdLine), TEXT("designw.exe ")) == 0)
                        {
                                // Put in a ProgID for them.
                                RegSetValue(HKEY_CLASSES_ROOT, szExtension, REG_SZ, TEXT("HDesign"), 0L);
                                // Force Open command under their ProgID.
                                TraceMsg(DM_TRACE, "c.cwifa: Expert Home Design special case hit.");
                                hr = StringCchCopy(szTypeName, ARRAYSIZE(szTypeName), TEXT("HDesign"));
                                if (FAILED(hr))
                                {
                                    continue;
                                }
                        }
                }
                
                //
                // HACK for Windows OrgChart which does not register OLE1 class
                // if ".WOC" is registered in the registry.
                //
                if (lstrcmpi(szExtension, TEXT(".WOC")) == 0)
                {
                        if (lstrcmpi(PathFindFileName(szCmdLine), TEXT("WINORG.EXE ")) == 0)
                        {
                                DebugMsg(DM_ERROR, TEXT("c.cwia: HACK: Found WINORG (%s, %s), skipped."), szExtension, pszLine);
                                continue;
                        }
                }
                
                // Record that we're about to move things over in the registry so we won't keep
                // doing it all the time.
                RegSetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, szExtension, pszLine);
                
                hr = StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%1"));
                if (FAILED(hr))
                {
                        continue;
                }
                
                // see if there are anything else to copy out...
                pszExt++;    // get beyond the ^
                pszT = szExtension;
                while (*pszExt && (CharLowerChar(*pszExt) == CharLowerChar(*pszT)))
                {
                        // Look for the next character...
                        pszExt++;
                        pszT++;
                }
                if (*pszExt)
                {
                        hr = StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), pszExt); // add the rest onto the command line
                        if (FAILED(hr))
                        {
                                continue;
                        }
                }
                
                // Now lets make the actual association.
                // We need to add on the right stuff onto the key...
                if (*szTypeName)
                {
                        hr = StringCchCopy(szExtension, ARRAYSIZE(szExtension), szTypeName);
                        if (FAILED(hr))
                        {
                                continue;
                        }
                }
                
        hr = StringCchCat(szExtension, ARRAYSIZE(szExtension), TEXT("\\shell\\open\\command"));
        if (SUCCEEDED(hr))
        {
            RegSetValue(HKEY_CLASSES_ROOT, szExtension, REG_SZ, szCmdLine, 0L);
            // DebugMsg(DM_TRACE, "c.cwifa: %s %s", szExtension, szCmdLine);
        }

        fAssocsMade = TRUE;
    }
        
    // If we made any associations we should let the cabinet know.
    //
    // Now call off to the notify function.
    if (fAssocsMade)
        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

Punt:
    // And cleanup our allocation
    LocalFree((HLOCAL)pszBuf);
}

typedef struct
{
    INT     iFlag;
    LPCTSTR pszKey;
    LPCTSTR pszValue;
} RESTRICTIONITEMS;

#define SZ_RESTRICTED_ACTIVEDESKTOP             L"ActiveDesktop"
#define REGSTR_VAL_RESTRICTRUNW                 L"RestrictRun"
#define REGSTR_VAL_PRINTERS_HIDETABSW           L"NoPrinterTabs"
#define REGSTR_VAL_PRINTERS_NODELETEW           L"NoDeletePrinter"
#define REGSTR_VAL_PRINTERS_NOADDW              L"NoAddPrinter"

const SHRESTRICTIONITEMS c_rgRestrictionItems[] =
{
    {REST_NORUN,                   L"Explorer", L"NoRun"},
    {REST_NOCLOSE,                 L"Explorer", L"NoClose"},
    {REST_NOSAVESET ,              L"Explorer", L"NoSaveSettings"},
    {REST_NOFILEMENU,              L"Explorer", L"NoFileMenu"},
    {REST_NOSETFOLDERS,            L"Explorer", L"NoSetFolders"},
    {REST_NOSETTASKBAR,            L"Explorer", L"NoSetTaskbar"},
    {REST_NODESKTOP,               L"Explorer", L"NoDesktop"},
    {REST_NOFIND,                  L"Explorer", L"NoFind"},
    {REST_NODRIVES,                L"Explorer", L"NoDrives"},
    {REST_NODRIVEAUTORUN,          L"Explorer", L"NoDriveAutoRun"},
    {REST_NODRIVETYPEAUTORUN,      L"Explorer", L"NoDriveTypeAutoRun"},
    {REST_NONETHOOD,               L"Explorer", L"NoNetHood"},
    {REST_STARTBANNER,             L"Explorer", L"NoStartBanner"},
    {REST_RESTRICTRUN,             L"Explorer", REGSTR_VAL_RESTRICTRUNW},
    {REST_NOPRINTERTABS,           L"Explorer", REGSTR_VAL_PRINTERS_HIDETABSW},
    {REST_NOPRINTERDELETE,         L"Explorer", REGSTR_VAL_PRINTERS_NODELETEW},
    {REST_NOPRINTERADD,            L"Explorer", REGSTR_VAL_PRINTERS_NOADDW},
    {REST_NOSTARTMENUSUBFOLDERS,   L"Explorer", L"NoStartMenuSubFolders"},
    {REST_MYDOCSONNET,             L"Explorer", L"MyDocsOnNet"},
    {REST_NOEXITTODOS,             L"WinOldApp", L"NoRealMode"},
    {REST_ENFORCESHELLEXTSECURITY, L"Explorer", L"EnforceShellExtensionSecurity"},
    {REST_NOCOMMONGROUPS,          L"Explorer", L"NoCommonGroups"},
    {REST_LINKRESOLVEIGNORELINKINFO,L"Explorer", L"LinkResolveIgnoreLinkInfo"},
    {REST_NOWEB,                   L"Explorer", L"NoWebMenu"},
    {REST_NOTRAYCONTEXTMENU,       L"Explorer", L"NoTrayContextMenu"},
    {REST_NOVIEWCONTEXTMENU,       L"Explorer", L"NoViewContextMenu"},
    {REST_NONETCONNECTDISCONNECT,  L"Explorer", L"NoNetConnectDisconnect"},
    {REST_STARTMENULOGOFF,         L"Explorer", L"StartMenuLogoff"},
    {REST_NOSETTINGSASSIST,        L"Explorer", L"NoSettingsWizards"},

    {REST_NODISCONNECT,           L"Explorer", L"NoDisconnect"},
    {REST_NOSECURITY,             L"Explorer", L"NoNTSecurity"  },
    {REST_NOFILEASSOCIATE,        L"Explorer", L"NoFileAssociate"  },

    // New for IE4
    {REST_NOINTERNETICON,          L"Explorer", L"NoInternetIcon"},
    {REST_NORECENTDOCSHISTORY,     L"Explorer", L"NoRecentDocsHistory"},
    {REST_NORECENTDOCSMENU,        L"Explorer", L"NoRecentDocsMenu"},
    {REST_NOACTIVEDESKTOP,         L"Explorer", L"NoActiveDesktop"},
    {REST_NOACTIVEDESKTOPCHANGES,  L"Explorer", L"NoActiveDesktopChanges"},
    {REST_NOFAVORITESMENU,         L"Explorer", L"NoFavoritesMenu"},
    {REST_CLEARRECENTDOCSONEXIT,   L"Explorer", L"ClearRecentDocsOnExit"},
    {REST_CLASSICSHELL,            L"Explorer", L"ClassicShell"},
    {REST_NOCUSTOMIZEWEBVIEW,      L"Explorer", L"NoCustomizeWebView"},
    {REST_NOHTMLWALLPAPER,         SZ_RESTRICTED_ACTIVEDESKTOP, L"NoHTMLWallPaper"},
    {REST_NOCHANGINGWALLPAPER,     SZ_RESTRICTED_ACTIVEDESKTOP, L"NoChangingWallPaper"},
    {REST_NODESKCOMP,              SZ_RESTRICTED_ACTIVEDESKTOP, L"NoComponents"},
    {REST_NOADDDESKCOMP,           SZ_RESTRICTED_ACTIVEDESKTOP, L"NoAddingComponents"},
    {REST_NODELDESKCOMP,           SZ_RESTRICTED_ACTIVEDESKTOP, L"NoDeletingComponents"},
    {REST_NOCLOSEDESKCOMP,         SZ_RESTRICTED_ACTIVEDESKTOP, L"NoClosingComponents"},
    {REST_NOCLOSE_DRAGDROPBAND,    L"Explorer", L"NoCloseDragDropBands"},
    {REST_NOMOVINGBAND,            L"Explorer", L"NoMovingBands"},
    {REST_NOEDITDESKCOMP,          SZ_RESTRICTED_ACTIVEDESKTOP, L"NoEditingComponents"},
    {REST_NORESOLVESEARCH,         L"Explorer", L"NoResolveSearch"},
    {REST_NORESOLVETRACK,          L"Explorer", L"NoResolveTrack"},
    {REST_FORCECOPYACLWITHFILE,    L"Explorer", L"ForceCopyACLWithFile"},
    {REST_NOLOGO3CHANNELNOTIFY,    L"Explorer", L"NoMSAppLogo5ChannelNotify"},
    {REST_NOFORGETSOFTWAREUPDATE,  L"Explorer", L"NoForgetSoftwareUpdate"},
    {REST_GREYMSIADS,              L"Explorer", L"GreyMSIAds"},

    // More start menu Restritions for 4.01
    {REST_NOSETACTIVEDESKTOP,      L"Explorer", L"NoSetActiveDesktop"},
    {REST_NOUPDATEWINDOWS,         L"Explorer", L"NoWindowsUpdate"},
    {REST_NOCHANGESTARMENU,        L"Explorer", L"NoChangeStartMenu"},
    {REST_NOFOLDEROPTIONS,         L"Explorer", L"NoFolderOptions"},
    {REST_NOCSC,                   L"Explorer", L"NoSyncAll"},

    // NT5 shell restrictions
    {REST_HASFINDCOMPUTERS,        L"Explorer", L"FindComputers"},
    {REST_RUNDLGMEMCHECKBOX,       L"Explorer", L"MemCheckBoxInRunDlg"},
    {REST_INTELLIMENUS,            L"Explorer", L"IntelliMenus"},
    {REST_SEPARATEDESKTOPPROCESS,  L"Explorer", L"SeparateProcess"}, // this one was actually checked in IE4 in shdocvw, but not here. Duh.
    {REST_MaxRecentDocs,           L"Explorer", L"MaxRecentDocs"},
    {REST_NOCONTROLPANEL,          L"Explorer", L"NoControlPanel"},     // Remove only the control panel from the Settings menu
    {REST_ENUMWORKGROUP,           L"Explorer", L"EnumWorkgroup"},
    {REST_ARP_ShowPostSetup,       L"Uninstall", L"ShowPostSetup"},
    {REST_ARP_NOARP,               L"Uninstall", L"NoAddRemovePrograms"},
    {REST_ARP_NOREMOVEPAGE,        L"Uninstall", L"NoRemovePage"},
    {REST_ARP_NOADDPAGE,           L"Uninstall", L"NoAddPage"},
    {REST_ARP_NOWINSETUPPAGE,      L"Uninstall", L"NoWindowsSetupPage"},
    {REST_NOCHANGEMAPPEDDRIVELABEL, L"Explorer", L"NoChangeMappedDriveLabel"},
    {REST_NOCHANGEMAPPEDDRIVECOMMENT, L"Explorer", L"NoChangeMappedDriveComment"},
    {REST_NONETWORKCONNECTIONS,    L"Explorer", L"NoNetworkConnections"},
    {REST_FORCESTARTMENULOGOFF,    L"Explorer", L"ForceStartMenuLogoff"},
    {REST_NOWEBVIEW,               L"Explorer", L"NoWebView"},
    {REST_NOCUSTOMIZETHISFOLDER,   L"Explorer", L"NoCustomizeThisFolder"},
    {REST_NOENCRYPTION,            L"Explorer", L"NoEncryption"},
    {REST_DONTSHOWSUPERHIDDEN,     L"Explorer", L"DontShowSuperHidden"},
    {REST_NOSHELLSEARCHBUTTON,     L"Explorer", L"NoShellSearchButton"},
    {REST_NOHARDWARETAB,           L"Explorer", L"NoHardwareTab"},
    {REST_NORUNASINSTALLPROMPT,    L"Explorer", L"NoRunasInstallPrompt"},
    {REST_PROMPTRUNASINSTALLNETPATH, L"Explorer", L"PromptRunasInstallNetPath"},
    {REST_NOMANAGEMYCOMPUTERVERB,  L"Explorer", L"NoManageMyComputerVerb"},
    {REST_NORECENTDOCSNETHOOD,     L"Explorer", L"NoRecentDocsNetHood"},
    {REST_DISALLOWRUN,             L"Explorer", L"DisallowRun"},
    {REST_NOWELCOMESCREEN,         L"Explorer", L"NoWelcomeScreen"},
    {REST_RESTRICTCPL,             L"Explorer", L"RestrictCpl"},
    {REST_DISALLOWCPL,             L"Explorer", L"DisallowCpl"},
    {REST_NOSMBALLOONTIP,          L"Explorer", L"NoSMBalloonTip"},
    {REST_NOSMHELP,                L"Explorer", L"NoSMHelp"},
    {REST_NOWINKEYS,               L"Explorer", L"NoWinKeys"},
    {REST_NOENCRYPTONMOVE,         L"Explorer", L"NoEncryptOnMove"},
    {REST_NOLOCALMACHINERUN,       L"Explorer", L"DisableLocalMachineRun"},
    {REST_NOCURRENTUSERRUN,        L"Explorer", L"DisableCurrentUserRun"},
    {REST_NOLOCALMACHINERUNONCE,   L"Explorer", L"DisableLocalMachineRunOnce"},
    {REST_NOCURRENTUSERRUNONCE,    L"Explorer", L"DisableCurrentUserRunOnce"},
    {REST_FORCEACTIVEDESKTOPON,    L"Explorer", L"ForceActiveDesktopOn"},
    {REST_NOCOMPUTERSNEARME,       L"Explorer", L"NoComputersNearMe"},
    {REST_NOVIEWONDRIVE,           L"Explorer", L"NoViewOnDrive"},

    // Millennium shell restrictions
    // Exception: REST_NOSMMYDOCS is also supported on NT5.

    {REST_NONETCRAWL,              L"Explorer", L"NoNetCrawling"},
    {REST_NOSHAREDDOCUMENTS,       L"Explorer", L"NoSharedDocuments"},
    {REST_NOSMMYDOCS,              L"Explorer", L"NoSMMyDocs"},
    {REST_NOSMMYPICS,              L"Explorer", L"NoSMMyPictures"},
    {REST_ALLOWBITBUCKDRIVES,      L"Explorer", L"RecycleBinDrives"},

    // These next few restrictions are mixed between Neptune and Millennium
    // (Isn't simultaneous development fun?)
    {REST_NONLEGACYSHELLMODE,     L"Explorer", L"NoneLegacyShellMode"},         // Neptune
    {REST_NOCONTROLPANELBARRICADE, L"Explorer", L"NoControlPanelBarricade"},    // Millennium

    {REST_NOAUTOTRAYNOTIFY,        L"Explorer", L"NoAutoTrayNotify"},   // traynot.h
    {REST_NOTASKGROUPING,          L"Explorer", L"NoTaskGrouping"},
    {REST_NOCDBURNING,             L"Explorer", L"NoCDBurning"},
    {REST_MYCOMPNOPROP,            L"Explorer", L"NoPropertiesMyComputer"},
    {REST_MYDOCSNOPROP,            L"Explorer", L"NoPropertiesMyDocuments"},

    {REST_NODISPLAYAPPEARANCEPAGE, L"System",   L"NoDispAppearancePage"},
    {REST_NOTHEMESTAB,             L"Explorer", L"NoThemesTab"},
    {REST_NOVISUALSTYLECHOICE,     L"System",   L"NoVisualStyleChoice"},
    {REST_NOSIZECHOICE,            L"System",   L"NoSizeChoice"},
    {REST_NOCOLORCHOICE,           L"System",   L"NoColorChoice"},
    {REST_SETVISUALSTYLE,          L"System",   L"SetVisualStyle"},

    {REST_STARTRUNNOHOMEPATH,      L"Explorer", L"StartRunNoHOMEPATH"},
    {REST_NOSTARTPANEL,            L"Explorer", L"NoSimpleStartMenu"},
    {REST_NOUSERNAMEINSTARTPANEL,  L"Explorer", L"NoUserNameInStartMenu"},
    {REST_NOMYCOMPUTERICON,        L"NonEnum",  L"{20D04FE0-3AEA-1069-A2D8-08002B30309D}"},
    {REST_NOSMNETWORKPLACES,       L"Explorer", L"NoStartMenuNetworkPlaces"},
    {REST_NOSMPINNEDLIST,          L"Explorer", L"NoStartMenuPinnedList"},
    {REST_NOSMMYMUSIC,             L"Explorer", L"NoStartMenuMyMusic"},
    {REST_NOSMEJECTPC,             L"Explorer", L"NoStartMenuEjectPC"},
    {REST_NOSMMOREPROGRAMS,        L"Explorer", L"NoStartMenuMorePrograms"},
    {REST_NOSMMFUPROGRAMS,         L"Explorer", L"NoStartMenuMFUprogramsList"},

    {REST_HIDECLOCK,               L"Explorer", L"HideClock"},
    {REST_NOLOWDISKSPACECHECKS,    L"Explorer", L"NoLowDiskSpaceChecks"},
    {REST_NODESKTOPCLEANUP,        L"Explorer", L"NoDesktopCleanupWizard"},

    // NT6 shell restrictions (Whistler)
    {REST_NOENTIRENETWORK,         L"Network",  L"NoEntireNetwork"}, // Note WNet stores it's policy in "Network".

    {REST_BITBUCKNUKEONDELETE,     L"Explorer", L"NoRecycleFiles"},
    {REST_BITBUCKCONFIRMDELETE,    L"Explorer", L"ConfirmFileDelete"},
    {REST_BITBUCKNOPROP,           L"Explorer", L"NoPropertiesRecycleBin"},
    {REST_NOTRAYITEMSDISPLAY,      L"Explorer", L"NoTrayItemsDisplay"}, // traynot.h
    {REST_NOTOOLBARSONTASKBAR,     L"Explorer", L"NoToolbarsOnTaskbar"},

    {REST_NODISPBACKGROUND,        L"System",   L"NoDispBackgroundPage"},
    {REST_NODISPSCREENSAVEPG,      L"System",   L"NoDispScrSavPage"},
    {REST_NODISPSETTINGSPG,        L"System",   L"NoDispSettingsPage"},
    {REST_NODISPSCREENSAVEPREVIEW, L"System",   L"NoScreenSavePreview"},    // Do not show screen saver previews
    {REST_NODISPLAYCPL,            L"System",   L"NoDispCPL"},              // Do not show the Display Control Panel at all.
    {REST_HIDERUNASVERB,           L"Explorer", L"HideRunAsVerb"},
    {REST_NOTHUMBNAILCACHE,        L"Explorer", L"NoThumbnailCache"},       // Do not use a thumbnail cache
    {REST_NOSTRCMPLOGICAL,         L"Explorer", L"NoStrCmpLogical"},        // Do not use a logical sorting in the namespace

    {REST_NOSMCONFIGUREPROGRAMS,   L"Explorer", L"NoSMConfigurePrograms"},  // Windows 2000 SP3 shell restriction

    {REST_NOPUBLISHWIZARD,         L"Explorer", L"NoPublishingWizard"}, 
    {REST_NOONLINEPRINTSWIZARD,    L"Explorer", L"NoOnlinePrintsWizard"},
    {REST_NOWEBSERVICES,           L"Explorer", L"NoWebServices"},

    {REST_ALLOWUNHASHEDWEBVIEW,    L"Explorer", L"AllowUnhashedWebView"},
    {REST_ALLOWLEGACYWEBVIEW,      L"Explorer", L"AllowLegacyWebView"},
    {REST_REVERTWEBVIEWSECURITY,   L"Explorer", L"RevertWebViewSecurity"},

    {REST_INHERITCONSOLEHANDLES,   L"Explorer", L"InheritConsoleHandles"},


    {0, NULL, NULL},
};

DWORD g_rgRestrictionItemValues[ARRAYSIZE(c_rgRestrictionItems) - 1 ] = { 0 };

EXTERN_C HANDLE g_hRestrictions = NULL;
LONG g_lProcessRestrictionsCount = -1; //  current process's count

HANDLE _GetRestrictionsCounter()
{
    return SHGetCachedGlobalCounter(&g_hRestrictions, &GUID_Restrictions);
}

BOOL _QueryRestrictionsChanged(void)
{
    long lGlobalCount = SHGlobalCounterGetValue(_GetRestrictionsCounter());
    if (g_lProcessRestrictionsCount != lGlobalCount)
    {
        g_lProcessRestrictionsCount = lGlobalCount;
        return TRUE;
    }
    return FALSE;
}


// Returns DWORD vaolue if any of the specified restrictions are in place.
// 0 otherwise.

STDAPI_(DWORD) SHRestricted(RESTRICTIONS rest)
{
    // The cache may be invalid. Check first! We have to use
    // a global named semaphore in case this function is called
    // from a process other than the shell process. (And we're
    // sharing the same count between shell32 and shdocvw.)
    if (_QueryRestrictionsChanged())
    {
        memset(g_rgRestrictionItemValues, (BYTE)-1, sizeof(g_rgRestrictionItemValues));
    }

    return SHRestrictionLookup(rest, NULL, c_rgRestrictionItems, g_rgRestrictionItemValues);
}

STDAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest)
{
    if (SHRestricted(rest))
    {
        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
            MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
        return TRUE;
    }
    return FALSE;
}


BOOL UpdateScreenSaver(BOOL bActive, LPCTSTR pszNewSSName, int iNewSSTimeout)
{
    BOOL bUpdatedSS = FALSE;
    BOOL bCurrentActive;
    TCHAR szCurrentSSPath[MAX_PATH];
    int iCurrentSSTimeout;
    HKEY hk;

    // check the screen saver path

    // first find out what the users screensaver path is set to
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk) == ERROR_SUCCESS)
    {
        if (ERROR_SUCCESS == SHRegGetString(hk, NULL, TEXT("SCRNSAVE.EXE"), szCurrentSSPath, ARRAYSIZE(szCurrentSSPath)))
        {
            // if we have a new name, then we might need to override the users current value
            if (pszNewSSName)
            {
                BOOL bTestExpandedPath;
                TCHAR szExpandedSSPath[MAX_PATH];

                // even though SCRNSAVE.EXE is of type REG_SZ, it can contain env variables (sigh)
                bTestExpandedPath = SHExpandEnvironmentStrings(szCurrentSSPath, szExpandedSSPath, ARRAYSIZE(szExpandedSSPath));

                // see if the new string matches the current
                if ((lstrcmpi(pszNewSSName, szCurrentSSPath) != 0)  &&
                    (!bTestExpandedPath || (lstrcmpi(pszNewSSName, szExpandedSSPath) != 0)))
                {
                    // new screensaver string is different from the old, so update the users value w/ the policy setting
                    if (RegSetValueEx(hk,
                                      TEXT("SCRNSAVE.EXE"),
                                      0,
                                      REG_SZ,
                                      (LPBYTE)pszNewSSName,
                                      (lstrlen(pszNewSSName) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                    {
                        bUpdatedSS = TRUE;
                    }
                }
            }
            else
            {
                // we do not have a screensaver set via policy. if the user does not have one set, then
                // there is going to be nothing to run! In this case, don't ever activate it
                if ((szCurrentSSPath[0] == TEXT('\0'))              ||    
                    (lstrcmpi(szCurrentSSPath, TEXT("\"\"")) == 0)  ||
                    (lstrcmpi(szCurrentSSPath, TEXT("none")) == 0)  ||
                    (lstrcmpi(szCurrentSSPath, TEXT("(none)")) == 0))
                {
                    // policy does not specify a screensaver and the user doesn't have one, so do
                    // not make the screensaver active.
                    bActive = FALSE;
                }
            }
        }
        else
        {
            // user did not have a screensaver registry value
            if (pszNewSSName)
            {
                // update the users value w/ the policy setting
                if (RegSetValueEx(hk,
                                  TEXT("SCRNSAVE.EXE"),
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszNewSSName,
                                  (lstrlen(pszNewSSName) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                {
                    bUpdatedSS = TRUE;
                }
                else
                {
                    // if we failed to set the screensaver then do not make it active
                    bActive = FALSE;
                }
            }
            else
            {
                // policy does not specify a screensaver and the user doesn't have one, so do
                // not make the screensaver active.
                bActive = FALSE;
            }
        }

        RegCloseKey(hk);
    }

    // check the timeout value
    if (iNewSSTimeout && SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, (void*)&iCurrentSSTimeout, 0))
    {
        if (iNewSSTimeout != iCurrentSSTimeout)
        {
            if (SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, iNewSSTimeout, NULL, SPIF_UPDATEINIFILE))
            {
                bUpdatedSS = TRUE;
            }
        }
    }

    // check to see if we need to change our active status
    if (SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, (void*)&bCurrentActive, 0) && 
        (bActive != bCurrentActive))
    {
        if (SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bActive, NULL, SPIF_UPDATEINIFILE))
        {
            bUpdatedSS = TRUE;
        }
    }

    return bUpdatedSS;
}


// Called by Explorer.exe when things change so that we can zero our global
// data on ini changed status. Wparam and lparam are from a WM_SETTINGSCHANGED/WM_WININICHANGE
// message.

STDAPI_(void) SHSettingsChanged(WPARAM wParam, LPARAM lParam)
{
    BOOL bPolicyChanged = FALSE;

    if (lstrcmpi(TEXT("Policy"), (LPCTSTR)lParam) == 0)
    {
        bPolicyChanged = TRUE;
    }

    if (!lParam ||
        bPolicyChanged ||
        lstrcmpi(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"), (LPCTSTR)lParam) == 0)
    {
        SHGlobalCounterIncrement(_GetRestrictionsCounter());
    }
}

void SHRegCloseKeys(HKEY ahkeys[], UINT ckeys)
{
    UINT ikeys;
    for (ikeys = 0; ikeys < ckeys; ikeys++)
    {
        if (ahkeys[ikeys])
        {
            RegCloseKey(ahkeys[ikeys]);
            ahkeys[ikeys] = NULL;
        }
    }
}

STDAPI_(BOOL) SHWinHelp(HWND hwndMain, LPCTSTR lpszHelp, UINT usCommand, ULONG_PTR ulData)
{
    // Try to show help
    if (!WinHelp(hwndMain, lpszHelp, usCommand, ulData))
    {
        // Problem.
        ShellMessageBox(HINST_THISDLL, hwndMain,
                MAKEINTRESOURCE(IDS_WINHELPERROR),
                MAKEINTRESOURCE(IDS_WINHELPTITLE),
                MB_ICONHAND | MB_OK);
        return FALSE;
    }
    return TRUE;
}

STDAPI StringToStrRet(LPCTSTR pszName, LPSTRRET pStrRet)
{
    pStrRet->uType = STRRET_WSTR;
    return SHStrDup(pszName, &pStrRet->pOleStr);
}

STDAPI ResToStrRet(UINT id, STRRET *pStrRet)
{
    TCHAR szTemp[MAX_PATH];

    pStrRet->uType = STRRET_WSTR;
    LoadString(HINST_THISDLL, id, szTemp, ARRAYSIZE(szTemp));
    return SHStrDup(szTemp, &pStrRet->pOleStr);
}

UINT g_uCodePage = 0;

LPCTSTR SkipLeadingSlashes(LPCTSTR pszURL)
{
    LPCTSTR pszURLStart;

    ASSERT(IS_VALID_STRING_PTR(pszURL, -1));

    pszURLStart = pszURL;

    // Skip two leading slashes.

    if (pszURL[0] == TEXT('/') && pszURL[1] == TEXT('/'))
        pszURLStart += 2;

    ASSERT(IS_VALID_STRING_PTR(pszURL, -1) &&
           IsStringContained(pszURL, pszURLStart));

    return pszURLStart;
}


#undef PropVariantClear

STDAPI PropVariantClearLazy(PROPVARIANT *pvar)
{
    switch(pvar->vt)
    {
    case VT_I4:
    case VT_UI4:
    case VT_EMPTY:
    case VT_FILETIME:
        // No operation
        break;

    // SHAlloc matches the CoTaskMemFree functions and will init OLE if it must be
    // loaded.
    case VT_LPSTR:
        SHFree(pvar->pszVal);
        break;
    case VT_LPWSTR:
        SHFree(pvar->pwszVal);
        break;

    default:
        return PropVariantClear(pvar);  // real version in OLE32
    }
    return S_OK;

}


// Return S_OK if all of the items are HTML or CDF references.
//     Otherwise, return S_FALSE.

HRESULT IsDeskCompHDrop(IDataObject * pido)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    // asking for CF_HDROP
    HRESULT hr = pido->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        HDROP hDrop = (HDROP)medium.hGlobal;
        DRAGINFO di;

        di.uSize = sizeof(di);
        if (DragQueryInfo(hDrop, &di))  // di.lpFileList will be in TCHAR format -- see DragQueryInfo impl
        {
            if (di.lpFileList)
            {
                LPTSTR pszCurrPath = di.lpFileList;

                while (pszCurrPath && pszCurrPath[0])
                {
                    // Is this file not acceptable to create a Desktop Component?
                    if (!PathIsContentType(pszCurrPath, SZ_CONTENTTYPE_HTML) &&
                        !PathIsContentType(pszCurrPath, SZ_CONTENTTYPE_CDF))
                    {
                        // Yes, I don't recognize this file as being acceptable.
                        hr = S_FALSE;
                        break;
                    }
                    pszCurrPath += lstrlen(pszCurrPath) + 1;
                }

                SHFree(di.lpFileList);
            }
        }
        else
        {
            // NOTE: Win95/NT4 dont have this fix, you will fault if you hit this case!
            AssertMsg(FALSE, TEXT("hDrop contains the opposite TCHAR (UNICODE when on ANSI)"));
        }
        ReleaseStgMedium(&medium);
    }

    return hr;
}

HRESULT _LocalAddDTI(LPCSTR pszUrl, HWND hwnd, int x, int y, int nType)
{
    IActiveDesktop * pad;
    HRESULT hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pad));
    if (SUCCEEDED(hr))
    {
        COMPONENT comp = {
            sizeof(COMPONENT),              //Size of this structure
            0,                              //For Internal Use: Set it always to zero.
            nType,              //One of COMP_TYPE_*
            TRUE,           // Is this component enabled?
            FALSE,             // Had the component been modified and not yet saved to disk?
            FALSE,          // Is the component scrollable?
            {
                sizeof(COMPPOS),             //Size of this structure
                x - GetSystemMetrics(SM_XVIRTUALSCREEN),    //Left of top-left corner in screen co-ordinates.
                y - GetSystemMetrics(SM_YVIRTUALSCREEN),    //Top of top-left corner in screen co-ordinates.
                -1,            // Width in pixels.
                -1,           // Height in pixels.
                10000,            // Indicates the Z-order of the component.
                TRUE,         // Is the component resizeable?
                TRUE,        // Resizeable in X-direction?
                TRUE,        // Resizeable in Y-direction?
                -1,    //Left of top-left corner as percent of screen width
                -1     //Top of top-left corner as percent of screen height
            },              // Width, height etc.,
            L"\0",          // Friendly name of component.
            L"\0",          // URL of the component.
            L"\0",          // Subscrined URL.
            IS_NORMAL       // ItemState
        };
        SHAnsiToUnicodeCP(CP_UTF8, pszUrl, comp.wszSource, ARRAYSIZE(comp.wszSource));
        SHAnsiToUnicodeCP(CP_UTF8, pszUrl, comp.wszFriendlyName, ARRAYSIZE(comp.wszFriendlyName));
        SHAnsiToUnicodeCP(CP_UTF8, pszUrl, comp.wszSubscribedURL, ARRAYSIZE(comp.wszSubscribedURL));

        hr = pad->AddDesktopItemWithUI(hwnd, &comp, DTI_ADDUI_DISPSUBWIZARD);
        pad->Release();
    }
    return hr;
}

// Create Desktop Components for each item.

HRESULT ExecuteDeskCompHDrop(LPTSTR pszMultipleUrls, HWND hwnd, int x, int y)
{
    IActiveDesktop * pad;
    HRESULT hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pad));
    if (SUCCEEDED(hr))
    {
        COMPONENT comp = {
            sizeof(COMPONENT),              //Size of this structure
            0,                              //For Internal Use: Set it always to zero.
            COMP_TYPE_WEBSITE,              //One of COMP_TYPE_*
            TRUE,           // Is this component enabled?
            FALSE,             // Had the component been modified and not yet saved to disk?
            FALSE,          // Is the component scrollable?
            {
                sizeof(COMPPOS),             //Size of this structure
                x - GetSystemMetrics(SM_XVIRTUALSCREEN),    //Left of top-left corner in screen co-ordinates.
                y - GetSystemMetrics(SM_YVIRTUALSCREEN),    //Top of top-left corner in screen co-ordinates.
                -1,            // Width in pixels.
                -1,           // Height in pixels.
                10000,            // Indicates the Z-order of the component.
                TRUE,         // Is the component resizeable?
                TRUE,        // Resizeable in X-direction?
                TRUE,        // Resizeable in Y-direction?
                -1,    //Left of top-left corner as percent of screen width
                -1     //Top of top-left corner as percent of screen height
            },              // Width, height etc.,
            L"\0",          // Friendly name of component.
            L"\0",          // URL of the component.
            L"\0",          // Subscrined URL.
            IS_NORMAL       // ItemState
        };
        while (pszMultipleUrls[0])
        {
            SHTCharToUnicode(pszMultipleUrls, comp.wszSource, ARRAYSIZE(comp.wszSource));
            SHTCharToUnicode(pszMultipleUrls, comp.wszFriendlyName, ARRAYSIZE(comp.wszFriendlyName));
            SHTCharToUnicode(pszMultipleUrls, comp.wszSubscribedURL, ARRAYSIZE(comp.wszSubscribedURL));

            hr = pad->AddDesktopItemWithUI(hwnd, &comp, DTI_ADDUI_DISPSUBWIZARD);
            pszMultipleUrls += lstrlen(pszMultipleUrls) + 1;
        }

        pad->Release();
    }

    return hr;
}

typedef struct {
    LPSTR pszUrl;
    LPTSTR pszMultipleUrls;
    BOOL fMultiString;
    HWND hwnd;
    DWORD dwFlags;
    int x;
    int y;
} CREATEDESKCOMP;


// Create Desktop Components for one or mowe items.  We need to start
//    a thread to do this because it may take a while and we don't want
//    to block the UI thread because dialogs may be displayed.

DWORD CALLBACK _CreateDeskComp_ThreadProc(void *pvCreateDeskComp)
{
    CREATEDESKCOMP * pcdc = (CREATEDESKCOMP *) pvCreateDeskComp;

    HRESULT hr = OleInitialize(0);
    if (EVAL(SUCCEEDED(hr)))
    {
        if (pcdc->fMultiString)
        {
            hr = ExecuteDeskCompHDrop(pcdc->pszMultipleUrls, pcdc->hwnd, pcdc->x, pcdc->y);
            SHFree(pcdc->pszMultipleUrls);
        }
        else if (pcdc->dwFlags & DESKCOMP_URL)
        {
            hr = _LocalAddDTI(pcdc->pszUrl, pcdc->hwnd, pcdc->x, pcdc->y, COMP_TYPE_WEBSITE);
            Str_SetPtrA(&(pcdc->pszUrl), NULL);
        }
        else if (pcdc->dwFlags & DESKCOMP_IMAGE)
        {
            hr = _LocalAddDTI(pcdc->pszUrl, pcdc->hwnd, pcdc->x, pcdc->y, COMP_TYPE_PICTURE);
        }
        OleUninitialize();
    }

    LocalFree(pcdc);
    return 0;
}


/*********************************************************************\
        Create Desktop Components for one or mowe items.  We need to start
    a thread to do this because it may take a while and we don't want
    to block the UI thread because dialogs may be displayed.
\*********************************************************************/
HRESULT CreateDesktopComponents(LPCSTR pszUrl, IDataObject* pido, HWND hwnd, DWORD dwFlags, int x, int y)
{
    CREATEDESKCOMP *pcdc;
    HRESULT hr = SHLocalAlloc(sizeof(CREATEDESKCOMP), &pcdc);
    // Create Thread....
    if (SUCCEEDED(hr))
    {
        pcdc->pszUrl = NULL; // In case of failure.
        pcdc->pszMultipleUrls = NULL; // In case of failure.
        pcdc->fMultiString = (pido ? TRUE : FALSE);
        pcdc->hwnd = hwnd;
        pcdc->dwFlags = dwFlags;
        pcdc->x = x;
        pcdc->y = y;

        if (!pcdc->fMultiString)
        {
            Str_SetPtrA(&(pcdc->pszUrl), pszUrl);
        }
        else
        {
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;

            // asking for CF_HDROP
            hr = pido->GetData(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                HDROP hDrop = (HDROP)medium.hGlobal;
                DRAGINFO di;

                di.uSize = sizeof(di);
                if (DragQueryInfo(hDrop, &di))
                {
                    // di.lpFileList will be in TCHAR format -- see DragQueryInfo impl
                    pcdc->pszMultipleUrls = di.lpFileList;
                }
                else
                {
                    // NOTE: Win95/NT4 dont have this fix, you will fault if you hit this case!
                    AssertMsg(FALSE, TEXT("hDrop contains the opposite TCHAR (UNICODE when on ANSI)"));
                }
                ReleaseStgMedium(&medium);
            }
        }

        if (pcdc->pszUrl || pcdc->pszMultipleUrls)
        {
            if (SHCreateThread(_CreateDeskComp_ThreadProc, pcdc, CTF_INSIST | CTF_PROCESS_REF, NULL))
            {
                hr = S_OK;
            }
            else
            {
                hr = ResultFromLastError();
                LocalFree(pcdc);        
            }
        }
        else
        {
            hr = E_FAIL;
            LocalFree(pcdc);
        }
    }

    return hr;
}


// This is exported, as ordinal 184.  It was in shell32\smrttile.c, but no-one was using it
// internally, and it does not appear that anyone external is using it (verified that taskman
// on NT and W95 uses the win32 api's CascadeWindows and TileWindows.  This could probably be
// removed altogether.                                                    (t-saml, 12/97)
STDAPI_(WORD) ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND *ahwnd)
{
    ASSERT(0);
    return 0;
}

/*
    GetFileDescription retrieves the friendly name from a file's verion rsource.
    The first language we try will be the first item in the
    "\VarFileInfo\Translations" section;  if there's nothing there,
    we try the one coded into the IDS_VN_FILEVERSIONKEY resource string.
    If we can't even load that, we just use English (040904E4).  We
    also try English with a null codepage (04090000) since many apps
    were stamped according to an old spec which specified this as
    the required language instead of 040904E4.

    If there is no FileDescription in version resource, return the file name.

    Parameters:
        LPCTSTR pszPath: full path of the file
        LPTSTR pszDesc: pointer to the buffer to receive friendly name. If NULL,
                        *pcchDesc will be set to the length of friendly name in
                        characters, including ending NULL, on successful return.
        UINT *pcchDesc: length of the buffer in characters. On successful return,
                        it contains number of characters copied to the buffer,
                        including ending NULL.

    Return:
        TRUE on success, and FALSE otherwise
*/
STDAPI_(BOOL) GetFileDescription(LPCTSTR pszPath, LPTSTR pszDesc, UINT *pcchDesc)
{
    TCHAR szVersionKey[60];         /* big enough for anything we need */
    LPTSTR pszVersionKey = NULL;

    // Try same language as this program
    if (LoadString(HINST_THISDLL, IDS_VN_FILEVERSIONKEY, szVersionKey, ARRAYSIZE(szVersionKey)))
    {
        HRESULT hr = StringCchCat(szVersionKey, SIZECHARS(szVersionKey), TEXT("FileDescription"));
        if (SUCCEEDED(hr))
        {
            pszVersionKey = szVersionKey;
        }
    }

    //  just use the default cut list
    return SHGetFileDescription(pszPath, pszVersionKey, NULL, pszDesc, pcchDesc);
}


STDAPI_(int) SHOutOfMemoryMessageBox(HWND hwnd, LPTSTR pszTitle, UINT fuStyle)
{
    return IDOK;
}

bool IsDiscardablePropertySet(const FMTID & fmtid)
{
    if (IsEqualGUID(fmtid, FMTID_DiscardableInformation))
        return true;

    return false;
}

bool IsDiscardableStream(LPCTSTR pszStreamName)
{
    static const LPCTSTR _apszDiscardableStreams[] =
    {
        // Mike Hillberg claims this stream is discardable, and is used to
        //  hold a few state bytes for property set information

        TEXT(":{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}:$DATA")
    };

    for (int i = 0; i < ARRAYSIZE(_apszDiscardableStreams); i++)
    {
        if (0 == lstrcmpi(_apszDiscardableStreams[i], pszStreamName))
            return TRUE;
    }

    return FALSE;
}

LPTSTR NTFSPropSetMsg(LPCWSTR pszSrcObject, LPTSTR pszUserMessage)
{
    // Now look for native property NTFS sets
    IPropertySetStorage *pPropSetStorage;
    if (SUCCEEDED(StgOpenStorageEx(pszSrcObject,
                                   STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE,
                                   STGFMT_FILE,
                                   0,0,0,
                                   IID_PPV_ARG(IPropertySetStorage, &pPropSetStorage))))
    {
        // Enum the property set storages available for this file

        IEnumSTATPROPSETSTG *pEnumSetStorage;
        if (SUCCEEDED(pPropSetStorage->Enum(&pEnumSetStorage)))
        {
            STATPROPSETSTG statPropSet[10];
            ULONG cSets;

            // Enum the property sets available in this property set storage

            while (SUCCEEDED(pEnumSetStorage->Next(ARRAYSIZE(statPropSet), statPropSet, &cSets)) && cSets > 0)
            {
                // For each property set we receive, open it and enumerate the
                // properties contained withing it

                for (ULONG iSet = 0; iSet < cSets; iSet++)
                {
                    if (FALSE == IsDiscardablePropertySet(statPropSet[iSet].fmtid))
                    {
                        TCHAR szText[MAX_PATH];
                        size_t cch = 0;

                        static const struct
                        {
                            const FMTID * m_pFMTID;
                            UINT          m_idTextID;
                        }
                        _aKnownPsets[] =
                        {
                            { &FMTID_SummaryInformation,          IDS_DOCSUMINFOSTREAM        },
                            { &FMTID_DocSummaryInformation,       IDS_SUMINFOSTREAM           },
                            { &FMTID_UserDefinedProperties,       IDS_USERDEFPROP             },
                            { &FMTID_ImageSummaryInformation,     IDS_IMAGEINFO               },
                            { &FMTID_AudioSummaryInformation,     IDS_AUDIOSUMINFO            },
                            { &FMTID_VideoSummaryInformation,     IDS_VIDEOSUMINFO            },
                            { &FMTID_MediaFileSummaryInformation, IDS_MEDIASUMINFO            }
                        };

                        // First try to map the fmtid to a better name than what the api gave us

                        for (int i = 0; i < ARRAYSIZE(_aKnownPsets); i++)
                        {
                            if (IsEqualGUID(*(_aKnownPsets[i].m_pFMTID), statPropSet[iSet].fmtid))
                            {
                                cch = LoadString(HINST_THISDLL, _aKnownPsets[i].m_idTextID, szText, ARRAYSIZE(szText));
                                break;
                            }
                        }

                        // No useful name... use Unidentied User Properties

                        if (0 == cch)
                            cch = LoadString(HINST_THISDLL,
                                                 IDS_UNKNOWNPROPSET,
                                                 szText, ARRAYSIZE(szText));

                        if (cch)
                        {
                            LPTSTR pszOldMessage = pszUserMessage;
                            UINT cchLen;

                            if (pszOldMessage)
                            {
                                cchLen = lstrlen(pszUserMessage) + cch + 3;

                                pszUserMessage = (TCHAR *) LocalReAlloc(pszOldMessage,
                                                                        cchLen * sizeof(TCHAR),
                                                                        LMEM_MOVEABLE);
                                if (pszUserMessage)
                                {
                                    StringCchCat(pszUserMessage, cchLen, TEXT("\r\n")); // ok to truncate
                                }
                            }
                            else
                            {
                                cchLen = cch + 1;
                                pszUserMessage = (TCHAR *) LocalAlloc(LPTR, cchLen * sizeof(TCHAR));
                            }

                            if (NULL == pszUserMessage)
                            {
                                pszUserMessage = pszOldMessage; // Can't grow it, but at least keep what we know so far
                            }
                            else
                            {
                                StringCchCat(pszUserMessage, cchLen, szText);   // ok to truncate
                            }
                        }
                    }
                }
            }
            pEnumSetStorage->Release();
        }
        pPropSetStorage->Release();
    }
    return pszUserMessage;
}

// GetDownlevelCopyDataLossText
//
// If data will be lost on a downlevel copy from NTFS to FAT, we return
// a string containing a description of the data that will be lost,
// suitable for display to the user.  String must be freed by the caller.
//
// If nothing will be lost, a NULL is returned.
//
// pbDirIsSafe points to a BOOL passed in by the caller.  On return, if
// *pbDirIsSafe has been set to TRUE, no further data loss could occur
// in this directory
//
// Davepl 01-Mar-98

#define NT_FAILED(x) NT_ERROR(x)   // More consistent name for this macro

LPWSTR GetDownlevelCopyDataLossText(LPCWSTR pszSrcObject, LPCWSTR pszDestDir, BOOL bIsADir, BOOL *pbDirIsSafe)
{
    OBJECT_ATTRIBUTES               SrcObjectAttributes;
    OBJECT_ATTRIBUTES               DestObjectAttributes;
    IO_STATUS_BLOCK                 IoStatusBlock;
    HANDLE SrcObjectHandle            = INVALID_HANDLE_VALUE;
    HANDLE DestPathHandle           = INVALID_HANDLE_VALUE;
    UNICODE_STRING                  UnicodeSrcObject;
    UNICODE_STRING                  UnicodeDestPath;
    NTSTATUS                        NtStatus;

    *pbDirIsSafe = FALSE;

    // pAttributeInfo will point to enough stack to hold the
    // FILE_FS_ATTRIBUTE_INFORMATION and worst-case filesystem name

    size_t cbAttributeInfo          = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) +
                                         MAX_PATH * sizeof(TCHAR);
    PFILE_FS_ATTRIBUTE_INFORMATION  pAttributeInfo =
                                      (PFILE_FS_ATTRIBUTE_INFORMATION) _alloca(cbAttributeInfo);

    // Covert the conventional paths to UnicodePath descriptors

    NtStatus = RtlInitUnicodeStringEx(&UnicodeSrcObject, pszSrcObject);
    if (NT_FAILED(NtStatus))
    {
        AssertMsg(FALSE, TEXT("RtlInitUnicodeStringEx failed for source."));
        return NULL;
    }

    if (!RtlDosPathNameToNtPathName_U(pszSrcObject, &UnicodeSrcObject, NULL, NULL))
    {
        AssertMsg(FALSE, TEXT("RtlDosPathNameToNtPathName_U failed for source."));
        return NULL;
    }

    NtStatus = RtlInitUnicodeStringEx(&UnicodeDestPath, pszDestDir);
    if (NT_FAILED(NtStatus))
    {
        AssertMsg(FALSE, TEXT("RtlInitUnicodeStringEx failed for dest."));
        return NULL;
    }

    if (!RtlDosPathNameToNtPathName_U(pszDestDir, &UnicodeDestPath, NULL, NULL))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        AssertMsg(FALSE, TEXT("RtlDosPathNameToNtPathName_U failed for dest."));
        return NULL;
    }

    // Build an NT object descriptor from the UnicodeSrcObject

    InitializeObjectAttributes(&SrcObjectAttributes,  &UnicodeSrcObject, OBJ_CASE_INSENSITIVE, NULL, NULL);
    InitializeObjectAttributes(&DestObjectAttributes, &UnicodeDestPath,  OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Open the file for generic read, and the dest path for attribute read

    NtStatus = NtOpenFile(&SrcObjectHandle, FILE_GENERIC_READ, &SrcObjectAttributes,
                          &IoStatusBlock, FILE_SHARE_READ, (bIsADir ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE));
    if (NT_FAILED(NtStatus))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDestPath.Buffer);
        return NULL;
    }

    NtStatus = NtOpenFile(&DestPathHandle, FILE_READ_ATTRIBUTES, &DestObjectAttributes,
                          &IoStatusBlock, FILE_SHARE_READ, FILE_DIRECTORY_FILE);
    if (NT_FAILED(NtStatus))
    {
        NtClose(SrcObjectHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDestPath.Buffer);
        return NULL;
    }

    // Incrementally try allocation sizes for the ObjectStreamInformation,
    // then retrieve the actual stream info

    BYTE * pBuffer = NULL;

    __try   // Current and future allocations and handles free'd by __finally block
    {
        size_t cbBuffer;
        LPTSTR pszUserMessage = NULL;

        // Quick check of filesystem type for this file

        NtStatus = NtQueryVolumeInformationFile(
                    SrcObjectHandle,
                    &IoStatusBlock,
                    (BYTE *) pAttributeInfo,
                    cbAttributeInfo,
                    FileFsAttributeInformation
                   );

        if (NT_FAILED(NtStatus))
            return NULL;

        // If the source filesystem isn't NTFS, we can just bail now

        pAttributeInfo->FileSystemName[
            (pAttributeInfo->FileSystemNameLength / sizeof(WCHAR)) ] = L'\0';

        if (0 == StrStrIW(pAttributeInfo->FileSystemName, L"NTFS"))
        {
            *pbDirIsSafe = TRUE;
            return NULL;
        }

        NtStatus = NtQueryVolumeInformationFile(
                    DestPathHandle,
                    &IoStatusBlock,
                    (BYTE *) pAttributeInfo,
                    cbAttributeInfo,
                    FileFsAttributeInformation
                   );

        if (NT_FAILED(NtStatus))
            return NULL;

        // If the target filesystem is NTFS, no stream loss will happen

        pAttributeInfo->FileSystemName[
            (pAttributeInfo->FileSystemNameLength / sizeof(WCHAR)) ] = L'\0';
        if (StrStrIW(pAttributeInfo->FileSystemName, L"NTFS"))
        {
            *pbDirIsSafe = TRUE;
            return NULL;
        }

        // At this point we know we're doing an NTFS->FAT copy, so we need
        // to find out whether or not the source file has multiple streams

        // pBuffer will point to enough memory to hold the worst case for
        // a single stream.

        cbBuffer = sizeof(FILE_STREAM_INFORMATION) + MAX_PATH * sizeof(WCHAR);
        if (NULL == (pBuffer = (BYTE *) LocalAlloc(LPTR, cbBuffer)))
            return NULL;
        do
        {
            BYTE * pOldBuffer = pBuffer;
            if (NULL == (pBuffer = (BYTE *) LocalReAlloc(pBuffer, cbBuffer, LMEM_MOVEABLE)))
            {
                LocalFree(pOldBuffer);
                return NULL;
            }

            NtStatus = NtQueryInformationFile(SrcObjectHandle, &IoStatusBlock, pBuffer, cbBuffer,
                                            FileStreamInformation);
            cbBuffer *= 2;
        } while (STATUS_BUFFER_OVERFLOW == NtStatus);

        if (NT_SUCCESS(NtStatus))
        {
            FILE_STREAM_INFORMATION * pStreamInfo = (FILE_STREAM_INFORMATION *) pBuffer;
            BOOL bLastPass = (0 == pStreamInfo->NextEntryOffset);

            if (bIsADir)
            {
                // From experimentation, it seems that if there's only one stream on a directory and
                // it has a zero-length name, its a vanilla directory

                if ((0 == pStreamInfo->NextEntryOffset) && (0 == pStreamInfo->StreamNameLength))
                    return NULL;
            }
            else // File
            {
                // Single stream only if first stream has no next offset

                if ((0 == pStreamInfo->NextEntryOffset) && (pBuffer == (BYTE *) pStreamInfo))
                    return NULL;
            }

            for(;;)
            {
                int i;
                TCHAR szText[MAX_PATH];

                // Table of known stream names and the string IDs that we actually want to show
                // to the user instead of the raw stream name.

                static const struct _ADATATYPES
                {
                    LPCTSTR m_pszStreamName;
                    UINT    m_idTextID;
                }
                _aDataTypes[] =
                {
                    { TEXT("::"),                               0                    },
                    { TEXT(":AFP_AfpInfo:"),                    IDS_MACINFOSTREAM    },
                    { TEXT(":AFP_Resource:"),                   IDS_MACRESSTREAM     }
                };

                if (FALSE == IsDiscardableStream(pStreamInfo->StreamName))
                {
                    for (i = 0; i < ARRAYSIZE(_aDataTypes); i++)
                    {

                        // Can't use string compare since they choke on the \005 character
                        // used in property storage streams
                        int cbComp = min(lstrlen(pStreamInfo->StreamName) * sizeof(TCHAR),
                                         lstrlen(_aDataTypes[i].m_pszStreamName) * sizeof(TCHAR));
                        if (0 == memcmp(_aDataTypes[i].m_pszStreamName,
                                        pStreamInfo->StreamName,
                                        cbComp))
                        {
                            break;
                        }
                    }

                    size_t cch = 0;
                    if (i == ARRAYSIZE(_aDataTypes))
                    {
                        // Not found, so use the actual stream name, unless it has a \005
                        // at the beginning of its name, in which case we'll pick this one
                        // up when we check for property sets.

                        if (pStreamInfo->StreamName[1] ==  TEXT('\005'))
                        {
                            cch = 0;
                        }
                        else
                        {
                            StringCchCopy(szText, ARRAYSIZE(szText), pStreamInfo->StreamName);  // ok to truncate
                            cch = lstrlen(szText);
                        }
                    }
                    else
                    {
                        // We found this stream in our table of well-known streams, so
                        // load the string which the user will see describing this stream,
                        // as we likely have a more useful name than the stream itself.

                        cch = _aDataTypes[i].m_idTextID ?
                                  LoadString(HINST_THISDLL, _aDataTypes[i].m_idTextID, szText, ARRAYSIZE(szText))
                                  : 0;
                    }

                    // Reallocate the overall buffer to be large enough to add this new
                    // stream description, plus 2 chars for the crlf

                    if (cch)
                    {
                        LPTSTR pszOldMessage = pszUserMessage;
                        UINT cchLen;
                        if (pszOldMessage)
                        {
                            cchLen = lstrlen(pszUserMessage) + cch + 3;

                            pszUserMessage = (TCHAR *) LocalReAlloc(pszOldMessage,
                                                                    cchLen * sizeof(TCHAR),
                                                                    LMEM_MOVEABLE);
                            if (pszUserMessage)
                            {
                                StringCchCat(pszUserMessage, cchLen, TEXT("\r\n")); // ok to truncate
                            }
                        }
                        else
                        {
                            cchLen = cch + 1;
                            pszUserMessage = (TCHAR *) LocalAlloc(LPTR, cchLen * sizeof(TCHAR));
                        }

                        if (NULL == pszUserMessage)
                            return pszOldMessage; // Can't grow it, but at least return what we know so far

                        StringCchCat(pszUserMessage, cchLen, szText);
                    }
                }

                if (bLastPass)
                    break;

                pStreamInfo = (FILE_STREAM_INFORMATION *) (((BYTE *) pStreamInfo) + pStreamInfo->NextEntryOffset);
                bLastPass = (0 == pStreamInfo->NextEntryOffset);
            }
        }

        pszUserMessage = NTFSPropSetMsg(pszSrcObject, pszUserMessage);

        return pszUserMessage;
    }
    __finally   // Cleanup
    {
        if (pBuffer)
            LocalFree(pBuffer);

        NtClose(SrcObjectHandle);
        NtClose(DestPathHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDestPath.Buffer);
    }

    return NULL;
}

// lstrcmp? uses thread lcid.  but in UI visual sorting, we need
// to use the user's choice. (thus the u in ustrcmp)
int _ustrcmp(LPCTSTR psz1, LPCTSTR psz2, BOOL fCaseInsensitive)
{
    COMPILETIME_ASSERT(CSTR_LESS_THAN == 1);
    COMPILETIME_ASSERT(CSTR_EQUAL  == 2);
    COMPILETIME_ASSERT(CSTR_GREATER_THAN  == 3);
    return (CompareString(LOCALE_USER_DEFAULT,
                         fCaseInsensitive ? NORM_IGNORECASE : 0,
                         psz1, -1, psz2, -1) - CSTR_EQUAL);
}

void HWNDWSPrintf(HWND hwnd, LPCTSTR psz)
{
    TCHAR szTemp[2048];
    TCHAR szTemp1[2048];

    GetWindowText(hwnd, szTemp, ARRAYSIZE(szTemp));
    StringCchPrintf(szTemp1, ARRAYSIZE(szTemp1), szTemp, psz);  // ok to truncate
    SetWindowText(hwnd, szTemp1);
}

STDAPI_(BOOL) Priv_Str_SetPtrW(WCHAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew)
{
    LPWSTR pwzOld;
    LPWSTR pwzNewCopy = NULL;

    if (pwzNew)
    {
        int cchLength = lstrlenW(pwzNew);

        // alloc a new buffer w/ room for the null terminator
        pwzNewCopy = (LPWSTR) LocalAlloc(LPTR, (cchLength + 1) * sizeof(WCHAR));

        if (!pwzNewCopy)
            return FALSE;

        HRESULT hr = StringCchCopyW(pwzNewCopy, cchLength + 1, pwzNew);
        if (FAILED(hr))
        {
            LocalFree(pwzNewCopy);
            return FALSE;
        }
    }

    pwzOld = (LPWSTR) InterlockedExchangePointer((void * *)ppwzCurrent, pwzNewCopy);

    if (pwzOld)
        LocalFree(pwzOld);

    return TRUE;
}

// combines pidlParent with part of pidl, upto pidlNext, example:
//
// in:
//      pidlParent      [c:] [windows]
//      pidl                           [system] [foo.txt]
//      pidlNext                              --^
//
// returns:
//                      [c:] [windows] [system]
//

STDAPI_(LPITEMIDLIST) ILCombineParentAndFirst(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNext)
{
    ULONG cbParent = ILGetSize(pidlParent);
    ULONG cbRest   = (ULONG)((ULONG_PTR)pidlNext - (ULONG_PTR)pidl);
    LPITEMIDLIST pidlNew = _ILCreate(cbParent + cbRest);
    if (pidlNew)
    {
        cbParent -= sizeof(pidlParent->mkid.cb);
        memcpy(pidlNew, pidlParent, cbParent);
        memcpy((BYTE *)pidlNew + cbParent, pidl, cbRest);
        ASSERT(_ILSkip(pidlNew, cbParent + cbRest)->mkid.cb == 0);
    }
    return pidlNew;
}


STDAPI_(LPTSTR) DumpPidl(LPCITEMIDLIST pidl)
{
#ifdef DEBUG
    static TCHAR szBuf[MAX_PATH];
    TCHAR szTmp[MAX_PATH];
    USHORT cb;
    LPTSTR pszT;

    szBuf[0] = 0;

    if (NULL == pidl)
    {
        StringCchCat(szBuf, ARRAYSIZE(szBuf), TEXT("Empty pidl"));  // ok to truncate
        return szBuf;
    }

    while (!ILIsEmpty(pidl))
    {
        cb = pidl->mkid.cb;
        StringCchPrintf(szTmp, ARRAYSIZE(szTmp), TEXT("cb:%x id:"), cb);    // ok to truncate
        StringCchCat(szBuf, ARRAYSIZE(szBuf), szTmp);

        switch (SIL_GetType(pidl) & SHID_TYPEMASK)
        {
        case SHID_ROOT:                pszT = TEXT("SHID_ROOT"); break;
        case SHID_ROOT_REGITEM:        pszT = TEXT("SHID_ROOT_REGITEM"); break;
        case SHID_COMPUTER:            pszT = TEXT("SHID_COMPUTER"); break;
        case SHID_COMPUTER_1:          pszT = TEXT("SHID_COMPUTER_1"); break;
        case SHID_COMPUTER_REMOVABLE:  pszT = TEXT("SHID_COMPUTER_REMOVABLE"); break;
        case SHID_COMPUTER_FIXED:      pszT = TEXT("SHID_COMPUTER_FIXED"); break;
        case SHID_COMPUTER_REMOTE:     pszT = TEXT("SHID_COMPUTER_REMOTE"); break;
        case SHID_COMPUTER_CDROM:      pszT = TEXT("SHID_COMPUTER_CDROM"); break;
        case SHID_COMPUTER_RAMDISK:    pszT = TEXT("SHID_COMPUTER_RAMDISK"); break;
        case SHID_COMPUTER_7:          pszT = TEXT("SHID_COMPUTER_7"); break;
        case SHID_COMPUTER_DRIVE525:   pszT = TEXT("SHID_COMPUTER_DRIVE525"); break;
        case SHID_COMPUTER_DRIVE35:    pszT = TEXT("SHID_COMPUTER_DRIVE35"); break;
        case SHID_COMPUTER_NETDRIVE:   pszT = TEXT("SHID_COMPUTER_NETDRIVE"); break;
        case SHID_COMPUTER_NETUNAVAIL: pszT = TEXT("SHID_COMPUTER_NETUNAVAIL"); break;
        case SHID_COMPUTER_C:          pszT = TEXT("SHID_COMPUTER_C"); break;
        case SHID_COMPUTER_D:          pszT = TEXT("SHID_COMPUTER_D"); break;
        case SHID_COMPUTER_REGITEM:    pszT = TEXT("SHID_COMPUTER_REGITEM"); break;
        case SHID_COMPUTER_MISC:       pszT = TEXT("SHID_COMPUTER_MISC"); break;
        case SHID_FS:                  pszT = TEXT("SHID_FS"); break;
        case SHID_FS_TYPEMASK:         pszT = TEXT("SHID_FS_TYPEMASK"); break;
        case SHID_FS_DIRECTORY:        pszT = TEXT("SHID_FS_DIRECTORY"); break;
        case SHID_FS_FILE:             pszT = TEXT("SHID_FS_FILE"); break;
        case SHID_FS_UNICODE:          pszT = TEXT("SHID_FS_UNICODE"); break;
        case SHID_FS_DIRUNICODE:       pszT = TEXT("SHID_FS_DIRUNICODE"); break;
        case SHID_FS_FILEUNICODE:      pszT = TEXT("SHID_FS_FILEUNICODE"); break;
        case SHID_NET:                 pszT = TEXT("SHID_NET"); break;
        case SHID_NET_DOMAIN:          pszT = TEXT("SHID_NET_DOMAIN"); break;
        case SHID_NET_SERVER:          pszT = TEXT("SHID_NET_SERVER"); break;
        case SHID_NET_SHARE:           pszT = TEXT("SHID_NET_SHARE"); break;
        case SHID_NET_FILE:            pszT = TEXT("SHID_NET_FILE"); break;
        case SHID_NET_GROUP:           pszT = TEXT("SHID_NET_GROUP"); break;
        case SHID_NET_NETWORK:         pszT = TEXT("SHID_NET_NETWORK"); break;
        case SHID_NET_RESTOFNET:       pszT = TEXT("SHID_NET_RESTOFNET"); break;
        case SHID_NET_SHAREADMIN:      pszT = TEXT("SHID_NET_SHAREADMIN"); break;
        case SHID_NET_DIRECTORY:       pszT = TEXT("SHID_NET_DIRECTORY"); break;
        case SHID_NET_TREE:            pszT = TEXT("SHID_NET_TREE"); break;
        case SHID_NET_REGITEM:         pszT = TEXT("SHID_NET_REGITEM"); break;
        case SHID_NET_PRINTER:         pszT = TEXT("SHID_NET_PRINTER"); break;
        default:                       pszT = TEXT("unknown"); break;
        }
        StringCchCat(szBuf, ARRAYSIZE(szBuf), pszT);    // ok to truncate

        if (SIL_GetType(pidl) & SHID_JUNCTION)
        {
            StringCchCat(szBuf, ARRAYSIZE(szBuf), TEXT(", junction"));
        }

        pidl = _ILNext(pidl);

        if (!ILIsEmpty(pidl))
        {
            StringCchCat(szBuf, ARRAYSIZE(szBuf), TEXT("; "));
        }
    }

    return szBuf;
#else
    return TEXT("");
#endif // DEBUG
}

STDAPI SaveShortcutInFolder(int csidl, LPTSTR pszName, IShellLink *psl)
{
    TCHAR szPath[MAX_PATH];

    HRESULT hr = SHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE, NULL, 0, szPath);
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;

        hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            if (PathAppend(szPath, pszName))
            {
                WCHAR wszPath[MAX_PATH];
                SHTCharToUnicode(szPath, wszPath, ARRAYSIZE(wszPath));

                hr = ppf->Save(wszPath, TRUE);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
            }
            ppf->Release();
        }
    }
    return hr;
}


// TrackPopupMenu does not work, if the hwnd does not have
// the input focus. We believe this is a bug in USER

STDAPI_(BOOL) SHTrackPopupMenu(HMENU hmenu, UINT wFlags, int x, int y,
                                 int wReserved, HWND hwndOwner, LPCRECT lprc)
{
    int iRet = FALSE;
    DWORD dwExStyle = 0L;
    if (IS_WINDOW_RTL_MIRRORED(hwndOwner))
    {
        dwExStyle |= RTL_MIRRORED_WINDOW;
    }
    HWND hwndDummy = CreateWindowEx(dwExStyle, TEXT("Static"), NULL,
                           0, x, y, 1, 1, HWND_DESKTOP,
                           NULL, HINST_THISDLL, NULL);
    if (hwndDummy)
    {
        HWND hwndPrev = GetForegroundWindow();  // to restore

        SetForegroundWindow(hwndDummy);
        SetFocus(hwndDummy);
        iRet = TrackPopupMenu(hmenu, wFlags, x, y, wReserved, hwndDummy, lprc);

        //
        // We MUST unlock the destination window before changing its Z-order.
        //
        DAD_DragLeave();

        if (iRet && hwndOwner)
        {
            // non-cancel item is selected. Make the hwndOwner foreground.
            SetForegroundWindow(hwndOwner);
            SetFocus(hwndOwner);
        }
        else
        {
            // The user canceled the menu.
            // Restore the previous foreground window (before destroying hwndDummy).
            if (hwndPrev)
                SetForegroundWindow(hwndPrev);
        }

        DestroyWindow(hwndDummy);
    }

    return iRet;
}

//
// user does not support pop-up only menu.
//
STDAPI_(HMENU) SHLoadPopupMenu(HINSTANCE hinst, UINT id)
{
    HMENU hmenuParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (hmenuParent)
    {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }
    return NULL;
}

STDAPI PathToAppPathKeyBase(LPCTSTR pszBase, LPCTSTR pszPath, LPTSTR pszKey, int cchKey)
{
    // Use the szTemp variable of pseem to build key to the programs specific
    // key in the registry as well as other things...
    HRESULT hr = StringCchPrintf(pszKey, cchKey, TEXT("%s\\%s"),
                                 pszBase, PathFindFileName(pszPath));
    if (FAILED(hr))
    {
        return hr;
    }

    // Currently we will only look up .EXE if an extension is not
    // specified
    if (*PathFindExtension(pszKey) == 0)
    {
        hr = StringCchCat(pszKey, cchKey, c_szDotExe);
    }
    return hr;
}

STDAPI PathToAppPathKey(LPCTSTR pszPath, LPTSTR pszKey, int cchKey)
{
    HRESULT hr = PathToAppPathKeyBase(REGSTR_PATH_APPPATHS, pszPath, pszKey, cchKey);

    if (SUCCEEDED(hr))
    {
#ifdef _WIN64
        //
        //  If the app isn't registered under Win64's AppPath,
        //  then try the 32-bit version.
        //
#define REGSTR_PATH_APPPATHS32 TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\App Paths")
        LONG cb;
        if (RegQueryValue(HKEY_LOCAL_MACHINE, pszKey, 0, &cb) == ERROR_FILE_NOT_FOUND)
        {
            hr = PathToAppPathKeyBase(REGSTR_PATH_APPPATHS32, pszPath, pszKey, cchKey);
        }
#endif
    }
    return hr;
}

// out:
//      pszResultPath   assumed to be MAX_PATH in length

STDAPI_(BOOL) PathToAppPath(LPCTSTR pszPath, LPTSTR pszResultPath)
{
    TCHAR szRegKey[MAX_PATH];
    DWORD cbData = MAX_PATH * sizeof(TCHAR);
    HRESULT hr;

    hr = PathToAppPathKey(pszPath, szRegKey, ARRAYSIZE(szRegKey));
    if (FAILED(hr))
    {
        return FALSE;
    }

    return SHRegGetValue(HKEY_LOCAL_MACHINE, szRegKey, NULL, SRRF_RT_REG_SZ, NULL, pszResultPath, &cbData) == ERROR_SUCCESS;
}

HWND GetTopParentWindow(HWND hwnd)
{
    if (IsWindow(hwnd))
    {
        HWND hwndParent;
        while (NULL != (hwndParent = GetWindow(hwnd, GW_OWNER)))
            hwnd = hwndParent;
    }
    else
        hwnd = NULL;

    return hwnd;
}


BOOL _IsLink(LPCTSTR pszPath, DWORD dwAttributes)
{
    SHFILEINFO sfi = {0};
    DWORD dwFlags = SHGFI_ATTRIBUTES | SHGFI_ATTR_SPECIFIED;

    sfi.dwAttributes = SFGAO_LINK;  // setup in param (SHGFI_ATTR_SPECIFIED requires this)

    if (-1 != dwAttributes)
        dwFlags |= SHGFI_USEFILEATTRIBUTES;

    return SHGetFileInfo(pszPath, dwAttributes, &sfi, sizeof(sfi), dwFlags) &&
        (sfi.dwAttributes & SFGAO_LINK);
}

STDAPI_(BOOL) PathIsShortcut(LPCTSTR pszPath, DWORD dwAttributes)
{
    BOOL bRet = FALSE;
    BOOL bMightBeFile;

    if (-1 == dwAttributes)
        bMightBeFile = TRUE;      // optmistically assume it is (to get shortcircut cases)
    else
        bMightBeFile = !(FILE_ATTRIBUTE_DIRECTORY & dwAttributes);

    // optimistic shortcurcut. if we don't know it is a folder for sure use the extension test
    if (bMightBeFile)
    {
        if (PathIsLnk(pszPath))
        {
            bRet = TRUE;    // quick short-circut for perf
        }
        else if (PathIsExe(pszPath))
        {
            bRet = FALSE;   // quick short-cut to avoid blowing stack on Win16
        }
        else
        {
            bRet = _IsLink(pszPath, dwAttributes);
        }
    }
    else
    {
        bRet = _IsLink(pszPath, dwAttributes);
    }
    return bRet;
}

HRESULT _UIObject_AssocCreate(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    //  this means that the folder doesnt support
    //  the IQueryAssociations.  so we will
    //  just check to see if this is a folder.
    //
    //  some shellextensions mask the FILE system
    //  and want the file system associations to show
    //  up for their items.  so we will try a simple pidl
    //
    HRESULT hr = E_NOTIMPL;
    DWORD rgfAttrs = SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_FILESYSTEM);
    if (rgfAttrs & SFGAO_FILESYSTEM)
    {
        TCHAR sz[MAX_PATH];
        hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, sz, ARRAYSIZE(sz));
        if (SUCCEEDED(hr))
        {
            WIN32_FIND_DATA fd = {0};
            LPITEMIDLIST pidlSimple;

            if (rgfAttrs & SFGAO_FOLDER)
                fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;

            hr = SHSimpleIDListFromFindData(sz, &fd, &pidlSimple);
            if (SUCCEEDED(hr))
            {
                //  need to avoid recursion, so we cant call SHGetUIObjectOf()
                hr = SHGetUIObjectFromFullPIDL(pidlSimple, NULL, riid, ppv);
                ILFree(pidlSimple);
            }
        }
    }

    if (FAILED(hr) && (rgfAttrs & (SFGAO_FOLDER | SFGAO_BROWSABLE)))
    {
        IAssociationArrayInitialize *paa;
        //  make sure at least folders work.
        hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IAssociationArrayInitialize, &paa));
        if (SUCCEEDED(hr))
        {
            hr = paa->InitClassElements(0, L"Folder");
            if (SUCCEEDED(hr))
            {
                hr = paa->QueryInterface(riid, ppv);
            }
            paa->Release();
        }
    }
        
    return hr;
}

typedef HRESULT (* PFNUIOBJECTHELPER)(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

typedef struct
{
    const IID *piidDesired;
    const IID *piidAlternate;
    PFNUIOBJECTHELPER pfn;
} UIOBJECTMAP;

static const UIOBJECTMAP c_rgUIObjectMap[] = 
{
    {&IID_IQueryAssociations, NULL, _UIObject_AssocCreate},
    {&IID_IAssociationArray, &IID_IQueryAssociations, _UIObject_AssocCreate},
//    {&IID_IContextMenu2, &IID_IContextMenu, NULL},
};

const UIOBJECTMAP *_GetUiObjectMap(REFIID riid)
{
    for (int i = 0; i < ARRAYSIZE(c_rgUIObjectMap); i++)
    {
        if (riid == *(c_rgUIObjectMap[i].piidDesired))
            return &c_rgUIObjectMap[i];
    }
    return NULL;
}

STDAPI UIObjectOf(IShellFolder *psf, LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = psf->GetUIObjectOf(hwnd, 1, &pidl, riid, NULL, ppv);
    if (FAILED(hr))
    {
        const UIOBJECTMAP *pmap = _GetUiObjectMap(riid);
        if (pmap)
        {
            if (pmap->piidAlternate)
            {
                IUnknown *punk;
                hr = psf->GetUIObjectOf(hwnd, 1, &pidl, *(pmap->piidAlternate), NULL, (void **)&punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(riid, ppv);
                    punk->Release();
                }
            }

            //  let the fallback code run
            if (FAILED(hr) && pmap->pfn)
            {
                hr = pmap->pfn(psf, pidl, riid, ppv);
            }
        }
    }
    return hr;
}

STDAPI AssocGetDetailsOfSCID(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv, BOOL *pfFoundScid)
{
    *pfFoundScid = FALSE;
    HRESULT hr = E_NOTIMPL;
    static const struct 
    {
        const SHCOLUMNID *pscid;
        ASSOCQUERY query;
        LPCWSTR pszCue;
    } s_rgAssocSCIDs[] = 
    {
        { &SCID_DetailsProperties, AQN_NAMED_VALUE, L"Details"},
    };

    for (int i = 0; i < ARRAYSIZE(s_rgAssocSCIDs); i++)
    {
        if (IsEqualSCID(*pscid, *(s_rgAssocSCIDs[i].pscid)))
        {
            IAssociationArray *paa;
            hr = UIObjectOf(psf, pidl, NULL, IID_PPV_ARG(IAssociationArray, &paa));
            if (SUCCEEDED(hr))
            {
                CSmartCoTaskMem<WCHAR> spsz;
                hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, s_rgAssocSCIDs[i].query, s_rgAssocSCIDs[i].pszCue, &spsz);
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStr(pv, spsz);
                }
                paa->Release();
            }
            break;
        }
    }
    return hr;
}

//
// retrieves the UIObject interface for the specified full pidl.
//
STDAPI SHGetUIObjectOf(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = UIObjectOf(psf, pidlChild, hwnd, riid, ppv);
        psf->Release();
    }

    return hr;
}


STDAPI SHGetAssociations(LPCITEMIDLIST pidl, void **ppv)
{
    return SHGetUIObjectOf(pidl, NULL, IID_IQueryAssociations, ppv);
}

//
//  SHGetAssocKeys() retrieves an array of class keys
//  from a pqa.
//
//  if the caller is just interested in the primary class key,
//  call with cKeys == 1.  the return value is the number of keys
//  inserted into the array.
//

STDAPI AssocKeyFromElement(IAssociationElement *pae, HKEY *phk)
{
    IObjectWithQuerySource *powqs;
    HRESULT hr = pae->QueryInterface(IID_PPV_ARG(IObjectWithQuerySource, &powqs));
    if (SUCCEEDED(hr))
    {
        IObjectWithRegistryKey *powrk;
        hr = powqs->GetSource(IID_PPV_ARG(IObjectWithRegistryKey, &powrk));
        if (SUCCEEDED(hr))
        {
            hr = powrk->GetKey(phk);
            powrk->Release();
        }
        powqs->Release();
    }
    return hr;
}

HRESULT AssocElemCreateForClass(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae)
{
    IPersistString2 *pips;
    HRESULT hr = AssocCreate(*pclsid, IID_PPV_ARG(IPersistString2, &pips));
    if (SUCCEEDED(hr))
    {
        hr = pips->SetString(pszClass);
        if (SUCCEEDED(hr))
        {
            hr = pips->QueryInterface(IID_PPV_ARG(IAssociationElement, ppae));
        }
        pips->Release();
    }
    return hr;
}

HRESULT AssocElemCreateForKey(const CLSID *pclsid, HKEY hk, IAssociationElement **ppae)
{
    IObjectWithQuerySource *powqs;
    HRESULT hr = AssocCreate(*pclsid, IID_PPV_ARG(IObjectWithQuerySource, &powqs));
    if (SUCCEEDED(hr))
    {
        IQuerySource *pqs;
        hr = QuerySourceCreateFromKey(hk, NULL, FALSE, IID_PPV_ARG(IQuerySource, &pqs));
        if (SUCCEEDED(hr))
        {
            hr = powqs->SetSource(pqs);
            if (SUCCEEDED(hr))
            {
                hr = powqs->QueryInterface(IID_PPV_ARG(IAssociationElement, ppae));
            }
            pqs->Release();
        }
        powqs->Release();
    }
    return hr;
}


STDAPI_(DWORD) SHGetAssocKeysEx(IAssociationArray *paa, ASSOCELEM_MASK mask, HKEY *rgKeys, DWORD cKeys)
{
    DWORD cRet = 0;
    IEnumAssociationElements *penum;
    HRESULT hr = paa->EnumElements(mask, &penum);
    if (SUCCEEDED(hr))
    {
        IAssociationElement *pae;
        ULONG c;
        while (cRet < cKeys && S_OK == penum->Next(1, &pae, &c))
        {
            if (SUCCEEDED(AssocKeyFromElement(pae, &rgKeys[cRet])))
                cRet++;
                
            pae->Release();
        }
        penum->Release();
    }
    return cRet;
}

DWORD SHGetAssocKeys(IQueryAssociations *pqa, HKEY *rgKeys, DWORD cKeys)
{
    IAssociationArray *paa;
    if (SUCCEEDED(pqa->QueryInterface(IID_PPV_ARG(IAssociationArray, &paa))))
    {
        cKeys = SHGetAssocKeysEx(paa, ASSOCELEM_MASK_ENUMCONTEXTMENU, rgKeys, cKeys);
        paa->Release();
    }
    else
        cKeys = 0;

    return cKeys;
}

STDAPI_(DWORD) SHGetAssocKeysForIDList(LPCITEMIDLIST pidl, HKEY *rghk, DWORD ck)
{
    IQueryAssociations *pqa;
    if (SUCCEEDED(SHGetAssociations(pidl, (void **)&pqa)))
    {
        ck = SHGetAssocKeys(pqa, rghk, ck);
        pqa->Release();
    }
    else
        ck = 0;

    return ck;
}


// NOTE:
//  this API returns a win32 file system path for the item in the name space
//  and has a few special cases that include returning UNC printer names too!

STDAPI_(BOOL) SHGetPathFromIDListEx(LPCITEMIDLIST pidl, LPTSTR pszPath, UINT uOpts)
{
    HRESULT hr;

    *pszPath = 0;    // zero output buffer

    if (!pidl)
        return FALSE;   // bad params

    if (ILIsEmpty(pidl))
    {
        // desktop special case because we can not depend on the desktop
        // returning a file system path (APP compat)
        hr = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, pszPath);
        if (hr == S_FALSE)
            hr = E_FAIL;
    }
    else
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            hr = DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING, pszPath, MAX_PATH);
            if (SUCCEEDED(hr))
            {
                DWORD dwAttributes = SFGAO_FILESYSTEM;
                hr = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlLast, &dwAttributes);
                if (SUCCEEDED(hr) && !(dwAttributes & SFGAO_FILESYSTEM))
                {
                    // special case for UNC printer names. this is an app
                    // compat issue (HP LaserJet 2100 setup) & some Semantic apps
                    if (uOpts & GPFIDL_UNCPRINTER)
                    {
                        CLSID clsid;
                        hr = IUnknown_GetClassID(psf, &clsid);
                        if (FAILED(hr) || (clsid != CLSID_NetworkServer))
                        {
                            hr = E_FAIL;
                            *pszPath = 0;
                        }
                    }
                    else
                    {
                        hr = E_FAIL;    // not a file system guy, slam it
                        *pszPath = 0;
                    }
                }
            }
            psf->Release();
        }
    }

    if (SUCCEEDED(hr) && (uOpts & GPFIDL_ALTNAME))
    {
        TCHAR szShort[MAX_PATH];
        if (GetShortPathName(pszPath, szShort, ARRAYSIZE(szShort)))
        {
            hr = StringCchCopy(pszPath, MAX_PATH, szShort);
            if (FAILED(hr))
            {
                *pszPath = TEXT('\0');
            }
        }
    }
    return SUCCEEDED(hr);
}

STDAPI_(BOOL) SHGetPathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    // NOTE: we pass GPFIDL_UNCPRINTER to get UNC printer names too
    return SHGetPathFromIDListEx(pidl, pszPath, GPFIDL_UNCPRINTER);
}

#define CBHUMHEADER     14
inline BOOL _DoHummingbirdHack(LPCITEMIDLIST pidl)
{
    static const char rgchHum[] = {(char)0xe8, (char)0x03, 0,0,0,0,0,0,(char)0x10,0};

    return (pidl && pidl->mkid.cb > CBHUMHEADER) && ILIsEmpty(_ILNext(pidl))
    && (0 == memcmp(_ILSkip(pidl, 4), rgchHum, sizeof(rgchHum)))
    && GetModuleHandle(TEXT("heshell"));
}

STDAPI_(BOOL) SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath)
{
    WCHAR wszPath[MAX_PATH];

    *pszPath = 0;  // Assume error

    if (SHGetPathFromIDListW(pidl, wszPath))
    {
        // Thunk the output result string back to ANSI.  If the conversion fails,
        // or if the default char is used, we fail the API call.

        if (0 == WideCharToMultiByte(CP_ACP, 0, wszPath, -1, pszPath, MAX_PATH, NULL, NULL))
        {
            return FALSE;  // (DavePl) Note failure only due to text thunking
        }
        return TRUE;        // warning, word perfect tests explictly for TRUE (== TRUE)
    }
    else if (_DoHummingbirdHack(pidl))
    {
        //
        //  HACKHACK - hummingbird isn't very good here because we used be even worse - Zekel 7-OCT-99
        //  hummingbird's shell extension passes us a pidl that is relative to
        //  itself.  however SHGetPathFromIDList() used to try some weird stuff
        //  when it didnt recognize the pidl.  in this case it would combine the
        //  relative pidl with the CSIDL_DESKTOPDIRECTORY pidl, and then ask for
        //  the path.  due to crappy parameter validation we would actually return
        //  back a path with a string from inside their relative pidl.  the path
        //  of course doesnt exist at all, but hummingbird fails to initialize its
        //  subfolders if we fail here.  they dont do anything with the path except
        //  look for a slash.  (if the slash is missing they will fault.)
        //
        SHGetFolderPathA(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, pszPath);
        return PathAppendA(pszPath, (LPCSTR)_ILSkip(pidl, CBHUMHEADER));
    }

    return FALSE;
}

//
//  Race-condition-free version.
//
STDAPI_(HANDLE) SHGetCachedGlobalCounter(HANDLE *phCache, const GUID *pguid)
{
    if (!*phCache)
    {
        HANDLE h = SHGlobalCounterCreate(*pguid);
        if (SHInterlockedCompareExchange(phCache, h, 0))
        {
            // some other thread raced with us, throw away our copy
            SHGlobalCounterDestroy(h);
        }
    }
    return *phCache;
}

//
//  Race-condition-free version.
//
STDAPI_(void) SHDestroyCachedGlobalCounter(HANDLE *phCache)
{
    HANDLE h = InterlockedExchangePointer(phCache, NULL);
    if (h)
    {
        SHGlobalCounterDestroy(h);
    }
}

//
//  Use this function when you want to lazy-create and cache some object.
//  It's safe in the multithreaded case where two people lazy-create the
//  object and both try to put it into the cache.
//
STDAPI_(void) SetUnknownOnSuccess(HRESULT hr, IUnknown *punk, IUnknown **ppunkToSet)
{
    if (SUCCEEDED(hr))
    {
        if (SHInterlockedCompareExchange((void **)ppunkToSet, punk, 0))
            punk->Release();  // race, someone did this already
    }
}

//
//  Create and cache a tracking folder.
//
//  pidlRoot    = where the folder should reside; can be MAKEINTIDLIST(csidl).
//  csidlTarget = the csidl we should track, CSIDL_FLAG_CREATE is allowed
//  ppsfOut     = Receives the cached folder
//
//  If there is already a folder in the cache, succeeds vacuously.
//
STDAPI SHCacheTrackingFolder(LPCITEMIDLIST pidlRoot, int csidlTarget, IShellFolder2 **ppsfCache)
{
    HRESULT hr = S_OK;

    if (!*ppsfCache)
    {
        PERSIST_FOLDER_TARGET_INFO pfti = {0};
        IShellFolder2 *psf;
        LPITEMIDLIST pidl;

        // add FILE_ATTRIBUTE_SYSTEM to allow MUI stuff underneath this folder.
        // since its just for these tracking folders it isnt a perf hit to enable this.
        pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM;
        pfti.csidl = csidlTarget | CSIDL_FLAG_PFTI_TRACKTARGET;

        if (IS_INTRESOURCE(pidlRoot))
        {
            hr = SHGetFolderLocation(NULL, PtrToInt(pidlRoot), NULL, 0, &pidl);
        }
        else
        {
            pidl = const_cast<LPITEMIDLIST>(pidlRoot);
        }

        if (SUCCEEDED(hr))
        {
            hr = CFSFolder_CreateFolder(NULL, NULL, pidl, &pfti, IID_PPV_ARG(IShellFolder2, &psf));
            SetUnknownOnSuccess(hr, psf, (IUnknown **)ppsfCache);
        }

        if (pidl != pidlRoot)
            ILFree(pidl);

    }
    return hr;
}

STDAPI DefaultSearchGUID(GUID *pGuid)
{
    if (SHRestricted(REST_NOFIND))
    {
        *pGuid = GUID_NULL;
        return E_NOTIMPL;
    }

    *pGuid = SRCID_SFileSearch;
    return S_OK;
}


// Helper function to save IPersistHistory stream for you
//
HRESULT SavePersistHistory(IUnknown* punk, IStream* pstm)
{
    IPersistHistory* pPH;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IPersistHistory, &pPH));
    if (SUCCEEDED(hr))
    {
        CLSID clsid;
        hr = pPH->GetClassID(&clsid);
        if (SUCCEEDED(hr))
        {
            hr = IStream_Write(pstm, &clsid, sizeof(clsid));
            if (SUCCEEDED(hr))
            {
                hr = pPH->SaveHistory(pstm);
            }
        }
        pPH->Release();
    }
    return hr;
}

STDAPI Stream_WriteStringA(IStream *pstm, LPCSTR psz)
{
    SHORT cch = (SHORT)lstrlenA(psz);
    HRESULT hr = pstm->Write(&cch, sizeof(cch), NULL);
    if (SUCCEEDED(hr))
        hr = pstm->Write(psz, cch * sizeof(*psz), NULL);

    return hr;
}

STDAPI Stream_WriteStringW(IStream *pstm, LPCWSTR psz)
{
    SHORT cch = (SHORT)lstrlenW(psz);
    HRESULT hr = pstm->Write(&cch, sizeof(cch), NULL);
    if (SUCCEEDED(hr))
        hr = pstm->Write(psz, cch * sizeof(*psz), NULL);

    return hr;
}

STDAPI Stream_WriteString(IStream *pstm, LPCWSTR psz, BOOL bWideInStream)
{
    HRESULT hr;
    if (bWideInStream)
    {
        hr = Stream_WriteStringW(pstm, psz);
    }
    else
    {
        CHAR szBuf[MAX_PATH];
        SHUnicodeToAnsi(psz, szBuf, ARRAYSIZE(szBuf));
        hr = Stream_WriteStringA(pstm, szBuf);
    }
    return hr;
}

STDAPI Stream_ReadStringA(IStream *pstm, LPSTR pszBuf, UINT cchBuf)
{
    *pszBuf = 0;

    USHORT cch;
    HRESULT hr = pstm->Read(&cch, sizeof(cch), NULL);   // size of data
    if (SUCCEEDED(hr))
    {
        if (cch >= (USHORT)cchBuf)
        {
            DebugMsg(DM_TRACE, TEXT("truncating string read(%d to %d)"), cch, cchBuf);
            cch = (USHORT)cchBuf - 1;   // leave room for null terminator
        }

        hr = pstm->Read(pszBuf, cch, NULL);
        if (SUCCEEDED(hr))
            pszBuf[cch] = 0;      // add NULL terminator
    }
    return hr;
}

STDAPI Stream_ReadStringW(IStream *pstm, LPWSTR pwszBuf, UINT cchBuf)
{
    *pwszBuf = 0;

    USHORT cch;
    HRESULT hr = pstm->Read(&cch, sizeof(cch), NULL);   // size of data
    if (SUCCEEDED(hr))
    {
        if (cch >= (USHORT)cchBuf)
        {
            DebugMsg(DM_TRACE, TEXT("truncating string read(%d to %d)"), cch, cchBuf);
            cch = (USHORT)cchBuf - 1;   // leave room for null terminator
        }

        hr = pstm->Read(pwszBuf, cch * sizeof(*pwszBuf), NULL);
        if (SUCCEEDED(hr))
            pwszBuf[cch] = 0;      // add NULL terminator
    }
    return hr;
}

STDAPI Stream_ReadString(IStream *pstm, LPTSTR psz, UINT cchBuf, BOOL bWideInStream)
{
    HRESULT hr;
    if (bWideInStream)
    {
        hr = Stream_ReadStringW(pstm, psz, cchBuf);
    }
    else
    {
        CHAR szAnsiBuf[MAX_PATH];
        hr = Stream_ReadStringA(pstm, szAnsiBuf, ARRAYSIZE(szAnsiBuf));
        if (SUCCEEDED(hr))
            SHAnsiToUnicode(szAnsiBuf, psz, cchBuf);
    }
    return hr;
}

STDAPI Str_SetFromStream(IStream *pstm, LPTSTR *ppsz, BOOL bWideInStream)
{
    TCHAR szBuf[MAX_PATH];
    HRESULT hr = Stream_ReadString(pstm, szBuf, ARRAYSIZE(szBuf), bWideInStream);
    if (SUCCEEDED(hr))
        if (!Str_SetPtr(ppsz, szBuf))
            hr = E_OUTOFMEMORY;
    return hr;
}

LPSTR ThunkStrToAnsi(LPCWSTR pszW, CHAR *pszA, UINT cchA)
{
    if (pszW)
    {
        SHUnicodeToAnsi(pszW, pszA, cchA);
        return pszA;
    }
    return NULL;
}

LPWSTR ThunkStrToWide(LPCSTR pszA, LPWSTR pszW, DWORD cchW)
{
    if (pszA)
    {
        SHAnsiToUnicode(pszA, pszW, cchW);
        return pszW;
    }
    return NULL;
}

#define ThunkSizeAnsi(pwsz)       WideCharToMultiByte(CP_ACP,0,(pwsz),-1,NULL,0,NULL,NULL)
#define ThunkSizeWide(psz)       MultiByteToWideChar(CP_ACP,0,(psz),-1,NULL,0)

STDAPI SEI2ICIX(LPSHELLEXECUTEINFO pei, LPCMINVOKECOMMANDINFOEX pici, void **ppvFree)
{
    HRESULT hr = S_OK;

    *ppvFree = NULL;
    ZeroMemory(pici, sizeof(CMINVOKECOMMANDINFOEX));

    pici->cbSize = sizeof(CMINVOKECOMMANDINFOEX);
    pici->fMask = (pei->fMask & SEE_VALID_CMIC_BITS);
    pici->hwnd = pei->hwnd;
    pici->nShow = pei->nShow;
    pici->dwHotKey = pei->dwHotKey;
    pici->lpTitle = NULL;

    //  the pei->hIcon can have multiple meanings...
    if ((pei->fMask & SEE_MASK_HMONITOR) && pei->hIcon)
    {
        //  in this case we want the hMonitor to
        //  make it through to where the pcm calls shellexec
        //  again.
        RECT rc;
        if (GetMonitorRect((HMONITOR)pei->hIcon, &rc))
        {
            //  default to the top left corner of
            //  the monitor.  it is just the monitor
            //  that is relevant here.
            pici->ptInvoke.x = rc.left;
            pici->ptInvoke.y = rc.top;
            pici->fMask |= CMIC_MASK_PTINVOKE;
        }
    }
    else
    {
        pici->hIcon = pei->hIcon;
    }

    // again, pei->lpClass can have multiple meanings...
    if (pei->fMask & (SEE_MASK_HASTITLE | SEE_MASK_HASLINKNAME))
    {
        pici->lpTitleW = pei->lpClass;
    }

    pici->lpVerbW       = pei->lpVerb;
    pici->lpParametersW = pei->lpParameters;
    pici->lpDirectoryW  = pei->lpDirectory;

    //  we need to thunk the strings down.  first get the length of all the buffers
    DWORD cbVerb = ThunkSizeAnsi(pei->lpVerb);
    DWORD cbParameters = ThunkSizeAnsi(pei->lpParameters);
    DWORD cbDirectory = ThunkSizeAnsi(pei->lpDirectory);
    DWORD cbTotal = cbVerb + cbParameters + cbDirectory;

    if (cbTotal)
    {
        hr = SHLocalAlloc(cbVerb + cbParameters + cbDirectory, ppvFree);
        if (SUCCEEDED(hr))
        {
            LPSTR pch = (LPSTR) *ppvFree;

            pici->lpVerb = ThunkStrToAnsi(pei->lpVerb, pch, cbVerb);
            pch += cbVerb;
            pici->lpParameters  = ThunkStrToAnsi(pei->lpParameters, pch, cbParameters);
            pch += cbParameters;
            pici->lpDirectory   = ThunkStrToAnsi(pei->lpDirectory, pch, cbDirectory);
        }
    }

    pici->fMask |= CMIC_MASK_UNICODE;

    return hr;
}

STDAPI ICIX2SEI(LPCMINVOKECOMMANDINFOEX pici, LPSHELLEXECUTEINFO pei)
{
    //  perhaps we should allow just plain ici's, and do the thunk in here, but
    //  it looks like all the callers want to do the thunk themselves...
    //  HRESULT hr = S_OK;

    ZeroMemory(pei, sizeof(SHELLEXECUTEINFO));
    pei->cbSize = sizeof(SHELLEXECUTEINFO);
    pei->fMask = pici->fMask & SEE_VALID_CMIC_BITS;

    // if we are doing this async, then we will abort this thread
    // as soon as the shellexecute completes.  If the app holds open
    // a dde conversation, this may hang them.  This happens on W95 base
    // with winword95
    IUnknown *punk;
    HRESULT hr = TBCGetObjectParam(TBCDIDASYNC, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        pei->fMask |= SEE_MASK_FLAG_DDEWAIT;
        punk->Release();
    }

    pei->hwnd = pici->hwnd;
    pei->nShow = pici->nShow;
    pei->dwHotKey = pici->dwHotKey;

    if (pici->fMask & CMIC_MASK_ICON)
    {
        pei->hIcon = pici->hIcon;
    }
    else if (pici->fMask & CMIC_MASK_PTINVOKE)
    {
        pei->hIcon = (HANDLE)MonitorFromPoint(pici->ptInvoke, MONITOR_DEFAULTTONEAREST);
        pei->fMask |= SEE_MASK_HMONITOR;
    }

    ASSERT(pici->fMask & CMIC_MASK_UNICODE);

    pei->lpParameters = pici->lpParametersW;
    pei->lpDirectory  = pici->lpDirectoryW;

    if (!IS_INTRESOURCE(pici->lpVerbW))
    {
        pei->lpVerb = pici->lpVerbW;
    }

    // both the title and linkname can be stored the lpClass field
    if (pici->fMask & (CMIC_MASK_HASTITLE | CMIC_MASK_HASLINKNAME))
    {
            pei->lpClass = pici->lpTitleW;
    }

    //  if we have to do any thunking in here, we
    //  will have a real return hr.
    return S_OK;
}

STDAPI ICI2ICIX(LPCMINVOKECOMMANDINFO piciIn, LPCMINVOKECOMMANDINFOEX piciOut, void **ppvFree)
{
    ASSERT(piciIn->cbSize >= sizeof(CMINVOKECOMMANDINFO));

    HRESULT hr = S_OK;
    *ppvFree = NULL;

    ZeroMemory(piciOut, sizeof(*piciOut));
    memcpy(piciOut, piciIn, min(sizeof(*piciOut), piciIn->cbSize));
    piciOut->cbSize = sizeof(*piciOut);
    
    //  if the UNICODE params arent there, we must put them there
    if (!(piciIn->cbSize >= CMICEXSIZE_NT4) || !(piciIn->fMask & CMIC_MASK_UNICODE))
    {
        DWORD cchDirectory = ThunkSizeWide(piciOut->lpDirectory);
        DWORD cchTitle = ThunkSizeWide(piciOut->lpTitle);
        DWORD cchParameters = ThunkSizeWide(piciOut->lpParameters);
        DWORD cchVerb = 0;
        if (!IS_INTRESOURCE(piciOut->lpVerb))
            cchVerb = ThunkSizeWide(piciOut->lpVerb);

        DWORD cchTotal = (cchDirectory + cchTitle + cchVerb + cchParameters);

        if (cchTotal)
        {
            hr = SHLocalAlloc(sizeof(WCHAR) * cchTotal, ppvFree);
            if (SUCCEEDED(hr))
            {
                LPWSTR pch = (LPWSTR) *ppvFree;
                piciOut->lpDirectoryW = ThunkStrToWide(piciOut->lpDirectory, pch, cchDirectory);
                pch += cchDirectory;
                piciOut->lpTitleW = ThunkStrToWide(piciOut->lpTitle, pch, cchTitle);
                pch += cchTitle;
                piciOut->lpParametersW = ThunkStrToWide(piciOut->lpParameters, pch, cchParameters);
                pch += cchParameters;

                //only thunk if it is a string...
                if (!IS_INTRESOURCE(piciOut->lpVerb))
                {
                    piciOut->lpVerbW = ThunkStrToWide(piciOut->lpVerb, pch, cchVerb);
                }
                else
                {
                    piciOut->lpVerbW = (LPCWSTR)piciOut->lpVerb;
                }
            }
        }

        piciOut->fMask |= CMIC_MASK_UNICODE;
    }

    return hr;
}


IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation, HINSTANCE hAnimationInst)
{
    IProgressDialog * ppd;

    if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IProgressDialog, &ppd))))
    {
        WCHAR wzTitle[MAX_PATH];

        EVAL(SUCCEEDED(ppd->SetAnimation(hAnimationInst, idAnimation)));
        if (EVAL(LoadStringW(HINST_THISDLL, idTitle, wzTitle, ARRAYSIZE(wzTitle))))
            EVAL(SUCCEEDED(ppd->SetTitle(wzTitle)));
    }

    return ppd;
}

STDAPI GetCurFolderImpl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    if (pidl)
        return SHILClone(pidl, ppidl);

    *ppidl = NULL;
    return S_FALSE; // success but empty
}


//
// converts a simple PIDL to a real PIDL by converting to display name and then
// reparsing the name
//
STDAPI SHGetRealIDL(IShellFolder *psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST *ppidlReal)
{
    *ppidlReal = NULL;      // clear output

    STRRET str;
    HRESULT hr = IShellFolder_GetDisplayNameOf(psf, pidlSimple, SHGDN_FORPARSING | SHGDN_INFOLDER, &str, 0);
    if (SUCCEEDED(hr))
    {
        WCHAR szPath[MAX_PATH];
        hr = StrRetToBufW(&str, pidlSimple, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            DWORD dwAttrib = SFGAO_FILESYSTEM;
            if (SUCCEEDED(psf->GetAttributesOf(1, &pidlSimple, &dwAttrib)) && !(dwAttrib & SFGAO_FILESYSTEM))
            {
                // not a file sys object, some name spaces (WinCE) support
                // parse, but don't do a good job, in this case
                // return the input as the output
                hr = SHILClone(pidlSimple, ppidlReal);
            }
            else
            {
                hr = IShellFolder_ParseDisplayName(psf, NULL, NULL, szPath, NULL, ppidlReal, NULL);
                if (E_INVALIDARG == hr || E_NOTIMPL == hr)
                {
                    // name space does not support parse, assume pidlSimple is OK
                    hr = SHILClone(pidlSimple, ppidlReal);
                }
            }
        }
    }
    return hr;
}

//  trial and error has shown that
//  16k is a good number for FTP,
//  thus we will use that as our default buffer
#define CBOPTIMAL    (16 * 1024)

STDAPI CopyStreamUI(IStream *pstmSrc, IStream *pstmDest, IProgressDialog *pdlg, ULONGLONG ullMaxBytes)
{
    HRESULT hr = E_FAIL;
    ULONGLONG ullMax;

    if (ullMaxBytes != 0)
    {
        ullMax = ullMaxBytes;
    }
    else if (pdlg)
    {
        STATSTG stat = {0};
        if (FAILED(pstmSrc->Stat(&stat, STATFLAG_NONAME)))
            pdlg = NULL;
        else
            ullMax = stat.cbSize.QuadPart;
    }

    if (!pdlg)
    {
        ULARGE_INTEGER ulMax = {-1, -1};
        // If ullMaxBytes was passed in as non-zero, don't write more bytes than we were told to:
        if (0 != ullMaxBytes)
        {
            ulMax.QuadPart = ullMaxBytes;
        }
        hr = pstmSrc->CopyTo(pstmDest, ulMax, NULL, NULL);

        //  BUBBUGREMOVE - URLMON has bug which breaks CopyTo() - Zekel
        //  fix URLMON and then we can remove this garbage.
        //  so we will fake it here
    }

    if (FAILED(hr))
    {
        // try doing it by hand
        void *pv = LocalAlloc(LPTR, CBOPTIMAL);
        BYTE buf[1024];
        ULONG cbBuf, cbRead, cbBufReal;
        ULONGLONG ullCurr = 0;

        //  need to reset the streams,
        //  because CopyTo() doesnt guarantee any kind
        //  of state
        IStream_Reset(pstmSrc);
        IStream_Reset(pstmDest);

        //  if we werent able to get the
        //  best size, just use a little stack space :)
        if (pv)
            cbBufReal = CBOPTIMAL;
        else
        {
            pv = buf;
            cbBufReal = sizeof(buf);
        }

        cbBuf = cbBufReal;
        while (SUCCEEDED(pstmSrc->Read(pv, cbBuf, &cbRead)))
        {
            ullCurr += cbBuf;

            if (pdlg)
            {
                if (pdlg->HasUserCancelled())
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }


                //  Note: urlmon doesnt always fill in the correct value for cbBuf returned
                //  so we need to make sure we dont pass bigger curr than max
                pdlg->SetProgress64(min(ullCurr, ullMax), ullMax);
            }

            // If ullMaxBytes was passed in as non-zero, don't write more bytes than we were told to:
            ULONG ulBytesToWrite = (0 != ullMaxBytes) ?
                                         (ULONG) min(cbRead, ullMaxBytes - (ullCurr - cbBuf)) :
                                         cbRead;

            if (!ulBytesToWrite)
            {
                hr = S_OK;
                break;
            }

            hr = IStream_Write(pstmDest, pv, ulBytesToWrite);
            if (S_OK != hr)
                break;  // failure!

            cbBuf = cbBufReal;
        }

        if (pv != buf)
            LocalFree(pv);
    }

    return hr;

}

STDAPI CopyStream(IStream *pstmSrc, IStream *pstmDest)
{
    return CopyStreamUI(pstmSrc, pstmDest, NULL, 0);
}

STDAPI_(BOOL) IsWindowInProcess(HWND hwnd)
{
    DWORD idProcess;

    GetWindowThreadProcessId(hwnd, &idProcess);
    return idProcess == GetCurrentProcessId();
}

class CFileSysBindData: public IFileSystemBindData
{
public:
    CFileSysBindData();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IFileSystemBindData
    STDMETHODIMP SetFindData(const WIN32_FIND_DATAW *pfd);
    STDMETHODIMP GetFindData(WIN32_FIND_DATAW *pfd);

private:
    ~CFileSysBindData();

    LONG  _cRef;
    WIN32_FIND_DATAW _fd;
};


CFileSysBindData::CFileSysBindData() : _cRef(1)
{
    ZeroMemory(&_fd, sizeof(_fd));
}

CFileSysBindData::~CFileSysBindData()
{
}

HRESULT CFileSysBindData::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFileSysBindData, IFileSystemBindData), // IID_IFileSystemBindData
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileSysBindData::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileSysBindData::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFileSysBindData::SetFindData(const WIN32_FIND_DATAW *pfd)
{
    _fd = *pfd;
    return S_OK;
}

HRESULT CFileSysBindData::GetFindData(WIN32_FIND_DATAW *pfd)
{
    *pfd = _fd;
    return S_OK;
}

STDAPI SHCreateFileSysBindCtx(const WIN32_FIND_DATA *pfd, IBindCtx **ppbc)
{
    HRESULT hr;
    IFileSystemBindData *pfsbd = new CFileSysBindData();
    if (pfsbd)
    {
        if (pfd)
        {
            pfsbd->SetFindData(pfd);
        }

        hr = CreateBindCtx(0, ppbc);
        if (SUCCEEDED(hr))
        {
            BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
            bo.grfMode = STGM_CREATE;
            (*ppbc)->SetBindOptions(&bo);
            (*ppbc)->RegisterObjectParam(STR_FILE_SYS_BIND_DATA, pfsbd);
        }
        pfsbd->Release();
    }
    else
    {
        *ppbc = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI SHCreateFileSysBindCtxEx(const WIN32_FIND_DATA *pfd, DWORD grfMode, DWORD grfFlags, IBindCtx **ppbc)
{
    HRESULT hr = SHCreateFileSysBindCtx(pfd, ppbc);
    if (SUCCEEDED(hr))
    {
        BIND_OPTS bo = {sizeof(bo)};
        hr = (*ppbc)->GetBindOptions(&bo);
        if (SUCCEEDED(hr))
        {
            bo.grfMode =  grfMode;
            bo.grfFlags = grfFlags;
            hr = (*ppbc)->SetBindOptions(&bo);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }
    return hr;
}


// returns S_OK if this is a simple bind ctx
// out:
//      optional (may be NULL) pfd
//
STDAPI SHIsFileSysBindCtx(IBindCtx *pbc, WIN32_FIND_DATA **ppfd)
{
    HRESULT hr = S_FALSE; // default to no
    IUnknown *punk;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_FILE_SYS_BIND_DATA, &punk)))
    {
        IFileSystemBindData *pfsbd;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IFileSystemBindData, &pfsbd))))
        {
            hr = S_OK;    // yes
            if (ppfd)
            {
                hr = SHLocalAlloc(sizeof(WIN32_FIND_DATA), ppfd);
                if (SUCCEEDED(hr))
                    pfsbd->GetFindData(*ppfd);
            }
            pfsbd->Release();
        }
        punk->Release();
    }
    return hr;
}


STDAPI SHCreateSkipBindCtx(IUnknown *punkToSkip, IBindCtx **ppbc)
{
    HRESULT hr = CreateBindCtx(0, ppbc);
    if (SUCCEEDED(hr))
    {
        // NULL clsid means bind context that skips all junction points
        if (punkToSkip)
        {
            (*ppbc)->RegisterObjectParam(STR_SKIP_BINDING_CLSID, punkToSkip);
        }
        else
        {
            BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
            bo.grfFlags = BIND_JUSTTESTEXISTENCE;
            (*ppbc)->SetBindOptions(&bo);
        }
    }
    return hr;
}

// We've overloaded the meaning of the BIND_OPTS flag
// BIND_JUSTTESTEXISTENCE to mean don't bind to junctions
// when evaluating paths...so check it here...
//
//  pbc         optional bind context (can be NULL)
//  pclsidSkip  optional CLSID to test. if null we test for skiping all
//              junction binding, not just on this specific CLSID
//
STDAPI_(BOOL) SHSkipJunctionBinding(IBindCtx *pbc, const CLSID *pclsidSkip)
{
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(BIND_OPTS), 0};  // Requires size filled in.
        return (SUCCEEDED(pbc->GetBindOptions(&bo)) &&
                bo.grfFlags == BIND_JUSTTESTEXISTENCE) ||
                (pclsidSkip && SHSkipJunction(pbc, pclsidSkip));     // should we skip this specific CLSID?
    }
    return FALSE;   // do junction binding, no context provided
}

// Bind file system object to storage.
// in:
//      dwFileAttributes    optional (-1)
//
STDAPI SHFileSysBindToStorage(LPCWSTR pszPath, DWORD dwFileAttributes, DWORD grfMode, DWORD grfFlags,
                              REFIID riid, void **ppv)
{
    if (-1 == dwFileAttributes)
    {
        TCHAR szPath[MAX_PATH];
        SHUnicodeToTChar(pszPath, szPath, ARRAYSIZE(szPath));
        dwFileAttributes = GetFileAttributes(szPath);
        if (-1 == dwFileAttributes)
            return STG_E_FILENOTFOUND;
    }

    WIN32_FIND_DATA wfd = {0};
    wfd.dwFileAttributes = dwFileAttributes;

    IBindCtx *pbc;
    HRESULT hr = SHCreateFileSysBindCtxEx(&wfd, grfMode, grfFlags, &pbc);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;

            hr = psfDesktop->ParseDisplayName(NULL, pbc, (LPWSTR)pszPath, NULL, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlLast;

                hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
                if (SUCCEEDED(hr))
                {
                    hr = psf->BindToStorage(pidlLast, pbc, riid, ppv);
                    psf->Release();
                }
                ILFree(pidl);
            }
            psfDesktop->Release();
        }
        pbc->Release();
    }
    return hr;
}


// return a relative IDList to pszFolder given the find data for that item

STDAPI SHCreateFSIDList(LPCTSTR pszFolder, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    LPITEMIDLIST pidl;

    *ppidl = NULL;

    if (PathCombine(szPath, pszFolder, pfd->cFileName))
    {
        hr = SHSimpleIDListFromFindData(szPath, pfd, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = SHILClone(ILFindLastID(pidl), ppidl);
            ILFree(pidl);
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI SHSimulateDropWithSite(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                              const POINTL *ppt, DWORD *pdwEffect, IUnknown *punkSite)
{
    if (punkSite)
        IUnknown_SetSite(pdrop, punkSite);

    HRESULT hr = SHSimulateDrop(pdrop, pdtobj, grfKeyState, ppt, pdwEffect);

    if (punkSite)
        IUnknown_SetSite(pdrop, NULL);

    return hr;
}

STDAPI SimulateDropWithPasteSucceeded(IDropTarget * pdrop, IDataObject * pdtobj,
                                      DWORD grfKeyState, const POINTL *ppt, DWORD dwEffect,
                                      IUnknown * punkSite, BOOL fClearClipboard)
{
    // simulate the drag drop protocol
    HRESULT hr = SHSimulateDropWithSite(pdrop, pdtobj, grfKeyState, ppt, &dwEffect, punkSite);

    if (SUCCEEDED(hr))
    {
        // these formats are put into the data object by the drop target code. this
        // requires the data object support ::SetData() for arbitrary data formats
        //
        // g_cfPerformedDropEffect effect is the reliable version of dwEffect (some targets
        // return dwEffect == DROPEFFECT_MOVE always)
        //
        // g_cfLogicalPerformedDropEffect indicates the logical action so we can tell the
        // difference between optmized and non optimized move

        DWORD dwPerformedEffect        = DataObj_GetDWORD(pdtobj, g_cfPerformedDropEffect, DROPEFFECT_NONE);
        DWORD dwLogicalPerformedEffect = DataObj_GetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, DROPEFFECT_NONE);

        if ((DROPEFFECT_MOVE == dwLogicalPerformedEffect) ||
            (DROPEFFECT_MOVE == dwEffect && DROPEFFECT_MOVE == dwPerformedEffect))
        {
            // communicate back the source data object
            // so they can complete the "move" if necessary

            DataObj_SetDWORD(pdtobj, g_cfPasteSucceeded, dwEffect);

            // if we just did a paste and we moved the files we cant paste
            // them again (because they moved!) so empty the clipboard

            if (fClearClipboard)
            {
                OleSetClipboard(NULL);
            }
        }
    }

    return hr;
}


STDAPI TransferDelete(HWND hwnd, HDROP hDrop, UINT fOptions)
{
    HRESULT hr = E_OUTOFMEMORY;
    DRAGINFO di = { sizeof(DRAGINFO), 0 };
    if (DragQueryInfo(hDrop, &di)) // di.lpFileList will be in TCHAR format -- see DragQueryInfo impl
    {
        FILEOP_FLAGS fFileop;
        if (fOptions & SD_SILENT)
        {
            fFileop = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_ALLOWUNDO;
        }
        else
        {
            fFileop = ((fOptions & SD_NOUNDO) || (GetAsyncKeyState(VK_SHIFT) < 0)) ? 0 : FOF_ALLOWUNDO;

            if (fOptions & SD_WARNONNUKE)
            {
                // we pass this so the user is warned that they will loose
                // data during a move-to-recycle bin operation
                fFileop |= FOF_WANTNUKEWARNING;
            }

            if (!(fOptions & SD_USERCONFIRMATION))
                fFileop |= FOF_NOCONFIRMATION;
        }

        SHFILEOPSTRUCT fo = {
            hwnd,
            FO_DELETE,
            di.lpFileList,
            NULL,
            fFileop,
        };

        int iErr = SHFileOperation(&fo);
        if ((0 == iErr) && fo.fAnyOperationsAborted)
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user canceled (at least something was canceled)
        }
        else
        {
            hr = HRESULT_FROM_WIN32(iErr);
        }
        SHFree(di.lpFileList);
    }
    return hr;
}


STDAPI DeleteFilesInDataObject(HWND hwnd, UINT uFlags, IDataObject *pdtobj, UINT fOptions)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        fOptions |= (uFlags & CMIC_MASK_FLAG_NO_UI) ? SD_SILENT : SD_USERCONFIRMATION;

        if ((uFlags & CMIC_MASK_SHIFT_DOWN) || (GetKeyState(VK_SHIFT) < 0))
        {
            fOptions |= SD_NOUNDO;
        }

        hr = TransferDelete(hwnd, (HDROP)medium.hGlobal, fOptions);

        ReleaseStgMedium(&medium);

        SHChangeNotifyHandleEvents();
    }
    return hr;
}

STDAPI GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidlLast, CLSID *pclsid)
{
    VARIANT var;
    HRESULT hr = psf->GetDetailsEx(pidlLast, &SCID_DESCRIPTIONID, &var);
    if (SUCCEEDED(hr))
    {
        SHDESCRIPTIONID did;
        if (VariantToBuffer(&var, (void *)&did, sizeof(did)))
        {
            *pclsid = did.clsid;
        }
        else
        {
            hr = E_FAIL;
        }

        VariantClear(&var);
    }
    return hr;
}

// in:
//      pidl    fully qualified IDList to test. we will bind to the
//              parent of this and ask it for the CLSID
// out:
//      pclsid  return the CLSID of the item

STDAPI GetCLSIDFromIDList(LPCITEMIDLIST pidl, CLSID *pclsid)
{
    IShellFolder2 *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        hr = GetItemCLSID(psf, pidlLast, pclsid);
        psf->Release();
    }
    return hr;
}

STDAPI _IsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid)
{
    HRESULT hr;
    LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
    if (pidlFirst)
    {
        CLSID clsid;

        hr = GetCLSIDFromIDList(pidlFirst, &clsid);

        if (SUCCEEDED(hr))
        {
            hr = (IsEqualCLSID(clsid, *pclsid) ? S_OK : S_FALSE);
        }
            
        ILFree(pidlFirst);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#ifdef DEBUG
// We do not want to use IsIDListInNameSpace in ASSERTs since this fct can fail.
// Instead, if we fail, we return TRUE.  This will mainly happen because of low memory
// conditions.
STDAPI_(BOOL) AssertIsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid)
{
    // We return FALSE only if we succeeded and determined that the pidl is NOT in
    // the namespace.
    return (S_FALSE != _IsIDListInNameSpace(pidl, pclsid));
}
#endif

// test to see if this IDList is in the net hood name space scoped by clsid
// for example pass CLSID_NetworkPlaces or CLSID_MyComputer

STDAPI_(BOOL) IsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid)
{
    return (S_OK == _IsIDListInNameSpace(pidl, pclsid));
}

#define FILE_ATTRIBUTE_SH (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)

struct {
    LPCTSTR pszFile;
    BOOL bDeleteIfEmpty;
    DWORD dwAttributes;
} const c_aFilesToFix[] = {
    // autoexec.bat and config.sys are not in this list because hiding them
    // breaks some 16 bit apps (yes, lame). but we deal with hiding those
    // files in the file system enumerator (it special cases such files)

    { TEXT("X:\\autoexec.000"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.old"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.bak"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.dos"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.win"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\config.dos"),   TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\config.win"),   TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\command.com"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\command.dos"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\logo.sys"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\msdos.---"),    FALSE,  FILE_ATTRIBUTE_SH },    // Win9x backup of msdos.*
    { TEXT("X:\\boot.ini"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\boot.bak"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\boot.---"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\bootsect.dos"), FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\bootlog.txt"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x first boot log
    { TEXT("X:\\bootlog.prv"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffastun.ffa"),  FALSE,  FILE_ATTRIBUTE_SH },    // Office 97 only used hidden, O2K uses SH
    { TEXT("X:\\ffastun.ffl"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffastun.ffx"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffastun0.ffx"), FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffstunt.ffl"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\sms.ini"),      FALSE,  FILE_ATTRIBUTE_SH },    // SMS
    { TEXT("X:\\sms.new"),      FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\sms_time.dat"), FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\smsdel.dat"),   FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\mpcsetup.log"), FALSE,  FILE_ATTRIBUTE_HIDDEN },// Microsoft Proxy Server
    { TEXT("X:\\detlog.txt"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win9x PNP detection log
    { TEXT("X:\\detlog.old"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win9x PNP detection log
    { TEXT("X:\\setuplog.txt"), FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\setuplog.old"), FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\suhdlog.dat"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\suhdlog.---"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\suhdlog.bak"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\system.1st"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win95 system.dat backup
    { TEXT("X:\\netlog.txt"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win9x network setup log file
    { TEXT("X:\\setup.aif"),    FALSE,  FILE_ATTRIBUTE_SH },    // NT4 unattended setup script
    { TEXT("X:\\catlog.wci"),   FALSE,  FILE_ATTRIBUTE_HIDDEN },// index server folder
    { TEXT("X:\\cmsstorage.lst"), FALSE,  FILE_ATTRIBUTE_SH },  // Microsoft Media Manager
};

void PathSetSystemDrive(TCHAR *pszPath)
{
    TCHAR szWin[MAX_PATH];
    
    if (GetWindowsDirectory(szWin, ARRAYSIZE(szWin)))
        *pszPath = szWin[0];
    else
        *pszPath = TEXT('C');   // try this in failure
}

void PrettyPath(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
    PathSetSystemDrive(szPath);
    PathMakePretty(PathFindFileName(szPath));  // fix up the file spec part

    MoveFile(pszPath, szPath);      // rename to the good name.
}

void DeleteEmptyFile(LPCTSTR pszPath)
{
    WIN32_FIND_DATA fd;
    HANDLE hfind = FindFirstFile(pszPath, &fd);
    if (hfind != INVALID_HANDLE_VALUE)
    {
        FindClose(hfind);
        if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
             (fd.nFileSizeHigh == 0) && (fd.nFileSizeLow == 0))
            DeleteFile(pszPath);
    }
}

STDAPI_(void) CleanupFileSystem()
{
    // try to fix up other variations of the windows folders that may
    // not be the current windir. this is to make dual boots and old installs
    // of windows have nicely cases file names when displayed in the explorer
    PrettyPath(TEXT("X:\\WINDOWS"));
    PrettyPath(TEXT("X:\\WINNT"));

    for (int i = 0; i < ARRAYSIZE(c_aFilesToFix); i++)
    {
        TCHAR szPath[MAX_PATH];
        HRESULT hr;

        hr = StringCchCopy(szPath, ARRAYSIZE(szPath), c_aFilesToFix[i].pszFile);
        if (SUCCEEDED(hr))
        {
            PathSetSystemDrive(szPath);

            if (c_aFilesToFix[i].bDeleteIfEmpty)
                DeleteEmptyFile(szPath);

            SetFileAttributes(szPath, c_aFilesToFix[i].dwAttributes);
        }
    }
}

// Always frees pidlToPrepend and *ppidl on failure
STDAPI SHILPrepend(LPITEMIDLIST pidlToPrepend, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    if (!*ppidl)
    {
        *ppidl = pidlToPrepend;
        hr = S_OK;
    }
    else
    {
        LPITEMIDLIST pidlSave = *ppidl;             // append to the list
        hr = SHILCombine(pidlToPrepend, pidlSave, ppidl);
        ILFree(pidlSave);
        ILFree(pidlToPrepend);
    }
    return hr;
}

// in:
//      pidlToAppend    this item is appended to *ppidl and freed
//
// in/out:
//      *ppidl  idlist to append to, if empty gets pidlToAppend
//
STDAPI SHILAppend(LPITEMIDLIST pidlToAppend, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    if (!*ppidl)
    {
        *ppidl = pidlToAppend;
        hr = S_OK;
    }
    else
    {
        LPITEMIDLIST pidlSave = *ppidl;             // append to the list
        hr = SHILCombine(pidlSave, pidlToAppend, ppidl);
        ILFree(pidlSave);
        ILFree(pidlToAppend);
    }
    return hr;
}


STDAPI SHSimpleIDListFromFindData(LPCTSTR pszPath, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    // Office 2000 does a SHChangeNotify(SHCNE_DELETE, ""), and
    // ParseDisplayName("") returns CSIDL_DRIVES for app compat,
    // so we must catch that case here and prevent Office from
    // delete your My Computer icon (!)

    if (pszPath[0])
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            IBindCtx *pbc;
            hr = SHCreateFileSysBindCtx(pfd, &pbc);
            if (SUCCEEDED(hr))
            {
                WCHAR wszPath[MAX_PATH];

                // Must use a private buffer because ParseDisplayName takes a non-const pointer
                SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));

                hr = psfDesktop->ParseDisplayName(NULL, pbc, wszPath, NULL, ppidl, NULL);
                pbc->Release();
            }
            psfDesktop->Release();
        }
    }
    else
        hr = E_INVALIDARG;

    if (FAILED(hr))
        *ppidl = NULL;
    return hr;
}

STDAPI SHSimpleIDListFromFindData2(IShellFolder *psf, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;  // assume failure

    IBindCtx *pbc;
    HRESULT hr = SHCreateFileSysBindCtx(pfd, &pbc);
    if (SUCCEEDED(hr))
    {
        WCHAR wszPath[MAX_PATH];
        // Must use a private buffer because ParseDisplayName takes a non-const pointer
        SHTCharToUnicode(pfd->cFileName, wszPath, ARRAYSIZE(wszPath));

        hr = psf->ParseDisplayName(NULL, pbc, wszPath, NULL, ppidl, NULL);
        pbc->Release();
    }
    return hr;
}

STDAPI_(LPITEMIDLIST) SHSimpleIDListFromPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHSimpleIDListFromFindData(pszPath, NULL, &pidl);
    ASSERT(SUCCEEDED(hr) ? pidl != NULL : pidl == NULL);
    return pidl;
}

// convert a full file system IDList into one relative to the a special folder
// For example,
//      pidlFS == [my computer] [c:] [windows] [desktop] [dir] [foo.txt]
// returns:
//      [dir] [foo.txt]
//
// returns NULL if no translation was performed

STDAPI_(LPITEMIDLIST) SHLogILFromFSIL(LPCITEMIDLIST pidlFS)
{
    LPITEMIDLIST pidlOut;
    SHILAliasTranslate(pidlFS, &pidlOut, XLATEALIAS_ALL); // will set pidlOut=NULL on failure
    return pidlOut;
}

//
// Returns:
//  The resource index (of SHELL232.DLL) of the appropriate icon.
//
STDAPI_(UINT) SILGetIconIndex(LPCITEMIDLIST pidl, const ICONMAP aicmp[], UINT cmax)
{
    UINT uType = (pidl->mkid.abID[0] & SHID_TYPEMASK);
    for (UINT i = 0; i < cmax; i++)
    {
        if (aicmp[i].uType == uType)
        {
            return aicmp[i].indexResource;
        }
    }

    return II_DOCUMENT;   // default
}


BOOL IsSelf(UINT cidl, LPCITEMIDLIST *apidl)
{
    return cidl == 0 || (cidl == 1 && (apidl == NULL || apidl[0] == NULL || ILIsEmpty(apidl[0])));
}

//
// GetIconLocationFromExt
//
// Given "txt" or ".txt" return "C:\WINNT\System32\Notepad.exe" and the index into this file for the icon.
//
// if pszIconPath/cchIconPath is too small, this api will fail
//
STDAPI GetIconLocationFromExt(IN LPTSTR pszExt, OUT LPTSTR pszIconPath, UINT cchIconPath, OUT LPINT piIconIndex)
{
    IAssocStore* pas;
    IAssocInfo* pai;
    HRESULT hr;

    RIPMSG(pszIconPath && IS_VALID_STRING_PTR(pszIconPath, cchIconPath), "GetIconLocationFromExt: caller passed bad pszIconPath");

    if (!pszExt || !pszExt[0] || !pszIconPath)
        return E_INVALIDARG;

    pszIconPath[0] = 0;

    pas = new CFTAssocStore();
    if (pas)
    {
        hr = pas->GetAssocInfo(pszExt, AIINIT_EXT, &pai);
        if (SUCCEEDED(hr))
        {
            DWORD cchSize = cchIconPath;
        
            hr = pai->GetString(AISTR_ICONLOCATION, pszIconPath, &cchSize); 
        
            if (SUCCEEDED(hr))
            {
                *piIconIndex = PathParseIconLocation(pszIconPath);
            }

            pai->Release();
        }
        delete pas;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


STDAPI SHFindFirstFile(LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind)
{
    HRESULT hr;

    // instead of the ...erm HACK in the reserved word (win95), use the super new (NT only) FindFileEx instead
    // this is not guaranteed to filter, it is a "hint" according to the manual
    FINDEX_SEARCH_OPS eOps = FindExSearchNameMatch;
    if (pfd->dwReserved0 == 0x56504347)
    {
        eOps = FindExSearchLimitToDirectories;
        pfd->dwReserved0 = 0;
    }

    *phfind = FindFirstFileEx(pszPath, FindExInfoStandard, pfd, eOps, NULL, 0);
    if (*phfind == INVALID_HANDLE_VALUE)
    {
        DWORD err = GetLastError();
        if ((err == ERROR_NO_MORE_FILES ||      // what dos returns
             err == ERROR_FILE_NOT_FOUND) &&    // win32 return for dir searches
            PathIsWild(pszPath))
        {
            // convert search to empty success (probalby a root)
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(err);
        }
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


void _GoModal(HWND hwnd, IUnknown *punkModless, BOOL fModal)
{
    if (hwnd)
    {
        IUnknown_EnableModless(punkModless, !fModal);
    }
}

// in:
//      hwnd    NULL means no UI
//      pfFromWNet The caller will pass this to us with it set to TRUE because they will assume
//              that any error value returned from this function will come from a WNet API.
//              We need to change this value to FALSE if it doesn't come from WNet so
//              the string version of the error number is not generated from WNet.
HRESULT _RetryNetwork(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, IN BOOL * pfFromWNet, WIN32_FIND_DATA *pfd, HANDLE *phfind)
{
    HRESULT hr;
    TCHAR szT[MAX_PATH];
    DWORD err;

    AssertMsg((TRUE == *pfFromWNet), TEXT("We assume that *pfFromWNet comes in TRUE.  Someone changed that behavior. -BryanSt"));
    if (PathIsUNC(pszPath))
    {
        NETRESOURCE rc = { 0, RESOURCETYPE_ANY, 0, 0, NULL, szT, NULL, NULL} ;

        hr = StringCchCopy(szT, ARRAYSIZE(szT), pszPath);
        if (FAILED(hr))
        {
            return hr;
        }

        PathStripToRoot(szT);

        _GoModal(hwnd, punkModless, TRUE);
        err = WNetAddConnection3(hwnd, &rc, NULL, NULL, (hwnd ? (CONNECT_TEMPORARY | CONNECT_INTERACTIVE) : CONNECT_TEMPORARY));
        if (WN_SUCCESS == err)
        {
            *pfFromWNet = FALSE;
        }

        _GoModal(hwnd, punkModless, FALSE);
    }
    else
    {
        TCHAR szDrive[4];

        szDrive[0] = pszPath[0];
        szDrive[1] = TEXT(':');
        szDrive[2] = 0;

        _GoModal(hwnd, punkModless, TRUE);

        DWORD dwFlags = 0;
        if (hwnd == NULL)
        {
            dwFlags |= WNRC_NOUI;
        }
        err = WNetRestoreConnection2(hwnd, szDrive, dwFlags, NULL);

        _GoModal(hwnd, punkModless, FALSE);
        if (err == WN_SUCCESS)
        {
            *pfFromWNet = FALSE;

            // refresh drive info... generate change notify
            szDrive[2] = TEXT('\\');
            szDrive[3] = 0;

            CMountPoint::NotifyReconnectedNetDrive(szDrive);
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_PATH, szDrive, NULL);
        }
        else if (err != ERROR_OUTOFMEMORY)
        {
            err = WN_CANCEL;    // user cancel (they saw UI) == ERROR_CANCELLED
        }
    }

    if (err == WN_SUCCESS)
        hr = SHFindFirstFile(pszPath, pfd, phfind);
    else
        hr = HRESULT_FROM_WIN32(err);

    return hr;
}


typedef struct {
    HWND hDlg;
    LPCTSTR pszPath;
    WIN32_FIND_DATA *pfd;
    HANDLE *phfind;
    HRESULT hr;
} RETRY_DATA;

STDAPI_(UINT) QueryCancelAutoPlayMsg()
{
    static UINT s_msgQueryCancelAutoPlay = 0;
    if (0 == s_msgQueryCancelAutoPlay)
        s_msgQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
    return s_msgQueryCancelAutoPlay;
}

BOOL IsQueryCancelAutoPlay(UINT uMsg)
{

    return uMsg == QueryCancelAutoPlayMsg();
}

#define IDT_RETRY    1

BOOL _IsUnformatedMediaResult(HRESULT hr)
{
    return hr == HRESULT_FROM_WIN32(ERROR_GEN_FAILURE) ||         // Win9x
           hr == HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_MEDIA) ||  // NT4
           hr == HRESULT_FROM_WIN32(ERROR_NOT_DOS_DISK) ||        // Could happen, I think.
           hr == HRESULT_FROM_WIN32(ERROR_SECTOR_NOT_FOUND) ||    // Happened on Magnatized disk
           hr == HRESULT_FROM_WIN32(ERROR_CRC) ||                 // Happened on Magnatized disk
           hr == HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_VOLUME);   // NT5
}

STDAPI_(BOOL) PathRetryRemovable(HRESULT hr, LPCTSTR pszPath)
{
    return (hr == HRESULT_FROM_WIN32(ERROR_NOT_READY) ||            // normal case
            hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)) &&   // SCSI ZIP drive does this
            PathIsRemovable(pszPath);
}


BOOL_PTR CALLBACK _OnTimeCheckDiskForInsert(HWND hDlg, RETRY_DATA *prd)
{
    BOOL_PTR fReturnValue = 0;

    prd->hr = SHFindFirstFile(prd->pszPath, prd->pfd, prd->phfind);
    // we are good or they inserted unformatted disk

    if (SUCCEEDED(prd->hr) || _IsUnformatedMediaResult(prd->hr))
    {
        EndDialog(hDlg, IDRETRY);
    }

    return fReturnValue;
}


BOOL_PTR CALLBACK RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RETRY_DATA *prd = (RETRY_DATA *)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        prd = (RETRY_DATA *)lParam;
        prd->hDlg = hDlg;
        {
            TCHAR szFormat[128], szText[MAX_PATH];
            HRESULT hr;
            GetDlgItemText(hDlg, IDD_TEXT, szFormat, ARRAYSIZE(szFormat));

            hr = StringCchPrintf(szText, ARRAYSIZE(szText), szFormat, prd->pszPath[0]);
            if (SUCCEEDED(hr))
            {
                SetDlgItemText(hDlg, IDD_TEXT, szText);
            }

            hr = StringCchCopy(szText, ARRAYSIZE(szText), prd->pszPath);
            if (SUCCEEDED(hr))
            {
                PathStripToRoot(szText);

                // get info about the file.
                SHFILEINFO sfi = {0};
                SHGetFileInfo(szText, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                    SHGFI_USEFILEATTRIBUTES |
                    SHGFI_ICON | SHGFI_LARGEICON | SHGFI_ADDOVERLAYS);

                ReplaceDlgIcon(prd->hDlg, IDD_ICON, sfi.hIcon);
            }
        }
        SetTimer(prd->hDlg, IDT_RETRY, 2000, NULL);
        break;

    case WM_DESTROY:
        ReplaceDlgIcon(prd->hDlg, IDD_ICON, NULL);
        break;

    case WM_TIMER:
        _OnTimeCheckDiskForInsert(hDlg, prd);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            prd->hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;
        }
        break;

    default:
        if (IsQueryCancelAutoPlay(uMsg))
        {
             SetWindowLongPtr(hDlg, DWLP_MSGRESULT,  1);  // cancel AutoPlay
             return TRUE;
        }
        return FALSE;
    }

    return TRUE;
}

// the removable media specific find first that does the UI prompt
// check for HRESULT_FROM_WIN32(ERROR_CANCELLED) for end user cancel

STDAPI FindFirstRetryRemovable(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind)
{
    RETRY_DATA rd = {0};
    TCHAR szPath[MAX_PATH];

    HRESULT hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
    if (SUCCEEDED(hr))
    {
        PathStripToRoot(szPath);
        hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

        if (PathAppend(szPath, TEXT("*.*")))
        {
            BOOL bPathChanged = (0 != StrCmpI(szPath, pszPath));

            rd.pszPath = szPath;
            rd.pfd = pfd;
            rd.phfind = phfind;
            rd.hr = E_OUTOFMEMORY;

            _GoModal(hwnd, punkModless, TRUE);
            DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_RETRYFOLDERENUM), hwnd, RetryDlgProc, (LPARAM)&rd);
            _GoModal(hwnd, punkModless, FALSE);
            if (SUCCEEDED(rd.hr))
            {
                if (bPathChanged)
                {
                    // strip produced another path, we need to retry on the requested path
                    if (S_OK == rd.hr)
                    {
                        FindClose(*phfind);
                    }
                    rd.hr = SHFindFirstFile(pszPath, pfd, phfind);
                }
            }
            hr = rd.hr;
        }
    }
    return hr;
}


/***********************************************************************\
        If the string was formatted as a UNC or Drive path, offer to
    create the directory path if it doesn't exist.

    PARAMETER:
        RETURN: S_OK It exists.
                FAILURE(): Caller should not display error UI because either
                        error UI was displayed or the user didn't want to create
                        the directory.
\***********************************************************************/
HRESULT _OfferToCreateDir(HWND hwnd, IUnknown *punkModless, LPCTSTR pszDir, DWORD dwFlags)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    int nResult = IDYES;

    hr  = StringCchCopy(szPath, ARRAYSIZE(szPath), pszDir);
    if (SUCCEEDED(hr))
    {
        PathRemoveFileSpec(szPath); // wild card removed

        if (SHPPFW_ASKDIRCREATE & dwFlags)
        {
            if (hwnd)
            {
                _GoModal(hwnd, punkModless, TRUE);
                nResult = ShellMessageBox(HINST_THISDLL, hwnd,
                                MAKEINTRESOURCE(IDS_CREATEFOLDERPROMPT),
                                MAKEINTRESOURCE(IDS_FOLDERDOESNTEXIST),
                                (MB_YESNO | MB_ICONQUESTION),
                                szPath);
                _GoModal(hwnd, punkModless, FALSE);
            }
            else
                nResult = IDNO;
        }

        if (IDYES == nResult)
        {
            _GoModal(hwnd, punkModless, TRUE);
            // SHCreateDirectoryEx() will display Error UI.
            DWORD err = SHCreateDirectoryEx(hwnd, szPath, NULL);
            hr = HRESULT_FROM_WIN32(err);
            _GoModal(hwnd, punkModless, FALSE);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);    // Until we get a valid directory, we can't do the download.
        }
    }

    return hr;
}


/***********************************************************************\
    See if the path w/o the spec exits.  Examples:
    pszPath="C:\dir1\dir2\*.*",           Test="C:\dir1\dir2\"
    pszPath="\\unc\share\dir1\dir2\*.*",  Test="\\unc\share\dir1\dir2\"
\***********************************************************************/
BOOL PathExistsWithOutSpec(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr;

    hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
    if (FAILED(hr))
    {
        return FALSE;
    }

    PathRemoveFileSpec(szPath);

    return PathFileExists(szPath);
}


/***********************************************************************\
    See if the Drive or UNC share exists.
    Examples:
    Path="C:\dir1\dir2\*.*",        Test="C:\"
    Path="\\unc\share\dir1\*.*",    Test="\\unc\share\"
\***********************************************************************/
BOOL PathExistsRoot(LPCTSTR pszPath)
{
    TCHAR szRoot[MAX_PATH];

    StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszPath);  // ok to truncate - hopefully all roots are below MAX_PATH
    PathStripToRoot(szRoot);

    return PathFileExists(szRoot);
}

inline DWORD _Win32FromHresult(HRESULT hr)
{
    //
    //  NOTE - we get back 0x28 on 'Lock'ed volumes
    //  however even though that is the error that FindFirstFile
    //  returns, there is no corresponding entry in
    //  winerror.h and format message doesnt yield anything useful,
    //  so we map it to ERROR_ACCESS_DENIED.
    //
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32
        && (HRESULT_CODE(hr) != 0x28))
        return HRESULT_CODE(hr);
    return ERROR_ACCESS_DENIED;
}

BOOL _IsMountedFolder(LPCTSTR pszPath, LPTSTR pszMountPath, UINT cchMountPath)
{
    BOOL fMountedOnFolder = FALSE;
    // first check if it is mounted on a folder
    if (GetVolumePathName(pszPath, pszMountPath, cchMountPath))
    {
        if ((0 != pszMountPath[2]) && (0 != pszMountPath[3]))
        {
            fMountedOnFolder = TRUE;
        }
    }
    return fMountedOnFolder;
}


// like the Win32 FindFirstFile() but post UI and returns errors in HRESULT
// in:
//      hwnd    NULL -> disable UI (but do net reconnects, etc)
//              non NULL enable UI including insert disk, format disk, net logon
//
// returns:
//      S_OK    hfind and find data are filled in with result
//      S_FALSE no results, but media is present (hfind == INVALID_HANDLE_VALUE)
//              (this is the empty enum case)
//      HRESULT_FROM_WIN32(ERROR_CANCELLED) - user saw UI, thus canceled the operation
//              or confirmed the failure
//      FAILED() win32 error codes in the hresult (path not found, file not found, etc)

STDAPI SHFindFirstFileRetry(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind, DWORD dwFlags)
{
    HANDLE hfindToClose = INVALID_HANDLE_VALUE;
    if (NULL == phfind)
        phfind = &hfindToClose;

    HRESULT hr = SHFindFirstFile(pszPath, pfd, phfind);

    if (FAILED(hr))
    {
        BOOL fNet = PathIsUNC(pszPath) || IsDisconnectedNetDrive(DRIVEID(pszPath));
        if (fNet)
        {
            hr = _RetryNetwork(hwnd, punkModless, pszPath, &fNet, pfd, phfind);
        }
        else if (hwnd)
        {
            if (PathRetryRemovable(hr, pszPath))
            {
                hr = FindFirstRetryRemovable(hwnd, punkModless, pszPath, pfd, phfind);
            }

            // disk should be in now, see if it needs format
            if (_IsUnformatedMediaResult(hr))
            {
                CMountPoint* pmtpt = CMountPoint::GetMountPoint(pszPath);
                if (pmtpt)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    if (pmtpt->IsFormattable())
                    {
                        TCHAR szMountPath[MAX_PATH];
                        if (_IsMountedFolder(pszPath, szMountPath, ARRAYSIZE(szMountPath)))
                        {
                            _GoModal(hwnd, punkModless, TRUE);
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_MVUNFORMATTED), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                                (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK),
                                                szMountPath);
                            _GoModal(hwnd, punkModless, FALSE);
                        }
                        else
                        {
                            int iDrive = PathGetDriveNumber(pszPath);
                            _GoModal(hwnd, punkModless, TRUE);
                            int nResult = ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_UNFORMATTED), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                               (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_YESNO),
                                               (DWORD)(iDrive + TEXT('A')));
                            _GoModal(hwnd, punkModless, FALSE);

                            if (IDYES == nResult)
                            {
                                _GoModal(hwnd, punkModless, TRUE);
                                DWORD dwError = SHFormatDrive(hwnd, iDrive, SHFMT_ID_DEFAULT, 0);
                                _GoModal(hwnd, punkModless, FALSE);

                                switch (dwError)
                                {
                                case SHFMT_ERROR:
                                case SHFMT_NOFORMAT:
                                    _GoModal(hwnd, punkModless, TRUE);
                                    ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_NOFMT), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                            (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK), (DWORD)(iDrive + TEXT('A')));
                                    _GoModal(hwnd, punkModless, FALSE);
                                    break;

                                default:
                                    hr = SHFindFirstFile(pszPath, pfd, phfind);  // try again after format
                                }
                            }
                        }
                    }
                    else
                    {
                        _GoModal(hwnd, punkModless, TRUE);
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_UNRECOGNIZED_DISK), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                            (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK),
                                            NULL);
                        _GoModal(hwnd, punkModless, FALSE);
                    }

                    pmtpt->Release();
                }
            }
        }

        // If the caller wants us to create the directory (with or without asking), we
        // need to see if we can display UI and if either that root exists (D:\ or \\unc\share\)
        // Note that for PERF we want to check the full path.
        if (FAILED_AND_NOT_CANCELED(hr) &&
            ((SHPPFW_DIRCREATE | SHPPFW_ASKDIRCREATE) & dwFlags) &&
             !PathExistsWithOutSpec(pszPath) && PathExistsRoot(pszPath))
        {
            hr = _OfferToCreateDir(hwnd, punkModless, pszPath, dwFlags);
            ASSERT(INVALID_HANDLE_VALUE == *phfind);

            if (SUCCEEDED(hr))
                hr = SHFindFirstFile(pszPath, pfd, phfind);  // try again after dir create
        }

        if (FAILED_AND_NOT_CANCELED(hr) && hwnd && !(SHPPFW_MEDIACHECKONLY & dwFlags))
        {
            DWORD err = _Win32FromHresult(hr);
            TCHAR szPath[MAX_PATH];

            UINT idTemplate = PathIsUNC(pszPath) ? IDS_ENUMERR_NETTEMPLATE2 : IDS_ENUMERR_FSTEMPLATE;    // "%2 is not accessible.\n\n%1"

            if (err == ERROR_PATH_NOT_FOUND)
                idTemplate = IDS_ENUMERR_PATHNOTFOUND;    // "%2 is not accessible.\n\nThis folder was moved or removed."

            hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
            if (SUCCEEDED(hr))
            {
                if (PathIsWild(szPath))
                    PathRemoveFileSpec(szPath); // wild card removed

                _GoModal(hwnd, punkModless, TRUE);
                SHEnumErrorMessageBox(hwnd, idTemplate, err, szPath, fNet, MB_OK | MB_ICONHAND);
                _GoModal(hwnd, punkModless, FALSE);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hfindToClose)
        FindClose(hfindToClose);

    return hr;
}

// TODO: Use the code in: \\orville\razzle\src\private\sm\sfc\dll\fileio.c to register
//       for CD/DVD inserts instead of constantly pegging the CPU and drive.  Too bad
//       it doesn't work for floppies.  SfcGetPathType(), RegisterForDevChange(),
//       SfcQueueCallback(), SfcIsTargetAvailable()
STDAPI SHPathPrepareForWrite(HWND hwnd, IUnknown *punkModless, LPCTSTR pwzPath, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pwzPath);
    if (SUCCEEDED(hr))
    {
        if (SHPPFW_IGNOREFILENAME & dwFlags)
            PathRemoveFileSpec(szPath);      // Strip file name so we just check the dir.

        // We can't do anything about just a UNC server. "\\server" (no share)
        if (!PathIsUNCServer(szPath))
        {
            HANDLE hFind;
            WIN32_FIND_DATA wfd;

            if (PathAppend(szPath, TEXT("*.*")))
            {
                hr = SHFindFirstFileRetry(hwnd, punkModless, szPath, &wfd, &hFind, dwFlags);
                if (S_OK == hr)
                    FindClose(hFind);
                else if (S_FALSE == hr)
                {
                    // S_FALSE from SHFindFirstFileRetry() means it exists but there
                    // isn't a handle.  We want to return S_OK for Yes, and E_FAIL or S_FALSE for no.
                    hr = S_OK;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
            }
        }
    }
    return hr;
}


STDAPI SHPathPrepareForWriteA(HWND hwnd, IUnknown *punkModless, LPCSTR pszPath, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH];

    SHAnsiToTChar(pszPath, szPath, ARRAYSIZE(szPath));
    return SHPathPrepareForWrite(hwnd, punkModless, szPath, dwFlags);
}

//
//  public export of SHBindToIDlist() has a slightly different
//  name so that we dont get compile link problems on legacy versions
//  of the shell.  shdocvw and browseui need to call SHBindToParentIDList()
STDAPI SHBindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    return SHBindToIDListParent(pidl, riid, ppv, ppidlLast);
}


// helper function to extract the target of a link file

STDAPI GetPathFromLinkFile(LPCTSTR pszLinkPath, LPTSTR pszTargetPath, int cchTargetPath)
{
    IShellLink* psl;
    HRESULT hr = LoadFromFile(CLSID_ShellLink, pszLinkPath, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        IShellLinkDataList* psldl;
        hr = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psldl));
        if (SUCCEEDED(hr))
        {
            EXP_DARWIN_LINK* pexpDarwin;

            hr = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
            if (SUCCEEDED(hr))
            {
                // woah, this is a darwin link. darwin links don't really have a path so we
                // will fail in this case
                SHUnicodeToTChar(pexpDarwin->szwDarwinID, pszTargetPath, cchTargetPath);
                LocalFree(pexpDarwin);
                hr = S_FALSE;
            }
            else
            {
                hr = psl->GetPath(pszTargetPath, cchTargetPath, NULL, NULL);

                // FEATURE: (reinerf) - we might try getting the path from the idlist if
                // pszTarget is empty (eg a link to "Control Panel" will return empyt string).

            }
            psldl->Release();
        }
        psl->Release();
    }

    return hr;
}

// a .EXE that is registered in the app paths key, this implies it is installed

STDAPI_(BOOL) PathIsRegisteredProgram(LPCTSTR pszPath)
{
    TCHAR szTemp[MAX_PATH];
    //
    //  PathIsBinaryExe() returns TRUE for .exe, .com
    //  PathIsExe()       returns TRUE for .exe, .com, .bat, .cmd, .pif
    //
    //  we dont want to treat .pif files as EXE files, because the
    //  user sees them as links.
    //
    return PathIsBinaryExe(pszPath) && PathToAppPath(pszPath, szTemp);
}

STDAPI_(void) ReplaceDlgIcon(HWND hDlg, UINT id, HICON hIcon)
{
    hIcon = (HICON)SendDlgItemMessage(hDlg, id, STM_SETICON, (WPARAM)hIcon, 0);
    if (hIcon)
        DestroyIcon(hIcon);
}

STDAPI_(LONG) GetOfflineShareStatus(LPCTSTR pcszPath)
{
    ASSERT(pcszPath);
    LONG lResult = CSC_SHARESTATUS_INACTIVE;
    HWND hwndCSCUI = FindWindow(STR_CSCHIDDENWND_CLASSNAME, NULL);
    if (hwndCSCUI)
    {
        COPYDATASTRUCT cds;
        cds.dwData = CSCWM_GETSHARESTATUS;
        cds.cbData = sizeof(WCHAR) * (lstrlenW(pcszPath) + 1);
        cds.lpData = (void *) pcszPath;
        lResult = (LONG)SendMessage(hwndCSCUI, WM_COPYDATA, 0, (LPARAM) &cds);
    }
    return lResult;
}

#define _FLAG_CSC_COPY_STATUS_LOCALLY_DIRTY         (FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED   | \
                                                     FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_DELETED         | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_CREATED)

// These are defined in shellapi.h, but require _WIN32_WINNT >= 0x0500.
// This file is currently compiled with _WIN32_WINNT = 0x0400.  Rather
// that futz with the compile settings, just #define duplicates here.
// They'd better not change (ever) since this is a documented API.
#ifndef OFFLINE_STATUS_LOCAL
#define OFFLINE_STATUS_LOCAL        0x0001
#define OFFLINE_STATUS_REMOTE       0x0002
#define OFFLINE_STATUS_INCOMPLETE   0x0004
#endif

STDAPI SHIsFileAvailableOffline(LPCWSTR pwszPath, LPDWORD pdwStatus)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szUNC[MAX_PATH];

    szUNC[0] = 0;

    if (pdwStatus)
    {
        *pdwStatus = 0;
    }

    //
    // Need full UNC path (TCHAR) for calling CSC APIs.
    // (Non-net paths are "not cached" by definition.)
    //
    if (pwszPath && pwszPath[0])
    {
        if (PathIsUNCW(pwszPath))
        {
            SHUnicodeToTChar(pwszPath, szUNC, ARRAYSIZE(szUNC));
        }
        else if (L':' == pwszPath[1] && L':' != pwszPath[0])
        {
            // Check for mapped net drive
            TCHAR szPath[MAX_PATH];
            SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath));

            DWORD dwLen = ARRAYSIZE(szUNC);
            if (S_OK == SHWNetGetConnection(szPath, szUNC, &dwLen))
            {
                // Got \\server\share, append the rest
                if (!PathAppend(szUNC, PathSkipRoot(szPath)))
                {
                    szUNC[0] = TEXT('\0');
                    hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                }
            }
            // else not mapped
        }
    }

    // Do we have a UNC path?
    if (szUNC[0])
    {
        // Assume CSC not running
        hr = E_FAIL;

        if (CSCIsCSCEnabled())
        {
            DWORD dwCscStatus = 0;

            // Assume cached
            hr = S_OK;

            if (!CSCQueryFileStatus(szUNC, &dwCscStatus, NULL, NULL))
            {
                // Not cached, return failure
                DWORD dwErr = GetLastError();
                if (ERROR_SUCCESS == dwErr)
                    dwErr = ERROR_PATH_NOT_FOUND;
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            else if (pdwStatus)
            {
                // File is cached, and caller wants extra status info
                DWORD dwResult = 0;
                BOOL bDirty = FALSE;

                // Is it a sparse file?
                // Note: CSC always marks directories as sparse
                if ((dwCscStatus & FLAG_CSC_COPY_STATUS_IS_FILE) &&
                    (dwCscStatus & FLAG_CSC_COPY_STATUS_SPARSE))
                {
                    dwResult |= OFFLINE_STATUS_INCOMPLETE;
                }

                // Is it dirty?
                if (dwCscStatus & _FLAG_CSC_COPY_STATUS_LOCALLY_DIRTY)
                {
                    bDirty = TRUE;
                }

                // Get share status
                PathStripToRoot(szUNC);
                dwCscStatus = 0;
                if (CSCQueryFileStatus(szUNC, &dwCscStatus, NULL, NULL))
                {
                    if (dwCscStatus & FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP)
                    {
                        // Server offline --> all opens are local (only)
                        dwResult |= OFFLINE_STATUS_LOCAL;
                    }
                    else if (bDirty)
                    {
                        // Server online, but file is dirty --> open is remote
                        dwResult |= OFFLINE_STATUS_REMOTE;
                    }
                    else
                    {
                        // Server is online and file is in sync --> open is both
                        dwResult |= OFFLINE_STATUS_LOCAL | OFFLINE_STATUS_REMOTE;

                        if ((dwCscStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_VDO)
                        {
                            // Feature: (JeffreyS) The share is VDO, but that only affects files
                            // opened for execution. Is there a way to tell whether
                            // the file is only open locally?
                        }
                    }
                }
                else
                {
                    // Very strange. CSCQueryFileStatus succeeded for the file,
                    // but failed for the share.  Assume no active connection
                    // exists and the server is online (open both).
                    dwResult |= OFFLINE_STATUS_LOCAL | OFFLINE_STATUS_REMOTE;
                }

                *pdwStatus = dwResult;
            }
        }
    }

    return hr;
}

STDAPI_(BOOL) GetShellClassInfo(LPCTSTR pszPath, LPTSTR pszKey, LPTSTR pszBuffer, DWORD cchBuffer)
{
    *pszBuffer = 0;

    TCHAR szIniFile[MAX_PATH];
    if (PathCombine(szIniFile, pszPath, TEXT("Desktop.ini")))
    {
        return (SHGetIniString(TEXT(".ShellClassInfo"), pszKey, pszBuffer, cchBuffer, szIniFile) ? TRUE : FALSE);
    }
    else
    {
        return FALSE;
    }
}

STDAPI GetShellClassInfoInfoTip(LPCTSTR pszPath, LPTSTR pszBuffer, DWORD cchBuffer)
{
    HRESULT hr;

    if (GetShellClassInfo(pszPath, TEXT("InfoTip"), pszBuffer, cchBuffer))
    {
        hr = SHLoadIndirectString(pszBuffer, pszBuffer, cchBuffer, NULL);
    }
    else
    {
        if (cchBuffer > 0)
        {
            *pszBuffer = 0;
        }
        hr = E_FAIL;
    }

    return hr;
}

TCHAR const c_szUserAppData[] = TEXT("%userappdata%");

HRESULT ExpandUserAppData(LPTSTR pszFile, int cch)
{
    HRESULT hr = S_OK;

    //Check if the given string has %UserAppData%
    LPTSTR psz = StrChr(pszFile, TEXT('%'));
    if (psz)
    {
        if (!StrCmpNI(psz, c_szUserAppData, ARRAYSIZE(c_szUserAppData)-1))
        {
            TCHAR szTempBuff[MAX_PATH];
            if (SHGetSpecialFolderPath(NULL, szTempBuff, CSIDL_APPDATA, TRUE))
            {
                if (PathAppend(szTempBuff, psz + lstrlen(c_szUserAppData)))
                {
                    int cchRemaining = pszFile + cch - psz;

                    //Copy back to the input buffer!
                    hr = StringCchCopy(psz, cchRemaining, szTempBuff);   // not ok to truncate, but we check'd size
                }
            }
        }
    }
    return hr;
}


TCHAR const c_szWebDir[] = TEXT("%WebDir%");
HRESULT ExpandWebDir(LPTSTR pszFile, int cch)
{
    HRESULT hr = S_OK;

    //Check if the given string has %WebDir%
    LPTSTR psz = StrChr(pszFile, TEXT('%'));
    if (psz)
    {
        if (!StrCmpNI(psz, c_szWebDir, ARRAYSIZE(c_szWebDir) - 1))
        {
            //Skip the %WebDir% string plus the following backslash.
            LPTSTR pszPathAndFileName = psz + lstrlen(c_szWebDir) + sizeof('\\');
            if (pszPathAndFileName && (pszPathAndFileName != psz))
            {
                TCHAR szTempBuff[MAX_PATH];

                hr = StringCchCopy(szTempBuff, ARRAYSIZE(szTempBuff), pszPathAndFileName);
                if (SUCCEEDED(hr))
                {
                    hr = SHGetWebFolderFilePath(szTempBuff, pszFile, cch);
                }
            }
        }
    }
    return hr;
}


HRESULT ExpandOtherVariables(LPTSTR pszFile, int cch)
{
    HRESULT hr = ExpandUserAppData(pszFile, cch);
    if (SUCCEEDED(hr))
    {
        hr = ExpandWebDir(pszFile, cch);
    }

    return hr;
}


HRESULT SubstituteWebDir(LPTSTR pszFile, int cch)
{
    HRESULT hr = S_OK;
    TCHAR szWebDirPath[MAX_PATH];

    if (SUCCEEDED(SHGetWebFolderFilePath(TEXT("folder.htt"), szWebDirPath, ARRAYSIZE(szWebDirPath))))
    {
        LPTSTR pszWebDirPart;

        PathRemoveFileSpec(szWebDirPath);

        pszWebDirPart = StrStrI(pszFile, szWebDirPath);
        if (pszWebDirPart)
        {
            TCHAR szTemp[MAX_PATH];
            int cchBeforeWebDir = (int)(pszWebDirPart - pszFile);

            // copy the part after C:\WINNT\Web into szTemp
            hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszWebDirPart + lstrlen(szWebDirPath));
            if (SUCCEEDED(hr))
            {
                // replace C:\WINNT\Web with %WebDir%
                hr = StringCchCopy(pszWebDirPart, cch - cchBeforeWebDir, c_szWebDir);
                if (SUCCEEDED(hr))
                {
                    // add back on the part that came after
                    hr = StringCchCat(pszFile, cch, szTemp);
                }
            }
        }
    }
    return hr;
}

STDAPI_(BOOL) IsExplorerBrowser(IShellBrowser *psb)
{
    HWND hwnd;
    return psb && SUCCEEDED(psb->GetControlWindow(FCW_TREE, &hwnd)) && hwnd;
}

STDAPI_(BOOL) IsExplorerModeBrowser(IUnknown *psite)
{
    BOOL bRet = FALSE;
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        bRet = IsExplorerBrowser(psb);
        psb->Release();
    }
    return bRet;
}

STDAPI InvokeFolderPidl(LPCITEMIDLIST pidl, int nCmdShow)
{
    SHELLEXECUTEINFO ei = {0};
    LPITEMIDLIST pidlFree = NULL;

    if (IS_INTRESOURCE(pidl))
    {
        pidlFree = SHCloneSpecialIDList(NULL, PtrToUlong((void *)pidl), FALSE);
        pidl = pidlFree;
    }

    ei.cbSize = sizeof(ei);
    ei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME | SEE_MASK_FLAG_DDEWAIT;
    ei.lpIDList = (void *)pidl;
    ei.nShow = nCmdShow;
    ei.lpClass = c_szFolderClass;

    HRESULT hr = ShellExecuteEx(&ei) ? S_OK : HRESULT_FROM_WIN32(GetLastError());

    ILFree(pidlFree);

    return hr;
}


HRESULT GetRGBFromBStr(BSTR bstr, COLORREF *pclr)
{
    *pclr = CLR_INVALID;

    HRESULT  hr = E_FAIL;
    if (bstr)
    {
        TCHAR szTemp[9], szColor[11] = {'0','x',0, };

        SHUnicodeToTChar(bstr, szTemp, ARRAYSIZE(szTemp));

        LPTSTR pszPound = StrChr(szTemp, TEXT('#'));
        if (pszPound)
            pszPound++; //Skip the pound sign!
        else
            pszPound = szTemp;  //Pound sign is missing. Use the whole strng

        StringCchCat(szColor, ARRAYSIZE(szColor), pszPound);   // ok to truncate

        INT rgb;
        if (StrToIntEx(szColor, STIF_SUPPORT_HEX, &rgb))
        {
            *pclr = (COLORREF)(((rgb & 0x000000ff) << 16) | (rgb & 0x0000ff00) | ((rgb & 0x00ff0000) >> 16));
            hr = S_OK;
        }
    }
    return hr;
}

STDAPI IUnknown_HTMLBackgroundColor(IUnknown *punk, COLORREF *pclr)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IHTMLDocument2 *pDoc;
        hr = punk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
        if (SUCCEEDED(hr))
        {
            VARIANT v;

            v.vt = VT_BSTR;
            v.bstrVal = NULL;

            hr = pDoc->get_bgColor(&v);
            if (SUCCEEDED(hr))
            {
                hr = GetRGBFromBStr(v.bstrVal, pclr);
                VariantClear(&v);
            }
            pDoc->Release();
        }
    }
    return hr;
}

STDAPI_(int) MapSCIDToColumn(IShellFolder2* psf2, const SHCOLUMNID* pscid)
{
    int i = 0;
    SHCOLUMNID scid;
    while (SUCCEEDED(psf2->MapColumnToSCID(i, &scid)))
    {
        if (IsEqualSCID(scid, *pscid))
            return i;
        i++;
    }
    return 0;
}

#ifdef COLUMNS_IN_DESKTOPINI
#define IsDigit(c) ((c) >= TEXT('0') && c <= TEXT('9'))

STDAPI _GetNextCol(LPTSTR* ppszText, DWORD* pnCol)
{
    HRESULT hr = S_OK;
    TCHAR *pszText;

    if (*ppszText[0])
    {
        pszText = StrChrI(*ppszText, TEXT(','));
        if (pszText)
        {
            *pszText = 0;
            *pnCol = StrToInt(*ppszText);
            *ppszText = ++pszText;
        }
        else if (IsDigit(*ppszText[0]))
        {
            *pnCol = StrToInt(*ppszText);
            *ppszText = 0;
        }
    }
    else
        hr = E_FAIL;

    return hr;
}
#endif




STDAPI_(int) DPA_ILFreeCallback(void *p, void *d)
{
    ILFree((LPITEMIDLIST)p);    // ILFree checks for NULL pointer
    return 1;
}

STDAPI_(void) DPA_FreeIDArray(HDPA hdpa)
{
    if (hdpa)
        DPA_DestroyCallback(hdpa, DPA_ILFreeCallback, 0);
}

STDAPI_(void) EnableAndShowWindow(HWND hWnd, BOOL bShow)
{
    ShowWindow(hWnd, bShow ? SW_SHOW : SW_HIDE);
    EnableWindow(hWnd, bShow);
}


//
// Helper function which returns a string value instead of the SHELLDETAILS
// object, to be used by clients which are only interested in the returned
// string value and want to avoid the hassle of doing a STRRET to STR conversion,
//
STDAPI DetailsOf(IShellFolder2 *psf2, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch)
{
    *psz = 0;
    SHELLDETAILS sd;
    HRESULT hr = psf2->GetDetailsOf(pidl, flags, &sd);
    if (SUCCEEDED(hr))
    {
        hr = StrRetToBuf(&sd.str, pidl, psz, cch);
    }
    return hr;
}

#pragma warning(push,4)

//  --------------------------------------------------------------------------
//  ::SHGetUserDisplayName
//
//  Arguments:  pszDisplayName  =   Buffer to retrieve the display name.
//              puLen           =   [in/out] Size of buffer
//
//  Purpose:    Returns the display name, or the logon name if the display name
//              is not available
//
//  Returns:    HRESULT
//
//
//
//  History:    2000-03-03  vtan        created
//              2001-03-01  fabriced    use GetUserNameEx
//  --------------------------------------------------------------------------

STDAPI  SHGetUserDisplayName (LPWSTR pszDisplayName, PULONG puLen)

{
    HRESULT     hr;

    //  Validate pszDisplayName.

    if ((pszDisplayName == NULL) || (puLen == NULL))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = S_OK;
        if (!GetUserNameEx(NameDisplay, pszDisplayName, puLen))
        {
            TCHAR szName[UNLEN+1];
            DWORD dwLen = ARRAYSIZE(szName);
            DWORD dwLastError = GetLastError();
            if (GetUserName(szName, &dwLen))
            {
                // If we are not on a domain, GetUserNameEx does not work :-(.
                if (dwLastError == ERROR_NONE_MAPPED)
                {
                    PUSER_INFO_2                pUserInfo;

                    DWORD dwErrorCode = NetUserGetInfo(NULL,  // Local account
                                                 szName,
                                                 2,
                                                 reinterpret_cast<LPBYTE*>(&pUserInfo));
                    if (ERROR_SUCCESS == dwErrorCode)
                    {
                        if (pUserInfo->usri2_full_name[0] != L'\0')
                        {
                            hr = StringCchCopy(pszDisplayName, *puLen, pUserInfo->usri2_full_name);
                            if (SUCCEEDED(hr))
                            {
                                *puLen = lstrlen(pUserInfo->usri2_full_name) + 1;
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                        TW32(NetApiBufferFree(pUserInfo));
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwErrorCode);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(dwLastError);
                }

                if (FAILED(hr))
                {
                    hr = StringCchCopy(pszDisplayName, *puLen, szName);
                    if (SUCCEEDED(hr))
                    {
                        *puLen = dwLen;
                    }
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    return hr;
}

//  --------------------------------------------------------------------------
//  ::SHIsCurrentThreadInteractive
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Determine whether the current thread is running on the
//              interactive desktop. This takes into account terminal services
//              and console disconnects as well.
//
//  History:    2000-03-23  vtan        created
//  --------------------------------------------------------------------------

STDAPI_(BOOL) SHIsCurrentThreadInteractive (void)
{
    BOOL fResult = FALSE;

    //  Open handles to the current process window station and thread
    //  desktop. These handles do NOT need to be closed.

    HWINSTA hWindowStation = GetProcessWindowStation();
    if (hWindowStation != NULL)
    {
        HDESK hDesktop = GetThreadDesktop(GetCurrentThreadId());
        if (hDesktop != NULL)
        {
            DWORD dwLengthNeeded = 0;
            (BOOL)GetUserObjectInformation(hWindowStation, UOI_NAME, NULL, 0, &dwLengthNeeded);
            if (dwLengthNeeded != 0)
            {
                TCHAR *pszWindowStationName = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwLengthNeeded));
                if (pszWindowStationName != NULL)
                {
                    if (GetUserObjectInformation(hWindowStation, UOI_NAME, pszWindowStationName, dwLengthNeeded, &dwLengthNeeded) != FALSE)
                    {
                        dwLengthNeeded = 0;
                        (BOOL)GetUserObjectInformation(hDesktop, UOI_NAME, NULL, 0, &dwLengthNeeded);
                        if (dwLengthNeeded != 0)
                        {
                            TCHAR *pszDesktopName = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwLengthNeeded));
                            if (pszDesktopName != NULL)
                            {
                                if (GetUserObjectInformation(hDesktop, UOI_NAME, pszDesktopName, dwLengthNeeded, &dwLengthNeeded) != FALSE)
                                {
                                    //  This is a hard coded string comparison. This name
                                    //  never changes WinSta0\Default

                                    if (lstrcmpi(pszWindowStationName, TEXT("WinSta0")) == 0)
                                    {
                                        fResult = (lstrcmpi(pszDesktopName, TEXT("WinLogon")) != 0 &&
                                                lstrcmpi(pszDesktopName, TEXT("Screen-Saver")) != 0);
                                    }
                                }
                                LocalFree(pszDesktopName);
                            }
                        }
                    }
                    LocalFree(pszWindowStationName);
                }
            }
        }
    }
    return fResult;
}

static  const TCHAR     s_szBaseKeyName[]           =   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail");
static  const TCHAR     s_szMessageCountValueName[] =   TEXT("MessageCount");
static  const TCHAR     s_szTimeStampValueName[]    =   TEXT("TimeStamp");
static  const TCHAR     s_szApplicationValueName[]  =   TEXT("Application");

//  --------------------------------------------------------------------------
//  ReadSingleUnreadMailCount
//
//  Arguments:  hKey                    =   Base HKEY to read info from.
//              pdwCount                =   Count returned.
//              pFileTime               =   FILETIME stamp returned.
//              pszShellExecuteCommand  =   Execute command returned.
//              cchShellExecuteCommand  =   Size of execute command buffer.
//
//  Returns:    LONG
//
//  Purpose:    Reads a single unread mail account information from the given
//              HKEY of the mail account.
//
//  History:    2000-06-20  vtan        created
//  --------------------------------------------------------------------------

LONG    ReadSingleUnreadMailCount (HKEY hKey, DWORD *pdwCount, FILETIME *pFileTime, LPTSTR pszShellExecuteCommand, int cchShellExecuteCommand)

{
    LONG    lError;
    DWORD   dwType, dwData, dwDataSize;

    dwDataSize = sizeof(*pdwCount);
    lError = RegQueryValueEx(hKey,
                             s_szMessageCountValueName,
                             NULL,
                             &dwType,
                             reinterpret_cast<LPBYTE>(&dwData),
                             &dwDataSize);
    if (ERROR_SUCCESS == lError)
    {
        FILETIME    fileTime;

        if ((pdwCount != NULL) && (REG_DWORD == dwType))
        {
            *pdwCount = dwData;
        }
        dwDataSize = sizeof(fileTime);
        lError = RegQueryValueEx(hKey,
                                 s_szTimeStampValueName,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>(&fileTime),
                                 &dwDataSize);
        if (ERROR_SUCCESS == lError)
        {
            TCHAR   szTemp[512];

            if ((pFileTime != NULL) && (REG_BINARY == dwType))
            {
                *pFileTime = fileTime;
            }
            dwDataSize = sizeof(szTemp);
            lError = SHQueryValueEx(hKey,
                                    s_szApplicationValueName,
                                    NULL,
                                    &dwType,
                                    reinterpret_cast<LPBYTE>(szTemp),
                                    &dwDataSize);
            if (ERROR_SUCCESS == lError)
            {
                if ((pszShellExecuteCommand != NULL) && (REG_SZ == dwType))
                {
                    HRESULT hr = StringCchCopy(pszShellExecuteCommand, cchShellExecuteCommand, szTemp);
                    if (FAILED(hr))
                    {
                        lError = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            }
        }
    }
    return lError;
}

//  --------------------------------------------------------------------------
//  ::SHEnumerateUnreadMailAccounts
//
//  Arguments:  hKeyUser        =   HKEY to user's hive.
//              dwIndex         =   Index of mail account.
//              pszMailAddress  =   Returned mail address for account.
//              cchMailAddress  =   Characters in mail address buffer.
//
//  Returns:    HRESULT
//
//  Purpose:    Given an index returns the actual indexed email account from
//              the given user's hive.
//
//  History:    2000-06-29  vtan        created
//  --------------------------------------------------------------------------

STDAPI  SHEnumerateUnreadMailAccounts (HKEY hKeyUser, DWORD dwIndex, LPTSTR pszMailAddress, int cchMailAddress)

{
    HRESULT     hr;
    LONG        lError;
    HKEY        hKey;

    //  Open the unread mail

    lError = RegOpenKeyEx(hKeyUser != NULL ? hKeyUser : HKEY_CURRENT_USER,
                          s_szBaseKeyName,
                          0,
                          KEY_ENUMERATE_SUB_KEYS,
                          &hKey);
    if (ERROR_SUCCESS == lError)
    {
        DWORD       dwMailAddressSize;
        FILETIME    ftLastWriteTime;

        //  Get the given index mail address.

        dwMailAddressSize = static_cast<DWORD>(cchMailAddress);
        lError = RegEnumKeyEx(hKey,
                              dwIndex,
                              pszMailAddress,
                              &dwMailAddressSize,
                              NULL,
                              NULL,
                              NULL,
                              &ftLastWriteTime);
        if (ERROR_SUCCESS != lError)
        {
            pszMailAddress[0] = TEXT('\0');
        }
        TW32(RegCloseKey(hKey));
    }
    if (ERROR_SUCCESS == lError)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lError);
    }
    return hr;
}

//  --------------------------------------------------------------------------
//  ::SHGetUnreadMailCount
//
//  Arguments:  hKeyUser                =   HKEY to user's hive.
//              pszMailAddress          =   Mail address for account.
//              pdwCount                =   Number of unread messages.
//              pszShellExecuteCommand  =   Execution command for application.
//              cchShellExecuteCommand  =   Number of characters in buffer.
//
//  Returns:    HRESULT
//
//  Purpose:    Reads unread mail messages for the given user and mail
//              address. If being run in a user's environment then hKeyUser
//              should be NULL. This will use HKEY_CURRENT_USER. If being run
//              from the SYSTEM context this will be HKEY_USERS\{SID}.
//
//              Callers may pass NULL for output parameters if not required.
//
//  History:    2000-06-20  vtan        created
//  --------------------------------------------------------------------------

STDAPI  SHGetUnreadMailCount (HKEY hKeyUser, LPCTSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPTSTR pszShellExecuteCommand, int cchShellExecuteCommand)

{
    HRESULT     hr;
    LONG        lError;
    HKEY        hKey;
    TCHAR       szTemp[512];

    //  Validate parameters. Valid parameters actually depends on pszMailAddress
    //  If pszMailAddress is NULL then the total unread mail count for ALL accounts
    //  is returned and pszShellExecuteCommand is ignored and MUST be
    //  NULL. pFileTime can be null and if so it is ignored but if it is non null, it
    //  is a filter to show only unread mail entries that are newer than the specified 
    //  filetime. Otherwise only items for the specified mail account are returned.

    if (pszMailAddress == NULL)
    {
        if ((pszShellExecuteCommand != NULL) ||
            (cchShellExecuteCommand != 0))
        {
            return E_INVALIDARG;
        }
        else
        {
            LONG    lError;

            *pdwCount = 0;
            lError = RegOpenKeyEx(hKeyUser != NULL ? hKeyUser : HKEY_CURRENT_USER,
                                  s_szBaseKeyName,
                                  0,
                                  KEY_ENUMERATE_SUB_KEYS,
                                  &hKey);
            if (ERROR_SUCCESS == lError)
            {
                DWORD       dwIndex, dwTempSize;
                FILETIME    ftLastWriteTime;

                //  Because this uses advapi32!RegEnumKeyEx and this returns items
                //  in an arbitrary order and is subject to indeterminate behavior
                //  when keys are added while the key is enumerated there exists a
                //  possible race condition / dual access problem. Deal with this
                //  if it shows up. It's possible for a mail application to write
                //  information at the exact time this loop is retrieving the
                //  information. Slim chance but still possible.

                dwIndex = 0;
                do
                {
                    dwTempSize = ARRAYSIZE(szTemp);
                    lError = RegEnumKeyEx(hKey,
                                          dwIndex++,
                                          szTemp,
                                          &dwTempSize,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &ftLastWriteTime);
                    if (ERROR_SUCCESS == lError)
                    {
                        HKEY    hKeyMailAccount;

                        lError = RegOpenKeyEx(hKey,
                                              szTemp,
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKeyMailAccount);
                        if (ERROR_SUCCESS == lError)
                        {
                            DWORD   dwCount;
                            FILETIME ft;

                            lError = ReadSingleUnreadMailCount(hKeyMailAccount, &dwCount, &ft, NULL, 0);
                            
                            if (ERROR_SUCCESS == lError)
                            {
                                BOOL ftExpired = false;
                                // If they pass in a pFileTime, use it as a filter and only
                                // count accounts that have been updated since the passed
                                // in file time
                                if (pFileTime)
                                {
                                    ftExpired = (CompareFileTime(&ft, pFileTime) < 0);
                                }

                                if (!ftExpired)
                                {
                                    *pdwCount += dwCount;
                                }
                            }
                            TW32(RegCloseKey(hKeyMailAccount));
                        }
                    }
                } while (ERROR_SUCCESS == lError);

                //  Ignore the ERROR_NO_MORE_ITEMS that is returned when the
                //  enumeration is done.

                if (ERROR_NO_MORE_ITEMS == lError)
                {
                    lError = ERROR_SUCCESS;
                }
                TW32(RegCloseKey(hKey));
            }
            if (ERROR_SUCCESS == lError)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
        }
    }
    else
    {
        //  Calculate the length of the registry path where we will create the
        //  key that will store the values. This is:
        //
        //  HKCU\Software\Microsoft\Windows\CurrentVersion\UnreadMail\{MailAddr}
        //
        //  Note that a NULL terminator is not used in the comparison because
        //  ARRAYSIZE on the static string is used which includes '\0'.

        hr = StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%s\\%s"), s_szBaseKeyName, pszMailAddress);
        if (SUCCEEDED(hr))
        {
            lError = RegOpenKeyEx(hKeyUser != NULL ? hKeyUser : HKEY_CURRENT_USER,
                                  szTemp,
                                  0,
                                  KEY_QUERY_VALUE,
                                  &hKey);
            if (ERROR_SUCCESS == lError)
            {
                lError = ReadSingleUnreadMailCount(hKey, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
                TW32(RegCloseKey(hKey));
            }
            if (ERROR_SUCCESS == lError)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
        }
    }
    return hr;
}

//  --------------------------------------------------------------------------
//  ::SHSetUnreadMailCount
//
//  Arguments:  pszMailAddress          =   Mail address for account.
//              dwCount                 =   Number of unread messages.
//              pszShellExecuteCommand  =   Execution command for application.
//
//  Returns:    HRESULT
//
//  Purpose:    Writes unread mail information to the registry for the
//              current user. Do NOT call this API from a system process
//              impersonating a user because it uses HKEY_CURRENT_USER. If
//              this is required in future a thread impersonation token
//              check will be required.
//
//  History:    2000-06-19  vtan        created
//  --------------------------------------------------------------------------

STDAPI  SHSetUnreadMailCount (LPCTSTR pszMailAddress, DWORD dwCount, LPCTSTR pszShellExecuteCommand)

{
    HRESULT     hr;
    TCHAR       szTemp[512];

    //  Calculate the length of the registry path where we will create the
    //  key that will store the values. This is:
    //
    //  HKCU\Software\Microsoft\Windows\CurrentVersion\UnreadMail\{MailAddr}
    //
    //  Note that a NULL terminator is not used in the comparison because
    //  ARRAYSIZE on the static string is used which includes '\0'.

    hr = StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%s\\%s"), s_szBaseKeyName, pszMailAddress);
    if (SUCCEEDED(hr))
    {
        LONG    lError;
        DWORD   dwDisposition;
        HKEY    hKey;

        lError = RegCreateKeyEx(HKEY_CURRENT_USER,
                                szTemp,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE,
                                NULL,
                                &hKey,
                                &dwDisposition);
        if (ERROR_SUCCESS == lError)
        {
            lError = RegSetValueEx(hKey,
                                   s_szMessageCountValueName,
                                   0,
                                   REG_DWORD,
                                   reinterpret_cast<LPBYTE>(&dwCount),
                                   sizeof(dwCount));
            if (ERROR_SUCCESS == lError)
            {
                FILETIME    fileTime;

                GetSystemTimeAsFileTime(&fileTime);
                lError = RegSetValueEx(hKey,
                                       s_szTimeStampValueName,
                                       0,
                                       REG_BINARY,
                                       reinterpret_cast<LPBYTE>(&fileTime),
                                       sizeof(fileTime));
                if (ERROR_SUCCESS == lError)
                {
                    DWORD   dwType;

                    if (PathUnExpandEnvStrings(pszShellExecuteCommand, szTemp, ARRAYSIZE(szTemp)) != FALSE)
                    {
                        dwType = REG_EXPAND_SZ;
                    }
                    else
                    {
                        hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszShellExecuteCommand);
                        dwType = REG_SZ;
                    }

                    if (SUCCEEDED(hr))
                    {
                        lError = RegSetValueEx(hKey,
                                               s_szApplicationValueName,
                                               0,
                                               REG_SZ,      // This is HKLM so it doesn't need to be REG_EXPAND_SZ.
                                               reinterpret_cast<LPBYTE>(szTemp),
                                               (lstrlen(szTemp) + sizeof('\0')) * sizeof(TCHAR));
                        if (ERROR_SUCCESS == lError)
                        {
                            hr = S_OK;
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(lError);
                        }
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(lError);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
            TW32(RegCloseKey(hKey));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lError);
        }
    }

    return hr;
}

#pragma warning(pop)


// wrapper around name space stuff to parse printer names
// returns fully qualified pidl for printer
static HRESULT _ParsePrinterName(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl, IBindCtx *pbc = NULL)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;

        LPITEMIDLIST pidlFolder;
        hr = SHGetFolderLocation(NULL, CSIDL_PRINTERS, NULL, 0, &pidlFolder);

        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));

            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = psf->ParseDisplayName(NULL, pbc, (LPWSTR)pszPrinter, NULL, &pidl, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidlFolder, pidl, ppidl);
                    ILFree(pidl);
                }
                psf->Release();
            }
            ILFree(pidlFolder);
        }
    }

    return hr;
}

STDAPI ParsePrinterName(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl)
{
    // invoke the internal routine with no bind context
    return _ParsePrinterName(pszPrinter, ppidl, NULL);
}

STDAPI ParsePrinterNameEx(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl, BOOL bValidated, DWORD dwType, USHORT uFlags)
{
    // prepare the bind context
    IPrintersBindInfo *pbi;
    HRESULT hr = Printers_CreateBindInfo(pszPrinter, dwType, bValidated, NULL, &pbi);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = pbc->RegisterObjectParam(PRINTER_BIND_INFO, pbi);
            if (SUCCEEDED(hr))
            {
                // invoke the internal routine with a valid bind context
                hr = _ParsePrinterName(pszPrinter, ppidl, pbc);
            }
            pbc->Release();
        }
        pbi->Release();
    }

    return hr;
}

//
// A function to read a value from the registry and return it as a variant
// Currently it handles the following registry data types - 
//
// DWORD -> returns a Variant int
// REG_SZ, REG_EXPAND_SZ -> returns a Variant str
//
STDAPI GetVariantFromRegistryValue(HKEY hkey, LPCTSTR pszValueName, VARIANT *pv)
{
    HRESULT hr = E_FAIL;
    
    BYTE ab[INFOTIPSIZE * sizeof(TCHAR)]; // this is the largest string value we expect
    DWORD cb = sizeof(ab), dwType;        
    
    if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, pszValueName, SRRF_RT_REG_SZ | SRRF_RT_DWORD, &dwType, (LPBYTE) ab, &cb))
    {
        switch (dwType)
        {
        case REG_SZ:
            hr = InitVariantFromStr(pv, (LPCTSTR) ab);
            break;
            
        case REG_DWORD:
            pv->vt = VT_I4; // 4 byte integer
            pv->lVal = *((LONG *) ab);
            hr = S_OK;
            break;

        case REG_EXPAND_SZ:  // SHRegQueryValue will map this to REG_SZ
            AssertMsg(FALSE, TEXT("REG_EXPAND_SZ should be expanded and returned as REG_SZ"));
            break;

        default:        // return failure for any other type
            break;
        }   
    }        
    return hr;
}

STDAPI_(UINT) GetControlCharWidth(HWND hwnd)
{
    SIZE siz;

    siz.cx = 8;  // guess a size in case something goes wrong.

    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        HFONT hfOld = SelectFont(hdc, FORWARD_WM_GETFONT(hwnd, SendMessage));
    
        if (hfOld)
        {
            GetTextExtentPoint(hdc, TEXT("0"), 1, &siz);

            SelectFont(hdc, hfOld);
        }

        ReleaseDC(NULL, hdc);
    }

    return siz.cx;
}

STDAPI_(BOOL) ShowSuperHidden()
{
    BOOL bRet = FALSE;

    if (!SHRestricted(REST_DONTSHOWSUPERHIDDEN))
    {
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SHOWSUPERHIDDEN, FALSE);
        bRet = ss.fShowSuperHidden;
    }
    return bRet;
}

#define FILE_ATTRIBUTE_SUPERHIDDEN (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)

STDAPI_(BOOL) IsSuperHidden(DWORD dwAttribs)
{
    BOOL bRet = FALSE;

    if (!ShowSuperHidden())
    {
        bRet = (dwAttribs & FILE_ATTRIBUTE_SUPERHIDDEN) == FILE_ATTRIBUTE_SUPERHIDDEN;
    }
    return bRet;
}

// make sure LFN paths are nicly quoted and have args at the end

STDAPI_(void) PathComposeWithArgs(LPTSTR pszPath, LPTSTR pszArgs)
{
    PathQuoteSpaces(pszPath);

    if (pszArgs[0]) 
    {
        int len = lstrlen(pszPath);

        if (len < (MAX_PATH - 3)) 
        {     // 1 for null, 1 for space, 1 for arg
            pszPath[len++] = TEXT(' ');
            StringCchCopy(pszPath + len, MAX_PATH - len, pszArgs);  // not ok to truncate - but already checked length
        }
    }
}

// do the inverse of the above, parse pszPath into a unquoted
// path string and put the args in pszArgs
//
// returns:
//      TRUE    we verified the thing exists
//      FALSE   it may not exist

STDAPI PathSeperateArgs(LPTSTR pszPath, LPTSTR pszArgs, UINT cchArgs, BOOL *pfExists)
{
    if (pfExists)
    {
        *pfExists = FALSE;
    }

    ASSERT(pszPath);
    if (!pszPath)
    {
        return E_FAIL;    //invalid args
    }
        
    PathRemoveBlanks(pszPath);

    // if the unquoted sting exists as a file just use it

    if (PathFileExistsAndAttributes(pszPath, NULL))
    {
        if (pszArgs)
            *pszArgs = 0;
        if (pfExists)
            *pfExists = TRUE;
        return S_OK;
    }

    LPTSTR pszT = PathGetArgs(pszPath);
    if (*pszT)
        *(pszT - 1) = 0;

    HRESULT hr = S_OK;
    if (pszArgs)
    {
        hr = StringCchCopy(pszArgs, cchArgs, pszT);
    }

    PathUnquoteSpaces(pszPath);

    return hr;
}

STDAPI_(int) CompareIDsAlphabetical(IShellFolder2 *psf, UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRes = 0;

    LPITEMIDLIST pidlFirst1 = ILCloneFirst(pidl1);
    LPITEMIDLIST pidlFirst2 = ILCloneFirst(pidl2);
    if (pidlFirst1 && pidlFirst2)
    {
        TCHAR szName1[MAX_PATH], szName2[MAX_PATH];
        HRESULT hr = DetailsOf(psf, pidlFirst1, iColumn, szName1, ARRAYSIZE(szName1));
        if (SUCCEEDED(hr))
        {                  
            hr = DetailsOf(psf, pidlFirst2, iColumn, szName2, ARRAYSIZE(szName2));
            if (SUCCEEDED(hr))
                iRes = StrCmpLogicalRestricted(szName1, szName2);
        }

        if (FAILED(hr))
        {
            // revert to compare of names
            hr = DisplayNameOf(psf, pidlFirst1, SHGDN_NORMAL, szName1, ARRAYSIZE(szName1));
            if (SUCCEEDED(hr))
            {
                hr = DisplayNameOf(psf, pidlFirst2, SHGDN_NORMAL, szName2, ARRAYSIZE(szName2));
                if (SUCCEEDED(hr))
                    iRes = StrCmpLogicalRestricted(szName1, szName2);
            }
        }
    }

    ILFree(pidlFirst1);
    ILFree(pidlFirst2);

    return iRes;
}

HMONITOR GetPrimaryMonitor()
{
    POINT pt = {0,0};
    return MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY); 
}

// Gets the Monitor's bounding or work rectangle, if the hMon is bad, return
// the primary monitor's bounding rectangle. 
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork)
{
    MONITORINFO mi; 
    mi.cbSize = sizeof(mi);
    if (hMon && GetMonitorInfo(hMon, &mi))
    {
        if (!prc)
            return TRUE;
        
        else if (bWork)
            CopyRect(prc, &mi.rcWork);
        else 
            CopyRect(prc, &mi.rcMonitor);
        
        return TRUE;
    }
    
    if (prc)
        SetRect(prc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    return FALSE;
}

STDAPI StatStgFromFindData(const WIN32_FIND_DATA * pfd, DWORD dwFlags, STATSTG * pstat)
{
    HRESULT hr = S_OK;
    if (dwFlags & STATFLAG_NONAME)
    {
        pstat->pwcsName = NULL;
    }
    else
    {
        hr = SHStrDup(pfd->cFileName, &pstat->pwcsName);
    }

    pstat->type = (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? STGTY_STORAGE : STGTY_STREAM;
    pstat->cbSize.HighPart = pfd->nFileSizeHigh;
    pstat->cbSize.LowPart = pfd->nFileSizeLow;
    pstat->mtime = pfd->ftLastWriteTime;
    pstat->ctime = pfd->ftCreationTime;
    pstat->atime = pfd->ftLastAccessTime;
    pstat->grfMode = 0;
    pstat->grfLocksSupported = 0;
    pstat->clsid = CLSID_NULL;
    pstat->grfStateBits = 0;
    pstat->reserved = pfd->dwFileAttributes;

    return hr;
}

// see if the QueryService chain will hit the desktop browser (the desktop window)
STDAPI_(BOOL) IsDesktopBrowser(IUnknown *punkSite)
{
    BOOL bRet = FALSE;
    IUnknown *punk;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_SShellDesktop, IID_PPV_ARG(IUnknown, &punk))))
    {   
        punk->Release();
        bRet = TRUE;    // It's the actual desktop!
    }
    return bRet;
}


// calculates the maximum allowable char length for a given path.
//      i.e. c:\winnt\system\bob
// this will return the maximum size the filename for bob can be changed to.

STDAPI GetCCHMaxFromPath(LPCTSTR pszFullPath, UINT* pcchMax, BOOL fShowExtension)
{
    int cchAvailable;

    ASSERTMSG(pszFullPath != NULL, "GetCCHMaxFromPath: caller passed null pszFullPath!");
    ASSERTMSG(pcchMax != NULL, "GetCCHMaxFromPath: callser passed null pcchMax!");

    TCHAR szParent[MAX_PATH];
    if (SUCCEEDED(StringCchCopy(szParent, ARRAYSIZE(szParent), pszFullPath)))
    {
        DWORD cchParent;
        DWORD cchMaxComponentLength = MAX_PATH;
        BOOL  bIsDir;

        PathRemoveFileSpec(szParent);
        cchParent = lstrlen(szParent);

        // amount of room available = MAX_PATH - lstrlen(szParent) - ('\\' + '\0')
        cchAvailable = MAX_PATH - cchParent - (cchParent > 0 && szParent[cchParent-1] == L'\\' ? 1 : 2);
    
        // if we have a directory, it has to be long enought to contain an 8.3 name or else
        // the shell will have lots of problems (eg cannot put a desktop.ini inside it)
        bIsDir = PathIsDirectory(pszFullPath);
        if (bIsDir)
        {
            // magic "12" comes from length of 8.3 (see comment above)
            cchAvailable -= 12;
        }
        
        // now check to see if there is something about the filesystem that limits path sizes
        PathStripToRoot(szParent);
        if (GetVolumeInformation(szParent, NULL, 0, NULL, &cchMaxComponentLength, NULL, NULL, 0))
        {
            // cap the length if restricted by the filesystem
            cchAvailable = min((int)cchMaxComponentLength, cchAvailable);
        }

        // Take into account if we are hiding the extensions
        if (!fShowExtension)
        {
            if (cchMaxComponentLength <= 12)
            {
                // for filesystems that return <=12, they really mean "we only support 8.3 files"
                // (eg 9.2 would be invalid). Therefore cap the size at 8 since we are not showing 
                // extensions
                cchAvailable = min(8, cchAvailable);
            }
            else if (!bIsDir)
            {
                // we only subtract off the extension for files (since directories named "dir1.foo" show
                // the extension even if you have "hide extensions" enabled)
                cchAvailable -= lstrlen(PathFindExtension(pszFullPath));
            }
        }    
    }
    else
    {
        cchAvailable = 0;
    }

    HRESULT hr;

    if (cchAvailable > 0)
    {
        *pcchMax = (UINT)cchAvailable;
        hr = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "GetCCHMaxFromPath: pszFullPath already too big-- cannot rename!");

        *pcchMax = 0;
        hr = HRESULT_CODE(ERROR_FILENAME_EXCED_RANGE);
    }

    return hr;
}

STDAPI ViewModeFromSVID(const SHELLVIEWID *pvid, FOLDERVIEWMODE *pViewMode)
{
    HRESULT hr = S_OK;
    
    if (IsEqualIID(*pvid, VID_LargeIcons))
        *pViewMode = FVM_ICON;
    else if (IsEqualIID(*pvid, VID_SmallIcons))
        *pViewMode = FVM_SMALLICON;
    else if (IsEqualIID(*pvid, VID_Thumbnails))
        *pViewMode = FVM_THUMBNAIL;
    else if (IsEqualIID(*pvid, VID_ThumbStrip))
        *pViewMode = FVM_THUMBSTRIP;
    else if (IsEqualIID(*pvid, VID_List))
        *pViewMode = FVM_LIST;
    else if (IsEqualIID(*pvid, VID_Tile))
        *pViewMode = FVM_TILE;
    else if (IsEqualIID(*pvid, VID_Details))
        *pViewMode = FVM_DETAILS;
    else
    {
        if (IsEqualIID(*pvid, VID_WebView))
            TraceMsg(TF_WARNING, "ViewModeFromSVID received VID_WebView");
        else
            TraceMsg(TF_WARNING, "ViewModeFromSVID received unknown VID");

        *pViewMode = FVM_ICON;
        hr = E_FAIL;
    }
    return hr;
}

STDAPI SVIDFromViewMode(FOLDERVIEWMODE uViewMode, SHELLVIEWID *psvid)
{
    switch (uViewMode) 
    {
    case FVM_ICON:
        *psvid = VID_LargeIcons;
        break;

    case FVM_SMALLICON:
        *psvid = VID_SmallIcons;
        break;

    case FVM_LIST:
        *psvid = VID_List;
        break;

    case FVM_DETAILS:
        *psvid = VID_Details;
        break;

    case FVM_THUMBNAIL:
        *psvid = VID_Thumbnails;
        break;

    case FVM_TILE:
        *psvid = VID_Tile;
        break;

    case FVM_THUMBSTRIP:
        *psvid = VID_ThumbStrip;
        break;

    default:
        TraceMsg(TF_ERROR, "SVIDFromViewMode given invalid uViewMode!");
        *psvid = VID_LargeIcons;
        break;
    }
    return S_OK;
}

// modify the SLDF_ link flags via new bits + a mask, return the old flags
STDAPI_(DWORD) SetLinkFlags(IShellLink *psl, DWORD dwFlags, DWORD dwMask)
{
    DWORD dwOldFlags = 0;
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psld))))
    {
        if (SUCCEEDED(psld->GetFlags(&dwOldFlags)))
        {
            if (dwMask)
                psld->SetFlags((dwFlags & dwMask) | (dwOldFlags & ~dwMask));
        }
        psld->Release();
    }
    return dwOldFlags;  // return the previous value
}

// Helper function to compare the 2 variants and return the standard
// C style (-1, 0, 1) value for the comparison.
STDAPI_(int) CompareVariants(VARIANT va1, VARIANT va2)
{
    int iRetVal = 0;

    if (va1.vt == VT_EMPTY)
    {
        if (va2.vt == VT_EMPTY)
            iRetVal = 0;
        else
            iRetVal = 1;
    }
    else if (va2.vt == VT_EMPTY)
    {
        if (va1.vt == VT_EMPTY)
            iRetVal = 0;
        else
            iRetVal = -1;
    }
    else
    {
        // Special case becasue VarCmp cannot handle ULONGLONG
        if (va1.vt == VT_UI8 && va2.vt == VT_UI8)
        {
            if (va1.ullVal < va2.ullVal)
                iRetVal = -1;
            else if (va1.ullVal > va2.ullVal)
                iRetVal = 1;
        }
        else if (va1.vt == VT_BSTR && va2.vt == VT_BSTR)
        {
            iRetVal = StrCmpLogicalRestricted(va1.bstrVal, va2.bstrVal);
        }
        else
        {
            HRESULT hr = VarCmp(&va1, &va2, GetUserDefaultLCID(), 0);
            if (SUCCEEDED(hr))
            {
                // Translate the result into the C convention...
                ASSERT(hr != VARCMP_NULL);
                iRetVal = hr - VARCMP_EQ;
            }
        }
    }

    return iRetVal;
}

// Check which of the pidl's passed in represent a folder.  If only one 
// is a folder, then put it first.
STDAPI_(int) CompareFolderness(IShellFolder *psf, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL bIsFolder1 = SHGetAttributes(psf, pidl1, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER;
    BOOL bIsFolder2 = SHGetAttributes(psf, pidl2, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER;

    int iRetVal;
    if (bIsFolder1 && !bIsFolder2)
    {
        iRetVal = -1;   // Don't swap
    }
    else if (!bIsFolder1 && bIsFolder2)
    {
        iRetVal = 1;    // Swap
    }
    else
    {
        iRetVal = 0;    // equal
    }

    return iRetVal;
}

// Compare the two items using GetDetailsEx, it is assumed that folderness has been established already
// Return -1 if pidl1 comes before pidl2,
//         0 if the same
//         1 if pidl2 comes before pidl1

STDAPI_(int) CompareBySCID(IShellFolder2 *psf, const SHCOLUMNID *pscid, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // ignore failures here, leaving VT_EMPTY that we compare below
    VARIANT v1 = {0}, v2 = {0};
    psf->GetDetailsEx(pidl1, pscid, &v1);
    psf->GetDetailsEx(pidl2, pscid, &v2);   

    int iRet = CompareVariants(v1, v2);

    VariantClear(&v2);
    VariantClear(&v1);
    return iRet;
}

//
// Determines if a filename is that of a regitem
//        
// a regitem's SHGDN_INFOLDER | SHGDN_FORPARSING name is always "::{someguid}"
// 
// This test can lead to false positives if you have other items which have infolder 
// parsing names beginning with "::{", but as ':' is not presently allowed in filenames 
// it should not be a problem. 
//
STDAPI_(BOOL) IsRegItemName(LPCTSTR pszName, CLSID* pclsid)
{
    BOOL fRetVal = FALSE;
    
    if (pszName && lstrlen(pszName) >= 3)
    {
        if (pszName[0] == TEXT(':') && pszName[1] == TEXT(':') && pszName[2] == TEXT('{'))
        {
            CLSID clsid;
            fRetVal = GUIDFromString(pszName + 2, &clsid); // skip the leading :: before regitem
            if (pclsid)
            {
                memcpy(pclsid, &clsid, sizeof(clsid));
            }
        }
    }

    return fRetVal;
}

STDAPI GetMyDocumentsDisplayName(LPTSTR pszPath, UINT cch)
{
    *pszPath = 0;
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidl)))
    {
        SHGetNameAndFlags(pidl, SHGDN_NORMAL, pszPath, cch, NULL);
        ILFree(pidl);
    }
    return *pszPath ? S_OK : E_FAIL;
}


STDAPI BSTRFromCLSID(REFCLSID clsid, BSTR *pbstr)
{
    WCHAR sz[GUIDSTR_MAX + 1];
    
    //  Get the File/Folders search guid in string form
    SHStringFromGUIDW(clsid, sz, ARRAYSIZE(sz));
    *pbstr = SysAllocString(sz);
    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

// [in] pdo -- data object we're interested in
// [in] dwAttributeMask -- the bits we want to know about
// [out,optional] pdwAttributes -- write the bits of dwAttributeMask that we calculate
// [out,optional] pcItems -- count of pidls in pdo
//
// returns S_FALSE only if the dataobject doesn't support HIDA, used to help out defview for legacy cases.
// in general callers dont have to check for success/failure and they can use the dwAttribs, it's zero-inited.
HRESULT SHGetAttributesFromDataObject(IDataObject *pdo, DWORD dwAttributeMask, DWORD *pdwAttributes, UINT *pcItems)
{
    HRESULT hr = S_OK;

    DWORD dwAttributes = 0;
    DWORD cItems = 0;

    // These are all the bits we regularly ask for:
    #define TASK_ATTRIBUTES (SFGAO_READONLY|SFGAO_STORAGE|SFGAO_CANRENAME|SFGAO_CANMOVE|SFGAO_CANCOPY|SFGAO_CANDELETE|SFGAO_FOLDER|SFGAO_STREAM)

    if ((dwAttributeMask&TASK_ATTRIBUTES) != dwAttributeMask)
    {
        TraceMsg(TF_WARNING, "SHGetAttributesFromDataObject cache can be more efficient");
    }

    if (pdo)
    {
        // We cache the attributes on the data object back in the data object,
        // since we call for them so many times.
        //
        // To do this we need to remember:
        struct {
            DWORD dwRequested;
            DWORD dwReceived;
            UINT  cItems;
        } doAttributes = {0};
        
        static UINT s_cfDataObjectAttributes = 0;
        if (0 == s_cfDataObjectAttributes)
            s_cfDataObjectAttributes = RegisterClipboardFormat(TEXT("DataObjectAttributes"));

        if (FAILED(DataObj_GetBlob(pdo, s_cfDataObjectAttributes, &doAttributes, sizeof(doAttributes))) ||
            ((doAttributes.dwRequested & dwAttributeMask) != dwAttributeMask))
        {
            // If we fail along the way, cache that we tried to ask for these bits,
            // since we'll probably fail next time.
            //
            // Also, always ask for a superset of bits, and include the most commonly requested ones too
            //
            doAttributes.dwRequested |= (dwAttributeMask | TASK_ATTRIBUTES);

            // try to get the attributes requested
            STGMEDIUM medium = {0};
            LPIDA pida = DataObj_GetHIDA(pdo, &medium);
            if (pida)
            {
                doAttributes.cItems = pida->cidl;

                if (pida->cidl >= 1)
                {
                    IShellFolder* psf;
                    if (SUCCEEDED(SHBindToObjectEx(NULL, HIDA_GetPIDLFolder(pida), NULL, IID_PPV_ARG(IShellFolder, &psf))))
                    {
                        // who cares if we get the wrong bits when there are a bunch of items - check the first 10 or so...
                        LPCITEMIDLIST apidl[10];
                        UINT cItems = (UINT)min(pida->cidl, ARRAYSIZE(apidl));
                        for (UINT i = 0 ; i < cItems ; i++)
                        {
                            apidl[i] = HIDA_GetPIDLItem(pida, i);

                            if (ILGetNext(ILGetNext(apidl[i])))
                            {
                                // search namespace has non-flat HIDA, which is probably a bug.
                                // work around it here:
                                //   if the first item is non-flat, use that one item for attributes
                                //   otherwise use the flat items already enumerated
                                //
                                IShellFolder* psfNew;
                                if (0==i &&
                                    (SUCCEEDED(SHBindToFolderIDListParent(psf, apidl[i], IID_PPV_ARG(IShellFolder, &psfNew), &(apidl[i])))))
                                {
                                    psf->Release();
                                    psf = psfNew;

                                    cItems = 1;
                                }
                                else
                                {
                                    cItems = i;
                                }

                                break;
                            }
                        }

                        DWORD dwAttribs = doAttributes.dwRequested;
                        if (SUCCEEDED(psf->GetAttributesOf(cItems, apidl, &dwAttribs)))
                        {
                            doAttributes.dwReceived = dwAttribs;
                        }

                        psf->Release();
                    }
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
            else
            {
                hr = S_FALSE;
            }

            DataObj_SetBlob(pdo, s_cfDataObjectAttributes, &doAttributes, sizeof(doAttributes));
        }

        dwAttributes = doAttributes.dwReceived & dwAttributeMask;
        cItems = doAttributes.cItems;
    }

    if (pdwAttributes)
        *pdwAttributes = dwAttributes;
    if (pcItems)
        *pcItems = cItems;
    
    return hr;
}

STDAPI SHSimulateDropOnClsid(REFCLSID clsidDrop, IUnknown* punkSite, IDataObject* pdo)
{
    IDropTarget* pdt;
    HRESULT hr = SHExtCoCreateInstance2(NULL, &clsidDrop, NULL, CLSCTX_ALL, IID_PPV_ARG(IDropTarget, &pdt));
    if (SUCCEEDED(hr))
    {
        hr = SHSimulateDropWithSite(pdt, pdo, 0, NULL, NULL, punkSite);
        pdt->Release();
    }
    return hr;
}

STDAPI SHPropertiesForUnk(HWND hwnd, IUnknown *punk, LPCTSTR psz)
{
    HRESULT hr;
    LPITEMIDLIST pidl;
    if (S_OK == SHGetIDListFromUnk(punk, &pidl))
    {
        hr = SHPropertiesForPidl(hwnd, pidl, psz);
        ILFree(pidl);
    }
    else
        hr = E_FAIL;
    return hr;
}

STDAPI SHFullIDListFromFolderAndItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetIDListFromUnk(psf, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        hr = SHILCombine(pidlFolder, pidl, ppidl);
        ILFree(pidlFolder);
    }
    return hr;
}

STDAPI_(BOOL) IsWindowClass(HWND hwndTest, LPCTSTR pszClass)
{
    TCHAR szClass[128];
    if (pszClass && GetClassName(hwndTest, szClass, ARRAYSIZE(szClass)))
        return 0 == lstrcmpi(pszClass, szClass);
    return FALSE;
}

STDAPI DCA_ExtCreateInstance(HDCA hdca, int iItem, REFIID riid, void **ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    return pclsid ? SHExtCoCreateInstance(NULL, pclsid, NULL, riid, ppv) : E_INVALIDARG;
}

STDAPI_(HINSTANCE) SHGetShellStyleHInstance (void)
{
    TCHAR szDir[MAX_PATH];
    TCHAR szColor[100];
    HINSTANCE hInst = NULL;
    LPTSTR lpFullPath;

    //
    // First try to load shellstyle.dll from the theme (taking into account color variations)
    //
    if (SUCCEEDED(GetCurrentThemeName(szDir, ARRAYSIZE(szDir), szColor, ARRAYSIZE(szColor), NULL, NULL)))
    {
        UINT cch = lstrlen(szDir) + lstrlen(szColor) + 25;  // 23 = length of "\\Shell\\" + "\\ShellStyle.dll" + Nul + slop

        PathRemoveFileSpec(szDir);

        lpFullPath = (LPTSTR) LocalAlloc (LPTR, cch * sizeof(TCHAR));

        if (lpFullPath)
        {
            HRESULT hr;

            hr = StringCchPrintf(lpFullPath, cch, TEXT("%s\\Shell\\%s\\ShellStyle.dll"), szDir, szColor);
            if (SUCCEEDED(hr))
            {
                hInst = LoadLibraryEx(lpFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
            }

            LocalFree (lpFullPath);
        }
    }

    //
    // If shellstyle.dll couldn't be loaded from the theme, load the default (classic)
    // version from system32.
    //
    if (!hInst)
    {
        if (ExpandEnvironmentStrings (TEXT("%SystemRoot%\\System32\\ShellStyle.dll"),
                                      szDir, ARRAYSIZE(szDir)))
        {
            hInst = LoadLibraryEx(szDir, NULL, LOAD_LIBRARY_AS_DATAFILE);
        }
    }

    return hInst;
}

// adjust an infotip object in a custom way for the folder
// poke in an extra property to be displayed and wrap the object with the
// delegating outter folder if needed

STDAPI WrapInfotip(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, IUnknown *punk)
{
    HRESULT hr = S_OK;

    if (pscid)
    {
        ICustomizeInfoTip *pcit;
        hr = punk->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit));
        if (SUCCEEDED(hr))
        {
            hr = pcit->SetExtraProperties(pscid, 1);
            pcit->Release();
        }
    }

    if (psf && pidl)
    {
        IParentAndItem *ppai;
        hr = punk->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai));
        if (SUCCEEDED(hr))
        {
            ppai->SetParentAndItem(NULL, psf, pidl);
            ppai->Release();
        }
    }
    return hr;
}

STDAPI CloneIDListArray(UINT cidl, const LPCITEMIDLIST rgpidl[], UINT *pcidl, LPITEMIDLIST **papidl)
{
    HRESULT hr;
    LPITEMIDLIST *ppidl;

    if (cidl && rgpidl)
    {
        ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, cidl * sizeof(*ppidl));
        if (ppidl)
        {
            hr = S_OK;
            for (UINT i = 0; i < cidl && SUCCEEDED(hr); i++)
            {
                hr = SHILClone(rgpidl[i], &ppidl[i]);
                if (FAILED(hr))
                {
                    FreeIDListArray(ppidl, i);
                    ppidl = NULL;
                }
            }   
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        ppidl = NULL;
        hr = S_FALSE;   // success by empty
    }

    *papidl = ppidl;
    *pcidl = SUCCEEDED(hr) ? cidl : 0;
    return hr;
}

BOOL RunWindowCallback(VARIANT var, ENUMSHELLWINPROC pEnumFunc, LPARAM lParam)
{
    BOOL fKeepGoing = TRUE;
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(var.pdispVal, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        IShellView *psv;
        if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
        {
            HWND hwnd;
            if (SUCCEEDED(psv->GetWindow(&hwnd)))
            {
                IPersistIDList *pPI;
                if (SUCCEEDED(psv->QueryInterface(IID_PPV_ARG(IPersistIDList, &pPI))))
                {
                    LPITEMIDLIST pidl;
                    if (SUCCEEDED(pPI->GetIDList(&pidl)))
                    {
                        fKeepGoing = pEnumFunc(hwnd, pidl, lParam);
                        ILFree(pidl);
                    }
                    pPI->Release();
                }
            }
            psv->Release();
        }
        psb->Release();
    }
    return fKeepGoing;
}

// runs through all open shell browser windows and runs a caller-defined function on the hwnd and pidl.
STDAPI EnumShellWindows(ENUMSHELLWINPROC pEnumFunc, LPARAM lParam)
{
    HRESULT hr;
    IShellWindows *psw = WinList_GetShellWindows(TRUE);
    if (psw)
    {
        IUnknown *punk;
        hr = psw->_NewEnum(&punk);
        if (SUCCEEDED(hr))
        {
            IEnumVARIANT *penum;
            hr = punk->QueryInterface(IID_PPV_ARG(IEnumVARIANT, &penum));
            if (SUCCEEDED(hr))
            {
                VARIANT var;
                VariantInit(&var);
                BOOL fKeepGoing = TRUE;
                while (fKeepGoing && (S_OK == penum->Next(1, &var, NULL)))
                {
                    ASSERT(var.vt == VT_DISPATCH);
                    ASSERT(var.pdispVal);
                    fKeepGoing = RunWindowCallback(var, pEnumFunc, lParam);
                    VariantClear(&var);
                }
                penum->Release();
            }
            punk->Release();
        }
        psw->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// Determine if infotips are on or off (from the registry settings).
//
BOOL SHShowInfotips()
{
    // REVIEW (buzzr): Is it necessary to force a refresh every time?
    SHELLSTATE ss;
    SHRefreshSettings();
    SHGetSetSettings(&ss, SSF_SHOWINFOTIP, FALSE);
    return ss.fShowInfoTip;
}

HRESULT SHCreateInfotipWindow(HWND hwndParent, LPWSTR pszInfotip, HWND *phwndInfotip)
{
    HRESULT hr;

    if (hwndParent && IsWindow(hwndParent))
    {
        DWORD dwExStyle = 0;
        if (IS_WINDOW_RTL_MIRRORED(hwndParent) || IS_BIDI_LOCALIZED_SYSTEM())
        {
            dwExStyle = WS_EX_LAYOUTRTL;
        }

        *phwndInfotip = CreateWindowEx(dwExStyle,
                                       TOOLTIPS_CLASS,
                                       NULL,
                                       WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                                       CW_USEDEFAULT,
                                       CW_USEDEFAULT,
                                       CW_USEDEFAULT,
                                       CW_USEDEFAULT,
                                       hwndParent,
                                       NULL,
                                       HINST_THISDLL,
                                       NULL);
        if (*phwndInfotip)
        {
            SetWindowPos(*phwndInfotip,
                         HWND_TOPMOST,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            TOOLINFOW ti;
            ZeroMemory(&ti, sizeof(ti));
            ti.cbSize   = sizeof(ti);
            ti.uFlags   = TTF_SUBCLASS;
            ti.hwnd     = hwndParent;
            ti.hinst    = HINST_THISDLL;
            ti.lpszText = pszInfotip;
            GetClientRect(hwndParent, &ti.rect);

            if (SendMessage(*phwndInfotip, TTM_ADDTOOL, 0, (LPARAM)&ti))
            {
                static const RECT rcMargin = { 2, 2, 2, 2 };
                SendMessage(*phwndInfotip, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                //
                // Set the initial delay time to 2 times the default.
                // Set the auto-pop time to a very large value.
                // These are the same parameters used by defview for it's tooltips.
                //
                LRESULT uiShowTime = SendMessage(*phwndInfotip, TTM_GETDELAYTIME, TTDT_INITIAL, 0);
                SendMessage(*phwndInfotip, TTM_SETDELAYTIME, TTDT_INITIAL, MAKELONG(uiShowTime * 2, 0));
                SendMessage(*phwndInfotip, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);

                SendMessage(*phwndInfotip, TTM_SETMAXTIPWIDTH, 0, 300);
                hr = S_OK;
            }
            else
                hr = ResultFromLastError();
        }
        else
            hr = ResultFromLastError();
    }
    else
        hr = E_INVALIDARG;

    return THR(hr);
}

HRESULT SHShowInfotipWindow(HWND hwndInfotip, BOOL bShow)
{
    HRESULT hr;

    if (hwndInfotip && IsWindow(hwndInfotip))
    {
        SendMessage(hwndInfotip, TTM_ACTIVATE, (WPARAM)bShow, 0);
        hr = S_OK;
    }
    else
        hr = E_INVALIDARG;

    return THR(hr);
}

HRESULT SHDestroyInfotipWindow(HWND *phwndInfotip)
{
    HRESULT hr;

    if (*phwndInfotip)
    {
        if (IsWindow(*phwndInfotip))
        {
            if (DestroyWindow(*phwndInfotip))
            {
                *phwndInfotip = NULL;
                hr = S_OK;
            }
            else
                hr = ResultFromLastError();
        }
        else
            hr = S_OK;
    }
    else
        hr = E_INVALIDARG;

    return THR(hr);
}

// we hide wizards in defview iff we are in explorer and webview is on
STDAPI SHShouldShowWizards(IUnknown *punksite)
{
    HRESULT hr = S_OK;      // assume yes
    IShellBrowser* psb;
    if (SUCCEEDED(IUnknown_QueryService(punksite, SID_STopWindow, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_WEBVIEW, FALSE);
        if (ss.fWebView)
        {
            if (SHRegGetBoolUSValueW(REGSTR_EXPLORER_ADVANCED, TEXT("ShowWizardsTEST"),
                        FALSE, // Don't ignore HKCU
                        FALSE)) // By default we assume we're not using these test tools
            {
                // Test teams that have old test tools that don't know how to talk to DUI need a way
                // to force the legacy wizards back into the listview to keep their automation working
            }
            else
            {
                hr = S_FALSE;
            }
        }
        psb->Release();
    }
    return hr;
}

// split a full pidl into the "folder" part and the "item" part.
// callers need to free the folder part 
// (pay special attention to the constness of the out params)

STDAPI SplitIDList(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFolder, LPCITEMIDLIST *ppidlChild)
{
    HRESULT hr;
    *ppidlFolder = ILCloneParent(pidl);
    if (*ppidlFolder)
    {
        *ppidlChild = ILFindLastID(pidl);   // const alias result
        hr = S_OK;
    }
    else
    {
        *ppidlChild = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT GetAppNameFromCLSID(CLSID clsid, PWSTR *ppszApp)
{
    *ppszApp = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        PWSTR pszProgID;
        hr = ProgIDFromCLSID(clsid, &pszProgID);
        if (SUCCEEDED(hr))
        {
            hr = pqa->Init(NULL, pszProgID, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;

                DWORD cch = 0;
                pqa->GetString(ASSOCF_NOTRUNCATE, ASSOCSTR_FRIENDLYAPPNAME, NULL, NULL, &cch);
                if (cch)
                {
                    *ppszApp = (PWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
                    if (*ppszApp)
                    {
                        hr = pqa->GetString(0, ASSOCSTR_FRIENDLYAPPNAME, NULL, *ppszApp, &cch);

                        if (FAILED(hr))
                        {
                            Str_SetPtr(ppszApp, NULL);
                        }
                    }
                }
            }
            CoTaskMemFree(pszProgID);
        }
        pqa->Release();
    }
    return hr;
}

HRESULT GetAppNameFromMoniker(IRunningObjectTable *prot, IMoniker *pmkFile, PWSTR *ppszApp)
{
    HRESULT hr = E_FAIL;
    IUnknown *punk;
    if (prot->GetObject(pmkFile, &punk) == S_OK)
    {
        IOleObject *pole;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleObject, &pole));
        if (SUCCEEDED(hr))
        {
            CLSID clsid;
            hr = pole->GetUserClassID(&clsid);
            if (SUCCEEDED(hr))
            {
                hr = GetAppNameFromCLSID(clsid, ppszApp);
            }
            pole->Release();
        }
        punk->Release();
    }
    return hr;
}

// pmkPath  c:\foo
// pmk      c:\foo\doc.txt
BOOL IsMonikerPrefix(IMoniker *pmkPath, IMoniker *pmkFile)
{
    BOOL bRet = FALSE;
    IMoniker *pmkPrefix;
    if (SUCCEEDED(pmkPath->CommonPrefixWith(pmkFile, &pmkPrefix)))
    {
        bRet = (S_OK == pmkPath->IsEqual(pmkPrefix));
        pmkPrefix->Release();
    }
    return bRet;
}

STDAPI FindAppForFileInUse(PCWSTR pszFile, PWSTR *ppszApp)
{
    IRunningObjectTable *prot;
    HRESULT hr = GetRunningObjectTable(0, &prot);
    if (SUCCEEDED(hr))
    {
        IMoniker *pmkFile;
        hr = CreateFileMoniker(pszFile, &pmkFile);
        if (SUCCEEDED(hr))
        {
            IEnumMoniker *penumMk;
            hr = prot->EnumRunning(&penumMk);
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;

                ULONG celt;
                IMoniker *pmk;
                while (FAILED(hr) && (penumMk->Next(1, &pmk, &celt) == S_OK))
                {
                    DWORD dwType;
                    if (SUCCEEDED(pmk->IsSystemMoniker(&dwType)) && (dwType == MKSYS_FILEMONIKER))
                    {
                        if (IsMonikerPrefix(pmkFile, pmk))
                        {
                            hr = GetAppNameFromMoniker(prot, pmk, ppszApp);
                        }
                    }
                    pmk->Release();
                }
                penumMk->Release();
            }
            pmkFile->Release();
        }
        prot->Release();
    }
    return hr;
}

#include <trkwks_c.c>

// DirectUI initialization helper functions

static BOOL g_DirectUIInitialized = FALSE;

HRESULT InitializeDUIViewClasses();  // duiview.cpp
HRESULT InitializeCPClasses();       // cpview.cpp

HRESULT InitializeDirectUI()
{
    HRESULT hr;

    // If we have already initialized DirectUI, exit now.
    // Multiple threads will be attempting to initialize. InitProcess
    // and class registration expects to be run on the primary thread.
    // Make sure it only happens once on a single thread

    ENTERCRITICAL;
    
    if (g_DirectUIInitialized)
    {
        hr = S_OK;
        goto Done;
    }

    // Initialize DirectUI for the process
    hr = DirectUI::InitProcess();
    if (FAILED(hr))
        goto Done;

    // Initialize the classes that DUIView uses
    hr = InitializeDUIViewClasses();
    if (FAILED(hr))
        goto Done;

    // Initialize the classes that Control Panel uses
    hr = InitializeCPClasses();
    if (FAILED(hr))
        goto Done;

    g_DirectUIInitialized = TRUE;

Done:

    if (FAILED(hr))
    {
        // Safe to call if InitProcess fails. Will unregister
        // all registered classes. All InitThread calls will fail
        DirectUI::UnInitProcess();
    }    

    LEAVECRITICAL;

    return hr;
}

void UnInitializeDirectUI(void)
{
    ENTERCRITICAL;

    if (g_DirectUIInitialized)
    {
        DirectUI::UnInitProcess();

        g_DirectUIInitialized = FALSE;
    }

    LEAVECRITICAL;
}

BOOL IsForceGuestModeOn(void)
{
    BOOL fIsForceGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForceGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        DWORD dwForceGuest;
        DWORD cb = sizeof(dwForceGuest);

        // Professional, not in a domain. Check the ForceGuest value.

        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"), TEXT("ForceGuest"), NULL, &dwForceGuest, &cb)
            && 1 == dwForceGuest)
        {
            fIsForceGuestModeOn = TRUE;
        }
    }

    return fIsForceGuestModeOn;
}

BOOL IsFolderSecurityModeOn(void)
{
    DWORD dwSecurity;
    DWORD cb = sizeof(dwSecurity);
    DWORD err;

    err = SHGetValue(HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("MoveSecurityAttributes"), NULL, &dwSecurity, &cb);

    if (err == ERROR_SUCCESS)
    {
        return (dwSecurity == 0);
    }
    else
    {
        return IsForceGuestModeOn();
    }
}

STDAPI_(int) StrCmpLogicalRestricted(PCWSTR psz1, PCWSTR psz2)
{
    if (!SHRestricted(REST_NOSTRCMPLOGICAL))
        return StrCmpLogicalW(psz1, psz2);
    else
        return StrCmpIW(psz1, psz2);
}
    
HRESULT HavePreviousVersionsAt(IShellItemArray *psiItemArray, DWORD dwIndex, BOOL fOkToBeSlow, BOOL* pfAvailable)
{
    HRESULT hr = S_OK;
    LPOLESTR pszPath = NULL;

    if (NULL == pfAvailable)
        return E_POINTER;

    *pfAvailable = FALSE;   // default answer is No

    if (NULL == psiItemArray)
        return E_INVALIDARG;

#ifdef DEBUG
    DWORD dwNumItems;
    ASSERT(S_OK == psiItemArray->GetCount(&dwNumItems));
    ASSERT(dwIndex < dwNumItems);
#endif

    IShellItem *psi;
    if (SUCCEEDED(psiItemArray->GetItemAt(dwIndex, &psi)))
    {
        SFGAOF flags = SFGAO_FOLDER | SFGAO_LINK;
        if (SUCCEEDED(psi->GetAttributes(flags, &flags))
            && (flags & SFGAO_FOLDER) && (flags & SFGAO_LINK))
        {
            // It's a folder shortcut. Use the target.
            IShellItem *psiTarget;
            if (SUCCEEDED(psi->BindToHandler(NULL, BHID_LinkTargetItem, IID_PPV_ARG(IShellItem, &psiTarget))))
            {
                psi->Release();
                psi = psiTarget;
            }
        }
        psi->GetDisplayName(SIGDN_FILESYSPATH, &pszPath);
        psi->Release();
    }

    if (NULL != pszPath)
    {
        // This check is duplicated by the shell extension below
        // (ppvi->AreSnapshotsAvailable) but do it here to avoid loading
        // the other dll until we really need to.
        //
        // Shadow copies are only available on network paths.
        if (PathIsNetworkPathW(pszPath) && !PathIsUNCServerW(pszPath))
        {
            // {596AB062-B4D2-4215-9F74-E9109B0A8153}   CLSID_TimeWarpProp
            const CLSID CLSID_TimeWarpProp = {0x596AB062, 0xB4D2, 0x4215, {0x9F, 0x74, 0xE9, 0x10, 0x9B, 0x0A, 0x81, 0x53}};

            IPreviousVersionsInfo *ppvi = NULL;
            if (SUCCEEDED(SHExtCoCreateInstance(NULL, &CLSID_TimeWarpProp, NULL, IID_PPV_ARG(IPreviousVersionsInfo, &ppvi))))
            {
                // This returns E_PENDING if the answer is unknown
                // and fOkToBeSlow is FALSE
                hr = ppvi->AreSnapshotsAvailable(pszPath, fOkToBeSlow, pfAvailable);
                ppvi->Release();
            }
        }
        CoTaskMemFree(pszPath);
    }

    return hr;
}

HRESULT ShowPreviousVersionsAt(IShellItemArray *psiItemArray, DWORD dwIndex, HWND hwndOwner)
{
    HRESULT hr;

    if (NULL == psiItemArray)
        return E_INVALIDARG;

#ifdef DEBUG
    DWORD dwNumItems;
    ASSERT(S_OK == psiItemArray->GetCount(&dwNumItems));
    ASSERT(dwIndex < dwNumItems);
#endif

    IShellItem *psi;
    hr = psiItemArray->GetItemAt(dwIndex, &psi);
    if (SUCCEEDED(hr))
    {
        // Retrieve pidl.
        LPITEMIDLIST pidl;
        hr = SHGetIDListFromUnk(psi, &pidl);
        if (SUCCEEDED(hr))
        {
            TCHAR szSheetName[32];
            LoadString(HINST_THISDLL, IDS_TASK_SHADOW_PAGE, szSheetName, ARRAYSIZE(szSheetName));
            SHELLEXECUTEINFO sei =
            {
                SIZEOF(sei),
                SEE_MASK_INVOKEIDLIST,      // fMask
                hwndOwner,                  // hwnd
                c_szProperties,             // lpVerb
                NULL,                       // lpFile
                szSheetName,                // lpParameters
                NULL,                       // lpDirectory
                SW_SHOWNORMAL,              // nShow
                NULL,                       // hInstApp
                pidl,                       // lpIDList
                NULL,                       // lpClass
                0,                          // hkeyClass
                0,                          // dwHotKey
                NULL                        // hIcon
            };

            ShellExecuteEx(&sei);

            ILFree(pidl);
        }
        psi->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\viewstate.h ===
#ifndef _DVViewState_h
#define _DVViewState_h

// Forwards
class CDefView;

typedef struct
{
    POINT pt;
    ITEMIDLIST idl;
} VIEWSTATE_POSITION;

typedef struct
{
    // NOTE: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG lParamSort;

    int iDirection;
    int iLastColumnClick;
} WIN95SAVESTATE;

typedef struct 
{
    WORD          cbSize;
    WORD          wUnused; // junk on stack at this location has been saved in the registry since Win95... bummer
    DWORD         ViewMode;
    POINTS        ptScroll;
    WORD          cbColOffset;
    WORD          cbPosOffset;
    WIN95SAVESTATE   dvState;

} WIN95HEADER;

// Even though we don't currently store anything we care
// about in this structure relating to the view state,
// the cbStreamSize value fixes a bug in Win95 where we
// read to the end of the stream instead of just reading
// in the same number of bytes we wrote out.
//
typedef struct
{
    DWORD       dwSignature;    // DVSAVEHEADEREX_SIGNATURE
    WORD        cbSize;         // size of this structure, in bytes
    WORD        wVersion;       // DVSAVEHEADEREX_VERSION
    DWORD       cbStreamSize;   // size of all info saved, in bytes
    DWORD       dwUnused;       // used to be SIZE szExtended (ie4 beta1)
    WORD        cbColOffset;    // overrides DVSAVEHEADER.cbColOffset
    WORD        wAlign;
} IE4HEADER;

typedef struct 
{
    WIN95HEADER    dvSaveHeader;
    IE4HEADER  dvSaveHeaderEx;
} DVSAVEHEADER_COMBO;

#define IE4HEADER_SIGNATURE 0xf0f0f0f0 // don't conflict with CCOLSHEADER_SIGNATURE
#define IE4HEADER_VERSION 3 // for easy versioning

#define VIEWSTATEHEADER_SIGNATURE 0xfddfdffd
#define VIEWSTATEHEADER_VERSION_1 0x0C
#define VIEWSTATEHEADER_VERSION_2 0x0E
#define VIEWSTATEHEADER_VERSION_3 0x0f
#define VIEWSTATEHEADER_VERSION_CURRENT VIEWSTATEHEADER_VERSION_3

typedef struct
{
    GUID guidGroupID;
    SHCOLUMNID scidDetails; 
} GROUP_PERSIST;

typedef struct
{
    struct
    {
        DWORD  dwSignature;
        USHORT uVersion; // 0x0c == IE4, 0x0e == IE5
        USHORT uCols;
        USHORT uOffsetWidths;
        USHORT uOffsetColOrder;
    } Version1;

    struct
    {
        USHORT uOffsetColStates;
    } Version2;

    struct
    {
        USHORT uOffsetGroup;
    } Version3;
} VIEWSTATEHEADER;


class CViewState
{
    void InitFromHeader(DVSAVEHEADER_COMBO* pdv);
    void LoadPositionBlob(CDefView* pdv, DWORD cbSizeofStream, IStream* pstm);
    HRESULT SavePositionBlob(CDefView* pdv, IStream* pstm);
    BOOL SyncColumnWidths(CDefView* pdv, BOOL fSetListViewState);
    BOOL SyncColumnStates(CDefView* pdv, BOOL fSetListViewstate);
    BOOL SyncPositions(CDefView* pdv);
    static int CALLBACK _SavedItemCompare(void *p1, void *p2, LPARAM lParam);
    DWORD _GetStreamSize(IStream* pstm);
public:
    // Save State
    LPARAM  _lParamSort;
    int     _iDirection;
    int     _iLastColumnClick;
    DWORD   _ViewMode;
    POINTS  _ptScroll;

    HDSA    _hdsaColumnOrder;
    HDSA    _hdsaColumnWidths;
    HDSA    _hdsaColumnStates;
    HDSA    _hdsaColumns;
    HDPA    _hdpaItemPos;
    BYTE*   _pbPositionData;
    GUID    _guidGroupID;
    SHCOLUMNID _scidDetails; 

    BOOL    _fFirstViewed;

    CViewState();
    ~CViewState();

    // When initializing a new DefView, see if we can 
    // propogate information from the previous one.
    void InitFromPreviousView(IUnknown* pPrevView);
    void InitWithDefaults(CDefView* pdv);
    void GetDefaults(CDefView* pdv, LPARAM* plParamSort, int* piDirection, int* piLastColumnClick);
    HRESULT InitializeColumns(CDefView* pdv);

    BOOL AppendColumn(UINT uCol, USHORT uWidth, INT uOrder);
    BOOL RemoveColumn(UINT uCol);
    UINT GetColumnWidth(UINT uCol, UINT uDefaultWidth);
    UINT GetColumnCount();

    // Column Helpers.
    DWORD GetColumnState(UINT uCol);
    DWORD GetTransientColumnState(UINT uCol);
    void SetColumnState(UINT uCol, DWORD dwMask, DWORD dwState);
    void SetTransientColumnState(UINT uCol, DWORD dwMask, DWORD dwState);
    LPTSTR GetColumnName(UINT uCol);
    int GetColumnFormat(UINT uCol);
    UINT GetColumnCharCount(UINT uCol);

    // When Loading or Saving from the View State Stream
    HRESULT SaveToStream(CDefView* pdv, IStream* pstm);
    HRESULT LoadFromStream(CDefView* pdv, IStream* pstm);
    
    HRESULT SaveToPropertyBag(CDefView* pdv, IPropertyBag* ppb);
    HRESULT LoadFromPropertyBag(CDefView* pdv, IPropertyBag* ppb);

    // When Loading from a View Callback provided stream.
    HRESULT LoadColumns(CDefView* pdv, IStream* pstm);
    HRESULT SaveColumns(CDefView* pdv, IStream* pstm);

    // Syncronizes ListView with the current View State. 
    // TRUE means take the view state object and set it into the listview.
    HRESULT Sync(CDefView* pdv, BOOL fSetListViewState);
    void ClearPositionData();
    
    // Needs to be called at the time of CDefView::AddColumns
    BOOL SyncColumnOrder(CDefView* pdv, BOOL fSetListViewState);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ynlist.h ===
#ifndef _YNLIST_H
#define _YNLIST_H


typedef struct {

    LPTSTR pszzList;            // Double NULL terminated list of directories
    UINT  cbAlloc;              // Space allocated to list, in BYTEs
    UINT  cchUsed;              // Space used in list, in CHARacters
    BOOL  fEverythingInList;    // TRUE if everything is considered on the list

} DIRLIST, *PDIRLIST;

typedef struct {

    DIRLIST dlYes;              // List of YES directories
    DIRLIST dlNo;               // List of NO directories

} YNLIST, *PYNLIST;

STDAPI_(void) CreateYesNoList(PYNLIST pynl);
STDAPI_(void) DestroyYesNoList(PYNLIST pynl);
STDAPI_(BOOL) IsInYesList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(BOOL) IsInNoList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(void) AddToYesList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(void) AddToNoList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(void) SetYesToAll(PYNLIST pynl);

#endif  // _YNLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\w32utils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       w32utils.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: Win32 templates & utilities (ported from printscan\ui\printui)
 *
 *****************************************************************************/

#ifndef _W32UTILS_H
#define _W32UTILS_H

////////////////////////////////////////////////
//
// template class CScopeLocker<TLOCK>
//
template <class TLOCK>
class CScopeLocker
{
public:
    CScopeLocker(TLOCK &lock): 
        m_Lock(lock), m_bLocked(false) 
    { m_bLocked = (m_Lock && m_Lock.Lock()); }

    ~CScopeLocker() 
    { if (m_bLocked) m_Lock.Unlock(); }

    operator bool () const 
    { return m_bLocked; }

private:
    bool m_bLocked;
    TLOCK &m_Lock;
};

////////////////////////////////////////////////
//
// class CCSLock - win32 critical section lock.
//
class CCSLock
{
public:
    // CCSLock::Locker should be used as locker class.
    typedef CScopeLocker<CCSLock> Locker;
   
    CCSLock(): m_bInitialized(false)
    { 
        __try 
        { 
            // InitializeCriticalSection may rise STATUS_NO_MEMORY exception 
            // in low memory conditions (according the SDK)
            InitializeCriticalSection(&m_CS); 
            m_bInitialized = true; 
            return;
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {}
        // if we end up here m_bInitialized will remain false 
        // (i.e. out of memory exception was thrown)
    }

    ~CCSLock()    
    { 
        if (m_bInitialized) 
        {
            // delete the critical section only if initialized successfully
            DeleteCriticalSection(&m_CS); 
        }
    }

    operator bool () const
    { 
        return m_bInitialized; 
    }

    bool Lock()
    { 
        __try 
        { 
            // EnterCriticalSection may rise STATUS_NO_MEMORY exception 
            // in low memory conditions (this may happen if there is contention
            // and ntdll can't allocate the wait semaphore)
            EnterCriticalSection(&m_CS); 
            return true; 
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {}

        // out of memory or invalid handle exception was thrown.
        return false;
    }

    void Unlock() 
    {
        // Unlock() should be called *ONLY* if the corresponding 
        // Lock() call has succeeded.
        LeaveCriticalSection(&m_CS); 
    }

private:
    bool m_bInitialized;
    CRITICAL_SECTION m_CS;
};

#endif // endif _W32UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\_security.h ===
/**************************************************************\
    FILE: _security.h

    DESCRIPTION:
        This file will contain helper functions and objects that
    help deal with security.  This mainly means Zones Security, but
    can include other types.

    We can't call this file "security.h" because there's already
    a file with that name in sdk\inc.
\**************************************************************/

#ifndef __SECURITY_H
#define __SECURITY_H

#include <urlmon.h>

SHSTDAPI ZoneCheckPidl(LPCITEMIDLIST pidl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);

#endif // __SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\websvc.cpp ===
#include "shellprv.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "mshtmdid.h"
#include "htiframe.h"
#include "exdisp.h"
#include "exdispid.h"
#include "dspsprt.h"
#include "cowsite.h"
#include "ids.h"
#include "inetsmgr.h"
#pragma hdrstop


// helper functions

typedef BOOL (*pfnDllRegisterWindowClasses)(const SHDRC * pshdrc);

BOOL SHDOCVW_DllRegisterWindowClasses(const SHDRC * pshdrc)
{
    static HINSTANCE _hinstShdocvw = NULL;
    static pfnDllRegisterWindowClasses _regfunc = NULL;

    BOOL fSuccess = FALSE;

    if (!_hinstShdocvw)
    {
        _hinstShdocvw = LoadLibrary(TEXT("shdocvw.dll"));
        _regfunc = (pfnDllRegisterWindowClasses) GetProcAddress(_hinstShdocvw, "DllRegisterWindowClasses");
    }

    if (_regfunc)
        fSuccess = _regfunc(pshdrc);

    return fSuccess;
}


// Advise point for DIID_DWebBrowserEvents2
// Just an IDispatch implementation that delegates back to the main class. Allows us to have a separate "Invoke".

class CWebWizardPage;

class CWebEventHandler : public IServiceProvider, DWebBrowserEvents2
{
public:
    CWebEventHandler(CWebWizardPage *pswp); 
    ~CWebEventHandler();					// TODO: Make this virtual or it will never execute.

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() {return 2;}
    STDMETHODIMP_(ULONG) Release() {return 1;}

    // (DwebBrowserEvents)IDispatch
    STDMETHODIMP GetTypeInfoCount(/* [out] */ UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(
        /* [in] */ UINT iTInfo,
        /* [in] */ LCID lcid,
        /* [out] */ ITypeInfo **ppTInfo)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId)
        { return E_NOTIMPL; }
    
    /* [local] */ STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

    HRESULT _Advise(BOOL fConnect);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    CWebWizardPage* _pwizPage;
    DWORD _dwCPCookie;
    IConnectionPoint* _pcpCurrentConnection;
};

#define SHOW_PROGRESS_TIMER     1
#define SHOW_PROGRESS_TIMEOUT   1000 // Start showing the progress indicator after 1 second of dead time.

class CWebWizardPage : public CImpIDispatch, 
                              CObjectWithSite, 
                              IDocHostUIHandler,
                              IServiceProvider, 
                              IWebWizardExtension, 
                              INewWDEvents
{
public:
    CWebWizardPage();
    ~CWebWizardPage();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDocHostUIHandler
    STDMETHODIMP ShowContextMenu(
        /* [in] */ DWORD dwID,
        /* [in] */ POINT *ppt,
        /* [in] */ IUnknown *pcmdtReserved,
        /* [in] */ IDispatch *pdispReserved)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetHostInfo(
        /* [out][in] */ DOCHOSTUIINFO *pInfo);
    
    STDMETHODIMP ShowUI(
        /* [in] */ DWORD dwID,
        /* [in] */ IOleInPlaceActiveObject *pActiveObject,
        /* [in] */ IOleCommandTarget *pCommandTarget,
        /* [in] */ IOleInPlaceFrame *pFrame,
        /* [in] */ IOleInPlaceUIWindow *pDoc)
        { return E_NOTIMPL; }

    STDMETHODIMP HideUI(void)
        { return E_NOTIMPL; }
    
    STDMETHODIMP UpdateUI(void)
        { return E_NOTIMPL; }
    
    STDMETHODIMP EnableModeless(
        /* [in] */ BOOL fEnable)
        { return E_NOTIMPL; }
    
    STDMETHODIMP OnDocWindowActivate(
        /* [in] */ BOOL fActivate)
        { return E_NOTIMPL; }
    
    STDMETHODIMP OnFrameWindowActivate(
        /* [in] */ BOOL fActivate)
        { return E_NOTIMPL; }
    
    STDMETHODIMP ResizeBorder(
        /* [in] */ LPCRECT prcBorder,
        /* [in] */ IOleInPlaceUIWindow *pUIWindow,
        /* [in] */ BOOL fRameWindow)
        { return E_NOTIMPL; }
    
    STDMETHODIMP TranslateAccelerator(
        /* [in] */ LPMSG lpMsg,
        /* [in] */ const GUID *pguidCmdGroup,
        /* [in] */ DWORD nCmdID)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetOptionKeyPath(
        /* [out] */ LPOLESTR *pchKey,
        /* [in] */ DWORD dw)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetDropTarget(
        /* [in] */ IDropTarget *pDropTarget,
        /* [out] */ IDropTarget **ppDropTarget)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetExternal(
        /* [out] */ IDispatch **ppDispatch);
    
    STDMETHODIMP TranslateUrl(
        /* [in] */ DWORD dwTranslate,
        /* [in] */ OLECHAR *pchURLIn,
        /* [out] */ OLECHAR **ppchURLOut)
        { return E_NOTIMPL; }
    
    STDMETHODIMP FilterDataObject(
        /* [in] */ IDataObject *pDO,
        /* [out] */ IDataObject **ppDORet)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(
        /*[in]*/ REFGUID guidService,
        /*[in]*/ REFIID riid,
        /*[out]*/ void **ppv);

    // INewWDEvents

    // (IDispatch)
    STDMETHODIMP GetTypeInfoCount(
        /* [out] */ UINT *pctinfo)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetTypeInfo(
        /* [in] */ UINT iTInfo,
        /* [in] */ LCID lcid,
        /* [out] */ ITypeInfo **ppTInfo)
    {
        return CImpIDispatch::GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId)
    {
        return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr)
    {
        return CImpIDispatch::Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }

    STDMETHODIMP FinalBack(void);
    STDMETHODIMP FinalNext(void);
    STDMETHODIMP Cancel(void);

    STDMETHODIMP put_Caption(
        /* [in] */ BSTR bstrCaption);
    
    STDMETHODIMP get_Caption(
        /* [retval][out] */ BSTR *pbstrCaption);
    
    STDMETHODIMP put_Property(
        /* [in] */ BSTR bstrPropertyName,
        /* [in] */ VARIANT *pvProperty);
    
    STDMETHODIMP get_Property(
        /* [in] */ BSTR bstrPropertyName,
        /* [retval][out] */ VARIANT *pvProperty);
    
    STDMETHODIMP SetWizardButtons(
        /* [in] */ VARIANT_BOOL vfEnableBack,
        /* [in] */ VARIANT_BOOL vfEnableNext,
        /* [in] */ VARIANT_BOOL vfLastPage);

    STDMETHODIMP SetHeaderText(
        /* [in] */ BSTR bstrHeaderTitle,
        /* [in] */ BSTR bstrHeaderSubtitle);
    
    STDMETHODIMP PassportAuthenticate(
        /* [in] */ BSTR bstrSignInUrl,
        /* [retval][out] */ VARIANT_BOOL * pvfAuthenticated);

    // IWizardExtension
    STDMETHODIMP AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages);
    STDMETHODIMP GetFirstPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetLastPage(HPROPSHEETPAGE *phPage)
        { return GetFirstPage(phPage); }

    // IWebWizardExtension
    STDMETHODIMP SetInitialURL(LPCWSTR pszDefaultURL);
    STDMETHODIMP SetErrorURL(LPCWSTR pszErrorURL);

protected:
    friend class CWebEventHandler;
    void _OnDownloadBegin();
    void _OnDocumentComplete();

private:
    void _InitBrowser();
    HRESULT _NavigateBrowser(LPCWSTR pszUrl);
    HRESULT _CallScript(IWebBrowser2* pbrowser, LPCWSTR pszFunction);
    BOOL _IsScriptFunctionOnPage(IWebBrowser2* pbrowser, LPCWSTR pszFunction);
    BOOL _IsBrowserVisible();
    void _ShowBrowser(BOOL fShow);
    void _SizeProgress();
    void _ShowProgress(BOOL fShow);
    void _StartShowProgressTimer();
    void _SetHeaderText(LPCWSTR pszHeader, LPCWSTR pszSubHeader);

    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT PropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnDestroy(HWND hwnd);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnTimer(HWND hwnd, UINT nIDEvent);

    LONG _cRef;
    CWebEventHandler *_pwebEventHandler;
    IWebBrowser2 *_pwebbrowser;
    IOleInPlaceActiveObject *_poipao;
    HWND _hwndOCHost; // Web browser control window
    HWND _hwndFrame;  // Wizard frame window
    HWND _hwnd;       // Dialog window
    HPROPSHEETPAGE _hPage;

    LPWSTR _pszInitialURL;
    LPWSTR _pszErrorURL;
};


INT_PTR CWebWizardPage::StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWebWizardPage* pthis = (CWebWizardPage*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    PROPSHEETPAGE* ppage;
    INT_PTR fProcessed;

    if (uMsg == WM_INITDIALOG)
    {
        ppage = (PROPSHEETPAGE*) lParam;
        pthis = (CWebWizardPage*) ppage->lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
    }

    if (pthis != NULL)
    {
        fProcessed = pthis->DialogProc(hwndDlg, uMsg, wParam, lParam);
    }
    else
    {
        fProcessed = FALSE;
    }

    return fProcessed;
}


// construction and IUnknown

CWebEventHandler::CWebEventHandler(CWebWizardPage *pwswp) :
    _pcpCurrentConnection(NULL),
    _pwizPage(pwswp)
{
}

CWebEventHandler::~CWebEventHandler()
{
    _Advise(FALSE);
}

HRESULT CWebEventHandler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CWebEventHandler, IDispatch, DWebBrowserEvents2),
        QITABENTMULTI2(CWebEventHandler, DIID_DWebBrowserEvents2, DWebBrowserEvents2),
        // QITABENTMULTI2(CWebEventHandler, DIID_DWebBrowserEvents, DWebBrowserEvents),
        QITABENT(CWebEventHandler, IServiceProvider),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CWebEventHandler::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;                // no result yet

    // we are a site for the OleControlSite interfaces only    
    if (guidService == SID_OleControlSite)
    {
        if (riid == IID_IDispatch)
        {
            hr = this->QueryInterface(riid, ppv);
        }
    }
    return hr;
}

HRESULT CWebEventHandler_CreateInstance(CWebWizardPage *pwswp, CWebEventHandler **ppweh)
{
    *ppweh = new CWebEventHandler(pwswp);
    if (!*ppweh)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT CWebEventHandler::_Advise(BOOL fConnect)
{
    HRESULT hr = S_OK;

    // If we're already connected, disconnect, since we either want to disconnect or reconnect to
    // a different webbrowser.
    if (_pcpCurrentConnection)
    {
        hr = _pcpCurrentConnection->Unadvise(_dwCPCookie);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(_pcpCurrentConnection);
        }
    }
    else
    {
        // We expect that if _pcpCurrentConnection is NULL, no code earlier would have changed hr, and that it is still S_OK
        // The code below expects that if !SUCCEEDED(hr), Unadvise failed above.
        ASSERT(SUCCEEDED(hr));
    }

    if (_pwizPage && _pwizPage->_pwebbrowser)
    {
        if (SUCCEEDED(hr) && fConnect)
        {
            IConnectionPointContainer* pcontainer;
            hr = _pwizPage->_pwebbrowser->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcontainer));
            if (SUCCEEDED(hr))
            {
                IConnectionPoint* pconnpoint;
                hr = pcontainer->FindConnectionPoint(DIID_DWebBrowserEvents2, &pconnpoint);
                if (SUCCEEDED(hr))
                {
                    IDispatch* pDisp;
                    hr = QueryInterface(IID_PPV_ARG(IDispatch, &pDisp));
                    if (SUCCEEDED(hr))
                    {
                        hr = pconnpoint->Advise(pDisp, &_dwCPCookie);
                        pDisp->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
						// TODO: Enable ATOMICRELEASE() to verify we won't leak anything
			            // ATOMICRELEASE(_pcpCurrentConnection);
                        _pcpCurrentConnection = pconnpoint;
                    }
                    else
                    {
                        pconnpoint->Release();
                    }
                }
                pcontainer->Release();
            }
        }
    }

    return hr;
}

HRESULT CWebEventHandler::Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr)
{
    HRESULT hr = S_OK;
    switch (dispIdMember)
    {
        case DISPID_BEFORENAVIGATE2:
            _pwizPage->_OnDownloadBegin();
            break;

        case DISPID_DOCUMENTCOMPLETE:
            _pwizPage->_OnDocumentComplete();
            break;

        default:
            hr = DISP_E_MEMBERNOTFOUND;
            break;
    }
    return hr;
}

// Object for hosting HTML wizard pages

CWebWizardPage::CWebWizardPage() : 
    CImpIDispatch(LIBID_Shell32, 0, 0, IID_INewWDEvents),
    _cRef(1)
{
    // Ensure zero-init happened
    ASSERT(NULL == _pwebbrowser);
    ASSERT(NULL == _pwebEventHandler);
    ASSERT(NULL == _pszInitialURL);
    ASSERT(NULL == _pszErrorURL);
}

CWebWizardPage::~CWebWizardPage()
{
    ATOMICRELEASE(_pwebbrowser);
    ATOMICRELEASE(_pwebEventHandler);
    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_poipao);

    Str_SetPtr(&_pszInitialURL, NULL);
    Str_SetPtr(&_pszErrorURL, NULL);
}

HRESULT CWebWizardPage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENTMULTI(CWebWizardPage, IWizardExtension, IWebWizardExtension),
        QITABENT(CWebWizardPage, IWebWizardExtension),
        QITABENT(CWebWizardPage, IDocHostUIHandler),
        QITABENT(CWebWizardPage, IServiceProvider),
        QITABENT(CWebWizardPage, INewWDEvents),
        QITABENT(CWebWizardPage, IDispatch),
        QITABENT(CWebWizardPage, IWebWizardExtension),
        QITABENT(CWebWizardPage, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CWebWizardPage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CWebWizardPage::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CWebWizardPage::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (_punkSite)
        return IUnknown_QueryService(_punkSite, guidService, riid, ppv);
        
    return E_NOINTERFACE;
}


void CWebWizardPage::_OnDownloadBegin()
{
    _ShowBrowser(FALSE);
    _StartShowProgressTimer();

    SetWizardButtons(VARIANT_FALSE, VARIANT_FALSE, VARIANT_FALSE);
}

void CWebWizardPage::_OnDocumentComplete()
{
    if (!_IsScriptFunctionOnPage(_pwebbrowser, L"OnBack"))
    {
        // This is an invalid page; navigate to our private error page
        BSTR bstrOldUrl;
        if (_pwebbrowser && SUCCEEDED(_pwebbrowser->get_LocationURL(&bstrOldUrl)))
        {
#ifdef DEBUG
            if (IDYES == ::MessageBox(_hwnd, L"A Web Service Error has occured.\n\nDo you want to load the HTML page anyway so you can debug it?\n\n(This only appears in debug builds)", bstrOldUrl, MB_ICONERROR | MB_YESNO))
            {
                _ShowBrowser(TRUE);
                SysFreeString(bstrOldUrl);
                return;
            }
#endif
            BSTR bstrUrl = NULL;
            BOOL fUsingCustomError = FALSE;

            // If we have a custom error URL and we haven't already failed trying
            // to navigate to this custom URL...
            if ((NULL != _pszErrorURL) && 
                (0 != StrCmpI(_pszErrorURL, bstrOldUrl)))
            {
                // then use the custom URL.
                bstrUrl = SysAllocString(_pszErrorURL);
                fUsingCustomError = TRUE;
            }
            else
            {
                bstrUrl = SysAllocString(L"res://shell32.dll/WebServiceError.htm");
            }

            if (bstrUrl)
            {
                _pwebbrowser->Navigate(bstrUrl, NULL, NULL, NULL, NULL);
                SysFreeString(bstrUrl);

                // Custom error URL will provide its own header and subheader
                if (!fUsingCustomError)
                {
                    WCHAR szTitle[256];
                    LoadString(g_hinst, IDS_WEBDLG_ERRTITLE, szTitle, ARRAYSIZE(szTitle));
#ifdef DEBUG
                    _SetHeaderText(szTitle, bstrOldUrl);
#else
                    _SetHeaderText(szTitle, L"");
#endif
                }
            }
            SysFreeString(bstrOldUrl);
        }
        // else out of memory - oops.
    }
    else
    {
        _ShowBrowser(TRUE);
    }
}

HRESULT CWebWizardPage::GetHostInfo(DOCHOSTUIINFO* pInfo)
{
    ZeroMemory(pInfo, sizeof(*pInfo));
    pInfo->cbSize = sizeof(*pInfo);
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_NO3DBORDER | 
                     DOCHOSTUIFLAG_ENABLE_FORMS_AUTOCOMPLETE | DOCHOSTUIFLAG_THEME | 
                     DOCHOSTUIFLAG_FLAT_SCROLLBAR | DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK;
    return S_OK;
}

HRESULT CWebWizardPage::GetExternal(IDispatch** ppDispatch)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDispatch));
}

INT_PTR CWebWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_DESTROY, OnDestroy);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_TIMER, OnTimer);
    }
    return FALSE;
}

HRESULT CWebWizardPage::_CallScript(IWebBrowser2* pbrowser, LPCWSTR pszFunction)
{
    HRESULT hr = E_INVALIDARG;

    if (pbrowser)
    {
        IDispatch* pdocDispatch;

        hr = pbrowser->get_Document(&pdocDispatch);
        if ((S_OK == hr) && pdocDispatch)
        {
            IHTMLDocument* pdoc;
            hr = pdocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument, &pdoc));
            if (SUCCEEDED(hr))
            {
                IDispatch* pdispScript;
                hr = pdoc->get_Script(&pdispScript);
                if (S_OK == hr)
                {
                    DISPID dispid;
                    hr = pdispScript->GetIDsOfNames(IID_NULL, const_cast<LPWSTR*>(&pszFunction), 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                    if (SUCCEEDED(hr))
                    {
                        unsigned int uArgErr;
                        DISPPARAMS dispparams = {0};
                        hr = pdispScript->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &dispparams, NULL, NULL, &uArgErr);
                    }
                    pdispScript->Release();
                }
                else
                {
                    hr = E_FAIL;
                }
                pdoc->Release();
            }
            else
            {
                hr = E_FAIL;
            }
            pdocDispatch->Release();
        }
    }

    return hr;
}

BOOL CWebWizardPage::_IsScriptFunctionOnPage(IWebBrowser2* pbrowser, LPCWSTR pszFunction)
{
    HRESULT hr = E_INVALIDARG;

    if (pbrowser)
    {
        IDispatch* pdocDispatch;

        hr = pbrowser->get_Document(&pdocDispatch);
        if (S_OK == hr && pdocDispatch)
        {
            IHTMLDocument* pdoc;
            hr = pdocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument, &pdoc));
            if (SUCCEEDED(hr))
            {
                IDispatch* pdispScript;
                hr = pdoc->get_Script(&pdispScript);
                if (S_OK == hr)
                {
                    DISPID dispid;
                    hr = pdispScript->GetIDsOfNames(IID_NULL, const_cast<LPWSTR*>(&pszFunction), 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                    pdispScript->Release();
                }
                else
                {
                    hr = E_FAIL;
                }
                pdoc->Release();
            }
            else
            {
                hr = E_FAIL;
            }
            pdocDispatch->Release();
        }
    }

    return (S_OK == hr) ? TRUE : FALSE;
}


// Uncomment this to NOT pass the LCID on the URL query string - for testing only. 

BOOL CWebWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            {
                _SizeProgress();
                _ShowProgress(FALSE);
                _ShowBrowser(FALSE);

                // fetch the high contrast flag, and set accordingly for the HTML to read
                // its OK for us to fail setting this into the property bag.

                HIGHCONTRAST hc = {sizeof(hc)};
                if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
                {
                    VARIANT var = {VT_BOOL};
                    var.boolVal = (hc.dwFlags & HCF_HIGHCONTRASTON) ? VARIANT_TRUE:VARIANT_FALSE;
                    put_Property(L"HighContrast", &var);
                }

                // Position the OCHost window

                RECT rectClient;
                GetClientRect(hwnd, &rectClient);
                SetWindowPos(_hwndOCHost, NULL, 0, 0, rectClient.right, rectClient.bottom, SWP_NOMOVE | SWP_NOOWNERZORDER);

                // set the initial URL         

                if (_pszInitialURL)
                {
                    WCHAR szURLWithLCID[INTERNET_MAX_URL_LENGTH];
                    LPCWSTR pszFormat = StrChr(_pszInitialURL, L'?') ? L"%s&lcid=%d&langid=%d":L"%s?lcid=%d&langid=%d";
                    if (SUCCEEDED(StringCchPrintf(szURLWithLCID,
                                                  ARRAYSIZE(szURLWithLCID),
                                                  pszFormat,
                                                  _pszInitialURL,
                                                  GetUserDefaultLCID(),
                                                  GetUserDefaultUILanguage())))
                    {
                        _NavigateBrowser(szURLWithLCID);
                    }
                }
            }
            break;

        // WIZNEXT and WIZBACK don't actually cause a navigation to occur - they instead forward on the message to the
        // hosted web page. Real wizard navigations occur when the hosted web page calls our FinalBack() and FinalNext() methods.

        case PSN_WIZNEXT:
            _CallScript(_pwebbrowser, L"OnNext");
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
            return TRUE;

        case PSN_WIZBACK:
            _CallScript(_pwebbrowser, L"OnBack");
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
            return TRUE;

        // query cancel results in a call to the site to determine if we are going
        // to cancel out and if the site wants to provide a page for us to navigate
        // to - in some cases, eg. the web publishing wizard this is important
        // so that we can cancel the order being processed etc.

        case PSN_QUERYCANCEL:
            if (_punkSite)
            {
                IWizardSite *pws;
                if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                {
                    HPROPSHEETPAGE hpage;
                    if (S_OK == pws->GetCancelledPage(&hpage))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)TRUE);
                    }
                    pws->Release();
                }
            }
            return TRUE;

        case PSN_TRANSLATEACCELERATOR:
            {
                LPPSHNOTIFY ppsn = (LPPSHNOTIFY)pnmh;
                MSG *pmsg = (MSG *)ppsn->lParam;
                LONG_PTR lres = PSNRET_NOERROR;
                
                if (_poipao && S_OK == _poipao->TranslateAccelerator(pmsg))
                {
                    lres = PSNRET_MESSAGEHANDLED;
                }

                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, lres);
            }
            break;
                
    }

    return TRUE;
}

BOOL CWebWizardPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    _hwnd = hwnd;
    _hwndFrame = GetParent(hwnd);

    // lets remap some of the text in the dialog if we need to

    IResourceMap *prm;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_ResourceMap, IID_PPV_ARG(IResourceMap, &prm));
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdn;
        hr = prm->SelectResourceScope(TEXT("dialog"), TEXT("ws:downloading"), &pdn);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[512];
            if (SUCCEEDED(prm->LoadString(pdn, TEXT("header"), szBuffer, ARRAYSIZE(szBuffer))))
            {
                SetDlgItemText(hwnd, IDC_PROGTEXT1, szBuffer);
            }
            if (SUCCEEDED(prm->LoadString(pdn, TEXT("footer"), szBuffer, ARRAYSIZE(szBuffer))))
            {
                SetDlgItemText(hwnd, IDC_PROGTEXT2, szBuffer);
            }
            pdn->Release();
        }
        prm->Release();
    }

    // create the web view browser that we will show the providers HTML in

    SHDRC shdrc = {0};
    shdrc.cbSize = sizeof(shdrc);
    shdrc.dwFlags = SHDRCF_OCHOST;

    if (SHDOCVW_DllRegisterWindowClasses(&shdrc))
    {
        RECT rectClient;
        GetClientRect(hwnd, &rectClient);

        _hwndOCHost = CreateWindow(OCHOST_CLASS, NULL,
                                   WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_TABSTOP,
                                   0, 0, rectClient.right, rectClient.bottom,
                                   hwnd, NULL, g_hinst, NULL);
        if (_hwndOCHost)
        {
            OCHINITSTRUCT ocs = {0};
            ocs.cbSize = sizeof(ocs);   
            ocs.clsidOC  = CLSID_WebBrowser;
            ocs.punkOwner = SAFECAST(this, IDocHostUIHandler*);

            hr = OCHost_InitOC(_hwndOCHost, (LPARAM)&ocs);        
            if (SUCCEEDED(hr))
            {
                _InitBrowser();

                OCHost_DoVerb(_hwndOCHost, OLEIVERB_INPLACEACTIVATE, TRUE);
                ShowWindow(_hwndOCHost, TRUE);

                IServiceProvider* pSP;
                hr = _pwebEventHandler->QueryInterface(IID_PPV_ARG(IServiceProvider, &pSP));
                if (SUCCEEDED(hr))
                {
                    OCHost_SetServiceProvider(_hwndOCHost, pSP);
                    pSP->Release();
                }
            }
        }
    }

    if (FAILED(hr))
        EndDialog(hwnd, IDCANCEL);

    return TRUE;
}

BOOL CWebWizardPage::OnTimer(HWND hwnd, UINT nIDEvent)
{
    if (nIDEvent == SHOW_PROGRESS_TIMER)
    {
        _ShowProgress(TRUE);
    }
    return TRUE;
}

BOOL CWebWizardPage::OnDestroy(HWND hwnd)
{
    ATOMICRELEASE(_pwebbrowser);
    return TRUE;
}

void CWebWizardPage::_InitBrowser(void)
{
    ASSERT(IsWindow(_hwndOCHost));
    ASSERT(!_pwebbrowser);

    HRESULT hr = OCHost_QueryInterface(_hwndOCHost, IID_PPV_ARG(IWebBrowser2, &_pwebbrowser));
    if (SUCCEEDED(hr) && _pwebbrowser)
    {
        ITargetFrame2* ptgf;
        if (SUCCEEDED(_pwebbrowser->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            DWORD dwOptions;
            if (SUCCEEDED(ptgf->GetFrameOptions(&dwOptions)))
            {
                dwOptions |= FRAMEOPTIONS_BROWSERBAND | FRAMEOPTIONS_SCROLL_AUTO;
                ptgf->SetFrameOptions(dwOptions);
            }
            ptgf->Release();
        }

        _pwebbrowser->put_RegisterAsDropTarget(VARIANT_FALSE);

        // Set up the connection point (including creating the object

        if (!_pwebEventHandler)
            CWebEventHandler_CreateInstance(this, &_pwebEventHandler);

        if (_pwebEventHandler)
            _pwebEventHandler->_Advise(TRUE);

        OCHost_QueryInterface(_hwndOCHost, IID_PPV_ARG(IOleInPlaceActiveObject, &_poipao));
    }
}

HRESULT CWebWizardPage::_NavigateBrowser(LPCWSTR pszUrl)
{
    HRESULT hr = E_FAIL;

    if (_hwndOCHost && _pwebbrowser)
    {
        BSTR bstrUrl = SysAllocString(pszUrl);
        if (bstrUrl)
        {
            hr = _pwebbrowser->Navigate(bstrUrl, NULL, NULL, NULL, NULL);
            SysFreeString(bstrUrl);
        }
    }

    return hr;
}

HRESULT CWebWizardPage::FinalBack(void)
{
    if (_punkSite)
    {
        IWizardSite *pws;
        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
        {
            HPROPSHEETPAGE hpage;
            HRESULT hr = pws->GetPreviousPage(&hpage);
            if (SUCCEEDED(hr))
            {
                PropSheet_SetCurSel(_hwndFrame, hpage, -1);
            }
            pws->Release();
        }
    }
    return S_OK;
}

HRESULT CWebWizardPage::FinalNext(void)
{
    if (_punkSite)
    {
        IWizardSite *pws;
        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
        {
            HPROPSHEETPAGE hpage;
            HRESULT hr = pws->GetNextPage(&hpage);
            if (SUCCEEDED(hr))
            {
                PropSheet_SetCurSel(_hwndFrame, hpage, -1);
            }
            pws->Release();
        }
    }
    return S_OK;
}

HRESULT CWebWizardPage::Cancel(void)
{
    PropSheet_PressButton(_hwndFrame, PSBTN_CANCEL);      // simulate cancel...
    return S_OK;
}

HRESULT CWebWizardPage::put_Caption(
    /* [in] */ BSTR bstrCaption)
{
    return S_OK;
}

HRESULT CWebWizardPage::get_Caption(
    /* [retval][out] */ BSTR *pbstrCaption)
{
    WCHAR szCaption[MAX_PATH];

    GetWindowText(_hwndFrame, szCaption, ARRAYSIZE(szCaption));
    *pbstrCaption = SysAllocString(szCaption);

    return S_OK;
}


// fetch and put properties into the frames property bag.  this we do
// by a QueryService call and then we can modify the properties accordingly.

HRESULT CWebWizardPage::put_Property(
    /* [in] */ BSTR bstrPropertyName,
    /* [in] */ VARIANT *pvProperty)
{
    IPropertyBag *ppb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_WebWizardHost, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        hr = ppb->Write(bstrPropertyName, pvProperty);
        ppb->Release();
    }
    return hr;
}

HRESULT CWebWizardPage::get_Property(
    /* [in] */ BSTR bstrPropertyName,
    /* [retval][out] */ VARIANT *pvProperty)
{
    IPropertyBag *ppb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_WebWizardHost, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        hr = ppb->Read(bstrPropertyName, pvProperty, NULL);

        if (FAILED(hr))
        {
            // Return a NULL-variant
            VariantInit(pvProperty);
            pvProperty->vt = VT_NULL;
            hr = S_FALSE;
        }
        
        ppb->Release();
    }
    return hr;
}

HRESULT CWebWizardPage::SetWizardButtons(
    /* [in] */ VARIANT_BOOL vfEnableBack,
    /* [in] */ VARIANT_BOOL vfEnableNext,
    /* [in] */ VARIANT_BOOL vfLastPage)
{
    // We ignore vfLastPage because it isn't the last page for us!
    DWORD dwButtons = 0;

    if (vfEnableBack)
        dwButtons |= PSWIZB_BACK;

    if (vfEnableNext)
        dwButtons |= PSWIZB_NEXT;

    PropSheet_SetWizButtons(_hwndFrame, dwButtons);
    return S_OK;
}

void CWebWizardPage::_SetHeaderText(LPCWSTR pszHeader, LPCWSTR pszSubHeader)
{
    int iPageNumber = PropSheet_HwndToIndex(_hwndFrame, _hwnd);
    if (-1 != iPageNumber)
    {
        PropSheet_SetHeaderTitle(_hwndFrame, iPageNumber, pszHeader);
        PropSheet_SetHeaderSubTitle(_hwndFrame, iPageNumber, pszSubHeader);
    }
}

HRESULT CWebWizardPage::SetHeaderText(
    /* [in] */ BSTR bstrHeaderTitle,
    /* [in] */ BSTR bstrHeaderSubtitle)
{
    _SetHeaderText(bstrHeaderTitle, bstrHeaderSubtitle);
    return S_OK;
}

HRESULT CWebWizardPage::PassportAuthenticate(
        /* [in] */ BSTR bstrURL,
        /* [retval][out] */ VARIANT_BOOL * pfAuthenticated)
{
    *pfAuthenticated = VARIANT_FALSE;                 // the user isn't authenticated.

    IXMLHttpRequest *preq;
    HRESULT hr = CoCreateInstance(CLSID_XMLHTTPRequest, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLHttpRequest, &preq));
    if (SUCCEEDED(hr))
    {
        VARIANT varNULL = {0};
        VARIANT varAsync = {VT_BOOL};
        varAsync.boolVal = VARIANT_FALSE;

        // open a post request to the destination that we have
        hr = preq->open(L"GET", bstrURL, varAsync, varNULL, varNULL);
        if (SUCCEEDED(hr))
        {
            VARIANT varBody = {0};
            hr = preq->send(varBody);
            if (SUCCEEDED(hr))
            {
                long lStatus;
                hr = preq->get_status(&lStatus);
                if (SUCCEEDED(hr) && (lStatus == HTTP_STATUS_OK))
                {
                    *pfAuthenticated = VARIANT_TRUE;
                }
            }
        }
        preq->Release();
    }

    return S_OK;
}

BOOL CWebWizardPage::_IsBrowserVisible()
{
    return IsWindowVisible(_hwndOCHost);
}
 
void CWebWizardPage::_ShowBrowser(BOOL fShow)
{
    ShowWindow(_hwndOCHost, fShow ? SW_SHOW : SW_HIDE);

    if (fShow)
    {
        // Can't have these windows overlapping.
        _ShowProgress(FALSE);
    }
}

void CWebWizardPage::_StartShowProgressTimer()
{
    _ShowProgress(FALSE);

    if (!SetTimer(_hwnd, SHOW_PROGRESS_TIMER, SHOW_PROGRESS_TIMEOUT, NULL))
    {
        // Timer failed to set; show progress now;
        _ShowProgress(TRUE);
    }
}

// Size the progress bar to fit the client area it is in.
void CWebWizardPage::_SizeProgress()
{
    HWND hwndProgress = GetDlgItem(_hwnd, IDC_PROGRESS);

    RECT rcPage;
    GetClientRect(_hwnd, &rcPage);
    RECT rcProgress;
    GetClientRect(hwndProgress, &rcProgress);
    MapWindowPoints(hwndProgress, _hwnd, (LPPOINT) &rcProgress, 2);

    rcProgress.right = rcPage.right - rcProgress.left;

    SetWindowPos(hwndProgress, NULL, 0, 0, rcProgress.right - rcProgress.left, rcProgress.bottom - rcProgress.top, SWP_NOMOVE | SWP_NOZORDER | SWP_NOREPOSITION);
}

void CWebWizardPage::_ShowProgress(BOOL fShow)
{
    HWND hwndProgress = GetDlgItem(_hwnd, IDC_PROGRESS);
    ShowWindow(hwndProgress, fShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(_hwnd, IDC_PROGTEXT1), fShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(_hwnd, IDC_PROGTEXT2), fShow ? SW_SHOW : SW_HIDE);

    KillTimer(_hwnd, SHOW_PROGRESS_TIMER);

    if (fShow)
    {
        SendMessage(hwndProgress, PBM_SETMARQUEE, (WPARAM) TRUE, 0);

        // Set the header/subheader to a "Connecting to Internet" message.
        WCHAR szTitle[256];
        WCHAR szSubtitle[256];
        LoadString(g_hinst, IDS_WEBDLG_TITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_hinst, IDS_WEBDLG_SUBTITLE, szSubtitle, ARRAYSIZE(szSubtitle));
        _SetHeaderText(szTitle, szSubtitle);
    }
    else
    {
        SendMessage(hwndProgress, PBM_SETMARQUEE, (WPARAM) FALSE, 0);
    }
}


// IWizardExtn

UINT CWebWizardPage::PropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp)
{
    CWebWizardPage *pwwp = (CWebWizardPage*)ppsp->lParam;
    switch (uMsg)
    {
        case PSPCB_CREATE:
            return TRUE;

        // we need to release our site in this scenario, we know that we won't be using it
        // anymore, and to ensure that clients down have a circular refernce to us we
        // release it before they call us for our final destruction.

        case PSPCB_RELEASE:
            ATOMICRELEASE(pwwp->_punkSite);
            break;
    }
    return FALSE;
}

HRESULT CWebWizardPage::AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages)
{
    PROPSHEETPAGE psp = { 0 };
    psp.dwSize = sizeof(psp);
    psp.hInstance = g_hinst;
    psp.dwFlags = PSP_DEFAULT|PSP_USECALLBACK ;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_WEBWIZARD);
    psp.lParam = (LPARAM) this;
    psp.pfnDlgProc = CWebWizardPage::StaticProc;
    psp.pfnCallback = PropPageProc;

    _hPage = CreatePropertySheetPage(&psp);
    if (!_hPage)
        return E_FAIL;

    // return the page we created.

    *aPages = _hPage;
    *pnPages = 1;

    return S_OK;
}

STDMETHODIMP CWebWizardPage::GetFirstPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hPage;
    return S_OK;
}

STDMETHODIMP CWebWizardPage::SetInitialURL(LPCWSTR pszDefaultURL)
{
    HRESULT hr = E_INVALIDARG;
    if (pszDefaultURL)
    {
        hr = Str_SetPtr(&_pszInitialURL, pszDefaultURL) ? S_OK:E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CWebWizardPage::SetErrorURL(LPCWSTR pszErrorURL)
{
    HRESULT hr = E_INVALIDARG;
    if (pszErrorURL)
    {
        hr = Str_SetPtr(&_pszErrorURL, pszErrorURL) ? S_OK:E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI CWebWizardPage_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    if (NULL != pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CWebWizardPage *pwwp = new CWebWizardPage();
    if (!pwwp)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwwp->QueryInterface(riid, ppv);
    pwwp->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\xiconwrap.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "xiconwrap.h"

// IUnknown
STDMETHODIMP CExtractIconBase::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CExtractIconBase, IExtractIconA),
        QITABENT(CExtractIconBase, IExtractIconW),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CExtractIconBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CExtractIconBase::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CExtractIconBase::CExtractIconBase() : _cRef(1)
{
    DllAddRef();
}

CExtractIconBase::~CExtractIconBase()
{
    DllRelease();
}

// IExtractIconA
STDMETHODIMP CExtractIconBase::GetIconLocation(UINT uFlags,
    LPSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags)
{
    WCHAR sz[MAX_PATH];
    HRESULT hr = _GetIconLocationW(uFlags, sz, ARRAYSIZE(sz), piIndex, pwFlags);
    if (S_OK == hr)
    {
        // We don't want to copy the icon file name on the S_FALSE case
        SHUnicodeToAnsi(sz, pszIconFile, cchMax);
    }

    return hr;
}

STDMETHODIMP CExtractIconBase::Extract(LPCSTR pszFile, UINT nIconIndex,
    HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize)
{
    WCHAR sz[MAX_PATH];

    SHAnsiToUnicode(pszFile, sz, ARRAYSIZE(sz));
    return _ExtractW(sz, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}

// IExtractIconW
STDMETHODIMP CExtractIconBase::GetIconLocation(UINT uFlags,
    LPWSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags)
{
    return _GetIconLocationW(uFlags, pszIconFile, cchMax, piIndex, pwFlags);
}

STDMETHODIMP CExtractIconBase::Extract(LPCWSTR pszFile, UINT nIconIndex,
    HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize)
{
    return _ExtractW(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ynlist.c ===
#include "shellprv.h"
#include "ynlist.h"

#define YNLIST_ALLOC    (2 * MAX_PATH * sizeof(TCHAR))

//
// Constructor - creates a YesNoList
//
void CreateYesNoList(PYNLIST pynl)
{
    ZeroMemory(pynl, sizeof(*pynl));
}

//
// Destructor - frees and destroys a YesNoList
//
void DestroyYesNoList(PYNLIST pynl)
{
    if (pynl->dlYes.pszzList)
        GlobalFree(pynl->dlYes.pszzList);
    if (pynl->dlNo.pszzList)
        GlobalFree(pynl->dlNo.pszzList);
    ZeroMemory(pynl, sizeof(*pynl));
}

//
// IsPathOfItem - determine if pszPath is on the path to pszItem
//
BOOL IsPathOfItem(LPCTSTR pszPath, LPCTSTR pszItem)
{
    //
    // Validate pszPath is the first
    // substring of pszItem.
    //
    while (*pszPath)
    {
        if (*pszPath != *pszItem)
        {
            return FALSE;
        }

        pszPath++;
        pszItem++;
    }

    //
    // pszPath is the path if pszItem is empty (exact match),
    // or pszItem is a directory separator.
    //
    return (*pszItem == TEXT('\\')) || (*pszItem == TEXT('\0'));
}

//
// IsInDirList - determines if DIRLIST contains
// the path to pszItem.
//
BOOL IsInDirList(PDIRLIST pdl, LPCTSTR pszItem)
{
    LPTSTR pszzList;

    //
    // Quick check for everything flag.
    //
    if (pdl->fEverythingInList)
        return TRUE;

    //
    // Quick check for empty list.
    //
    if (pdl->pszzList == NULL)
    {
        return FALSE;
    }

    //
    // Compare against each string in the szz list.
    //
    pszzList = pdl->pszzList;
    while (*pszzList)
    {
        //
        // If pszList is the beginning of the path to pszItem,
        // the item is in the list.
        //
        if (IsPathOfItem(pszzList, pszItem))
        {
            return TRUE;
        }

        pszzList += lstrlen(pszzList) + 1;
    }

    //
    // Couldn't find it.
    //
    return FALSE;
}

//
// IsInYesList - determine if an item is in the
// yes list of a YesNoList.
//
BOOL IsInYesList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    return IsInDirList(&pynl->dlYes, pszItem);
}

//
// IsInNoList - determine if an item is in the
// no list of a YesNoList.
//
BOOL IsInNoList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    return IsInDirList(&pynl->dlNo, pszItem);
}

//
// AddToDirList - adds an item to a dir list if necessary.
//
void AddToDirList(PDIRLIST pdl, LPCTSTR pszItem)
{
    UINT cchItem;

    //
    // Is the item already in the list?
    //
    if (IsInDirList(pdl, pszItem))
    {
        return;
    }

    //
    // Is the list empty?
    //
    if (pdl->pszzList == NULL)
    {
        pdl->pszzList = (LPTSTR)GlobalAlloc(GPTR, YNLIST_ALLOC);

        if (pdl->pszzList == NULL)
        {
            return;
        }

        pdl->cbAlloc = YNLIST_ALLOC;
        pdl->cchUsed = 1;
        ASSERT(pdl->pszzList[0] == TEXT('\0'));
    }

    //
    // Get the string length,
    // verify it can be added with
    // at most one additional alloc.
    //
    cchItem = lstrlen(pszItem) + 1;
    if (CbFromCch(cchItem) >= YNLIST_ALLOC)
    {
        return;
    }

    //
    // Do we need to allocate more space?
    //
    if (CbFromCch(cchItem) > pdl->cbAlloc - CbFromCch(pdl->cchUsed))
    {
        LPTSTR pszzNew;

        pszzNew = (LPTSTR)GlobalReAlloc(pdl->pszzList, pdl->cbAlloc + YNLIST_ALLOC, GMEM_MOVEABLE|GMEM_ZEROINIT);

        if (pszzNew == NULL)
        {
            return;
        }
        pdl->pszzList = pszzNew;

        pdl->cbAlloc += YNLIST_ALLOC;
    }

    //
    // Add the item.
    //
    
    // Enough memory is allocated above that there is no need for bounded
    // copy
    lstrcpy(&(pdl->pszzList[pdl->cchUsed - 1]), pszItem);
    pdl->cchUsed += cchItem;

    //
    // Add the second NULL terminator
    // (GlobalReAlloc can't guarantee zeromeminit)
    //
    pdl->pszzList[pdl->cchUsed - 1] = TEXT('\0');
}

//
// Adds an item to the Yes list.
//
void AddToYesList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    AddToDirList(&pynl->dlYes, pszItem);
}

//
// Adds an item to the No list.
//
void AddToNoList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    AddToDirList(&pynl->dlNo, pszItem);
}

//
// SetYesToAll - puts everything in the yes list.
//
void SetYesToAll(PYNLIST pynl)
{
    pynl->dlYes.fEverythingInList = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\bands.cpp ===
#include "shellprv.h"
#include "bands.h"
#include "util.h"

#include "..\inc\bands.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\downlevel\makefile.inc ===
$(O)\dl_thunk.lst : dl_thunks.lst
    mkalias.cmd $** $(O)
    copy $** $@

$(O)\alias.lib : $(O)\dl_thunk.lst
    link -lib -out:$@ $(O)\alias_*.obj

$(PROJECT_ROOT)\lib\$(O)\downlevel_shell32.lib : $(O)\downlevel_shell32.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\xiconwrap.h ===
// Helper to create a IExtractIcon handler.
//
// Usage:
//      (1) Derive from CExtractIconBase to implement your business logic by
//          overloading CExtractIconBase two virtual member fcts
//              ex: class CEIBMyDerivedClass : public CExtractIconBase
//
//      (2) Add a few Initalization member fcts
//              ex: HRESULT CEIBMyDerivedClass::MyInit(MyData1* p1, MyData2* p2);
//
//      (3) Create your derived object using the new operator, 
//              ex: CEIBMyDerivedClass* peibmdc = new ...
//
//      (4) Initialize it (using (2)),
//              ex: hr = peibmdc->MyInit(p1, p2);
//

class CExtractIconBase : public IExtractIconA, public IExtractIconW
{
public:
    // IExtractIconA
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize);

    // IExtractIconW
    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCWSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize);

    // IUnknown helpers
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // derived class implements these
    virtual HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile,
        UINT cchMax, int *piIndex, UINT *pwFlags) PURE;
    virtual HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex,
        HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize) PURE;

    CExtractIconBase();

protected:
    virtual ~CExtractIconBase();

private:
    LONG _cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\downlevel\dl_thunks.c ===
#define _SHELL32_ 1 // we implement shell32 fn's

#include <windows.h>
#include <winnt.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>

// The following functions do NOT exist in NT4sp6's non-integrate shell32, so we implement them 
// here so that browseui and shdocvw can link to shell32.nt4 and this code lib (downlevel_shell32.lib)

HMODULE DL_GetSHELL32()
{
    static HMODULE hmod = (HMODULE)-1;

    if (hmod == (HMODULE)-1)
    {
        hmod = LoadLibraryA("shell32.dll");
    }

    return hmod;
}


typedef HRESULT (* PFNSHDefExtractIconA) (LPCSTR, int, UINT, HICON*, HICON*, UINT);
STDAPI DL_SHDefExtractIconA(
    LPCSTR pszIconFile,
    int iIndex,
    UINT uFlags,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHDefExtractIconA pfn = (PFNSHDefExtractIconA)-1;

        if (pfn == (PFNSHDefExtractIconA)-1)
        {
            pfn = (PFNSHDefExtractIconA)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(3));
        }
        
        if (pfn)
        {
            return pfn(pszIconFile, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
        }
    }

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}
PFNSHDefExtractIconA g_pfnDL_SHDefExtractIconA = &DL_SHDefExtractIconA;


typedef HRESULT (* PFNSHStartNetConnectionDialogW) (HWND, LPCWSTR, DWORD);
STDAPI DL_SHStartNetConnectionDialogW(
    HWND hwnd,
    LPCWSTR pszRemoteName,
    DWORD dwType
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHStartNetConnectionDialogW pfn = (PFNSHStartNetConnectionDialogW)-1;

        if (pfn == (PFNSHStartNetConnectionDialogW)-1)
        {
            pfn = (PFNSHStartNetConnectionDialogW)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(14));
        }
        
        if (pfn)
        {
            return pfn(hwnd, pszRemoteName, dwType);
        }
    }

    return S_OK;
}
PFNSHStartNetConnectionDialogW g_pfnDL_SHStartNetConnectionDialogW = &DL_SHStartNetConnectionDialogW;


typedef BOOL (* PFNDAD_DragEnterEx2) (HWND, const POINT, IDataObject*);
STDAPI_(BOOL) DL_DAD_DragEnterEx2(
    HWND hwndTarget,
    const POINT ptStart,
    IDataObject* pdtObject
    )
{
    // DAD_DragEnterEx2 only exists on v5 shell32 and higher
    if (GetUIVersion() >= 5)
    {
        static PFNDAD_DragEnterEx2 pfn = (PFNDAD_DragEnterEx2)-1;

        if (pfn == (PFNDAD_DragEnterEx2)-1)
        {
            pfn = (PFNDAD_DragEnterEx2)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(22));
        }
        
        if (pfn)
        {
            return pfn(hwndTarget, ptStart, pdtObject);
        }
    }

    // this exists on downlevel shell32, so we fall back to calling the older api
    return DAD_DragEnterEx(hwndTarget, ptStart);
}
PFNDAD_DragEnterEx2 g_pfnDL_DAD_DragEnterEx2 = &DL_DAD_DragEnterEx2;


typedef void (* PFNSHUpdateImageW) (LPCWSTR, int, UINT, int);
STDAPI_(void) DL_SHUpdateImageW(
    LPCWSTR pszHashItem,
    int iIndex,
    UINT uFlags,
    int iImageIndex
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHUpdateImageW pfn = (PFNSHUpdateImageW)-1;

        if (pfn == (PFNSHUpdateImageW)-1)
        {
            pfn = (PFNSHUpdateImageW)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(192));
        }
        
        if (pfn)
        {
            pfn(pszHashItem, iIndex, uFlags, iImageIndex);
            return;
        }
    }
}
PFNSHUpdateImageW g_pfnDL_SHUpdateImageW = &DL_SHUpdateImageW;


typedef int (* PFNSHHandleUpdateImage) (LPCITEMIDLIST);
STDAPI_(int) DL_SHHandleUpdateImage(
    LPCITEMIDLIST pidlExtra
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHHandleUpdateImage pfn = (PFNSHHandleUpdateImage)-1;

        if (pfn == (PFNSHHandleUpdateImage)-1)
        {
            pfn = (PFNSHHandleUpdateImage)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(193));
        }
        
        if (pfn)
        {
            return pfn(pidlExtra);
        }
    }

    return -1;
}
PFNSHHandleUpdateImage g_pfnDL_SHHandleUpdateImage = &DL_SHHandleUpdateImage;


typedef HRESULT (* PFNSHLimitInputEdit) (HWND, IShellFolder*);
STDAPI DL_SHLimitInputEdit(
    HWND hwndEdit,
    IShellFolder *psf
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHLimitInputEdit pfn = (PFNSHLimitInputEdit)-1;

        if (pfn == (PFNSHLimitInputEdit)-1)
        {
            pfn = (PFNSHLimitInputEdit)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(747));
        }
        
        if (pfn)
        {
            return pfn(hwndEdit, psf);
        }
    }

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}
PFNSHLimitInputEdit g_pfnDL_SHLimitInputEdit = DL_SHLimitInputEdit;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\cwndproc.h ===
#include "..\inc\cwndproc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\bands.h ===
#include "../inc/bands.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\basebar.h ===
#ifndef BaseBar_H_
#define BaseBar_H_
#include "cwndproc.h"

#ifdef __cplusplus

//========================================================================
// class CBaseBar (CBaseBar* pwbar)
//========================================================================
class CBaseBar : public IOleCommandTarget
               , public IServiceProvider
               , public IDeskBar
                ,public IInputObjectSite
                ,public IInputObject
               , public CImpWndProc
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk);
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient);
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

protected:
    // Constructor & Destructor
    CBaseBar();
    virtual ~CBaseBar();
   
    BOOL _CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);    

    virtual void _NotifyModeChange(DWORD dwMode); // NOTE: we may be abhe to get rid of this virtual...
    void _GetBorderRect(RECT* prc);

    virtual STDMETHODIMP ShowDW(BOOL fShow); // match IDockingWindow::ShowDW
    virtual STDMETHODIMP CloseDW(DWORD dwReserved); // match IDockingWindow::CloseDW
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual LRESULT _OnNotify(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnSize(void);
    virtual void _OnCreate();
    virtual void _OnPostedPosRectChange();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();

    // Window procedure
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    

    // Member variables
    UINT            _cRef;                  // reference count
    IUnknown*       _punkChild;             // ptr to IUnknown  for client area
    IDeskBarClient*     _pDBC;              // cached BaseBarClient for _punkChild
    IWinEventHandler*   _pWEH;              // cached IWenEventHandler for _punkChild
    HWND            _hwndChild;             // cached HWND      for _punkChild
    HWND            _hwndSite;              // hwnd of the site

    BOOL            _fShow :1;
    BOOL            _fPosRectChangePending;

    DWORD           _dwMode;

    SIZE            _szChild;               // last requested size from child

private:
    // Private members
    void _RegisterDeskBarClass();
    void _CreateDeskBarWindow();

};

#endif // __cplusplus
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\dpastuff.cpp ===
#include "shellprv.h"
#include "util.h"
#include "common.h"

#define _WorA_Shell_GetCachedImageIndex Shell_GetCachedImageIndex
#define IEILCreate _ILCreate

#include "..\inc\dpastuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\droptgt.h ===
#include "../inc/droptgt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\cwndproc.cpp ===
#include "shellprv.h"
#include "util.h"

#define g_fNewNotify TRUE
#define _SHChangeNotification_Lock SHChangeNotification_Lock
#define _SHChangeNotification_Unlock SHChangeNotification_Unlock

#include "..\inc\cwndproc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\basebar.cpp ===
#include "shellprv.h"
#include "apithk.h"
#include "basebar.h"

#define DBM_ONPOSRECTCHANGE  (WM_USER)


//*** CBaseBar::IDeskBar::* {
//


/*----------------------------------------------------------
Purpose: IDeskBar::SetClient

         Usually the function that composes a bar/bandsite/band
         union is responsible for calling this method to inform
         the bar what the client (bandsite) is.

*/
HRESULT CBaseBar::SetClient(IUnknown *punkChild)
{
    if (_punkChild != NULL)
    {
        // 4, 3, 2, 1 Release
        _hwndChild = NULL;

        if (_pDBC)
        {
            // This must happen first, before _pWEH becomes NULL so cleanup
            // notifications can still go thru
            _pDBC->SetDeskBarSite(NULL);
        }

        ATOMICRELEASE(_pDBC);

        ATOMICRELEASE(_pWEH);

        ATOMICRELEASE(_punkChild);
    }

    _punkChild = punkChild;

    HRESULT hr = S_OK;
    if (_punkChild != NULL)
    {
        // 1, 2, 3, 4 QI/AddRef/etc.
        _punkChild->AddRef();
        if (!_hwnd)
        {
            _RegisterDeskBarClass();
            _CreateDeskBarWindow();
            if (!_hwnd)
            {
                return E_OUTOFMEMORY;
            }

            // can't do CBaseBar::_Initialize yet (haven't done SetSite yet)
        }

        hr = _punkChild->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pWEH));
        if (SUCCEEDED(hr))
        {
            hr = _punkChild->QueryInterface(IID_PPV_ARG(IDeskBarClient, &_pDBC));
            if (SUCCEEDED(hr))
            {
                // nothing to cache yet due to lazy CreateWindow
                hr = _pDBC->SetDeskBarSite(SAFECAST(this, IDeskBar*));

                IUnknown_GetWindow(_punkChild, &_hwndChild);
            }
        }
    }

    return hr;
}

HRESULT CBaseBar::GetClient(IUnknown **ppunk)
{
    *ppunk = _punkChild;
    if (_punkChild)
        _punkChild->AddRef();
    return _punkChild ? S_OK : E_FAIL;
}

HRESULT CBaseBar::OnPosRectChangeDB(LPRECT prc)
{
    _szChild.cx = RECTWIDTH(*prc);
    _szChild.cy = RECTHEIGHT(*prc);

    // We can't change our size right away because we haven't returned from processing
    // this WM_SIZE message. If we resize right now, USER gets confused...
    //
    // We cannot use PeekMessage to determine if there is already a pending
    // DBM_ONPOSRECTCHANGE because that allows incoming SendMessage's to
    // arrive, and then we can get into a bad recursive situation when there
    // are a lot of SHChangeNotify's arriving in rapid succession.
    //
    if (!_fPosRectChangePending)
    {
        _fPosRectChangePending = TRUE;
        PostMessage(_hwnd, DBM_ONPOSRECTCHANGE, 0, 0);
    }

    return S_OK;
}

//  Derived classes are expected to implement this method and do something
//  interesting...
void CBaseBar::_OnPostedPosRectChange()
{
}

// }

HRESULT CBaseBar::ShowDW(BOOL fShow)
{
    fShow = BOOLIFY(fShow);

    if (BOOLIFY(_fShow) == fShow)
        return S_OK;

    _fShow = fShow;

    if (_pDBC)
        return _pDBC->UIActivateDBC(fShow ? DBC_SHOW : DBC_HIDE);
    else
        return E_UNEXPECTED;
}

void CBaseBar::_OnCreate()
{
    SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
}

LRESULT CBaseBar::_OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}


/***
 */
LRESULT CBaseBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch (uMsg) {
    case WM_CREATE:
        _OnCreate();
        break;

    case WM_COMMAND:
        return _OnCommand(uMsg, wParam, lParam);
        

    case WM_SIZE:     
        _OnSize();    
        break;

    case WM_NOTIFY:
        return _OnNotify(uMsg, wParam, lParam);

    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
    case WM_PALETTECHANGED:
        _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);
        break;

    case DBM_ONPOSRECTCHANGE:
        _fPosRectChangePending = FALSE;
        _OnPostedPosRectChange();
        break;

    default:
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

/***
 */
CBaseBar::CBaseBar() : _cRef(1)
{
    DllAddRef();
}

/***
 */
CBaseBar::~CBaseBar()
{
    // see Release, where we call virtuals (which can't be called from dtor)
    DllRelease();
}

/***
 */
void CBaseBar::_RegisterDeskBarClass()
{
    WNDCLASS  wc = {0};
    wc.style            = _GetClassStyle();
    wc.lpfnWndProc      = s_WndProc;
    //wc.cbClsExtra       = 0;
    wc.cbWndExtra       = SIZEOF(CBaseBar*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE+1);
    //wc.lpszMenuName     =  NULL;
    wc.lpszClassName    = TEXT("BaseBar");
    //wc.hIcon            = NULL;

    SHRegisterClass(&wc);
}

DWORD CBaseBar::_GetExStyle()
{
    return WS_EX_TOOLWINDOW;
}

DWORD CBaseBar::_GetClassStyle()
{
    return 0;
}

void CBaseBar::_CreateDeskBarWindow()
{
    // _hwnd is set in s_WndProc
    DWORD dwExStyle = _GetExStyle();    
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;
    HWND hwndDummy = CreateWindowEx(
                                    dwExStyle,
                                    TEXT("BaseBar"), NULL,
                                    _hwndSite ? WS_CHILD | WS_CLIPCHILDREN : WS_POPUP | WS_CLIPCHILDREN,
                                    0,0,100,100,
                                    _hwndSite, NULL, HINST_THISDLL,
                                    (LPVOID)SAFECAST(this, CImpWndProc*));
}


void CBaseBar::_OnSize(void)
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);
    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER);
}

void CBaseBar::_NotifyModeChange(DWORD dwMode)
{
    if (_pDBC) {
        _dwMode = dwMode;
        // FEATURE: should we add an STBBIF_VIEWMODE_FLOAT?
        _pDBC->SetModeDBC(_dwMode);
    }
}

BOOL CBaseBar::_CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwnd = NULL;

    *plres = 0;
    switch (uMsg)
    {
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        hwnd = _hwndChild;
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        hwnd = _hwndChild;
        break;
    }
    
    if (hwnd && _pWEH && _pWEH->IsWindowOwner(hwnd) == S_OK)
    {
        _pWEH->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
        return TRUE;
    }
    return FALSE;
}

/***
 */
LRESULT CBaseBar::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}

HRESULT CBaseBar::CloseDW(DWORD dwReserved)
{
    SetClient(NULL);
    if (_hwnd) {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    return S_OK;
}


HRESULT CBaseBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBaseBar, IOleWindow),
        QITABENT(CBaseBar, IDeskBar),
        QITABENT(CBaseBar, IInputObject),
        QITABENT(CBaseBar, IInputObjectSite),
        QITABENT(CBaseBar, IServiceProvider),
        QITABENT(CBaseBar, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


ULONG CBaseBar::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBaseBar::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    // 'virtual dtor'
    // gotta do virtual stuff here (not in dtor) because can't call
    // any virtuals in the dtor
    // CBaseBar::Destroy() {
    CloseDW(0);
    // }

    delete this;
    return 0;
}

//*** CBaseBar::IOleWindow::* {
//

HRESULT CBaseBar::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return (_hwnd) ? S_OK : E_FAIL;
}

HRESULT CBaseBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    // FEATURE: Visit here later.
    return E_NOTIMPL;
}
// }


// }
// some helpers... {

// What's the point of having
// these empty implementations in the base class?
//

//*** CBaseBar::IServiceProvider::*
//
HRESULT CBaseBar::QueryService(REFGUID guidService,
                                REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;

    return hres;
}

//*** CBaseBar::IOleCommandTarget::*
//
HRESULT CBaseBar::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return MayQSForward(_pDBC, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CBaseBar::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return MayExecForward(_pDBC, OCTD_DOWN, pguidCmdGroup, nCmdID, nCmdexecopt,
        pvarargIn, pvarargOut);
}

// }


//*** CDeskBar::IInputObject::* {

HRESULT CBaseBar::HasFocusIO()
{
    HRESULT hres;

    hres = IUnknown_HasFocusIO(_pDBC);
    return hres;
}

HRESULT CBaseBar::TranslateAcceleratorIO(LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_TranslateAcceleratorIO(_pDBC, lpMsg);
    return hres;
}

HRESULT CBaseBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_UIActivateIO(_pDBC, fActivate, lpMsg);
    return hres;
}

// }

//***   CDeskBar::IInputObjectSite::* {

HRESULT CBaseBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

#include "clsobj.h"

// For use with VC6
#pragma warning(4:4242)  //'initializing' : conversion from 'unsigned int' to 'unsigned short', possible loss of data


#define NO_CFVTBL
#include <cfdefs.h>
#include <exdispid.h>
#include <htiframe.h>
#include <mshtmhst.h>
#include <brutil.h>

#include "ids.h"

#define EnterModeless() AddRef()       // Used for selfref'ing
#define ExitModeless() Release()

#define SID_SDropBlocker CLSID_SearchBand
#define DLL_IS_UNICODE         (sizeof(TCHAR) == sizeof(WCHAR))
#define LoadMenuPopup(id) SHLoadMenuPopup(MLGetHinst(), id)   

#define MAX_TOOLTIP_STRING 80
#define REG_SUBKEY_FAVORITESA            "\\MenuOrder\\Favorites"
#define REG_SUBKEY_FAVORITES             TEXT(REG_SUBKEY_FAVORITESA)

// Command group for private communication with CITBar
// 67077B95-4F9D-11D0-B884-00AA00B60104
const GUID CGID_PrivCITCommands = { 0x67077B95L, 0x4F9D, 0x11D0, 0xB8, 0x84, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };


// IBandNavigate
//  band needs to navigate its UI to a specific pidl.
#undef  INTERFACE
#define INTERFACE  IBandNavigate
DECLARE_INTERFACE_(IBandNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBandNavigate methods ***
    STDMETHOD(Select)(THIS_ LPCITEMIDLIST pidl) PURE;

} ;

#define TF_SHDREF           TF_MENUBAND
#define TF_BAND             TF_MENUBAND      // Bands (ISF Band, etc)

#define DF_GETMSGHOOK       0x00001000      // GetMessageFilter 
#define DF_TRANSACCELIO     0x00002000      // GetMessageFilter 
#define THID_TOOLBARACTIVATED       6

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\droptgt.cpp ===
#include "shellprv.h"

#define TF_SHDLIFE          TF_MENUBAND
#define TF_BAND             TF_MENUBAND      // Bands (ISF Band, etc)


void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
void _DragMove(HWND hwndTarget, const POINTL ptStart);


#include "..\inc\droptgt.h"
#include "..\inc\droptgt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\fadetsk.h ===
#ifndef _FADETSK_H
#define _FADETSK_H

class CFadeTask : public IFadeTask
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IFadeTask ***
    STDMETHODIMP FadeRect(LPCRECT prc);

private:
    friend HRESULT CFadeTask_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    CFadeTask();
    ~CFadeTask();

    void _DoPreFade();
    void _DoFade();
    void _StopFade();

    static DWORD WINAPI s_FadeThreadProc(LPVOID lpThreadParameter);
    static DWORD WINAPI s_FadeSyncProc(LPVOID lpThreadParameter);

    LONG        _cRef;
    HWND        _hwndFader;
    RECT        _rect;
    HDC         _hdcFade;
    HBITMAP     _hbm;
    HBITMAP     _hbmOld;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\fadetsk.cpp ===
#include "shellprv.h"
#include "common.h"
#include "fadetsk.h"

BOOL BlendLayeredWindow(HWND hwnd, HDC hdcDest, POINT* ppt, SIZE* psize, HDC hdc, POINT* pptSrc, BYTE bBlendConst)
{
    BLENDFUNCTION blend;
    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bBlendConst;

    return UpdateLayeredWindow(hwnd, hdcDest, ppt, psize, hdc, pptSrc, 0, &blend, ULW_ALPHA);
}

/// Fade Rect Support

CFadeTask::CFadeTask()
{
    _cRef = 1;

    WNDCLASSEX wc = {0};
    if (!GetClassInfoEx(g_hinst, TEXT("SysFader"), &wc)) 
    {
        wc.cbSize          = sizeof(wc);
        wc.lpfnWndProc     = DefWindowProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hInstance       = g_hinst;
        wc.lpszClassName   = TEXT("SysFader");
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;

        // If this fails we just wind up with a NULL _hwndFader
        RegisterClassEx(&wc);
    }
    _hwndFader = CreateWindowEx(WS_EX_LAYERED | WS_EX_TRANSPARENT | 
                            WS_EX_TOPMOST | WS_EX_TOOLWINDOW, 
                            TEXT("SysFader"), TEXT("SysFader"),
                            WS_POPUP,
                            0, 0, 0, 0, NULL, (HMENU) 0, 
                            g_hinst, NULL);
}

STDAPI CFadeTask_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    *ppv = NULL;

    ASSERT(!punkOuter); // clsobj.c should've filtered this out already
    CFadeTask *ptFader = new CFadeTask();
    if (ptFader)
    {
        hr = ptFader->QueryInterface(riid, ppv);
        ptFader->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


CFadeTask::~CFadeTask()
{
    // Must use WM_CLOSE instead of DestroyWindow to ensure proper
    // destruction in case the final release occurs from the background
    // thread.  (Threads are not allowed to DestroyWindow windows that
    // are owned by other threads.)

    if (_hwndFader)
        SendNotifyMessage(_hwndFader, WM_CLOSE, 0, 0);
}

HRESULT CFadeTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFadeTask, IFadeTask),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}


ULONG CFadeTask::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFadeTask::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


#define ALPHASTART (200)

HRESULT CFadeTask::FadeRect(LPCRECT prc)
{
    BOOL fThreadStarted = FALSE;

    if (_hwndFader)
    {
        _rect = *prc;

        POINT   pt;
        POINT   ptSrc = {0, 0};
        SIZE    size;

        // prc and pt are in screen coordinates.
        pt.x = _rect.left;
        pt.y = _rect.top;

        // Get the size of the rectangle for the blits.
        size.cx = RECTWIDTH(_rect);
        size.cy = RECTHEIGHT(_rect);

        // Get the DC for the screen and window.
        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            HDC hdcWin = GetDC(_hwndFader);
            if (hdcWin)
            {
                // If we don't have a HDC for the fade, then create one.
                if (!_hdcFade)
                {
                    _hdcFade = CreateCompatibleDC(hdcScreen);
                    if (!_hdcFade)
                        goto Stop;

                    // Create a bitmap that covers the fade region, instead of the whole screen.
                    _hbm = CreateCompatibleBitmap(hdcScreen, size.cx, size.cy);
                    if (!_hbm)
                        goto Stop;

                    // select it in, saving the old bitmap's handle
                    _hbmOld = (HBITMAP)SelectBitmap(_hdcFade, _hbm);
                }

                // Get the stuff from the screen and squirt it into the fade dc.
                BitBlt(_hdcFade, 0, 0, size.cx, size.cy, hdcScreen, pt.x, pt.y, SRCCOPY);

                // Now let user do it's magic. We're going to mimic user and start with a slightly
                // faded, instead of opaque, rendering (Looks smoother and cleaner.
                BlendLayeredWindow(_hwndFader, hdcWin, &pt, &size, _hdcFade, &ptSrc, ALPHASTART);

                fThreadStarted = SHCreateThread(s_FadeThreadProc, this, 0, s_FadeSyncProc);
        Stop:
                ReleaseDC(_hwndFader, hdcWin);
            }

            ReleaseDC(NULL, hdcScreen);
        }

        if (!fThreadStarted)
        {
            // clean up member variables on failure
            _StopFade();
        }
    }

    return fThreadStarted ? S_OK : E_FAIL;
}



#define FADE_TIMER_ID 10
#define FADE_TIMER_TIMEOUT 10 // milliseconds
#define FADE_TIMEOUT 350 // milliseconds
#define FADE_ITERATIONS 35
#define QUAD_PART(a) ((a)##.QuadPart)

void CFadeTask::_StopFade()
{
    if (_hdcFade)
    {
        if (_hbmOld)
        {
            SelectBitmap(_hdcFade, _hbmOld);
        }
        DeleteDC(_hdcFade);
        _hdcFade = NULL;
    }
    
    if (_hbm)
    {
        DeleteObject(_hbm);
        _hbm = NULL;
    }
}

DWORD CFadeTask::s_FadeSyncProc(LPVOID lpThreadParameter)
{
    CFadeTask* pThis = (CFadeTask*)lpThreadParameter;
    pThis->AddRef();
    pThis->_DoPreFade();
    return 0;
}

DWORD CFadeTask::s_FadeThreadProc(LPVOID lpThreadParameter)
{
    CFadeTask* pThis = (CFadeTask*)lpThreadParameter;
    pThis->_DoFade();
    pThis->Release();
    return 0;
}

void CFadeTask::_DoPreFade()
{
    // Now that we have it all build up, display it on screen.
    SetWindowPos(_hwndFader, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
}

void CFadeTask::_DoFade()
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;
    LARGE_INTEGER liStart;
    DWORD dwElapsed;
    BYTE bBlendConst;

    // Start the fade timer and the count-down for the fade.
    QueryPerformanceFrequency(&liFreq);
    QueryPerformanceCounter(&liStart);

    // Do this until the conditions specified in the loop.
    while ( TRUE )
    {
        // Calculate the elapsed time in milliseconds.
        QueryPerformanceCounter(&liDiff);
        QUAD_PART(liDiff) -= QUAD_PART(liStart);
        dwElapsed = (DWORD)((QUAD_PART(liDiff) * 1000) / QUAD_PART(liFreq));

        if (dwElapsed >= FADE_TIMEOUT) 
        {
            goto Stop;
        }

        bBlendConst = (BYTE)(ALPHASTART * (FADE_TIMEOUT - 
                dwElapsed) / FADE_TIMEOUT);

        if (bBlendConst <= 1) 
        {
            goto Stop;
        }

        // Since only the alpha is updated, there is no need to pass
        // anything but the new alpha function. This saves a source copy.
        if (!BlendLayeredWindow(_hwndFader, NULL, NULL, NULL, NULL, NULL, bBlendConst))
        {
            // The app we just launched probably switched the screen into
            // a video mode that doesn't support layered windows, so just bail.
            goto Stop;
        }
        Sleep(FADE_TIMER_TIMEOUT);
    }

Stop:
    SetWindowPos(_hwndFader, HWND_BOTTOM, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);

    _StopFade();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\isfmenu.h ===
// CISFMenuCallback implementation

#ifndef _ISFMENU_H
#define _ISFMENU_H

#include "cowsite.h"

class CISFMenuCallback : public IShellMenuCallback,
                           public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);

    CISFMenuCallback();
    HRESULT Initialize(IUnknown* punk);

private:
    virtual ~CISFMenuCallback();

    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    BOOL _IsVisible(LPITEMIDLIST pidl);
    HRESULT _GetSFInfo(LPSMDATA psmd, PSMINFO psminfo);

    int _cRef;
    IOleCommandTarget* _poct;    // our isfband subject
    IUnknown* _punkSite;
    LPITEMIDLIST _pidl;
};

#endif // _ISFMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\icotask.h ===
#ifndef CIconTask_h
#define CIconTask_h

#include <runtask.h>

typedef void (*PFNICONTASKBALLBACK)(LPVOID pvData, UINT uId, UINT iIconIndex);

class CIconTask : public CRunnableTask
{
public:
    // IRunnableTask methods (override)
    virtual STDMETHODIMP RunInitRT(void);

    CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId);
private:
    virtual ~CIconTask();


    LPITEMIDLIST        _pidl;
    PFNICONTASKBALLBACK _pfn;
    LPVOID              _pvData;
    UINT                _uId;
};

// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98
HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder,
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId, 
                    int* piTempIcon);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\iaccess.cpp ===
#include "shellprv.h"
// APPCOMPAT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "apithk.h"
#include "mnbandid.h"
#include "initguid.h"
#include "iaccess.h"

#include "mluisupp.h"

CAccessible::CAccessible(HMENU hmenu, WORD wID):
    _hMenu(hmenu), _wID(wID), _cRef(1)
{
    _fState = MB_STATE_TRACK;
}

CAccessible::CAccessible(IMenuBand* pmb): _cRef(1)
{
    _fState = MB_STATE_MENU;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::CAccessible(IMenuBand* pmb, int iIndex): _cRef(1)
{
    _fState = MB_STATE_ITEM;
    _iAccIndex = iIndex;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::~CAccessible()
{
    ATOMICRELEASE(_pTypeInfo);
    ATOMICRELEASE(_pInnerAcc);
    switch (_fState)
    {
    case MB_STATE_TRACK:
        ASSERT(!_hwndMenuWindow || IsWindow(_hwndMenuWindow));
        if (_hwndMenuWindow)
        {
            // Don't Destroy hmenu. It's part of a larger one...
            SetMenu(_hwndMenuWindow, NULL);
            DestroyWindow(_hwndMenuWindow);
            _hwndMenuWindow = NULL;
        }
        break;

    case MB_STATE_ITEM:
        ATOMICRELEASE(_pmtbItem);
        // Fall Through

    case MB_STATE_MENU:
        ATOMICRELEASE(_pmtbTop);
        ATOMICRELEASE(_pmtbBottom);
        ATOMICRELEASE(_psma);
        ATOMICRELEASE(_pmb);
        break;
    }
}

HRESULT CAccessible::InitAcc()
{
    HRESULT hr = E_FAIL;
    if (_fInitialized)
        return NOERROR;

    _fInitialized = TRUE;   // We're initialized if we fail or not...

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (EVAL(_hMenu))
        {
            _hwndMenuWindow = CreateWindow(TEXT("static"),
                TEXT("MenuWindow"), WS_POPUP, 0, 0, 0, 0, NULL,
                _hMenu, g_hinst, NULL);
            if (EVAL(_hwndMenuWindow))
            {
                IAccessible* paccChild1;
                hr = CreateStdAccessibleObject(_hwndMenuWindow, OBJID_MENU, IID_PPV_ARG(IAccessible, &paccChild1));
                if (SUCCEEDED(hr))
                {
                    VARIANT varChild;
                    varChild.vt = VT_I4;
                    varChild.lVal = _wID + 1;        //Accesibility is 1 based

                    // In order to get "On par" with the OleAcc's implementation of the HMENU wrapper,
                    // we need to do this twice. Once gets us the IAccessible for the "MenuItem" on the 
                    // "Menubar". The second gets us the "Menuitem's" child. This is what we need to emulate
                    // their heirarchy.
                    IDispatch* pdispChild1;
                    hr = paccChild1->get_accChild(varChild, &pdispChild1);

                    // OLEAcc returns a Success code (S_FALSE) while initializing the out param to zero.
                    // Explicitly test this situation.

                    // Does this have a Child?
                    if (hr == S_OK)
                    {
                        // Yes. Look for that child
                        IAccessible* paccChild2;
                        hr = pdispChild1->QueryInterface(IID_PPV_ARG(IAccessible, &paccChild2));

                        // Does this have a child?
                        if (hr == S_OK)
                        {
                            // Yep, then we store this guy's child...
                            IDispatch* pdispChild2;
                            varChild.lVal = 1;        //Get the first child
                            hr = paccChild2->get_accChild(varChild, &pdispChild2);
                            if (hr == S_OK)
                            {
                                hr = pdispChild2->QueryInterface(IID_PPV_ARG(IAccessible, &_pInnerAcc));
                                pdispChild2->Release();
                            }
                            paccChild2->Release();
                        }
                        pdispChild1->Release();
                    }
                    paccChild1->Release();
                }
            }
        }
        break;


    case MB_STATE_ITEM:
    case MB_STATE_MENU:
        hr = _pmb->QueryInterface(IID_PPV_ARG(IShellMenuAcc, &_psma));
        if (SUCCEEDED(hr))
        {
            _psma->GetTop(&_pmtbTop);
            _psma->GetBottom(&_pmtbBottom);
            if (!_pmtbTop || !_pmtbBottom)
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr) && (_fState == MB_STATE_ITEM))
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            if (SUCCEEDED(_GetChildFromVariant(&varChild, &_pmtbItem, &_iIndex)))
                _idCmd = GetButtonCmd(_pmtbItem->_hwndMB, _iIndex);
        }

        break;
    }

    return hr;
}



/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CAccessible::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessible, IDispatch),
        QITABENT(CAccessible, IAccessible),
        QITABENT(CAccessible, IEnumVARIANT),
        QITABENT(CAccessible, IOleWindow),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfoCount method

*/
STDMETHODIMP CAccessible::GetTypeInfoCount(UINT * pctinfo)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfoCount(pctinfo);
    *pctinfo = 1;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfo method

*/
STDMETHODIMP CAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    *pptinfo = NULL;
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfo(itinfo, lcid, pptinfo);

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (EVAL(_LoadTypeLib()))
    {
        *pptinfo = _pTypeInfo;
        _pTypeInfo->AddRef();
        return NOERROR;
    }
    else
        return E_FAIL;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetIDsOfNames method

*/
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
        LCID lcid, DISPID * rgdispid)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDispatch::Invoke method

*/
STDMETHODIMP CAccessible::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,
    UINT * puArgErr)

{
    if (_pInnerAcc)
        return _pInnerAcc->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, 
            pexcepinfo, puArgErr);
    
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->Invoke(static_cast<IDispatch*>(this),
            dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
        return E_FAIL;
}

BOOL CAccessible::_LoadTypeLib()
{
    ITypeLib* pTypeLib;
    if (_pTypeInfo)
        return TRUE;

    if (SUCCEEDED(LoadTypeLib(L"oleacc.dll", &pTypeLib)))
    {
        pTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &_pTypeInfo);
        ATOMICRELEASE(pTypeLib);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accParent method

*/
STDMETHODIMP CAccessible::get_accParent(IDispatch ** ppdispParent)
{   
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accParent(ppdispParent);
        break;

    case MB_STATE_MENU:
        {
            IUnknown* punk;
            if (SUCCEEDED(_psma->GetParentSite(IID_PPV_ARG(IUnknown, &punk))))
            {
                IAccessible* pacc;
                if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                    IID_PPV_ARG(IAccessible, &pacc))))
                {
                    VARIANT varChild = {VT_I4, CHILDID_SELF};     // Init
                    hr = pacc->get_accFocus(&varChild);
                    if (SUCCEEDED(hr))
                    {
                        hr = pacc->get_accChild(varChild, ppdispParent);
                    }
                    VariantClear(&varChild);
                    pacc->Release();
                }
                else
                {
                    // Another implementation headache: Accessibility requires
                    // us to return S_FALSE when there is no parent.

                    *ppdispParent = NULL;
                    hr = S_FALSE;
                }

                punk->Release();
            }

            return hr;
        }
    case MB_STATE_ITEM:
        // The parent of an item is the menuband itself
        return IUnknown_QueryService(_psma, SID_SMenuPopup, IID_PPV_ARG(IDispatch, ppdispParent));
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChildCount method

*/
STDMETHODIMP CAccessible::get_accChildCount(long * pChildCount)
{   
    *pChildCount = 0;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChildCount(pChildCount);
        break;

    case MB_STATE_MENU:
        {
            int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
            int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
            *pChildCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;
        }
        break;
    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            *pChildCount = 1;
        break;

    }
    
    return NOERROR;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChild method

*/
STDMETHODIMP CAccessible::get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild)     
{   
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChild(varChildIndex, ppdispChild);
        break;

    case MB_STATE_MENU:
        {
            if (varChildIndex.vt == VT_I4 && varChildIndex.lVal == CHILDID_SELF)
            {
                // So this is the ONLY menthod that is allowed to fail when something is
                // unavailable.
                *ppdispChild = NULL;
                hr = E_INVALIDARG;
            }
            else
            {
                int iIndex;
                // Since it's returing an index, we don't need to test the success case
                _GetChildFromVariant(&varChildIndex, NULL, &iIndex);
                hr = _GetAccessibleItem(iIndex, ppdispChild);
            }
        }
        break;

    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
        {
            VARIANT varChild;
            hr = _GetVariantFromChildIndex(_pmtbItem->_hwndMB, _iIndex, &varChild);
            if (SUCCEEDED(hr))
            {
                hr = _psma->GetSubMenu(&varChild, IID_PPV_ARG(IDispatch, ppdispChild));
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                }
            }
        }
        else
            hr = E_NOINTERFACE;
        break;
    }
    
    return hr;   
}

HRESULT CAccessible::_GetAccName(BSTR* pbstr)
{
    IDispatch* pdisp;
    HRESULT hr = get_accParent(&pdisp);
    // Get parent can return a success code, but still fail to return a parent.
    // 
    if (hr == S_OK)
    {
        IAccessible* pacc;
        hr = pdisp->QueryInterface(IID_PPV_ARG(IAccessible, &pacc));
        if (SUCCEEDED(hr))
        {
            VARIANT varChild;
            hr = pacc->get_accFocus(&varChild);
            if (SUCCEEDED(hr))
                hr = pacc->get_accName(varChild, pbstr);
        }
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accName method

*/
STDMETHODIMP CAccessible::get_accName(VARIANT varChild, BSTR* pszName)
{
    CMenuToolbarBase* pmtb = _pmtbItem;
    int idCmd = _idCmd;
    int iIndex = _iIndex;

    *pszName = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accName(varChild, pszName);
        break;

    case MB_STATE_MENU:
        if (varChild.lVal == CHILDID_SELF)
        {
            if (_GetAccName(pszName) == S_FALSE)
            {
                TCHAR sz[100];
                LoadString(HINST_THISDLL, IDS_ACC_APP, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
                if (!*pszName)
                    return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        else
        {
            if (FAILED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                return DISP_E_MEMBERNOTFOUND;

            idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
        }

        // Fall Through

    case MB_STATE_ITEM:
        {
            TCHAR sz[MAX_PATH];
            int idString = 0;
            TBBUTTON tbb;
            if (ToolBar_GetButton(pmtb->_hwndMB, iIndex, &tbb) && 
                tbb.fsStyle & BTNS_SEP)
            {
                idString = IDS_ACC_SEP;
            }
            else if (pmtb->GetChevronID() == _idCmd)
            {
                idString = IDS_ACC_CHEVRON;
            }

            if (idString != 0)
            {
                LoadString(HINST_THISDLL, idString, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
            }
            else
            {
                UINT cch = SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, NULL);

                if (cch != 0 && cch < ARRAYSIZE(sz))
                {
                    if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                    {
                        SHStripMneumonic(sz);
                        *pszName = SysAllocString(sz);
                    }
                }
            }

            if (_fState == MB_STATE_MENU)
                pmtb->Release();

            if (!*pszName)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accValue method

*/
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR* pszValue)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accValue(varChild, pszValue);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        *pszValue = NULL;
        return S_FALSE;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDescription method

*/
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR * pszDescription)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDescription(varChild, pszDescription);
        break;

    case MB_STATE_MENU:
        if (FAILED(_GetAccName(pszDescriptio