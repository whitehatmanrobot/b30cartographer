jPath
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjPath::CObjPath( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CObjPath::CObjPath( void )
    : m_parsedObj( NULL )
{

} //*** CObjPath::CObjPath()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjPath::~CObjPath( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CObjPath::~CObjPath( void )
{
    CObjectPathParser objParser( e_ParserAcceptRelativeNamespace );
    objParser.Free( m_parsedObj );

} //*** CObjPath::~CObjPath()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetStringValueForProperty(
//      LPCWSTR     pwszIn
//      )
//
//  Description:
//      Retrieve the string value for the given property.
//
//  Arguments:
//      pwszIn      -- Name of the property
//
//  Return Values:
//      The property's value.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetStringValueForProperty(
    LPCWSTR     pwszIn
    )
{
    int         idx;
    KeyRef *    pKey;

    _ASSERTE(pwszIn != NULL);

    for( idx = 0 ; idx < m_parsedObj->m_dwNumKeys ; idx++ )
    {
        pKey = m_parsedObj->m_paKeys[ idx ];
        if( _wcsicmp( pKey->m_pName, pwszIn ) == 0 )
        {
            if( pKey->m_vValue.vt == VT_BSTR )
            {
                return pKey->m_vValue.bstrVal;
            }
        }
    }

    return L"";

} //*** CObjPath::GetStringValueForProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  long
//  CObjPath::GetLongValueForProperty(
//      LPCWSTR     pwszIn
//      )
//
//  Description:
//      Retrieve the long value for the given property.
//
//  Arguments:
//      pwszIn      -- Name of the property
//
//  Return Values:
//      The property's value.
//
//--
//////////////////////////////////////////////////////////////////////////////
long
CObjPath::GetLongValueForProperty(
    LPCWSTR     pwszIn
    )
{
    int         idx;
    KeyRef *    pKey;

    _ASSERTE(pwszIn != NULL);
    
    for( idx = 0 ; idx < m_parsedObj->m_dwNumKeys ; idx++ )
    {
        pKey = m_parsedObj->m_paKeys[ idx ];
        if( _wcsicmp( pKey->m_pName, pwszIn ) == 0 )
        {
            if( pKey->m_vValue.vt == VT_I4 )
            {
                return pKey->m_vValue.lVal;
            }
        }
    }

    return 0;

} //*** CObjPath::GetLongValueForProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LONGLONG
//  CObjPath::GetI64ValueForProperty(
//      LPCWSTR     pwszIn
//      )
//
//  Description:
//      Retrieve the I64 value for the given property.
//      I64 properties are handled as strings in WMI.
//
//  Arguments:
//      pwszIn      -- Name of the property
//
//  Return Values:
//      The property's value.
//
//--
//////////////////////////////////////////////////////////////////////////////
LONGLONG
CObjPath::GetI64ValueForProperty(
    LPCWSTR     pwszIn
    )
{
    int         idx;
    KeyRef *    pKey;
    LONGLONG    llRetVal = 0;
    WCHAR       wszTemp[g_cchMAX_I64DEC_STRING] = L"";

    _ASSERTE(pwszIn != NULL);
    
    for( idx = 0 ; idx < m_parsedObj->m_dwNumKeys ; idx++ )
    {
        pKey = m_parsedObj->m_paKeys[ idx ];
        if( _wcsicmp( pKey->m_pName, pwszIn ) == 0 )
        {
            if( pKey->m_vValue.vt == VT_BSTR )
            {
                llRetVal = _wtoi64((WCHAR *) pKey->m_vValue.bstrVal);
                _i64tow( llRetVal, wszTemp, 10 );
                if ( _wcsicmp( wszTemp, (WCHAR *) pKey->m_vValue.bstrVal ) )
                {
                    CProvException e( E_INVALIDARG );
                    throw e;
                }

                return llRetVal;
            }
        }
    }

    return llRetVal;

} //*** CObjPath::GetI64ValueForProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetClassName( void )

//
//  Description:
//      Get the class name.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Class name string.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetClassName( void )
{
    return m_parsedObj->m_pClass;

} //*** CObjPath::GetClassName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::Init(
//      LPCWSTR     pwszPathIn
//      )
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      pwszPathIn  -- Object path string
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::Init(
    LPCWSTR     pwszPathIn
    )
{
    if ( pwszPathIn == NULL )
    {
        return FALSE;
    }
    else
    {
        CObjectPathParser objParser( e_ParserAcceptRelativeNamespace );
        objParser.Parse(
            const_cast< WCHAR * >( pwszPathIn ),
            &m_parsedObj
            );
    }

    if ( m_parsedObj == NULL )
    {
        return FALSE;
    } // if:

    return TRUE;

} //*** CObjPath::Init()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::SetClass(
//      LPCWSTR     pwszValueIn
//      )
//
//  Description:
//      Set the name of the class for the object path.
//
//  Arguments:
//      pwszValueIn     -- Class name string.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::SetClass(
    LPCWSTR     pwszValueIn
    )
{
    _ASSERTE(pwszValueIn != NULL);
    
    return m_parsedObj->SetClassName( pwszValueIn );

} //*** CObjPath::SetClass()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::AddProperty(
//      IN LPCWSTR pwszNameIn,
//      IN LPCWSTR pwszValueIn
//      )
//
//  Description:
//      Add property to object path.
//
//  Arguments:
//      pwszNameIn      -- Name of the property.
//      pwszValueIn     -- Value of the property in WCHAR* format.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::AddProperty(
    IN LPCWSTR pwszNameIn,
    IN LPCWSTR pwszValueIn
    )
{
    VARIANT v;
    BOOL    bRt = FALSE;

    _ASSERTE(pwszNameIn != NULL);
    _ASSERTE(pwszValueIn != NULL);
    
    VariantInit( & v );
    v.vt = VT_BSTR;
    v.bstrVal = _bstr_t( pwszValueIn ).copy(  );
    bRt = m_parsedObj->AddKeyRef(
                pwszNameIn,
                & v
                );
    VariantClear( & v );
    return bRt;
    
} //*** CObjPath::AddProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetObjectPathString( void )
//
//  Description:
//      Retrieve object path string.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Object path string in _bstr_t.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetObjectPathString( void )
{
    LPWSTR  pwszPath = NULL;
    _bstr_t bstrResult;

    try
    {
        CObjectPathParser::Unparse( m_parsedObj, & pwszPath );
        bstrResult = pwszPath;
    }
    catch( ... )   //catch _com_error
    {
        if ( pwszPath )
        {
            delete [] pwszPath;
        }
        throw;
    }
    if ( pwszPath )
    {
        delete [] pwszPath;
    }
    return bstrResult;

} //*** CObjPath::GetObjectPathString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::AddProperty(
//      LPCWSTR     pwszNameIn,
//      VARIANT *   pvValueIn
//      )
//
//  Description:
//      Add a property to this instance.
//
//  Arguments:
//      pwszNameIn      -- Name of the property.
//      pvValueIn       -- Value of the property in VARIANT format
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::AddProperty(
    LPCWSTR     pwszNameIn,
    VARIANT *   pvValueIn
    )
{
    _ASSERTE(pwszNameIn != NULL);
    _ASSERTE(pvValueIn != NULL);
    
    return m_parsedObj->AddKeyRef( pwszNameIn, pvValueIn );

} //*** CObjPath::AddProperty

//****************************************************************************
//
//  CProvException
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  CProvException::PwszErrorMessage( void ) const
//
//  Description:
//      retrieve Error message 
//
//  Arguments:
//      None.
//
//  Return Values:
//      Null-terminated Unicode error message from the exception.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
CProvException::PwszErrorMessage( void ) const
{
    if ( m_bstrError.length( ) == 0 )
    {
        LPWSTR pError = NULL;
        DWORD rt = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        HRESULT_CODE( m_hr ),
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPWSTR) &pError,
                        0,
                        NULL
                        );
        m_bstrError = pError;
        LocalFree( pError );

    } // if: string is empty
    return m_bstrError;

} //*** CProvException::PwszErrorMessage()

//****************************************************************************
//
//  CWbemClassObject
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::CWbemClassObject( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject( void )
    : m_pClassObject( NULL )
{
    VariantInit( &m_v );

} //*** CWbemClassObject::CWbemClassObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::CWbemClassObject(
//      IWbemClassObject *  pInstIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pInstIn     -- WMI class object interface.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject(
    IWbemClassObject *  pInstIn
    )
    : m_pClassObject( NULL )
{
    m_pClassObject = pInstIn;
    if ( m_pClassObject )
    {
        m_pClassObject->AddRef();
    }
    VariantInit( &m_v );

} //*** CWbemClassObject::CWbemClassObject( pInstIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::~CWbemClassObject( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::~CWbemClassObject( void )
{
    if ( m_pClassObject )
    {
        m_pClassObject->Release();
    }
    VariantClear( &m_v );

} //*** CWbemClassObject::~CWbemClassObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      DWORD       dwValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set dword value of a property.
//
//  Arguments:
//      dwValueIn       -- Property dword value
//      pwszPropNameIn  -- Property Name
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetProperty(
    DWORD       dwValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT sc;

    _ASSERTE(pwszPropNameIn != NULL);
    
    VariantClear( &m_v );
    m_v.vt = VT_I4;
    m_v.lVal = dwValueIn;
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0, 
                &m_v,
                0
                );

    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( dwValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      double       dblValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set dword value of a property.
//
//  Arguments:
//      dblValueIn       -- Property double value
//      pwszPropNameIn  -- Property Name
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetPropertyR64(
    double       dblValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT sc;

    _ASSERTE(pwszPropNameIn != NULL);
    
    VariantClear( &m_v );
    m_v.vt = VT_R8;
    m_v.dblVal = dblValueIn;
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0, 
                &m_v,
                0
                );

    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetPropertyR64( dblValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetPropertyI64(
//      LONGLONG    llValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set LONGLONG value of a property.
//
//  Arguments:
//      llValueIn       -- Property LONGLONG value
//      pwszPropNameIn  -- Property Name
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetPropertyI64(
    ULONGLONG    ullValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    // Integers in 64-bit format must be encoded as strings 
    // because Automation does not support a 64-bit integral type
    HRESULT sc;
    WCHAR   wszTemp[g_cchMAX_I64DEC_STRING] = L"";

    _ASSERTE(pwszPropNameIn != NULL);
    
    VariantClear( &m_v );
    m_v.vt = VT_BSTR;
    _ui64tow( ullValueIn, wszTemp, 10 );
    m_v.bstrVal = _bstr_t( wszTemp ).copy();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0, 
                &m_v,
                0
                );

    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetPropertyI64( llValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetPropertyI64(
//      LONGLONG    llValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set LONGLONG value of a property.
//
//  Arguments:
//      llValueIn       -- Property LONGLONG value
//      pwszPropNameIn  -- Property Name
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetPropertyI64(
    LONGLONG    llValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    // Integers in 64-bit format must be encoded as strings 
    // because Automation does not support a 64-bit integral type
    HRESULT sc;
    WCHAR   wszTemp[g_cchMAX_I64DEC_STRING] = L"";

    _ASSERTE(pwszPropNameIn != NULL);
    
    VariantClear( &m_v );
    m_v.vt = VT_BSTR;
    _i64tow( llValueIn, wszTemp, 10 );
    m_v.bstrVal = _bstr_t( wszTemp ).copy();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0, 
                &m_v,
                0
                );

    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetPropertyI64( llValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      LPCWSTR     pwszValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set wstring value of a property.
//
//  Arguments:
//      pwszValueIn     -- Property string value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemClassObject::SetProperty(
    LPCWSTR     pwszValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT sc;

    _ASSERTE(pwszPropNameIn != NULL);
    
    if ( pwszValueIn == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    VariantClear( &m_v );
    m_v.vt = VT_BSTR;
    m_v.bstrVal = _bstr_t( pwszValueIn ).copy();

    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                0
                );
    VariantClear( &m_v );


    if( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;
 
} //*** CWbemClassObject::SetProperty( pwszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      DWORD       dwSizeIn,
//      PBYTE       pByteIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set binary value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pByteIn.
//      pByteIn         -- Pointer to byte.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    PBYTE       pByteIn,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LONG            idx;
    LONG            ix;

    _ASSERTE(pwszPropNameIn != NULL);    
    
    rgsabound[ 0 ].lLbound = 0;
    rgsabound[ 0 ].cElements = dwSizeIn;

    if( pByteIn == NULL )
    {
        return sc;
    }
    
    VariantClear( &m_v );

    psa = SafeArrayCreate( VT_UI1, 1, rgsabound );
    if(psa == NULL)
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    for( idx = 0 ; idx < dwSizeIn ; idx++ )
    {
        ix = idx;
        sc = SafeArrayPutElement(
                psa,
                &ix,
                static_cast< void * >( pByteIn+idx )
                );

        if ( sc != S_OK )
        {
            throw CProvException( sc );
        }
    }

    m_v.vt = ( VT_ARRAY | VT_UI1 );

    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            0
            );

    if ( sc != S_OK )
    {
        throw CProvException( sc );
    }

    return sc;


} //*** CWbemClassObject::SetProperty( pByteIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      DWORD       dwSizeIn,
//      BSTR *      pbstrIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set wstring array value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pByteIn.
//      pbstrIn         -- Pointer to BSTR array.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    BSTR *      pbstrIn,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LONG            idx;
    LONG            ix;

    _ASSERTE(pwszPropNameIn != NULL);
    
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwSizeIn;

    if ( pbstrIn == NULL )
    {
        return sc;
    }

    VariantClear( &m_v );

    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    if ( psa == NULL )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    for( idx = 0 ; idx < dwSizeIn ; idx++)
    {
        ix = idx;
        sc = SafeArrayPutElement(
                psa,
                &ix,
                pbstrIn[ idx ]
                );

        if ( sc != S_OK)
        {
            throw CProvException( sc );
        }
    }

    m_v.vt = (VT_ARRAY | VT_BSTR );

    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            0
            );
    
    if ( sc != S_OK)
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pbstrIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//
//  Description:
//      Set MultiSz value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pwszMultiSzIn.
//      pwszMultiSzIn   -- Pointer to MultiSz.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    LPCWSTR     pwszMultiSzIn,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LPCWSTR         pwsz = NULL;
    LONG            idx;
    LONG            ix;

    _ASSERTE(pwszPropNameIn != NULL);
    
    if( pwszMultiSzIn == NULL )
    {
        return sc;
    }
    VariantClear( &m_v );

    //
    // find out the number of string
    //
    DWORD cMultiSz = 1;
    for ( pwsz = pwszMultiSzIn; *pwsz || *pwsz ++ ; pwsz ++ )
    {
        if ( ! ( *pwsz ) )
        {
            cMultiSz ++ ;
        }
    }
    rgsabound[ 0 ].lLbound = 0;
    rgsabound[ 0 ].cElements = cMultiSz;

    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound);
    if ( psa == NULL )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    pwsz = pwszMultiSzIn;
    for( idx = 0 ; idx < cMultiSz ; idx++ )
    {
        ix = idx;
        sc = SafeArrayPutElement(
                    psa,
                    &ix,
                    (BSTR) _bstr_t( pwsz )
                    );

        if ( sc != S_OK )
        {
            throw CProvException( sc );
        }
        pwsz = wcschr( pwsz, L'\0' );
        pwsz ++;
    }

    m_v.vt = (VT_ARRAY | VT_BSTR );
    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0, 
            &m_v,
            0
            );

    if ( sc != S_OK )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pwszMultiSzIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      LPCSTR      pszValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set ansi string value of a property.
//
//  Arguments:
//      pszValueIn      -- Property string value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetProperty(
    LPCSTR      pszValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    _ASSERTE(pwszPropNameIn != NULL);
    
    if ( pszValueIn == NULL )
    {
        return S_OK;
    }
    return SetProperty(
                static_cast< WCHAR * >( _bstr_t( pszValueIn ) ),
                pwszPropNameIn
                );

} //*** CWbemClassObject::SetProperty( pszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SetProperty(
//      IWbemClassObject *  pWbemClassObject,
//      LPCWSTR             pwszPropNameIn
//      )
//
//  Description:
//      Set wbem class object of a property.
//
//  Arguments:
//      pWbemClassObject    -- Property wbem class object 
//      pwszPropNameIn      -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SetProperty(
    IWbemClassObject *  pWbemClassObjectIn,
    LPCWSTR             pwszPropNameIn
    )
{
    HRESULT   sc = S_OK;

    _ASSERTE(pwszPropNameIn != NULL);
    
    if ( pWbemClassObjectIn == NULL )
    {
        return sc;
    }
    VariantClear( & m_v );
    
    m_v.vt = VT_UNKNOWN  ;
    m_v.punkVal = pWbemClassObjectIn;
    pWbemClassObjectIn->AddRef();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                0
                );
    VariantClear( &m_v );


    if( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SpawnInstance(
//      LONG                lFlagIn,
//      IWbemClassObject ** ppNewOut
//      )
//
//  Description:
//      Spawn a instance of IWbemClassObject.
//
//  Arguments:
//      lFlagIn     -- WMI flag, reserved, must be 0.
//      ppNewOut    -- Created new instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SpawnInstance(
    LONG                lFlagIn,
    IWbemClassObject ** ppNewOut
    )
{
    _ASSERTE(ppNewOut != NULL);
    
    return m_pClassObject->SpawnInstance( lFlagIn, ppNewOut );

} //*** CWbemClassObject::SpawnInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::SpawnDerivedClass(
//      LONG                lFlagIn,
//      IWbemClassObject ** ppNewOut
//      )
//
//  Description:
//      Spawn a derived class.
//
//  Arguments:
//      lFlagIn     -- WMI flag, reserved, must be 0.
//      ppNewOut    -- Created new instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::SpawnDerivedClass(
    LONG                lFlagIn,
    IWbemClassObject ** ppNewOut
    )
{
    _ASSERTE(ppNewOut != NULL);
    
    return m_pClassObject->SpawnDerivedClass( lFlagIn, ppNewOut );

} //*** CWbemClassObject::SpawnInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetMethod(
//      BSTR                bstrMethodNameIn,
//      LONG                lFlagIn,
//      IWbemClassObject ** ppINOut,
//      IWbemClassObject ** ppOUTOut
//      )
//
//  Description:
//      Retrieve the method for an WMI object.
//
//  Arguments:
//      bstrMethodNameIn
//          Method Name.
//
//      lFlagIn
//          WMI flag, Reserved. It must be zero.
//
//      ppINOut
//          IWbemClassObject pointer which describes the in-parameters 
//          to the method.
//
//      ppOUTOut
//          an IWbemClassObject pointer which describes the 
//          out-parameters to the method
//
//  Return Values:
//      WBEM stand error
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::GetMethod(
    BSTR                bstrMethodNameIn,
    LONG                lFlagIn,
    IWbemClassObject ** ppINOut,
    IWbemClassObject ** ppOUTOut
    )
{
    _ASSERTE(bstrMethodNameIn != NULL);
    _ASSERTE(ppINOut != NULL);
    _ASSERTE(ppOUTOut != NULL);
    
    return m_pClassObject->GetMethod(
                bstrMethodNameIn,
                lFlagIn,
                ppINOut,
                ppOUTOut
                );

} //*** CWbemClassObject::GetMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the DWORD property for this WMI object.
//
//  Arguments:
//      pdwValueOut     -- DWORD variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemClassObject::GetProperty(
    DWORD *     pdwValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pdwValueOut != NULL);
        
    VariantClear( &m_v );
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_I4 )
        {
            *pdwValueOut = m_v.lVal;
            return sc;
        }
        else if ( m_v.vt == VT_BOOL)
        {
            if ( m_v.boolVal == VARIANT_TRUE )
            {
                *pdwValueOut = 1;
            }
            else
            {
                *pdwValueOut = 0;
            }
            return sc;
        }
        else if ( m_v.vt == VT_UI1 )
        {
            *pdwValueOut = ( DWORD ) m_v.bVal;
            return sc;
        }
        else if ( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    // raise exception if sc is not S_OK or vt is not expected
    CProvException e( sc );
    throw e;
    
    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty( pdwValueOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the DWORD property for this WMI object.
//
//  Arguments:
//      pdwValueOut     -- DWORD variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemClassObject::GetPropertyR64(
    double *     pdblValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pdblValueOut != NULL);
        
    VariantClear( &m_v );
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_R8 )
        {
            *pdblValueOut = m_v.dblVal;
            return sc;
        }
        else if ( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    // raise exception if sc is not S_OK or vt is not expected
    CProvException e( sc );
    throw e;
    
    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetPropertyR64( pdblValueOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetPropertyI64(
//      LONGLONG *  pllValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the LONGLONG property for this WMI object.
//
//  Arguments:
//      pllValueOut     -- LONGLONG variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemClassObject::GetPropertyI64(
    LONGLONG *  pllValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pllValueOut != NULL);    
    
    VariantClear( &m_v );
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_BSTR )
        {
            // convert from uint64 (VT_BSTR) to LONGLONG
            *pllValueOut = _wtoi64( (WCHAR *) m_v.bstrVal );
            return sc;
        }
        else if ( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    // raise exception if sc is not S_OK or vt is not expected
    CProvException e( sc );
    throw e;
    
    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetPropertyI64( pllValueOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      _bstr_t &   rBstrOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BSTR property for this WMI object.
//
//  Arguments:
//      rBstrOut        -- bstr_t variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::GetProperty(
    _bstr_t &   rBstrOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    
    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );
    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_BSTR )
        {
            rBstrOut = m_v.bstrVal;
            return sc;
        }
        else if( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    CProvException e( sc );
    throw e;
    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty( rBstrOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      BOOL *      pfValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BOOL property for this WMI object.
//
//  Arguments:
//      pfValueOut      -- BOOL variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemClassObject::GetProperty(
    BOOL *      pfValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pfValueOut != NULL);    
    
    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );

    if ( m_v.vt == VT_BOOL )
    {
        *pfValueOut = m_v.boolVal;
        return sc;
    }

    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      PBYTE *     ppByteOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the binary property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppByteOut       -- Output buffer.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemClassObject::GetProperty(
    DWORD *     pdwSizeOut,
    PBYTE *     ppByteOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT sc;
    VariantClear(&m_v);

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pdwSizeOut != NULL);    
    _ASSERTE(ppByteOut != NULL);    
    
    *pdwSizeOut = 0;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                & m_v,
                NULL,
                NULL
                );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_UI1 ) )
        {
            PBYTE   pByte;

            * pdwSizeOut = m_v.parray->rgsabound[ 0 ].cElements;
            * ppByteOut = new BYTE[ *pdwSizeOut ];
            if ( * ppByteOut == NULL )
                throw CProvException( E_OUTOFMEMORY );

            sc = SafeArrayAccessData( m_v.parray, ( void ** ) &pByte );
            if ( SUCCEEDED ( sc ) )
            {    
                UINT idx;
                for ( idx = 0; idx < *pdwSizeOut; idx ++ )
                {
                    *( (* ppByteOut ) + idx ) = *( pByte + idx );
                }
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException(static_cast< HRESULT > (WBEM_E_INVALID_PARAMETER));
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppByteOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      _bstr_t **  ppbstrOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BSTR array property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppbstrOut       -- BSTR variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::GetProperty(
    DWORD *     pdwSizeOut,
    _bstr_t **  ppbstrOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT sc;
    VariantClear( &m_v );

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pdwSizeOut != NULL);    
    _ASSERTE(ppbstrOut != NULL);    

    *pdwSizeOut = 0;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                & m_v,
                NULL, 
                NULL
                );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_BSTR ) )
        {
            BSTR * pBstr;

            *pdwSizeOut = m_v.parray->rgsabound[0].cElements;
            *ppbstrOut = new _bstr_t[ *pdwSizeOut ];
            if ( * ppbstrOut == NULL )
                throw CProvException( E_OUTOFMEMORY );
            
            sc = SafeArrayAccessData( m_v.parray, (void **) & pBstr );
            if ( SUCCEEDED ( sc ) )
            {
                UINT idx;
                for( idx = 0; idx < *pdwSizeOut; idx ++)
                {
                    *( (*ppbstrOut) + idx ) = *( pBstr + idx );
                }
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppbstrOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      LPWSTR *    ppwszMultiSzOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the MultiSz property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppwszMultiSzOut -- MultiSz output buffer.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::GetPropertyMultiSz(
    DWORD *     pdwSizeOut,
    LPWSTR *    ppwszMultiSzOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT       sc;
    DWORD       cElements;
    DWORD       cMultiSz = 0;

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pdwSizeOut != NULL);    
    _ASSERTE(ppwszMultiSzOut != NULL);    

    VariantClear(&m_v);
    *pdwSizeOut = 0;
//    *ppOut = NULL;
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            & m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_BSTR ) )
        {
            LPWSTR * ppwsz = NULL;

            cElements = m_v.parray->rgsabound[ 0 ].cElements;
            sc = SafeArrayAccessData( m_v.parray, ( void ** ) & ppwsz );
            if ( SUCCEEDED ( sc ) )
            {    
                UINT idx;
                for( idx = 0; idx < cElements; idx ++)
                {
                   cMultiSz = cMultiSz + wcslen( *(ppwsz + idx) ) + sizeof (WCHAR); 
                }
                cMultiSz += sizeof( WCHAR ) * 2;
                *ppwszMultiSzOut = new WCHAR[ cMultiSz ];
                if (*ppwszMultiSzOut == NULL)                // prefix change
                {                                            // prefix change
                    SafeArrayUnaccessData( m_v.parray );    // prefix change
                    throw CProvException( E_OUTOFMEMORY );    // prefix change
                }                                            // prefix change

                LPWSTR pwszDst = *ppwszMultiSzOut;
                LPWSTR pwszSrc;
                for ( idx = 0; idx < cElements ; idx ++)
                {
                    for( pwszSrc = *( ppwsz + idx); *pwszSrc ; pwszDst++, pwszSrc ++ )
                    {
                        *pwszDst = *pwszSrc;
                    }
                    *(pwszDst++) = L'\0';
                }
                *pwszDst = L'\0';
                *pdwSizeOut = cMultiSz;
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppwszMultiSzOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//      VARIANT *   pVariantOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the variant property for this WMI object.
//
//  Arguments:
//      pVariantOut     -- Variant variable to receive property value
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::GetProperty(
    VARIANT *   pVariantOut,
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    _ASSERTE(pVariantOut != NULL);    

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                pVariantOut,
                NULL,
                NULL
                );
    if ( FAILED( sc ) )
    {
        CProvException e( sc );
        throw e;
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( pVariantOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemClassObject::GetProperty(
//  CWbemClassObject & rWcoInout,
//  LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the embeded object property for this WMI object.
//
//  Arguments:
//      rWcoInout       -- class object variable to receive property value
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemClassObject::GetProperty(
    CWbemClassObject & rWcoInout,
    LPCWSTR     pwszPropNameIn
    )
{
    
    HRESULT hr = E_FAIL;

    _ASSERTE(pwszPropNameIn != NULL);

    VariantClear( &m_v );
    hr = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );

    if (FAILED(hr))
    {
        throw CProvException (hr);
    }
    
    if ( m_v.vt != VT_UNKNOWN )
    {
        hr = WBEM_E_INVALID_PARAMETER;        
        throw CProvException(hr);
    }
    
    IWbemClassObject * pwco = NULL;
    hr = m_v.punkVal->QueryInterface( & pwco );
    rWcoInout = pwco;
    VariantClear( & m_v );
    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( rWcoInout )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CWbemClassObject::IsPropertyNull(
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      return TRUE if the property is NULL
//
//  Arguments:
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CWbemClassObject::IsPropertyNull(
    LPCWSTR     pwszPropNameIn
    )
{
    HRESULT   sc;

    _ASSERTE(pwszPropNameIn != NULL);
    
    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );

    if (FAILED(sc))
    {
        CProvException e( sc );
        throw e;        
    }
    
    if ( m_v.vt == VT_NULL )
        return TRUE;

    return FALSE;
} //*** CWbemClassObject::IsPropertyNull
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\provfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvFactory.cpp
//
//  Description:
//      Implementation of CProvFactory class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ProvFactory.h"

//****************************************************************************
//
//  CProvFactory
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::QueryInterface(
//      REFIID  riidIn,
//      PPVOID  ppvOut
//      )
//
//  Description:
//      Query for an interface supported by this COM object.
//
//  Arguments:
//      riidIn      -- Interface ID.
//      ppvOut      -- Receives the interface pointer.
//
//  Return Values:
//      NOERROR
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::QueryInterface(
    REFIID  riidIn,
    PPVOID  ppvOut
    )
{
    if (ppvOut == NULL)
    {
        return E_INVALIDARG;
    }
    
    *ppvOut = NULL;

    if ( IID_IUnknown == riidIn || IID_IClassFactory == riidIn )
    {
        *ppvOut = this;
    }

    if ( NULL != *ppvOut )
    {
        ( (LPUNKNOWN) *ppvOut )->AddRef( );
        return NOERROR;
    }

    return E_NOINTERFACE;

} //*** CProvFactory::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProvFactory::AddRef ( void )
//
//  Description:
//      Increment the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProvFactory::AddRef ( void )
{
    //return ++m_cRef;
    return InterlockedIncrement( (long *) &m_cRef );

} //*** CProvFactory::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProvFactory::Release( void )
//
//  Description:
//      Decrement the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProvFactory::Release( void )
{
    ULONG nNewCount = InterlockedDecrement( (long *) & m_cRef );
    if ( 0L == nNewCount )
    {
        delete this;
    } // if: 0L == nNewCount
    
    return nNewCount;

} //*** CProvFactory::Release()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::CreateInstance(
//      LPUNKNOWN   pUnkOuterIn,
//      REFIID      riidIn,
//      PPVOID      ppvObjOut
//      )
//
//  Description:
//      Instantiates a Locator object returning an interface pointer.
//
//  Arguments:
//      pUnkOuterIn
//          LPUNKNOWN to the controlling IUnknown if we are being used in
//          an aggregation.
//
//      riidIn
//          REFIID identifying the interface the caller desires to have
//          for the new object.
//
//      ppvObjOut
//          PPVOID in which to store the desired interface pointer for the
//          new object.
//
//  Return Values:
//      NOERROR
//      E_OUTOFMEMORY
//      E_NOINTERFACE
//      CLASS_E_NOAGGREGATION
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::CreateInstance(
    LPUNKNOWN   pUnkOuterIn,
    REFIID      riidIn,
    PPVOID      ppvObjOut
    )
{
    IUnknown *  pObj = NULL;
    HRESULT     hr;

    _ASSERTE(ppvObjOut != NULL);
    _ASSERTE(m_pFactoryData != NULL);

    *ppvObjOut = NULL;

    // This object doesnt support aggregation.

    if ( NULL != pUnkOuterIn )
    {
        return CLASS_E_NOAGGREGATION;
    } /// if: not pUnkOuter

    
    hr = m_pFactoryData->pFnCreateInstance(
                NULL,
                reinterpret_cast< VOID ** >( &pObj )
                );

    if ( NULL == pObj )
    {
        return E_OUTOFMEMORY;
    } // if: pObj is NULL

    hr = pObj->QueryInterface( riidIn, ppvObjOut );

    //Kill the object if initial creation or Init failed.

    if ( FAILED( hr ) )
    {
        delete pObj;
    } // if: failed

    return hr;

} //*** CProvFactory::CreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::LockServer(
//      BOOL    fLockIn
//      )
//
//  Description:
//      Increments or decrements the lock count of the DLL.  If the lock
//      count goes to zero and there are no objects, the DLL is allowed to
//      unload.  See DllCanUnloadNow.
//
//  Arguments:
//      fLockIn
//          BOOL specifying whether to increment or decrement the lock count.
//
//  Return Values:
//      NOERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::LockServer(
    BOOL    fLockIn
    )
{
    if ( fLockIn )
    {
        InterlockedIncrement( & g_cLock );
    } /// if: lock
    else
    {
        InterlockedDecrement( & g_cLock );
    } /// else:

    return NOERROR;

} //*** CProvFactory::LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\vs_trace.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_trace.cxx

Abstract:

    This module defines the global debug\trace facilities used by the
	Long Term Storage service.
	
	Previous name: bsdebug.cxx

Author:


Revision History:
	Name		Date		Comments
    ssteiner    06/03/98    Made numerious changes and removed iostream
                            dependencies, added a few new registry entries and
                            added serialization.
	aoltean		06/06/99	Taken from atl30\atlbase.h in order to avoid linking ATL with BSCommon.lib
    ssteiner    05/15/00    Fixed bug #116688.  Added file locking to prevent multiple processes from
                            interferring with writing to the trace file.  Added code to place a UNICODE
                            BOM at the beginning of the trace file.
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
//#include <vssmsg.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>



#include "vs_inc.hxx"
//#include "vs_idl.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCTRCC"
//
////////////////////////////////////////////////////////////////////////

//
//  The following global, g_cDbgTrace must be declared BEFORE any of our
//  objects including _Module, since some of our static objects have destructors
//  that call trace methods.  The following pragma ensures that this
//  module's static objects are initialized before any of our other
//  static objects, assuming they don't use this same pragma.
//
#pragma warning(disable:4073) // ignore init_seg warning
#pragma init_seg(lib)

CBsDbgTrace g_cDbgTrace;


static VOID MakeFileUnicode(
    IN HANDLE hFile
    );

/////////////////////////////////////////////////////////////////////////////
// constants
//

const WCHAR	VSS_TRACINGKEYPATH[]	=
			L"SYSTEM\\CurrentControlSet\\Services\\VSS\\Debug\\Tracing";

const WCHAR	SETUP_KEY[]	=
			L"SYSTEM\\Setup";

const WCHAR	SETUP_INPROGRESS_REG[]	=
			L"SystemSetupInProgress";

const DWORD SETUP_INPROGRESS_VALUE = 1;

const x_nMaxCoCreateInstanceRetries = 10;


/////////////////////////////////////////////////////////////////////////////
//  Globals
//

//
//  NOTE: g_cDbgTrace, the global instance of this class is declared in
//  ltss\modules\ltssvc\src\ltssvc.cxx since we have to make sure
//  this object is the last one being destructed, otherwise possible
//  calls to this object will fail.
//

//
// Define a TLS var, stores the CLTermStg & intention list index.
// The index is a counter that is incremented and set for each thread
// coming into the service, in the CLTermStg::FinalConstruct method.
// The counter is also incremented and set for each intention list
// thread that is created by the service.
//
//  WARNING
//
//
//_declspec( thread ) DWORD CBsDbgTrace::m_dwContextNum = 0;

//
//  Queries a registry value name and if found sets dwValue to the value.
//  If the value name is not found, dwValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT DWORD &dwValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );
    
    if ( dwResult == ERROR_SUCCESS )
        dwValue = dwReadValue;

    return dwResult;
}

//
//  Queries a registry value name and if found sets bValue to the value.
//  If the value name is not found, bValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT BOOL &bValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );

    if ( dwResult == ERROR_SUCCESS )
        bValue = (BOOL)(dwReadValue != 0);

    return dwResult;
}

//
//  Queries a registry value name and if found sets wsValue to the value.
//  If the value name is not found, wsValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    OUT LPWSTR &wsValue, // If allocated, must be freed before calling with ::VssFreeString
    IN LPCWSTR pwszValueName
    )
{
	WCHAR pszValueBuffer[_MAX_PATH];
    DWORD dwCount = _MAX_PATH;
    DWORD dwResult = cRegKey.QueryValue( pszValueBuffer, pwszValueName, &dwCount );

    BS_ASSERT(wsValue == NULL);
    if ( dwResult == ERROR_SUCCESS ) 
        ::VssDuplicateStr(wsValue, pszValueBuffer);

    return dwResult;
}

//
//  ***** class definitions *****
//


CBsDbgTrace::CBsDbgTrace()

/*++

Routine Description:

    Constructor method. Default values are given to operational
    parameters and overwritten using values from the registry if
    set.  Also prints out the trace file banner.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
	m_bInitialized = false;
	m_bTracingEnabled = false;
	m_pcs = NULL;
    Initialize( TRUE );
}


CBsDbgTrace::~CBsDbgTrace()
/*++

Routine Description:

    Destructor method.  Prints out the last record in the NTMS


Arguments:

	LONG Indent - NOT USED YET [todo] this is the indentation indicator
	LONG Level - this is the debug trace level

Return Value:

    BOOL

--*/
{
    if ( !m_bInitialized )
        return;

    if ( m_bTracingEnabled ) {
        //
        //  Write out a finished tracing message
        //
        m_pcs->Enter();
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING FINISHED - ProcessId: 0x%x, ContextId: 0x%x",
            m_dwCurrentProcessId, m_dwContextId ) );
        WCHAR pwszCurrentTime[128];
        time_t ltime;
        struct tm *pToday;
        time( &ltime );
        pToday = localtime( &ltime );
        wcsftime( pwszCurrentTime, sizeof pwszCurrentTime, L"%c", pToday );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Elapsed time: %d seconds", ltime- m_lTimeStarted ) );
   	    BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Command-line: %s", GetCommandLineW() ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        m_pcs->Leave();

        //
        //  Make sure the file is flushed before leaving
        //
        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
                ::FlushFileBuffers( m_hTraceFile );
                ::CloseHandle( m_hTraceFile );
            }
        }
    }

    ::VssFreeString(m_pwszTraceFileName);

    //
    //  Delete the critical section
    //
    delete m_pcs;
    m_pcs = NULL;
    m_bInitialized = FALSE;
}

//
//  In certain cases the global trace object doesn't seem to get it's constructor called.
//  To fix this problem, this function was added to perform the initialization of the
//  object.  This function is called both in the constructor and the set context call
//  which all DLLs that use the trace class call.
//
VOID
CBsDbgTrace::Initialize(
    IN  BOOL bInConstructor
    )
{
    if ( !m_bInitialized )
    {
		try
			{
			//
			//  Get the critical section created first
			//
			m_pcs = new CBsCritSec;
			if ( m_pcs == NULL )
				throw E_OUTOFMEMORY;
			m_bInitialized = TRUE;

			m_bTracingEnabled       = FALSE;
			m_bTraceToFile          = BS_DBG_TRACE_TO_FILE_DFLT;
			m_bTraceToDebugger      = BS_DBG_TRACE_TO_DEBUGGER_DFLT;
			m_bTraceEnterExit       = BS_DBG_TRACE_ENTER_EXIT_DFLT;
			m_dwTraceLevel          = BS_DBG_TRACE_LEVEL_DFLT;
			m_bTraceFileLineInfo    = BS_DBG_TRACE_FILE_LINE_INFO_DFLT;
			m_bTraceTimestamp       = BS_DBG_TRACE_TIMESTAMP_DFLT;
			m_pwszTraceFileName     = NULL;
			m_bForceFlush           = BS_DBG_TRACE_FORCE_FLUSH_DFLT;
			m_dwTraceIndent         = 0;
			m_bInTrace              = FALSE;
			m_hTraceFile            = INVALID_HANDLE_VALUE;
			m_dwLineNum             = 0;
			m_dwCurrentProcessId    = GetCurrentProcessId();
			m_bIsDuringSetup        = FALSE;
			
			LARGE_INTEGER liTimer;
			if ( ::QueryPerformanceCounter( &liTimer ) )
				{
				//  Got high performance counter, use the low part
				m_dwContextId = liTimer.LowPart;
				}
			else
				{
				m_dwContextId = ::GetTickCount();
				}

			ReadRegistry();

			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING STARTED - ProcessId: 0x%x, ContextId: 0x%x",
				m_dwCurrentProcessId, m_dwContextId ) );
			if ( !bInConstructor )
				BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  N.B. NOT INITIALIZED BY THE CONSTRUCTOR" ) );

			WCHAR pwszCurrentTime[128];
			struct tm *pToday;
			time( &m_lTimeStarted );
			pToday = localtime( &m_lTimeStarted );
			wcsftime( pwszCurrentTime, sizeof pwszCurrentTime, L"%c", pToday );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Command-line: %s", GetCommandLineW() ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Product version: %d.%d.%d.%d", VER_PRODUCTVERSION ) );
			//BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  VSS SKU ID: 0x%02x", (UINT)CVssSKU::GetSKU() ) );			
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );

			//if ( CVssSKU::GetSKU() == CVssSKU::VSS_SKU_INVALID )
    			//BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"ERROR: Unable to determine the Windows SKU" ) );			    
			}
		catch(...)
			{
			delete m_pcs;
			m_pcs = NULL;
			m_bInitialized = false;
			m_bTracingEnabled = false;
			}
		}

}


BOOL
CBsDbgTrace::IsDuringSetup()
{
    return m_bIsDuringSetup;
}



HRESULT
CBsDbgTrace::ReadRegistry()
/*++

Routine Description:

    Tries to read debug specific values from the registry and adds
    the values if they don't exist.

Arguments:

    NONE

Return Value:

    HRESULT

--*/
{

	DWORD dwRes;
	CRegKey cRegKeySetup;
	CRegKey cRegKeyTracing;


    m_bTracingEnabled = FALSE;
    m_bIsDuringSetup = FALSE;
    
	//
	// Open the Setup key
	//

	dwRes = cRegKeySetup.Open( HKEY_LOCAL_MACHINE, SETUP_KEY, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
        DWORD dwSetupInProgress = 0;
        QuerySetValue( cRegKeySetup, dwSetupInProgress, SETUP_INPROGRESS_REG );
        m_bIsDuringSetup = ( dwSetupInProgress == SETUP_INPROGRESS_VALUE );
	}
	
	//
	// Open the VSS tracing key
	//

	dwRes = cRegKeyTracing.Open( HKEY_LOCAL_MACHINE, VSS_TRACINGKEYPATH, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
		
        // The name of the optional trace file
        QuerySetValue( cRegKeyTracing, m_pwszTraceFileName, BS_DBG_TRACE_FILE_NAME_REG );

        // The trace level determines what type of traciung will occur. Zero
        // indicates that no tracing will occur, and is the default.
        QuerySetValue( cRegKeyTracing, m_dwTraceLevel, BS_DBG_TRACE_LEVEL_REG );

        // The TraceEnterExit flag determines whether or not function entry & exit
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceEnterExit, BS_DBG_TRACE_ENTER_EXIT_REG );

        // The TraceToFile flag determines whether or not trace information is output to
        // the trace file. If this value is FALSE, no output is sent to the trace file.
        QuerySetValue( cRegKeyTracing, m_bTraceToFile, BS_DBG_TRACE_TO_FILE_REG );

        // The TraceToDebugger flag determines whether or not trace information is output
        // to the debugger. If this value is FALSE, no output is sent to the debugger.
        QuerySetValue( cRegKeyTracing, m_bTraceToDebugger, BS_DBG_TRACE_TO_DEBUGGER_REG );

        // The Timestamp flag determines whether or not timestamp
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceTimestamp, BS_DBG_TRACE_TIMESTAMP_REG );

        // The FileLineInfo flag determines whether or not the module file name
        // and line number information is output to the trace file & the debug
        // output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceFileLineInfo, BS_DBG_TRACE_FILE_LINE_INFO_REG );

        // The TraceForceFlush flag specifies whether or not after each trace message is
        // written to the trace file a forced flush occurs.  If enabled, no trace records
        // are ever lost, however, performance is greatly reduced.
        QuerySetValue( cRegKeyTracing, m_bForceFlush, BS_DBG_TRACE_FORCE_FLUSH_REG );

        // Determine if tracing should be enabled
        if ( m_bTraceToDebugger || m_bTraceToFile )
            m_bTracingEnabled = TRUE;

	}

    return S_OK;
}


HRESULT
CBsDbgTrace::PrePrint(
    IN LPCWSTR pwszSourceFileName,
    IN DWORD dwLineNum,
    IN DWORD dwIndent,
    IN DWORD dwLevel,
    IN LPCWSTR pwszFunctionName,
    IN BOOL bTraceEnter
    )
/*++

Routine Description:

    Acquires the critical section so that other threads are
    now serialized.  Opens the trace file if necessary.
    N.B. Any A/V's in this code can cause a hang since the SEH translator function
    calls these trace functions.

Arguments:

    pszSourceFileName - Source file name of the module whose
        code called this method.
    dwLineNum - Line number in the source
    dwIndent - Number to increase or decrease the indendation level
    dwLevel - Trace level that specifies for which component
        the code resides in.
    pwszFunctionName - For entry/exit tracing.  Specifies the
        function name constains a call the a trace macro.
    bTraceEnter - True if this is a entry trace.

Return Value:

    HRESULT

--*/
{
    m_pcs->Enter();

    //
    //  Assume the trace macros have already filtered out traces based
    //  on m_bTracingEnabled and on the active trace level.
    //

    if ( m_bTracingEnabled && (dwLevel & m_dwTraceLevel) != 0) {
        if ( pwszSourceFileName == NULL )
            m_pwszSourceFileName = L"(Unknown source file)";
        else
        {
            //
            //  Keep only two levels deep of directory components
            //
            LPCWSTR pwszTemp = pwszSourceFileName + ::wcslen( pwszSourceFileName ) - 1;
            for ( int i = 0; pwszTemp > pwszSourceFileName && i < 3; ++i )
            {
                do
                {
                    --pwszTemp;
                }
                while( *pwszTemp != L'\\' && pwszTemp > pwszSourceFileName ) ;
            }
            if ( pwszTemp > pwszSourceFileName )
                m_pwszSourceFileName = pwszTemp + 1;
            else
                m_pwszSourceFileName = pwszSourceFileName;
        }

        m_pwszFunctionName   = pwszFunctionName;
        m_dwLineNum        = dwLineNum;
        m_bTraceEnter      = bTraceEnter;

        BS_ASSERT( m_hTraceFile == INVALID_HANDLE_VALUE );

        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile == INVALID_HANDLE_VALUE ) {
                //
                //  Error opening the file, print a message to the debugger if debugger
                //  tracing is enabled
                //
                Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to open trace file, dwRet: %u", ::GetLastError() );
            } else {
                //
                //  Now lock the process from other processes and threads that are concurrently
                //  accessing the file.  Just lock the first byte of the file.
                //
                OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
                if ( !::LockFileEx( m_hTraceFile,
                                    LOCKFILE_EXCLUSIVE_LOCK,
                                    0,
                                    1,
                                    0,
                                    &ovStart ) ) {
                    //
                    //  Tracing to file will be skipped for this record.  This should
                    //  never happen in practice.
                    //
                    ::CloseHandle( m_hTraceFile );
                    m_hTraceFile = INVALID_HANDLE_VALUE;

                    //
                    //  Try printing a trace message that will get to the debugger if debugger
                    //  tracing is enabled
                    //
                    Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to lock trace file, skipping trace record, dwRet: %u", ::GetLastError() );
                } else {
                    //
                    //  If the file is new (empty) put the UNICODE BOM at the beginning of the file
                    //
                    LARGE_INTEGER liPointer;
                    if ( ::GetFileSizeEx( m_hTraceFile, &liPointer ) ) {
                        if ( liPointer.QuadPart == 0 )
                            ::MakeFileUnicode( m_hTraceFile );
                    }

                    //
                    //  Now move the file pointer to the end of the file
                    //
                    liPointer.QuadPart = 0;
                    if ( !::SetFilePointerEx( m_hTraceFile,
                                              liPointer,
                                              NULL,
                                              FILE_END ) ) {
                        //
                        //  Don't write to the file since it might overwrite valid records.
                        //  Tracing to file will be skipped for this record.  This should
                        //  never happen in practice.
                        //
                        ::CloseHandle( m_hTraceFile );
                        m_hTraceFile = INVALID_HANDLE_VALUE;

                        //
                        //  Try printing a trace message that will get to the debugger if debugger
                        //  tracing is enabled
                        //
                        Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to set end of file, skipping trace record, dwRet: %u", ::GetLastError() );
                    }
                }
            }
        }

        m_bInTrace = TRUE;
    }

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT
CBsDbgTrace::PostPrint(
    IN DWORD dwIndent
    )
/*++

Routine Description:

    Releases the critical section so that other threads
    can now call perform tracing.  Closes the trace file
    and resets variables.

Arguments:

    dwIndent - Number to increase or decrease the indendation level

Return Value:

    HRESULT

--*/
{
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
        if ( !::UnlockFileEx( m_hTraceFile,
                              0,
                              1,
                              0,
                              &ovStart ) ) {
            Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to unlock trace file, dwRet: %u", ::GetLastError() );
        }
        if ( m_bForceFlush )
            ::FlushFileBuffers( m_hTraceFile );
        ::CloseHandle( m_hTraceFile );
        m_hTraceFile = INVALID_HANDLE_VALUE;
    }

    m_pwszSourceFileName = NULL;
    m_pwszFunctionName = NULL;
    m_dwLineNum = 0;
    m_bInTrace  = FALSE;

    m_pcs->Leave();

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT _cdecl
CBsDbgTrace::Print(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            swprintf( m_pwszOutBuf,
                      L"[%010u,",
                      GetTickCount() );
        else
            swprintf( m_pwszOutBuf,
                      L"[-," );

        swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId );

        if ( m_bTraceFileLineInfo )
          swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                    L"%s(%04u): ",
                    m_pwszSourceFileName,
                    m_dwLineNum );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    _vsnwprintf( m_pwszOutBuf, BS_DBG_OUT_BUF_SIZE-1, pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT _cdecl
CBsDbgTrace::PrintEnterExit(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the entry/exit trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            swprintf( m_pwszOutBuf,
                      L"[%010u,",
                      GetTickCount() );
        else
            swprintf( m_pwszOutBuf,
                      L"[-," );

        swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] %s {%s}: ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId,
                  m_bTraceEnter ? L"ENTER" : L"EXIT ",
                  m_pwszFunctionName );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    _vsnwprintf( m_pwszOutBuf, BS_DBG_OUT_BUF_SIZE-1, pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT
CBsDbgTrace::OutputString()
/*++

Routine Description:

    Prints the trace message out to the trace file and/or debugger.

Arguments:

    Assumes m_pwszOutBuf has the string to be printed.

Return Value:

    HRESULT

--*/
{
    //
    //  Make sure we didn't go off the end.  Can't use BS_ASSERT(), it
    //  will cause an deadlock.
    //
    _ASSERTE( wcslen( m_pwszOutBuf ) < BS_DBG_OUT_BUF_SIZE );

    //
    // Print to the debug stream for debug builds
    //
    if ( m_bTraceToDebugger )
        OutputDebugString( m_pwszOutBuf );

    //
    // If file tracing is enabled, dump to file
    //
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        DWORD dwBytesWritten;
        ::WriteFile( m_hTraceFile,
                     m_pwszOutBuf,
                     (DWORD)(wcslen( m_pwszOutBuf ) * sizeof(WCHAR)),
                     &dwBytesWritten,
                     NULL );
    }

    return S_OK;
}


VOID CBsDbgTrace::SetContextNum(
    IN DWORD dwContextNum
    )
/*++

Routine Description:

    Use to be used to set the context number of the operation.  Now it is only
    used to determine if a DLL is loading using the trace class.

Arguments:

    LTS_CONTEXT_DELAYED_DLL - DLL is using the class object.

--*/
{
    if (dwContextNum == LTS_CONTEXT_DELAYED_DLL && !m_bInitialized )
    {
        Initialize();
    }

}


/*++

Routine Description:

    Puts the UNICODE UCS-2 BOM (Byte Order Mark) at the beginning of the file
    to let applications know that 1. this is a UCS-2 UNICODE file and 2. that
    the byte ordering is little-endian.

    Assumes the file is empty.

Arguments:

    hFile - Handle to the file

Return Value:

    <Enter return values here>

--*/
static VOID MakeFileUnicode(
    IN HANDLE hFile
    )
{
    BS_ASSERT( hFile != INVALID_HANDLE_VALUE );
    BYTE byteBOM[2] = { 0xFF, 0xFE };

    DWORD dwBytesWritten;
    ::WriteFile( hFile,
                 byteBOM,
                 sizeof byteBOM,
                 &dwBytesWritten,
                 NULL );
}


void __cdecl CVssFunctionTracer::TranslateError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszRoutine
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

--*/

    {
	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
#ifdef LOG_ERROR        
		LogError(VSS_ERROR_UNEXPECTED_CALLING_ROUTINE, dbgInfo << wszRoutine << hr);
#endif		
		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error in routine %s.  hr = 0x%08lx", wszRoutine, hr);
		}
	}


void __cdecl CVssFunctionTracer::TranslateGenericError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
        CVssOutputBuffer buffer;
        if (!buffer.IsBufferValid())
            throw(E_OUTOFMEMORY);
    
        va_list marker;
        va_start( marker, wszErrorTextFormat );
        _vsnwprintf( buffer.GetBuffer(), buffer.GetBufferSize(), wszErrorTextFormat, marker );
        va_end( marker );

    	if (hr == E_OUTOFMEMORY ||
    		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
    		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
    		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s", buffer.GetBuffer());
    	else
    		{
#ifdef LOG_ERROR        
    		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << buffer.GetBuffer() << hr);
#endif		
    		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s  [hr = 0x%08lx]", buffer.GetBuffer(), hr);
    		}
	}



void __cdecl CVssFunctionTracer::LogGenericWarning
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Log a generic warning.

--*/

    {
    CVssOutputBuffer buffer;
    if (!buffer.IsBufferValid())
        throw(E_OUTOFMEMORY);

    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( buffer.GetBuffer(), buffer.GetBufferSize(), wszErrorTextFormat, marker );
    va_end( marker );

#ifdef LOG_ERROR
       LogError(VSS_WARNING_UNEXPECTED, dbgInfo << buffer.GetBuffer() << hr, EVENTLOG_WARNING_TYPE);
#endif
       Trace(dbgInfo, L"WARNING: %s [hr = 0x%08lx]", buffer.GetBuffer(), hr);
	}


// This method must be called prior to calling a CoCreateInstance that may start VSS
void CVssFunctionTracer::LogVssStartupAttempt()
{
    // the name of the Volume Snapshot Service
    const LPCWSTR wszVssvcServiceName = L"VSS";
    
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;

    try
	{
        //
        //  Check to see if VSSVC is running. If not, we are putting an entry into the trace log if enabled.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"QueryServiceStatus (shSCService, &sSStat)");

        // If the service is not running, then we will put an informational error log entry 
        // if (sSStat.dwCurrentState != SERVICE_RUNNING)
        //     LogError(VSS_INFO_SERVICE_STARTUP, 
        //         VSSDBG_GEN << GetCommandLineW() << (HRESULT)sSStat.dwCurrentState, 
        //         EVENTLOG_INFORMATION_TYPE);
        if (sSStat.dwCurrentState != SERVICE_RUNNING)
            Trace( VSSDBG_GEN, 
                L"Volume Snapshots Service information: Service starting at request of process '%s'. [0x%08x]",
                GetCommandLineW(), sSStat.dwCurrentState );        
	} VSS_STANDARD_CATCH ((*this));

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);
}


void CVssFunctionTracer::CoCreateInstanceWithLog(
		IN  CVssDebugInfo   dbgInfo,          // Caller debugging info
        IN  CLSID           ServerClassID,
        IN  LPCWSTR         ServerName,
        IN  DWORD           dwContext,
        IN  IID             InterfaceID,
        OUT IUnknown **     ppUnknown
        )
{
    for(int nRetries = 0; nRetries < x_nMaxCoCreateInstanceRetries; nRetries++)
    {
        hr = ::CoCreateInstance( 
                            ServerClassID, 
                            NULL, 
                            dwContext, 
                            InterfaceID, 
                            (void**)ppUnknown);
        if (hr != CO_E_SERVER_EXEC_FAILURE)
            break;
    }

    // Treatment of the error cases
    switch(hr)
    {
    case S_OK:
        break;
    case E_OUTOFMEMORY:
        break;
    case CO_E_SERVER_EXEC_FAILURE:
#ifdef LOG_ERROR        
      	LogError( VSS_ERROR_STARTING_COM_SERVER_HEAVYLOAD, 
      	    dbgInfo << ServerClassID << ServerName << hr );
#endif
        break;
    default:
        BS_ASSERT(FAILED(hr));
#ifdef LOG_ERROR        
      	LogError( VSS_ERROR_STARTING_COM_SERVER, 
      	    dbgInfo << ServerClassID << ServerName << hr );
#endif
        break;
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\cmdproc.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name: CmdProc.cpp
//
//  Description:    
//      Definition of Command Processor class
//      CCommandProcessor initializes, starts and waits for processes.
//
//  Author:   Jim Benton (jbenton) 08-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCmdProcessor
{
    
public:
    
    CCmdProcessor();
    ~CCmdProcessor();

    HRESULT
    InitializeAsProcess(
        IN WCHAR* pwszApplication,
        IN WCHAR* pwszCommand);

    HRESULT
    InitializeAsClient(
        IN WCHAR* pwszApplication,
        IN WCHAR* pwszCommand);

    HRESULT
    LaunchProcess();

    HRESULT
    Wait(
        IN DWORD cMilliSeconds,
        OUT DWORD* pdwStatus);

    HRESULT
    QueryStatus(
        OUT DWORD* pdwStatus);
    
private:

    WCHAR* m_pwszApplication;
    WCHAR* m_pwszCommand;
    HANDLE m_hToken;
    HANDLE m_hProcess;
    void* m_pvEnvironment;   
    PROCESS_INFORMATION m_ProcessInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\cmdproc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name: CmdProc.cpp
//
//  Description:    
//      Implementation of Command Processor class
//      CCommandProcessor initializes, starts and waits for processes.
//
//  Author:   Jim Benton (jbenton) 08-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <userenv.h>
#include <strsafe.h>
#include "cmdproc.h"

CCmdProcessor::CCmdProcessor()
{
    m_pwszCommand = NULL;
    m_pwszApplication = NULL;
    m_pvEnvironment = NULL;
    m_hProcess = INVALID_HANDLE_VALUE;
    m_hToken = INVALID_HANDLE_VALUE;
    memset (&m_ProcessInfo, 0, sizeof (m_ProcessInfo));
    m_ProcessInfo.hProcess = INVALID_HANDLE_VALUE;
    m_ProcessInfo.hThread = INVALID_HANDLE_VALUE;
}

CCmdProcessor::~CCmdProcessor()
{
    delete [] m_pwszApplication;
    delete [] m_pwszCommand;
    if (m_pvEnvironment)
        DestroyEnvironmentBlock(m_pvEnvironment);
    if (m_hProcess != INVALID_HANDLE_VALUE)
        CloseHandle(m_hProcess);
    if (m_hToken != INVALID_HANDLE_VALUE)
        CloseHandle(m_hToken);
    if (m_ProcessInfo.hProcess != INVALID_HANDLE_VALUE)
        CloseHandle(m_ProcessInfo.hProcess);
    if (m_ProcessInfo.hThread != INVALID_HANDLE_VALUE)
        CloseHandle(m_ProcessInfo.hThread);
}

HRESULT
CCmdProcessor::InitializeAsClient(
    IN WCHAR* pwszApplication,
    IN WCHAR* pwszCommand)
{
    HRESULT hr = E_FAIL;
    HANDLE hTokenImpersonate = INVALID_HANDLE_VALUE;

    do
    {
        DWORD cchBuf = 0;
        BOOL bStatus = FALSE;
        
        if (pwszApplication == NULL || pwszCommand == NULL)
        {
            hr = E_INVALIDARG;
            break;
        }

        cchBuf = wcslen(pwszApplication) + 1;
        m_pwszApplication = new WCHAR[cchBuf];
        if (m_pwszApplication == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = StringCchCopy(m_pwszApplication, cchBuf, pwszApplication);
        if (FAILED(hr)) break;

        cchBuf = wcslen(pwszCommand) + 1;
        m_pwszCommand = new WCHAR[cchBuf];
        if (m_pwszCommand == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        hr = StringCchCopy(m_pwszCommand, cchBuf, pwszCommand);
        if (FAILED(hr)) break;

        bStatus = OpenThreadToken(
                                GetCurrentThread(),
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                                TRUE,
                                &hTokenImpersonate);
        if (!bStatus)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        bStatus = DuplicateTokenEx(
                                hTokenImpersonate,
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &m_hToken);
        if (!bStatus)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        bStatus = CreateEnvironmentBlock(
                                &m_pvEnvironment,
                                m_hToken,
                                FALSE);
        if (!bStatus)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        hr  = S_OK;
    }
    while (false);

    if (hTokenImpersonate != INVALID_HANDLE_VALUE)
        CloseHandle(hTokenImpersonate);
    
    return hr;
}

HRESULT
CCmdProcessor::LaunchProcess()
{
    HRESULT hr = S_OK;
    STARTUPINFO StartupInfo ;
    
    memset (&StartupInfo, 0, sizeof (StartupInfo));
    
    StartupInfo.cb = sizeof (STARTUPINFO) ;
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow  = SW_HIDE;
    
    BOOL bStatus = FALSE;

    bStatus = CreateProcessAsUser(
                            m_hToken,
                            m_pwszApplication,
                            m_pwszCommand,
                            NULL,   // default process security descriptor, not inheritable
                            NULL,   // default thread security descriptor, not inheritable
                            FALSE,  // no handles inherited from this process
                            NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
                            m_pvEnvironment,
                            NULL,   // use current working directory; this is SYSTEM32 directory for the WMI provider
                            &StartupInfo,
                            &m_ProcessInfo);                            
    if (!bStatus)
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}

HRESULT
CCmdProcessor::Wait(
    IN DWORD cMilliseconds,
    OUT DWORD* pdwStatus)
{
    HRESULT hr = E_FAIL;
    BOOL bStatus = FALSE;

    if (pdwStatus == NULL)
        return E_INVALIDARG;

    switch(WaitForSingleObject(m_ProcessInfo.hProcess, cMilliseconds))
    {
        case WAIT_OBJECT_0:
            bStatus = GetExitCodeProcess(m_ProcessInfo.hProcess, pdwStatus);
            if (!bStatus)
                hr = HRESULT_FROM_WIN32(GetLastError());
            else
                hr = S_OK;
            break;

        case WAIT_TIMEOUT:
            *pdwStatus = STILL_ACTIVE;
            hr = S_OK;
            break;
            
        default:
            *pdwStatus = WAIT_FAILED;
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT
CCmdProcessor::QueryStatus(
    OUT DWORD* pdwStatus)
{
    if (pdwStatus == NULL)
        return E_INVALIDARG;

    if (!GetExitCodeProcess(m_ProcessInfo.hProcess, pdwStatus))
        return HRESULT_FROM_WIN32(GetLastError());
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\instanceprov.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.cpp
//
//  Description:    
//      Implementation of CInstanceProv class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//        MSP Prabu  (mprabu)  06-Jan-2001
//        Jim Benton (jbenton) 15-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "Pch.h"
#include "InstanceProv.h"
#include "VdsClasses.h"
#include "Quota.h"
#include "msg.h"

BOOL MapVdsErrorToMsgAndWMIStatus(
    IN HRESULT hr,
    OUT LONG *plMsgNum,
    OUT HRESULT* pHr
    );

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

long                g_lNumInst = 0;
ClassMap            g_ClassMap;

//****************************************************************************
//
//  CInstanceProv
//
//****************************************************************************

CInstanceProv::~CInstanceProv( void )
{
    InterlockedDecrement( &g_cObj );

    DeleteCriticalSection(&g_csThreadData);

    //#ifdef _DEBUG
    #ifdef _DEBUG_NEVER
        _CrtDumpMemoryLeaks();
    #endif
}



//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoCreateInstanceEnumAsync
//
//  Description:
//      Enumerate instance for a given class.
//
//  Arguments:
//      bstrRefStr    -- Name the class to enumerate
//      lFlags        -- WMI flag
//      pCtx          -- WMI context
//      pHandler      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::DoCreateInstanceEnumAsync(
    IN BSTR bstrRefStr,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    
    HRESULT hr = WBEM_S_NO_ERROR;
    if (bstrRefStr == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        auto_ptr<CProvBase> pProvBase;

        CreateClass(bstrRefStr, m_pNamespace, pProvBase);

        hr = pProvBase->EnumInstance(
            lFlags,
            pCtx,
            pHandler
            );
        
        if (FAILED(hr))
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
    
} //*** CInstanceProv::DoCreateInstanceEnumAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoGetObjectAsync
//
//  Description:
//      Creates an instance given a particular path value.
//
//  Arguments:
//      bstrObjectPath    -- Object path to an object
//      lFlags            -- WMI flag
//      pCtx              -- WMI context
//      pHandler          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::DoGetObjectAsync(
    IN BSTR bstrObjectPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    HRESULT hr = S_OK;
    if (bstrObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        CObjPath ObjPath;
        _bstr_t bstrClass;
        auto_ptr<CProvBase> pProvBase;

        if (!ObjPath.Init( bstrObjectPath))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();

        CreateClass(bstrClass, m_pNamespace, pProvBase);

        hr = pProvBase->GetObject(
            ObjPath,
            lFlags,
            pCtx,
            pHandler
            );

        if (FAILED(hr))
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
         hr = SetExtendedStatus(prove, & pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;

} //*** CInstanceProv::DoGetObjectAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoPutInstanceAsync
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      pInst         -- WMI object to be saved
//      lFlags        -- WMI flag
//      pCtx          -- WMI context
//      pHandler      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CInstanceProv::DoPutInstanceAsync(
    IN IWbemClassObject* pInst,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    
    HRESULT hr = S_OK;
    if (pInst == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        _variant_t varClass;
        auto_ptr<CProvBase> pProvBase;
        CWbemClassObject wcoSrc(pInst);

        hr = pInst->Get(L"__CLASS", 0, &varClass, 0, 0);
        
        CreateClass(varClass.bstrVal, m_pNamespace, pProvBase);

        hr = pProvBase->PutInstance(
            wcoSrc,
            lFlags,
            pCtx,
            pHandler
            );

        if (FAILED(hr))
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
         hr = SetExtendedStatus(prove , &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
} //*** CInstanceProv::DoPutInstanceAsync()
 
//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoDeleteInstanceAsync
//
//  Description:
//      Delete this instance.
//
//  Arguments:
//      bstrObjectPath    -- ObjPath for the instance to be deleted
//      lFlags            -- WMI flag
//      pCtx              -- WMI context
//      pHandler          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////      
HRESULT
CInstanceProv::DoDeleteInstanceAsync(
     IN BSTR bstrObjectPath,
     IN long lFlags,
     IN IWbemContext* pCtx,
     IN IWbemObjectSink* pHandler
     )
{
    HRESULT hr = S_OK;
    if (bstrObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        CObjPath ObjPath;
        _bstr_t bstrClass;
        auto_ptr<CProvBase> pProvBase;

        if (!ObjPath.Init(bstrObjectPath))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();

        CreateClass(bstrClass, m_pNamespace, pProvBase);

        hr = pProvBase->DeleteInstance(
            ObjPath,
            lFlags,
            pCtx,
            pHandler
            );

        if (FAILED(hr))
        {
            CProvException exception( hr );
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
         hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;

} //*** CInstanceProv::DoDeleteInstanceAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoExecMethodAsync
//
//  Description:
//      Execute methods for the given object.
//
//  Arguments:
//      bstrObjectPath    -- Object path to a given object
//      bstrMethodName    -- Name of the method to be invoked
//      lFlags            -- WMI flag
//      pCtx              -- WMI context
//      pInParams         -- Input parameters for the method
//      pHandler          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::DoExecMethodAsync(
    IN BSTR bstrObjectPath,
    IN BSTR bstrMethodName,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemClassObject* pInParams,
    IN IWbemObjectSink* pHandler
    )
{
    HRESULT hr = S_OK;
    if (bstrObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL
        || bstrMethodName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        CObjPath ObjPath;
        _bstr_t bstrClass;
        auto_ptr<CProvBase> pProvBase;

        if (!ObjPath.Init(bstrObjectPath))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();

        CreateClass(bstrClass, m_pNamespace, pProvBase);

        hr = pProvBase->ExecuteMethod(
                bstrObjectPath,
                bstrMethodName,
                lFlags,
                pInParams,
                pHandler
                );

        if ( FAILED( hr ) )
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;

} //*** CInstanceProv::DoExecMethodAsync()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::SetExtendedStatus
//
//  Description:
//      Create and set extended error status.
//
//  Arguments:
//      rpeIn       -- Exception object.
//      rwcoInstOut -- Reference to WMI instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::SetExtendedStatus(
    IN CProvException &    rpe,
    IN IWbemObjectSink **  ppHandler
    )
{
    HRESULT hrStatus = WBEM_S_NO_ERROR; 
    CComPtr<IWbemClassObject> spStatus;
    CWbemClassObject wcoInst;

    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"SetExtendedStatus" );

    try
    {    
        ft.hr =  m_pNamespace->GetObject(
                    _bstr_t(PVD_WBEM_EXTENDEDSTATUS),
                    0,
                    NULL,
                    &spStatus,
                    NULL
                    );
        
        if (SUCCEEDED(ft.hr))
        {
            ft.hr = spStatus->SpawnInstance(0, &wcoInst);
            if (SUCCEEDED(ft.hr))
            {
                _bstr_t bstrError;
                WCHAR* pwszErrorMsg = NULL;
                LONG lMsg = 0;

                if (MapVdsErrorToMsgAndWMIStatus(rpe.hrGetError(), &lMsg, &hrStatus))
                {
                    // Auto-delete string
                    CVssAutoPWSZ awszMsg(GetMsg(lMsg));
                    
                    // The following may throw CProvException
                    wcoInst.SetProperty(awszMsg, PVD_WBEM_DESCRIPTION);
                }
                else
                {
                    if (rpe.PwszErrorMessage())
                    {
                        bstrError = rpe.PwszErrorMessage();
                        if (rpe.PwszGetErrorHelpInfo())
                        {
                            bstrError += L" ";
                            bstrError += rpe.PwszGetErrorHelpInfo();
                        }
                    }
                    else if (rpe.PwszGetErrorHelpInfo())
                    {
                        bstrError = rpe.PwszGetErrorHelpInfo();
                    }
                    
                    // The following may throw CProvException
                    wcoInst.SetProperty((WCHAR*)bstrError, PVD_WBEM_DESCRIPTION);
                }
                
                wcoInst.SetProperty(rpe.hrGetError(), PVD_WBEM_STATUSCODE);
                wcoInst.SetProperty(PVD_WBEM_PROVIDERNAME, PVD_WBEM_PROP_PROVIDERNAME);

                ft.hr = (*ppHandler)->SetStatus(
                        0,
                        hrStatus,
                        0,
                        wcoInst.data( )
                        );

                ft.Trace(VSSDBG_VSSADMIN, L"SetStatus <%#x>", hrStatus);

            }
        }
    }
    catch (CProvException& prove)
    {
        ft.hr = prove.hrGetError();
    }
    catch (_com_error& err)
    {
        ft.hr = err.Error();
    }
    
    return ft.hr;

} //*** CInstanceProv::SetExtendedStatus()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pUnknownOuterIn -- Outer IUnknown pointer.
//      ppvOut          -- Receives the created instance pointer.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::S_HrCreateThis(
    IN IUnknown*  ,// pUnknownOuterIn,
    OUT VOID**     ppv
    )
{
    _ASSERTE(ppv != NULL);
    *ppv = new CInstanceProv();
    return S_OK;

} //*** CInstanceProv::S_HrCreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CInstanceProv::Initialize
//
//  Description:
//      Initialize the instance provider.
//
//  Arguments:
//      pszUserIn       -- 
//      lFlagsIn        -- WMI flag
//      pszNamespaceIn  -- 
//      pszLocaleIn     -- 
//      pNamespaceIn    -- 
//      pCtxIn          -- WMI context
//      pInitSinkIn     -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CInstanceProv::Initialize(
    IN LPWSTR pszUser,
    IN LONG lFlags,
    IN LPWSTR pszNamespace,
    IN LPWSTR pszLocale,
    IN IWbemServices* pNamespace,
    IN IWbemContext* pCtx,
    IN IWbemProviderInitSink* pInitSink
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (!m_fInitialized)
        {
            // This global lock controls access to per thread data used
            // during Format and ChkDsk callbacks
            InitializeCriticalSection(&g_csThreadData);
                
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_MOUNTPOINT,
                CClassCreator(&CMountPoint::S_CreateThis, PVDR_CLASS_MOUNTPOINT)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_VOLUME,
                CClassCreator(&CVolume::S_CreateThis, PVDR_CLASS_VOLUME)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_VOLUMEQUOTA,
                CClassCreator(&CVolumeQuota::S_CreateThis, PVDR_CLASS_VOLUMEQUOTA)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_VOLUMEUSERQUOTA,
                CClassCreator(&CVolumeUserQuota::S_CreateThis, PVDR_CLASS_VOLUMEUSERQUOTA)));

            hr = CImpersonatedProvider::Initialize(
                    pszUser,
                    lFlags,
                    pszNamespace,
                    pszLocale,
                    pNamespace,
                    pCtx,
                    pInitSink
                    );

            m_fInitialized = TRUE;
        }
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
    }

    return hr;
} //*** CInstanceProv::Initialize()


//
//  Returns TRUE if error message was mapped
//
BOOL MapVdsErrorToMsgAndWMIStatus(
    IN HRESULT hr,
    OUT LONG *plMsgNum,
    OUT HRESULT* pHr
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"MapVdsErrorToMsg" );

    ft.Trace( VSSDBG_VSSADMIN, L"Input HR: 0x%08x", hr );

    _ASSERTE(plMsgNum != NULL);
    _ASSERTE(pHr != NULL);    
    
    LONG msg = 0;
    *plMsgNum = 0;
    *pHr = WBEM_E_PROVIDER_FAILURE;

    // Let Win32 errors through
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        *pHr = hr;
    }
    // Let WMI errors through
    else if (HRESULT_FACILITY(hr) == FACILITY_ITF && 
                HRESULT_CODE(hr) > 0x1000 && HRESULT_CODE(hr) < 0x108b)
    {
        *pHr = hr;
    }
    else
    {
        switch ( hr ) 
        {
        case E_ACCESSDENIED:
            msg = MSG_ERROR_ACCESS_DENIED;                
            *pHr = WBEM_E_ACCESS_DENIED;
            break;        
        case E_OUTOFMEMORY:
            msg = MSG_ERROR_OUT_OF_MEMORY;
            *pHr = WBEM_E_OUT_OF_MEMORY;
            break;
        case E_INVALIDARG:
            msg = MSG_ERROR_INVALID_ARGUMENT;                
            *pHr = WBEM_E_INVALID_PARAMETER;
            break;        
        case VDSWMI_E_DRIVELETTER_IN_USE:
            msg = MSG_ERROR_DRIVELETTER_IN_USE;                
            *pHr = WBEM_E_NOT_AVAILABLE;
            break;        
        case VDSWMI_E_DRIVELETTER_UNAVAIL:
            msg = MSG_ERROR_DRIVELETTER_UNAVAIL;                
            *pHr = WBEM_E_NOT_AVAILABLE;
            break;
        case VDSWMI_E_DRIVELETTER_CANT_DELETE:
            msg = MSG_ERROR_DRIVELETTER_CANT_DELETE;                
            *pHr = WBEM_E_NOT_SUPPORTED;
            break;
        }
    }

    if ( msg == 0 )
        return FALSE;
    
    *plMsgNum = msg;
    
    ft.Trace( VSSDBG_VSSADMIN, L"Output Msg#: 0x%08x", msg );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\util.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Util.cpp
//
//  Description:
//      Implementation of utility class and functions
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//      MSP Prabu  (mprabu)  06-Jan-2001
//      Jim Benton (jbenton) 15-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ProvBase.h"


//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////

//
// wbem
//
const WCHAR * const PVD_WBEM_PROVIDERNAME         = L"Volume Shadow Copy WMI Provider";
const WCHAR * const PVD_WBEM_EXTENDEDSTATUS         = L"__ExtendedStatus";
const WCHAR * const PVD_WBEM_DESCRIPTION            = L"Description";
const WCHAR * const PVD_WBEM_STATUSCODE             = L"StatusCode";
const WCHAR * const PVD_WBEM_STATUS                 = L"Status";
const WCHAR * const PVD_WBEM_CLASS                  = L"__CLASS";
const WCHAR * const PVD_WBEM_RELPATH                = L"__Relpath";
const WCHAR * const PVD_WBEM_PROP_ANTECEDENT        = L"Antecedent";
const WCHAR * const PVD_WBEM_PROP_DEPENDENT         = L"Dependent";
const WCHAR * const PVD_WBEM_PROP_ELEMENT         = L"Element";
const WCHAR * const PVD_WBEM_PROP_SETTING         = L"Setting";
const WCHAR * const PVD_WBEM_PROP_DEVICEID          = L"DeviceId";
const WCHAR * const PVD_WBEM_PROP_RETURNVALUE           = L"ReturnValue";
const WCHAR * const PVD_WBEM_PROP_PROVIDERNAME        = L"ProviderName";
const WCHAR * const PVD_WBEM_QUA_DYNAMIC            = L"Dynamic";
const WCHAR * const PVD_WBEM_QUA_CIMTYPE            = L"CIMTYPE";
const WCHAR * const PVD_WBEM_DATETIME_FORMAT             =L"%04d%02d%02d%02d%02d%02d.%06d%+03d";

//
// Constants used in partial value maps for localization
//
const WCHAR * const PVDR_CONS_UNAVAILABLE           = L"Unavailable";
const WCHAR * const PVDR_CONS_ENABLED               = L"Enabled";
const WCHAR * const PVDR_CONS_DISABLED              = L"Disabled";


//////////////////////////////////////////////////////////////////////////////
//++
//      
//  void
//  CreateClass(
//      const WCHAR *           pwszClassNameIn,
//      CWbemServices *         pNamespaceIn,
//      auto_ptr< CProvBase > & rNewClassInout
//      )
//
//  Description:
//      Create the specified class
//
//  Arguments:
//      pwszClassNameIn     -- Name of the class to create.
//      pNamespaceIn        -- WMI namespace
//      rNewClassInout      -- Receives the new class.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CreateClass(
    IN const WCHAR *           pwszClassName,
    IN CWbemServices *         pNamespace,
    IN OUT auto_ptr< CProvBase > & rNewClass
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CreateClass");
    ClassMap::iterator itMap;

    _ASSERTE(pwszClassName != NULL);
    _ASSERTE(pNamespace != NULL);

    itMap = g_ClassMap.find(pwszClassName);
    
    if ( itMap != g_ClassMap.end() )
    {
        CClassCreator& rcc = itMap->second;
       
        auto_ptr< CProvBase > pBase(
            rcc.m_pfnConstructor(
                rcc.m_pbstrClassName,
                pNamespace
                )
            );

            if (pBase.get() == NULL)
                throw CProvException( static_cast< HRESULT >( WBEM_E_INITIALIZATION_FAILURE ) );
            
            rNewClass = pBase;
    }
    else
    {
        throw CProvException( static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
    }

    return;

} //*** void CreateClass()

WCHAR* GuidToString(
    IN GUID guid
    )
{
    WCHAR* pwszGuid = reinterpret_cast<WCHAR*>(::CoTaskMemAlloc((g_cchGUID) * sizeof(WCHAR)));
    
    if (pwszGuid == NULL)
        throw CProvException(E_OUTOFMEMORY);

    _snwprintf(pwszGuid, g_cchGUID,
               L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}",
            GUID_PRINTF_ARG(guid));

    return pwszGuid;
}

_bstr_t EncodeQuotes( WCHAR * wszString )
{
    // Encodes only double-quote and back-slash in the key
    // property strings in building the object path string.

    _bstr_t bstrTemp;
    if( wszString == NULL )
        return bstrTemp;

    int nSize = 0;
    WCHAR* des = NULL;
    WCHAR* src = wszString;

    // loop to find the character to encode
    while(*src)
    {
        // check character
        switch(*src)
        {
        case L'"':
            nSize += 2;
            break;
        case L'\\':
            nSize += 2;
            break;
        default:
            nSize++;
            break;
        }

        src++;
    }
    
    // create buffer 
    WCHAR* pwszEncoded = new WCHAR[nSize + 1]; 
    if(pwszEncoded == NULL)
        return bstrTemp;

    ZeroMemory(pwszEncoded, (nSize + 1)*sizeof(WCHAR));
    src = wszString;
    des = pwszEncoded;

    // loop to encode
    while(*src)
    {
        // check character
        switch(*src)
        {
        case L'"':
            lstrcpyn(des, L"\\\"", 3);  // the char count includes null termination char
            des += 2;
            break;
        case L'\\':
            lstrcpyn(des, L"\\\\", 3);  // the char count includes null termination char
            des += 2;
            break;
        default:
            *des = *src;
            des++;
            break;
        }

        src++;
    }

    bstrTemp = pwszEncoded;
    delete [] pwszEncoded;

    return bstrTemp;
}


LPWSTR GetMsg(
    IN  LONG msgId,
    ...
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetMsg" );
    
    va_list args;
    LPWSTR lpMsgBuf;
    LPWSTR lpReturnStr = NULL;
    
    va_start( args, msgId );

    if (::FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | 
                FORMAT_MESSAGE_MAX_WIDTH_MASK,
            g_hModule,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args
            ))
    {
        ::VssSafeDuplicateStr( ft, lpReturnStr, lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }
    else if (::FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK,
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args ) )
    {
        ::VssSafeDuplicateStr( ft, lpReturnStr, lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }

    va_end( args );

    //  Returns NULL if message was not found
    return lpReturnStr;
}

#ifdef PROP_ARRAY_ENABLE
//****************************************************************************
//
//  PropMapEntryArray
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  SPropMapEntryArray::PwszLookup(
//      LPCWSTR     pwszIn
//      ) const
//
//  Description:
//      Lookup an entry in the array.
//
//  Arguments:
//      pwszIn      -- Name of entry to lookup.
//
//  Return Values:
//      Pointer to string entry in the array.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
SPropMapEntryArray::PwszLookup(
    IN LPCWSTR     pwsz
    ) const
{
    UINT idx;

    _ASSERTE(pwszIn != NULL);
    
    for ( idx = 0; idx < m_dwSize; idx ++ )
    {
        if ( _wcsicmp( pwsz, m_pArray[ idx ].clstName ) == 0 )
        {
            //
            // mofName is NULL for clstname not supported
            //
            return m_pArray[ idx ].mofName;
        }
    }

    //
    // mofname is the same as clstname if not found in the table
    //
    return pwsz;

} //*** SPropMapEntry::PwszLookup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  PwszSpaceReplace(
//      LPWSTR      pwszTrgInout,
//      LPCWSTR     pwszSrcIn,
//      WCHAR       wchArgIn
//      )
//
//  Description:
//      Replace spaces in a string with another character.
//      Ignores leading spaces.
//
//  Arguments:
//      pwszTrgInout    -- Target string.
//      pwszSrcIn       -- Source string.
//      wchArgIn        -- Character to replace spaces with.
//
//  Return Values:
//      Pointer to the target string.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPWSTR
PwszSpaceReplace(
    IN OUT LPWSTR      pwszTrg,
    IN LPCWSTR     pwszSrc,
    IN WCHAR       wchArg
    )
{
    LPCWSTR pwsz = NULL;
    LPWSTR  pwszTrg = NULL;

    if ( ( pwszTrg == NULL ) || ( pwszSrc == NULL ) )
    {
        return NULL;
    }

    //
    // ignore leading space
    //
    for ( pwsz = pwszSrc ; *pwsz == L' '; pwsz++ )
    {
        // empty loop
    }
    pwszTrg = pwszTrg;
    for ( ; *pwsz != L'\0' ; pwsz++ )
    {
        if ( *pwsz == L' ' )
        {
            *pwszTrg++  = wchArg;
            for ( ; *pwsz == L' '; pwsz++ )
            {
                // empty loop
            }
            pwsz--;
        }
        else
        {
            *pwszTrg++  = *pwsz;
        }
    } // for: each character in the source string

    *pwszTrg = L'\0';
    return pwszTrg;

} //*** PwszSpaceReplace()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\instanceprov.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.h
//
//  Implementation File:
//      InstanceProv.cpp
//
//  Description:
//      Definition of the CInstanceProv class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//        MSP Prabu  (mprabu)  06-Jan-2001
//        Jim Benton (jbenton) 15-Oct-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CInstanceProv;
class CWbemClassObject;
class CProvException;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CInstanceProv
//
//  Description:
//      Implement the Instance and method provider entry point class. WMI 
//      holds a pointer to this object, and invoking its member functions 
//      based client request
//
//--
//////////////////////////////////////////////////////////////////////////////
class CInstanceProv : public CImpersonatedProvider
{
protected:
    HRESULT SetExtendedStatus(
        CProvException &    rpe ,
        IWbemObjectSink **  ppHandler
        );
 
public:
    CInstanceProv(
        IN BSTR            bstrObjectPath    = NULL,
        IN BSTR            bstrUser          = NULL,
        IN BSTR            bstrPassword      = NULL,
        IN IWbemContext *  pCtx              = NULL
        )
    {
        InterlockedIncrement( &g_cObj );
        m_fInitialized = FALSE;
    }

    virtual ~CInstanceProv( void );
    
    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        IN BSTR                bstrObjectPath,
        IN long                lFlags,
        IN IWbemContext *      pCtx,
        IN IWbemObjectSink *   pHandler
        );

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IN IWbemClassObject *   pInst,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        ) ;

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        IN BSTR                 bstrObjectPath,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        ) ;

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        IN BSTR                 bstrRefStr,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        );

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        IN BSTR                 bstrQueryLanguage,
        IN BSTR                 bstrQuery,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        IN BSTR                bstrObjectPath,
        IN BSTR                bstrMethodName,
        IN long                lFlags,
        IN IWbemContext *      pCtx,
        IN IWbemClassObject *  pInParams,
        IN IWbemObjectSink *   pHandler
        );

    STDMETHODIMP Initialize(
         IN LPWSTR                  pszUser,
         IN LONG                    lFlags,
         IN LPWSTR                  pszNamespace,
         IN LPWSTR                  pszLocale,
         IN IWbemServices *         pNamespace,
         IN IWbemContext *          pCtx,
         IN IWbemProviderInitSink * pInitSink
         );

    static HRESULT S_HrCreateThis(
        IN IUnknown *  pUnknownOuter,
        OUT VOID **     ppv
        );

private:
    BOOL m_fInitialized;
}; //*** CInstanceProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter (DavidP) 05-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////


#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )
#include <wbemprov.h>
#include <objbase.h>
#include <map>
#include <comdef.h>

#include "vs_assert.hxx"

#include <atlbase.h>
#include "NtRkComm.h"
#include "ObjectPath.h"
#include "vs_inc.hxx"
#include "vs_vol.hxx"
#include "Common.h"
#include "schema.h"
#include "strsafe.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\quota.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name:
//      Quota.h
//
//  Implementation File:
//      Quota.cpp
//
//  Description:
//      Definition of the VDS WMI Provider quota classes.
//
//  Author:   Jim Benton (jbenton) 25-Mar-2002
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "ProvBase.h"
#include "dskquota.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CVolumeQuota
//
//  Description:
//      Provider Implementation for Volume
//
//--
//////////////////////////////////////////////////////////////////////////////
class CVolumeQuota : public CProvBase
{
//
// constructor
//
public:
    CVolumeQuota(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    ~CVolumeQuota(){ }

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize();

private:

    void LoadInstance(
        IN WCHAR* pwszVolume,
        IN WCHAR* pwszDirectory,
        IN OUT IWbemClassObject* pObject);

}; // class CVolumeQuota


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CVolumeUserQuota
//
//  Description:
//      Provider Implementation for Volume
//
//--
//////////////////////////////////////////////////////////////////////////////
class CVolumeUserQuota : public CProvBase
{
//
// constructor
//
public:
    CVolumeUserQuota(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    ~CVolumeUserQuota(){ }

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize();

private:

    void LoadInstance(
        IN WCHAR* pwszVolume,
        IN IDiskQuotaUser* pIDQUser,
        IN OUT IWbemClassObject* pObject);

    HRESULT Create(
        IN _bstr_t bstrDomainName,
        IN _bstr_t bstrUserName,
        IN IDiskQuotaControl* pIDQC,
        OUT IDiskQuotaUser** ppIQuotaUser);
}; // class CVolumeUserQuota
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\quota.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name: Quota.cpp
//
//  Description:    
//      Implementation of VDS WMI Provider quota classes 
//
//  Author:   Jim Benton (jbenton) 25-Mar-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Quota.h"
#include "volutil.h"

#define INITGUIDS
#include "dskquota.h"

HRESULT FindQuotaUserFromEnum(
    WCHAR* pwszUser,
    IDiskQuotaControl* pIDQC,
    IDiskQuotaUser** ppQuotaUser);

HRESULT FindQuotaUserWithRecord(
    IN _bstr_t bstrDomain,
    IN _bstr_t bstrUser,
    IN IDiskQuotaControl* pIDQC,
    OUT IDiskQuotaUser** ppIQuotaUser);

HRESULT FindQuotaUser(
    IN _bstr_t bstrDomain,
    IN _bstr_t bstrUser,
    IN IDiskQuotaControl* pIDQC,
    OUT IDiskQuotaUser** ppIQuotaUser);

BOOL TranslateDomainName(
    IN WCHAR* pwszDomain,
    OUT CVssAutoPWSZ& rawszDomain);

 BOOL GetLocalDomainName(
    IN DWORD dwWellKnownAuthority,
    OUT CVssAutoPWSZ& rawszDomain);


//****************************************************************************
//
//  CVolumeQuota
//
//****************************************************************************

CVolumeQuota::CVolumeQuota( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CVolumeQuota::CVolumeQuota()

CProvBase *
CVolumeQuota::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CVolumeQuota * pObj= NULL;

    pObj = new CVolumeQuota(pwszName, pNamespace);

    if (pObj)
    {
        hr = pObj->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pObj;
        pObj = NULL;
    }
    return pObj;

} //*** CVolumeQuota::S_CreateThis()


HRESULT
CVolumeQuota::Initialize()
{

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeQuota::Initialize");
    
    return ft.hr;
}

HRESULT
CVolumeQuota::EnumInstance( 
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink *    pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeQuota::EnumInstance");
    CVssAutoPWSZ awszVolume;
        
    try
    {
        awszVolume.Allocate(MAX_PATH);

        CVssVolumeIterator volumeIterator;

        while (true)
        {
            DWORD dwDontCare = 0;
            DWORD dwFileSystemFlags = 0;
            
            // Get the volume name
            if (!volumeIterator.SelectNewVolume(ft, awszVolume, MAX_PATH))
                break;

            if (VolumeSupportsQuotas(awszVolume))
            {
                CComPtr<IWbemClassObject> spInstance;
                WCHAR wszDisplayName[MAX_PATH+1] ;
                
                // The key property on the QuotaSetting object is the display name
                VssGetVolumeDisplayName(
                    awszVolume,
                    wszDisplayName,
                    MAX_PATH);
            
                ft.hr = m_pClass->SpawnInstance(0, &spInstance);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(awszVolume, wszDisplayName, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);            
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolumeQuota::EnumInstance()

void
CVolumeQuota:: LoadInstance(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszQuotaSetting,
    IN OUT IWbemClassObject* pObject)
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathQuotaSetting;
    CObjPath pathVolume;
    
    // Set the QuotaSetting Ref property
    pathQuotaSetting.Init(PVDR_CLASS_QUOTASETTING);
    pathQuotaSetting.AddProperty(PVDR_PROP_VOLUMEPATH, pwszQuotaSetting);    
    wcoInstance.SetProperty((wchar_t*)pathQuotaSetting.GetObjectPathString(), PVD_WBEM_PROP_SETTING);

    // Set the Volume Ref property
    pathVolume.Init(PVDR_CLASS_VOLUME);
    pathVolume.AddProperty(PVDR_PROP_DEVICEID, pwszVolume);    
    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVD_WBEM_PROP_ELEMENT);
}

//****************************************************************************
//
//  CVolumeUserQuota
//
//****************************************************************************

CVolumeUserQuota::CVolumeUserQuota( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CVolumeUserQuota::CVolumeUserQuota()

CProvBase *
CVolumeUserQuota::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CVolumeUserQuota * pObj= NULL;

    pObj = new CVolumeUserQuota(pwszName, pNamespace);

    if (pObj)
    {
        hr = pObj->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pObj;
        pObj = NULL;
    }
    return pObj;

} //*** CVolumeUserQuota::S_CreateThis()


HRESULT
CVolumeUserQuota::Initialize()
{

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::Initialize");
    
    return ft.hr;
}

HRESULT
CVolumeUserQuota::EnumInstance( 
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink *    pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::EnumInstance");
    CVssAutoPWSZ awszVolume;
        
    try
    {
        awszVolume.Allocate(MAX_PATH);

        CVssVolumeIterator volumeIterator;

        while (true)
        {
            DWORD dwDontCare = 0;
            DWORD dwFileSystemFlags = 0;
            
            // Get the volume name
            if (!volumeIterator.SelectNewVolume(ft, awszVolume, MAX_PATH))
                break;

            if (VolumeSupportsQuotas(awszVolume))
            {
                CComPtr<IDiskQuotaControl> spIDQC;
                IDiskQuotaControl* pIDQC = NULL;
                CComPtr<IEnumDiskQuotaUsers> spIEnum;
                
                ft.hr = CoCreateInstance(
                                CLSID_DiskQuotaControl,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IDiskQuotaControl,
                                (void **)&pIDQC);
                if (ft.HrFailed())
                {
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"unable to CoCreate IDiskQuotaControl");
                }

                spIDQC.Attach(pIDQC);

                ft.hr = spIDQC->Initialize(awszVolume, FALSE /* read only */);
                if (ft.HrFailed())
                {
                    ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaControl::Initialize failed for volume %lS", awszVolume);
                    continue;
                }        

                // Need to update the cache, else we can get old names
                ft.hr = spIDQC->InvalidateSidNameCache();
                if (ft.HrFailed())
                {
                    ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaControl::InvalidateSidNameCache failed for volume %lS", awszVolume);
                    continue;
                }        

                ft.hr = spIDQC->CreateEnumUsers(
                                            NULL, //All the users will be enumerated
                                            0,    // Ignored for enumerating all users
                                            DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                            &spIEnum );
                if (ft.HrFailed())
                {
                    ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaControl::CreateEnumUsers failed for volume %lS", awszVolume);
                    continue;
                }        

                if (spIEnum != NULL)
                {
                    while (true)
                    {
                        CComPtr<IWbemClassObject> spInstance;
                        CComPtr<IDiskQuotaUser> spIQuotaUser;
                        DWORD cUsers = 0;
                        
                        ft.hr = spIEnum->Next(1, &spIQuotaUser, &cUsers);
                        if (ft.HrFailed())
                        {
                            ft.Trace(VSSDBG_VSSADMIN, L"IEnumDiskQuotaUsers::Next failed for volume %lS", awszVolume);
                            continue;
                        }

                        if (ft.hr == S_FALSE)
                            break;

                        ft.hr = m_pClass->SpawnInstance(0, &spInstance);
                        if (ft.HrFailed())
                            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                        LoadInstance(awszVolume, spIQuotaUser, spInstance.p);

                        ft.hr = pHandler->Indicate(1, &spInstance.p);            
                    }
                }
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolumeUserQuota::EnumInstance()

HRESULT
CVolumeUserQuota::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::GetObject");

    try
    {
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrAccountRef, bstrDomainName, bstrUserName;
        CObjPath  objPathVolume;
        CObjPath  objPathAccount;
        CComPtr<IWbemClassObject> spInstance;
        CComPtr<IDiskQuotaUser> spIQuotaUser;
        CComPtr<IDiskQuotaControl> spIDQC;
        IDiskQuotaControl* pIDQC = NULL;
        _bstr_t bstrFQUser;

        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_VOLUME);

        // Get the Account reference
        bstrAccountRef = rObjPath.GetStringValueForProperty(PVDR_PROP_ACCOUNT);

        // Extract the Volume and Account Names
        objPathVolume.Init(bstrVolumeRef);
        objPathAccount.Init(bstrAccountRef);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        if ((wchar_t*)bstrVolumeName == NULL || ((wchar_t*)bstrVolumeName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property DeviceID not found");
        }

        bstrUserName = objPathAccount.GetStringValueForProperty(PVDR_PROP_NAME);
        if ((wchar_t*)bstrUserName == NULL || ((wchar_t*)bstrUserName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property Name not found");
        }

        bstrDomainName = objPathAccount.GetStringValueForProperty(PVDR_PROP_DOMAIN);
        if ((wchar_t*)bstrDomainName == NULL || ((wchar_t*)bstrDomainName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property Domain not found");
        }

        ft.hr = CoCreateInstance(
                        CLSID_DiskQuotaControl,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDiskQuotaControl,
                        (void **)&pIDQC);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"unable to CoCreate IDiskQuotaControl, %#x", ft.hr);

        spIDQC.Attach(pIDQC);

        ft.hr = spIDQC->Initialize(bstrVolumeName, TRUE /* read/write */);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IDiskQuotaControl::Initialize failed for volume %lS, %#x", bstrVolumeName, ft.hr);

        ft.hr = FindQuotaUser(bstrDomainName, bstrUserName, spIDQC, &spIQuotaUser);       
        if (ft.HrFailed())
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CVolumeQuotaUser::GetObject: could not find user %lS\\%lS", bstrDomainName, bstrUserName);
        }
        
        ft.hr = m_pClass->SpawnInstance(0, &spInstance);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

        LoadInstance(bstrVolumeName, spIQuotaUser, spInstance.p);

        ft.hr = pHandler->Indicate(1, &spInstance.p);            
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolume::GetObject()


void
CVolumeUserQuota:: LoadInstance(
    IN WCHAR* pwszVolume,
    IN IDiskQuotaUser* pIQuotaUser,
    IN OUT IWbemClassObject* pObject)
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathAccount;
    CObjPath pathVolume;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::LoadInstance");

    do
    {
        WCHAR wszDomain[g_cchAccountNameMax], *pwszDomain = NULL;
        WCHAR wszFQUser[g_cchAccountNameMax], *pwszUser = NULL;
        CVssAutoPWSZ awszDomain;
        DISKQUOTA_USER_INFORMATION UserQuotaInfo;
        DWORD dwStatus = 0;
        
        ft.hr = pIQuotaUser->GetName(wszDomain, g_cchAccountNameMax,
                                                         wszFQUser, g_cchAccountNameMax, NULL, 0);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaUser::GetName failed for volume %lS", pwszVolume);
            break;
        }                        

        // Win32_Account separates domain\user into two keys, Domain and Name

        // Prepare the Domain and Name keys
        pwszUser = wcschr(wszFQUser, L'\\');    // user name is domain\\name format
        if (pwszUser != NULL)
        {
            pwszDomain = wszFQUser;
            *pwszUser = L'\0';
            pwszUser++;
        }
        else
        {
            pwszDomain = wcschr(wszFQUser, L'@');  // user name is user@domain.xxx.com format
            if (pwszDomain != NULL)
            {
                pwszUser = wszFQUser;
                *pwszDomain = L'\0';
                pwszDomain++;

                WCHAR* pwc = wcschr(pwszDomain, L'.');                
                if (pwc != NULL)
                    *pwc = L'\0';
            }
            else
            {
                pwszDomain = wszDomain;
                pwszUser = wszFQUser;
            }                
        }

        // The GetName API returns BUILTIN and NT AUTHORITY
        // as the domain name for built-in local accounts.
        // BUILTIN and NT AUTHORITY accounts are represented
        // by Win32_Account and its children with the domain
        // name being the name of the machine, instead of
        // either of these strings.  We'll convert the domain name here.

        TranslateDomainName(pwszDomain, awszDomain);

        ft.hr = pIQuotaUser->GetQuotaInformation(&UserQuotaInfo, sizeof(UserQuotaInfo));
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaUser::GetQuotaInformation failed for volume %lS", pwszVolume);
            break;
        }                        
                
        // Set the Account Ref property
        pathAccount.Init(PVDR_CLASS_ACCOUNT);
        pathAccount.AddProperty(PVDR_PROP_DOMAIN, awszDomain);    
        pathAccount.AddProperty(PVDR_PROP_NAME, pwszUser);    
        wcoInstance.SetProperty((wchar_t*)pathAccount.GetObjectPathString(), PVDR_PROP_ACCOUNT);

        // Set the Volume Ref property
        pathVolume.Init(PVDR_CLASS_VOLUME);
        pathVolume.AddProperty(PVDR_PROP_DEVICEID, pwszVolume);    
        wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVDR_PROP_VOLUME);

        wcoInstance.SetPropertyI64((ULONGLONG)UserQuotaInfo.QuotaUsed, PVDR_PROP_DISKSPACEUSED);
        wcoInstance.SetPropertyI64((ULONGLONG)UserQuotaInfo.QuotaThreshold, PVDR_PROP_WARNINGLIMIT);
        wcoInstance.SetPropertyI64((ULONGLONG)UserQuotaInfo.QuotaLimit, PVDR_PROP_LIMIT);

        
        if (UserQuotaInfo.QuotaLimit == -1)
            dwStatus = 0; // OK, no limit set
        else
        {
            if (UserQuotaInfo.QuotaUsed >= UserQuotaInfo.QuotaLimit)
                dwStatus = 2;   // Limit exceeded
            else if (UserQuotaInfo.QuotaUsed >= UserQuotaInfo.QuotaThreshold)
                dwStatus = 1;   // Warning limit exceeded
            else
                dwStatus = 0;   // OK, under the warning limit
        }
        
        wcoInstance.SetProperty(dwStatus, PVDR_PROP_STATUS);
    }
    while(false);
}


HRESULT
CVolumeUserQuota::PutInstance(
        IN CWbemClassObject&  rInstToPut,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::PutInstance");

    try
    {
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrAccountRef, bstrDomainName, bstrUserName;
        CObjPath  objPathVolume;
        CObjPath  objPathAccount;
        _bstr_t bstrFQUser;
        CComPtr<IDiskQuotaUser> spIQuotaUser;
        CComPtr<IDiskQuotaControl> spIDQC;
        IDiskQuotaControl* pIDQC = NULL;
        BOOL fCreate = FALSE;
        BOOL fUpdate = FALSE;
        LONGLONG llLimit = -1, llThreshold = -1;

        // Retrieve key properties of the object to be saved.
        rInstToPut.GetProperty(bstrVolumeRef, PVDR_PROP_VOLUME);
        rInstToPut.GetProperty(bstrAccountRef, PVDR_PROP_ACCOUNT);

        // Extract the Volume, Domain and User names
        objPathVolume.Init(bstrVolumeRef);
        objPathAccount.Init(bstrAccountRef);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        if ((wchar_t*)bstrVolumeName == NULL || ((wchar_t*)bstrVolumeName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property DeviceID not found");
        }

        bstrDomainName = objPathAccount.GetStringValueForProperty(PVDR_PROP_DOMAIN);
        if ((wchar_t*)bstrDomainName == NULL || ((wchar_t*)bstrDomainName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property Domain not found");
        }

        bstrUserName = objPathAccount.GetStringValueForProperty(PVDR_PROP_NAME);
        if ((wchar_t*)bstrUserName == NULL || ((wchar_t*)bstrUserName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property Name not found");
        }

        // Retrieve writeable properties
        // If the properties are NULL it is expected that llLimit and llThreshold will retain their default values (-1)
        rInstToPut.GetPropertyI64(&llLimit, PVDR_PROP_LIMIT);
        rInstToPut.GetPropertyI64(&llThreshold, PVDR_PROP_WARNINGLIMIT);

        ft.hr = CoCreateInstance(
                        CLSID_DiskQuotaControl,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDiskQuotaControl,
                        (void **)&pIDQC);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"unable to CoCreate IDiskQuotaControl, %#x", ft.hr);

        spIDQC.Attach(pIDQC);

        ft.hr = spIDQC->Initialize(bstrVolumeName, TRUE /* read/write */);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IDiskQuotaControl::Initialize failed for volume %lS, %#x", bstrVolumeName, ft.hr);

        ft.hr = FindQuotaUserWithRecord(bstrDomainName, bstrUserName, spIDQC, &spIQuotaUser);       
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unexpected failure searching for quota account");            
        
        DWORD dwPossibleOperations = (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_ONLY);
        switch (lFlag & dwPossibleOperations)
        {
            case WBEM_FLAG_CREATE_OR_UPDATE:
            {
                if (ft.hr == S_FALSE) // account not found
                    fCreate = TRUE;
                else
                    fUpdate = TRUE;
            }
            break;
            case WBEM_FLAG_UPDATE_ONLY:
            {
                if (ft.hr == S_FALSE)
                {
                    ft.hr = WBEM_E_NOT_FOUND;
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"QuotaUser %lS\\%lS not found", bstrDomainName, bstrUserName);
                }
                fUpdate = TRUE;
            }
            break;
            case WBEM_FLAG_CREATE_ONLY:
            {
                if (ft.hr == S_FALSE) // account not found
                {
                    fCreate = TRUE;
                }
                else
                {
                    ft.hr = WBEM_E_ALREADY_EXISTS;
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota %lS/%lS already exists", bstrVolumeName, bstrFQUser);
                }
            }
            break;            
            default:
            {
                ft.hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CVolumeUserQuota::PutInstance flag not supported %d", lFlag);
            }
        }

        ft.hr = S_OK;
        
        if (fCreate)
        {
            ft.hr = Create(bstrDomainName, bstrUserName, spIDQC, &spIQuotaUser);
            if (ft.hr == S_FALSE)  // User already exists
                ft.hr = E_UNEXPECTED;  // If so we should have found it above
            else if (ft.HrFailed())
                ft.hr = WBEM_E_INVALID_PARAMETER;
        }

        if (ft.HrSucceeded() || fUpdate)
        {
            ft.hr = spIQuotaUser->SetQuotaLimit (llLimit, TRUE);
            if (ft.HrSucceeded())
                ft.hr = spIQuotaUser->SetQuotaThreshold (llThreshold, TRUE);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolumeUserQuota::PutInstance()

//  The CIMV2 provider maps BUILTIN and NT AUTHORITY domains to <local machine name>
//  so we must try each of these if AddUserName fails 
HRESULT
CVolumeUserQuota::Create(
    IN _bstr_t bstrDomainName,
    IN _bstr_t bstrUserName,
    IN IDiskQuotaControl* pIDQC,
    OUT IDiskQuotaUser** ppIQuotaUser)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::Create");
    _bstr_t bstrFQUser;
    
    bstrFQUser = bstrDomainName + _bstr_t(L"\\") + bstrUserName;
    ft.hr = pIDQC->AddUserName(
                bstrFQUser ,
                DISKQUOTA_USERNAME_RESOLVE_SYNC,
                ppIQuotaUser);
    if (ft.hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
    {
        CVssAutoPWSZ awszDomain;
        
        // Get the localized NT Authority name
        if(!GetLocalDomainName(
                SECURITY_NETWORK_SERVICE_RID,
                awszDomain))
        {
            ft.hr = E_UNEXPECTED;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get localized 'NT Authority' name");
        }
        
        bstrFQUser = _bstr_t(awszDomain) + _bstr_t(L"\\") + bstrUserName;
        ft.hr = pIDQC->AddUserName(
                    bstrFQUser ,
                    DISKQUOTA_USERNAME_RESOLVE_SYNC,
                    ppIQuotaUser);
        if (ft.hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
        {
            awszDomain.Clear();
            // Get the localized BuiltIn name and try again
            if(!GetLocalDomainName(
                    SECURITY_BUILTIN_DOMAIN_RID,
                    awszDomain))
            {
                ft.hr = E_UNEXPECTED;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get localized 'BuiltIn' name");
            }
            bstrFQUser = _bstr_t(awszDomain) + _bstr_t(L"\\") + bstrUserName;
            ft.hr = pIDQC->AddUserName(
                        bstrFQUser ,
                        DISKQUOTA_USERNAME_RESOLVE_SYNC,
                        ppIQuotaUser);
        }
    }
    
    return ft.hr;
}

HRESULT
CVolumeUserQuota::DeleteInstance(
        IN CObjPath& rObjPath,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeUserQuota::DeleteInstance");

    try
    {
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrAccountRef, bstrDomainName, bstrUserName;
        CObjPath  objPathVolume;
        CObjPath  objPathAccount;
        CComPtr<IDiskQuotaUser> spIQuotaUser;
        CComPtr<IDiskQuotaControl> spIDQC;
        IDiskQuotaControl* pIDQC = NULL;
        _bstr_t bstrFQUser;

        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_VOLUME);

        // Get the Account reference
        bstrAccountRef = rObjPath.GetStringValueForProperty(PVDR_PROP_ACCOUNT);

        // Extract the Volume and Account Names
        objPathVolume.Init(bstrVolumeRef);
        objPathAccount.Init(bstrAccountRef);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        if ((wchar_t*)bstrVolumeName == NULL || ((wchar_t*)bstrVolumeName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property DeviceID not found");
        }

        bstrUserName = objPathAccount.GetStringValueForProperty(PVDR_PROP_NAME);
        if ((wchar_t*)bstrUserName == NULL || ((wchar_t*)bstrUserName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property Name not found");
        }

        bstrDomainName = objPathAccount.GetStringValueForProperty(PVDR_PROP_DOMAIN);
        if ((wchar_t*)bstrDomainName == NULL || ((wchar_t*)bstrDomainName)[0] == L'\0')
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"VolumeUserQuota key property Domain not found");
        }

        ft.hr = CoCreateInstance(
                        CLSID_DiskQuotaControl,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDiskQuotaControl,
                        (void **)&pIDQC);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"unable to CoCreate IDiskQuotaControl, %#x", ft.hr);

        spIDQC.Attach(pIDQC);

        ft.hr = spIDQC->Initialize(bstrVolumeName, TRUE /* read/write */);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IDiskQuotaControl::Initialize failed for volume %lS, %#x", bstrVolumeName, ft.hr);

        ft.hr = FindQuotaUser(bstrDomainName, bstrUserName, spIDQC, &spIQuotaUser);       
        if (ft.HrFailed())
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CVolumeQuotaUser::DeleteInstance: could not find user %lS\\%lS", bstrDomainName, bstrUserName);
        }
        
        ft.hr = spIDQC->DeleteUser(spIQuotaUser);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;    
}


BOOL
TranslateDomainName(
    IN WCHAR* pwszDomain,
    OUT CVssAutoPWSZ& rawszDomain
    )
{
    BOOL fReturn = FALSE;
    CVssAutoPWSZ awszNtAuthorityDomain;
    CVssAutoPWSZ awszBuiltInDomain;
    CVssAutoPWSZ awszComputerName;
    DWORD cchBuf = 0;

    do
    {      
        // Get the computer name
        awszComputerName.Allocate(MAX_COMPUTERNAME_LENGTH);
        cchBuf = MAX_COMPUTERNAME_LENGTH + 1;
        fReturn = GetComputerName(awszComputerName, &cchBuf);
        if (!fReturn) break;

        // Get the localized NT Authority name
        fReturn = GetLocalDomainName(
            SECURITY_NETWORK_SERVICE_RID,  // NetworkService is a member of Nt Authority domain
            awszNtAuthorityDomain);
        if (!fReturn) break;

        // Get the localized BUILTIN name
        fReturn = GetLocalDomainName(
            SECURITY_BUILTIN_DOMAIN_RID,
            awszBuiltInDomain);
        if (!fReturn) break;

        // Replace either of these domain names with the NetBIOS computer name
        if (lstrcmpi(pwszDomain, awszNtAuthorityDomain) == 0 ||
             lstrcmpi(pwszDomain, awszBuiltInDomain) == 0)
            rawszDomain.TransferFrom(awszComputerName);
        else
            rawszDomain.CopyFrom(pwszDomain);
    }
    while(false);

    return fReturn;

}

BOOL
GetLocalDomainName(
    IN DWORD dwWellKnownAuthority,
    OUT CVssAutoPWSZ& rawszDomain
    )
{
    BOOL fReturn = FALSE;
    PSID pSID = NULL;
    SID_NAME_USE snUse = SidTypeUnknown;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    CVssAutoPWSZ awszAccount;
    DWORD cchDomainName = 0;
    DWORD cchAccount = 0;

    do
    {
        // Allocate the SID for the given well known Authority
        fReturn = AllocateAndInitializeSid(
            &sidAuth,
            1,
            dwWellKnownAuthority,0,0,0,0,0,0,0,
            &pSID);
        if (!fReturn) break;
            
        // How long is the domain name?
        fReturn = LookupAccountSid(
            NULL, // computer name defaults to local
            pSID,
            NULL, // account name
            &cchAccount,      // account name len
            NULL,   // domain name
            &cchDomainName,
            &snUse);
        if (!fReturn && GetLastError() != ERROR_INSUFFICIENT_BUFFER) break;

        // Allocate the space
        rawszDomain.Allocate(cchDomainName); // allocates the term null too
        awszAccount.Allocate(cchAccount); // allocates the term null too

        // Get the domain name now
        fReturn = LookupAccountSid(
            NULL, // computer name defaults to local
            pSID,
            awszAccount, // account name
            &cchAccount,      // account name len
            rawszDomain,   // domain name
            &cchDomainName,
            &snUse);        
   }
    while(false);

    if (pSID)
        FreeSid(pSID);
    
    return fReturn;
}

HRESULT FindQuotaUserFromEnum(
    WCHAR* pwszUser,
    IDiskQuotaControl* pIDQC,
    IDiskQuotaUser** ppQuotaUser)
{
    WCHAR logonName[MAX_PATH+1];
    CComPtr<IEnumDiskQuotaUsers> spUserEnum;

    _ASSERTE(ppQuotaUser != NULL);
    *ppQuotaUser = NULL;

    HRESULT hr = pIDQC->CreateEnumUsers(0,0,DISKQUOTA_USERNAME_RESOLVE_SYNC, &spUserEnum);
    if (FAILED(hr))
        return hr;

    while((hr = spUserEnum->Next(1, ppQuotaUser, 0)) == NOERROR)
    {
        if (SUCCEEDED((*ppQuotaUser)->GetName( 0, 0, logonName, MAX_PATH, 0, 0))
            && _wcsicmp(logonName, pwszUser) == 0) return S_OK;
        (*ppQuotaUser)->Release();
        *ppQuotaUser = NULL;
    };

    return hr;
};

HRESULT FindQuotaUserWithRecord(
    IN _bstr_t bstrDomainName,
    IN _bstr_t bstrUserName,
    IN IDiskQuotaControl* pIDQC,
    OUT IDiskQuotaUser** ppIQuotaUser)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"FindQuotaUserWithRecord");
    _bstr_t bstrFQUser;
    
    bstrFQUser = bstrDomainName + _bstr_t(L"\\") + bstrUserName;
    // Look for the account name as-is
    ft.hr = FindQuotaUserFromEnum(bstrFQUser, pIDQC, ppIQuotaUser);
    if (ft.hr == S_FALSE)
    {
        CVssAutoPWSZ awszDomain;
        
        // Get the localized NT Authority name and try again
        if(!GetLocalDomainName(
                SECURITY_NETWORK_SERVICE_RID,
                awszDomain))
        {
            ft.hr = E_UNEXPECTED;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get localized 'NT Authority' name");
        }
        
        bstrFQUser = _bstr_t(awszDomain) + _bstr_t(L"\\") + bstrUserName;
        ft.hr = FindQuotaUserFromEnum(bstrFQUser, pIDQC, ppIQuotaUser);
        if (ft.hr == S_FALSE)
        {
            awszDomain.Clear();
            // Get the localized BuiltIn name and try again
            if(!GetLocalDomainName(
                    SECURITY_BUILTIN_DOMAIN_RID,
                    awszDomain))
            {
                ft.hr = E_UNEXPECTED;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get localized 'BuiltIn' name");
            }
            bstrFQUser = _bstr_t(awszDomain) + _bstr_t(L"\\") + bstrUserName;
            ft.hr = FindQuotaUserFromEnum(bstrFQUser, pIDQC, ppIQuotaUser);
        }
    }

    return ft.hr;
}

HRESULT FindQuotaUser(
    IN _bstr_t bstrDomainName,
    IN _bstr_t bstrUserName,
    IN IDiskQuotaControl* pIDQC,
    OUT IDiskQuotaUser** ppIQuotaUser)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"FindQuotaUser");
    _bstr_t bstrFQUser;
    
    bstrFQUser = bstrDomainName + _bstr_t(L"\\") + bstrUserName;
    ft.hr = pIDQC->FindUserName(bstrFQUser, ppIQuotaUser);
    if (ft.HrFailed())
    {
        CVssAutoPWSZ awszDomain;
        
        // Get the localized NT Authority name
        if(!GetLocalDomainName(
                SECURITY_NETWORK_SERVICE_RID,
                awszDomain))
        {
            ft.hr = E_UNEXPECTED;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get localized 'NT Authority' name");
        }
        
        bstrFQUser = _bstr_t(awszDomain) + _bstr_t(L"\\") + bstrUserName;
        ft.hr = pIDQC->FindUserName(bstrFQUser, ppIQuotaUser);
        if (ft.HrFailed())
        {
            awszDomain.Clear();
            if(!GetLocalDomainName(
                    SECURITY_BUILTIN_DOMAIN_RID,
                    awszDomain))
            {
                ft.hr = E_UNEXPECTED;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get localized 'BuiltIn' name");
            }
            bstrFQUser = _bstr_t(awszDomain) + _bstr_t(L"\\") + bstrUserName;
            ft.hr = pIDQC->FindUserName(bstrFQUser, ppIQuotaUser);
        }
    }

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\vdsclasses.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name: VdsClasses.cpp
//
//  Description:    
//      Implementation of VDS WMI Provider classes 
//
//  Author:   Jim Benton (jbenton) 15-Jan-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <winioctl.h>
#include <fmifs.h>
#include "VdsClasses.h"
#include "ichannel.hxx"
#include <ntddvol.h>

#define INITGUIDS
#include <initguid.h>
#include <dfrgifc.h>
#include <dskquota.h>

#include "volutil.h"
#include "cmdproc.h"

// Chkdsk and Format use callbacks which require us to track some data per thread
// These help define the per thread data channel
CRITICAL_SECTION g_csThreadData;
typedef std::map < DWORD, void* > ThreadDataMap;
static ThreadDataMap g_ThreadDataMap;

typedef struct _CHKDSK_THREAD_DATA
{
    BOOL fOkToRunAtBootup;
    DWORD rcStatus;
} CHKDSK_THREAD_DATA, *PCHKDSK_THREAD_DATA;

void
LoadDefragAnalysis(
    IN DEFRAG_REPORT* pDefragReport,
    IN OUT IWbemClassObject* pObject);

void
TranslateDefragError(
    IN HRESULT hr,
    OUT DWORD* pdwError);


void
SetThreadData(
    IN DWORD dwThreadID,
    IN void* pThreadData)
{
    EnterCriticalSection(&g_csThreadData);
    g_ThreadDataMap[dwThreadID] = pThreadData;
    LeaveCriticalSection(&g_csThreadData);
}

void*
GetThreadData(
    IN DWORD dwThreadID)
{
    void* pThreadData = 0;

    EnterCriticalSection(&g_csThreadData);
    pThreadData = g_ThreadDataMap[dwThreadID];
    LeaveCriticalSection(&g_csThreadData);
    
    return pThreadData;
}

void
RemoveThreadData(
    IN DWORD dwThreadID)
{
    EnterCriticalSection(&g_csThreadData);
    g_ThreadDataMap.erase(dwThreadID);
    LeaveCriticalSection(&g_csThreadData);
}

BOOLEAN ChkdskCallback( 
    FMIFS_PACKET_TYPE PacketType, 
    ULONG    PacketLength,
    PVOID    PacketData
)
{
    BOOL fFailed = FALSE;
    DWORD dwThreadID = GetCurrentThreadId();
    CHKDSK_THREAD_DATA* pThreadData =  (CHKDSK_THREAD_DATA*) GetThreadData(dwThreadID);

    _ASSERTE(pThreadData);

    switch (PacketType)
    {    
    case FmIfsTextMessage :
        FMIFS_TEXT_MESSAGE *MessageText;

        MessageText =  (FMIFS_TEXT_MESSAGE*) PacketData;

        break;

    case FmIfsFinished: 
        FMIFS_FINISHED_INFORMATION *Finish;
        Finish = (FMIFS_FINISHED_INFORMATION*) PacketData;
        if ( Finish->Success )
        {
            pThreadData->rcStatus =  CHKDSK_RC_NO_ERROR;
        }
        else
        {
            if (pThreadData->rcStatus != CHKDSK_RC_VOLUME_LOCKED)
            {
                pThreadData->rcStatus =  CHKDSK_RC_UNEXPECTED;
            }
        }
        break;

    case FmIfsCheckOnReboot:
        FMIFS_CHECKONREBOOT_INFORMATION *RebootResult;
        
        pThreadData->rcStatus =  CHKDSK_RC_VOLUME_LOCKED;
        RebootResult = (FMIFS_CHECKONREBOOT_INFORMATION *) PacketData;

        if (pThreadData->fOkToRunAtBootup)
            RebootResult->QueryResult = 1;
        else
            RebootResult->QueryResult = 1;
        break;
        
    // although following are the additional message types, callback routine never gets these messages
    // hence the detailed code for each of these return type is not written.
/*
    case FmIfsIncompatibleFileSystem:
        break;

    case FmIfsAccessDenied:
        break;

    case FmIfsBadLabel:
        break;

    case FmIfsHiddenStatus:
        break;

    case FmIfsClusterSizeTooSmall:
        break;

    case FmIfsClusterSizeTooBig:
        break;

    case FmIfsVolumeTooSmall:
        break;

    case FmIfsVolumeTooBig:
        break;

    case FmIfsNoMediaInDevice:
        break;

    case FmIfsClustersCountBeyond32bits:
        break;

    case FmIfsIoError:
        FMIFS_IO_ERROR_INFORMATION *IoErrorInfo;
        IoErrorInfo = ( FMIFS_IO_ERROR_INFORMATION * ) PacketData;
        break;

    case FmIfsMediaWriteProtected:
        break;

    case FmIfsIncompatibleMedia:
        break;

    case FmIfsInsertDisk:
        FMIFS_INSERT_DISK_INFORMATION *InsertDiskInfo;
        InsertDiskInfo = ( FMIFS_INSERT_DISK_INFORMATION *) PacketData;
        unRetVal = 1;
        break;
*/

    }

    return (BOOLEAN) (fFailed == FALSE);
}

//****************************************************************************
//
//  CVolume
//
//****************************************************************************

CVolume::CVolume( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CVolume::CVolume()

CProvBase *
CVolume::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CVolume * pObj = NULL;

    pObj = new CVolume(pwszName, pNamespace);

    if (pObj)
    {
        hr = pObj->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pObj;
        pObj = NULL;
    }
    return pObj;

} //*** CVolume::S_CreateThis()


HRESULT
CVolume::Initialize()
{
    DWORD cchBufLen = MAX_COMPUTERNAME_LENGTH;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Initialize");    
    return ft.hr;
}

HRESULT
CVolume::EnumInstance( 
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink *    pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::EnumInstance");
    CVssAutoPWSZ awszVolume;
        
    try
    {
        awszVolume.Allocate(MAX_PATH);

        CVssVolumeIterator volumeIterator;

        while (true)
        {
            CComPtr<IWbemClassObject> spInstance;

            // Get the volume name
            if (!volumeIterator.SelectNewVolume(ft, awszVolume, MAX_PATH))
                break;

            if (VolumeIsValid(awszVolume))
            {
                ft.hr = m_pClass->SpawnInstance(0, &spInstance);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(awszVolume, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolume::EnumInstance()

HRESULT
CVolume::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::GetObject");

    try
    {
        CComPtr<IWbemClassObject> spInstance;
        _bstr_t bstrID;

        // Get the Volume GUID name
        bstrID = rObjPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrID, WBEM_E_INVALID_OBJECT_PATH, L"CVolume::GetObject: volume key property not found")

        ft.hr = m_pClass->SpawnInstance(0, &spInstance);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

        if (VolumeIsValid((WCHAR*)bstrID))
        {
            LoadInstance((WCHAR*)bstrID, spInstance.p);            
            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
        else
        {
            ft.hr = WBEM_E_NOT_SUPPORTED;
            ft.Trace(VSSDBG_VSSADMIN, L"Unsupported volume GUID, hr<%lS>", (WCHAR*)bstrID); 
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolume::GetObject()

void
CVolume:: LoadInstance(
    IN WCHAR* pwszVolume,
    IN OUT IWbemClassObject* pObject)
{
    WCHAR wszDriveLetter[g_cchDriveName];
    DWORD cchBuf= MAX_COMPUTERNAME_LENGTH;
    WCHAR wszPath[MAX_PATH+1] ;
    CVssAutoPWSZ awszVolume;
    CVssAutoPWSZ awszComputerName;
    CComPtr<IDiskQuotaControl> spIDQC;
    IDiskQuotaControl* pIDQC = NULL;
    
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::LoadInstance");

    _ASSERTE(pwszVolume != NULL);
    _ASSERTE(pObject != NULL);
    
    CWbemClassObject wcoInstance(pObject);
    awszVolume.Allocate(MAX_PATH);

    // Set the volume GUID name key property
    wcoInstance.SetProperty(pwszVolume, PVDR_PROP_DEVICEID);

    // Get the computer name
    awszComputerName.Allocate(MAX_COMPUTERNAME_LENGTH);
    if (!GetComputerName(awszComputerName, &cchBuf))
    {
        ft.Trace(VSSDBG_VSSADMIN, L"GetComputerName failed %#x", GetLastError());
    }
    else
    {
        wcoInstance.SetProperty(awszComputerName, PVDR_PROP_SYSTEMNAME);
    }

    VssGetVolumeDisplayName(
        pwszVolume,
        wszPath,
        MAX_PATH);
    
    wcoInstance.SetProperty(wszPath, PVDR_PROP_NAME);
    wcoInstance.SetProperty(wszPath, PVDR_PROP_CAPTION);    

    // Don't populate the remaining properties if the volume is tagged no-automount
    if (!VolumeIsMountable(pwszVolume))
    {        
        wcoInstance.SetProperty((DWORD)false, PVDR_PROP_MOUNTABLE);
    }
    else
    {
        DWORD dwSerialNumber = 0;
        DWORD cchMaxFileNameLen = 0;
        DWORD dwFileSystemFlags = 0;
        DWORD cSectorsPerCluster = 0;        
        DWORD cBytesPerSector = 0;
        DWORD cDontCare = 0;
        ULARGE_INTEGER cbCapacity = {0, 0};
        ULARGE_INTEGER cbFreeSpace = {0, 0};
        ULARGE_INTEGER cbUserFreeSpace = {0, 0};
        DWORD dwAttributes = 0;
        WCHAR wszLabel[g_cchVolumeLabelMax+1];
        WCHAR wszFileSystem[g_cchFileSystemNameMax+1];

        wcoInstance.SetProperty((bool)true, PVDR_PROP_MOUNTABLE);

        // Set DriveType property
        wcoInstance.SetProperty(GetDriveType(pwszVolume), PVDR_PROP_DRIVETYPE);
        
        // Set DriveLetter property
        cchBuf = g_cchDriveName;
        if (GetVolumeDrive(
                pwszVolume, 
                cchBuf,
                wszDriveLetter))
        {
            wszDriveLetter[wcslen(wszDriveLetter) - 1] = L'\0';        // Remove the trailing '\'
            wcoInstance.SetProperty(wszDriveLetter, PVDR_PROP_DRIVELETTER);
        }

        // Skip remaining properties for drives without media
        if (VolumeIsReady(pwszVolume))
        {
            BOOL fDirty = FALSE;
            if (VolumeIsDirty(pwszVolume, &fDirty) == ERROR_SUCCESS)
                wcoInstance.SetProperty(fDirty, PVDR_PROP_DIRTYBITSET);

            // Set BlockSize property
            if (!GetDiskFreeSpace(
                pwszVolume,
                &cSectorsPerCluster,
                &cBytesPerSector,
                &cDontCare,     // total bytes
                &cDontCare))    // total free bytes
            {
                ft.Trace(VSSDBG_VSSADMIN, L"GetDiskFreeSpace failed for volume %lS, %#x", pwszVolume, GetLastError());
            }
            else
            {
                ULONGLONG cbBytesPerCluster = cBytesPerSector * cSectorsPerCluster;
                wcoInstance.SetPropertyI64(cbBytesPerCluster, PVDR_PROP_BLOCKSIZE);
            }
            
            // Set Label, FileSystem, SerialNumber, MaxFileNameLen, 
            // SupportsCompression, Compressed, SupportsQuotas properties
            if (!GetVolumeInformation(
                pwszVolume,
                wszLabel,
                g_cchVolumeLabelMax,
                &dwSerialNumber,
                &cchMaxFileNameLen,
                &dwFileSystemFlags,
                wszFileSystem,
                g_cchFileSystemNameMax))
            {
                ft.Trace(VSSDBG_VSSADMIN, L"GetVolumeInformation failed for volume %lS, %#x", pwszVolume, GetLastError());
            }
            else
            {
                if (wszLabel[0] != L'\0')
                    wcoInstance.SetProperty(wszLabel, PVDR_PROP_LABEL);
                wcoInstance.SetProperty(wszFileSystem, PVDR_PROP_FILESYSTEM);
                wcoInstance.SetProperty(dwSerialNumber, PVDR_PROP_SERIALNUMBER);
                wcoInstance.SetProperty(cchMaxFileNameLen, PVDR_PROP_MAXIMUMFILENAMELENGTH);
                wcoInstance.SetProperty(dwFileSystemFlags & FS_VOL_IS_COMPRESSED, PVDR_PROP_COMPRESSED);
                wcoInstance.SetProperty(dwFileSystemFlags & FILE_VOLUME_QUOTAS, PVDR_PROP_SUPPORTSDISKQUOTAS);
                wcoInstance.SetProperty(dwFileSystemFlags & FS_FILE_COMPRESSION, PVDR_PROP_SUPPORTSFILEBASEDCOMPRESSION);
            }

            if (!GetDiskFreeSpaceEx(
                pwszVolume,
                &cbUserFreeSpace,
                &cbCapacity,
                &cbFreeSpace))
            {
                ft.Trace(VSSDBG_VSSADMIN, L"GetDiskFreeSpace failed for volume, %lS", pwszVolume);
            }
            {
                ULONGLONG llTmp = 0;
                llTmp = cbCapacity.QuadPart;        
                wcoInstance.SetPropertyI64(llTmp, PVDR_PROP_CAPACITY);
                llTmp = cbFreeSpace.QuadPart;        
                wcoInstance.SetPropertyI64(llTmp, PVDR_PROP_FREESPACE);
            }

            if (_wcsicmp(wszFileSystem, L"NTFS") == 0)
            {
                dwAttributes = GetFileAttributes(pwszVolume);
                if (dwAttributes == INVALID_FILE_ATTRIBUTES)
                {
                    ft.Trace(VSSDBG_VSSADMIN, L"GetFileAttributes failed for volume %lS, %#x", pwszVolume, GetLastError());
                }
                else
                {
                    BOOL fIndexingEnabled = !(dwAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);
                    wcoInstance.SetProperty(fIndexingEnabled, PVDR_PROP_INDEXINGENABLED);
                }
            }

            ft.hr = CoCreateInstance(
                    CLSID_DiskQuotaControl,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IDiskQuotaControl,
                    (void **)&pIDQC);
            if (ft.HrFailed())
            {
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"unable to CoCreate IDiskQuotaControl");
            }

            spIDQC.Attach(pIDQC);

            ft.hr = spIDQC->Initialize(pwszVolume, FALSE /* read only */);
            if (ft.HrFailed())
            {
                ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaControl::Initialize failed for volume %lS", pwszVolume);
            }        
            else
            {
                DWORD dwState = 0;
                ft.hr = spIDQC->GetQuotaState(&dwState);
                if (ft.HrSucceeded())
                {
                    wcoInstance.SetProperty(!(DISKQUOTA_IS_DISABLED(dwState)), PVDR_PROP_QUOTASENABLED);
                    wcoInstance.SetProperty(DISKQUOTA_FILE_INCOMPLETE(dwState), PVDR_PROP_QUOTASINCOMPLETE);
                    wcoInstance.SetProperty(DISKQUOTA_FILE_REBUILDING(dwState), PVDR_PROP_QUOTASREBUILDING);
                }
            }
        }
    }
}

HRESULT
CVolume::PutInstance(
        IN CWbemClassObject&  rInstToPut,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::PutInstance");

    try
    {
        _bstr_t bstrVolume;
        _bstr_t bstrDriveLetter;
        _bstr_t bstrLabel;
        BOOL fIndexingEnabled = FALSE;
        WCHAR* pwszVolume = NULL;

        if ( lFlag & WBEM_FLAG_CREATE_ONLY )
        {
            return WBEM_E_UNSUPPORTED_PARAMETER ;
        }
        
        // Retrieve key properties of the object to be saved.
        rInstToPut.GetProperty(bstrVolume, PVDR_PROP_DEVICEID);
        if ((WCHAR*)bstrVolume == NULL)
        {
            ft.hr = WBEM_E_INVALID_OBJECT;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CVolume::PutInstance: NULL volume name");
        }

        pwszVolume = (wchar_t*)bstrVolume;
        
        if (VolumeIsValid(pwszVolume) && VolumeIsMountable(pwszVolume))
        {
            // Retrieve writeable properties of the object to be saved.
            rInstToPut.GetProperty(bstrDriveLetter, PVDR_PROP_DRIVELETTER);
            rInstToPut.GetProperty(bstrLabel, PVDR_PROP_LABEL);
            rInstToPut.GetProperty(&fIndexingEnabled, PVDR_PROP_INDEXINGENABLED);
            
            SetLabel(pwszVolume, bstrLabel);

            if (!rInstToPut.IsPropertyNull(PVDR_PROP_INDEXINGENABLED))
                SetContentIndexing(pwszVolume, fIndexingEnabled);

            SetDriveLetter(pwszVolume, bstrDriveLetter);
        }        
        else
        {
            ft.hr = WBEM_E_NOT_SUPPORTED;
            ft.Trace(VSSDBG_VSSADMIN, L"Attempt to modify an unsupported or unmountedable volume, %lS", pwszVolume);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CStorage::PutInstance()

void
CVolume::SetDriveLetter(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDrive
    )
{
    WCHAR wszCurrentDrivePath[g_cchDriveName+1];
    BOOL fFoundDrive = FALSE;
    BOOL fDeleteDrive = FALSE;
    BOOL fAssignDrive = FALSE;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::SetDriveLetter");

    _ASSERTE(pwszVolume != NULL)

    // Validate drive letter
    if (pwszDrive != NULL)
    {
        ft.hr = WBEM_E_INVALID_PARAMETER;
        
        if (wcslen(pwszDrive) == 2)
        {
            WCHAR wc = towupper(pwszDrive[0]);

            if (wc >= L'A' && wc <= L'Z' && pwszDrive[1] == L':')
                ft.hr = S_OK;
        }
        
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetDriveLetter: invalid drive letter, %lS", pwszDrive);
    }

    // Get the current drive letter if any
    fFoundDrive = GetVolumeDrive(
                                    pwszVolume, 
                                    g_cchDriveName,
                                    wszCurrentDrivePath);

    if (fFoundDrive)
    {
        if (wszCurrentDrivePath[wcslen(wszCurrentDrivePath) - 1] != L'\\')
        {
            ft.hr = E_UNEXPECTED;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetDriveLetter: unexpected drive letter format from GetVolumeDrivePath, %lS", wszCurrentDrivePath);
        }
    }
    
    if (pwszDrive == NULL && fFoundDrive == FALSE)
    {
        // Do nothing, drive letter already deleted
    }
    else if (pwszDrive == NULL && fFoundDrive == TRUE)
    {
        // Delete drive letter
        fDeleteDrive = TRUE;
    }
    else if (pwszDrive != NULL && fFoundDrive == FALSE)
    {
        // No drive letter currently assigned, assign drive letter
        fAssignDrive = TRUE;
    }
    else if (_wcsnicmp(pwszDrive, wszCurrentDrivePath, 2) != 0)
    {
        // Requested drive letter is different than currently assigned
        // Delete current drive letter
        fDeleteDrive = TRUE;
        // Assign new drive letter
        fAssignDrive = TRUE;
    }
    else
    {
        // Do nothing, drive letter not changing
    }

    if (fAssignDrive)
    {
        // Verify that the target drive letter is available
        // A race condition exists here since the drive letter may be stolen 
        // after this verification and before the actual assignment
        if (!IsDriveLetterAvailable(pwszDrive))
        {
            if (IsDriveLetterSticky(pwszDrive))
            {
                ft.hr = VDSWMI_E_DRIVELETTER_IN_USE;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"drive letter is assigned to another volume");
            }
            else
            {                
                ft.hr = VDSWMI_E_DRIVELETTER_UNAVAIL;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"drive letter is unavailable until reboot");
            }
        }
    }
    
    if (fDeleteDrive)
    {
        if (!IsBootDrive(wszCurrentDrivePath) && 
            !VolumeIsSystem(pwszVolume) &&
            !VolumeHoldsPagefile(pwszVolume))
        {
            // Try to lock the volume and delete the mountpoint.
            // If the volume can't be locked, remove the drive letter from the 
            // volume mgr database only
            // Remove any network shares for this drive letter??
            DeleteVolumeDriveLetter(pwszVolume, wszCurrentDrivePath);
        }
        else
        {
            ft.hr = VDSWMI_E_DRIVELETTER_CANT_DELETE;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Drive letter deletion is blocked for this volume %lS", pwszVolume);
        }
    }

    if (fAssignDrive)
    {
        // No attempt will be made to roll back a previously deleted drive letter
        // if this assignment fails

        // SetVolumeMountPoint API requires trailing backslash
        WCHAR wszDrivePath[g_cchDriveName], *pwszDrivePath = wszDrivePath;
        ft.hr = StringCchPrintf(wszDrivePath, g_cchDriveName, L"%s\\", pwszDrive);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"StringCchPrintf failed %#x", ft.hr);
        
        if (!SetVolumeMountPoint(wszDrivePath, pwszVolume))
        {
             ft.hr = HRESULT_FROM_WIN32(GetLastError());
             ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetVolumeMountPoint failed, volume<%lS> drivePath<%lS>", pwszVolume, wszDrivePath);
        }
    }
}

void
CVolume::SetLabel(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszLabel
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::SetLabel");

    _ASSERTE(pwszVolume != NULL);
    
     if (!SetVolumeLabel(pwszVolume, pwszLabel))
     {
         ft.hr = HRESULT_FROM_WIN32(GetLastError());
         ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetVolumeLabel failed, volume<%lS> label<%lS>", pwszVolume, pwszLabel);
     }
}

void
CVolume::SetContentIndexing(
    IN WCHAR* pwszVolume,
    IN BOOL fIndexingEnabled
    )
{
    DWORD dwAttributes;
    
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::SetContentIndexing");
    
    // Get the file attributes which include the content indexing flag
    dwAttributes = GetFileAttributes(pwszVolume);
    if (dwAttributes == INVALID_FILE_ATTRIBUTES)
    {
         ft.hr = HRESULT_FROM_WIN32(GetLastError());
         ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GetFileAttributes failed, volume<%lS>", pwszVolume);
    }
    
    // Set the indexing flag
    if (fIndexingEnabled)
    {
        // Turn indexing on
        dwAttributes &= ~FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    }
    else
    {
        // Turn indexing off
        dwAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    }
    if (!SetFileAttributes(pwszVolume, dwAttributes))
    {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetFileAttributes failed, volume<%lS>", pwszVolume);
    }    
}

HRESULT
CVolume::ExecuteMethod(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecuteMethod");
    
    try
    {
        if (!_wcsicmp(pwszMethodName, PVDR_MTHD_ADDMOUNTPOINT))
        {
            ft.hr = ExecAddMountPoint(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_MOUNT))
        {
            ft.hr = ExecMount(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_DISMOUNT))
        {
            ft.hr = ExecDismount(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_DEFRAG))
        {
            ft.hr = ExecDefrag(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_DEFRAGANALYSIS))
        {
            ft.hr = ExecDefragAnalysis(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_CHKDSK))
        {
            ft.hr = ExecChkdsk(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_SCHEDULECHK))
        {
            ft.hr = ExecScheduleAutoChk(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_EXCLUDECHK))
        {
            ft.hr = ExecExcludeAutoChk(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else if (!_wcsicmp(pwszMethodName, PVDR_MTHD_FORMAT))
        {
            ft.hr = ExecFormat(
                            bstrObjPath,
                            pwszMethodName,
                            lFlag,
                            pParams,
                            pHandler);
        }
        else
        {
            ft.hr = WBEM_E_INVALID_METHOD;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Invalid method called, %lS, hr<%#x>", pwszMethodName, ft.hr);            
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }
    
    return ft.hr;

}

HRESULT
CVolume::ExecAddMountPoint(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecAddMountPoint");
    
    CComPtr<IWbemClassObject> spOutParamClass;
    _bstr_t bstrDirectory;
    _bstr_t bstrVolume;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;

    
    if (pParams == NULL)
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::AddMountPoint called with no parameters, hr<%#x>", ft.hr);
    }

    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecAddMountPoint: volume key property not found")
    
    CWbemClassObject wcoInParam(pParams);
    CWbemClassObject wcoOutParam;
    
    if (wcoInParam.data() == NULL)
    {
        ft.hr = E_OUTOFMEMORY;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::AddMountPoint: out of memory, hr<%#x>", ft.hr);
    }
    
    // Gets the Directory name - input param
    wcoInParam.GetProperty(bstrDirectory, PVDR_PROP_DIRECTORY);
    IF_WSTR_NULL_THROW(bstrDirectory, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecAddMountPoint: Directory param is NULL")
    WCHAR* pwszDirectory = bstrDirectory;
    
    if (pwszDirectory[wcslen(pwszDirectory) - 1] != L'\\')
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Invalid mount point directory, %lS, hr<%#x>", pwszDirectory, ft.hr);
    }

    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_ADDMOUNTPOINT),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"AddMountPoint GetMethod failed, hr<%#x>", ft.hr);

    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

    rcStatus = AddMountPoint(bstrVolume, bstrDirectory);

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );

    return ft.hr;
}

HRESULT
CVolume::ExecMount(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecMount");
    CComPtr<IWbemClassObject> spOutParamClass;
    _bstr_t bstrVolume;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;

    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecMount: volume key property not found")
    
    CWbemClassObject wcoOutParam;
    
    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_MOUNT),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Mount GetMethod failed, hr<%#x>", ft.hr);

    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

    rcStatus = Mount(bstrVolume);

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    
    return ft.hr;
}

HRESULT
CVolume::ExecDismount(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecDismount");
    CComPtr<IWbemClassObject> spOutParamClass;
    _bstr_t bstrVolume;
    BOOL fForce = FALSE;
    BOOL fPermanent = FALSE;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;

    if (pParams == NULL)
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::Dismount called with no parameters, hr<%#x>", ft.hr);
    }

    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecDismount: volume key property not found")
    
    CWbemClassObject wcoInParam(pParams);
    CWbemClassObject wcoOutParam;
    
    if (wcoInParam.data() == NULL)
    {
        ft.hr = E_OUTOFMEMORY;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::Dismount out of memory, hr<%#x>", ft.hr);
    }
    
    // Get the Force flag
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_FORCE, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecDismount: Force param is NULL")
    wcoInParam.GetProperty(&fForce, PVDR_PROP_FORCE);

    // Get the Permanent flag
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_PERMANENT, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecDismount: Permanent param is NULL")
    wcoInParam.GetProperty(&fPermanent, PVDR_PROP_PERMANENT);

    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_DISMOUNT),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Dismount GetMethod failed, hr<%#x>", ft.hr);

    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

    rcStatus = Dismount(bstrVolume, fForce, fPermanent);

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    
    return ft.hr;
}

HRESULT
CVolume::ExecDefrag(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecDefrag");
    CComPtr<IWbemClassObject> spOutParamClass;
    CComPtr<IWbemClassObject> spObjReport;
    _bstr_t bstrVolume;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;
    BOOL fForce = FALSE;    

    if (pParams == NULL)
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::Defrag called with no parameters, hr<%#x>", ft.hr);
    }

    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecDefrag: volume key property not found")
    
    CWbemClassObject wcoInParam(pParams);
    CWbemClassObject wcoOutParam;            
    
    // Get the force flag
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_FORCE, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecDefrag: Force param is NULL")
    wcoInParam.GetProperty(&fForce, PVDR_PROP_FORCE);
    
    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_DEFRAG),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Defrag GetMethod failed, hr<%#x>", ft.hr);

    // Create an out param object
    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

    // Create a defrag analysis report object
    ft.hr = m_pNamespace->GetObject(
                                            _bstr_t(PVDR_CLASS_DEFRAGANALYSIS),
                                            0,
                                            0,
                                            &spObjReport,
                                            NULL);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DefragAnalysis object creation failed, hr<%#x>", ft.hr);
    
    rcStatus = Defrag(bstrVolume, fForce, pHandler, spObjReport);

    ft.hr = wcoOutParam.SetProperty(spObjReport, PVDR_PROP_DEFRAGANALYSIS);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    
    return ft.hr;
}

HRESULT
CVolume::ExecDefragAnalysis(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecDefragAnalysis");
    CComPtr<IWbemClassObject> spOutParamClass;
    CComPtr<IWbemClassObject> spObjReport;
    _bstr_t bstrVolume;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;
    BOOL fDefragRecommended = FALSE;
    

    // The DefragAnalysis method has no input parameters
    
    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecDefragAnalysis: volume key property not found")
    
    CWbemClassObject wcoOutParam;
    
    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_DEFRAGANALYSIS),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DefragAnalysis GetMethod failed, hr<%#x>", ft.hr);

    // Create an out param object
    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

    // Create a defrag analysis report object
    ft.hr = m_pNamespace->GetObject(
                                            _bstr_t(PVDR_CLASS_DEFRAGANALYSIS),
                                            0,
                                            0,
                                            &spObjReport,
                                            NULL);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DefragAnalysis object creation failed, hr<%#x>", ft.hr);
    
    rcStatus = DefragAnalysis(bstrVolume, &fDefragRecommended, spObjReport);

    ft.hr = wcoOutParam.SetProperty(fDefragRecommended, PVDR_PROP_DEFRAGRECOMMENDED);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);

    ft.hr = wcoOutParam.SetProperty(spObjReport, PVDR_PROP_DEFRAGANALYSIS);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    
    return ft.hr;
}

HRESULT
CVolume::ExecChkdsk(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Chkdsk");
    CComPtr<IWbemClassObject> spOutParamClass;
    _bstr_t bstrVolume;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;
    BOOL fFixErrors = FALSE;
    BOOL fVigorousIndexCheck = FALSE;
    BOOL fSkipFolderCycle = FALSE;
    BOOL fForceDismount = FALSE;
    BOOL fRecoverBadSectors = FALSE;
    BOOL fOkToRunAtBootup = FALSE;
    
    if (pParams == NULL)
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::Chkdsk called with no parameters, hr<%#x>", ft.hr);
    }

    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecChkdsk: volume key property not found")
    
    CWbemClassObject wcoInParam(pParams);
    CWbemClassObject wcoOutParam;            
    
    // Check the params
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_FIXERRORS, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecChkdsk: FixErrors param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_VIGOROUSINDEXCHECK, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecChkdsk: VigorousCheck param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_SKIPFOLDERCYCLE, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecChkdsk: SkipFolderCycle param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_FORCEDISMOUNT, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecChkdsk: ForceDismount param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_RECOVERBADSECTORS, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecChkdsk: RecoverBadSectors param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_OKTORUNATBOOTUP, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecChkdsk: OkToRunAtBootUp param is NULL")
    
    // Get the params
    wcoInParam.GetProperty(&fFixErrors, PVDR_PROP_FIXERRORS);
    wcoInParam.GetProperty(&fVigorousIndexCheck, PVDR_PROP_VIGOROUSINDEXCHECK);
    wcoInParam.GetProperty(&fSkipFolderCycle, PVDR_PROP_SKIPFOLDERCYCLE);
    wcoInParam.GetProperty(&fForceDismount, PVDR_PROP_FORCEDISMOUNT);
    wcoInParam.GetProperty(&fRecoverBadSectors, PVDR_PROP_RECOVERBADSECTORS);
    wcoInParam.GetProperty(&fOkToRunAtBootup, PVDR_PROP_OKTORUNATBOOTUP);
    
    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_CHKDSK),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Chkdsk GetMethod failed, hr<%#x>", ft.hr);

    // Create an out param object
    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);
    
    rcStatus = Chkdsk(
                            bstrVolume, 
                            fFixErrors,
                            fVigorousIndexCheck,
                            fSkipFolderCycle,
                            fForceDismount,
                            fRecoverBadSectors,
                            fOkToRunAtBootup
                            );

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    
    return ft.hr;
}

// ScheduleAutoChk is a class static method.
HRESULT
CVolume::ExecScheduleAutoChk(
    IN BSTR bstrObjPath,    // no object path for static methods
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecScheduleAutoChk");
    
    DWORD rcStatus = ERROR_SUCCESS;
    WCHAR* pmszVolumes = NULL;

    try
    {
        DWORD cchVolumes = 0;
        CComPtr<IWbemClassObject> spOutParamClass;
        CObjPath objPath;
        
        if (pParams == NULL)
        {
            ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::ExecScheduleAutoChk called with no parameters, hr<%#x>", ft.hr);
        }

        CWbemClassObject wcoInParam(pParams);
        CWbemClassObject wcoOutParam;
        
        if (wcoInParam.data() == NULL)
        {
            ft.hr = E_OUTOFMEMORY;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::ExecScheduleAutoChk: out of memory, hr<%#x>", ft.hr);
        }
        
        // Gets the Volumes
        wcoInParam.GetPropertyMultiSz(&cchVolumes, &pmszVolumes, PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(pmszVolumes, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecScheduleAutoChk: volume array param is NULL")

        ft.hr = m_pClass->GetMethod(
            _bstr_t(PVDR_MTHD_SCHEDULECHK),
            0,
            NULL,
            &spOutParamClass
            );
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"ExecScheduleAutoChk GetMethod failed, hr<%#x>", ft.hr);

        ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

        rcStatus = AutoChk(g_wszScheduleAutoChkCommand, pmszVolumes);

        ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
               
        ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    }
    catch (...)
    {
        delete [] pmszVolumes;
        throw;
    }

    delete [] pmszVolumes;

    return ft.hr;
}

// ExcludeAutoChk is a class static method.
HRESULT
CVolume::ExecExcludeAutoChk(
    IN BSTR bstrObjPath,    // no object path for static methods
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecExcludeAutoChk");
    
    DWORD rcStatus = ERROR_SUCCESS;
    WCHAR* pmszVolumes = NULL;

    try
    {
        DWORD cchVolumes = 0;
        CComPtr<IWbemClassObject> spOutParamClass;
        CObjPath objPath;
        
        if (pParams == NULL)
        {
            ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::ExecExcludeAutoChk called with no parameters, hr<%#x>", ft.hr);
        }

        CWbemClassObject wcoInParam(pParams);
        CWbemClassObject wcoOutParam;
        
        if (wcoInParam.data() == NULL)
        {
            ft.hr = E_OUTOFMEMORY;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::ExecExcludeAutoChk: out of memory, hr<%#x>", ft.hr);
        }
        
        // Gets the Volumes
        wcoInParam.GetPropertyMultiSz(&cchVolumes, &pmszVolumes, PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(pmszVolumes, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecExcludeAutoChk: volume array param is NULL")

        ft.hr = m_pClass->GetMethod(
            _bstr_t(PVDR_MTHD_EXCLUDECHK),
            0,
            NULL,
            &spOutParamClass
            );
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"ExecExcludeAutoChk GetMethod failed, hr<%#x>", ft.hr);

        ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

        rcStatus = AutoChk(g_wszExcludeAutoChkCommand, pmszVolumes);

        ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
               
        ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    }
    catch (...)
    {
        delete [] pmszVolumes;
        throw;
    }

    delete [] pmszVolumes;

    return ft.hr;
}



HRESULT
CVolume::ExecFormat(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ExecFormat");
    CComPtr<IWbemClassObject> spOutParamClass;
    _bstr_t bstrVolume;
    CObjPath objPath;
    DWORD rcStatus = ERROR_SUCCESS;
    _bstr_t bstrFileSystem;
    _bstr_t bstrLabel;
    BOOL fQuickFormat = FALSE;
    BOOL fEnableCompression = FALSE;
    DWORD dwClusterSize = 0;
    
    if (pParams == NULL)
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume::Format called with no parameters, hr<%#x>", ft.hr);
    }

    objPath.Init(bstrObjPath);
    bstrVolume = objPath.GetStringValueForProperty(PVDR_PROP_DEVICEID);
    IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_OBJECT_PATH, L"ExecFormat: volume key property not found")

    CWbemClassObject wcoInParam(pParams);
    CWbemClassObject wcoOutParam;            
    
    // Get the parameters
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_QUICKFORMAT, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecFormat: FileSystem param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_ENABLECOMPRESSION, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecFormat: FileSystem param is NULL")
    IF_PROP_NULL_THROW(wcoInParam, PVDR_PROP_CLUSTERSIZE, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecFormat: FileSystem param is NULL")
    
    wcoInParam.GetProperty(bstrFileSystem, PVDR_PROP_FILESYSTEM);
    IF_WSTR_NULL_THROW(bstrFileSystem, WBEM_E_INVALID_METHOD_PARAMETERS, L"ExecFormat: FileSystem param is NULL")
    wcoInParam.GetProperty(&fQuickFormat, PVDR_PROP_QUICKFORMAT);
    wcoInParam.GetProperty(&fEnableCompression, PVDR_PROP_ENABLECOMPRESSION);
    wcoInParam.GetProperty(&dwClusterSize, PVDR_PROP_CLUSTERSIZE);
    wcoInParam.GetProperty(bstrLabel, PVDR_PROP_LABEL);
    if ((WCHAR*)bstrLabel == NULL) // non-NULL zero length label is OK
    {
        ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"ExecFormat: Label param is NULL");
    }
    
    ft.hr = m_pClass->GetMethod(
        _bstr_t(PVDR_MTHD_FORMAT),
        0,
        NULL,
        &spOutParamClass
        );
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Format GetMethod failed, hr<%#x>", ft.hr);

    // Create an out param object
    ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);
    
    rcStatus = Format(
                            bstrVolume, 
                            fQuickFormat,
                            fEnableCompression,
                            bstrFileSystem,
                            dwClusterSize,
                            bstrLabel,
                            pHandler
                            );

    ft.hr = wcoOutParam.SetProperty(rcStatus, PVD_WBEM_PROP_RETURNVALUE);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
           
    ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
    
    return ft.hr;
}

DWORD
CVolume::AddMountPoint(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDirectory
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::AddMountPoint");
    DWORD rcStatus = MOUNTPOINT_RC_NO_ERROR;

    _ASSERTE(pwszVolume != NULL);
    _ASSERTE(pwszDirectory != NULL);
    
    if (!SetVolumeMountPoint(pwszDirectory, pwszVolume))
    {
        switch(GetLastError())
        {
            case ERROR_FILE_NOT_FOUND:
                rcStatus = MOUNTPOINT_RC_FILE_NOT_FOUND;
                break;                    
            case ERROR_DIR_NOT_EMPTY:
                rcStatus = MOUNTPOINT_RC_DIRECTORY_NOT_EMPTY;
                break;                    
            case ERROR_INVALID_PARAMETER:
            case ERROR_INVALID_NAME:
                rcStatus = MOUNTPOINT_RC_INVALID_ARG;
                break;                    
            case ERROR_ACCESS_DENIED:
                rcStatus = MOUNTPOINT_RC_ACCESS_DENIED;
                break;                    
            case ERROR_INVALID_FUNCTION:
                rcStatus = MOUNTPOINT_RC_NOT_SUPPORTED;
                break;                    

            default:
                        rcStatus = GetLastError();
                        ft.Trace(VSSDBG_VSSADMIN, L"CVolume::AddMountPoint: SetVolumeMountPoint failed %#x", rcStatus);
        }            
    }
    
    return rcStatus;
}

DWORD
CVolume::Mount(
    IN WCHAR* pwszVolume
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Mount");
    DWORD rcStatus = MOUNT_RC_NO_ERROR;

    _ASSERTE(pwszVolume != NULL);

    // Issue mount only for offline volumes.  System will automount others on next IO
    if (!VolumeIsMountable(pwszVolume))
    {
        DWORD   cch;
        HANDLE  hVol;
        BOOL bOnline = FALSE;
        DWORD   bytes;

        cch = wcslen(pwszVolume);
        pwszVolume[cch - 1] = 0;
        hVol = CreateFile(pwszVolume, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        pwszVolume[cch - 1] = '\\';
        
        if (hVol != INVALID_HANDLE_VALUE)
        {
            bOnline = DeviceIoControl(hVol, IOCTL_VOLUME_ONLINE, NULL, 0, NULL, 0, &bytes,
                                NULL);
            CloseHandle(hVol);

            if (!bOnline)
                rcStatus = MOUNT_RC_UNEXPECTED;
        }
        else
        {
            switch(GetLastError())
            {
                case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_NAME:
                    ft.hr = WBEM_E_NOT_FOUND;
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CVolume::Mount: CreateFile failed %#x", GetLastError());
                    break;                    
                case ERROR_ACCESS_DENIED:
                    rcStatus = MOUNT_RC_ACCESS_DENIED;
                    break;                    
                default:
                    rcStatus = GetLastError();
                    ft.Trace(VSSDBG_VSSADMIN, L"CVolume::Mount: CreateFile failed %#x", rcStatus);
            }            
        }            
    }
       
    return rcStatus;
}

DWORD
CVolume::Dismount(
    IN WCHAR* pwszVolume,
    IN BOOL fForce,
    IN BOOL fPermanent
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Dismount");
    DWORD rcStatus = DISMOUNT_RC_NO_ERROR;
    HANDLE  hVol = INVALID_HANDLE_VALUE;

    _ASSERTE(pwszVolume != NULL);

    try
    {
        // Issue dismount only for online volumes.
        if (VolumeIsMountable(pwszVolume))
        {
            BOOL bIO = FALSE;
            DWORD   bytes;
            DWORD   cch;

            cch = wcslen(pwszVolume);
            pwszVolume[cch - 1] = 0;
            hVol = CreateFile(pwszVolume, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
            pwszVolume[cch - 1] = '\\';
            
            if (hVol != INVALID_HANDLE_VALUE)
            {
                if (fPermanent)  // Put the volume in an offline state
                {
                    // Make sure there are no mount points for the volume
                    if (VolumeHasMountPoints(pwszVolume))
                        throw DISMOUNT_RC_VOLUME_HAS_MOUNT_POINTS;

                    // Make sure the volume supports ONLINE/OFFLINE
                    bIO = DeviceIoControl(hVol, IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE, NULL, 0,
                                        NULL, 0, &bytes, NULL);                    
                    if (!bIO)
                        throw DISMOUNT_RC_NOT_SUPPORTED;
                    
                    // Lock the volume so that apps have a chance to dismount gracefully.
                    // If the LOCK fails, continue only if Force is specified.
                    bIO = DeviceIoControl(hVol, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &bytes, NULL);
                    if (!fForce && !bIO)
                        throw DISMOUNT_RC_FORCE_OPTION_REQUIRED;

                    // Dismount the volume
                    bIO = DeviceIoControl(hVol, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &bytes, NULL);
                    if (!bIO)
                        throw DISMOUNT_RC_UNEXPECTED;

                    // Set the volume offline
                    bIO = DeviceIoControl(hVol, IOCTL_VOLUME_OFFLINE, NULL, 0, NULL, 0, &bytes, NULL);
                    if (!bIO)
                        throw DISMOUNT_RC_UNEXPECTED;

                }
                else
                {
                    // Lock the volume so that apps have a chance to dismount gracefully.
                    // If the LOCK fails, continue only if Force is specified.
                    bIO = DeviceIoControl(hVol, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &bytes, NULL);
                    if (!fForce && !bIO)
                        throw DISMOUNT_RC_FORCE_OPTION_REQUIRED;

                    bIO = DeviceIoControl(hVol, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &bytes, NULL);
                    if (!bIO)
                        throw DISMOUNT_RC_UNEXPECTED;
                }
            }
            else
            {
                switch(GetLastError())
                {
                    case ERROR_FILE_NOT_FOUND:
                    case ERROR_INVALID_PARAMETER:
                    case ERROR_INVALID_NAME:
                        ft.hr = WBEM_E_NOT_FOUND;
                        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CVolume::Dismount: CreateFile failed %#x", GetLastError());
                        break;                    
                    case ERROR_ACCESS_DENIED:
                        rcStatus = DISMOUNT_RC_ACCESS_DENIED;
                        break;                    
                    default:
                        rcStatus = GetLastError();
                        ft.Trace(VSSDBG_VSSADMIN, L"CVolume::Dismount: CreateFile failed %#x", rcStatus);
                }            
            }            
        }
    }
    catch (DISMOUNT_ERROR rcEx)
    {
        rcStatus = rcEx;
    }
    catch (...)
    {
        if (hVol != INVALID_HANDLE_VALUE)
            CloseHandle(hVol);
        throw;
    }
       
    if (hVol != INVALID_HANDLE_VALUE)
        CloseHandle(hVol);
    
    return rcStatus;
}


DWORD
CVolume::Defrag(
    IN WCHAR* pwszVolume,
    IN BOOL fForce,
    IN IWbemObjectSink* pHandler,
    IN OUT IWbemClassObject* pObject
    )
{
    DWORD rcStatus = DEFRAG_RC_NO_ERROR;
    CComPtr<IFsuDefrag> spIDefrag;
    CComPtr<IFsuAsync> spAsync;
    HRESULT hrDefrag = E_FAIL;
    DEFRAG_REPORT DefragReport;
    BOOL fDirty = FALSE;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Defrag");

    _ASSERTE(pObject != NULL);

    if (GetDriveType(pwszVolume) == DRIVE_REMOVABLE && !VolumeIsReady(pwszVolume))
        return DEFRAG_RC_NOT_SUPPORTED;
    
    VolumeIsDirty(pwszVolume, &fDirty);
    if (fDirty)
        return DEFRAG_RC_DIRTY_BIT_SET;

    ft.hr = spIDefrag.CoCreateInstance(__uuidof(FsuDefrag));
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuDefrag CoCreateInstance failed, %#x", ft.hr);            

    ft.hr = spIDefrag->Defrag(
                pwszVolume,
                fForce,
                &spAsync);
    if (ft.HrFailed())
        ft.Trace(VSSDBG_VSSADMIN, L"IFsuDefrag::Defrag failed, %#x", ft.hr);            

    hrDefrag = ft.hr;

    if (ft.HrSucceeded())
    {
        do
        {
            ULONG ulPercentDone = 0;
            ft.hr = spAsync->QueryStatus(&hrDefrag, &ulPercentDone);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::QueryStatus failed, %#x", ft.hr);

            ft.hr = pHandler->SetStatus(
                        WBEM_STATUS_PROGRESS,          // progress report
                        MAKELONG(ulPercentDone, 100),   // LOWORD is work done so far, HIWORD is total work
                        NULL,
                        NULL);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Defrag: unable to set intermediate status, SetStatus returned %#x", ft.hr);
            
            Sleep(200);
        }
        while (hrDefrag == E_PENDING);

        ft.hr = spAsync->Wait(&hrDefrag);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::Wait failed, %#x", ft.hr);
    }
        
    if(SUCCEEDED(hrDefrag))
    {
        memset(&DefragReport, 0, sizeof(DefragReport));

        ft.hr = spAsync->GetDefragReport(&DefragReport);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::GetDefragReport failed, %#x", ft.hr);            

        LoadDefragAnalysis(&DefragReport, pObject);
    }
    else
    {
        TranslateDefragError(hrDefrag, &rcStatus);
    }

    return rcStatus;
}


DWORD
CVolume::DefragAnalysis(
    IN WCHAR* pwszVolume,
    OUT BOOL* pfDefragRecommended,
    IN OUT IWbemClassObject* pObject
    )
{
    DWORD rcStatus = DEFRAG_RC_NO_ERROR;
    CComPtr<IFsuDefrag> spIDefrag;
    CComPtr<IFsuAsync> spAsync;
    HRESULT hrDefrag = E_FAIL;
    DEFRAG_REPORT DefragReport;
    BOOL fDirty = FALSE;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::DefragAnalysis");

    _ASSERTE(pfDefragRecommended != NULL);
    _ASSERTE(pObject != NULL);

    *pfDefragRecommended = FALSE;

    if (GetDriveType(pwszVolume) == DRIVE_REMOVABLE && !VolumeIsReady(pwszVolume))
        return DEFRAG_RC_NOT_SUPPORTED;
    
    VolumeIsDirty(pwszVolume, &fDirty);
    if (fDirty)
        return DEFRAG_RC_DIRTY_BIT_SET;

    ft.hr = spIDefrag.CoCreateInstance(__uuidof(FsuDefrag));
    //ft.hr = spIDefrag.CoCreateInstance(CLSID_Defrag);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IDefrag CoCreateInstance failed, %#x", ft.hr);            

    ft.hr = spIDefrag->DefragAnalysis(
                pwszVolume,
                &spAsync);
    if (ft.HrFailed())
        ft.Trace(VSSDBG_VSSADMIN, L"IDefrag::DefragAnalysis failed, %#x", ft.hr);            

    hrDefrag = ft.hr;
    
    if (ft.HrSucceeded())
    {
        ft.hr = spAsync->Wait(&hrDefrag);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::Wait failed, %#x", ft.hr);            
    }
    
    if(SUCCEEDED(hrDefrag))
    {
        memset(&DefragReport, 0, sizeof(DefragReport));
    
        ft.hr = spAsync->GetDefragReport(&DefragReport);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::GetDefragReport failed, %#x", ft.hr);            
    
        //If the fragmentation on the disk exceeds 10% fragmentation, then recommend defragging.
        if ((DefragReport.PercentDiskFragged + DefragReport.FreeSpaceFragPercent)/2 > 10)
        {
            *pfDefragRecommended = TRUE;
        }
        ft.Trace(VSSDBG_VSSADMIN, L"bDefragRecommended<%d>", *pfDefragRecommended);            

        LoadDefragAnalysis(&DefragReport, pObject);
    }
    else
    {
        TranslateDefragError(hrDefrag, &rcStatus);
    }
    
    return rcStatus;
}

DWORD
CVolume::Chkdsk(
    IN WCHAR* pwszVolume,
    IN BOOL fFixErrors,
    IN BOOL fVigorousIndexCheck,
    IN BOOL fSkipFolderCycle,
    IN BOOL fForceDismount,
    IN BOOL fRecoverBadSectors,
    IN BOOL fOkToRunAtBootup
    )
{
    DWORD rcStatus = CHKDSK_RC_NO_ERROR;
    DWORD dwThreadID = GetCurrentThreadId();
    HINSTANCE hDLL = NULL;
    CHKDSK_THREAD_DATA threadData;    
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Chkdsk");

    if (GetDriveType(pwszVolume) == DRIVE_REMOVABLE && !VolumeIsReady(pwszVolume))
        return CHKDSK_RC_NO_MEDIA;

    threadData.fOkToRunAtBootup = fOkToRunAtBootup;
    threadData.rcStatus = rcStatus;
    SetThreadData(dwThreadID, &threadData);

    try
    {
        WCHAR wszFileSystem[g_cchFileSystemNameMax+1];
        DWORD dwDontCare = 0;
        PFMIFS_CHKDSKEX_ROUTINE ChkDskExRoutine = NULL;
        FMIFS_CHKDSKEX_PARAM Param;

        // Get the file system
        if (!GetVolumeInformation(
            pwszVolume,
            NULL,
            0,
            &dwDontCare,
            &dwDontCare,
            &dwDontCare,
            wszFileSystem,
            g_cchFileSystemNameMax))
        {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GetVolumeInformation failed for volume %lS, %#x", pwszVolume, GetLastError());
        }

        if (lstrcmpi(L"FAT", wszFileSystem) != 0 &&
            lstrcmpi(L"FAT32", wszFileSystem) != 0 &&
            lstrcmpi(L"NTFS", wszFileSystem)  != 0)
        {
            rcStatus = CHKDSK_RC_UNSUPPORTED_FS;
        }
        else
        {
            // Load the chkdsk function
            hDLL = LoadLibrary(L"fmifs.dll");
            if (hDLL == NULL)
            {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to load library fmifs.dll, %#x", GetLastError());            
            }

            ChkDskExRoutine = (PFMIFS_CHKDSKEX_ROUTINE) GetProcAddress(hDLL,  "ChkdskEx");
            if (ChkDskExRoutine == NULL)
            {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GetProcAddress failed for ChkdskEx, %#x", GetLastError());            
            }        
            
            Param.Major = 1;
            Param.Minor = 0;
            Param.Flags = 0;  // For the Verbose Flag
            Param.Flags |= fRecoverBadSectors ? FMIFS_CHKDSK_RECOVER : 0;
            Param.Flags |= fForceDismount ? FMIFS_CHKDSK_FORCE : 0;
            Param.Flags |= fVigorousIndexCheck ? FMIFS_CHKDSK_SKIP_INDEX_SCAN : 0;
            Param.Flags |= fSkipFolderCycle ? FMIFS_CHKDSK_SKIP_CYCLE_SCAN : 0;

            if (fRecoverBadSectors || fForceDismount)
            {
                fFixErrors = true;
            }

            // Return value captured in callback routine
            ChkDskExRoutine ( 
                    pwszVolume,
                    wszFileSystem,
                    (BOOLEAN)fFixErrors,
                    &Param,
                    ChkdskCallback);
        }
        
        rcStatus = threadData.rcStatus;        
    }
    catch (...)
    {
        RemoveThreadData(dwThreadID);
        if (hDLL)
            FreeLibrary(hDLL);
        throw;
    }

    RemoveThreadData(dwThreadID);
    
    if (hDLL)
        FreeLibrary(hDLL);
    
    return rcStatus;
}

#define VOLUME_GUID_PREFIX  L"\\\\?\\Volume"

DWORD
CVolume::AutoChk(
    IN const WCHAR* pwszAutoChkCommand,
    IN WCHAR* pwmszVolumes
    )
{
    DWORD rcStatus = AUTOCHK_RC_NO_ERROR;
    CCmdProcessor CmdProc;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::ScheduleAutoChk");
    WCHAR* pwszCurrentVolume = NULL;

    do
    {
        DWORD dwExecStatus = 0;
        DWORD cchVolumes = 0;

        // Validate the volumes
        pwszCurrentVolume = pwmszVolumes;
        while(true)
        {
            DWORD dwDriveType = 0;
            // End of iteration?
            LONG lCurrentVolumeLength = (LONG) ::wcslen(pwszCurrentVolume);
            if (lCurrentVolumeLength < 1)
                break;

            WCHAR wcDrive = towupper(pwszCurrentVolume[0]);

            // Drive letter, drive path or volume
            if (wcslen(pwszCurrentVolume) < 2)
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Invalid volume name, %lS", pwszCurrentVolume);
            }

            if ((pwszCurrentVolume[1] == L':' && (wcDrive < L'A' || wcDrive > L'Z')) ||
                 (pwszCurrentVolume[1] != L':' &&_wcsnicmp(pwszCurrentVolume, VOLUME_GUID_PREFIX, wcslen(VOLUME_GUID_PREFIX)) != 0))
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Invalid volume name, %lS", pwszCurrentVolume);
            }
            
            dwDriveType = GetDriveType(pwszCurrentVolume);
            switch (dwDriveType)
            {
                case DRIVE_REMOTE:
                    return  AUTOCHK_RC_NETWORK_DRIVE;

                case DRIVE_CDROM:
                case DRIVE_REMOVABLE:
                    return AUTOCHK_RC_REMOVABLE_DRIVE;

                case DRIVE_UNKNOWN:
                    return AUTOCHK_RC_UNKNOWN_DRIVE;

                case DRIVE_NO_ROOT_DIR:
                    return AUTOCHK_RC_NOT_ROOT_DIRECTORY ;

                case DRIVE_FIXED:
                    break;

                default:
                    return AUTOCHK_RC_UNEXPECTED;
            }

            // Destroy the multi-sz as we go along, transforming it into the command line
            // Last volume will have a trailing space character; the NULL that terminates
            // the multi-sz will terminate the string; the calling function throws the multi-sz
            // away without re-use anyway.
            if (*(pwszCurrentVolume + lCurrentVolumeLength - 1) == L'\\')
                *(pwszCurrentVolume + lCurrentVolumeLength - 1) = L' ';  // remove trailing '\' if any
                    
            *(pwszCurrentVolume + lCurrentVolumeLength) = L' '; // change the intermediate NULL to a space.

            cchVolumes += lCurrentVolumeLength + 1; // add one for the space (was term-NULL)
            
            // Go to the next one. Skip the zero character.
            pwszCurrentVolume += lCurrentVolumeLength + 1;
        }
        
        // Allocate and build the command line
        CVssAutoPWSZ awszCommand;
        DWORD cchCommand = wcslen(pwszAutoChkCommand) + cchVolumes + 1;
        awszCommand.Allocate(cchCommand);  // internally accounts for terminating NULL
        ft.hr = StringCchPrintf(awszCommand, cchCommand+1, L"%s %s", pwszAutoChkCommand, pwmszVolumes);

        ft.hr = CmdProc.InitializeAsClient(L"chkntfs.exe", awszCommand);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CCmdProcessor::InitializeAsClient failed, %#x", ft.hr);

        ft.hr = CmdProc.LaunchProcess();
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CCmdProcessor::LaunchProcess failed, %#x", ft.hr);

        do
        {
            ft.hr = CmdProc.Wait(200, &dwExecStatus);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CCmdProcessor::Wait failed, %#x", ft.hr);
            
        } while (dwExecStatus == STILL_ACTIVE);

        if (dwExecStatus != ERROR_SUCCESS)
        {
            rcStatus = AUTOCHK_RC_UNEXPECTED;
        }
        
    }
    while (false);

    return rcStatus;
}

DWORD
CVolume::Format(
    IN WCHAR* pwszVolume,
    IN BOOL fQuickFormat,
    IN BOOL fEnableCompression,
    IN WCHAR* pwszFileSystem,
    IN DWORD cbClusterSize,
    IN WCHAR* pwszLabel,
    IN IWbemObjectSink* pHandler
    )
{
    DWORD rcStatus = FORMAT_RC_NO_ERROR;
    HRESULT hrStatus = E_UNEXPECTED;
    CComPtr<IFsuFormat> spIFormat;
    CComPtr<IFsuAsync> spAsync;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::Format");

    _ASSERTE(pwszVolume != NULL);
    _ASSERTE(pwszFileSystem != NULL);
    _ASSERTE(pwszLabel != NULL);

    if (GetDriveType(pwszVolume) == DRIVE_REMOVABLE && !VolumeIsReady(pwszVolume))
        return FORMAT_RC_NO_MEDIA;
    
    ft.hr = spIFormat.CoCreateInstance(__uuidof(FsuFormat));
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuFormat CoCreateInstance failed, %#x", ft.hr);            

    ft.hr = spIFormat->Format(
                                        pwszVolume,
                                        pwszFileSystem,
                                        pwszLabel,
                                        fQuickFormat,
                                        fEnableCompression,
                                        cbClusterSize,
                                        &spAsync);
    if (ft.HrFailed())
        ft.Trace(VSSDBG_VSSADMIN, L"IFsuFormat::Format failed, %#x", ft.hr);            

    hrStatus = ft.hr;

    if (ft.HrSucceeded())
    {
        do
        {
            ULONG ulPercentDone = 0;
            ft.hr = spAsync->QueryStatus(&hrStatus, &ulPercentDone);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::QueryStatus failed, %#x", ft.hr);

            ft.hr = pHandler->SetStatus(
                        WBEM_STATUS_PROGRESS,          // progress report
                        MAKELONG(ulPercentDone, 100),   // LOWORD is work done so far, HIWORD is total work
                        NULL,
                        NULL);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Format: unable to set intermediate status, SetStatus returned %#x", ft.hr);
            
            Sleep(200);
        }
        while (hrStatus == E_PENDING);

        ft.hr = spAsync->Wait(&hrStatus);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IFsuAsync::Wait failed, %#x", ft.hr);
    }

    switch (hrStatus)
    {
        case S_OK:
            rcStatus = FORMAT_RC_NO_ERROR;
            break;
        case E_ACCESSDENIED:
            rcStatus = FORMAT_RC_ACCESS_DENIED;
            break;
        case E_ABORT:
            rcStatus = FORMAT_RC_CALL_CANCELLED;
            break;
        case FMT_E_UNSUPPORTED_FS:
            rcStatus = FORMAT_RC_UNSUPPORTED_FS;
            break;
        case FMT_E_CANT_QUICKFORMAT:
            rcStatus = FORMAT_RC_CANT_QUICKFORMAT;
            break;
        case FMT_E_CANCEL_TOO_LATE:
            rcStatus = FORMAT_RC_CANCEL_TOO_LATE;
            break;
        case FMT_E_IO_ERROR:
            rcStatus = FORMAT_RC_IO_ERROR;
            break;
        case FMT_E_BAD_LABEL:
            rcStatus = FORMAT_RC_BAD_LABEL;
            break;
        case FMT_E_INCOMPATIBLE_MEDIA:
            rcStatus = FORMAT_RC_INCOMPATIBLE_MEDIA;
            break;
        case FMT_E_WRITE_PROTECTED:
            rcStatus = FORMAT_RC_WRITE_PROTECTED;
            break;
        case FMT_E_CANT_LOCK:
            rcStatus = FORMAT_RC_CANT_LOCK;
            break;
        case FMT_E_NO_MEDIA:
            rcStatus = FORMAT_RC_NO_MEDIA;
            break;
        case FMT_E_VOLUME_TOO_SMALL:
            rcStatus = FORMAT_RC_VOLUME_TOO_SMALL;
            break;
        case FMT_E_VOLUME_TOO_BIG:
            rcStatus = FORMAT_RC_VOLUME_TOO_BIG;
            break;
        case FMT_E_VOLUME_NOT_MOUNTED:
            rcStatus = FORMAT_RC_VOLUME_NOT_MOUNTED;
            break;
        case FMT_E_CLUSTER_SIZE_TOO_SMALL:
            rcStatus = FORMAT_RC_CLUSTER_SIZE_TOO_SMALL;
            break;
        case FMT_E_CLUSTER_SIZE_TOO_BIG:
            rcStatus = FORMAT_RC_CLUSTER_SIZE_TOO_BIG;
            break;
        case FMT_E_CLUSTER_COUNT_BEYOND_32BITS:
            rcStatus = FORMAT_RC_CLUSTER_COUNT_BEYOND_32BITS;
            break;
        default:
            rcStatus = FORMAT_RC_UNEXPECTED;
    }
    
    return rcStatus;
}

//****************************************************************************
//
//  CMountPoint
//
//****************************************************************************

CMountPoint::CMountPoint( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CMountPoint::CMountPoint()

CProvBase *
CMountPoint::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CMountPoint * pObj= NULL;

    pObj = new CMountPoint(pwszName, pNamespace);

    if (pObj)
    {
        hr = pObj->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pObj;
        pObj = NULL;
    }
    return pObj;

} //*** CMountPoint::S_CreateThis()


HRESULT
CMountPoint::Initialize()
{

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CMountPoint::Initialize");
    
    return ft.hr;
}

HRESULT
CMountPoint::EnumInstance( 
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink *    pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CMountPoint::EnumInstance");
    CVssAutoPWSZ awszVolume;
        
    try
    {
        awszVolume.Allocate(MAX_PATH);

        CVssVolumeIterator volumeIterator;

        while (true)
        {
            CVssAutoPWSZ awszMountPoints;
            WCHAR* pwszCurrentMountPoint = NULL;

            // Get the volume name
            if (!volumeIterator.SelectNewVolume(ft, awszVolume, MAX_PATH))
                break;

            // Get the list of all mount points

            // Get the length of the multi-string array
            DWORD cchVolumesBufferLen = 0;
            BOOL bResult = GetVolumePathNamesForVolumeName(awszVolume, NULL, 0, &cchVolumesBufferLen);
            if (!bResult && (GetLastError() != ERROR_MORE_DATA))
                ft.TranslateGenericError(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
                    L"GetVolumePathNamesForVolumeName(%s, 0, 0, %p)", (LPWSTR)awszVolume, &cchVolumesBufferLen);

            // Allocate the array
            awszMountPoints.Allocate(cchVolumesBufferLen);

            // Get the mount points
            // Note: this API was introduced in WinXP so it will need to be replaced if backported
            bResult = GetVolumePathNamesForVolumeName(awszVolume, awszMountPoints, cchVolumesBufferLen, NULL);
            if (!bResult)
                ft.Throw(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
                    L"GetVolumePathNamesForVolumeName(%s, %p, %lu, 0)", (LPWSTR)awszVolume, awszMountPoints, cchVolumesBufferLen);

            // If the volume has mount points
            pwszCurrentMountPoint = awszMountPoints;
            if ( pwszCurrentMountPoint[0] )
            {
                while(true)
                {
                    CComPtr<IWbemClassObject> spInstance;
                    
                    // End of iteration?
                    LONG lCurrentMountPointLength = (LONG) ::wcslen(pwszCurrentMountPoint);
                    if (lCurrentMountPointLength == 0)
                        break;

                    ft.hr = m_pClass->SpawnInstance(0, &spInstance);
                    if (ft.HrFailed())
                        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                    // Only a root directory should have a trailing backslash character
                    if (lCurrentMountPointLength > 2 &&
                        pwszCurrentMountPoint[lCurrentMountPointLength-1] == L'\\' && 
                        pwszCurrentMountPoint[lCurrentMountPointLength-2] != L':')
                    {
                            pwszCurrentMountPoint[lCurrentMountPointLength-1] = L'\0';
                    }
                    LoadInstance(awszVolume, pwszCurrentMountPoint, spInstance.p);

                    ft.hr = pHandler->Indicate(1, &spInstance.p);            

                    // Go to the next one. Skip the zero character.
                    pwszCurrentMountPoint += lCurrentMountPointLength + 1;
                }
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CMountPoint::EnumInstance()

HRESULT
CMountPoint::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CMountPoint::GetObject");

    try
    {
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrDirectoryRef, bstrDirectoryName;
        CObjPath  objPathVolume;
        CObjPath  objPathDirectory;
        CVssAutoPWSZ awszMountPoints;
        WCHAR* pwszCurrentMountPoint = NULL;
        BOOL fFound = FALSE;
        CComPtr<IWbemClassObject> spInstance;

        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint volume key property not found")

        // Get the Directory reference
        bstrDirectoryRef = rObjPath.GetStringValueForProperty(PVDR_PROP_DIRECTORY);
        IF_WSTR_NULL_THROW(bstrDirectoryRef, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint directory key property not found")

        // Extract the Volume and Directory Names
        objPathVolume.Init(bstrVolumeRef);
        objPathDirectory.Init(bstrDirectoryRef);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint volume key property DeviceID not found")

        bstrDirectoryName = objPathDirectory.GetStringValueForProperty(PVDR_PROP_NAME);
        IF_WSTR_NULL_THROW(bstrDirectoryName, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint directory key property Name not found")

        if (VolumeMountPointExists(bstrVolumeName, bstrDirectoryName))
        {
            CComPtr<IWbemClassObject> spInstance;
            
            ft.hr = m_pClass->SpawnInstance(0, &spInstance);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            LoadInstance(bstrVolumeName, bstrDirectoryName, spInstance.p);

            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
        else
        {
            ft.hr = WBEM_E_NOT_FOUND;
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }
    
    return ft.hr;
    
} //*** CMountPoint::GetObject()

void
CMountPoint:: LoadInstance(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDirectory,
    IN OUT IWbemClassObject* pObject)
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathDirectory;
    CObjPath pathVolume;

    _ASSERTE(pwszVolume != NULL);
    _ASSERTE(pwszDirectory != NULL);
    
    // Set the Directory Ref property
    pathDirectory.Init(PVDR_CLASS_DIRECTORY);
    pathDirectory.AddProperty(PVDR_PROP_NAME, pwszDirectory);    
    wcoInstance.SetProperty((wchar_t*)pathDirectory.GetObjectPathString(), PVDR_PROP_DIRECTORY);

    // Set the Volume Ref property
    pathVolume.Init(PVDR_CLASS_VOLUME);
    pathVolume.AddProperty(PVDR_PROP_DEVICEID, pwszVolume);    
    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVDR_PROP_VOLUME);
}


HRESULT
CMountPoint::PutInstance(
        IN CWbemClassObject&  rInstToPut,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CMountPoint::PutInstance");
    
    try
    {
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrDirectoryRef, bstrDirectoryName;
        CObjPath  objPathVolume;
        CObjPath  objPathDirectory;

        if ( lFlag & WBEM_FLAG_UPDATE_ONLY )
        {
            return WBEM_E_UNSUPPORTED_PARAMETER ;
        }        

        // Retrieve key properties of the object to be saved.
        rInstToPut.GetProperty(bstrVolumeRef, PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT, L"MountPoint volume key property not found")

        rInstToPut.GetProperty(bstrDirectoryRef, PVDR_PROP_DIRECTORY);
        IF_WSTR_NULL_THROW(bstrDirectoryRef, WBEM_E_INVALID_OBJECT, L"MountPoint directory key property not found")

         // Extract the Volume and Directory Names
        objPathVolume.Init(bstrVolumeRef);
        objPathDirectory.Init(bstrDirectoryRef);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint volume key property DeviceID not found")

        bstrDirectoryName = objPathDirectory.GetStringValueForProperty(PVDR_PROP_NAME);
        IF_WSTR_NULL_THROW(bstrDirectoryName, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint directory key property Name not found")

        ft.Trace(VSSDBG_VSSADMIN, L"CMountPoint::PutInstance Volume<%lS> Directory<%lS>",
            (WCHAR*)bstrVolumeName, (WCHAR*)bstrDirectoryName);

        if (VolumeMountPointExists(bstrVolumeName, bstrDirectoryName))
        {
            ft.hr = WBEM_E_ALREADY_EXISTS;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CMountPoint:PutInstance mount point already exists");
        }
        
        // Only root directories have the trailing backslash; fix the others
        WCHAR* pwszDirectoryName = bstrDirectoryName;
        if (pwszDirectoryName[wcslen(bstrDirectoryName) -1] != L'\\')
            bstrDirectoryName += _bstr_t(L"\\");
        
        if (!SetVolumeMountPoint(bstrDirectoryName, bstrVolumeName))
        {
            switch(GetLastError())
            {
                case ERROR_FILE_NOT_FOUND:
                case ERROR_DIR_NOT_EMPTY:
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_NAME:
                    ft.hr = WBEM_E_INVALID_PARAMETER;
                    break;                    
                case ERROR_ACCESS_DENIED:
                    ft.hr = WBEM_E_ACCESS_DENIED;
                    break;                    
                case ERROR_INVALID_FUNCTION:
                    ft.hr = WBEM_E_NOT_SUPPORTED;
                    break;                    

                default:
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.Trace(VSSDBG_VSSADMIN, L"C MountPoint: PutInstance: SetVolumeMountPoint failed %#x", ft.hr);
            }            
        }        
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

HRESULT
CMountPoint::DeleteInstance(
        IN CObjPath& rObjPath,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CMountPoint::DeleteInstance");
    
    try
    {
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrDirectoryRef, bstrDirectoryName;
        CObjPath  objPathVolume;
        CObjPath  objPathDirectory;

        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint volume key property not found")

        // Get the Directory reference
        bstrDirectoryRef = rObjPath.GetStringValueForProperty(PVDR_PROP_DIRECTORY);
        IF_WSTR_NULL_THROW(bstrDirectoryRef, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint directory key property not found")
        
        // Extract the Volume and Directory Names
        objPathVolume.Init(bstrVolumeRef);
        objPathDirectory.Init(bstrDirectoryRef);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint volume key property DeviceID not found")

        bstrDirectoryName = objPathDirectory.GetStringValueForProperty(PVDR_PROP_NAME);
        IF_WSTR_NULL_THROW(bstrDirectoryName, WBEM_E_INVALID_OBJECT_PATH, L"MountPoint directory key property Name not found")

        ft.Trace(VSSDBG_VSSADMIN, L"CMountPoint::DeleteInstance Volume<%lS> Directory<%lS>",
            (WCHAR*)bstrVolumeName, (WCHAR*)bstrDirectoryName);

        // Only root directories have the trailing backslash; fix the others
        WCHAR* pwszDirectoryName = bstrDirectoryName;
        if (pwszDirectoryName[wcslen(bstrDirectoryName) -1] != L'\\')
            bstrDirectoryName += _bstr_t(L"\\");
        
        if (!DeleteVolumeMountPoint(bstrDirectoryName))
            ft.Throw(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()), L"DeleteVolumeMountPoint failed %#x", GetLastError());
        
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

void
 LoadDefragAnalysis(
    IN DEFRAG_REPORT* pDefragReport,
    IN OUT IWbemClassObject* pObject)
{
    DWORD dwPercent = 0;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolume::LoadDefragAnalysis");

    _ASSERTE(pDefragReport != NULL);
    _ASSERTE(pObject != NULL);
    
    CWbemClassObject wcoInstance(pObject);   
    
    ft.Trace(VSSDBG_VSSADMIN, L"PercentDiskFragged<%d>", pDefragReport->PercentDiskFragged);            
    ft.Trace(VSSDBG_VSSADMIN, L"FreeSpaceFragPercent<%d>", pDefragReport->FreeSpaceFragPercent);            
    ft.Trace(VSSDBG_VSSADMIN, L"FreeSpacePercent<%d>", pDefragReport->FreeSpacePercent);            

    // General volume properties
    wcoInstance.SetPropertyI64(pDefragReport->DiskSize, PVDR_PROP_VOLUMESIZE);
    wcoInstance.SetPropertyI64(pDefragReport->BytesPerCluster, PVDR_PROP_CLUSTERSIZE);
    wcoInstance.SetPropertyI64(pDefragReport->UsedSpace, PVDR_PROP_USEDSPACE);
    wcoInstance.SetPropertyI64(pDefragReport->FreeSpace, PVDR_PROP_FREESPACE);
    wcoInstance.SetProperty(pDefragReport->FreeSpacePercent, PVDR_PROP_FRAGFREEPCT);

    // Volume fragmentation

    dwPercent = ((pDefragReport->PercentDiskFragged + pDefragReport->FreeSpaceFragPercent)/2);
    wcoInstance.SetProperty(dwPercent, PVDR_PROP_FRAGTOTALPCT);
    wcoInstance.SetProperty(pDefragReport->PercentDiskFragged, PVDR_PROP_FILESFRAGPCT);
    wcoInstance.SetProperty(pDefragReport->FreeSpaceFragPercent, PVDR_PROP_FREEFRAGPCT);

    // File fragmentation
    wcoInstance.SetPropertyI64(pDefragReport->TotalFiles, PVDR_PROP_FILESTOTAL);
    wcoInstance.SetPropertyI64(pDefragReport->AvgFileSize, PVDR_PROP_FILESIZEAVG);
    wcoInstance.SetPropertyI64(pDefragReport->NumFraggedFiles, PVDR_PROP_FILESFRAGTOTAL);
    wcoInstance.SetPropertyI64(pDefragReport->NumExcessFrags, PVDR_PROP_EXCESSFRAGTOTAL);

    // IDefrag interface currently reports this statistic per 100 files
    double dblAvgFragsPerFile = (double)(pDefragReport->AvgFragsPerFile)/100.0;
    wcoInstance.SetPropertyR64(dblAvgFragsPerFile, PVDR_PROP_FILESFRAGAVG);
    
    // Pagefile fragmentation
    wcoInstance.SetPropertyI64(pDefragReport->PagefileBytes, PVDR_PROP_PAGEFILESIZE);
    wcoInstance.SetPropertyI64(pDefragReport->PagefileFrags, PVDR_PROP_PAGEFILEFRAG);
    
    // Folder fragmentation
    wcoInstance.SetPropertyI64(pDefragReport->TotalDirectories, PVDR_PROP_FOLDERSTOTAL);
    wcoInstance.SetPropertyI64(pDefragReport->FragmentedDirectories, PVDR_PROP_FOLDERSFRAG);
    wcoInstance.SetPropertyI64(pDefragReport->ExcessDirFrags, PVDR_PROP_FOLDERSFRAGEXCESS);

    // Master File Table fragmentation
    wcoInstance.SetPropertyI64(pDefragReport->MFTBytes, PVDR_PROP_MFTSIZE);
    wcoInstance.SetPropertyI64(pDefragReport->InUseMFTRecords, PVDR_PROP_MFTRECORDS);
    dwPercent = pDefragReport->TotalMFTRecords?(100*pDefragReport->InUseMFTRecords/pDefragReport->TotalMFTRecords):0;
    wcoInstance.SetProperty(dwPercent, PVDR_PROP_MFTINUSEPCT);
    wcoInstance.SetPropertyI64(pDefragReport->MFTExtents, PVDR_PROP_MFTFRAGTOTAL);
}

void
TranslateDefragError(
    IN HRESULT hr,
    OUT DWORD* pdwError)
{
    _ASSERTE(pdwError != NULL);

    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED))
            *pdwError = DEFRAG_RC_NOT_SUPPORTED;
    else
    {
        switch (hr)
        {
            case DFRG_E_LOW_FREESPACE:
                *pdwError = DEFRAG_RC_LOW_FREESPACE;
                break;
            case DFRG_E_CORRUPT_MFT:
                *pdwError = DEFRAG_RC_CORRUPT_MFT;
                break;
            case E_ABORT:
                *pdwError  = DEFRAG_RC_CALL_CANCELLED;
                break;
            case DFRG_E_CANCEL_TOO_LATE:
                *pdwError  = DEFRAG_RC_CANCEL_TOO_LATE;
                break;
            case DFRG_E_ALREADY_RUNNING:
                *pdwError  = DEFRAG_RC_ALREADY_RUNNING;
                break;
            case DFRG_E_ENGINE_CONNECT:
                *pdwError  = DEFRAG_RC_ENGINE_CONNECT;
                break;
            case DFRG_E_ENGINE_ERROR:                
                *pdwError  = DEFRAG_RC_ENGINE_ERROR;
                break;
            default:
                *pdwError  = DEFRAG_RC_UNEXPECTED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\volutil.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name: volutil.cpp
//
//  Description:    
//      Utility functions for handling volumes
//
//  Author:   Jim Benton (jbenton) 30-Apr-2002
//
//////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <map>

#include "vs_assert.hxx"
#include <atlbase.h>

#include <winioctl.h>
#include <ntddvol.h> // IOCTL_VOLUME_IS_OFFLINE
#include <mountmgr.h> // MOUNTDEV_NAME
#include <lm.h> // NetShareDel
#include "vs_inc.hxx"
#include <strsafe.h>
#include "schema.h"
#include "volutil.h"

#define SYMBOLIC_LINK_LENGTH        28  // \DosDevices\X:
#define GLOBALROOT_SIZE                  14  // \\?\GLOBALROOT

const WCHAR SETUP_KEY[] = L"SYSTEM\\Setup";
const WCHAR SETUP_SYSTEMPARTITION[] = L"SystemPartition";

BOOL GetVolumeDrive (
    IN WCHAR* pwszVolumePath,
    IN DWORD  cchDriveName,
    OUT WCHAR* pwszDriveNameBuf
)
{
    CVssAutoPWSZ awszMountPoints;
    WCHAR* pwszCurrentMountPoint = NULL;
    BOOL fFound = FALSE;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeMountPointExists");
    
    // Get the length of the multi-string array
    DWORD cchVolumesBufferLen = 0;
    BOOL bResult = GetVolumePathNamesForVolumeName(
                                pwszVolumePath,
                                NULL,
                                0,
                                &cchVolumesBufferLen);
    if (!bResult && (GetLastError() != ERROR_MORE_DATA))
        ft.TranslateGenericError(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
            L"GetVolumePathNamesForVolumeName(%s, 0, 0, %p)", pwszVolumePath, &cchVolumesBufferLen);

    // Allocate the array
    awszMountPoints.Allocate(cchVolumesBufferLen);

    // Get the mount points
    // Note: this API was introduced in WinXP so it will need to be replaced if backported
    bResult = GetVolumePathNamesForVolumeName(
                                pwszVolumePath,
                                awszMountPoints,
                                cchVolumesBufferLen,
                                NULL);
    if (!bResult)
        ft.Throw(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
            L"GetVolumePathNamesForVolumeName(%s, %p, %lu, 0)", pwszVolumePath, awszMountPoints, cchVolumesBufferLen);

    // If the volume has mount points
    pwszCurrentMountPoint = awszMountPoints;
    if ( pwszCurrentMountPoint[0] )
    {
        while(!fFound)
        {
            // End of iteration?
            LONG lCurrentMountPointLength = (LONG) ::wcslen(pwszCurrentMountPoint);
            if (lCurrentMountPointLength == 0)
                break;

            // Only a root directory should have a trailing backslash character
            if (lCurrentMountPointLength == 3 && pwszCurrentMountPoint[1] == L':'  && 
                pwszCurrentMountPoint[2] == L'\\')
            {
                ft.hr = StringCchCopy(pwszDriveNameBuf, cchDriveName, pwszCurrentMountPoint);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"StringCChCopy failed %#x", ft.hr);
                fFound = TRUE;
            }

            // Go to the next one. Skip the zero character.
            pwszCurrentMountPoint += lCurrentMountPointLength + 1;
        }
    }

    return fFound;
}

BOOL
VolumeSupportsQuotas(
    IN WCHAR* pwszVolume
    )
{
    BOOL fSupportsQuotas = FALSE;
    DWORD dwDontCare = 0;
    DWORD dwFileSystemFlags = 0;
    
    _ASSERTE(pwszVolume != NULL);

    if (GetVolumeInformation(
                pwszVolume,
                NULL,
                0,
                &dwDontCare,
                &dwDontCare,
                &dwFileSystemFlags,
                NULL,
                0))
    {
        if (dwFileSystemFlags & FILE_VOLUME_QUOTAS)
            fSupportsQuotas = TRUE;
    }

    return fSupportsQuotas;
}

// Filter volumes where:
//     - the supporting device is disconnected
//     - the supporting device is a floppy
//     - the volume is not found
// All other volumes are assumed valid
BOOL
VolumeIsValid(
    IN WCHAR* pwszVolume
    )
{
    bool fValid = true;
    HANDLE  hVol = INVALID_HANDLE_VALUE;
    DWORD  cch = 0;
    DWORD dwRet = 0;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeIsValid");

    _ASSERTE(pwszVolume != NULL);

    cch = wcslen(pwszVolume);
    pwszVolume[cch - 1] = 0;
    hVol = CreateFile(pwszVolume, 0,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    pwszVolume[cch - 1] = '\\';

    dwRet = GetLastError();
    
    if (hVol == INVALID_HANDLE_VALUE && dwRet != ERROR_NOT_READY)
    {
        if (dwRet == ERROR_FILE_NOT_FOUND ||
            dwRet == ERROR_DEVICE_NOT_CONNECTED)
        {
            fValid = false;
        }
        else
        {
            ft.Trace(VSSDBG_VSSADMIN, L"Unable to open volume %lS, %#x", pwszVolume, dwRet);
        }
    }
    
    if (hVol != INVALID_HANDLE_VALUE)
        CloseHandle(hVol);

    // Filter floppy drives
    if (fValid)
    {
        fValid = !VolumeIsFloppy(pwszVolume);
    }

    return fValid;        
}

DWORD
VolumeIsDirty(
    IN WCHAR* pwszVolume,
    OUT BOOL* pfDirty
    )
{
    HANDLE  hVol = INVALID_HANDLE_VALUE;
    DWORD dwRet = 0;
    DWORD cBytes = 0;
    DWORD dwResult = 0;
    WCHAR wszDeviceName[MAX_PATH+GLOBALROOT_SIZE];
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeIsDirty");
        
    _ASSERTE(pwszVolume != NULL);
    _ASSERTE(pfDirty != NULL);

    *pfDirty = FALSE;

    do
    {
        dwRet = GetDeviceName(pwszVolume, wszDeviceName);
        if (dwRet != ERROR_SUCCESS)
        {
            ft.hr = HRESULT_FROM_WIN32(dwRet);
            ft.Trace(VSSDBG_VSSADMIN, L"Unable to get volume device name %lS", pwszVolume);
            break;
        }

        hVol = CreateFile(wszDeviceName, GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);

        if (hVol != INVALID_HANDLE_VALUE)
        {
            if (DeviceIoControl(hVol, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &dwResult, sizeof(dwResult), &cBytes, NULL))
            {
                *pfDirty = dwResult & VOLUME_IS_DIRTY;
            }
            else
            {
                dwRet = GetLastError();
                ft.Trace(VSSDBG_VSSADMIN, L"DeviceIoControl failed for device %lS, %#x", wszDeviceName, dwRet);
                break;
            }
            CloseHandle(hVol);
        }
        else
        {
            dwRet = GetLastError();
            ft.Trace(VSSDBG_VSSADMIN, L"Unable to open volume %lS, %#x", pwszVolume, dwRet);
            break;
        }
    }
    while(false);

    return dwRet;        
}

BOOL
VolumeIsMountable(
    IN WCHAR* pwszVolume
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeIsMountable");
    DWORD   cch = 0;
    HANDLE  hVol = INVALID_HANDLE_VALUE;
    BOOL bIsOffline = FALSE;
    DWORD bytes = 0;

    cch = wcslen(pwszVolume);
    pwszVolume[cch - 1] = 0;
    hVol = CreateFile(pwszVolume, 0,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    pwszVolume[cch - 1] = '\\';
    
    if (hVol != INVALID_HANDLE_VALUE)
    {
        bIsOffline = DeviceIoControl(hVol, IOCTL_VOLUME_IS_OFFLINE, NULL, 0, NULL, 0, &bytes,
                            NULL);
        CloseHandle(hVol);
    }
    else
    {
        ft.Trace(VSSDBG_VSSADMIN, L"Unable to open volume %lS, %#x", pwszVolume, GetLastError());
    }

    return !bIsOffline;
}

BOOL
VolumeHasMountPoints(
    IN WCHAR* pwszVolume
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeHasMountPoints");
    DWORD dwVolumesBufferLen = 0;
    
    BOOL bResult = GetVolumePathNamesForVolumeName(
        pwszVolume, 
        NULL, 
        0, 
        &dwVolumesBufferLen);
    if (!bResult && (GetLastError() != ERROR_MORE_DATA))
        ft.Throw(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
            L"GetVolumePathNamesForVolumeName(%s, 0, 0, %p)", pwszVolume, &dwVolumesBufferLen);

    // More than three characters are needed to store just one mount point (multi-string buffer)
    // dwVolumesBufferLen == 1 typically for an un-mounted volume.
    return dwVolumesBufferLen > 3;
}

BOOL
VolumeIsFloppy(
    WCHAR* pwszVolume
    )
{
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    WCHAR wszDeviceName[MAX_PATH+GLOBALROOT_SIZE];
    NTSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    BOOL fIsFloppy = FALSE;

    DWORD dwRet = GetDeviceName(pwszVolume, wszDeviceName);

    if (dwRet == ERROR_SUCCESS)
    {
        hDevice = CreateFile(wszDeviceName, FILE_READ_ATTRIBUTES,
                       FILE_SHARE_READ |FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            Status = NtQueryVolumeInformationFile(
                            hDevice,
                            &IoStatusBlock,
                            &DeviceInfo,
                            sizeof(DeviceInfo),
                            FileFsDeviceInformation);

            if (NT_SUCCESS(Status))
            {
                if (DeviceInfo.DeviceType == FILE_DEVICE_DISK && DeviceInfo.Characteristics & FILE_FLOPPY_DISKETTE)
                {
                    fIsFloppy = TRUE ;
                }
            }
        }
    }
    
   if (hDevice != INVALID_HANDLE_VALUE)
        CloseHandle(hDevice);

   return fIsFloppy;
}

BOOL
VolumeIsReady(
    IN WCHAR* pwszVolume
    )
{
    BOOL bIsReady = FALSE;
    DWORD dwDontCare;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeIsReady");

    if (GetVolumeInformation(
                pwszVolume,
                NULL,
                0,
                &dwDontCare,
                &dwDontCare,
                &dwDontCare,
                NULL,
                0))
    {
        bIsReady = TRUE;
    }
    else if (GetLastError() != ERROR_NOT_READY)
        ft.Trace(VSSDBG_VSSADMIN, L"GetVolumeInformation failed for volume %lS, %#x", pwszVolume, GetLastError());
    
    return bIsReady;
}

BOOL
VolumeIsSystem(
    IN WCHAR* pwszVolume
    )   
{
    CRegKey cRegKeySetup;
    DWORD dwRet = 0;
    WCHAR wszRegDevice[MAX_PATH];
    WCHAR wszVolDevice[MAX_PATH+GLOBALROOT_SIZE];
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeIsSystem");

    dwRet = cRegKeySetup.Open( HKEY_LOCAL_MACHINE, SETUP_KEY, KEY_READ);
    if (dwRet != ERROR_SUCCESS)
    {
        ft.hr = HRESULT_FROM_WIN32(dwRet);
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Reg key open failed, %#x", dwRet);
    }

    DWORD dwLen = MAX_PATH;
    dwRet = cRegKeySetup.QueryValue(wszRegDevice, SETUP_SYSTEMPARTITION, &dwLen);
    if (dwRet != ERROR_SUCCESS)
    {
        ft.hr = HRESULT_FROM_WIN32(dwRet);
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Reg key query failed, %#x", dwRet);
    }

    dwRet = GetDeviceName(pwszVolume, wszVolDevice);
    if (dwRet != ERROR_SUCCESS)
    {
        ft.hr = HRESULT_FROM_WIN32(dwRet);
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get volume device name, %lS, %#x", pwszVolume, dwRet);
    }

    if (_wcsicmp(wszVolDevice+GLOBALROOT_SIZE, wszRegDevice) == 0)
        return TRUE;
    
    return FALSE;
}

BOOL
VolumeHoldsPagefile(
    IN WCHAR* pwszVolume
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeHoldsPagefile");

    //
    // Retrieve page files.
    //

    BYTE* pbBuffer;
    DWORD dwBufferSize;
    PSYSTEM_PAGEFILE_INFORMATION  pPageFileInfo = NULL;
    NTSTATUS status;
    BOOL fFound = FALSE;

    try
    {
        for (dwBufferSize=512; ; dwBufferSize += 512)
        {
            // Allocate buffer at 512 bytes increment. Previous allocation is
            // freed automatically.
            pbBuffer = (BYTE *) new BYTE[dwBufferSize];
            if ( pbBuffer==NULL )
                return E_OUTOFMEMORY;

            status = NtQuerySystemInformation(
                                               SystemPageFileInformation,
                                               pbBuffer,
                                               dwBufferSize,
                                               NULL
                                             );
            if ( status==STATUS_INFO_LENGTH_MISMATCH ) // buffer not big enough.
            {
                delete [] pbBuffer;
                continue;
            }

            pPageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) pbBuffer;
            
            if (!NT_SUCCESS(status))
            {
                ft.hr = HRESULT_FROM_NT(status);
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"NtQuerySystemInformation failed, %#x", status);
            }
            else
                break;
        }

        //
        // Walk through each of the page file volumes. Usually the return
        // looks like "\??\C:\pagefile.sys." If a pagefile is added\extended
        // \moved, the return will look like 
        //      "\Device\HarddiskVolume2\pagefile.sys."
        //

        WCHAR       *p;
        WCHAR       wszDrive[3] = L"?:";
        WCHAR       buffer2[MAX_PATH], *pbuffer2 = buffer2;
        WCHAR wszVolDevice[MAX_PATH+GLOBALROOT_SIZE], *pwszVolDevice = wszVolDevice;
        DWORD       dwRet;

        dwRet = GetDeviceName(pwszVolume, wszVolDevice);
        if (dwRet != ERROR_SUCCESS)
        {
            ft.hr = HRESULT_FROM_WIN32(dwRet);
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unable to get volume device name, %lS, %#x", pwszVolume, dwRet);
        }

        for ( ; ; )
        {
            if ( pPageFileInfo==NULL ||
                 pPageFileInfo->TotalSize==0 )  // We get 0 on WinPE.
                break;

            if ( pPageFileInfo->PageFileName.Length==0)
                break;

            p = wcschr(pPageFileInfo->PageFileName.Buffer, L':');
            if (p != NULL)
            {
                //
                // Convert drive letter to volume name.
                //

                _ASSERTE(p>pPageFileInfo->PageFileName.Buffer);
                _ASSERTE(towupper(*(p-1))>=L'A');
                _ASSERTE(towupper(*(p-1))<=L'Z');

                wszDrive[0] = towupper(*(p-1));
                dwRet = QueryDosDevice(wszDrive, buffer2, MAX_PATH);
                if (dwRet == 0)
                {
                    ft.hr = HRESULT_FROM_NT(dwRet);
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"QueryDosDevice failed, %#x", dwRet);
                }
            }
            else
            {
                _ASSERTE(_wcsnicmp(pPageFileInfo->PageFileName.Buffer,
                                    L"\\Device",
                                    7)==0 );

                p = wcsstr(pPageFileInfo->PageFileName.Buffer,L"\\pagefile.sys");
                _ASSERTE( p!=NULL );
                if (p == NULL)
                {
                    ft.hr = E_UNEXPECTED;
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Unexpected pagefile name format, %lS", pPageFileInfo->PageFileName.Buffer);
                }
                
                *p = L'\0';
                ft.hr = StringCchCopy(buffer2, MAX_PATH, pPageFileInfo->PageFileName.Buffer);
                if (ft.HrFailed())
                {
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"StringCchCopy failed, %#x", ft.hr);
                }
            }

            if (_wcsicmp(wszVolDevice+GLOBALROOT_SIZE, buffer2) == 0)
            {
                fFound = TRUE;
                break;
            }

            //
            // Next page file volume.
            //

            if (pPageFileInfo->NextEntryOffset == 0) 
                break;

            pPageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)pPageFileInfo
                           + pPageFileInfo->NextEntryOffset);

        }
    }
    catch (...)
    {
        delete [] pbBuffer;
        throw;
    }

    delete [] pbBuffer;

    return fFound;
}


DWORD GetDeviceName(
            IN  WCHAR* pwszVolume,
            OUT WCHAR wszDeviceName[MAX_PATH+GLOBALROOT_SIZE]
        )
/*++

Description:

    Get the device name of the given device. 
    E.g. \Device\HarddiskVolume###
    
Arguments:

    pwszVolume - volume GUID name.

    wszDeviceName - a buffer to receive device name. The buffer size must be 
        MAX_PATH+GLOBALROOT_SIZE (including "\\?\GLOBALROOT").

Return Value:

    Win32 errors

--*/
{
    DWORD dwRet;
    BOOL bRet;
    WCHAR wszMountDevName[MAX_PATH+sizeof(MOUNTDEV_NAME)];
        // Based on GetVolumeNameForRoot (in volmount.c), MAX_PATH seems to
        // be big enough as out buffer for IOCTL_MOUNTDEV_QUERY_DEVICE_NAME.
        // But we assume the size of device name could be as big as MAX_PATH-1,
        // so we allocate the buffer size to include MOUNTDEV_NAME size.
    PMOUNTDEV_NAME      pMountDevName;
    DWORD dwBytesReturned;
    HANDLE hVol = INVALID_HANDLE_VALUE;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"GetDeviceName");
    DWORD cch = 0;

    _ASSERTE(pwszVolume != NULL);

    wszDeviceName[0] = L'\0';
    
    //
    // query the volume's device object name
    //

    cch = wcslen(pwszVolume);
    pwszVolume[cch - 1] = 0;
    hVol = CreateFile(pwszVolume, 0,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    pwszVolume[cch - 1] = '\\';

    if (hVol != INVALID_HANDLE_VALUE)
    {
        bRet = DeviceIoControl(
                            hVol,            // handle to device
                            IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                            NULL,               // input data buffer
                            0,                  // size of input data buffer
                            wszMountDevName,       // output data buffer
                            sizeof(wszMountDevName),   // size of output data buffer
                            &dwBytesReturned,
                            NULL                // overlapped information
                        );

        dwRet = GetLastError();
        
        CloseHandle(hVol);
        
        if ( bRet==FALSE )
        {
            ft.Trace(VSSDBG_VSSADMIN, L"GetDeviceName: DeviceIoControl() failed: %X", dwRet);
            return dwRet;
        }

        pMountDevName = (PMOUNTDEV_NAME) wszMountDevName;
        if (pMountDevName->NameLength == 0)
        {
            // TODO: Is this possible? UNKNOWN?
            _ASSERTE( 0 );
        }
        else
        {
            //
            // copy name
            //

            ft.hr = StringCchPrintf(wszDeviceName, MAX_PATH+GLOBALROOT_SIZE, L"\\\\?\\GLOBALROOT" );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"StringCchPrintf failed: %#x", ft.hr);

            CopyMemory(wszDeviceName+GLOBALROOT_SIZE,
                        pMountDevName->Name,
                        pMountDevName->NameLength
                      );
            // appending terminating NULL
            wszDeviceName[pMountDevName->NameLength/2 + GLOBALROOT_SIZE] = L'\0';
        }
    }

    return ERROR_SUCCESS;
}

// VolumeMountPointExists is currently written specifically to verify the existence of a mountpoint
// as defined by the WMI Win32_MountPoint Directory reference string.  This string names the directory
// such that the trailing backslash appears only on root directories.  This is a basic assumption
// made by this function.  It is not general purpose.  The calling code should be changed to append
// the trailing backslash so that this function can be generalized.  Mount points are enumerated
// by GetVolumePathNamesForVolumeName API with trailing backslashes.
BOOL
VolumeMountPointExists(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDirectory
    )
{
    CVssAutoPWSZ awszMountPoints;
    WCHAR* pwszCurrentMountPoint = NULL;
    BOOL fFound = FALSE;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"VolumeMountPointExists");
    
    // Get the length of the multi-string array
    DWORD cchVolumesBufferLen = 0;
    BOOL bResult = GetVolumePathNamesForVolumeName(
                                pwszVolume,
                                NULL,
                                0,
                                &cchVolumesBufferLen);
    if (!bResult && (GetLastError() != ERROR_MORE_DATA))
        ft.TranslateGenericError(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
            L"GetVolumePathNamesForVolumeName(%s, 0, 0, %p)", pwszVolume, &cchVolumesBufferLen);

    // Allocate the array
    awszMountPoints.Allocate(cchVolumesBufferLen);

    // Get the mount points
    // Note: this API was introduced in WinXP so it will need to be replaced if backported
    bResult = GetVolumePathNamesForVolumeName(
                                pwszVolume,
                                awszMountPoints,
                                cchVolumesBufferLen,
                                NULL);
    if (!bResult)
        ft.Throw(VSSDBG_VSSADMIN, HRESULT_FROM_WIN32(GetLastError()),
            L"GetVolumePathNamesForVolumeName(%s, %p, %lu, 0)", pwszVolume, awszMountPoints, cchVolumesBufferLen);

    // If the volume has mount points
    pwszCurrentMountPoint = awszMountPoints;
    if ( pwszCurrentMountPoint[0] )
    {
        while(true)
        {
            // End of iteration?
            LONG lCurrentMountPointLength = (LONG) ::wcslen(pwszCurrentMountPoint);
            if (lCurrentMountPointLength == 0)
                break;

            // Only a root directory should have a trailing backslash character
            if (lCurrentMountPointLength > 2 &&
                pwszCurrentMountPoint[lCurrentMountPointLength-1] == L'\\' && 
                pwszCurrentMountPoint[lCurrentMountPointLength-2] != L':')
            {
                    pwszCurrentMountPoint[lCurrentMountPointLength-1] = L'\0';
            }

            if (_wcsicmp(pwszDirectory, pwszCurrentMountPoint) == 0)
            {
                fFound = TRUE;                
                break;
            }

            // Go to the next one. Skip the zero character.
            pwszCurrentMountPoint += lCurrentMountPointLength + 1;
        }
    }

    return fFound;
}

void
DeleteVolumeDriveLetter(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDrivePath
    )
{
    BOOL fVolumeLocked = FALSE;
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    DWORD dwRet = 0;
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"DeleteVolumeDriveLetter");

    _ASSERTE(pwszVolume != NULL);
    _ASSERTE(pwszDrivePath != NULL);
    
    // Try to lock the volume
    DWORD cch = wcslen(pwszVolume);
    pwszVolume[cch - 1] = 0;
    hVolume = CreateFile(
                                    pwszVolume, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    NULL,
                                    NULL
                                    );
    pwszVolume[cch - 1] = '\\';

    if (hVolume == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        ft.hr = HRESULT_FROM_WIN32(dwRet);
        ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"CreateFile(OPEN_EXISTING) failed for %lS, %#x", pwszVolume, dwRet);
    }

    dwRet = LockVolume(hVolume);
    if (dwRet == ERROR_SUCCESS)
    {
        fVolumeLocked = TRUE;
        ft.Trace(VSSDBG_VSSADMIN,
            L"volume %lS locked", pwszVolume);
    }
    else
    {
        ft.Trace(VSSDBG_VSSADMIN,
            L"Unable to lock volume %lS, %#x", pwszVolume, dwRet);
    }

    try
    {        
        if (fVolumeLocked)
        {
            // If volume is locked delete the mount point
            if (!DeleteVolumeMountPoint(pwszDrivePath))
            {
                dwRet = GetLastError();
                ft.hr = HRESULT_FROM_WIN32(dwRet);
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DeleteVolumeMountPoint failed %#x, drivepath<%lS>", dwRet, pwszDrivePath);
            }
        }
        else
        {
            // Otherwise, remove the entry from the volume mgr database only
            // The volume will still be accessible through the drive letter until reboot
            ft.hr = DeleteDriveLetterFromDB(pwszDrivePath);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DeleteDriveLetterFromDB failed %#x, drivepath<%lS>", ft.hr, pwszDrivePath);
        }
    }
    catch (...)
    {
        CloseHandle(hVolume);
        throw;
    }

    CloseHandle(hVolume);
}

HRESULT
DeleteDriveLetterFromDB(
    IN WCHAR* pwszDriveLetter)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"DeleteDriveLetterFromDB");

    MOUNTMGR_MOUNT_POINT    *InputMountPoint=NULL;
    MOUNTMGR_MOUNT_POINTS   *OutputMountPoints=NULL;
    ULONG ulInputSize = 0;
    HANDLE hMountMgr = INVALID_HANDLE_VALUE;
    DWORD dwBytesReturned = 0;
    DWORD dwRet = 0;
    BOOL bRet = FALSE;

    _ASSERTE(pwszDriveLetter != NULL);
    
    //
    // Prepare IOCTL_MOUNTMGR_QUERY_POINTS input
    //

    ulInputSize = sizeof(MOUNTMGR_MOUNT_POINT) + SYMBOLIC_LINK_LENGTH;
    InputMountPoint = (MOUNTMGR_MOUNT_POINT *) new BYTE[ulInputSize];
    
    if ( InputMountPoint==NULL )
    {
        ft.hr = E_OUTOFMEMORY;
        return ft.hr;
    }

    ZeroMemory(InputMountPoint, ulInputSize);
    InputMountPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    InputMountPoint->SymbolicLinkNameLength = SYMBOLIC_LINK_LENGTH;
    InputMountPoint->UniqueIdOffset         = 0;
    InputMountPoint->UniqueIdLength         = 0;
    InputMountPoint->DeviceNameOffset       = 0;
    InputMountPoint->DeviceNameLength       = 0;

    //
    // Fill device name.
    //

    WCHAR       wszBuffer[SYMBOLIC_LINK_LENGTH/2+1];
    LPWSTR      pwszBuffer;

    pwszBuffer = (LPWSTR)((PCHAR)InputMountPoint + 
                        InputMountPoint->SymbolicLinkNameOffset);
    pwszDriveLetter[0] = towupper(pwszDriveLetter[0]);
    ft.hr = StringCchPrintf(wszBuffer, SYMBOLIC_LINK_LENGTH/2+1, L"\\DosDevices\\%c:", pwszDriveLetter[0] );
    if (ft.HrFailed())
    {
        ft.Trace(VSSDBG_VSSADMIN, L"StringCchPrintf failed %#x", ft.hr);
        goto _bailout;
    }
    memcpy(pwszBuffer, wszBuffer, SYMBOLIC_LINK_LENGTH);

    //
    // Allocate space for output
    //

    OutputMountPoints = (MOUNTMGR_MOUNT_POINTS *) new WCHAR[4096];
    if ( OutputMountPoints==NULL )
    {
        ft.hr = E_OUTOFMEMORY;
        goto _bailout;
    }

    //
    // Open mount manager
    //

    hMountMgr = CreateFile( MOUNTMGR_DOS_DEVICE_NAME, 
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                          );
    if ( hMountMgr==INVALID_HANDLE_VALUE )
    {
        dwRet = GetLastError();
        ft.hr = HRESULT_FROM_WIN32(dwRet);
        ft.Trace(VSSDBG_VSSADMIN, L"DeleteDriveLetterFromDB CreateFile failed %#x", dwRet);
        goto _bailout;
    }

    //
    // Issue IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
    //

    bRet = DeviceIoControl( hMountMgr,
                            IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY,
                            InputMountPoint,
                            ulInputSize,
                            OutputMountPoints,
                            4096 * sizeof(WCHAR),
                            &dwBytesReturned,
                            NULL 
                          );

    dwRet = GetLastError(); // Save error code.
    
    CloseHandle(hMountMgr);
    hMountMgr = NULL;

    if ( bRet==FALSE )
    {
        ft.hr = HRESULT_FROM_WIN32(dwRet);
        ft.Trace(VSSDBG_VSSADMIN, L"DeleteDriveLetterFromDB DeviceIoControl failed %#x", dwRet);
        goto _bailout;
    }

    delete [] InputMountPoint;
    delete [] OutputMountPoints;
    return S_OK;

_bailout:

    delete [] InputMountPoint;
    delete [] OutputMountPoints;
    return ft.hr;
}

DWORD
LockVolume(
    IN HANDLE hVolume
    )
{
    DWORD dwBytes = 0;
    BOOL fRet = FALSE;
    int nCount = 0;
    
    while ( fRet==FALSE )
    {
        fRet = DeviceIoControl(
                                hVolume,
                                FSCTL_LOCK_VOLUME,
                                NULL,
                                0,
                                NULL,
                                0,
                                &dwBytes,
                                NULL
                            );
        if (fRet == FALSE)
        {
            DWORD dwRet = GetLastError();

            if (dwRet != ERROR_ACCESS_DENIED || nCount>=60)
            {
                return dwRet;
            }

            nCount++;
            Sleep( 500 );       // Wait for half second up to 60 times (30s).
        }
    }

    return ERROR_SUCCESS;
}

// Returns TRUE if the drive letter is available
BOOL IsDriveLetterAvailable (
    IN WCHAR* pwszDriveLetter
)
{
    int iLen = 0;
    BOOL fFound = FALSE;
    DWORD cchBufLen = 0;
    CVssAutoPWSZ awszDriveStrings;
    
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"IsDriveLetterAvailable");

    _ASSERTE(pwszDriveLetter != NULL);
    
    // How much space needed for drive strings?
    cchBufLen = GetLogicalDriveStrings(0, NULL);
    if (cchBufLen == 0)
    {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.Trace(VSSDBG_VSSADMIN, L"GetLogicalDriveStrings failed %#x", GetLastError());
    }
    else
    {
        // Allocate space for the drive strings
        awszDriveStrings.Allocate(cchBufLen);

        // Get the drive strings
        if (GetLogicalDriveStrings(cchBufLen, awszDriveStrings) == 0)
        {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.Trace(VSSDBG_VSSADMIN, L"GetLogicalDriveStrings failed %#x", GetLastError());
        }
        else
        {
            WCHAR* pwcTempDriveString = awszDriveStrings;
            WCHAR wcDriveLetter = towupper(pwszDriveLetter[0]);

            // Look for the drive letter in the list of system drive letters
            while (!fFound)
            {                
                iLen = lstrlen(pwcTempDriveString);
                if (iLen == 0)
                    break;

                pwcTempDriveString[0] = towupper(pwcTempDriveString[0]);

                if (pwcTempDriveString[0] == wcDriveLetter)
                {                    
                    fFound = TRUE;
                    break;
                }
                
                pwcTempDriveString = &pwcTempDriveString [iLen + 1];
            }
        }
    }

    return !fFound;
}

BOOL
IsDriveLetterSticky(
    IN WCHAR* pwszDriveLetter
    )
{
    BOOL fFound = FALSE;
    WCHAR wszTempVolumeName [MAX_PATH+1];
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"IsDriveLetterSticky");
    WCHAR wszDrivePath[g_cchDriveName];
    
    _ASSERTE(pwszDriveLetter != NULL);    

    wszDrivePath[0] = towupper(pwszDriveLetter[0]);
    wszDrivePath[1] = L':';
    wszDrivePath[2] = L'\\';
    wszDrivePath[3] = L'\0';
    
    if (GetVolumeNameForVolumeMountPoint(
                    wszDrivePath,
                    wszTempVolumeName,
                    MAX_PATH))
    {
        WCHAR wszCurrentDrivePath[g_cchDriveName];
        if (GetVolumeDrive(wszTempVolumeName, g_cchDriveName, wszCurrentDrivePath))
        {
            wszCurrentDrivePath[0] = towupper(wszCurrentDrivePath[0]);
            if (wszDrivePath[0] == wszCurrentDrivePath[0])
                fFound = TRUE;
        }
    }
    
    return fFound;
}

BOOL
IsBootDrive(
    IN WCHAR* pwszDriveLetter
    )
{
    WCHAR wszSystemDirectory[MAX_PATH+1];
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"IsBootDrive");

    _ASSERTE(pwszDriveLetter != NULL);

    WCHAR wcDrive = towupper(pwszDriveLetter[0]);
    
    if (!GetSystemDirectory(wszSystemDirectory, MAX_PATH+1))
    {
        DWORD dwErr = GetLastError();
        ft.hr = HRESULT_FROM_WIN32(dwErr);
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GetSystemDirectory failed %#x", dwErr);
    }
    wszSystemDirectory[0] = towupper(wszSystemDirectory[0]);
    
    if (wcDrive == wszSystemDirectory[0])
        return TRUE;
    
    return FALSE;
}

BOOL
DeleteNetworkShare(
        IN WCHAR*  pwszDriveRoot
    )
{
    NET_API_STATUS status;
    WCHAR wszShareName[3];

    wszShareName[0] = pwszDriveRoot[0];
    wszShareName[1] = L'$';
    wszShareName[2] = L'\0';
    
    status = NetShareDel(NULL, wszShareName, 0);
    if ( status!=NERR_Success )
        return FALSE;
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\vdsclasses.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name:
//      VdsClasses.h
//
//  Implementation File:
//      VdsClasses.cpp
//
//  Description:
//      Definition of the VDS WMI Provider classes.
//
//  Author:   Jim Benton (jbenton) 15-Jan-2002
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

extern CRITICAL_SECTION g_csThreadData;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CVolume
//
//  Description:
//      Provider Implementation for Volume
//
//--
//////////////////////////////////////////////////////////////////////////////
class CVolume : public CProvBase
{
//
// constructor
//
public:
    CVolume(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    ~CVolume()
        { }

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize();

private:

    void LoadInstance(
        IN WCHAR* pwszVolume,
        IN OUT IWbemClassObject* pObject);

    BOOL IsValid(
        IN WCHAR* pwszVolume);
    
    BOOL IsDirty(
        IN WCHAR* pwszVolume);
    
    BOOL IsMountable(
        IN WCHAR* pwszVolume);

    BOOL HasMountPoints(
        IN WCHAR* pwszVolume);
    
    HRESULT
    ExecAddMountPoint(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecMount(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecDismount(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecDefrag(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecDefragAnalysis(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecChkdsk(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecScheduleAutoChk(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecExcludeAutoChk(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    HRESULT
    ExecFormat(
        IN BSTR bstrObjPath,
        IN WCHAR* pwszMethodName,
        IN long lFlag,
        IN IWbemClassObject* pParams,
        IN IWbemObjectSink* pHandler);
        
    DWORD AddMountPoint(
        IN WCHAR* pwszVolume,
        IN WCHAR* pwszDirectory);
        
    DWORD Mount(
        IN WCHAR* pwszVolume);
        
    DWORD Dismount(
        IN WCHAR* pwszVolume,
        IN BOOL fForce,
        IN BOOL fPermanent);
        
    DWORD
    Defrag(
        IN WCHAR* pwszVolume,
        OUT BOOL fForce,
        IN IWbemObjectSink* pHandler,
        IN OUT IWbemClassObject* pObject);

    DWORD
    DefragAnalysis(
        IN WCHAR* pwszVolume,
        OUT BOOL* pfDefragRecommended,
        IN OUT IWbemClassObject* pObject);

    DWORD
    Chkdsk(
        IN WCHAR* pwszVolume,
        IN BOOL fFixErrors,
        IN BOOL fVigorousIndexCheck,
        IN BOOL fSkipFolderCycle,
        IN BOOL fForceDismount,
        IN BOOL fRecoverBadSectors,
        IN BOOL fOkToRunAtBootup
	 );

    DWORD
    AutoChk(
        IN const WCHAR* pwszAutoChkCommand,
        IN WCHAR* pwmszVolumes
        );
    
    DWORD
    Format(
        IN WCHAR* pwszVolume,
        IN BOOL fQuickFormat,
        IN BOOL fEnableCompression,
        IN WCHAR* pwszFileSystem,
        IN DWORD cbAllocationSize,
        IN WCHAR* pwszLabel,
        IN IWbemObjectSink* pHandler
        );

    void
    SetDriveLetter(
        IN WCHAR* pwszVolume,
        IN WCHAR* pwszDrive
        );

    void
    SetLabel(
        IN WCHAR* pwszVolume,
        IN WCHAR* pwszLabel
        );
    
    void
    SetContentIndexing(
        IN WCHAR* pwszVolume,
        IN BOOL fIndexingEnabled
        );

    void
    SetQuotasEnabled(
        IN WCHAR* pwszVolume,
        IN BOOL fQuotasEnabled
        );    

}; // class CVolume



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CMountPoint
//
//  Description:
//      Provider Implementation for Volume
//
//--
//////////////////////////////////////////////////////////////////////////////
class CMountPoint : public CProvBase
{
//
// constructor
//
public:
    CMountPoint(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    ~CMountPoint(){ }

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize();

private:

    void LoadInstance(
        IN WCHAR* pwszVolume,
        IN WCHAR* pwszDirectory,
        IN OUT IWbemClassObject* pObject);

}; // class CMountPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\vdswmi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: vdswmi.cpp
//
//  Implementation of the provider registration and entry point.
//
//  Author:    MSP Prabu  (mprabu)  04-Dec-2000
//             Jim Benton (jbenton) 15-Oct-2000
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <initguid.h>
#include "ProvFactory.h"
#include "InstanceProv.h"

////////////////////////////////////////////////////////////////////////
////  Standard foo for file name aliasing.  This code block must be after
////  all includes of VDS header files.
////
#ifdef VDS_FILE_ALIAS
#undef VDS_FILE_ALIAS
#endif
#define VDS_FILE_ALIAS "VDSWMIPR"
////
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////

const int g_cchRegkey = 128;

// {890CB943-D715-401b-98B1-CF82DCF36D7C}
DEFINE_GUID(CLSID_VDS_PROVIDER, 
0x890CB943, 
0xD715, 
0x401b, 
0x98, 0xB1, 0xCF, 0x82, 0xDC, 0xF3, 0x6D, 0x7C);


// Count number of objects and number of locks.

long        g_cObj = 0;
long        g_cLock = 0;
HMODULE     g_hModule;

FactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_VDS_PROVIDER,
        CInstanceProv::S_HrCreateThis,
        PVD_WBEM_PROVIDERNAME
    }
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  WINAPI
//  DllMain(
//      HANDLE  hModule,
//      DWORD   ul_reason_for_call,
//      LPVOID  lpReserved
//      )
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      hModule             -- DLL module handle.
//      ul_reason_for_call  -- 
//      lpReserved          -- 
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HANDLE  hModule,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
	g_hModule = static_cast< HMODULE >( hModule );
    if (dwReason == DLL_PROCESS_ATTACH)
    {
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }
    return TRUE;

} //*** DllMain()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllCanUnloadNow( void )
//
//  Description:
//      Called periodically by Ole in order to determine if the
//      DLL can be freed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = ( 0L == g_cObj && 0L == g_cLock ) ? S_OK : S_FALSE;
    return sc;

} //*** DllCanUnloadNow()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllRegisterServer( void )
//
//  Description:
//      Called during setup or by regsvr32.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{   
    WCHAR   wszID[ g_cchGUID ];
    WCHAR   wszCLSID[ g_cchRegkey ];
    WCHAR   wszModule[ MAX_PATH ];
    INT     idx;
    WCHAR * pwszModel   = L"Both";
    HKEY    hKey1 = NULL;
    HKEY    hKey2 = NULL;
    DWORD   dwRet        =  ERROR_SUCCESS;
    INT     cArray      = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    // Create the path.
    try
    {
        for ( idx = 0 ; idx < cArray && dwRet == ERROR_SUCCESS ; idx++ )
        {
            LPCWSTR pwszName = g_FactoryDataArray[ idx ].m_pwszRegistryName;

            dwRet = StringFromGUID2(
                *g_FactoryDataArray[ idx ].m_pCLSID,
                wszID,
                g_cchGUID
                );

            if (dwRet == 0)
            {
                dwRet = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            if (FAILED(StringCchPrintf(wszCLSID, g_cchRegkey, L"Software\\Classes\\CLSID\\%lS", wszID)))
            {
                dwRet = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            wszCLSID[g_cchRegkey - 1] = L'\0';

            // Create entries under CLSID

            dwRet = RegCreateKeyW(
                        HKEY_LOCAL_MACHINE,
                        wszCLSID,
                        &hKey1
                        );
            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            dwRet = RegSetValueEx(
                        hKey1,
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) pwszName,
                        sizeof( WCHAR ) * (lstrlenW( pwszName ) + 1)
                        );
            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            dwRet = RegCreateKeyW(
                        hKey1,
                        L"InprocServer32",
                        & hKey2
                        );

            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            GetModuleFileName( g_hModule, wszModule, MAX_PATH );

            dwRet = RegSetValueEx(
                        hKey2,
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) wszModule,
                        sizeof( WCHAR ) * (lstrlen( wszModule ) + 1)
                        );

            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            dwRet = RegSetValueExW(
                        hKey2,
                        L"ThreadingModel",
                        0,
                        REG_SZ,
                        (BYTE *) pwszModel,
                        sizeof( WCHAR ) * (lstrlen( pwszModel ) + 1)
                        );
            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }
 
            RegCloseKey( hKey1 );
            hKey1 = NULL;
            RegCloseKey( hKey2 );
            hKey2 = NULL;
        } // for: each entry in factory entry array 
    }
    catch ( ... )
    {
          dwRet = SELFREG_E_CLASS;
    }
    
    if (hKey1 != NULL)
        RegCloseKey( hKey1 );
    if (hKey2 != NULL)
        RegCloseKey( hKey2 );
    
    return dwRet;

} //*** DllRegisterServer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllUnregisterServer( void )
//
//  Description:
//      Called when it is time to remove the registry entries.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
    WCHAR   wszID[ g_cchGUID ];
    WCHAR   wszCLSID[ g_cchRegkey ];
    HKEY    hKey;
    INT     idx;
    DWORD   dwRet   = ERROR_SUCCESS;
    INT     cArray  = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < cArray && dwRet == ERROR_SUCCESS ; idx++ )
    {
       dwRet = StringFromGUID2(
            *g_FactoryDataArray[ idx ].m_pCLSID,
            wszID,
            g_cchGUID
            );

        if (dwRet == 0)
        {
            dwRet = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if (FAILED(StringCchPrintf(wszCLSID, g_cchRegkey, L"Software\\Classes\\CLSID\\%lS", wszID)))
        {
            dwRet = ERROR_INSUFFICIENT_BUFFER;
            break;
        }
        wszCLSID[g_cchRegkey - 1] = L'\0';

        // First delete the InProcServer subkey.

        dwRet = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    wszCLSID,
                    &hKey
                    );
        if ( dwRet != ERROR_SUCCESS )
        {
            continue;
        }
        
        dwRet = RegDeleteKeyW( hKey, L"InProcServer32" );
        RegCloseKey( hKey );

        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }

        dwRet = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Classes\\CLSID",
                    &hKey
                    );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
        
        dwRet = RegDeleteKeyW( hKey,wszID );
        RegCloseKey( hKey );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
    } // for: each object
    
    //if ( dwRet != ERROR_SUCCESS )
    //{
    //    dwRet = SELFREG_E_CLASS;
    //}

    return S_OK;

} //*** DllUnregisterServer()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllGetClassObject(
//      REFCLSID    rclsidIn,
//      REFIID      riidIn,
//      PPVOID      ppvOut
//      )
//
//  Description:
//      Called by Ole when some client wants a class factory.  Return
//      one only if it is the sort of class this DLL supports.
//
//  Arguments:
//      rclsidIn    --
//      riidIn      --
//      ppvOut      --
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      E_OUTOFMEMORY
//      E_FAIL
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    PPVOID      ppvOut
    )
{

    HRESULT         hr;
    CProvFactory *  pObj = NULL;
    UINT            idx;
    UINT            cDataArray = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < cDataArray ; idx++ )
    {
        if ( IsEqualCLSID(rclsidIn, *g_FactoryDataArray[ idx ].m_pCLSID) )
        {
            pObj= new CProvFactory( &g_FactoryDataArray[ idx ] );
            if ( NULL == pObj )
            {
                return E_OUTOFMEMORY;
            }

            hr = pObj->QueryInterface( riidIn, ppvOut );

            if ( FAILED( hr ) )
            {
                delete pObj;
            }

            return hr;
        }
    }
    return E_FAIL;

} //*** DllGetClassObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\volutil.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002-2004 Microsoft Corporation
//
//  Module Name: volutil.h
//
//  Description:    
//      Utility functions for handling volumes
//
//  Author:   Jim Benton (jbenton) 30-Apr-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#define GLOBALROOT_SIZE             14      // \\?\GLOBALROOT

BOOL
GetVolumeDrive(
    IN WCHAR* pwszVolumePath,
    IN DWORD  cchDriveName, 
    OUT WCHAR* pwszDriveNameBuf
    );

BOOL
VolumeSupportsQuotas(
    IN WCHAR* pwszVolume
    );

BOOL
VolumeIsValid(
    IN WCHAR* pwszVolume
    );

DWORD
VolumeIsDirty(
    IN WCHAR* pwszVolume,
    OUT BOOL* pfDirty
    );

BOOL
VolumeIsMountable(
    IN WCHAR* pwszVolume
    );
BOOL
VolumeHasMountPoints(
    IN WCHAR* pwszVolume
    );

BOOL
VolumeIsReady(
    IN WCHAR* pwszVolume
    );

BOOL
VolumeIsFloppy(
    IN WCHAR* pwszVolume
    );

BOOL
VolumeIsSystem(
    IN WCHAR* pwszVolume
    );

BOOL
VolumeHoldsPagefile(
    IN WCHAR* pwszVolume
    );


DWORD
GetDeviceName(
    IN  WCHAR* pwszVolume,
    OUT WCHAR wszDeviceName[MAX_PATH+GLOBALROOT_SIZE]
    );

BOOL
VolumeMountPointExists(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDirectory
    );

void
DeleteVolumeDriveLetter(
    IN WCHAR* pwszVolume,
    IN WCHAR* pwszDrivePath
    );

HRESULT
DeleteDriveLetterFromDB(
    IN WCHAR* pwszDriveLetter
    );

DWORD
LockVolume(
    IN HANDLE hVolume
    );

BOOL IsDriveLetterAvailable (
    IN WCHAR* pwszDriveLetter
);

BOOL
IsDriveLetterSticky(
    IN WCHAR* pwszDriveLetter
    );

BOOL
IsBootDrive(
    IN WCHAR* pwszDriveLetter
    );

BOOL
DeleteNetworkShare(
        IN WCHAR*  pwszDriveRoot
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\instanceprov.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.cpp
//
//  Description:    
//      Implementation of CInstanceProv class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//        MSP Prabu  (mprabu)  06-Jan-2001
//        Jim Benton (jbenton) 15-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "Pch.h"
#include "InstanceProv.h"
#include "VssClasses.h"
#include "msg.h"

BOOL MapVssErrorToMsgAndWMIStatus(
    IN HRESULT hr,
    OUT LONG* plMsgNum,
    OUT HRESULT* pHr
    );

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

long                g_lNumInst = 0;
ClassMap         g_ClassMap;

//****************************************************************************
//
//  CInstanceProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoCreateInstanceEnumAsync
//
//  Description:
//      Enumerate instance for a given class.
//
//  Arguments:
//      bstrRefStr    -- Name the class to enumerate
//      lFlags        -- WMI flag
//      pCtx          -- WMI context
//      pHandler      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::DoCreateInstanceEnumAsync(
    IN BSTR bstrRefStr,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    
    HRESULT hr = WBEM_S_NO_ERROR;
    if (bstrRefStr == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        auto_ptr<CProvBase> pProvBase;

        CreateClass(bstrRefStr, m_pNamespace, pProvBase);

        hr = pProvBase->EnumInstance(
            lFlags,
            pCtx,
            pHandler
            );
        
        if (FAILED(hr))
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
    
} //*** CInstanceProv::DoCreateInstanceEnumAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoGetObjectAsync
//
//  Description:
//      Creates an instance given a particular path value.
//
//  Arguments:
//      bstrObjectPath    -- Object path to an object
//      lFlags            -- WMI flag
//      pCtx              -- WMI context
//      pHandler          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::DoGetObjectAsync(
    IN BSTR bstrObjectPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    HRESULT hr = S_OK;
    if (bstrObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        CObjPath ObjPath;
        _bstr_t bstrClass;
        auto_ptr<CProvBase> pProvBase;

        if (!ObjPath.Init( bstrObjectPath))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();

        CreateClass(bstrClass, m_pNamespace, pProvBase);

        hr = pProvBase->GetObject(
            ObjPath,
            lFlags,
            pCtx,
            pHandler
            );

        if (FAILED(hr))
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;

} //*** CInstanceProv::DoGetObjectAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoPutInstanceAsync
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      pInst         -- WMI object to be saved
//      lFlags        -- WMI flag
//      pCtx          -- WMI context
//      pHandler      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CInstanceProv::DoPutInstanceAsync(
    IN IWbemClassObject* pInst,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    
    HRESULT hr = S_OK;
    if (pInst == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        _variant_t varClass;
        auto_ptr<CProvBase> pProvBase;
        CWbemClassObject wcoSrc(pInst);

        hr = pInst->Get(L"__CLASS", 0, &varClass, 0, 0);
        
        CreateClass(varClass.bstrVal, m_pNamespace, pProvBase);

        hr = pProvBase->PutInstance(
            wcoSrc,
            lFlags,
            pCtx,
            pHandler
            );

        if (FAILED(hr))
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
} //*** CInstanceProv::DoPutInstanceAsync()
 
//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoDeleteInstanceAsync
//
//  Description:
//      Delete this instance.
//
//  Arguments:
//      bstrObjectPath    -- ObjPath for the instance to be deleted
//      lFlags            -- WMI flag
//      pCtx              -- WMI context
//      pHandler          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////      
HRESULT
CInstanceProv::DoDeleteInstanceAsync(
     IN BSTR bstrObjectPath,
     IN long lFlags,
     IN IWbemContext* pCtx,
     IN IWbemObjectSink* pHandler
     )
{
    HRESULT hr = S_OK;
    if (bstrObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        CObjPath ObjPath;
        _bstr_t bstrClass;
        auto_ptr<CProvBase> pProvBase;

        if (!ObjPath.Init(bstrObjectPath))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();

        CreateClass(bstrClass, m_pNamespace, pProvBase);

        hr = pProvBase->DeleteInstance(
            ObjPath,
            lFlags,
            pCtx,
            pHandler
            );

        if (FAILED(hr))
        {
            CProvException exception( hr );
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;

} //*** CInstanceProv::DoDeleteInstanceAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::DoExecMethodAsync
//
//  Description:
//      Execute methods for the given object.
//
//  Arguments:
//      bstrObjectPath    -- Object path to a given object
//      bstrMethodName    -- Name of the method to be invoked
//      lFlags            -- WMI flag
//      pCtx              -- WMI context
//      pInParams         -- Input parameters for the method
//      pHandler          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::DoExecMethodAsync(
    IN BSTR bstrObjectPath,
    IN BSTR bstrMethodName,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemClassObject* pInParams,
    IN IWbemObjectSink* pHandler
    )
{
    HRESULT hr = S_OK;
    if (bstrObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL
        || bstrMethodName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    try
    {
        CObjPath ObjPath;
        _bstr_t bstrClass;
        auto_ptr<CProvBase> pProvBase;

        if (!ObjPath.Init(bstrObjectPath))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();

        CreateClass(bstrClass, m_pNamespace, pProvBase);

        hr = pProvBase->ExecuteMethod(
                bstrObjectPath,
                bstrMethodName,
                lFlags,
                pInParams,
                pHandler
                );

        if ( FAILED( hr ) )
        {
            CProvException exception(hr);
            hr = SetExtendedStatus(exception, &pHandler);
        } 
        else  // Set status OK
        {
            pHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0);
        }
    }
    catch (CProvException& prove)
    {
        hr = SetExtendedStatus(prove, &pHandler);
    }
    catch (_com_error& err)
    {
        CProvException exception(err.Error());
        hr = SetExtendedStatus(exception, &pHandler);
    }
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;

} //*** CInstanceProv::DoExecMethodAsync()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::SetExtendedStatus
//
//  Description:
//      Create and set extended error status.
//
//  Arguments:
//      rpeIn       -- Exception object.
//      rwcoInstOut -- Reference to WMI instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//  Note:
//      Do not allow CProvException, _com_error or HRESULT exceptions through
//      this function is called to handle these exceptions.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::SetExtendedStatus(
    IN CProvException &    rpe,
    IN IWbemObjectSink **  ppHandler
    )
{
    HRESULT hr         = WBEM_S_NO_ERROR;
    HRESULT hrStatus = WBEM_S_NO_ERROR; 
    CComPtr<IWbemClassObject> spStatus;
    WCHAR* pwszErrorMsg = NULL;

    try
    {    
        hr =  m_pNamespace->GetObject(
                    _bstr_t(PVD_WBEM_EXTENDEDSTATUS),
                    0,
                    NULL,
                    &spStatus,
                    NULL
                    );
        
        if (SUCCEEDED(hr))
        {
            CWbemClassObject wcoInst;
            
            hr = spStatus->SpawnInstance(0, &wcoInst);
            if (SUCCEEDED(hr))
            {
                _bstr_t bstrError;
                LONG lMsg = 0;

                if (MapVssErrorToMsgAndWMIStatus(rpe.hrGetError(), &lMsg, &hrStatus))
                {
                    // Auto-delete string
                    CVssAutoPWSZ awszMsg(GetMsg(lMsg));
                    
                    // The following may throw CProvException
                    wcoInst.SetProperty(awszMsg, PVD_WBEM_DESCRIPTION);
                }
                else
                {
                    if (rpe.PwszErrorMessage())
                    {
                        bstrError = rpe.PwszErrorMessage();
                        if (rpe.PwszGetErrorHelpInfo())
                        {
                            bstrError += L" ";
                            bstrError += rpe.PwszGetErrorHelpInfo();
                        }
                    }
                    else if (rpe.PwszGetErrorHelpInfo())
                    {
                        bstrError = rpe.PwszGetErrorHelpInfo();
                    }
                    
                    // The following may throw CProvException
                    wcoInst.SetProperty((WCHAR*)bstrError, PVD_WBEM_DESCRIPTION);
                }
                
                wcoInst.SetProperty(rpe.hrGetError(), PVD_WBEM_STATUSCODE);
                wcoInst.SetProperty(PVD_WBEM_PROVIDERNAME, PVD_WBEM_PROP_PROVIDERNAME);

                hr = (*ppHandler)->SetStatus(
                        0,
                        hrStatus,
                        0,
                        wcoInst.data( )
                        );          

                hr = hrStatus;
                
            }
        }
    }
    catch (CProvException& prove)
    {
        hr = prove.hrGetError();
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }

    return hr;
    
} //*** CInstanceProv::SetExtendedStatus()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pUnknownOuterIn -- Outer IUnknown pointer.
//      ppvOut          -- Receives the created instance pointer.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::S_HrCreateThis(
    IN IUnknown*  ,// pUnknownOuterIn,
    OUT VOID**     ppv
    )
{
    _ASSERTE(ppv != NULL);
    *ppv = new CInstanceProv();
    return S_OK;

} //*** CInstanceProv::S_HrCreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CInstanceProv::Initialize
//
//  Description:
//      Initialize the instance provider.
//
//  Arguments:
//      pszUserIn       -- 
//      lFlagsIn        -- WMI flag
//      pszNamespaceIn  -- 
//      pszLocaleIn     -- 
//      pNamespaceIn    -- 
//      pCtxIn          -- WMI context
//      pInitSinkIn     -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CInstanceProv::Initialize(
    IN LPWSTR pszUser,
    IN LONG lFlags,
    IN LPWSTR pszNamespace,
    IN LPWSTR pszLocale,
    IN IWbemServices* pNamespace,
    IN IWbemContext* pCtx,
    IN IWbemProviderInitSink* pInitSink
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (!m_fInitialized)
        {
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_PROVIDER,
                CClassCreator(CProvider::S_CreateThis, PVDR_CLASS_PROVIDER)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_SHADOW,
                CClassCreator(CShadow::S_CreateThis, PVDR_CLASS_SHADOW)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_SHADOWFOR,
                CClassCreator(CShadowFor::S_CreateThis, PVDR_CLASS_SHADOWFOR)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_SHADOWBY,
                CClassCreator(CShadowBy::S_CreateThis, PVDR_CLASS_SHADOWBY)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_SHADOWON,
                CClassCreator(CShadowOn::S_CreateThis, PVDR_CLASS_SHADOWON)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_VOLUMESUPPORT,
                CClassCreator(CVolumeSupport::S_CreateThis, PVDR_CLASS_VOLUMESUPPORT)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_DIFFVOLUMESUPPORT,
                CClassCreator(CDiffVolumeSupport::S_CreateThis, PVDR_CLASS_DIFFVOLUMESUPPORT)));
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_STORAGE,
                CClassCreator(CStorage::S_CreateThis, PVDR_CLASS_STORAGE)));
#ifdef ENABLE_WRITERS
            g_ClassMap.insert(ClassMap::value_type(PVDR_CLASS_WRITER,
                CClassCreator(CWriter::S_CreateThis, PVDR_CLASS_WRITER)));
#endif

            hr = CImpersonatedProvider::Initialize(
                    pszUser,
                    lFlags,
                    pszNamespace,
                    pszLocale,
                    pNamespace,
                    pCtx,
                    pInitSink
                    );

            m_fInitialized = TRUE;
        }
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
    }

    return hr;
    
} //*** CInstanceProv::Initialize()


//
//  Returns TRUE if error message was mapped
//
BOOL MapVssErrorToMsgAndWMIStatus(
    IN HRESULT hr,
    OUT LONG* plMsgNum,
    OUT HRESULT* pHr
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"MapVssErrorToMsg" );

    ft.Trace( VSSDBG_VSSADMIN, L"Input HR: 0x%08x", hr );

    _ASSERTE(plMsgNum != NULL);
    _ASSERTE(pHr != NULL);
    
    LONG msg = 0;
    *plMsgNum = 0;
    *pHr = WBEM_E_PROVIDER_FAILURE;
    
    // Let Win32 errors through
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        *pHr = hr;
    }
    // Let WMI errors through
    else if (HRESULT_FACILITY(hr) == FACILITY_ITF && 
                HRESULT_CODE(hr) > 0x1000 && HRESULT_CODE(hr) < 0x108b)
    {
        *pHr = hr;
    }
    else
    {
        switch ( hr ) 
        {
        case E_INVALIDARG:
            msg = MSG_ERROR_INVALID_OPTION_VALUE;
            *pHr = WBEM_E_INVALID_PARAMETER;
            break;
        case E_OUTOFMEMORY:
            msg = MSG_ERROR_OUT_OF_MEMORY;
            *pHr = WBEM_E_OUT_OF_MEMORY;
            break;
        case E_ACCESSDENIED:
            msg = MSG_ERROR_ACCESS_DENIED;
            *pHr = WBEM_E_ACCESS_DENIED;
            break;

            
        // VSS errors
        case VSS_E_PROVIDER_NOT_REGISTERED:
            msg = MSG_ERROR_VSS_PROVIDER_NOT_REGISTERED;
            break;                
        case VSS_E_OBJECT_NOT_FOUND:
            msg = MSG_ERROR_VSS_VOLUME_NOT_FOUND;
            *pHr = WBEM_E_NOT_FOUND;
            break;                                
        case VSS_E_PROVIDER_VETO:
            msg = MSG_ERROR_VSS_PROVIDER_VETO;
            break;                    
        case VSS_E_VOLUME_NOT_SUPPORTED:
            msg = MSG_ERROR_VSS_VOLUME_NOT_SUPPORTED;
            break;
        case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:
            msg = MSG_ERROR_VSS_VOLUME_NOT_SUPPORTED_BY_PROVIDER;
            break;
        case VSS_E_UNEXPECTED_PROVIDER_ERROR:
            msg = MSG_ERROR_VSS_UNEXPECTED_PROVIDER_ERROR;
            break;
        case VSS_E_FLUSH_WRITES_TIMEOUT:
            msg = MSG_ERROR_VSS_FLUSH_WRITES_TIMEOUT;
            break;
        case VSS_E_HOLD_WRITES_TIMEOUT:
            msg = MSG_ERROR_VSS_HOLD_WRITES_TIMEOUT;
            break;
        case VSS_E_UNEXPECTED_WRITER_ERROR:
            msg = MSG_ERROR_VSS_UNEXPECTED_WRITER_ERROR;
            break;
        case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
            msg = MSG_ERROR_VSS_SNAPSHOT_SET_IN_PROGRESS;
            break;
        case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:
            msg = MSG_ERROR_VSS_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED;
            break;
        case VSS_E_UNSUPPORTED_CONTEXT:
            msg = MSG_ERROR_VSS_UNSUPPORTED_CONTEXT;
            *pHr = WBEM_E_INVALID_METHOD_PARAMETERS;
            break;
        case VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED:
            msg = MSG_ERROR_VSS_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED;
            break;
        case VSS_E_INSUFFICIENT_STORAGE:
            msg = MSG_ERROR_VSS_INSUFFICIENT_STORAGE;
            *pHr = WBEM_E_BUFFER_TOO_SMALL;
            break;                    

        case VSS_E_BAD_STATE:
        case VSS_E_CORRUPT_XML_DOCUMENT:
        case VSS_E_INVALID_XML_DOCUMENT:
        case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:
            msg = MSG_ERROR_INTERNAL_VSSADMIN_ERROR;
            break;
        }    
    }

    if ( msg == 0 )
        return FALSE;
    
    *plMsgNum = msg;
    
    ft.Trace( VSSDBG_VSSADMIN, L"Output Msg#: 0x%08x", msg );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\test\valprop\main.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "pch.h"
#include <atlbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <comdef.h>
#include <winioctl.h>
#include <ntddvol.h> // IOCTL_VOLUME_IS_OFFLINE
#include "..\..\..\inc\ntrkcomm.h"
#include "..\..\..\inc\objectpath.h"
#include "..\..\schema.cpp"
#include "..\..\volutil.cpp"

#define INITGUIDS
#include <dskquota.h>

BOOL g_fVerbose = FALSE;

typedef enum _Variation
{
    Variation_None = 0,
    Variation_ValProp,
    Variation_End
} Variation;

void
PrintVerbose(CHAR* pwszFormat, ...)
{
    if (g_fVerbose)
    {
        va_list marker;
        va_start( marker, pwszFormat );
        vprintf(pwszFormat, marker );
        va_end( marker );    
    }
}

class CVolumeValidation
{
public:
    
    CVolumeValidation()
    {
        m_fStatus = TRUE;
        m_wszLabel[0] = L'\0';
        m_wszFileSystem[0] = L'\0';
        m_dwSerialNumber = 0;
        m_cchMaxFileNameLen = 0;
        m_dwFileSystemFlags = 0;
        m_fGotVolumeInformation = FALSE;
        m_fGotQuotaInformation = FALSE;
        m_fGotSizeInformation = FALSE;
        m_cbCapacity = 0;
        m_cbFreeSpace = 0;
        m_fQuotasEnabled = FALSE;
        m_fQuotasIncomplete = FALSE;
        m_fQuotasRebuilding = FALSE;
    }
    ~CVolumeValidation() {}
    BOOL Validate(IWbemClassObject* pIObj);

private:

    CWbemClassObject m_wcoVol;
    BOOL m_fStatus;
    BOOL m_fGotVolumeInformation;
    BOOL m_fGotQuotaInformation;
    BOOL m_fGotSizeInformation;
    _bstr_t m_bstrVolume;
    WCHAR m_wszLabel[g_cchVolumeLabelMax+1];
    WCHAR m_wszFileSystem[g_cchFileSystemNameMax+1];
    DWORD m_dwSerialNumber;
    DWORD m_cchMaxFileNameLen;
    DWORD m_dwFileSystemFlags;
    ULONGLONG m_cbCapacity;
    ULONGLONG m_cbFreeSpace;
    BOOL m_fQuotasEnabled;
    BOOL m_fQuotasIncomplete;
    BOOL m_fQuotasRebuilding;

    void ValidateAutomount();
    void ValidateBlockSize();
    void ValidateBootVolume();
    void ValidateCapacity();
    void ValidateCaptionName();
    void ValidateCompressed();
    void ValidateCrashdump();
    void ValidateDirtyBitSet();
    void ValidateDriveLetter();
    void ValidateDriveType();
    void ValidateFileSystem();
    void ValidateFreeSpace();
    void ValidateIndexingEnabled();
    void ValidateLabel();
    void ValidateMaximumFileNameLength();
    void ValidatePagefile();
    void ValidateQuotasEnabled();
    void ValidateQuotasIncomplete();
    void ValidateQuotasRebuilding();
    void ValidateSerialNumber();
    void ValidateSupportsDiskQuotas();
    void ValidateSupportsFileBasedCompression();
    void ValidateSystemName();    
    void ValidateSystemVolume();    
    
    BOOL ValidatePropertyIsNull(
        IN const WCHAR* pwszName);
    
    BOOL ValidatePropertyNotNull(
        IN const WCHAR* pwszName);
    
    void CompareProperty(
        IN const WCHAR* pwszName,
        IN WCHAR* pwszAPI);

    void CompareProperty(
        IN const WCHAR* pwszName,
        IN DWORD dwAPI);

    void CompareProperty(
        IN const WCHAR* pwszName,
        IN ULONGLONG llAPI);

    void GetVolumeInformationLocal();
    void GetSizeInformation();
    void GetQuotaInformation();
};

void
CVolumeValidation::CompareProperty(
    const WCHAR* pwszName,
    WCHAR* pwszAPI)
{
    _bstr_t bstrWMI;

    m_wcoVol.GetProperty(bstrWMI, pwszName);

    if (pwszAPI == NULL && bstrWMI.length() == 0)
    {
        PrintVerbose("    %lS<%lS> OK\n", pwszName, (WCHAR*)bstrWMI);
    }
    else if (pwszAPI == NULL && bstrWMI.length() != 0)
    {
        m_fStatus = FALSE;
        printf("    Error: %lS<%lS> should be <NULL>\n", pwszName, (WCHAR*)bstrWMI);
    }
    else if (bstrWMI.length() == 0 && wcslen(pwszAPI) == 0)
    {
        PrintVerbose("    %lS<NULL> OK\n", pwszName, (WCHAR*)bstrWMI);
    }
    else if (bstrWMI.length() != 0 && _wcsicmp((WCHAR*)bstrWMI, pwszAPI) == 0)
    {
        PrintVerbose("    %lS<%lS> OK\n", pwszName, (WCHAR*)bstrWMI);
    }
    else
    {
        m_fStatus = FALSE;
        printf("    Error: %lS<NULL> should be <%lS>\n", pwszName, pwszAPI);
    }
}

void
CVolumeValidation::CompareProperty(
    const WCHAR* pwszName,
    ULONGLONG llAPI)
{
    LONGLONG llWMI = 0;

    if (ValidatePropertyNotNull(pwszName))
    {
        m_wcoVol.GetPropertyI64(&llWMI, pwszName);
        
        if (llWMI == llAPI)
        {
            PrintVerbose("    %lS<%I64d> OK\n", pwszName, llWMI);
        }
        else
        {
            m_fStatus = FALSE;
            printf("    Error: %lS<%I64d> should be <%I64d>\n", pwszName, llWMI, llAPI);
        }
    }
}

void
CVolumeValidation::CompareProperty(
    const WCHAR* pwszName,
    DWORD dwAPI)
{
    DWORD dwWMI = 0;

    if (ValidatePropertyNotNull(pwszName))
    {
        m_wcoVol.GetProperty(&dwWMI, pwszName);
        
        if (dwWMI == dwAPI)
        {
            PrintVerbose("    %lS<%d> OK\n", pwszName, dwWMI);
        }
        else
        {
            m_fStatus = FALSE;
            printf("    Error: %lS<%d> should be <%d>\n", pwszName, dwWMI, dwAPI);
        }
    }
}

BOOL
CVolumeValidation::ValidatePropertyIsNull(
    const WCHAR* pwszName)
{
    _variant_t varVal;
    BOOL fStatus = TRUE;

    HRESULT hr = m_wcoVol.data()->Get(
                _bstr_t(pwszName),
                0,
                &varVal,
                NULL,
                NULL
                );

    if (SUCCEEDED(hr))
    {
        if (varVal.vt == VT_NULL)
        {
            PrintVerbose("    %lS<NULL> OK\n", pwszName);
        }
        else
        {
            printf("    Error: %lS should be NULL\n", pwszName);
            m_fStatus = FALSE;
            fStatus = FALSE;
        }
    }
    else
    {
            printf("    Error: %lS not found\n", pwszName);
            m_fStatus = FALSE;
            fStatus = FALSE;
    }

    return fStatus;
}

BOOL
CVolumeValidation::ValidatePropertyNotNull(
    const WCHAR* pwszName)
{
    _variant_t varVal;
    BOOL fStatus = TRUE;

    HRESULT hr = m_wcoVol.data()->Get(
                _bstr_t(pwszName),
                0,
                &varVal,
                NULL,
                NULL
                );

    if (SUCCEEDED(hr))
    {
        if (varVal.vt == VT_NULL)
        {
            printf("    Error: %lS should not be NULL\n", pwszName);
            m_fStatus = FALSE;
            fStatus = FALSE;
        }
    }
    else
    {
            printf("    Error: %lS not found\n", pwszName);
            m_fStatus = FALSE;
            fStatus = FALSE;
    }

    return fStatus;
}

BOOL
CVolumeValidation::Validate(IWbemClassObject* pIVolume)
{
    m_wcoVol = pIVolume;
    
    try
    {
        m_wcoVol.GetProperty(m_bstrVolume, PVDR_PROP_DEVICEID);
        printf("VolumeGUID<%lS>\n", (WCHAR*)m_bstrVolume);

        ValidateSystemName();
        ValidateCaptionName();
        ValidateAutomount();
        ValidateDriveType();

        if (VolumeIsMountable(m_bstrVolume) && VolumeIsReady(m_bstrVolume))
        {
            ValidateBlockSize();
            ValidateBootVolume();
            ValidateCapacity();
            ValidateCompressed();
            ValidateCrashdump();
            ValidateDirtyBitSet();
            ValidateDriveLetter();
            ValidateFileSystem();
            ValidateFreeSpace();
            ValidateIndexingEnabled();
            ValidateLabel();
            ValidateMaximumFileNameLength();
            ValidatePagefile();
            ValidateQuotasEnabled();
            ValidateQuotasIncomplete();
            ValidateQuotasRebuilding();
            ValidateSerialNumber();
            ValidateSupportsDiskQuotas();
            ValidateSupportsFileBasedCompression();
            ValidateSystemVolume();
        }
        else
        {
            ValidatePropertyIsNull(PVDR_PROP_BLOCKSIZE);
            ValidatePropertyIsNull(PVDR_PROP_CAPACITY);
            ValidatePropertyIsNull(PVDR_PROP_COMPRESSED);
            ValidatePropertyIsNull(PVDR_PROP_DIRTYBITSET);
            ValidatePropertyIsNull(PVDR_PROP_FILESYSTEM);
            ValidatePropertyIsNull(PVDR_PROP_FREESPACE);
            ValidatePropertyIsNull(PVDR_PROP_INDEXINGENABLED);
            ValidatePropertyIsNull(PVDR_PROP_LABEL);
            ValidatePropertyIsNull(PVDR_PROP_MAXIMUMFILENAMELENGTH);
            ValidatePropertyIsNull(PVDR_PROP_QUOTASENABLED);
            ValidatePropertyIsNull(PVDR_PROP_QUOTASINCOMPLETE);
            ValidatePropertyIsNull(PVDR_PROP_QUOTASREBUILDING);
            ValidatePropertyIsNull(PVDR_PROP_SERIALNUMBER);
            ValidatePropertyIsNull(PVDR_PROP_SUPPORTSDISKQUOTAS);
        }

        ValidatePropertyIsNull(PVDR_PROP_DESCRIPTION);
        ValidatePropertyIsNull(L"Access");
        ValidatePropertyIsNull(L"Availability");
        ValidatePropertyIsNull(L"ConfigManagerErrorCode");
        ValidatePropertyIsNull(L"ConfigManagerUserConfig");
        ValidatePropertyIsNull(L"CreationClassName");
        ValidatePropertyIsNull(L"ErrorCleared");
        ValidatePropertyIsNull(L"ErrorDescription");
        ValidatePropertyIsNull(L"ErrorMethodology");
        ValidatePropertyIsNull(L"InstallDate");
        ValidatePropertyIsNull(L"LastErrorCode");
        ValidatePropertyIsNull(L"NumberOfBlocks");
        ValidatePropertyIsNull(L"PNPDeviceID");
        ValidatePropertyIsNull(L"PowerManagementCapabilities");
        ValidatePropertyIsNull(L"PowerManagementSupported");
        ValidatePropertyIsNull(L"Purpose");
        ValidatePropertyIsNull(L"Status");
        ValidatePropertyIsNull(L"StatusInfo");
        ValidatePropertyIsNull(L"SystemCreationClassName");
        
#ifdef NEVER        
            ft.hr = CoCreateInstance(
                    CLSID_DiskQuotaControl,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IDiskQuotaControl,
                    (void **)&pIDQC);
            if (ft.HrFailed())
            {
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"unable to CoCreate IDiskQuotaControl");
            }

            spIDQC.Attach(pIDQC);

            ft.hr = spIDQC->Initialize(pwszVolume, FALSE /* read only */);
            if (ft.HrFailed())
            {
                ft.Trace(VSSDBG_VSSADMIN, L"IDiskQuotaControl::Initialize failed for volume %lS", pwszVolume);
            }        
            else
            {
                DWORD dwState = 0;
                ft.hr = spIDQC->GetQuotaState(&dwState);
                if (ft.HrSucceeded())
                {
                    wcoInstance.SetProperty(!(DISKQUOTA_IS_DISABLED(dwState)), PVDR_PROP_QUOTASENABLED);
                }
            }
        }        
#endif
    }
    catch(CProvException ex)
    {
        printf("exception caught while validating volume, hr<%#x>\n", ex.hrGetError());
        m_fStatus = FALSE;
    }
    catch(HRESULT hrEx)
    {
        printf("exception caught while validating volume, hr<%#x>\n", hrEx);
        m_fStatus = FALSE;
    }

    return m_fStatus;
}

void
CVolumeValidation::ValidateAutomount()
{
    WCHAR wszPath[MAX_PATH+1] ;
    DWORD dwProp = 0;
    
    // Check Mountable (Automount)
    BOOL fMountable = VolumeIsMountable(m_bstrVolume);
    CompareProperty(PVDR_PROP_MOUNTABLE, (DWORD)fMountable);
}


void
CVolumeValidation::ValidateBlockSize()
{
    LONGLONG llProp = 0;
    DWORD cSectorsPerCluster = 0;        
    DWORD cBytesPerSector = 0;
    DWORD cDontCare = 0;
    
    // Check BlockSize
    if (GetDiskFreeSpace(
        m_bstrVolume,
        &cSectorsPerCluster,
        &cBytesPerSector,
        &cDontCare,     // total bytes
        &cDontCare))    // total free bytes
    {
        LONGLONG cbBytesPerCluster = cBytesPerSector * cSectorsPerCluster;
        CompareProperty(PVDR_PROP_BLOCKSIZE, (ULONGLONG)cbBytesPerCluster);
    }
    else
    {
        ValidatePropertyIsNull(PVDR_PROP_BLOCKSIZE);
    }
}

void
CVolumeValidation::ValidateCapacity()
{
    GetSizeInformation();
    CompareProperty(PVDR_PROP_CAPACITY, m_cbCapacity);
}

void
CVolumeValidation::ValidateCaptionName()
{
    WCHAR wszPath[MAX_PATH+1] ;
    _bstr_t bstrProp;
    
    // Check Name & Caption
    VssGetVolumeDisplayName(
        m_bstrVolume,
        wszPath,
        MAX_PATH);
    
    CompareProperty(PVDR_PROP_NAME, wszPath);

    CompareProperty(PVDR_PROP_CAPTION, wszPath);

}

void
CVolumeValidation::ValidateCompressed()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_COMPRESSED, m_dwFileSystemFlags & FS_VOL_IS_COMPRESSED);
}

void
CVolumeValidation::ValidateDirtyBitSet()
{
    DWORD dwProp = 0;
    BOOL fDirty = FALSE;
    DWORD dwRet = VolumeIsDirty(m_bstrVolume, &fDirty);
    if (dwRet != ERROR_SUCCESS)
    {
        printf("VolumeIsDirty failed %#x\n", dwRet);
        throw HRESULT_FROM_WIN32(dwRet);
    }
    CompareProperty(PVDR_PROP_DIRTYBITSET, (DWORD)fDirty);
}

void
CVolumeValidation::ValidateDriveLetter()
{
    WCHAR wszDriveLetter[g_cchDriveName];
    _bstr_t bstrProp;
    
    if (GetVolumeDrive(
            m_bstrVolume, 
            g_cchDriveName,
            wszDriveLetter))
    {
        wszDriveLetter[wcslen(wszDriveLetter) - 1] = L'\0';        // Remove the trailing '\'
        CompareProperty(PVDR_PROP_DRIVELETTER, wszDriveLetter);
    }
    else
        ValidatePropertyIsNull(PVDR_PROP_DRIVELETTER);
    

}

void
CVolumeValidation::ValidateDriveType()
{
    WCHAR wszDriveLetter[g_cchDriveName];
    _bstr_t bstrProp;
    
    CompareProperty(PVDR_PROP_DRIVETYPE, (DWORD)GetDriveType(m_bstrVolume));    

}


void
CVolumeValidation::ValidateFreeSpace()
{
    GetSizeInformation();
    CompareProperty(PVDR_PROP_FREESPACE, m_cbFreeSpace);
}

void
CVolumeValidation::ValidateFileSystem()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_FILESYSTEM, m_wszFileSystem);
}

void
CVolumeValidation::ValidateLabel()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_LABEL, m_wszLabel);
}

void
CVolumeValidation::ValidateIndexingEnabled()
{
   DWORD dwAttributes = GetFileAttributes(m_bstrVolume);
    if (dwAttributes == INVALID_FILE_ATTRIBUTES)
    {
        printf("GetFileAttributes failed %#x\n", GetLastError());
        throw HRESULT_FROM_WIN32(GetLastError());
    }

    BOOL fIndexingEnabled = !(dwAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);
    CompareProperty(PVDR_PROP_INDEXINGENABLED, (DWORD)fIndexingEnabled);
}

void
CVolumeValidation::ValidateMaximumFileNameLength()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_MAXIMUMFILENAMELENGTH, m_cchMaxFileNameLen);
}

void
CVolumeValidation::ValidateQuotasEnabled()
{
    GetQuotaInformation();
    if (m_fGotQuotaInformation)
        CompareProperty(PVDR_PROP_QUOTASENABLED, (DWORD)m_fQuotasEnabled);
    else
        ValidatePropertyIsNull(PVDR_PROP_QUOTASENABLED);        
}

void
CVolumeValidation::ValidateQuotasIncomplete()
{
    GetQuotaInformation();
    if (m_fGotQuotaInformation)
        CompareProperty(PVDR_PROP_QUOTASINCOMPLETE, (DWORD)m_fQuotasIncomplete);
    else
        ValidatePropertyIsNull(PVDR_PROP_QUOTASINCOMPLETE);        
}

void
CVolumeValidation::ValidateQuotasRebuilding()
{
    GetQuotaInformation();
    if (m_fGotQuotaInformation)
        CompareProperty(PVDR_PROP_QUOTASREBUILDING, (DWORD)m_fQuotasRebuilding);
    else
        ValidatePropertyIsNull(PVDR_PROP_QUOTASREBUILDING);        
}

void
CVolumeValidation::ValidateSerialNumber()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_SERIALNUMBER, m_dwSerialNumber);
}

void
CVolumeValidation::ValidateSupportsDiskQuotas()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_SUPPORTSDISKQUOTAS, 
       (m_dwFileSystemFlags & FILE_VOLUME_QUOTAS)?(DWORD)1:(DWORD)0);
}

void
CVolumeValidation::ValidateSupportsFileBasedCompression()
{
    GetVolumeInformationLocal();
    CompareProperty(PVDR_PROP_SUPPORTSFILEBASEDCOMPRESSION, 
        (DWORD)(m_dwFileSystemFlags & FS_FILE_COMPRESSION)?(DWORD)1:(DWORD)0);
}

void
CVolumeValidation::ValidateSystemName()
{
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH];
    DWORD cchBuf = MAX_COMPUTERNAME_LENGTH;
    
    // Check SystemName
    if (!GetComputerName(wszComputerName, &cchBuf))
    {
        printf("GetComputerName failed %#x\n", GetLastError());
        throw HRESULT_FROM_WIN32(GetLastError());
    }
    
    CompareProperty(PVDR_PROP_SYSTEMNAME, wszComputerName);
}

void
CVolumeValidation::ValidateBootVolume()
{
    CompareProperty(PVDR_PROP_BOOTVOLUME, (DWORD)FALSE);
}

void
CVolumeValidation::ValidateCrashdump()
{
    CompareProperty(PVDR_PROP_CRASHDUMP, (DWORD)FALSE);
}

void
CVolumeValidation::ValidatePagefile()
{
    CompareProperty(PVDR_PROP_PAGEFILE, (DWORD)FALSE);
}

void
CVolumeValidation::ValidateSystemVolume()
{
    CompareProperty(PVDR_PROP_SYSTEMVOLUME, (DWORD)FALSE);
}


void
CVolumeValidation::GetVolumeInformationLocal()
{
    if (!m_fGotVolumeInformation)
    {
        if (!GetVolumeInformation(
                    m_bstrVolume,
                    m_wszLabel,
                    g_cchVolumeLabelMax,
                    &m_dwSerialNumber,
                    &m_cchMaxFileNameLen,
                    &m_dwFileSystemFlags,
                    m_wszFileSystem,
                    g_cchFileSystemNameMax))
        {
            printf("GetVolumeInformation failed for volume %lS, %#x\n", (WCHAR*)m_bstrVolume, GetLastError());
            throw HRESULT_FROM_WIN32(GetLastError());
        }

        m_fGotVolumeInformation = TRUE;
    }
}

void
CVolumeValidation::GetSizeInformation()
{
    if (!m_fGotSizeInformation)
    {
        ULARGE_INTEGER cbCapacity = {0, 0};
        ULARGE_INTEGER cbFreeSpace = {0, 0};
        ULARGE_INTEGER cbUserFreeSpace = {0, 0};
        
        if (!GetDiskFreeSpaceEx(
            m_bstrVolume,
            &cbUserFreeSpace,
            &cbCapacity,
            &cbFreeSpace))
        {
            printf("GetDiskFreeSpaceEx failed for volume %lS, %#x\n", (WCHAR*)m_bstrVolume, GetLastError());
            throw HRESULT_FROM_WIN32(GetLastError());
        }
        
        m_cbCapacity = cbCapacity.QuadPart;        
        m_cbFreeSpace = cbFreeSpace.QuadPart;        
        m_fGotSizeInformation = TRUE;
    }
}

void
CVolumeValidation::GetQuotaInformation()
{
    HRESULT hr = S_OK;
    CComPtr<IDiskQuotaControl> spIDQC;
    IDiskQuotaControl* pIDQC = NULL;
    
    hr = CoCreateInstance(
            CLSID_DiskQuotaControl,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDiskQuotaControl,
            (void **)&pIDQC);
    if (FAILED(hr))
    {
        printf("IDiskQuotaControl CoCreateInstance failed, %#x\n",hr);
        throw hr;
    }

    spIDQC.Attach(pIDQC);

    // OK if this fails on some volumes with file systems that don't support quotas.
    hr = spIDQC->Initialize(m_bstrVolume, FALSE /* read only */);
    if (SUCCEEDED(hr))
    {
        DWORD dwState = 0;
        hr = spIDQC->GetQuotaState(&dwState);
        if (FAILED(hr))
        {
            printf("IDiskQuotaControl::GetQuotaState failed for volume %lS, %#x\n", m_bstrVolume, hr);
            throw hr;
        }

        m_fQuotasEnabled = !(DISKQUOTA_IS_DISABLED(dwState));
        m_fQuotasIncomplete = DISKQUOTA_FILE_INCOMPLETE(dwState);
        m_fQuotasRebuilding = DISKQUOTA_FILE_REBUILDING(dwState);
        m_fGotQuotaInformation = TRUE;
    }
}

HRESULT
testValProp(IWbemServices* pISvc)
{
    HRESULT hr = S_OK;
    BOOL bStatus = TRUE;
    
    do
    {
        CComPtr<IEnumWbemClassObject> spEnum;
        hr = pISvc->CreateInstanceEnum(
                    _bstr_t(L"Win32_Volume"), 0, NULL, &spEnum);
        if (FAILED(hr))
        {
            printf("Win32_Volume enumeration failed <%#x>\n", hr);    
            break;
        }

        while(true)
        {
            CComPtr<IWbemClassObject> spVolume;
            CVolumeValidation validation;
            
            ULONG cVolume = 0;
            
            hr = spEnum->Next(WBEM_INFINITE, 1, &spVolume, &cVolume);
            if (FAILED(hr))
            {
                printf("IEnumWbem::Next failed <%#x>\n", hr);
                goto Exit;
            }
            if (hr == S_FALSE)
            {
                hr = S_OK;
                break;
            }

            if (!validation.Validate(spVolume))
            {
                bStatus = FALSE;
            }                
        }
    }
    while (false);

    if (bStatus == FALSE)
    {
        printf("testValProp: instance validation failed for at least one volume\n");
        hr = S_FALSE;
    }
    
Exit:
    return hr;
}

void
PrintUsage()
{
    printf("Usage: valprop [-v] variation_number [volume_name]\n");
    printf("variations:\n");
    printf("1   -   validate properties against Win32 APIs\n");
}

HRESULT
RunTest(
    WCHAR* pwszVolume,
    long nVariation)
{
    HRESULT hr = E_FAIL;

    do
    {
        CComPtr<IWbemLocator> spILocator;
        CComPtr<IWbemServices> spISvc;
        hr = CoInitialize(NULL);
        if (FAILED(hr))
        {
            printf("CoInitialize failed <%#x>\n", hr);    
            break;
        }

        hr =  CoInitializeSecurity(NULL, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE,
                                  NULL, EOAC_NONE, 0);
        if (FAILED(hr))
        {
            printf("CoInitializeSecurity failed <%#x>\n", hr);    
            break;
        }
    
        hr = spILocator.CoCreateInstance(__uuidof(WbemLocator));
        if (FAILED(hr))
        {
            printf("IWbemLocator CoCreateInstance failed <%#x>\n", hr);    
            break;
        }

        hr = spILocator->ConnectServer(
                                _bstr_t("\\\\.\\root\\cimv2"),
                                NULL, NULL, NULL, 0, NULL, NULL, &spISvc);
        if (FAILED(hr))
        {
            printf("IWbemLocator::ConnectServer failed <%#x>\n", hr);    
            break;
        }

        switch (nVariation)
        {
            case Variation_ValProp:
                hr = testValProp(spISvc);
                break;
                
            default:
                printf("invalid variation number <%d>\n", nVariation);
                PrintUsage();
                hr = E_INVALIDARG;
        }
    }
    while (false);

    CoUninitialize();
    return hr;    
}

_cdecl wmain(int argc, wchar_t* argv[])
{
    HRESULT hr = E_FAIL;
    
    if (argc < 2)
    {
        PrintUsage();
        return 1;
    }

    int nArg = 1;
    if (_wcsicmp(argv[nArg], L"-v") == 0)
    {
        g_fVerbose = TRUE;
        nArg++;
    }
    long nVariation = wcstol(argv[nArg++], NULL, 10);
    WCHAR* pwszVolume = argv[nArg];

    hr = RunTest(pwszVolume, nVariation);

    if (hr != S_OK)
        printf("test failed <%#x>\n", hr);
    else
        printf("test succeeded\n");

    return hr == S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter (DavidP) 05-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////


#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )
#include <wbemprov.h>
#include <objbase.h>
#include <map>
#include <comdef.h>

#include "vs_assert.hxx"

#include <atlbase.h>
#include "NtRkComm.h"
#include "ObjectPath.h"
#include "vs_inc.hxx"
#include "vss.h"
#include "vsswprv.h"
#include "vscoordint.h"
#include "vsmgmt.h"
#include "vswriter.h"
#include "vsbackup.h"
#include "Common.h"
#include "schema.h"
#include "strsafe.h"

// constants
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\schema.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Definition of schema defined strings
//
//  Author:
//		Jim Benton (jbenton)    15-Oct-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef enum _DISMOUNT_ERROR
{
        DISMOUNT_RC_NO_ERROR = 0,
        DISMOUNT_RC_ACCESS_DENIED,
        DISMOUNT_RC_VOLUME_HAS_MOUNT_POINTS,
        DISMOUNT_RC_NOT_SUPPORTED,
        DISMOUNT_RC_FORCE_OPTION_REQUIRED,
        DISMOUNT_RC_UNEXPECTED,
} DISMOUNT_ERROR, *PDISMOUNT_ERROR;

typedef enum _MOUNT_ERROR
{
        MOUNT_RC_NO_ERROR = 0,
        MOUNT_RC_ACCESS_DENIED,
        MOUNT_RC_UNEXPECTED,
} MOUNT_ERROR, *PMOUNT_ERROR;

typedef enum _MOUNTPOINT_ERROR
{
        MOUNTPOINT_RC_NO_ERROR = 0,
        MOUNTPOINT_RC_ACCESS_DENIED,
        MOUNTPOINT_RC_INVALID_ARG,
        MOUNTPOINT_RC_DIRECTORY_NOT_EMPTY,
        MOUNTPOINT_RC_FILE_NOT_FOUND,
        MOUNTPOINT_RC_NOT_SUPPORTED,
        MOUNTPOINT_RC_UNEXPECTED,
} MOUNTPOINT_ERROR, *PMOUNTPOINT_ERROR;


typedef enum _CHKDSK_ERROR
{
    CHKDSK_RC_NO_ERROR = 0,
    CHKDSK_RC_VOLUME_LOCKED,
    CHKDSK_RC_UNSUPPORTED_FS,
    CHKDSK_RC_UNKNOWN_FS,
    CHKDSK_RC_NO_MEDIA,
    CHKDSK_RC_UNEXPECTED
} CHKDSK_ERROR, *PCHKDSK_ERROR;

typedef enum _AUTOCHK_ERROR
{
    AUTOCHK_RC_NO_ERROR = 0,
    AUTOCHK_RC_NETWORK_DRIVE,
    AUTOCHK_RC_REMOVABLE_DRIVE,
    AUTOCHK_RC_NOT_ROOT_DIRECTORY,
    AUTOCHK_RC_UNKNOWN_DRIVE,
    AUTOCHK_RC_UNEXPECTED
} AUTOCHK_ERROR, *PAUTOCHK_ERROR;


typedef enum _FORMAT_ERROR
{
    FORMAT_RC_NO_ERROR = 0,
    FORMAT_RC_UNSUPPORTED_FS,
    FORMAT_RC_INCOMPATIBLE_MEDIA,
    FORMAT_RC_ACCESS_DENIED,
    FORMAT_RC_CALL_CANCELLED,
    FORMAT_RC_CANCEL_TOO_LATE,
    FORMAT_RC_WRITE_PROTECTED,
    FORMAT_RC_CANT_LOCK,
    FORMAT_RC_CANT_QUICKFORMAT,
    FORMAT_RC_IO_ERROR,
    FORMAT_RC_BAD_LABEL,
    FORMAT_RC_NO_MEDIA,
    FORMAT_RC_VOLUME_TOO_SMALL,
    FORMAT_RC_VOLUME_TOO_BIG,
    FORMAT_RC_VOLUME_NOT_MOUNTED,
    FORMAT_RC_CLUSTER_SIZE_TOO_SMALL,
    FORMAT_RC_CLUSTER_SIZE_TOO_BIG,
    FORMAT_RC_CLUSTER_COUNT_BEYOND_32BITS,
    FORMAT_RC_UNEXPECTED
} FORMAT_ERROR, *PFORMAT_ERROR;

typedef enum _DEFRAG_ERROR
{
    DEFRAG_RC_NO_ERROR = 0,
    DEFRAG_RC_ACCESS_DENIED,
    DEFRAG_RC_NOT_SUPPORTED,
    DEFRAG_RC_DIRTY_BIT_SET,
    DEFRAG_RC_LOW_FREESPACE,
    DEFRAG_RC_CORRUPT_MFT,
    DEFRAG_RC_CALL_CANCELLED,
    DEFRAG_RC_CANCEL_TOO_LATE,
    DEFRAG_RC_ALREADY_RUNNING,
    DEFRAG_RC_ENGINE_CONNECT,
    DEFRAG_RC_ENGINE_ERROR,
    DEFRAG_RC_UNEXPECTED
} DEFRAG_ERROR, *PDEFRAG_ERROR;


const int g_cchFileSystemNameMax = 32;    
const int g_cchDriveName = 4;    
const int g_cchVolumeLabelMax = 32;
const int g_cchAccountNameMax = 256;

extern const WCHAR * const g_wszDfrgifsDLL;
extern const CHAR * const g_szDfrgifsDefrag;
extern const WCHAR*  const g_wszScheduleAutoChkCommand;
extern const WCHAR*  const g_wszExcludeAutoChkCommand;


//
// Class
//
extern const WCHAR * const PVDR_CLASS_DEFRAGANALYSIS;
extern const WCHAR * const PVDR_CLASS_DIRECTORY;
extern const WCHAR * const PVDR_CLASS_MOUNTPOINT;
extern const WCHAR * const PVDR_CLASS_VOLUME;
extern const WCHAR * const PVDR_CLASS_VOLUMEQUOTA;
extern const WCHAR * const PVDR_CLASS_VOLUMEUSERQUOTA;
extern const WCHAR * const PVDR_CLASS_QUOTASETTING;
extern const WCHAR * const PVDR_CLASS_ACCOUNT;

//
// Methods
//
extern const WCHAR * const PVDR_MTHD_ADDMOUNTPOINT;
extern const WCHAR * const PVDR_MTHD_DEFRAG;
extern const WCHAR * const PVDR_MTHD_DEFRAGANALYSIS;
extern const WCHAR * const PVDR_MTHD_DISMOUNT;
extern const WCHAR * const PVDR_MTHD_FORMAT;
extern const WCHAR * const PVDR_MTHD_MOUNT;
extern const WCHAR * const PVDR_MTHD_CHKDSK;
extern const WCHAR * const PVDR_MTHD_SCHEDULECHK;
extern const WCHAR * const PVDR_MTHD_EXCLUDECHK;

//
// Properties
//

// Volume properties
extern const WCHAR * const PVDR_PROP_BLOCKSIZE;
extern const WCHAR * const PVDR_PROP_BOOTVOLUME;
extern const WCHAR * const PVDR_PROP_CAPACITY;
extern const WCHAR * const PVDR_PROP_CAPTION;
extern const WCHAR * const PVDR_PROP_COMPRESSED;
extern const WCHAR * const PVDR_PROP_CRASHDUMP;
extern const WCHAR * const PVDR_PROP_DESCRIPTION;
extern const WCHAR * const PVDR_PROP_DEVICEID;
extern const WCHAR * const PVDR_PROP_DIRECTORY;
extern const WCHAR * const PVDR_PROP_DIRTYBITSET;
extern const WCHAR * const PVDR_PROP_DRIVELETTER;
extern const WCHAR * const PVDR_PROP_DRIVETYPE;
extern const WCHAR * const PVDR_PROP_FILESYSTEM;
extern const WCHAR * const PVDR_PROP_FREESPACE;
extern const WCHAR * const PVDR_PROP_INDEXINGENABLED;
extern const WCHAR * const PVDR_PROP_ISDIRTY;
extern const WCHAR * const PVDR_PROP_LABEL;
extern const WCHAR * const PVDR_PROP_MAXIMUMFILENAMELENGTH;
extern const WCHAR * const PVDR_PROP_MOUNTABLE;
extern const WCHAR * const PVDR_PROP_MOUNTED;
extern const WCHAR * const PVDR_PROP_NAME;
extern const WCHAR * const PVDR_PROP_PAGEFILE;
extern const WCHAR * const PVDR_PROP_QUOTASENABLED;
extern const WCHAR * const PVDR_PROP_QUOTASINCOMPLETE;
extern const WCHAR * const PVDR_PROP_QUOTASREBUILDING;
extern const WCHAR * const PVDR_PROP_SERIALNUMBER;
extern const WCHAR * const PVDR_PROP_SUPPORTSDISKQUOTAS;
extern const WCHAR * const PVDR_PROP_SUPPORTSFILEBASEDCOMPRESSION;
extern const WCHAR * const PVDR_PROP_SYSTEMNAME;
extern const WCHAR * const PVDR_PROP_SYSTEMVOLUME;
extern const WCHAR * const PVDR_PROP_VOLUME;

// Defrag properties
extern const WCHAR * const PVDR_PROP_DEFRAGANALYSIS;
extern const WCHAR * const PVDR_PROP_DEFRAGRECOMMENDED;
extern const WCHAR * const PVDR_PROP_VOLUMESIZE;
extern const WCHAR * const PVDR_PROP_CLUSTERSIZE;
extern const WCHAR * const PVDR_PROP_USEDSPACE;
extern const WCHAR * const PVDR_PROP_FRAGFREEPCT;
extern const WCHAR * const PVDR_PROP_FRAGTOTALPCT;
extern const WCHAR * const PVDR_PROP_FILESFRAGPCT;
extern const WCHAR * const PVDR_PROP_FREEFRAGPCT;
extern const WCHAR * const PVDR_PROP_FILESTOTAL;
extern const WCHAR * const PVDR_PROP_FILESIZEAVG;
extern const WCHAR * const PVDR_PROP_FILESFRAGTOTAL;
extern const WCHAR * const PVDR_PROP_EXCESSFRAGTOTAL;
extern const WCHAR * const PVDR_PROP_FILESFRAGAVG;
extern const WCHAR * const PVDR_PROP_PAGEFILESIZE;
extern const WCHAR * const PVDR_PROP_PAGEFILEFRAG;
extern const WCHAR * const PVDR_PROP_FOLDERSTOTAL;
extern const WCHAR * const PVDR_PROP_FOLDERSFRAG;
extern const WCHAR * const PVDR_PROP_FOLDERSFRAGEXCESS;
extern const WCHAR * const PVDR_PROP_MFTSIZE;
extern const WCHAR * const PVDR_PROP_MFTRECORDS;
extern const WCHAR * const PVDR_PROP_MFTINUSEPCT;
extern const WCHAR * const PVDR_PROP_MFTFRAGTOTAL;

// Others
extern const WCHAR * const PVDR_PROP_PERMANENT;
extern const WCHAR * const PVDR_PROP_FORCE;
extern const WCHAR * const PVDR_PROP_SETTING;
extern const WCHAR * const PVDR_PROP_VOLUMEPATH;
extern const WCHAR * const PVDR_PROP_ACCOUNT;
extern const WCHAR * const PVDR_PROP_DOMAIN;
extern const WCHAR * const PVDR_PROP_DISKSPACEUSED;
extern const WCHAR * const PVDR_PROP_LIMIT;
extern const WCHAR * const PVDR_PROP_STATUS;
extern const WCHAR * const PVDR_PROP_WARNINGLIMIT;
extern const WCHAR * const PVDR_PROP_FIXERRORS;
extern const WCHAR * const PVDR_PROP_VIGOROUSINDEXCHECK;
extern const WCHAR * const PVDR_PROP_SKIPFOLDERCYCLE;
extern const WCHAR * const PVDR_PROP_FORCEDISMOUNT;
extern const WCHAR * const PVDR_PROP_RECOVERBADSECTORS;
extern const WCHAR * const PVDR_PROP_OKTORUNATBOOTUP;
extern const WCHAR * const PVDR_PROP_CHKONLYIFDIRTY;
extern const WCHAR * const PVDR_PROP_QUICKFORMAT;
extern const WCHAR * const PVDR_PROP_ENABLECOMPRESSION;


// Message Id: MSG_ERROR_DRIVELETTER_UNAVAIL
//
// Message Text:
//
//   The drive letter is unavailable until reboot.
//
const HRESULT VDSWMI_E_DRIVELETTER_UNAVAIL = 0x80044500L;

// Message Id: MSG_ERROR_DRIVELETTER_IN_USE
//
// Message Text:
//
//   The drive letter is assigned to another volume.
//
const HRESULT VDSWMI_E_DRIVELETTER_IN_USE = 0x80044501L;

// Message Id: MSG_ERROR_DRIVELETTER_CANT_DELETE
//
// Message Text:
//
//   Drive letter deletion not supported for boot, system and pagefile volumes.
//
const HRESULT VDSWMI_E_DRIVELETTER_CANT_DELETE = 0x80044502L;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vds\schema.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Schema.cpp
//
//  Description:
//      Implementation of schema defined strings
//
//  Author:
//      Jim Benton (jbenton)  5-Nov-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////

const WCHAR * const g_wszDfrgifsDLL         = L"dfrgifs.dll";
const CHAR * const g_szDfrgifsDefrag    = "Defrag";
const WCHAR*  const g_wszScheduleAutoChkCommand = L"CHKNTFS /C";
const WCHAR*  const g_wszExcludeAutoChkCommand = L"CHKNTFS /X";

//
// class
//

const WCHAR * const PVDR_CLASS_DEFRAGANALYSIS    = L"Win32_DefragAnalysis";
const WCHAR * const PVDR_CLASS_DIRECTORY             = L"Win32_Directory";
const WCHAR * const PVDR_CLASS_MOUNTPOINT            = L"Win32_MountPoint";
const WCHAR * const PVDR_CLASS_VOLUME                   = L"Win32_Volume";
const WCHAR * const PVDR_CLASS_VOLUMEQUOTA         = L"Win32_VolumeQuota";
const WCHAR * const PVDR_CLASS_VOLUMEUSERQUOTA         = L"Win32_VolumeUserQuota";
const WCHAR * const PVDR_CLASS_QUOTASETTING       = L"Win32_QuotaSetting";
const WCHAR * const PVDR_CLASS_ACCOUNT                 = L"Win32_Account";

//
// Methods
//
const WCHAR * const PVDR_MTHD_ADDMOUNTPOINT    = L"AddMountPoint";
const WCHAR * const PVDR_MTHD_DEFRAG              = L"Defrag";
const WCHAR * const PVDR_MTHD_DEFRAGANALYSIS   = L"DefragAnalysis";
const WCHAR * const PVDR_MTHD_DISMOUNT              = L"Dismount";
const WCHAR * const PVDR_MTHD_FORMAT              = L"Format";
const WCHAR * const PVDR_MTHD_MOUNT              = L"Mount";
const WCHAR * const PVDR_MTHD_CHKDSK              = L"Chkdsk";
const WCHAR * const PVDR_MTHD_SCHEDULECHK              = L"ScheduleAutoChk";
const WCHAR * const PVDR_MTHD_EXCLUDECHK              = L"ExcludeFromAutoChk";


//
// Properties
//

// Volume properties
const WCHAR * const PVDR_PROP_BLOCKSIZE                 = L"BlockSize";
const WCHAR * const PVDR_PROP_BOOTVOLUME                 = L"BootVolume";
const WCHAR * const PVDR_PROP_CAPACITY                  = L"Capacity";
const WCHAR * const PVDR_PROP_CAPTION                   = L"Caption";
const WCHAR * const PVDR_PROP_COMPRESSED            = L"Compressed";
const WCHAR * const PVDR_PROP_CRASHDUMP            = L"Crashdump";
const WCHAR * const PVDR_PROP_DESCRIPTION           = L"Description";
const WCHAR * const PVDR_PROP_DEVICEID                  = L"DeviceID";
const WCHAR * const PVDR_PROP_DIRECTORY               = L"Directory";
const WCHAR * const PVDR_PROP_DIRTYBITSET          = L"DirtyBitSet";
const WCHAR * const PVDR_PROP_DRIVELETTER         = L"DriveLetter";
const WCHAR * const PVDR_PROP_DRIVETYPE         = L"DriveType";
const WCHAR * const PVDR_PROP_FILESYSTEM          = L"FileSystem";
const WCHAR * const PVDR_PROP_FREESPACE          = L"FreeSpace";
const WCHAR * const PVDR_PROP_INDEXINGENABLED            = L"IndexingEnabled";
const WCHAR * const PVDR_PROP_ISDIRTY                    = L"IsDirty";
const WCHAR * const PVDR_PROP_LABEL                       = L"Label";
const WCHAR * const PVDR_PROP_MAXIMUMFILENAMELENGTH       = L"MaximumFileNameLength";
const WCHAR * const PVDR_PROP_MOUNTED                  = L"Mounted";
const WCHAR * const PVDR_PROP_MOUNTABLE                = L"Automount";
const WCHAR * const PVDR_PROP_NAME                          = L"Name";
const WCHAR * const PVDR_PROP_PAGEFILE                         = L"Pagefile";
const WCHAR * const PVDR_PROP_QUOTASENABLED          = L"QuotasEnabled";
const WCHAR * const PVDR_PROP_QUOTASINCOMPLETE          = L"QuotasIncomplete";
const WCHAR * const PVDR_PROP_QUOTASREBUILDING          = L"QuotasRebuilding";
const WCHAR * const PVDR_PROP_SERIALNUMBER          = L"SerialNumber";
const WCHAR * const PVDR_PROP_SUPPORTSDISKQUOTAS          = L"SupportsDiskQuotas";
const WCHAR * const PVDR_PROP_SUPPORTSFILEBASEDCOMPRESSION          = L"SupportsFileBasedCompression";
const WCHAR * const PVDR_PROP_SYSTEMNAME          = L"SystemName";
const WCHAR * const PVDR_PROP_SYSTEMVOLUME          = L"SystemVolume";
const WCHAR * const PVDR_PROP_VOLUME                = L"Volume";

// Defrag properties
const WCHAR * const PVDR_PROP_DEFRAGANALYSIS    = L"DefragAnalysis";
const WCHAR * const PVDR_PROP_DEFRAGRECOMMENDED    = L"DefragRecommended";
const WCHAR * const PVDR_PROP_VOLUMESIZE        = L"VolumeSize";
const WCHAR * const PVDR_PROP_CLUSTERSIZE        = L"ClusterSize";
const WCHAR * const PVDR_PROP_USEDSPACE        = L"UsedSpace";
const WCHAR * const PVDR_PROP_FRAGFREEPCT        = L"FreeSpacePercent";
const WCHAR * const PVDR_PROP_FRAGTOTALPCT        = L"TotalPercentFragmentation";
const WCHAR * const PVDR_PROP_FILESFRAGPCT        = L"FilePercentFragmentation";
const WCHAR * const PVDR_PROP_FREEFRAGPCT        = L"FreeSpacePercentFragmentation";
const WCHAR * const PVDR_PROP_FILESTOTAL        = L"TotalFiles";
const WCHAR * const PVDR_PROP_FILESIZEAVG        = L"AverageFileSize";
const WCHAR * const PVDR_PROP_FILESFRAGTOTAL        = L"TotalFragmentedFiles";
const WCHAR * const PVDR_PROP_EXCESSFRAGTOTAL        = L"TotalExcessFragments";
const WCHAR * const PVDR_PROP_FILESFRAGAVG        = L"AverageFragmentsPerFile";
const WCHAR * const PVDR_PROP_PAGEFILESIZE        = L"PageFileSize";
const WCHAR * const PVDR_PROP_PAGEFILEFRAG        = L"TotalPageFileFragments";
const WCHAR * const PVDR_PROP_FOLDERSTOTAL        = L"TotalFolders";
const WCHAR * const PVDR_PROP_FOLDERSFRAG        = L"FragmentedFolders";
const WCHAR * const PVDR_PROP_FOLDERSFRAGEXCESS        = L"ExcessFolderFragments";
const WCHAR * const PVDR_PROP_MFTSIZE        = L"TotalMFTSize";
const WCHAR * const PVDR_PROP_MFTRECORDS        = L"MFTRecordCount";
const WCHAR * const PVDR_PROP_MFTINUSEPCT        = L"MFTPercentInUse";
const WCHAR * const PVDR_PROP_MFTFRAGTOTAL        = L"TotalMFTFragments";    

// Others
const WCHAR * const PVDR_PROP_PERMANENT        = L"Permanent";    
const WCHAR * const PVDR_PROP_FORCE        = L"Force";    
const WCHAR * const PVDR_PROP_SETTING        = L"Setting";    
const WCHAR * const PVDR_PROP_VOLUMEPATH        = L"VolumePath";    
const WCHAR * const PVDR_PROP_ACCOUNT        = L"Account";    
const WCHAR * const PVDR_PROP_DOMAIN        = L"Domain";    
const WCHAR * const PVDR_PROP_DISKSPACEUSED        = L"DiskSpaceUsed";
const WCHAR * const PVDR_PROP_LIMIT        = L"Limit";
const WCHAR * const PVDR_PROP_STATUS        = L"Status";
const WCHAR * const PVDR_PROP_WARNINGLIMIT        = L"WarningLimit";

const WCHAR * const PVDR_PROP_FIXERRORS         = L"FixErrors";
const WCHAR * const PVDR_PROP_VIGOROUSINDEXCHECK    = L"VigorousIndexCheck";
const WCHAR * const PVDR_PROP_SKIPFOLDERCYCLE   = L"SkipFolderCycle";
const WCHAR * const PVDR_PROP_FORCEDISMOUNT     = L"ForceDismount";
const WCHAR * const PVDR_PROP_RECOVERBADSECTORS = L"RecoverBadSectors";
const WCHAR * const PVDR_PROP_OKTORUNATBOOTUP   = L"OkToRunAtBootup";
const WCHAR * const PVDR_PROP_CHKONLYIFDIRTY    = L"ChkOnlyIfDirty";
const WCHAR * const PVDR_PROP_QUICKFORMAT    = L"QuickFormat";
const WCHAR * const PVDR_PROP_ENABLECOMPRESSION    = L"EnableCompression";

//
// WBEM Properties
const WCHAR * const PVDR_PROP_RETURNVALUE     = L"ReturnValue";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\instanceprov.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.h
//
//  Implementation File:
//      InstanceProv.cpp
//
//  Description:
//      Definition of the CInstanceProv class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//        MSP Prabu  (mprabu)  06-Jan-2001
//        Jim Benton (jbenton) 15-Oct-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CInstanceProv;
class CWbemClassObject;
class CProvException;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CInstanceProv
//
//  Description:
//      Implement the Instance and method provider entry point class. WMI 
//      holds a pointer to this object, and invoking its member functions 
//      based client request
//
//--
//////////////////////////////////////////////////////////////////////////////
class CInstanceProv : public CImpersonatedProvider
{
protected:
    HRESULT SetExtendedStatus(
        CProvException &    rpe ,
        IWbemObjectSink **  ppHandler
        );
 
public:
    CInstanceProv(
        IN BSTR            bstrObjectPath    = NULL,
        IN BSTR            bstrUser          = NULL,
        IN BSTR            bstrPassword      = NULL,
        IN IWbemContext *  pCtx              = NULL
        )
    {
        InterlockedIncrement( &g_cObj );
        m_fInitialized = FALSE;
    }

    virtual ~CInstanceProv( void )
    {
        InterlockedDecrement( &g_cObj );

        //#ifdef _DEBUG
        #ifdef _DEBUG_NEVER
            _CrtDumpMemoryLeaks();
        #endif
    }

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        IN BSTR                bstrObjectPath,
        IN long                lFlags,
        IN IWbemContext *      pCtx,
        IN IWbemObjectSink *   pHandler
        );

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IN IWbemClassObject *   pInst,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        ) ;

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        IN BSTR                 bstrObjectPath,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        ) ;

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        IN BSTR                 bstrRefStr,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        );

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        IN BSTR                 bstrQueryLanguage,
        IN BSTR                 bstrQuery,
        IN long                 lFlags,
        IN IWbemContext *       pCtx,
        IN IWbemObjectSink *    pHandler
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        IN BSTR                bstrObjectPath,
        IN BSTR                bstrMethodName,
        IN long                lFlags,
        IN IWbemContext *      pCtx,
        IN IWbemClassObject *  pInParams,
        IN IWbemObjectSink *   pHandler
        );

    STDMETHODIMP Initialize(
         IN LPWSTR                  pszUser,
         IN LONG                    lFlags,
         IN LPWSTR                  pszNamespace,
         IN LPWSTR                  pszLocale,
         IN IWbemServices *         pNamespace,
         IN IWbemContext *          pCtx,
         IN IWbemProviderInitSink * pInitSink
         );

    static HRESULT S_HrCreateThis(
        IN IUnknown *  pUnknownOuter,
        OUT VOID **     ppv
        );

private:
    BOOL m_fInitialized;
}; //*** CInstanceProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\vssclasses.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: VssClasses.cpp
//
//  Description:    
//      Implementation of VSS WMI Provider classes 
//
//  Author:   Jim Benton (jbenton) 15-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <wbemtime.h>
#include "VssClasses.h"

#ifndef ARRAY_LEN
#define ARRAY_LEN(A) (sizeof(A)/sizeof((A)[0]))
#endif

typedef CVssDLList<GUID> CGUIDList;
typedef CVssDLList<_bstr_t> CBSTRList;

void
GetProviderIDList(
    IN IVssCoordinator* pCoord,
    OUT CGUIDList* pList
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"GetProviderIDList");
    CComPtr<IVssEnumObject> spEnumProvider;

    _ASSERTE(pList != NULL);
    _ASSERTE(pCoord != NULL);

    // Clear list of any previous values
    pList->ClearAll();
    
    ft.hr = pCoord->Query(
            GUID_NULL,
            VSS_OBJECT_NONE,
            VSS_OBJECT_PROVIDER,
            &spEnumProvider);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Query for Providers failed hr<%#x>", ft.hr);
                        
    while (ft.HrSucceeded())
    {
        VSS_OBJECT_PROP prop;
        VSS_PROVIDER_PROP& propProv = prop.Obj.Prov;
        ULONG ulFetch = 0;

        ft.hr = spEnumProvider->Next(1, &prop, &ulFetch);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

        if (ft.hr == S_FALSE)
        {
            ft.hr = S_OK;
            break;
        }

        CVssAutoPWSZ awszProviderName(propProv.m_pwszProviderName);
        CVssAutoPWSZ awszProviderVersion(propProv.m_pwszProviderVersion);

        // Add to the ID list
        pList->Add(ft, propProv.m_ProviderId);
    }

    return;
}

HRESULT
MapContextNameToEnum(
    IN const WCHAR* pwszContextName,
    OUT LONG* plContext
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"MapContextToEnum");
    
    _ASSERTE(pwszContextName != NULL);
    _ASSERTE(plContext != NULL);

    *plContext = 0;
    
    if (!_wcsicmp(pwszContextName, VSS_CTX_NAME_CLIENTACCESSIBLE))
    {
        *plContext = VSS_CTX_CLIENT_ACCESSIBLE;
    }
    else if (!_wcsicmp(pwszContextName, VSS_CTX_NAME_NASROLLBACK))
    {
        *plContext = VSS_CTX_NAS_ROLLBACK;
    }
    else
    {
        ft.hr = VSS_E_UNSUPPORTED_CONTEXT;
        ft.Trace(VSSDBG_VSSADMIN,
            L"Unsupported context name, context<%lS>", pwszContextName);
    }    

    return ft.hr;
}


//****************************************************************************
//
//  CProvider
//
//****************************************************************************

CProvider::CProvider( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase( pwszName, pNamespace )
{
    
} //*** CProvider::CProvider()

CProvBase *
CProvider::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CProvider * pProvider = NULL;
    pProvider = new CProvider(pwszName, pNamespace);

    if (pProvider)
    {
        hr = pProvider->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pProvider;
        pProvider = NULL;
    }
    return pProvider;

} //*** CProvider::S_CreateThis()


HRESULT
CProvider::EnumInstance( 
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CProvider::EnumInstance");

    HANDLE hToken = INVALID_HANDLE_VALUE;
    
    try
    {
        CComPtr<IVssEnumObject> spEnumProvider;

        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);

        ft.hr = m_spCoord->Query(
                GUID_NULL,
                VSS_OBJECT_NONE,
                VSS_OBJECT_PROVIDER,
                &spEnumProvider);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::Query failed, hr<%#x>", ft.hr);
                            
        while (ft.HrSucceeded())
        {
            CComPtr<IWbemClassObject> spInstance;
            VSS_OBJECT_PROP prop;
            VSS_PROVIDER_PROP& propProv = prop.Obj.Prov;
            ULONG ulFetch = 0;

            ft.hr = spEnumProvider->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                break;  // All done
            }

            CVssAutoPWSZ awszProviderName(propProv.m_pwszProviderName);
            CVssAutoPWSZ awszProviderVersion(propProv.m_pwszProviderVersion);
                
            // Spawn an instance of the class
            ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            LoadInstance(&propProv, spInstance.p);

            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CProvider::EnumInstance()

HRESULT
CProvider::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CProvider::GetObject");

    try
    {
        CComPtr<IWbemClassObject> spInstance;
        CComPtr<IVssEnumObject> spEnumProvider;
        _bstr_t bstrID;
        GUID guid;

        // Get the Shadow ID (GUID)
        bstrID = rObjPath.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrID, WBEM_E_INVALID_OBJECT_PATH, L"CProvider::GetObject: provider key property not found");

        // Convert string GUID
        if (FAILED(CLSIDFromString(bstrID, &guid)))
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"CProvider::GetObject failed invalid ID (%lS), CLSIDFromString hr<%#x>", bstrID, ft.hr);
        }

        ft.hr = m_spCoord->Query(
                GUID_NULL,
                VSS_OBJECT_NONE,
                VSS_OBJECT_PROVIDER,
                &spEnumProvider);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::Query failed, hr<%#x>", ft.hr);
                            
        while (ft.HrSucceeded())
        {
            VSS_OBJECT_PROP prop;
            VSS_PROVIDER_PROP& propProv = prop.Obj.Prov;
            ULONG ulFetch = 0;
            _bstr_t bstrValue;

            ft.hr = spEnumProvider->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = WBEM_E_NOT_FOUND;
                break;  // All done; the provider was not found
            }

            CVssAutoPWSZ awszProviderName(propProv.m_pwszProviderName);
            CVssAutoPWSZ awszProviderVersion(propProv.m_pwszProviderVersion);

            if (guid == propProv.m_ProviderId)
            {
                // Spawn an instance of the class
                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                    LoadInstance(&propProv, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);

                break; // Found the provider; stop looking
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CProvider::GetObject()


void
CProvider::LoadInstance(
    IN VSS_PROVIDER_PROP* pProp,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);

    // Set the ID property
    CVssAutoPWSZ awszGUID(GuidToString(pProp->m_ProviderId));  // Auto-delete string
    wcoInstance.SetProperty(awszGUID, PVDR_PROP_ID);

    // Set the CLSID property
    awszGUID.Attach(GuidToString(pProp->m_ClassId));
    wcoInstance.SetProperty(awszGUID, PVDR_PROP_CLSID);

    // Set the VersionID property
    awszGUID.Attach(GuidToString(pProp->m_ProviderVersionId));
    wcoInstance.SetProperty(awszGUID, PVDR_PROP_VERSIONID);

    // Set the Version string property
    wcoInstance.SetProperty(pProp->m_pwszProviderVersion, PVDR_PROP_VERSION);

    // Set the Name property
    wcoInstance.SetProperty(pProp->m_pwszProviderName, PVDR_PROP_NAME);

    // Set the Type property
    wcoInstance.SetProperty(pProp->m_eProviderType, PVDR_PROP_TYPE);
}


#ifdef ENABLE_WRITERS
//****************************************************************************
//
//  CWriter
//
//****************************************************************************

CWriter::CWriter( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CWriter::CWriter()

CProvBase *
CWriter::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CWriter * pWriter = NULL;
    pWriter = new CWriter(pwszName, pNamespace);

    if (pWriter)
    {
        hr = pWriter->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pWriter;
        pWriter = NULL;
    }
    return pWriter;

} //*** CWriter::S_CreateThis()


HRESULT
CWriter::EnumInstance( 
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CComPtr<IVssBackupComponents> spBackup;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CWriter::EnumInstance");

    try
    {
        CComPtr<IVssAsync> spAsync;
        HRESULT hrAsync = S_OK;
        int nReserved = 0;
        UINT unWriterCount = 0;
        
        // Get the backup components object
        ft.hr = ::CreateVssBackupComponents(&spBackup);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CreateVssBackupComponents failed, hr<%#x>", ft.hr);

        // Ininitilize the backup components object
        ft.hr = spBackup->InitializeForBackup();
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"InitializeForBackup failed, hr<%#x>", ft.hr);

        // Get metadata for all writers
        ft.hr = spBackup->GatherWriterMetadata(&spAsync);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GatherWriterMetadata failed, hr<%#x>", ft.hr);

        ft.hr = spAsync->QueryStatus(&hrAsync, &nReserved);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::QueryStatus failed, hr<%#x>", ft.hr);

        if (hrAsync == VSS_S_ASYNC_PENDING)
        {
            // Wait some more if needed
            ft.hr = spAsync->Wait();
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::Wait failed, hr<%#x>", ft.hr);

            ft.hr = spAsync->QueryStatus(&hrAsync, &nReserved);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::QueryStatus failed, hr<%#x>", ft.hr);
        }

        // Check the async status for errors
        if (FAILED(hrAsync))
            ft.Throw(VSSDBG_VSSADMIN, hrAsync, L"GatherWriterMetadata async method failed, hr<%#x>", hrAsync);
            
        // Release the async helper
        spAsync = NULL;

        // Free the writer metadata
        ft.hr = spBackup->FreeWriterMetadata();
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"FreeWriterMetadata failed, hr<%#x>", ft.hr);

        // Gather the status of all writers
        ft.hr = spBackup->GatherWriterStatus(&spAsync);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GatherWriterStatus failed, hr<%#x>", ft.hr);

        ft.hr = spAsync->Wait();
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::Wait failed, hr<%#x>", ft.hr);

        ft.hr = spAsync->QueryStatus(&hrAsync, &nReserved);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::QueryStatus failed, hr<%#x>", ft.hr);

        // Check the async status for errors
        if (FAILED(hrAsync))
            ft.Throw(VSSDBG_VSSADMIN, hrAsync, L"GatherWriterStatus async method failed, hr<%#x>", hrAsync);

        spAsync = NULL;
        
        ft.hr = spBackup->GetWriterStatusCount(&unWriterCount);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GetWriterStatusCount failed, hr<%#x>", ft.hr);

        for (DWORD i = 0; i < unWriterCount; i++)
        {
            VSS_ID idInstance = GUID_NULL;
            VSS_ID idWriter = GUID_NULL;
            CComBSTR bstrWriter;
            VSS_WRITER_STATE eState = VSS_WS_UNKNOWN;
            HRESULT hrLastError = S_OK;
            CComPtr<IWbemClassObject> spInstance;

            ft.hr = spBackup->GetWriterStatus(
                    i,
                    &idInstance,
                    &idWriter,
                    &bstrWriter,
                    &eState,
                    &hrLastError);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"GetWriterStatus failed, hr<%#x>", ft.hr);

            ft.hr = m_pClass->SpawnInstance(0, &spInstance);

            CWbemClassObject wcoInstance(spInstance.p);

            // Set the ID property
            CVssAutoPWSZ awszGUID(GuidToString(idInstance));  // Auto-delete string
            wcoInstance.SetProperty(awszGUID, PVDR_PROP_ID);

            // Set the CLSID property
            awszGUID.Attach(GuidToString(idWriter));
            wcoInstance.SetProperty(awszGUID, PVDR_PROP_CLSID);

            // Set the Name property
            wcoInstance.SetProperty(bstrWriter, PVDR_PROP_NAME);

            // Set the State property
            wcoInstance.SetProperty(eState, PVDR_PROP_STATE);

            // Set the LastError property
            wcoInstance.SetProperty(hrLastError, PVDR_PROP_LASTERROR);

            ft.hr = pHandler->Indicate(1, wcoInstance.dataPtr());
        }

        ft.hr = spBackup->FreeWriterStatus();
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"FreeWriterStatus failed, hr<%#x>", ft.hr);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;    
} //*** CWriter::EnumInstance()

HRESULT
CWriter::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CWriter::GetObject");
    HRESULT hr = WBEM_E_NOT_FOUND;
    //_bstr_t    bstrClassName;
    _bstr_t    bstrName;

    //CComPtr< IWbemClassObject > spInstance;

    bstrName = rObjPath.GetStringValueForProperty( PVDR_PROP_NAME );

    return hr;

} //*** CWriter::GetObject()
#endif // ENABLE_WRITERS



//****************************************************************************
//
//  CShadow
//
//****************************************************************************

CShadow::CShadow( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CShadow::CShadow()

CProvBase *
CShadow::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CShadow * pShadow = NULL;
    pShadow = new CShadow(pwszName, pNamespace);

    if (pShadow)
    {
        hr = pShadow->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pShadow;
        pShadow = NULL;
    }
    return pShadow;

} //*** CShadow::S_CreateThis()


HRESULT
CShadow::EnumInstance( 
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadow::EnumInstance");

    try
    {
        CComPtr<IVssEnumObject> spEnumShadow;

        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);

        ft.hr = m_spCoord->Query(
                GUID_NULL,
                VSS_OBJECT_NONE,
                VSS_OBJECT_SNAPSHOT,
                &spEnumShadow);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::Query failed, hr<%#x>", ft.hr);

        while (ft.HrSucceeded() && ft.hr != S_FALSE)
        {
            CComPtr<IWbemClassObject> spInstance;
            VSS_OBJECT_PROP prop;
            ULONG ulFetch = 0;

            ft.hr = spEnumShadow->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                break;  // All done
            }

            CVssAutoSnapshotProperties apropSnap(prop);
            
            // Spawn an instance of the class
            ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            LoadInstance(apropSnap.GetPtr(), spInstance.p);

            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CShadow::EnumInstance()

HRESULT
CShadow::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadow::GetObject");

    try
    {
        CComPtr<IVssEnumObject> spEnumShadow;
        VSS_SNAPSHOT_PROP propSnap;
        _bstr_t bstrID;
        GUID guid = GUID_NULL;

        // Get the Shadow ID (GUID)
        bstrID = rObjPath.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrID, WBEM_E_INVALID_OBJECT_PATH, L"CShadow::GetObject: shadow key property not found");

        // Convert string GUID
        if (FAILED(CLSIDFromString(bstrID, &guid)))
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"CShadow::GetObject invalid ID (guid), hr<%#x>", ft.hr);
        }

        // Set the context to see all shadows
        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);

        // Query for a particular shadow
        ft.hr = m_spCoord->GetSnapshotProperties(
                guid,
                &propSnap);
        
        if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        {
            ft.hr = WBEM_E_NOT_FOUND;
        }
        else
        {
            CComPtr<IWbemClassObject> spInstance;
            CVssAutoSnapshotProperties apropSnap(propSnap);
            
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"GetSnapshotProperties failed, hr<%#x>", ft.hr);

            // Spawn an instance of the class
            ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            LoadInstance(apropSnap.GetPtr(), spInstance.p);

            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;

} //*** CShadow::GetObject()

HRESULT
CShadow::ExecuteMethod(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadow::ExecuteMethod");
    
    try
    {
        if (!_wcsicmp(pwszMethodName, PVDR_MTHD_CREATE))
        {
            CComPtr<IWbemClassObject> spOutParamClass;
            _bstr_t bstrVolume, bstrContext;
            VSS_ID idShadow = GUID_NULL;
            DWORD rcCreateStatus = ERROR_SUCCESS;

            if (pParams == NULL)
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Shadow::Create called with no parameters, hr<%#x>", ft.hr);
            }
            
            CWbemClassObject wcoInParam(pParams);
            CWbemClassObject wcoOutParam;
            
            if (wcoInParam.data() == NULL)
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Create GetMethod failed, hr<%#x>", ft.hr);
            
            // Gets the Context name string - input param
            wcoInParam.GetProperty(bstrContext, PVDR_PROP_CONTEXT);
            IF_WSTR_NULL_THROW(bstrContext, WBEM_E_INVALID_METHOD_PARAMETERS, L"Shadow: Create Context param is NULL");
            
            // Gets the Volume name string - input param
            wcoInParam.GetProperty(bstrVolume, PVDR_PROP_VOLUME);
            IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_METHOD_PARAMETERS, L"Shadow: Create Volume param is NULL");
            
            ft.hr = m_pClass->GetMethod(
                _bstr_t(PVDR_MTHD_CREATE),
                0,
                NULL,
                &spOutParamClass
                );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Create GetMethod failed, hr<%#x>", ft.hr);

            ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            rcCreateStatus = Create(bstrContext, bstrVolume, &idShadow);

            ft.hr = wcoOutParam.SetProperty(rcCreateStatus, PVD_WBEM_PROP_RETURNVALUE);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
            
            CVssAutoPWSZ awszGUID(GuidToString(idShadow));  // Auto-delete string

            ft.hr = wcoOutParam.SetProperty(awszGUID, PVDR_PROP_SHADOWID);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
        
            ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
        }
        else
        {
            ft.hr = WBEM_E_INVALID_METHOD;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Invalid method called, %lS, hr<%#x>", pwszMethodName, ft.hr);            
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }
    
    return ft.hr;

} //*** CShadow::ExecuteMethod()

HRESULT
CShadow::Create(
    IN BSTR bstrContext,
    IN BSTR bstrVolume,
    OUT VSS_ID* pidShadowID)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadow::Create");
    DWORD rcStatus = ERROR_SUCCESS;

    do
    {
        CComPtr<IVssAsync> spAsync;
        VSS_ID idShadow = GUID_NULL;
        VSS_ID idShadowSet = GUID_NULL;
        LONG lContext = VSS_CTX_ALL;
        HRESULT hrStatus = S_OK;
        WCHAR wszVolumeGUIDName[MAX_PATH];
        DWORD dwRet = ERROR_SUCCESS;

        _ASSERTE(bstrContext != NULL);
        _ASSERTE(bstrVolume != NULL);
        _ASSERTE(pidShadowID != NULL);
        
        // Decode the context name string (gen exception for unsupported/invalid context)
        ft.hr = MapContextNameToEnum(bstrContext, &lContext);
        if (ft.HrFailed()) break;

        // Input volume name can be drive letter path, mount point or volume GUID name.
        // Get the volume GUID name; error if none found
        // This API returns the volume GUID name when the GUID name is input
        if (!GetVolumeNameForVolumeMountPoint(
            bstrVolume,
            wszVolumeGUIDName,
            ARRAY_LEN(wszVolumeGUIDName)))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_INVALID_NAME)
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"invalid volume name %lS", (WCHAR*)bstrVolume);
            }
            // may return ERROR_FILE_NOT_FOUND == GetLastError()
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.Trace(VSSDBG_VSSADMIN, L"GetVolumeNameForVolumeMountPoint failed %#x", GetLastError());
            break;
        }
        
        // Set the context
        ft.hr = m_spCoord->SetContext(lContext);
        //ft.hr = m_spCoord->SetContext(VSS_CTX_CLIENT_ACCESSIBLE);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);
            break;
        }

        // Start the shadow copy set
        ft.hr = m_spCoord->StartSnapshotSet(&idShadowSet);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"StartSnapshotSet failed, hr<%#x>", ft.hr);
            break;
        }

        // Add the selected volume
        ft.hr = m_spCoord->AddToSnapshotSet(
            wszVolumeGUIDName, 
            GUID_NULL,  // VSS Coordinator will choose the best provider
            &idShadow);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"AddToSnapshotSet failed, hr<%#x>", ft.hr);
            break;
        }

        // Initiate the shadow copy
        ft.hr = m_spCoord->DoSnapshotSet(
            NULL, 
            &spAsync);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"DoSnapshotSet failed, hr<%#x>", ft.hr);
            break;
        }

        // Wait for the result
        ft.hr = spAsync->Wait();
        if ( ft.HrFailed() )
        {
            ft.Trace( VSSDBG_VSSADMIN, L"IVssAsync::Wait failed hr<%#x>", ft.hr);
            break;
        }

        ft.hr = spAsync->QueryStatus(&hrStatus, NULL);
        if ( ft.HrFailed() )
        {
            ft.Trace( VSSDBG_VSSADMIN, L"IVssAsync::QueryStatus failed hr<%#x>", ft.hr);
            break;
        }

        if (SUCCEEDED(hrStatus))
        {
            *pidShadowID = idShadow;
            hrStatus = S_OK;  // VSS returns VSS_S_ASYNC_COMPLETED for async operations
        }

        ft.hr = hrStatus;
    }
    while(0);

    // Don't map out of memory to return code
    if (ft.hr == E_OUTOFMEMORY)
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CShadow::Create: out of memory");

    // Map HRESULT to WMI method return code
    CreateMapStatus(ft.hr, rcStatus);
    
    return rcStatus;
 }  //*** CShadow::Create()

void
CShadow::CreateMapStatus(
        IN HRESULT hr,
        OUT DWORD& rc
        )
{
    HRESULT hrFileNotFound = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (hr == hrFileNotFound)
        rc = VSS_SHADOW_CREATE_RC_VOLUME_NOT_FOUND;
    else if (hr == S_OK)
        rc = VSS_SHADOW_CREATE_RC_NO_ERROR;        
    else if (hr == E_ACCESSDENIED)
        rc = VSS_SHADOW_CREATE_RC_ACCESS_DENIED;        
    else if (hr == E_INVALIDARG)
        rc = VSS_SHADOW_CREATE_RC_INVALID_ARG;
    else if (hr == VSS_E_OBJECT_NOT_FOUND)
        rc = VSS_SHADOW_CREATE_RC_VOLUME_NOT_FOUND;
    else if (hr == VSS_E_VOLUME_NOT_SUPPORTED)
        rc = VSS_SHADOW_CREATE_RC_VOLUME_NOT_SUPPORTED;
    else if (hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER)
        rc = VSS_SHADOW_CREATE_RC_VOLUME_NOT_SUPPORTED;
    else if (hr == VSS_E_UNSUPPORTED_CONTEXT)
        rc = VSS_SHADOW_CREATE_RC_UNSUPPORTED_CONTEXT;
    else if (hr == VSS_E_INSUFFICIENT_STORAGE)
        rc = VSS_SHADOW_CREATE_RC_INSUFFICIENT_STORAGE;
    else if (hr == VSS_E_VOLUME_IN_USE)
        rc = VSS_SHADOW_CREATE_RC_VOLUME_IN_USE;
    else if (hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED)
        rc = VSS_SHADOW_CREATE_RC_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED;
    else if (hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS)
        rc = VSS_SHADOW_CREATE_RC_SHADOW_COPY_IN_PROGRESS;
    else if (hr == VSS_E_PROVIDER_VETO)
        rc = VSS_SHADOW_CREATE_RC_PROVIDER_VETO;
    else if (hr == VSS_E_PROVIDER_NOT_REGISTERED)
        rc = VSS_SHADOW_CREATE_RC_PROVIDER_NOT_REGISTERED;
    else if (hr == VSS_E_UNEXPECTED_PROVIDER_ERROR)
        rc = VSS_SHADOW_CREATE_RC_UNEXPECTED_PROVIDER_FAILURE;
    else if (hr == E_UNEXPECTED)
        rc = VSS_SHADOW_CREATE_RC_UNEXPECTED;
    else if (hr == VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED)
        rc = VSS_SHADOW_CREATE_RC_UNEXPECTED;
    else if (hr == VSS_E_OBJECT_ALREADY_EXISTS)
        rc = VSS_SHADOW_CREATE_RC_UNEXPECTED;
    else if (hr == VSS_E_BAD_STATE)
        rc = VSS_SHADOW_CREATE_RC_UNEXPECTED;
    else
        rc = VSS_SHADOW_CREATE_RC_UNEXPECTED;
 }
        

HRESULT
CShadow::DeleteInstance(
        IN CObjPath& rObjPath,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadow::DeleteInstance");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        _bstr_t bstrID;
        VSS_ID guid;
        long nDeleted = 0;
        VSS_ID idNonDeleted = GUID_NULL;

        // Get the Shadow ID
        bstrID = rObjPath.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrID, WBEM_E_INVALID_OBJECT_PATH, L"CShadow::DeleteInstance: shadow key property not found");

        // Convert string GUID
        if (FAILED(CLSIDFromString(bstrID, &guid)))
        {
            ft.hr = E_INVALIDARG;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"CShadow::DeleteInstance failed invalid ID (%lS), CLSIDFromString hr<%#x>", bstrID, ft.hr);
        }

        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);
        
        ft.hr = m_spCoord->DeleteSnapshots(
            guid, 
            VSS_OBJECT_SNAPSHOT,
            TRUE, // Force delete
            &nDeleted,
            &idNonDeleted);

        if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Trace(VSSDBG_VSSADMIN, L"CShadow::DeleteInstance: object not found");
        }

        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DeleteSnapshots failed, hr<%#x>", ft.hr);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;

} //*** CShadow::DeleteInstance()

void
CShadow::LoadInstance(
    IN VSS_SNAPSHOT_PROP* pProp,
    IN OUT IWbemClassObject* pObject
    )
{
    WBEMTime wbemTime;
    FILETIME ftGMT = {0,0};
    CWbemClassObject wcoInstance(pObject);

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadow::LoadInstance");
    
    // Set the ID property
    CVssAutoPWSZ awszGUID(GuidToString(pProp->m_SnapshotId));  // Auto-delete string
    wcoInstance.SetProperty(awszGUID, PVDR_PROP_ID);

    // Set the SetID property
    awszGUID.Attach(GuidToString(pProp->m_SnapshotSetId));
    wcoInstance.SetProperty(awszGUID, PVDR_PROP_SETID);

    // Set the ProviderID property
    awszGUID.Attach(GuidToString(pProp->m_ProviderId));
    wcoInstance.SetProperty(awszGUID, PVDR_PROP_PROVIDERID);
    
    // Set the Count property
    wcoInstance.SetProperty(pProp->m_lSnapshotsCount, PVDR_PROP_COUNT);

    // Set the DeviceObject property
    wcoInstance.SetProperty(pProp->m_pwszSnapshotDeviceObject, PVDR_PROP_DEVICEOBJECT);

    // Set the VolumeName property
    wcoInstance.SetProperty(pProp->m_pwszOriginalVolumeName, PVDR_PROP_VOLUMENAME);

    // Set the OriginatingMachine property
    wcoInstance.SetProperty(pProp->m_pwszOriginatingMachine, PVDR_PROP_ORIGINATINGMACHINE);

    // Set the ServiceMachine property
    wcoInstance.SetProperty(pProp->m_pwszServiceMachine, PVDR_PROP_SERVICEMACHINE);

    // Set the ExposedName property
    wcoInstance.SetProperty(pProp->m_pwszExposedName, PVDR_PROP_EXPOSEDNAME);

    // Set the ExposedPath property
    wcoInstance.SetProperty(pProp->m_pwszExposedPath, PVDR_PROP_EXPOSEDPATH);

    // Set the TimeStamp property
    CopyMemory(&ftGMT, &pProp->m_tsCreationTimestamp, sizeof(ftGMT));
    wbemTime = ftGMT;
    if (wbemTime.IsOk())
    {
        CComBSTR bstrTime;
        bstrTime.Attach(wbemTime.GetDMTF(TRUE));
        wcoInstance.SetProperty(bstrTime, PVDR_PROP_TIMESTAMP);
    }
    else
        ft.Trace(VSSDBG_VSSADMIN, L"invalid shadow copy timespamp");

    // Set the State property
    wcoInstance.SetProperty(pProp->m_eStatus, PVDR_PROP_STATE);

    // Set the Persistent property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_PERSISTENT, PVDR_PROP_PERSISTENT);

    // Set the ClientAccessible property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE, PVDR_PROP_CLIENTACCESSIBLE);

    // Set the NoAutoRelease property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE, PVDR_PROP_NOAUTORELEASE);

    // Set the NoWriters property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_NO_WRITERS, PVDR_PROP_NOWRITERS);

    // Set the Transportable property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_TRANSPORTABLE, PVDR_PROP_TRANSPORTABLE);

    // Set the NotSurfaced property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_NOT_SURFACED, PVDR_PROP_NOTSURFACED);

    // Set the HardwareAssisted property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED, PVDR_PROP_HARDWAREASSISTED);

    // Set the Differential property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_DIFFERENTIAL, PVDR_PROP_DIFFERENTIAL);

    // Set the Plex property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_PLEX, PVDR_PROP_PLEX);

    // Set the Imported property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_IMPORTED, PVDR_PROP_IMPORTED);

    // Set the ExposedRemotely property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY, PVDR_PROP_EXPOSEDREMOTELY);

    // Set the ExposedLocally property
    wcoInstance.SetProperty(pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY, PVDR_PROP_EXPOSEDLOCALLY);
}


//****************************************************************************
//
//  CStorage
//
//****************************************************************************

CStorage::CStorage( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CStorage::CStorage()

CProvBase *
CStorage::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CStorage* pStorage = NULL;
    pStorage = new CStorage(pwszName, pNamespace);

    if (pStorage)
    {
        hr = pStorage->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pStorage;
        pStorage = NULL;
    }
    
    return pStorage;

} //*** CStorage::S_CreateThis()


HRESULT
CStorage::EnumInstance( 
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::EnumInstance");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        CComPtr<IVssEnumMgmtObject> spEnumVolume;
        VSS_ID idProvider = GUID_NULL;

        SelectDiffAreaProvider(&idProvider);

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        ft.hr = spMgmt->GetProviderMgmtInterface(
            idProvider,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

        ft.hr = spDiffMgmt->QueryVolumesSupportedForDiffAreas(NULL, &spEnumVolume);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"QueryVolumesSupportedForDiffAreas failed, hr<%#x>", ft.hr);
            
        while (ft.hr == S_OK)
        {
            VSS_MGMT_OBJECT_PROP propMgmt;
            VSS_DIFF_VOLUME_PROP& propDiff = propMgmt.Obj.DiffVol;
            CComPtr<IVssEnumMgmtObject> spEnumDiffArea;
            ULONG ulFetch = 0;

            ft.hr = spEnumVolume->Next(1, &propMgmt, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                break;  // No more volumes; try next provider
            }

            CVssAutoPWSZ awszDiffVolumeName(propDiff.m_pwszVolumeName);
            CVssAutoPWSZ awszDiffVolumeDisplayName(propDiff.m_pwszVolumeDisplayName);
                
            ft.hr = spDiffMgmt->QueryDiffAreasOnVolume(
                propDiff.m_pwszVolumeName,
                &spEnumDiffArea);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"QueryVolumesSupportedOnDiffAreas failed, hr<%#x>", ft.hr);
            
            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                continue;  // No diff areas, continue to next volume
            }

            while (1)
            {
                CComPtr<IWbemClassObject> spInstance;
                VSS_MGMT_OBJECT_PROP propMgmtDA;
                VSS_DIFF_AREA_PROP& propDiffArea = propMgmtDA.Obj.DiffArea;

                ulFetch = 0;                
                ft.hr = spEnumDiffArea->Next(1, &propMgmtDA, &ulFetch);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

                if (ft.hr == S_FALSE)
                {
                    ft.hr = S_OK;
                    break;  // No more diff areas; try next volume
                }

                CVssAutoPWSZ awszVolumeName(propDiffArea.m_pwszVolumeName);
                CVssAutoPWSZ awszDiffAreaVolumeName(propDiffArea.m_pwszDiffAreaVolumeName);

                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(&propDiffArea, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CStorage::EnumInstance()

HRESULT
CStorage::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::GetObject");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        CComPtr<IVssEnumMgmtObject> spEnumDiffArea;
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrDiffVolumeRef, bstrDiffVolumeName;
        CObjPath  objPathVolume;
        CObjPath  objPathDiffVolume;
        VSS_ID idProvider = GUID_NULL;
        BOOL fSupported = false;

        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"Storage::GetObject: storage volume key property not found");

        // Get the DiffVolume reference
        bstrDiffVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_DIFFVOLUME);
        IF_WSTR_NULL_THROW(bstrDiffVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"Storage::GetObject: storage diff volume key property not found");

        // Extract the Volume and DiffVolume Names
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"Storage::GetObject: Volume Object path parse failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathDiffVolume.Init(bstrDiffVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"Storage::GetObject: DiffVolume Object path parse failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"Storage::GetObject: storage volume key DeviceID property not found");

        bstrDiffVolumeName = objPathDiffVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrDiffVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"Storage::GetObject: storage diff volume key DeviceID property not found");

        SelectDiffAreaProvider(&idProvider);

        ft.hr = m_spCoord->IsVolumeSupported(idProvider, bstrVolumeName, &fSupported);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IsVolumeSupported failed, hr<%#x>", ft.hr);

        if (!fSupported)
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume not supported by selected provider");
        }

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        // Get the Mgmt object for the Provider
        ft.hr = spMgmt->GetProviderMgmtInterface(
            idProvider,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

        ft.hr = spDiffMgmt->QueryDiffAreasOnVolume(
            bstrDiffVolumeName,
            &spEnumDiffArea);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"QueryVolumesSupportedOnDiffAreas failed, hr<%#x>", ft.hr);
        
        while (ft.hr != S_FALSE)
        {
            CComPtr<IWbemClassObject> spInstance;
            VSS_MGMT_OBJECT_PROP propMgmtDA;
            VSS_DIFF_AREA_PROP& propDiffArea = propMgmtDA.Obj.DiffArea;
            ULONG ulFetch = 0;                

            ft.hr = spEnumDiffArea->Next(1, &propMgmtDA, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                break;  // No more diff areas on this volume; diff area not found
            }

            CVssAutoPWSZ awszVolumeName(propDiffArea.m_pwszVolumeName);
            CVssAutoPWSZ awszDiffAreaVolumeName(propDiffArea.m_pwszDiffAreaVolumeName);

            if (_wcsicmp(awszVolumeName, bstrVolumeName) == 0)
            {
                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(&propDiffArea, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);

                break;
            }
        }

        if (ft.hr == S_FALSE)
        {
            ft.hr = WBEM_E_NOT_FOUND;
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

HRESULT
CStorage::PutInstance(
        IN CWbemClassObject&  rInstToPut,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::PutInstance");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrDiffVolumeRef, bstrDiffVolumeName;
        CObjPath  objPathVolume;
        CObjPath  objPathDiffVolume;
        VSS_ID idProvider = GUID_NULL;
        BOOL fSupported = false;
        LONGLONG llMaxSpace = -1;

        // Retrieve key properties of the object to be saved.
        rInstToPut.GetProperty(bstrVolumeRef, PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT, L"Storage volume key property not found");
            
        rInstToPut.GetProperty(bstrDiffVolumeRef, PVDR_PROP_DIFFVOLUME);
        IF_WSTR_NULL_THROW(bstrDiffVolumeRef, WBEM_E_INVALID_OBJECT, L"Storage diff volume key property not found");

        // Extract the Volume and DiffVolume Names
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"Storage::PutInstance: Volume Object path parse failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathDiffVolume.Init(bstrDiffVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"Storage::PutInstance: DiffVolume Object path parse failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"Storage volume key property DeviceID not found");

        bstrDiffVolumeName = objPathDiffVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrDiffVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"Storage diff volume key property DeviceID not found");

        // Get the provider ID list
        SelectDiffAreaProvider(&idProvider);

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        // Get the Mgmt object for the Provider
        ft.hr = spMgmt->GetProviderMgmtInterface(
            idProvider,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

        // Retrieve non-key properties of the object to be saved.
        rInstToPut.GetPropertyI64(&llMaxSpace, PVDR_PROP_MAXSPACE);

        // Change the max storage space for this association
        ft.hr = spDiffMgmt->ChangeDiffAreaMaximumSize(
            bstrVolumeName,
            bstrDiffVolumeName,
            llMaxSpace);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CStorage::PutInstance()

HRESULT
CStorage::ExecuteMethod(
    IN BSTR bstrObjPath,
    IN WCHAR* pwszMethodName,
    IN long lFlag,
    IN IWbemClassObject* pParams,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::ExecuteMethod");
    
    try
    {
        if (!_wcsicmp(pwszMethodName, PVDR_MTHD_CREATE))
        {                        
            CComPtr<IWbemClassObject> spOutParamClass;
            _bstr_t bstrVolume, bstrDiffVolume;
            LONGLONG llMaxSpace = -1;
            CWbemClassObject wcoOutParam;
            DWORD rcCreateStatus = ERROR_SUCCESS;

            if (pParams == NULL)
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Storage::Create called with no parameters, hr<%#x>", ft.hr);
            }
                        
            CWbemClassObject wcoInParam(pParams);
            
            // Gets the Volume name string - input param
            wcoInParam.GetProperty(bstrVolume, PVDR_PROP_VOLUME);
            IF_WSTR_NULL_THROW(bstrVolume, WBEM_E_INVALID_METHOD_PARAMETERS, L"Storage Create volume param is NULL");
            
            // Gets the DiffVolume name string - input param
            wcoInParam.GetProperty(bstrDiffVolume, PVDR_PROP_DIFFVOLUME);
            IF_WSTR_NULL_THROW(bstrDiffVolume, WBEM_E_INVALID_METHOD_PARAMETERS, L"Storage Create diff volume param is NULL");
            
            // Gets the MaxSpace property - input param
            wcoInParam.GetPropertyI64(&llMaxSpace, PVDR_PROP_MAXSPACE);

            ft.hr = m_pClass->GetMethod(
                _bstr_t(PVDR_MTHD_CREATE),
                0,
                NULL,
                &spOutParamClass
                );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Create GetMethod failed, hr<%#x>", ft.hr);

            ft.hr = spOutParamClass->SpawnInstance(0, &wcoOutParam);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            rcCreateStatus = Create(bstrVolume, bstrDiffVolume, llMaxSpace);

            ft.hr = wcoOutParam.SetProperty(rcCreateStatus, PVD_WBEM_PROP_RETURNVALUE);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SetProperty failed, hr<%#x>", ft.hr);
        
            ft.hr = pHandler->Indicate( 1, wcoOutParam.dataPtr() );
        }
        else
        {
            ft.hr = WBEM_E_INVALID_METHOD;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Invalid method called, %lS, hr<%#x>", pwszMethodName, ft.hr);            
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }
    
    return ft.hr;

} //*** CStorage::ExecuteMethod()

HRESULT
CStorage::Create(
    IN BSTR bstrVolume,
    IN BSTR bstrDiffVolume,
    IN LONGLONG llMaxSpace)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::Create");
    DWORD rcStatus = ERROR_SUCCESS;
    DWORD dwRet = ERROR_SUCCESS;

    do
    {
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        CComPtr<IVssSnapshotMgmt> spMgmt;
        VSS_ID idProvider = GUID_NULL;
        BOOL fSupported = false;
        WCHAR wszVolumeGUIDName[MAX_PATH];
        WCHAR wszDiffVolumeGUIDName[MAX_PATH];

        // Input volume name can be drive letter path, mount point or volume GUID name.
        // Get the volume GUID name; error if none found
        // This API returns the volume GUID name when the GUID name is input
        if (!GetVolumeNameForVolumeMountPoint(
            bstrVolume,
            wszVolumeGUIDName,
            ARRAY_LEN(wszVolumeGUIDName)))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_INVALID_NAME)
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"invalid volume name %lS", (WCHAR*)bstrVolume);
            }
            // may return ERROR_FILE_NOT_FOUND == GetLastError()
            ft.hr = HRESULT_FROM_WIN32(dwRet);
            ft.Trace(VSSDBG_VSSADMIN, L"GetVolumeNameForVolumeMountPoint failed %#x", dwRet);
            break;
        }
        
        // Get the differential volume GUID name; error if none found
        if (!GetVolumeNameForVolumeMountPoint(
            bstrDiffVolume,
            wszDiffVolumeGUIDName,
            ARRAY_LEN(wszDiffVolumeGUIDName)))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_INVALID_NAME)
            {
                ft.hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"invalid volume name %lS", (WCHAR*)bstrVolume);
            }
            // may return ERROR_FILE_NOT_FOUND == GetLastError()
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.Trace(VSSDBG_VSSADMIN, L"GetVolumeNameForVolumeMountPoint failed %#x", GetLastError());
            break;
        }

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"Connection failed with hr<%#x>", ft.hr);
            break;
        }

        SelectDiffAreaProvider(&idProvider);
        
        ft.hr = m_spCoord->IsVolumeSupported(idProvider, wszVolumeGUIDName, &fSupported);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"IsVolumeSupported failed, hr<%#x>", ft.hr);
            break;
        }

        ft.hr = spMgmt->GetProviderMgmtInterface(
            idProvider,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);
            break;
        }

        ft.hr = spDiffMgmt->AddDiffArea(wszVolumeGUIDName, wszDiffVolumeGUIDName, llMaxSpace);            
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN, L"AddDiffArea failed, hr<%#x>", ft.hr);
            break;
        }
    }
    while(false);

    if (ft.hr == E_OUTOFMEMORY)
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"CStorage::Create: out of memory");
        
    CreateMapStatus(ft.hr, rcStatus);
    
    return rcStatus;
}  //*** CStorage::Create()

void
CStorage::CreateMapStatus(
        IN HRESULT hr,
        OUT DWORD& rc
        )
{
    HRESULT hrFileNotFound = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (hr == hrFileNotFound)
        rc = VSS_STORAGE_CREATE_RC_VOLUME_NOT_FOUND;
    else if (hr == S_OK)
        rc = VSS_STORAGE_CREATE_RC_NO_ERROR;        
    else if (hr == E_ACCESSDENIED)
        rc = VSS_STORAGE_CREATE_RC_ACCESS_DENIED;        
    else if (hr == E_INVALIDARG)
        rc = VSS_STORAGE_CREATE_RC_INVALID_ARG;
    else if (hr == VSS_E_OBJECT_NOT_FOUND)
        rc = VSS_STORAGE_CREATE_RC_VOLUME_NOT_FOUND;
    else if (hr == VSS_E_VOLUME_NOT_SUPPORTED)
        rc = VSS_STORAGE_CREATE_RC_VOLUME_NOT_SUPPORTED;
    else if (hr == VSS_E_OBJECT_ALREADY_EXISTS)
        rc = VSS_STORAGE_CREATE_RC_OBJECT_ALREADY_EXISTS;
    else if (hr == VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED)
        rc = VSS_STORAGE_CREATE_RC_MAXIMUM_NUMBER_OF_DIFFAREA_REACHED;
    else if (hr == VSS_E_PROVIDER_VETO)
        rc = VSS_STORAGE_CREATE_RC_PROVIDER_VETO;
    else if (hr == VSS_E_PROVIDER_NOT_REGISTERED)
        rc = VSS_STORAGE_CREATE_RC_PROVIDER_NOT_REGISTERED;
    else if (hr == VSS_E_UNEXPECTED_PROVIDER_ERROR)
        rc = VSS_STORAGE_CREATE_RC_UNEXPECTED_PROVIDER_FAILURE;
    else if (hr == E_UNEXPECTED)
        rc = VSS_STORAGE_CREATE_RC_UNEXPECTED;
    else
        rc = VSS_STORAGE_CREATE_RC_UNEXPECTED;

 }
        
void
CStorage::LoadInstance(
    IN VSS_DIFF_AREA_PROP* pProp,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathVolume;
    CObjPath pathDiffVolume;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::LoadInstance");
    
    // Set the Volume Ref property
    if (!pathVolume.Init(PVDR_CLASS_VOLUME))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"Storage::LoadInstance: Volume object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathVolume.AddProperty(PVDR_PROP_DEVICEID, pProp->m_pwszVolumeName))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"Storage::LoadInstance: unable to add DeviceID property to object path");
    
    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVDR_PROP_VOLUME);

    // Set the DiffVolume Ref property
    if (!pathDiffVolume.Init(PVDR_CLASS_VOLUME))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"Storage::LoadInstance: DiffVolume object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathDiffVolume.AddProperty(PVDR_PROP_DEVICEID, pProp->m_pwszDiffAreaVolumeName))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"Storage::LoadInstance: unable to add DeviceID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathDiffVolume.GetObjectPathString(), PVDR_PROP_DIFFVOLUME);

    // Set the MaxSpace property
    wcoInstance.SetPropertyI64((ULONGLONG)pProp->m_llMaximumDiffSpace, PVDR_PROP_MAXSPACE);

    // Set the AllocatedSpace property
    wcoInstance.SetPropertyI64((ULONGLONG)pProp->m_llAllocatedDiffSpace, PVDR_PROP_ALLOCATEDSPACE);

    // Set the UsedSpace property
    wcoInstance.SetPropertyI64((ULONGLONG)pProp->m_llUsedDiffSpace, PVDR_PROP_USEDSPACE);
}

HRESULT
CStorage::DeleteInstance(
        IN CObjPath& rObjPath,
        IN long lFlag,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::DeleteInstance");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        _bstr_t bstrVolumeRef, bstrVolumeName;
        _bstr_t bstrDiffVolumeRef, bstrDiffVolumeName;
        CObjPath  objPathVolume;
        CObjPath  objPathDiffVolume;
        VSS_ID idProvider = GUID_NULL;
        BOOL fSupported = false;

        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_VOLUME);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"Storage::DeleteInstance: storage volume key property not found");

        // Get the DiffVolume reference
        bstrDiffVolumeRef = rObjPath.GetStringValueForProperty(PVDR_PROP_DIFFVOLUME);
        IF_WSTR_NULL_THROW(bstrDiffVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"Storage::DeleteInstance: storage diff volume key property not found");

        // Extract the Volume and DiffVolume Names
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"Storage::DeleteInstance: Volume object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathDiffVolume.Init(bstrDiffVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"Storage::DeleteInstance: DiffVolume object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrVolumeName = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"Storage::DeleteInstance: storage volume key DeviceID property not found");

        bstrDiffVolumeName = objPathDiffVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrDiffVolumeName, WBEM_E_INVALID_OBJECT_PATH, L"Storage::DeleteInstance: storage diff volume key DeviceID property not found");

        SelectDiffAreaProvider(&idProvider);

        // Find the provider that supports the Volume

        ft.hr = m_spCoord->IsVolumeSupported(idProvider, bstrVolumeName, &fSupported);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"IsVolumeSupported failed, hr<%#x>", ft.hr);

        if (!fSupported)
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Volume not supported by selected provider");
        }

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        // Get the Mgmt object for the Provider
        ft.hr = spMgmt->GetProviderMgmtInterface(
            idProvider,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

        // Change the max storage space to the
        // 'magic number' reserved for deletion.
        ft.hr = spDiffMgmt->ChangeDiffAreaMaximumSize(
            bstrVolumeName,
            bstrDiffVolumeName,
            VSS_ASSOC_REMOVE);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CStorage::DeleteInstance()

//
// SelectDiffAreaProvider
//
// Returns the first 3rd party provider found
// Otherwise it returns the Microsoft Diff Area Provider.
//
void
CStorage::SelectDiffAreaProvider(
    OUT GUID* pProviderID
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CStorage::SelectProviderForStorage");
    CComPtr<IVssEnumObject> spEnumProvider;
    CComPtr<IVssSnapshotMgmt> spMgmt;

    // Set the default provider
    *pProviderID = VSS_SWPRV_ProviderId;

    // Create snapshot mgmt object
    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VssSnapshotMgmt,
            L"VssSnapshotMgmt",
            CLSCTX_ALL,
            IID_IVssSnapshotMgmt,
            (IUnknown**)&(spMgmt));
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);
        
    ft.hr = m_spCoord->Query(
            GUID_NULL,
            VSS_OBJECT_NONE,
            VSS_OBJECT_PROVIDER,
            &spEnumProvider);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Query for Providers failed hr<%#x>", ft.hr);
                        
    while (1)
    {
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        VSS_OBJECT_PROP prop;
        VSS_PROVIDER_PROP& propProv = prop.Obj.Prov;
        ULONG ulFetch = 0;

        ft.hr = spEnumProvider->Next(1, &prop, &ulFetch);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

        if (ft.hr == S_FALSE)
            break;

        CVssAutoPWSZ awszProviderName(propProv.m_pwszProviderName);
        CVssAutoPWSZ awszProviderVersion(propProv.m_pwszProviderVersion);

        if (propProv.m_ProviderId != VSS_SWPRV_ProviderId)
        {
            ft.hr = spMgmt->GetProviderMgmtInterface(
                propProv.m_ProviderId,
                IID_IVssDifferentialSoftwareSnapshotMgmt,
                reinterpret_cast<IUnknown**>(&spDiffMgmt));
            
            if (ft.hr == E_NOINTERFACE)
                continue;  // Inteface not supported, check next provider

            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

            *pProviderID = propProv.m_ProviderId;
            
            break;                
        }
    }

    return;
}

//****************************************************************************
//
//  CShadowFor
//
//****************************************************************************

CShadowFor::CShadowFor( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CShadowFor::CShadowFor()

CProvBase *
CShadowFor::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CShadowFor * pShadowFor = NULL;
    pShadowFor = new CShadowFor(pwszName, pNamespace);

    if (pShadowFor)
    {
        hr = pShadowFor->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pShadowFor;
        pShadowFor = NULL;
    }
    return pShadowFor;

} //*** CShadowFor::S_CreateThis()

HRESULT
CShadowFor::EnumInstance( 
        long lFlags,
        IWbemContext* pCtx,
        IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowFor::EnumInstance");

    try
    {
        CComPtr<IVssEnumObject> spEnumShadow;

        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);

        ft.hr = m_spCoord->Query(
                GUID_NULL,
                VSS_OBJECT_NONE,
                VSS_OBJECT_SNAPSHOT,
                &spEnumShadow);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::Query failed, hr<%#x>", ft.hr);

        while (ft.HrSucceeded() && ft.hr != S_FALSE)
        {
            CComPtr<IWbemClassObject> spInstance;
            VSS_OBJECT_PROP prop;
            ULONG ulFetch = 0;

            ft.hr = spEnumShadow->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                break;  // All done
            }

            CVssAutoSnapshotProperties apropSnap(prop);

            // Spawn an instance of the class
            ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            LoadInstance(apropSnap.GetPtr(), spInstance.p);

            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CShadowFor::EnumInstance()

HRESULT
CShadowFor::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowFor::GetObject");

    try
    {
        CComPtr<IWbemClassObject> spInstance;
        _bstr_t bstrVolumeRef, bstrVolumeID;
        _bstr_t bstrShadowRef, bstrShadowID;
        CObjPath  objPathVolume;
        CObjPath  objPathShadow;
        VSS_SNAPSHOT_PROP propSnap;
        
        // Get the Volume reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_ANTECEDENT);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"ShadowFor volume key property not found");

        // Get the Shadow reference
        bstrShadowRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_DEPENDENT);
        IF_WSTR_NULL_THROW(bstrShadowRef, WBEM_E_INVALID_OBJECT_PATH, L"ShadowFor shadow key property not found");

        // Extract the Volume and Shadow IDs
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"ShadowFor::GetObject: Volume object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathShadow.Init(bstrShadowRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"ShadowFor::GetObject: Shadow object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrVolumeID = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeID, WBEM_E_INVALID_OBJECT_PATH, L"ShadowFor volume key property DeviceID not found");

        bstrShadowID = objPathShadow.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrShadowID, WBEM_E_INVALID_OBJECT_PATH, L"ShadowFor shadow key property ID not found");

        ft.hr = GetShadowPropertyStruct(m_spCoord, bstrShadowID, &propSnap);
        if (ft.HrFailed())
        {
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                  L"GetShadowPropertyStruct failed for shadow copy %lS, hr<%#x>", (WCHAR*)bstrShadowID, ft.hr);
        }

        CVssAutoSnapshotProperties apropSnap(propSnap);
        
        // Verify the referenced Volume ID is the same as in the shadow properties
        if (_wcsicmp(bstrVolumeID, propSnap.m_pwszOriginalVolumeName) != 0)
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Referenced volume ID does not match shadow original volume");            
        }
        
        // Spawn an instance of the class
        ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

        LoadInstance(apropSnap.GetPtr(), spInstance.p);

        ft.hr = pHandler->Indicate(1, &spInstance.p);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

void
CShadowFor::LoadInstance(
    IN VSS_SNAPSHOT_PROP* pProp,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathShadow;
    CObjPath pathVolume;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowFor::LoadInstance");

    // Set the Shadow Ref property
    CVssAutoPWSZ awszGUID(GuidToString(pProp->m_SnapshotId));  // Auto-delete string
    if (!pathShadow.Init(PVDR_CLASS_SHADOW))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowFor::LoadInstance: Shadow object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathShadow.AddProperty(PVDR_PROP_ID, awszGUID))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowFor::LoadInstance: unable to add ID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathShadow.GetObjectPathString(), PVD_WBEM_PROP_DEPENDENT);

    // Set the Volume Ref property
    if (!pathVolume.Init(PVDR_CLASS_VOLUME))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowFor::LoadInstance: Volume object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathVolume.AddProperty(PVDR_PROP_DEVICEID, pProp->m_pwszOriginalVolumeName))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowFor::LoadInstance: unable to add DeviceID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVD_WBEM_PROP_ANTECEDENT);
}


//****************************************************************************
//
//  CShadowBy
//
//****************************************************************************

CShadowBy::CShadowBy( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CShadowBy::CShadowBy()

CProvBase *
CShadowBy::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CShadowBy* pShadowBy = NULL;
    pShadowBy = new CShadowBy(pwszName, pNamespace);

    if ( pShadowBy )
    {
        hr = pShadowBy->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pShadowBy;
        pShadowBy = NULL;
    }
    return pShadowBy;

} //*** CShadowBy::S_CreateThis()

HRESULT
CShadowBy::EnumInstance( 
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowBy::EnumInstance");

    try
    {
        CComPtr<IVssEnumObject> spEnumShadow;

        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);

        ft.hr = m_spCoord->Query(
                GUID_NULL,
                VSS_OBJECT_NONE,
                VSS_OBJECT_SNAPSHOT,
                &spEnumShadow);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::Query failed, hr<%#x>", ft.hr);

        while (ft.HrSucceeded() && ft.hr != S_FALSE)
        {
            CComPtr<IWbemClassObject> spInstance;
            VSS_OBJECT_PROP prop;
            ULONG ulFetch = 0;

            ft.hr = spEnumShadow->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);
            
            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                break;  // All done
            }

            CVssAutoSnapshotProperties apropSnap(prop);
            
            // Spawn an instance of the class
            ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

            LoadInstance(apropSnap.GetPtr(), spInstance.p);

            ft.hr = pHandler->Indicate(1, &spInstance.p);
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CShadowBy::EnumInstance()


HRESULT
CShadowBy::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowBy::GetObject");

    try
    {
        CComPtr<IWbemClassObject> spInstance;
        _bstr_t bstrProviderRef, bstrProviderID;
        _bstr_t bstrShadowRef, bstrShadowID;
        CObjPath  objPathProvider;
        CObjPath  objPathShadow;
        VSS_SNAPSHOT_PROP propSnap;
        
        // Get the Provider reference
        bstrProviderRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_ANTECEDENT);
        IF_WSTR_NULL_THROW(bstrProviderRef, WBEM_E_INVALID_OBJECT_PATH, L"ShadowBy provider key property not found");

        // Get the Shadow reference
        bstrShadowRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_DEPENDENT);
        IF_WSTR_NULL_THROW(bstrShadowRef, WBEM_E_INVALID_OBJECT_PATH, L"ShadowBy shadow key property not found");

        // Extract the Volume and Shadow IDs
        if (!objPathProvider.Init(bstrProviderRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"ShadowBy::GetObject: Provider object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathShadow.Init(bstrShadowRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"ShadowBy::GetObject: Shadow object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrProviderID = objPathProvider.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrProviderID, WBEM_E_INVALID_OBJECT_PATH, L"ShadowBy provider key property ID not found");

        bstrShadowID = objPathShadow.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrShadowID, WBEM_E_INVALID_OBJECT_PATH, L"ShadowBy shadow key property ID not found");

        ft.hr = GetShadowPropertyStruct(m_spCoord, bstrShadowID, &propSnap);
        if (ft.HrFailed())
        {
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                  L"GetShadowPropertyStruct failed for shadow copy %lS, hr<%#x>", (WCHAR*)bstrShadowID, ft.hr);
        }

        CVssAutoSnapshotProperties apropSnap(propSnap);

        // Verify the referenced Volume ID is the same as in the shadow properties
        if (!StringGuidIsGuid(bstrProviderID, propSnap.m_ProviderId))
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Referenced provider ID does not match shadow provider id");            
        }
        
        // Spawn an instance of the class
        ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

        LoadInstance(apropSnap.GetPtr(), spInstance.p);

        ft.hr = pHandler->Indicate(1, &spInstance.p);
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

void
CShadowBy::LoadInstance(
    IN VSS_SNAPSHOT_PROP* pProp,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathShadow;
    CObjPath pathProvider;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowBy::LoadInstance");
    
    // Set the Shadow Ref property
    CVssAutoPWSZ awszGUID(GuidToString(pProp->m_SnapshotId));  // Auto-delete string
    if (!pathShadow.Init(PVDR_CLASS_SHADOW))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowBy::LoadInstance: Shadow object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathShadow.AddProperty(PVDR_PROP_ID, awszGUID))  
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowBy::LoadInstance: unable to add ID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathShadow.GetObjectPathString(), PVD_WBEM_PROP_DEPENDENT);

    // Set the Provider Ref property
    awszGUID.Attach(GuidToString(pProp->m_ProviderId));
    if (!pathProvider.Init(PVDR_CLASS_PROVIDER))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowBy::LoadInstance: Provider object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathProvider.AddProperty(PVDR_PROP_ID, awszGUID))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"ShadowBy::LoadInstance: unable to add ID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathProvider.GetObjectPathString(), PVD_WBEM_PROP_ANTECEDENT);
}


//****************************************************************************
//
//  CShadowOn
//
//****************************************************************************

CShadowOn::CShadowOn( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CShadowOn::CShadowOn()

CProvBase *
CShadowOn::S_CreateThis( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CShadowOn * pShadowOn = NULL;
    pShadowOn = new CShadowOn(pwszName, pNamespace);

    if (pShadowOn)
    {
        hr = pShadowOn->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pShadowOn;
        pShadowOn = NULL;
    }
    return pShadowOn;

} //*** CShadowOn::S_CreateThis()

HRESULT
CShadowOn::EnumInstance( 
        IN long lFlagsIn,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowOn::EnumInstance");

    try
    {
        CComPtr<IVssEnumObject> spEnumShadow;
        CComPtr<IVssSnapshotMgmt> spMgmt;

        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        ft.hr = m_spCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);

        ft.hr = m_spCoord->Query(
                GUID_NULL,
                VSS_OBJECT_NONE,
                VSS_OBJECT_SNAPSHOT,
                &spEnumShadow);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"IVssCoordinator::Query failed, hr<%#x>", ft.hr);

        while (ft.HrSucceeded() && ft.hr != S_FALSE)
        {
            CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
            CComPtr<IVssEnumMgmtObject> spEnumDiffArea;
            VSS_OBJECT_PROP propObj;
            ULONG ulFetch = 0;

            ft.hr = spEnumShadow->Next(1, &propObj, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                break;  // All done
            }

            CVssAutoSnapshotProperties apropSnap(propObj);

            // Does the provider support diff areas?
            ft.hr = spMgmt->GetProviderMgmtInterface(
                apropSnap->m_ProviderId,
                IID_IVssDifferentialSoftwareSnapshotMgmt,
                reinterpret_cast<IUnknown**>(&spDiffMgmt));

            if (ft.hr == E_NOINTERFACE)
            {
                ft.hr = S_OK;
                continue;  // Diff areas not supported; try next shadow
            }

            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

            // Diff areas supported, continue
            ft.hr = spDiffMgmt->QueryDiffAreasForSnapshot(
                apropSnap->m_SnapshotId,
                &spEnumDiffArea);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"QueryDiffAreasForSnapshot failed, hr<%#x>", ft.hr);

            // Theoretically possible for a single snapshot to be on multiple diff areas
            while (1)
            {
                CComPtr<IWbemClassObject> spInstance;
                VSS_MGMT_OBJECT_PROP propMgmt;
                VSS_DIFF_AREA_PROP& propDiffArea = propMgmt.Obj.DiffArea;
                
                ulFetch = 0;
                ft.hr = spEnumDiffArea->Next(1, &propMgmt, &ulFetch);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

                if (ft.hr == S_FALSE)
                {
                    ft.hr = S_OK;
                    break;  // No more diff areas
                }

                CVssAutoPWSZ awszVolumeName(propDiffArea.m_pwszVolumeName);
                CVssAutoPWSZ awszDiffAreaVolumeName(propDiffArea.m_pwszDiffAreaVolumeName);
                
                // Spawn an instance of the class
                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(apropSnap.GetPtr(), &propDiffArea, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CShadowOn::EnumInstance()


HRESULT
CShadowOn::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowOn::GetObject");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssEnumMgmtObject> spEnumDiffArea;
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        _bstr_t bstrVolumeRef, bstrVolumeID;
        _bstr_t bstrShadowRef, bstrShadowID;
        CObjPath  objPathVolume;
        CObjPath  objPathShadow;
        VSS_SNAPSHOT_PROP propSnap;
        
        // Get the Provider reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_ANTECEDENT);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"ShadowOn volume key property not found");

        // Get the Shadow reference
        bstrShadowRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_DEPENDENT);
        IF_WSTR_NULL_THROW(bstrShadowRef, WBEM_E_INVALID_OBJECT_PATH, L"ShadowOn shadow key property not found");

        // Extract the Volume and Shadow IDs
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"ShadowOn::GetObject: Volume object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathShadow.Init(bstrShadowRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"ShadowOn::GetObject: Shadow object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrVolumeID = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeID, WBEM_E_INVALID_OBJECT_PATH, L"ShadowOn volume key property DeviceID not found");

        bstrShadowID = objPathShadow.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrShadowID, WBEM_E_INVALID_OBJECT_PATH, L"ShadowOn shadow key property ID not found");

        ft.hr = GetShadowPropertyStruct(m_spCoord, bstrShadowID, &propSnap);
        if (ft.HrFailed())
        {
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                  L"GetShadowPropertyStruct failed for shadow copy %lS, hr<%#x>", (WCHAR*)bstrShadowID, ft.hr);
        }

        CVssAutoSnapshotProperties apropSnap(propSnap);

        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        // Does the provider support diff areas?
        ft.hr = spMgmt->GetProviderMgmtInterface(
            apropSnap->m_ProviderId,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));

        if (ft.hr == E_NOINTERFACE)
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"shadow copy %lS was not created by a differential provider", (WCHAR*)bstrShadowID);
        }

        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

        // Diff areas supported, continue
        ft.hr = spDiffMgmt->QueryDiffAreasForSnapshot(
            apropSnap->m_SnapshotId,
            &spEnumDiffArea);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"QueryDiffAreasForSnapshot failed, hr<%#x>", ft.hr);

        // Theoretically possible for a single snapshot to be on multiple diff areas
        while (ft.hr != FALSE)
        {
            CComPtr<IWbemClassObject> spInstance;
            VSS_MGMT_OBJECT_PROP propMgmt;
            VSS_DIFF_AREA_PROP& propDiffArea = propMgmt.Obj.DiffArea;
            ULONG ulFetch = 0;
            
            ft.hr = spEnumDiffArea->Next(1, &propMgmt, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                break;  // No more diff areas; diff area not found
            }

            CVssAutoPWSZ awszVolumeName(propDiffArea.m_pwszVolumeName);
            CVssAutoPWSZ awszDiffAreaVolumeName(propDiffArea.m_pwszDiffAreaVolumeName);

            // Look for the difference area that is stored ON the referenced volume
            if (_wcsicmp(awszDiffAreaVolumeName, bstrVolumeID) == 0)
            {
                CComPtr<IWbemClassObject> spInstance;
                
                // Spawn an instance of the class
                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(apropSnap.GetPtr(), &propDiffArea, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);

                break;
            }
        }

        if (ft.hr == S_FALSE)
        {
            ft.hr = WBEM_E_NOT_FOUND;
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

void
CShadowOn::LoadInstance(
    IN VSS_SNAPSHOT_PROP* pPropSnap,
    IN VSS_DIFF_AREA_PROP* pPropDiff,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathShadow;
    CObjPath pathVolume;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CShadowOn::LoadInstance");

    // Set the Shadow Ref property
    CVssAutoPWSZ awszGUID(GuidToString(pPropSnap->m_SnapshotId));  // Auto-delete string
    if (!pathShadow.Init(PVDR_CLASS_SHADOW))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"CShadowOn::LoadInstance: Shadow object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathShadow.AddProperty(PVDR_PROP_ID, awszGUID))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"CShadowOn::LoadInstance: unable to add ID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathShadow.GetObjectPathString(), PVD_WBEM_PROP_DEPENDENT);

    // Set the DiffVolume Ref property
    if (!pathVolume.Init(PVDR_CLASS_VOLUME))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"CShadowOn::LoadInstance: DiffVolume object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathVolume.AddProperty(PVDR_PROP_DEVICEID, pPropDiff->m_pwszDiffAreaVolumeName))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"CShadowOn::LoadInstance: unable to add DeviceID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVD_WBEM_PROP_ANTECEDENT);
}


//****************************************************************************
//
//  CVolumeSupport
//
//****************************************************************************

CVolumeSupport::CVolumeSupport( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CVolumeSupport::CVolumeSupport()

CProvBase *
CVolumeSupport::S_CreateThis( 
    IN PCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CVolumeSupport * pVolumeSupport = NULL;
    pVolumeSupport = new CVolumeSupport(pwszName, pNamespace);

    if (pVolumeSupport)
    {
        hr = pVolumeSupport->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pVolumeSupport;
        pVolumeSupport = NULL;
    }
    return pVolumeSupport;

} //*** CVolumeSupport::S_CreateThis()

HRESULT
CVolumeSupport::EnumInstance( 
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeSupport::EnumInstance");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CGUIDList listProviderID;
        GUID guid;

        // Get the provider IDs
        GetProviderIDList(m_spCoord, &listProviderID);

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        while (listProviderID.Extract(guid))
        {
            CComPtr<IVssEnumMgmtObject> spEnumMgmt;
            
            ft.hr = spMgmt->QueryVolumesSupportedForSnapshots(
                        guid,
                        VSS_CTX_ALL,
                        &spEnumMgmt );
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"QueryVolumesSupportedForSnapshots failed, hr<%#x>", ft.hr);

            // An empty enumerator was returned (S_FALSE) for this provider; try next one
            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                continue;
            }

            while (1)
            {
                CComPtr<IWbemClassObject> spInstance;
                VSS_MGMT_OBJECT_PROP prop;
                VSS_VOLUME_PROP& propVolume = prop.Obj.Vol;
                ULONG ulFetch = 0;

                ft.hr = spEnumMgmt->Next(1, &prop, &ulFetch);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

                if (ft.hr == S_FALSE)
                {
                    ft.hr = S_OK;
                    break;  // All done with this provider
                }

                CVssAutoPWSZ awszVolumeName(propVolume.m_pwszVolumeName);
                CVssAutoPWSZ awszVolumeDisplayName(propVolume.m_pwszVolumeDisplayName);
                
                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(&guid, &propVolume, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CVolumeSupport::EnumInstance()


HRESULT
CVolumeSupport::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeSupportr::GetObject");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssEnumMgmtObject> spEnumMgmt;
        _bstr_t bstrProviderRef, bstrProviderID;
        _bstr_t bstrVolumeRef, bstrVolumeID;
        CObjPath  objPathProvider;
        CObjPath  objPathVolume;
        GUID guid = GUID_NULL;
        
        // Get the Provider reference
        bstrProviderRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_ANTECEDENT);
        IF_WSTR_NULL_THROW(bstrProviderRef, WBEM_E_INVALID_OBJECT_PATH, L"VolumeSupport provider key property not found");

        // Get the Shadow reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_DEPENDENT);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"VolumeSupport volume key property not found");

        // Extract the Volume and Shadow IDs
        if (!objPathProvider.Init(bstrProviderRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"VolumeSupport::GetObject: Provider object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"VolumeSupport::GetObject: Volume object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrProviderID = objPathProvider.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrProviderID, WBEM_E_INVALID_OBJECT_PATH, L"VolumeSupport provider key property ID not found");

        bstrVolumeID = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeID, WBEM_E_INVALID_OBJECT_PATH, L"VolumeSupport support key property DeviceID not found");

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        // Convert string GUID
        if (FAILED(CLSIDFromString(bstrProviderID, &guid)))
        {
            ft.hr = E_INVALIDARG;
            ft.Trace(VSSDBG_VSSADMIN, L"CLSIDFromString failed");
         }

        ft.hr = spMgmt->QueryVolumesSupportedForSnapshots(
                    guid,
                    VSS_CTX_ALL,
                    &spEnumMgmt );
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
            L"QueryVolumesSupportedForSnapshots failed, hr<%#x>", ft.hr);


        while (ft.hr != S_FALSE)
        {
            VSS_MGMT_OBJECT_PROP prop;
            VSS_VOLUME_PROP& propVolume = prop.Obj.Vol;
            ULONG ulFetch = 0;

            ft.hr = spEnumMgmt->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                break;  // Volume not found for this provider
            }

            CVssAutoPWSZ awszVolumeName(propVolume.m_pwszVolumeName);
            CVssAutoPWSZ awszVolumeDisplayName(propVolume.m_pwszVolumeDisplayName);

            if (_wcsicmp(awszVolumeName, bstrVolumeID) == 0)
            {
                CComPtr<IWbemClassObject> spInstance;

                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(&guid, &propVolume, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
                
                break;
            }
        }
       
        if (ft.hr == S_FALSE)
        {
            ft.hr = WBEM_E_NOT_FOUND;
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

void
CVolumeSupport::LoadInstance(
    IN GUID* pProviderID,
    IN VSS_VOLUME_PROP* pPropVol,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathProvider;
    CObjPath pathVolume;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVolumeSupport::LoadInstance");
    
    // Set the Provider Ref property
    CVssAutoPWSZ awszGUID(GuidToString(*pProviderID));  // Auto-delete string
    if (!pathProvider.Init(PVDR_CLASS_PROVIDER))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"VolumeSupport::LoadInstance: Provider object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathProvider.AddProperty(PVDR_PROP_ID, awszGUID))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"VolumeSupport::LoadInstance: unable to add ID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathProvider.GetObjectPathString(), PVD_WBEM_PROP_ANTECEDENT);

    // Set the Volume Ref property
    if (!pathVolume.Init(PVDR_CLASS_VOLUME))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"VolumeSupport::LoadInstance: Volume object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathVolume.AddProperty(PVDR_PROP_DEVICEID, pPropVol->m_pwszVolumeName))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"VolumeSupport::LoadInstance: unable to add DeviceID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVD_WBEM_PROP_DEPENDENT);
}


//****************************************************************************
//
//  CDiffVolumeSupport
//
//****************************************************************************

CDiffVolumeSupport::CDiffVolumeSupport( 
    IN LPCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
    : CProvBase(pwszName, pNamespace)
{
    
} //*** CDiffVolumeSupport::CDiffVolumeSupport()

CProvBase *
CDiffVolumeSupport::S_CreateThis( 
    IN PCWSTR pwszName,
    IN CWbemServices* pNamespace
    )
{
    HRESULT hr = WBEM_E_FAILED;
    CDiffVolumeSupport * pVolumeSupport = NULL;
    pVolumeSupport = new CDiffVolumeSupport(pwszName, pNamespace);

    if (pVolumeSupport)
    {
        hr = pVolumeSupport->Initialize();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr))
    {
        delete pVolumeSupport;
        pVolumeSupport = NULL;
    }
    return pVolumeSupport;

} //*** CDiffVolumeSupport::S_CreateThis()

HRESULT
CDiffVolumeSupport::EnumInstance( 
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemObjectSink* pHandler
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CDiffVolumeSupport::EnumInstance");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CGUIDList listProviderID;
        GUID guid;

        // Get the provider IDs
        GetProviderIDList(m_spCoord, &listProviderID);

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        while (listProviderID.Extract(guid))
        {
            CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
            CComPtr<IVssEnumMgmtObject> spEnumMgmt;

            ft.hr = spMgmt->GetProviderMgmtInterface(
                guid,
                IID_IVssDifferentialSoftwareSnapshotMgmt,
                reinterpret_cast<IUnknown**>(&spDiffMgmt));

            if (ft.hr == E_NOINTERFACE)
            {
                ft.hr = S_OK;
                continue;  // Inteface not supported, try next provider
            }

            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

            ft.hr = spDiffMgmt->QueryVolumesSupportedForDiffAreas(NULL, &spEnumMgmt);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                    L"QueryVolumesSupportedForDiffAreas failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                ft.hr = S_OK;
                continue;  // no Voumes supported; try next provider
            }
            
            while (1)
            {
                VSS_MGMT_OBJECT_PROP prop;
                VSS_DIFF_VOLUME_PROP& propDiff = prop.Obj.DiffVol;
                CComPtr<IWbemClassObject> spInstance;
                ULONG ulFetch = 0;

                ft.hr = spEnumMgmt->Next(1, &prop, &ulFetch);
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

                if (ft.hr == S_FALSE)
                {
                    ft.hr = S_OK;
                    break;  // No more volumes
                }

                CVssAutoPWSZ awszVolumeName(propDiff.m_pwszVolumeName);
                CVssAutoPWSZ awszVolumeDisplayName(propDiff.m_pwszVolumeDisplayName);
                
                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(&guid, &propDiff, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
            }
        }
    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
} //*** CDiffVolumeSupport::EnumInstance()


HRESULT
CDiffVolumeSupport::GetObject(
    IN CObjPath& rObjPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN IWbemObjectSink* pHandler
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CDiffVolumeSupport::GetObject");

    try
    {
        CComPtr<IVssSnapshotMgmt> spMgmt;
        CComPtr<IVssEnumMgmtObject> spEnumMgmt;
        CComPtr<IVssDifferentialSoftwareSnapshotMgmt> spDiffMgmt;
        _bstr_t bstrProviderRef, bstrProviderID;
        _bstr_t bstrVolumeRef, bstrVolumeID;
        CObjPath  objPathProvider;
        CObjPath  objPathVolume;
        GUID guid = GUID_NULL;
        
        // Get the Provider reference
        bstrProviderRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_ANTECEDENT);
        IF_WSTR_NULL_THROW(bstrProviderRef, WBEM_E_INVALID_OBJECT_PATH, L"DiffVolumeSupport provider key property not found");

        // Get the Shadow reference
        bstrVolumeRef = rObjPath.GetStringValueForProperty(PVD_WBEM_PROP_DEPENDENT);
        IF_WSTR_NULL_THROW(bstrVolumeRef, WBEM_E_INVALID_OBJECT_PATH, L"DiffVolumeSupport volume key property not found");

        // Extract the Volume and Shadow IDs
        if (!objPathProvider.Init(bstrProviderRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"DiffVolumeSupport::GetObject: Provider object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);
        if (!objPathVolume.Init(bstrVolumeRef))
            ft.Throw(VSSDBG_VSSADMIN, WBEM_E_INVALID_OBJECT_PATH, L"DiffVolumeSupport::GetObject: Volume object path initialization failed, hr<%#x>", WBEM_E_INVALID_OBJECT_PATH);

        bstrProviderID = objPathProvider.GetStringValueForProperty(PVDR_PROP_ID);
        IF_WSTR_NULL_THROW(bstrProviderID, WBEM_E_INVALID_OBJECT_PATH, L"DiffVolumeSupport provider key property ID not found");

        bstrVolumeID = objPathVolume.GetStringValueForProperty(PVDR_PROP_DEVICEID);
        IF_WSTR_NULL_THROW(bstrVolumeID, WBEM_E_INVALID_OBJECT_PATH, L"DiffVolumeSupport support key property DeviceID not found");

        // Convert provider string GUID
        if (FAILED(CLSIDFromString(bstrProviderID, &guid)))
        {
            ft.hr = E_INVALIDARG;
            ft.Trace(VSSDBG_VSSADMIN, L"CLSIDFromString failed");
         }

        // Create snapshot mgmt object
        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(spMgmt));
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr<%#x>", ft.hr);

        ft.hr = spMgmt->GetProviderMgmtInterface(
            guid,
            IID_IVssDifferentialSoftwareSnapshotMgmt,
            reinterpret_cast<IUnknown**>(&spDiffMgmt));

        if (ft.hr == E_NOINTERFACE)
        {
            ft.hr = WBEM_E_NOT_FOUND;
            ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"DiffVolumeSupport: provider is not a differential provider");
        }

        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"GetProviderMgmtInterface failed, hr<%#x>", ft.hr);

        ft.hr = spDiffMgmt->QueryVolumesSupportedForDiffAreas(NULL, &spEnumMgmt);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSADMIN, ft.hr,
                L"QueryVolumesSupportedForDiffAreas failed, hr<%#x>", ft.hr);

        while (ft.hr != S_FALSE)
        {
            VSS_MGMT_OBJECT_PROP prop;
            VSS_DIFF_VOLUME_PROP& propDiff = prop.Obj.DiffVol;
            ULONG ulFetch = 0;

            ft.hr = spEnumMgmt->Next(1, &prop, &ulFetch);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"Next failed, hr<%#x>", ft.hr);

            if (ft.hr == S_FALSE)
            {
                break;  // Diff volume not found for this provider
            }

            CVssAutoPWSZ awszVolumeName(propDiff.m_pwszVolumeName);
            CVssAutoPWSZ awszVolumeDisplayName(propDiff.m_pwszVolumeDisplayName);

            if (_wcsicmp(awszVolumeName, bstrVolumeID) == 0)
            {
                CComPtr<IWbemClassObject> spInstance;

                ft.hr = m_pClass->SpawnInstance( 0, &spInstance );
                if (ft.HrFailed())
                    ft.Throw(VSSDBG_VSSADMIN, ft.hr, L"SpawnInstance failed, hr<%#x>", ft.hr);

                LoadInstance(&guid, &propDiff, spInstance.p);

                ft.hr = pHandler->Indicate(1, &spInstance.p);
                
                break;
            }
        }
       
        if (ft.hr == S_FALSE)
        {
            ft.hr = WBEM_E_NOT_FOUND;
        }

    }
    catch (HRESULT hrEx)
    {
        ft.hr = hrEx;
    }

    return ft.hr;
    
}

void
CDiffVolumeSupport::LoadInstance(
    IN GUID* pProviderID,
    IN VSS_DIFF_VOLUME_PROP* pPropVol,
    IN OUT IWbemClassObject* pObject
    )
{
    CWbemClassObject wcoInstance(pObject);
    CObjPath pathProvider;
    CObjPath pathVolume;

    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CDiffVolumeSupport::LoadInstance");

    // Set the Provider Ref property
    CVssAutoPWSZ awszGUID(GuidToString(*pProviderID));  // Auto-delete string
    if (!pathProvider.Init(PVDR_CLASS_PROVIDER))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"DiffVolumeSupport::LoadInstance: Provider object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathProvider.AddProperty(PVDR_PROP_ID, awszGUID))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"DiffVolumeSupport::LoadInstance: unable to add ID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathProvider.GetObjectPathString(), PVD_WBEM_PROP_ANTECEDENT);

    // Set the Volume Ref property
    if (!pathVolume.Init(PVDR_CLASS_VOLUME))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"DiffVolumeSupport::LoadInstance: Volume object path initialization failed, hr<%#x>", E_UNEXPECTED);
    if (!pathVolume.AddProperty(PVDR_PROP_DEVICEID, pPropVol->m_pwszVolumeName))
        ft.Throw(VSSDBG_VSSADMIN, E_UNEXPECTED, L"DiffVolumeSupport::LoadInstance: unable to add DeviceID property to object path");

    wcoInstance.SetProperty((wchar_t*)pathVolume.GetObjectPathString(), PVD_WBEM_PROP_DEPENDENT);
}

HRESULT
GetShadowPropertyStruct(
    IN IVssCoordinator* pCoord,
    IN WCHAR* pwszShadowID,
    OUT VSS_SNAPSHOT_PROP* pPropSnap
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"GetShadowPropertyStruct");
    GUID guid = GUID_NULL;

    _ASSERTE(pPropSnap != NULL);
    _ASSERTE(pwszShadowID != NULL);
    
    // Convert string GUID
    if (FAILED(CLSIDFromString(pwszShadowID, &guid)))
    {
        ft.hr = E_INVALIDARG;
        ft.Trace(VSSDBG_VSSADMIN, L"CLSIDFromString failed");
     }
    else
    {
        // Set the context to see all shadows
        ft.hr = pCoord->SetContext(VSS_CTX_ALL);
        if (ft.HrFailed())
        {
            ft.Trace(VSSDBG_VSSADMIN,
                L"IVssCoordinator::SetContext failed, hr<%#x>", ft.hr);
        }
        else
        {
            // Query for the context to see all shadows
            ft.hr = pCoord->GetSnapshotProperties(
                    guid,
                    pPropSnap);
            
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
            {
                ft.hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return ft.hr;
}

BOOL
StringGuidIsGuid(
    IN WCHAR* pwszGuid,
    IN GUID& guidIn
    )
{
    BOOL fIsEqual = FALSE;
    GUID guid = GUID_NULL;
    
    if (SUCCEEDED(CLSIDFromString(pwszGuid, &guid)))
    {
        fIsEqual = IsEqualGUID(guid, guidIn);
    }
    return fIsEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\vssclasses.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      VssClasses.h
//
//  Implementation File:
//      VssClasses.cpp
//
//  Description:
//      Definition of the VSS WMI Provider classes.
//
//  Author:   Jim Benton (jbenton) 15-Nov-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

HRESULT
GetShadowPropertyStruct(
    IN IVssCoordinator* pCoord,
    IN WCHAR* pwszShadowID,
    OUT VSS_SNAPSHOT_PROP* pPropSnap
    );

BOOL
StringGuidIsGuid(
    IN WCHAR* pwszGuid,
    IN GUID& guidIn
    );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvider
//
//  Description:
//      Provider Implementation for Provider
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProvider : public CProvBase
{
//
// constructor
//
public:
    CProvider(
        LPCWSTR pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CProvider(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );    

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN VSS_PROVIDER_PROP* pProp,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

}; // class CProvider


#ifdef ENABLE_WRITERS
//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWriter
//
//  Description:
//      Provider Implementation for Writer
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWriter : public CProvBase
{
//
// constructor
//
public:
    CWriter(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CWriter(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        return S_OK;
    }

}; // class CWriter
#endif // ENABLE_WRITERS

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CShadow
//
//  Description:
//      Provider Implementation for Shadow
//
//--
//////////////////////////////////////////////////////////////////////////////
class CShadow : public CProvBase
{
//
// constructor
//
public:
    CShadow(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CShadow(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    static CProvBase* S_CreateThis(
        IN LPCWSTR         pwszName,
        IN CWbemServices* pNamespace
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN VSS_SNAPSHOT_PROP* pProp,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

    HRESULT Create(
        IN BSTR bstrContext,
        IN BSTR bstrVolume,
        OUT VSS_ID* pidShadow
        ) throw(HRESULT);

    void CreateMapStatus(
        IN HRESULT hr,
        OUT DWORD& rc
        );

}; // class CShadow

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStorage
//
//  Description:
//      Provider Implementation for Storage
//
//--
//////////////////////////////////////////////////////////////////////////////
class CStorage : public CProvBase
{
//
// constructor
//
public:
    CStorage(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CStorage(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        );
    
    static CProvBase* S_CreateThis(
        LPCWSTR pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN VSS_DIFF_AREA_PROP* pProp,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

    void SelectDiffAreaProvider(
        OUT GUID* pProviderID
        );

    HRESULT Create(
        IN BSTR bstrVolume,
        IN BSTR bstrDiffVolume,
        IN LONGLONG llMaxSpace
        ) throw(HRESULT);

    void CreateMapStatus(
        IN HRESULT hr,
        OUT DWORD& rc
        );

}; // class CStorage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CShadowFor
//
//  Description:
//      Provider Implementation for ShadowFor
//
//--
//////////////////////////////////////////////////////////////////////////////
class CShadowFor : public CProvBase
{
//
// constructor
//
public:
    CShadowFor(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CShadowFor(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN VSS_SNAPSHOT_PROP* pProp,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

}; // class CShadowFor


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CShadowBy
//
//  Description:
//      Provider Implementation for ShadowFor
//
//--
//////////////////////////////////////////////////////////////////////////////
class CShadowBy : public CProvBase
{
//
// constructor
//
public:
    CShadowBy(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CShadowBy(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN VSS_SNAPSHOT_PROP* pProp,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

}; // class CShadowBy


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CShadowOn
//
//  Description:
//      Provider Implementation for ShadowFor
//
//--
//////////////////////////////////////////////////////////////////////////////
class CShadowOn : public CProvBase
{
//
// constructor
//
public:
    CShadowOn(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CShadowOn(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN VSS_SNAPSHOT_PROP* pPropSnap,
        IN VSS_DIFF_AREA_PROP* pPropDiff,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

}; // class CShadowOn

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CVolumeSupport
//
//  Description:
//      Provider Implementation for ShadowFor
//
//--
//////////////////////////////////////////////////////////////////////////////
class CVolumeSupport : public CProvBase
{
//
// constructor
//
public:
    CVolumeSupport(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CVolumeSupport(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN GUID* pProviderID,
        IN VSS_VOLUME_PROP* pPropVol,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

}; // class CVolumeSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CDiffVolumeSupport
//
//  Description:
//      Provider Implementation for ShadowDiffVolumeSupport
//
//--
//////////////////////////////////////////////////////////////////////////////
class CDiffVolumeSupport : public CProvBase
{
//
// constructor
//
public:
    CDiffVolumeSupport(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    ~CDiffVolumeSupport(){}

//
// methods
//
public:

    virtual HRESULT EnumInstance( 
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT GetObject(
        CObjPath&           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext*       pCtxIn,
        IWbemObjectSink*    pHandlerIn
        );

    virtual HRESULT ExecuteMethod(
        BSTR                 bstrObjPathIn,
        WCHAR*              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject*   pParamsIn,
        IWbemObjectSink*    pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };

    virtual HRESULT PutInstance( 
        CWbemClassObject&  rInstToPutIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    virtual HRESULT DeleteInstance(
        CObjPath&          rObjPathIn,
        long                lFlagIn,
        IWbemContext*      pCtxIn,
        IWbemObjectSink*   pHandlerIn
        ) { return WBEM_E_NOT_SUPPORTED; };
    
    static CProvBase* S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices* pNamespaceIn
        );

    HRESULT Initialize()
    {
        HRESULT hr = S_OK;

        hr = m_spCoord.CoCreateInstance(__uuidof(VSSCoordinator));

        return hr;
    }

private:
    CComPtr<IVssCoordinator> m_spCoord;

    void LoadInstance(
        IN GUID* pProviderID,
        IN VSS_DIFF_VOLUME_PROP* pPropVol,
        IN OUT IWbemClassObject* pObject) throw(HRESULT);

}; // class CDiffVolumeSupport

class CVssAutoSnapshotProperties
{
// Constructors/destructors
private:
    CVssAutoSnapshotProperties(const CVssAutoSnapshotProperties&);

public:
    CVssAutoSnapshotProperties(VSS_SNAPSHOT_PROP &Snap): m_pSnap(&Snap) {};
    CVssAutoSnapshotProperties(VSS_OBJECT_PROP &Prop): m_pSnap(&Prop.Obj.Snap) {};

    // Automatically closes the handle
    ~CVssAutoSnapshotProperties() {
        Clear();
    };

// Operations
public:

    // Returns the value
    VSS_SNAPSHOT_PROP *GetPtr() {
        return m_pSnap;
    }
    
    // NULLs out the pointer.  Used after a pointer has been transferred to another
    // funtion.
    void Transferred() {
        m_pSnap = NULL;
    }

    // Clears the contents of the auto string
    void Clear() {
        if ( m_pSnap != NULL )
        {
            ::VssFreeSnapshotProperties(m_pSnap);
            m_pSnap = NULL;
        }
    }

    // Returns the value to the actual pointer
    VSS_SNAPSHOT_PROP* operator->() const {
        return m_pSnap;
    }
    
    // Returns the value of the actual pointer
    operator VSS_SNAPSHOT_PROP* () const {
        return m_pSnap;
    }

private:
    VSS_SNAPSHOT_PROP *m_pSnap;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\schema.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Definition of schema defined strings
//
//  Author:
//      Jim Benton (jbenton)    15-Oct-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef enum _STORAGE_CREATE_ERROR {
        VSS_STORAGE_CREATE_RC_NO_ERROR = 0,
        VSS_STORAGE_CREATE_RC_ACCESS_DENIED,
        VSS_STORAGE_CREATE_RC_INVALID_ARG,
        VSS_STORAGE_CREATE_RC_VOLUME_NOT_FOUND,
        VSS_STORAGE_CREATE_RC_VOLUME_NOT_SUPPORTED,
        VSS_STORAGE_CREATE_RC_OBJECT_ALREADY_EXISTS,
        VSS_STORAGE_CREATE_RC_MAXIMUM_NUMBER_OF_DIFFAREA_REACHED,
        VSS_STORAGE_CREATE_RC_PROVIDER_VETO,
        VSS_STORAGE_CREATE_RC_PROVIDER_NOT_REGISTERED,
        VSS_STORAGE_CREATE_RC_UNEXPECTED_PROVIDER_FAILURE,
        VSS_STORAGE_CREATE_RC_UNEXPECTED
} STORAGE_CREATE_ERROR, *PSTORAGE_CREATE_ERROR;

typedef enum _SHADOW_CREATE_ERROR {
        VSS_SHADOW_CREATE_RC_NO_ERROR = 0,
        VSS_SHADOW_CREATE_RC_ACCESS_DENIED,
        VSS_SHADOW_CREATE_RC_INVALID_ARG,
        VSS_SHADOW_CREATE_RC_VOLUME_NOT_FOUND,
        VSS_SHADOW_CREATE_RC_VOLUME_NOT_SUPPORTED,
        VSS_SHADOW_CREATE_RC_UNSUPPORTED_CONTEXT,
        VSS_SHADOW_CREATE_RC_INSUFFICIENT_STORAGE,
        VSS_SHADOW_CREATE_RC_VOLUME_IN_USE,
        VSS_SHADOW_CREATE_RC_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
        VSS_SHADOW_CREATE_RC_SHADOW_COPY_IN_PROGRESS,
        VSS_SHADOW_CREATE_RC_PROVIDER_VETO,
        VSS_SHADOW_CREATE_RC_PROVIDER_NOT_REGISTERED,
        VSS_SHADOW_CREATE_RC_UNEXPECTED_PROVIDER_FAILURE,
        VSS_SHADOW_CREATE_RC_UNEXPECTED
} SHADOW_CREATE_ERROR, *PSHADOW_CREATE_ERROR;

//
// Class
//
extern const WCHAR * const PVDR_CLASS_DIFFVOLUMESUPPORT;
extern const WCHAR * const PVDR_CLASS_PROVIDER;
extern const WCHAR * const PVDR_CLASS_SHADOW;
extern const WCHAR * const PVDR_CLASS_SHADOWBY;
extern const WCHAR * const PVDR_CLASS_SHADOWFOR;
extern const WCHAR * const PVDR_CLASS_SHADOWON;
extern const WCHAR * const PVDR_CLASS_STORAGE;
extern const WCHAR * const PVDR_CLASS_VOLUME;
extern const WCHAR * const PVDR_CLASS_VOLUMESUPPORT;
extern const WCHAR * const PVDR_CLASS_WRITER;

//
// Methods
//
extern const WCHAR * const PVDR_MTHD_CREATE;

//
// Properties
//
extern const WCHAR * const PVDR_PROP_ALLOCATEDSPACE;
extern const WCHAR * const PVDR_PROP_CLSID;
extern const WCHAR * const PVDR_PROP_CONTEXT;
extern const WCHAR * const PVDR_PROP_COUNT;
extern const WCHAR * const PVDR_PROP_DEVICEID;
extern const WCHAR * const PVDR_PROP_DEVICEOBJECT;
extern const WCHAR * const PVDR_PROP_DIFFVOLUME;
extern const WCHAR * const PVDR_PROP_DISPLAYNAME;
extern const WCHAR * const PVDR_PROP_EXPOSEDNAME;
extern const WCHAR * const PVDR_PROP_EXPOSEDPATH;
extern const WCHAR * const PVDR_PROP_FREESPACE;
extern const WCHAR * const PVDR_PROP_ID;
extern const WCHAR * const PVDR_PROP_LASTERROR;
extern const WCHAR * const PVDR_PROP_MAXSPACE;
extern const WCHAR * const PVDR_PROP_NAME;
extern const WCHAR * const PVDR_PROP_ORIGINATINGMACHINE;
extern const WCHAR * const PVDR_PROP_PROVIDER;
extern const WCHAR * const PVDR_PROP_PROVIDERID;
extern const WCHAR * const PVDR_PROP_SERVICEMACHINE;
extern const WCHAR * const PVDR_PROP_SETID;
extern const WCHAR * const PVDR_PROP_SHADOW;
extern const WCHAR * const PVDR_PROP_SHADOWID;
extern const WCHAR * const PVDR_PROP_STATE;
extern const WCHAR * const PVDR_PROP_STORAGE;
extern const WCHAR * const PVDR_PROP_TIMESTAMP;
extern const WCHAR * const PVDR_PROP_TYPE;
extern const WCHAR * const PVDR_PROP_USEDSPACE;
extern const WCHAR * const PVDR_PROP_VERSION;
extern const WCHAR * const PVDR_PROP_VERSIONID;
extern const WCHAR * const PVDR_PROP_VOLUME;
extern const WCHAR * const PVDR_PROP_VOLUMENAME;

// Shadow Attributes
extern const WCHAR * const PVDR_PROP_PERSISTENT;
extern const WCHAR * const PVDR_PROP_CLIENTACCESSIBLE;
extern const WCHAR * const PVDR_PROP_NOAUTORELEASE;
extern const WCHAR * const PVDR_PROP_NOWRITERS;
extern const WCHAR * const PVDR_PROP_TRANSPORTABLE;
extern const WCHAR * const PVDR_PROP_NOTSURFACED;
extern const WCHAR * const PVDR_PROP_HARDWAREASSISTED;
extern const WCHAR * const PVDR_PROP_DIFFERENTIAL;
extern const WCHAR * const PVDR_PROP_PLEX;
extern const WCHAR * const PVDR_PROP_IMPORTED;
extern const WCHAR * const PVDR_PROP_EXPOSEDREMOTELY;
extern const WCHAR * const PVDR_PROP_EXPOSEDLOCALLY;


// Shadow Context Names
extern const WCHAR * const VSS_CTX_NAME_BACKUP;
extern const WCHAR * const VSS_CTX_NAME_FILESHAREBACKUP;
extern const WCHAR * const VSS_CTX_NAME_NASROLLBACK;
extern const WCHAR * const VSS_CTX_NAME_APPROLLBACK;
extern const WCHAR * const VSS_CTX_NAME_CLIENTACCESSIBLE;
extern const WCHAR * const VSS_CTX_NAME_ALL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\bitblt.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: bitblt.c
 *
 * Contains the high-level DrvBitBlt and DrvCopyBits functions.
 *
 *
 * NOTE:  Please see heap.c for a discussion of the types of bitmaps
 *        our acceleration functions are likely to encounter and the
 *        possible states of these bitmaps.
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "clip.h"
#include "heap.h"
#include "log.h"

//@@BEGIN_DDKSPLIT
#if GDI_TEST
ULONG
vPuntBefore(SURFOBJ * psoSrc, SURFOBJ * psoDst)
{
    ULONG   flags = 0;

    if(MAKE_BITMAPS_OPAQUE)
    {
        if(psoSrc != NULL && psoSrc->iType == STYPE_DEVBITMAP)
        {
            Surf *  psurfSrc = (Surf *) psoSrc->dhpdev;

            ASSERTDD(psurfSrc != NULL, "expected non-null psurf");
    
            psoSrc->iType = STYPE_BITMAP;
            flags |= 1;
        }

        if(psoDst != NULL && psoDst->iType == STYPE_DEVBITMAP)
        {
            Surf *  psurfDst = (Surf *) psoDst->dhpdev;
            
            ASSERTDD(psurfDst != NULL, "expected non-null psurf");
    
            psoDst->iType = STYPE_BITMAP;
            flags |= 2;
    
        }

    }

    return flags;
}

void
vPuntAfter(ULONG flags, SURFOBJ * psoSrc, SURFOBJ * psoDst)
{
    if(MAKE_BITMAPS_OPAQUE)
    {
        if(psoSrc != NULL && (flags & 1))
        {
            Surf *  psurfSrc = (Surf *) psoSrc->dhpdev;
    
            ASSERTDD(psurfSrc != NULL, "expected non-null psurf");
            ASSERTDD(psoSrc->iType == STYPE_BITMAP, "expected STYPE_BITMAP");
    
            psoSrc->iType = STYPE_DEVBITMAP;
        }

        ASSERTDD(psoDst != NULL, "expected non-null psoDst");

        if(flags & 2)
        {
            Surf *  psurfDst = (Surf *) psoDst->dhpdev;
            
            ASSERTDD(psurfDst != NULL, "expected non-null psurf");
            ASSERTDD(psoDst->iType == STYPE_BITMAP, "expected STYPE_BITMAP");
                
            psoDst->iType = STYPE_DEVBITMAP;
    
        }

    }
}
#endif
//@@END_DDKSPLIT

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvBitBlt
//
// DrvBitBlt provides general bit-block transfer capabilities between
// device-managed surfaces, between GDI-managed standard-format bitmaps, or
// between a device-managed surface and a GDI-managed standard-format bitmap.
//
// Parameters:
//   psoDst---Points to the SURFOBJ structure that describes the surface on
//            which to draw
//   psoSrc---Points to a SURFOBJ structure that describes the source for
//            the bit-block transfer operation, if required by the rop4
//            parameter
//   psoMask--Points to a SURFOBJ structure that describes a surface to be
//            used as a mask for the rop4 parameter. The mask is a bitmap with
//            1 bit per pixel. Typically, a mask is used to limit the area to
//            be modified in the destination surface. Masking is selected by
//            setting the rop4 parameter to the value 0xAACC. The destination
//            surface is unaffected if the mask is 0x0000. 
//
//            The mask will be large enough to cover the destination rectangle.
//
//            If this parameter is null and a mask is required by the rop4
//            parameter, the implicit mask in the brush is used
//   pco------Points to a CLIPOBJ structure that limits the area to be modified
//            GDI services (CLIPOBJ_Xxx) that enumerate the clip region as a
//            set of rectangles are provided. Whenever possible, GDI simplifies
//            the clipping involved; for example, this function is never called
//            with a single clipping rectangle. GDI clips the destination
//            rectangle before calling this function, making additional
//            clipping unnecessary. 
//   pxlo-----Points to a XLATEOBJ structure that specifies how color indices
//            should be translated between the source and destination surfaces.
//            If the source surface is palette-managed, its colors are
//            represented by indices into a lookup table of RGB values. The
//            XLATEOBJ structure can be queried for a translate vector that
//            will allow the device driver to translate any source index into
//            a color index for the destination. 
//
//            The situation is more complicated when, for example, the source
//            is RGB, but the destination is palette-managed. In this case,
//            the closest match to each source RGB value must be found in the
//            destination palette. The driver can call the XLATEOBJ_iXlate
//            service to perform this operation. 
//
//            Optionally, the device driver can match colors when the target
//            palette is the default device palette. 
//   prclDst--Points to a RECTL structure that defines the area to be modified.
//            This structure uses the coordinate system of the destination
//            surface. The lower and right edges of this rectangle are not
//            part of the bit-block transfer, meaning the rectangle is lower
//            right exclusive. 
//            DrvBitBlt is never called with an empty destination rectangle.
//            The two points that define the rectangle are always well-ordered.
//   pptlSrc--Points to a POINTL structure that defines the upper left corner
//            of the source rectangle, if a source exists. This parameter is
//            ignored if there is no source. 
//   pptlMask-Points to a POINTL structure that defines which pixel in the mask
//            corresponds to the upper left corner of the source rectangle, if
//            a source exists. This parameter is ignored if the psoMask
//            parameter is null. 
//   pbo------Points to the brush object that defines the pattern for the
//            bit-block transfer. GDI's BRUSHOBJ_pvGetRbrush service can be
//            used to retrieve the device's realization of the brush. This
//            parameter is ignored if the rop4 parameter does not require a
//            pattern. 
//   pptlBrush-Points to a POINTL structure that defines the origin of the
//            brush in the destination surface. The upper left pixel of the
//            brush is aligned at this point, and the brush repeats according
//            to its dimensions. This parameter is ignored if the rop4
//            parameter does not require a pattern. 
//   rop4-----Specifies a raster operation that defines how the mask, pattern,
//            source, and destination pixels are combined to write to the
//            destination surface. 
//            This is a quaternary raster operation, which is an extension of
//            the ternary Rop3 operation. A Rop4 has 16 relevant bits, which
//            are similar to the 8 defining bits of a Rop3. The simplest way
//            to implement a Rop4 is to consider its 2 bytes separately: The
//            low byte specifies a Rop3 that should be calculated if the mask
//            is one; the high byte specifies a Rop3 that can be calculated and
//            applied if the mask is 0. 
//
// Return Value
//   The return value is TRUE if the bit-block transfer operation is successful
//   Otherwise, it is FALSE, and an error code is logged.
//
//-----------------------------------------------------------------------------
BOOL
DrvBitBlt(SURFOBJ*  psoDst,
          SURFOBJ*  psoSrc,
          SURFOBJ*  psoMsk,
          CLIPOBJ*  pco,
          XLATEOBJ* pxlo,
          RECTL*    prclDst,
          POINTL*   pptlSrc,
          POINTL*   pptlMsk,
          BRUSHOBJ* pbo,
          POINTL*   pptlBrush,
          ROP4      rop4)
{
    BOOL            bResult;
    GFNPB           pb;
    XLATEOBJ        xloTmp;
    ULONG           aulTmp[2];

    ASSERTDD(!(rop4 & 0xFFFF0000), "DrvBitBlt: unexpected rop4 code");

    pb.ulRop4   = (ULONG) rop4;

    pb.psurfDst = (Surf*)psoDst->dhsurf;
    
    pb.prclDst = prclDst;

    if ( psoSrc == NULL )
    {
        pb.psurfSrc = NULL;

        //
        // We will only be given fills to device managed surfaces
        //
        ASSERTDD(pb.psurfDst != NULL,
                 "DrvBitBlt: unexpected gdi managed destination");

        if ( pb.psurfDst->flags & SF_SM )
        {
            goto puntIt;
        }

        //
        // We are filling surface in video memory
        //
        pb.ppdev = pb.psurfDst->ppdev;

        vSurfUsed(pb.ppdev, pb.psurfDst);

        //
        // If a mask is required punt it
        //
        
        if ( (rop4 & 0xFF) != (rop4 >> 8) )
        {
            goto puntIt;
        }

        //
        // Since 'psoSrc' is NULL, the rop3 had better not indicate
        // that we need a source.
        //
        ASSERTDD((((rop4 >> 2) ^ rop4) & 0x33) == 0,
                 "Need source but GDI gave us a NULL 'psoSrc'");

        //
        // Default to solid fill
        //

        if ( (((rop4 >> 4) ^ rop4) & 0xf) != 0 )
        {
            //
            // The rop says that a pattern is truly required
            // (blackness, for instance, doesn't need one):
            //
            
            //
            // for pbo->iSolidColor, a value of 0xFFFFFFFF(-1) indicates that
            // a nonsolid brush must be realized
            //
            if ( pbo->iSolidColor == -1 )
            {
                //
                // Non-solid brush case. Try to realize the pattern brush; By
                // doing this call-back, GDI will eventually call us again
                // through DrvRealizeBrush
                //
                pb.prbrush = (RBrush*)pbo->pvRbrush;
                if ( pb.prbrush == NULL )
                {
                    pb.prbrush = (RBrush*)BRUSHOBJ_pvGetRbrush(pbo);
                    if ( pb.prbrush == NULL )
                    {
                        //
                        // If we couldn't realize the brush, punt
                        // the call (it may have been a non 8x8
                        // brush or something, which we can't be
                        // bothered to handle, so let GDI do the
                        // drawing):
                        //
                        DBG_GDI((2, "DrvBitBlt: BRUSHOBJ_pvGetRbrush failed"));
                        
                        goto puntIt;
                    }
                }

                pb.pptlBrush = pptlBrush;
                
                //
                // Check if brush pattern is 1 BPP or not
                // Note: This is set in DrvRealizeBrush
                //
                if ( pb.prbrush->fl & RBRUSH_2COLOR )
                {
                    //
                    // 1 BPP pattern. Do a Mono fill
                    //
                    pb.pgfn = vMonoPatFill;
                }
                else
                {
                    pb.pgfn = vPatFill;
                }
            }
            else
            {
                ASSERTDD( (pb.ppdev->cBitsPerPel == 32) 
                    ||(pbo->iSolidColor&(0xFFFFFFFF<<pb.ppdev->cBitsPerPel))==0,
                         "DrvBitBlt: unused solid color bits not zero");
               
                pb.solidColor = pbo->iSolidColor;

                if ( rop4 != ROP4_PATCOPY )
                {
                    pb.pgfn = vSolidFillWithRop;
                }
                else
                {
                    pb.pgfn = pb.ppdev->pgfnSolidFill;
                }
            }        
        }// if ((((ucRop3 >> 4) ^ (ucRop3)) & 0xf) != 0)
        else
        {
            //
            // Turn some logicops into solid block fills. We get here
            // only for rops 00, 55, AA and FF.
            //
            if ( rop4 == ROP4_BLACKNESS )
            {
                pb.solidColor = 0;
                pb.ulRop4 = ROP4_PATCOPY;
            }
            else if( rop4 == ROP4_WHITENESS )
            {
                pb.solidColor = 0xffffff;
                pb.ulRop4 = ROP4_PATCOPY;
            }
            else if ( pb.ulRop4 == ROP4_NOP)
            {
                return TRUE;
            }
            else
            {
                pb.pgfn = vInvert;
                goto doIt;
            }

            pb.pgfn = pb.ppdev->pgfnSolidFill;

        }

        goto doIt;

    }// if ( psoSrc == NULL )

    //
    // We know we have a source
    //
    pb.psurfSrc = (Surf*)psoSrc->dhsurf;
    pb.pptlSrc = pptlSrc;

    if ( (pb.psurfDst == NULL) || (pb.psurfDst->flags & SF_SM) )
    {
        //
        // Destination is in system memory
        //

        if(pb.psurfSrc != NULL && pb.psurfSrc->flags & SF_VM)
        {
            pb.ppdev = pb.psurfSrc->ppdev;

            //
            // Source is in video memory
            //
            if(rop4 == ROP4_SRCCOPY)
            {
                if(pb.ppdev->iBitmapFormat != BMF_32BPP &&
                   (pxlo == NULL || pxlo->flXlate == XO_TRIVIAL) )
                {
                    pb.psoDst = psoDst;
                    pb.pgfn = vUploadNative;
        
                    goto doIt;
                }
            }
        }

        goto puntIt;

    }

    //
    // After this point we know that the destination is in video memory
    //

    pb.ppdev = pb.psurfDst->ppdev;

    if ( psoMsk != NULL )
    {
        goto puntIt;
    }

    //
    // After this point we know we do not have a mask
    //
      if( (rop4 == 0xb8b8 || rop4 == 0xe2e2)
        && (pbo->iSolidColor != (ULONG)-1)
        && (psoSrc->iBitmapFormat == BMF_1BPP)
        && (pxlo->pulXlate[0] == 0)
        && ((pxlo->pulXlate[1] & pb.ppdev->ulWhite) == pb.ppdev->ulWhite) )
    {
        //
        // When the background and foreground colors are black and
        // white, respectively, and the ROP is 0xb8 or 0xe2, and
        // the source bitmap is monochrome, the blt is simply a
        // color expanding monochrome blt.
        //
        //
        // Rather than add another parameter to 'pfnXfer', we simply
        // overload the 'pxlo' pointer.  Note that we still have to
        // special-case 0xb8 and 0xe2 in our 'pfnXfer1bpp' routine
        // to handle this convention:
        //
        xloTmp = *pxlo;
        xloTmp.pulXlate = aulTmp;
        aulTmp[0] = pbo->iSolidColor;
        aulTmp[1] = pbo->iSolidColor;
        
        pb.pxlo = &xloTmp;
        DBG_GDI((6, "Rop is 0x%x", pb.ulRop4));
        pb.pgfn = vMonoDownload;
        pb.psoSrc = psoSrc;

        goto doIt;

    }

    if ( pbo != NULL )
    {
        goto puntIt;
    }

    //
    // After this point we know we do not have a brush
    //


    //
    // We have a source to dest rop2 operation
    //

    if ( pb.psurfSrc == NULL )
    {
        pb.psoSrc = psoSrc;

        if(psoSrc->iBitmapFormat == BMF_1BPP)
        {
            pb.pxlo = pxlo;
            pb.pgfn = vMonoDownload;
                        
            goto doIt;

        }
        else if(psoSrc->iBitmapFormat == pb.ppdev->iBitmapFormat 
                 && (pxlo == NULL || pxlo->flXlate == XO_TRIVIAL) )
        {
//@@BEGIN_DDKSPLIT
            // TODO: find out if we need to check for pxlo == NULL
            // TODO: Handle 24 bpp download since it get called many times
            // during WinBench 99 tests
//@@END_DDKSPLIT

            pb.psoSrc = psoSrc;
            pb.pgfn = vDownloadNative;

            goto doIt;
        }    
        else
        {
            goto puntIt;
        }
    }

    if ( pb.psurfSrc->flags & SF_SM )
    {
        //
        // Source is in system memory
        //
        goto puntIt;
    }

    //
    // We now have both a source and a destination in video memory
    //

//@@BEGIN_DDKSPLIT
    // TODO: find if we will ever get a non-trivial translation when
    //       both source and dest are device managed.
//@@END_DDKSPLIT
    if( pxlo != NULL && !(pxlo->flXlate & XO_TRIVIAL))
    {
        goto puntIt;
    }

    if ( (rop4 == ROP4_SRCCOPY) || (psoSrc == psoDst) )
    {
        if ( pb.psurfSrc->ulPixDelta == pb.psurfDst->ulPixDelta )
        {
            pb.pgfn = vCopyBltNative;
        }
        else
        {
            pb.pgfn = vCopyBlt;
        }
    }
    else
    {
        pb.pgfn = vRop2Blt;
    }

doIt:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvBitBlt: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(pb.ppdev);
    
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pb.pRects = pb.prclDst;
        pb.lNumRects = 1;
        pb.pgfn(&pb);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL   rcl;

        if (bIntersect(pb.prclDst, &pco->rclBounds, &rcl))
        {
            pb.pRects = &rcl;
            pb.lNumRects = 1;
            pb.pgfn(&pb);
        }
    }
    else
    {
        pb.pco = pco;
        vClipAndRender(&pb);
    }
    
    if( ((pb.pgfn == vCopyBlt) || (pb.pgfn == vCopyBltNative))
      &&(pb.ppdev->pdsurfScreen == pb.psurfSrc)
      &&(pb.psurfSrc == pb.psurfDst)
      &&(pb.ppdev->bNeedSync) )
    {
        pb.ppdev->bNeedSync = TRUE;
        InputBufferSwap(pb.ppdev);
    }
    else
    {
        InputBufferFlush(pb.ppdev);
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;

puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(psoSrc, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                        pptlMsk, pbo, pptlBrush, rop4);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, psoSrc, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT
    
    return bResult;
}// DrvBitBlt()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvCopyBits
//
// DrvCopyBits translates between device-managed raster surfaces and GDI
// standard-format bitmaps. 
//
// Parameters
//  psoDst------Points to the destination surface for the copy operation. 
//  psoSrc------Points to the source surface for the copy operation. 
//  pco---------Points to a CLIPOBJ structure that defines a clipping region on
//              the destination surface. 
//  pxlo--------Points to a XLATEOBJ structure that defines the translation of
//              color indices between the source and target surfaces. 
//  prclDst-----Points to a RECTL structure that defines the area to be
//              modified. This structure uses the coordinate system of the
//              destination surface. The lower and right edges of this
//              rectangle are not part of the bit-block transfer, meaning the
//              rectangle is lower right exclusive. 
//              DrvCopyBits is never called with an empty destination rectangle
//              The two points that define the rectangle are always
//              well-ordered. 
//
//  pptlSrc-----Points to a POINTL structure that defines the upper-left corner
//              of the source rectangle. 
//
// Return Value
//  The return value is TRUE if the source surface is successfully copied to
//  the destination surface.
//
// Comments
//  This function is required for a device driver that has device-managed
//  bitmaps or raster surfaces. The implementation in the driver must
//  translate driver surfaces to and from any standard-format bitmap.
//
//  Standard-format bitmaps are single-plane, packed-pixel format. Each scan
//  line is aligned on a 4-byte boundary. These bitmaps have 1, 4, 8, 16, 24,
//  32, or 64 bits per pixel.
//
//  This function should ideally be able to deal with RLE and device-dependent
//  bitmaps (see the Platform SDK). The device-dependent format is optional;
//  only a few specialized drivers need to support it. These bitmaps can be
//  sent to this function as a result of the following Win32 GDI functions:
//  SetDIBits, SetDIBitsToDevice, GetDIBits, SetBitmapBits, and GetBitmapBits.
//
//  Kernel-mode GDI calls this function from its simulations
//
//-----------------------------------------------------------------------------
BOOL
DrvCopyBits(SURFOBJ*  psoDst,
            SURFOBJ*  psoSrc,
            CLIPOBJ*  pco,
            XLATEOBJ* pxlo,
            RECTL*    prclDst,
            POINTL*   pptlSrc)
{
    return DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, 
                        NULL, NULL, NULL, ROP4_SRCCOPY);
}// DrvCopyBits()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvTransparentBlt
//
//DrvTransparentBlt provides bit-block transfer capabilities with transparency.
//
// Parameters
//  psoDst------Points to the SURFOBJ that identifies the target surface on
//              which to draw. 
//  psoSrc------Points to the SURFOBJ that identifies the source surface of the
//              bit-block transfer. 
//  pco---------Points to a CLIPOBJ structure. The CLIPOBJ_Xxx service routines
//              are provided to enumerate the clip region as a set of
//              rectangles. This enumeration limits the area of the destination
//              that is modified. Whenever possible, GDI simplifies the
//              clipping involved. 
//  pxlo--------Points to a XLATEOBJ that tells how the source color indices
//              should be translated for writing to the target surface. 
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified. This rectangle is specified in the coordinate
//              system of the destination surface and is defined by two points:
//              upper left and lower right. The rectangle is lower-right
//              exclusive; that is, its lower and right edges are not a part of
//              the bit-block transfer. The two points that define the
//              rectangle are always well ordered. 
//              DrvTransparentBlt is never called with an empty destination
//              rectangle. 
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied. This rectangle is specified in the coordinate
//              system of the source surface and is defined by two points:
//              upper left and lower right. The two points that define the
//              rectangle are always well ordered. 
//              The source rectangle will never exceed the bounds of the source
//              surface, and so will never overhang the source surface. 
//
//              This rectangle is mapped to the destination rectangle defined
//              by prclDst. DrvTransparentBlt is never called with an empty
//              source rectangle. 
//  iTransColor-Specifies the transparent color in the source surface format.
//              It is a color index value that has been translated to the
//              source surface's palette. 
//  ulReserved--Reserved; this parameter must be set to zero. 
//
// Return Value
//  DrvTransparentBlt returns TRUE upon success. Otherwise, it returns FALSE.
//
// Comments
//  Bit-block transfer with transparency is supported between two
//  device-managed surfaces or between a device-managed surface and a
//  GDI-managed standard format bitmap. Driver writers are encouraged to
//  support the case of blting from off-screen device bitmaps in video memory
//  to other surfaces in video memory; all other cases can be punted to
//  EngTransparentBlt with little performance penalty.
//
//  The pixels on the source surface that match the transparent color specified
//  by iTransColor are not copied.
//
//  The driver will never be called with overlapping source and destination
//  rectangles on the same surface.
//
//  The driver should ignore any unused bits in the color key comparison, such
//  as for the most significant bit when the bitmap format is a 5-5-5 16bpp.
//
//  The driver hooks DrvTransparentBlt by setting the HOOK_TRANSPARENTBLT flag
//  when it calls EngAssociateSurface. If the driver has hooked
//  DrvTransparentBlt and is called to perform an operation that it does not
//  support, the driver should have GDI handle the operation by forwarding the
//  data in a call to EngTransparentBlt.
//
//-----------------------------------------------------------------------------
BOOL 
DrvTransparentBlt(SURFOBJ*    psoDst,
                  SURFOBJ*    psoSrc,
                  CLIPOBJ*    pco,
                  XLATEOBJ*   pxlo,
                  RECTL*      prclDst,
                  RECTL*      prclSrc,
                  ULONG       iTransColor,
                  ULONG       ulReserved)
{
    GFNPB       pb;
    BOOL        bResult;

    ASSERTDD(psoDst != NULL, "DrvTransparentBlt: psoDst is NULL");
    ASSERTDD(psoSrc != NULL, "DrvTransparentBlt: psoSrc is NULL");

    pb.psurfDst = (Surf *) psoDst->dhsurf;
    pb.psurfSrc = (Surf *) psoSrc->dhsurf;

    ASSERTDD(pb.psurfDst != NULL || pb.psurfSrc != NULL, 
             "DrvTransparentBlt: expected at least one device managed surface");

    // Only handle one-to-one blts
    if (prclDst->right - prclDst->left != prclSrc->right - prclSrc->left)
        goto puntIt;

    if (prclDst->bottom - prclDst->top != prclSrc->bottom - prclSrc->top)
        goto puntIt;
    
    // Only handle trivial color translation
    if ( pxlo != NULL && !(pxlo->flXlate & XO_TRIVIAL))
        goto puntIt;

    // for now, only handle video memory to video memory transparent blts
    if(pb.psurfDst == NULL || pb.psurfDst->flags & SF_SM)
        goto puntIt;

    if(pb.psurfSrc == NULL || pb.psurfSrc->flags & SF_SM)
        goto puntIt;
    
    pb.ppdev = (PPDev) psoDst->dhpdev;

    pb.prclDst = prclDst;
    pb.prclSrc = prclSrc;
    pb.pptlSrc = NULL;
    pb.colorKey = iTransColor;
    pb.pgfn = pb.ppdev->pgfnTransparentBlt;
    pb.pco = pco;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvTransparentBlt: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(pb.ppdev);
    vClipAndRender(&pb);
    InputBufferFlush(pb.ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;
    
puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(psoSrc, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngTransparentBlt(psoDst,
                             psoSrc,
                             pco,
                             pxlo,
                             prclDst,
                             prclSrc,
                             iTransColor,
                             ulReserved);
//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, psoSrc, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;
}// DrvTransparentBlt()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvAlphaBlend
//
// DrvAlphaBlend provides bit-block transfer capabilities with alpha blending.
//
// Parameters
//  psoDest-----Points to a SURFOBJ that identifies the surface on which to
//              draw. 
//  psoSrc------Points to a SURFOBJ that identifies the source surface. 
//  pco---------Points to a CLIPOBJ. The CLIPOBJ_Xxx service routines are
//              provided to enumerate the clip region as a set of rectangles.
//              This enumeration limits the area of the destination that is
//              modified. Whenever possible, GDI simplifies the clipping
//              involved. However, unlike DrvBitBlt, DrvAlphaBlend might be
//              called with a single rectangle in order to prevent round-off
//              errors in clipping the output. 
//  pxlo--------Points to a XLATEOBJ that specifies how color indices should be
//              translated between the source and destination surfaces. 
//              If the source surface is palette managed, its colors are
//              represented by indices into a lookup table of RGB color values.
//              In this case, the XLATEOBJ can be queried for a translate
//              vector that allows the device driver to quickly translate any
//              source index into a color index for the destination. 
//
//              The situation is more complicated when, for example, the source
//              is RGB but the destination is palette managed. In this case,
//              the closest match to each source RGB value must be found in the
//              destination palette. The driver can call the XLATEOBJ_iXlate
//              service routine to perform this matching operation. 
//  prclDest----Points to a RECTL structure that defines the rectangular area
//              to be modified. This rectangle is specified in the coordinate
//              system of the destination surface and is defined by two points:
//              upper left and lower right. The two points that define the
//              rectangle are always well ordered. The rectangle is lower-right
//              exclusive; that is, its lower and right edges are not a part of
//              the blend. 
//              The driver should be careful to do proper clipping when writing
//              the pixels because the specified rectangle might overhang the
//              destination surface. 
//
//              DrvAlphaBlend is never called with an empty destination
//              rectangle. 
//  prclSrc-----Points to a RECTL structure that defines the area to be copied.
//              This rectangle is specified in the coordinate system of the
//              source surface, and is defined by two points: upper left and
//              lower right. The two points that define the rectangle are
//              always well ordered. The rectangle is lower-right exclusive;
//              that is, its lower and right edges are not a part of the blend.
//              The source rectangle will never exceed the bounds of the source
//              surface, and so will never overhang the source surface. 
//
//              DrvAlphaBlend is never called with an empty source rectangle. 
//
//              The mapping is defined by prclSrc and prclDest. The points
//              specified in prclDest and prclSrc lie on integer coordinates,
//              which correspond to pixel centers. A rectangle defined by two
//              such points is considered to be a geometric rectangle with two
//              vertices whose coordinates are the given points, but with 0.5
//              subtracted from each coordinate. (POINTL structures are
//              shorthand notation for specifying these fractional coordinate
//              vertices.) 
//  pBlendObj---Points to a BLENDOBJ structure that describes the blending
//              operation to perform between the source and destination
//              surfaces. This structure is a wrapper for the BLENDFUNCTION
//              structure, which includes necessary source and destination
//              format information not available in the XLATEOBJ. BLENDFUNCTION
//              is declared in the Platform SDK. Its members are defined as
//              follows: 
//              BlendOp defines the blend operation to be performed. Currently
//              this value must be AC_SRC_OVER, which means that the source
//              bitmap is placed over the destination bitmap based on the alpha
//              values of the source pixels. There are three possible cases
//              that this blend operation should handle. These are described in
//              the Comments section of this reference page. 
//
//              BlendFlags is reserved and is currently set to zero. 
//
//              SourceConstantAlpha defines the constant blend factor to apply
//              to the entire source surface. This value is in the range of
//              [0,255], where 0 is completely transparent and 255 is
//              completely opaque. 
//
//              AlphaFormat defines whether the surface is assumed to have an
//              alpha channel. This member can optionally be set to the
//              following value: 
//
//              AC_SRC_ALPHA 
//                  The source surface can be assumed to be in a pre-multiplied
//                  alpha 32bpp "BGRA" format; that is, the surface type is
//                  BMF_32BPP and the palette type is BI_RGB. The alpha
//                  component is an integer in the range of [0,255], where 0 is
//                  completely transparent and 255 is completely opaque. 
// Return Value
//  DrvAlphaBlend returns TRUE upon success. Otherwise, it reports an error and
//  returns FALSE.
//
// Comments
//  A bit-block transfer with alpha blending is supported between the following
//  surfaces: 
//
//  From one driver-managed surface to another driver-managed surface. 
//  From one GDI-managed standard format bitmap to another GDI-managed standard
//  format bitmap. 
//  From one device-managed surface to a GDI-managed surface, and vice versa. 
//  The three possible cases for the AC_SRC_OVER blend function are: 
//
//  The source bitmap has no per pixel alpha (AC_SRC_ALPHA is not set), so the
//  blend is applied to the pixel's color channels based on the constant source
//  alpha value specified in SourceConstantAlpha as follows: 
//
//  Dst.Red = Round(((Src.Red * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Red)) / 255);
//  Dst.Green = Round(((Src.Green * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Green)) / 255);
//  Dst.Blue = Round(((Src.Blue * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Blue)) / 255);
//
//  Do the next computation only if the destination bitmap has an alpha channel
//  Dst.Alpha = Round(((Src.Alpha * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Alpha)) / 255);
//
//  The source bitmap has per pixel alpha values (AC_SRC_ALPHA is set), and
//  SourceConstantAlpha is not used (it is set to 255). The blend is computed
//  as follows: 
//
//  Temp.Red = Src.Red + Round(((255 ? Src.Alpha) * Dst.Red) / 255);
//  Temp.Green = Src.Green + Round(((255 ? Src.Alpha) * Dst.Green) / 255);
//  Temp.Blue = Src.Blue + Round(((255 ? Src.Alpha) * Dst.Blue) / 255);
//
//  Do the next computation only if the destination bitmap has an alpha channel
//
//  Temp.Alpha = Src.Alpha + Round(((255 ? Src.Alpha) * Dst.Alpha) / 255);
//
//  The source bitmap has per pixel alpha values (AC_SRC_ALPHA is set), and
//  SourceConstantAlpha is used (it is not set to 255). The blend is computed
//  as follows: 
//
//  Temp.Red = Round((Src.Red * SourceConstantAlpha) / 255);
//  Temp.Green = Round((Src.Green * SourceConstantAlpha) / 255);
//  Temp.Blue = Round((Src.Blue * SourceConstantAlpha) / 255);
//
//  The next computation must be done even if the destination bitmap does not
//  have an alpha channel
//
//  Temp.Alpha = Round((Src.Alpha * SourceConstantAlpha) / 255);
//
//  Note that the following equations use the just-computed Temp.Alpha value:
//
//  Dst.Red = Temp.Red + Round(((255 ? Temp.Alpha) * Dst.Red) / 255);
//  Dst.Green = Temp.Green + Round(((255 ? Temp.Alpha) * Dst.Green) / 255);
//  Dst.Blue = Temp.Blue + Round(((255 ? Temp.Alpha) * Dst.Blue) / 255);
//
//  Do the next computation only if the destination bitmap has an alpha channel
//
//  Dst.Alpha = Temp.Alpha + Round(((255 ? Temp.Alpha) * Dst.Alpha) / 255);
//
//  DrvAlphaBlend can be optionally implemented in graphics drivers. It can be
//  provided to handle some kinds of alpha blends, such as blends where the
//  source and destination surfaces are the same format and do not contain an
//  alpha channel.
//
//  A hardware implementation can use floating point or fixed point in the
//  blend operation. Compatibility tests will account for a small epsilon in
//  the results. When using fixed point, an acceptable approximation to the
//  term x/255 is (x*257)/65536. Incorporating rounding, the term:
//
//  (255 - Src.Alpha) * Dst.Red) / 255
//
//  can then be approximated as:
//
//  temp = (255 - Src.Alpha) * Dst.Red) + 128;
//  result = (temp + (temp >> 8)) >> 8;
//
//  The Round(x) function rounds to the nearest integer, computed as:
//
//  Trunc(x + 0.5);
//
//  The driver hooks DrvAlphaBlend by setting the HOOK_ALPHABLEND flag when it
//  calls EngAssociateSurface. If the driver has hooked DrvAlphaBlend and is
//  called to perform an operation that it does not support, the driver should
//  have GDI handle the operation by forwarding the data in a call to
//  EngAlphaBlend.
//
//-----------------------------------------------------------------------------
BOOL
DrvAlphaBlend(SURFOBJ*  psoDst,
              SURFOBJ*  psoSrc,
              CLIPOBJ*  pco,
              XLATEOBJ* pxlo,
              RECTL*    prclDst,
              RECTL*    prclSrc,
              BLENDOBJ* pBlendObj)
{
    BOOL        bSourceInSM;
    BOOL        bResult;
    GFNPB       pb;
    
    ASSERTDD(psoDst != NULL, "DrvAlphaBlend: psoDst is NULL");
    ASSERTDD(psoSrc != NULL, "DrvAlphaBlend: psoSrc is NULL");

    DBG_GDI((7,"DrvAlphaBlend"));

    pb.psurfDst = (Surf *) psoDst->dhsurf;
    pb.psurfSrc = (Surf *) psoSrc->dhsurf;

    // Only handle one-to-one alpha blts
    if (prclDst->right - prclDst->left != prclSrc->right - prclSrc->left)
        goto puntIt;

    if (prclDst->bottom - prclDst->top != prclSrc->bottom - prclSrc->top)
        goto puntIt;
    
    if(pb.psurfDst == NULL || pb.psurfDst->flags & SF_SM)
        goto puntIt;

    pb.ppdev = (PPDev) psoDst->dhpdev;

    // We can't handle blending in 8bpp

//@@BEGIN_DDKSPLIT
    // TODO: Investigate doing blending in 8bpp
//@@END_DDKSPLIT
    if (pb.ppdev->cPelSize == 0)
        goto puntIt;

    pb.ucAlpha = pBlendObj->BlendFunction.SourceConstantAlpha;
    
    if(pb.psurfSrc == NULL || pb.psurfSrc->flags & SF_SM)
    {

        pb.psoSrc = psoSrc;

//@@BEGIN_DDKSPLIT
        // TODO: find out how we should verify that the XLATEOBJ is reasonable
//@@END_DDKSPLIT

        if(pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
        {
            ASSERTDD(psoSrc->iBitmapFormat == BMF_32BPP,
                "DrvAlphaBlend: source alpha specified with non 32bpp source");
        
            pb.pgfn = vAlphaBlendDownload;

            // This could be a cursor that is drawing... force a swap
            // buffer at the next synchronization event.

            pb.ppdev->bForceSwap = TRUE;

//@@BEGIN_DDKSPLIT
            // TODO: improve our alpha blend download acceleration code
            //       it's currently slower then punting
//@@END_DDKSPLIT
        }
        else
        {
            goto puntIt;
        }
    }
    else
    {
        // Only handle trivial color translation
        if (pxlo != NULL && !(pxlo->flXlate & XO_TRIVIAL))
            goto puntIt;

        if(pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
        {
            ASSERTDD(psoSrc->iBitmapFormat == BMF_32BPP,
                "DrvAlphaBlend: source alpha specified with non 32bpp source");
        
            pb.pgfn = vAlphaBlend;
        }
        else
        {
            pb.pgfn = vConstantAlphaBlend;
        }
    }

    pb.prclDst = prclDst;
    pb.prclSrc = prclSrc;
    pb.pptlSrc = NULL;
    pb.pco = pco;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvAlphaBlend: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(pb.ppdev);
    vClipAndRender(&pb);
    InputBufferFlush(pb.ppdev);
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;
    
puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(psoSrc, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngAlphaBlend(
        psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, pBlendObj);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, psoSrc, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;

}// DrvAlphaBlend()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvGradientFill
//
// DrvGradientFill shades the specified primitives.
//
// Parameters
//  psoDest-----Points to the SURFOBJ that identifies the surface on which to
//              draw. 
//  pco---------Points to a CLIPOBJ. The CLIPOBJ_Xxx service routines are
//              provided to enumerate the clip region as a set of rectangles.
//              This enumeration limits the area of the destination that is
//              modified. Whenever possible, GDI simplifies the clipping
//              involved. 
//  pxlo--------Should be ignored by the driver. 
//  pVertex-----Points to an array of TRIVERTEX structures, with each entry
//              containing position and color information. TRIVERTEX is defined
//              in the Platform SDK. 
//  nVertex-----Specifies the number of TRIVERTEX structures in the array to
//              which pVertex points. 
//  pMesh-------Points to an array of structures that define the connectivity
//              of the TRIVERTEX elements to which pVertex points. 
//              When rectangles are being drawn, pMesh points to an array of
//              GRADIENT_RECT structures that specify the upper left and lower
//              right TRIVERTEX elements that define a rectangle. Rectangle
//              drawing is lower-right exclusive. GRADIENT_RECT is defined in
//              the Platform SDK. 
//
//              When triangles are being drawn, pMesh points to an array of
//              GRADIENT_TRIANGLE structures that specify the three TRIVERTEX
//              elements that define a triangle. Triangle drawing is
//              lower-right exclusive. GRADIENT_TRIANGLE is defined in the
//              Platform SDK. 
//  nMesh-------Specifies the number of elements in the array to which pMesh
//              points. 
//  prclExtents-Points to a RECTL structure that defines the area in which the
//              gradient drawing is to occur. The points are specified in the
//              coordinate system of the destination surface. This parameter is
//              useful in estimating the size of the drawing operations. 
//  pptlDitherOrg-Points to a POINTL structure that defines the origin on the
//              surface for dithering. The upper left pixel of the dither
//              pattern is aligned with this point. 
//  ulMode------Specifies the current drawing mode and how to interpret the
//              array to which pMesh points. This parameter can be one of the
//              following values:
//              Value                   Meaning 
//              GRADIENT_FILL_RECT_H    pMesh points to an array of
//                                      GRADIENT_RECT structures. Each
//                                      rectangle is to be shaded from left to
//                                      right. Specifically, the upper-left and
//                                      lower-left pixels are the same color,
//                                      as are the upper-right and lower-right
//                                      pixels. 
//              GRADIENT_FILL_RECT_V    pMesh points to an array of
//                                      GRADIENT_RECT structures. Each
//                                      rectangle is to be shaded from top to
//                                      bottom. Specifically, the upper-left
//                                      and upper-right pixels are the same
//                                      color, as are the lower-left and
//                                      lower-right pixels. 
//              GRADIENT_FILL_TRIANGLE  pMesh points to an array of
//                                      GRADIENT_TRIANGLE structures. 
//
//              The gradient fill calculations for each mode are documented in
//              the Comments section. 
//
// Return Value
//  DrvGradientFill returns TRUE upon success. Otherwise, it returns FALSE. and
//  reports an error by calling EngSetLastError.
//
// Comments
//  DrvGradientFill can be optionally implemented in graphics drivers.
//
//  The driver hooks DrvGradientFill by setting the HOOK_GRADIENTFILL flag when
//  it calls EngAssociateSurface. If the driver has hooked DrvGradientFill and
//  is called to perform an operation that it does not support, the driver
//  should have GDI handle the operation by forwarding the data in a call to
//  EngGradientFill.
//
//  The formulas for computing the color value at each pixel of the primitive
//  depend on ulMode as follows: 
//
//  GRADIENT_FILL_TRIANGLE 
//      The triangle's vertices are defined as V1, V2, and V3. Point P is
//      inside the triangle. Draw lines from P to V1, V2, and V3 to form three
//      sub-triangles. Let ai denote the area of the triangle opposite Vi for
//      i=1,2,3. The color at point P is computed as: 
//
//      RedP   = (RedV1 * a1 + RedV2 * a2 + RedV3 * a3) / (a1+a2+a3 ()) 
//      GreenP = (GreenV1 * a1 + GreenV2 * a2 + GreenV3 * a3) / (a1+a2+a3 ()) 
//      BlueP ( )  = (BlueV1 * a1 + BlueV2 * a2 + BlueV3 * a3) / (a1+a2+a3)
//
//  GRADIENT_FILL_RECT_H 
//      The rectangle's top-left point is V1 and the bottom-right point is V2.
//      Point P is inside the rectangle. The color at point P is given by: 
//
//      RedP =   (RedV2 * (Px - V1x) + RedV1 * (V2x - Px)) / (V2x-V1x)
//      GreenP = (GreenV2 * (Px - V1x) + GreenV1 * (V2x - Px)) / (V2x-V1x)
//      BlueP =  (BlueV2 * (Px - V1x) + BlueV1 * (V2x - Px)) / (V2x-V1x)
//
//  GRADIENT_FILL_RECT_V 
//      The rectangle's top-left point is V1 and the bottom-right point is V2.
//      Point P is inside the rectangle. The color at point P is given by: 
//
//      RedP   = (RedV2 * (Py-V1y) + RedV1 * (V2y - Py)) / (V2y-V1y)
//      GreenP = (GreenV2 * (Py-V1y) + GreenV1 * (V2y - Py)) / (V2y-V1y)
//      BlueP  = (BlueV2 * (Py-V1y) + BlueV1 * (V2y - Py)) / (V2y-V1y)
//
//-----------------------------------------------------------------------------
BOOL
DrvGradientFill(SURFOBJ*    psoDst,
                CLIPOBJ*    pco,
                XLATEOBJ*   pxlo,
                TRIVERTEX*  pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL*      prclExtents,
                POINTL*     pptlDitherOrg,
                ULONG       ulMode)
{
    GFNPB       pb;
    BOOL        bResult;
    
    ASSERTDD(psoDst != NULL, "DrvGradientFill: psoDst is NULL");

    pb.psurfDst = (Surf *) psoDst->dhsurf;
    pb.psurfSrc = NULL;

    // for now, only handle video memory gradient fills
    if(pb.psurfDst == NULL || pb.psurfDst->flags & SF_SM)
        goto puntIt;

    pb.ppdev = (PPDev) psoDst->dhpdev;
    
    pb.ulMode = ulMode;

    // setup default dest
    
    if(pb.ulMode == GRADIENT_FILL_TRIANGLE)
    {
//@@BEGIN_DDKSPLIT
        // TODO: add support for triangle gradient fill ... our hardware
        //       can easily support this acceleration.
//@@END_DDKSPLIT
        goto puntIt;
    }
    else
    {
        GRADIENT_RECT   *pgr = (GRADIENT_RECT *) pMesh;

#ifdef DBG
        for(ULONG i = 0; i < nMesh; i++)
        {
            ULONG   ulLr = pgr[i].LowerRight;

            ASSERTDD( ulLr < nVertex, "DrvGradientFill: bad vertex index");
        }
#endif

        pb.pgfn = pb.ppdev->pgfnGradientFillRect;
    }

    pb.pco = pco;

    pb.ptvrt = pVertex;
    pb.ulNumTvrt = nVertex;
    pb.pvMesh = pMesh;
    pb.ulNumMesh = nMesh;
    pb.prclDst = prclExtents;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvGradientFill: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(pb.ppdev);
    vClipAndRender(&pb);
    InputBufferFlush(pb.ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;
    
puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(NULL, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngGradientFill(
            psoDst, pco, pxlo, pVertex, nVertex, 
            pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, NULL, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;

}// DrvGradientFill()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\vsswmi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: vsswmi.cpp
//
//  Implementation of the provider registration and entry point.
//
//  Author:    MSP Prabu  (mprabu)  04-Dec-2000
//             Jim Benton (jbenton) 15-Oct-2000
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <initguid.h>
#include "ProvFactory.h"
#include "InstanceProv.h"

////////////////////////////////////////////////////////////////////////
////  Standard foo for file name aliasing.  This code block must be after
////  all includes of VSS header files.
////
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMVWMIP"
////
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////

const int g_cchRegkey = 128;

// {72970BEB-81F8-46d4-B220-D743F4E49C95}
DEFINE_GUID(CLSID_VSS_PROVIDER, 
0x72970BEB, 
0x81F8, 
0x46d4, 
0xB2, 0x20, 0xD7, 0x43, 0xF4, 0xE4, 0x9C, 0x95);

//DECLARE_DEBUG_PRINTS_OBJECT();

// Count number of objects and number of locks.

long        g_cObj = 0;
long        g_cLock = 0;
HMODULE     g_hModule;

FactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_VSS_PROVIDER,
        CInstanceProv::S_HrCreateThis,
        PVD_WBEM_PROVIDERNAME
    }
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  WINAPI
//  DllMain(
//      HANDLE  hModule,
//      DWORD   ul_reason_for_call,
//      LPVOID  lpReserved
//      )
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      hModule             -- DLL module handle.
//      ul_reason_for_call  -- 
//      lpReserved          -- 
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HANDLE  hModule,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
	g_hModule = static_cast< HMODULE >( hModule );
    if (dwReason == DLL_PROCESS_ATTACH)
    {
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }
    return TRUE;

} //*** DllMain()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllCanUnloadNow( void )
//
//  Description:
//      Called periodically by Ole in order to determine if the
//      DLL can be freed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = ( 0L == g_cObj && 0L == g_cLock ) ? S_OK : S_FALSE;
    return sc;

} //*** DllCanUnloadNow()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllRegisterServer( void )
//
//  Description:
//      Called during setup or by regsvr32.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{   
    WCHAR   wszID[ g_cchGUID ];
    WCHAR   wszCLSID[ g_cchRegkey ];
    WCHAR   wszModule[ MAX_PATH ];
    INT     idx;
    WCHAR * pwszModel   = L"Both";
    HKEY    hKey1 = NULL;
    HKEY    hKey2 = NULL;
    DWORD   dwRet        =  ERROR_SUCCESS;
    INT     cArray      = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    // Create the path.
    try
    {
        for ( idx = 0 ; idx < cArray && dwRet == ERROR_SUCCESS ; idx++ )
        {
            LPCWSTR pwszName = g_FactoryDataArray[ idx ].m_pwszRegistryName;

            dwRet = StringFromGUID2(
                *g_FactoryDataArray[ idx ].m_pCLSID,
                wszID,
                g_cchGUID
                );

            if (dwRet == 0)
            {
                dwRet = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            if (FAILED(StringCchPrintf(wszCLSID, g_cchRegkey, L"Software\\Classes\\CLSID\\%lS", wszID)))
            {
                dwRet = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            wszCLSID[g_cchRegkey - 1] = L'\0';

            // Create entries under CLSID

            dwRet = RegCreateKeyW(
                        HKEY_LOCAL_MACHINE,
                        wszCLSID,
                        &hKey1
                        );
            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            dwRet = RegSetValueEx(
                        hKey1,
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) pwszName,
                        sizeof( WCHAR ) * (lstrlenW( pwszName ) + 1)
                        );
            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            dwRet = RegCreateKeyW(
                        hKey1,
                        L"InprocServer32",
                        & hKey2
                        );

            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            GetModuleFileName( g_hModule, wszModule, MAX_PATH );

            dwRet = RegSetValueEx(
                        hKey2,
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) wszModule,
                        sizeof( WCHAR ) * (lstrlen( wszModule ) + 1)
                        );

            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }

            dwRet = RegSetValueExW(
                        hKey2,
                        L"ThreadingModel",
                        0,
                        REG_SZ,
                        (BYTE *) pwszModel,
                        sizeof( WCHAR ) * (lstrlen( pwszModel ) + 1)
                        );
            if ( dwRet != ERROR_SUCCESS )
            {
                break;
            }
 
            RegCloseKey( hKey1 );
            hKey1 = NULL;
            RegCloseKey( hKey2 );
            hKey2 = NULL;
        } // for: each entry in factory entry array 
    }
    catch ( ... )
    {
          dwRet = SELFREG_E_CLASS;
    }

    if (hKey1 != NULL)
        RegCloseKey( hKey1 );
    if (hKey2 != NULL)
        RegCloseKey( hKey2 );
    
    return dwRet;

} //*** DllRegisterServer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllUnregisterServer( void )
//
//  Description:
//      Called when it is time to remove the registry entries.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
    WCHAR   wszID[ g_cchGUID ];
    WCHAR   wszCLSID[ g_cchRegkey ];
    HKEY    hKey;
    INT     idx;
    DWORD   dwRet   = ERROR_SUCCESS;
    INT     cArray  = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < cArray && dwRet == ERROR_SUCCESS ; idx++ )
    {
       dwRet = StringFromGUID2(
            *g_FactoryDataArray[ idx ].m_pCLSID,
            wszID,
            g_cchGUID
            );

        if (dwRet == 0)
        {
            dwRet = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if (FAILED(StringCchPrintf(wszCLSID, g_cchRegkey - 1, L"Software\\Classes\\CLSID\\%lS", wszID)))
        {
            dwRet = ERROR_INSUFFICIENT_BUFFER;
            break;
        }
        wszCLSID[g_cchRegkey - 1] = L'\0';

        // First delete the InProcServer subkey.

        dwRet = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    wszCLSID,
                    &hKey
                    );
        if ( dwRet != ERROR_SUCCESS )
        {
            continue;
        }
        
        dwRet = RegDeleteKeyW( hKey, L"InProcServer32" );
        RegCloseKey( hKey );

        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }

        dwRet = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Classes\\CLSID",
                    &hKey
                    );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
        
        dwRet = RegDeleteKeyW( hKey,wszID );
        RegCloseKey( hKey );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
    } // for: each object
    
    //if ( dwRet != ERROR_SUCCESS )
    //{
    //    dwRet = SELFREG_E_CLASS;
    //}

    return S_OK;

} //*** DllUnregisterServer()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllGetClassObject(
//      REFCLSID    rclsidIn,
//      REFIID      riidIn,
//      PPVOID      ppvOut
//      )
//
//  Description:
//      Called by Ole when some client wants a class factory.  Return
//      one only if it is the sort of class this DLL supports.
//
//  Arguments:
//      rclsidIn    --
//      riidIn      --
//      ppvOut      --
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      E_OUTOFMEMORY
//      E_FAIL
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    PPVOID      ppvOut
    )
{

    HRESULT         hr;
    CProvFactory *  pObj = NULL;
    UINT            idx;
    UINT            cDataArray = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < cDataArray ; idx++ )
    {
        if ( IsEqualCLSID(rclsidIn, *g_FactoryDataArray[ idx ].m_pCLSID) )
        {
            pObj= new CProvFactory( &g_FactoryDataArray[ idx ] );
            if ( NULL == pObj )
            {
                return E_OUTOFMEMORY;
            }

            hr = pObj->QueryInterface( riidIn, ppvOut );

            if ( FAILED( hr ) )
            {
                delete pObj;
            }

            return hr;
        }
    }
    return E_FAIL;

} //*** DllGetClassObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\clip.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: clip.h
*
* External interface for clip.h
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef __CLIP__
#define __CLIP__

VOID
vClipAndRender(
    GFNPB * ppb);

BOOL
bIntersect(
    RECTL*  pRcl1,
    RECTL*  pRcl2,
    RECTL*  pRclResult);

LONG
cIntersect(
    RECTL*  pRclClip,
    RECTL*  pRclIn,
    LONG    lNumOfRecs);

#endif // __CLIP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\brush.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: brush.h
*
* Contains all the brush related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef __BRUSH__H__
#define __BRUSH__H__

//
// Brush stuff
//
// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:
//
#define SLOW_BRUSH_CACHE_DIM_X  8
#define SLOW_BRUSH_CACHE_DIM_Y  1   // Controls the number of brushes cached
                                    // in off-screen memory, when we don't have
                                    // the hardware pattern support. We
                                    // allocate 3 x 3 brushes, so we can cache
                                    // a total of 9 brushes:

#define SLOW_BRUSH_COUNT  (SLOW_BRUSH_CACHE_DIM_X * SLOW_BRUSH_CACHE_DIM_Y)
#define SLOW_BRUSH_DIMENSION    40  // After alignment is taken care of, every
                                    // off-screen brush cache entry will be 48
                                    // pels in both dimensions

#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    // pattern, using the 8 extra for brush
                                    // alignment

//
// 'Fast' brushes are used when we have hardware pattern capability:
//
#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    // cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry is
                                    // 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    // the dimension of each brush allocation

//
// Common to both implementations:
//
#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

//
// New brush support
//

#define NUM_CACHED_BRUSHES      16

#define CACHED_BRUSH_WIDTH_LOG2 6
#define CACHED_BRUSH_WIDTH      (1 << CACHED_BRUSH_WIDTH_LOG2)
#define CACHED_BRUSH_HEIGHT_LOG2 6
#define CACHED_BRUSH_HEIGHT     (1 << CACHED_BRUSH_HEIGHT_LOG2)
#define CACHED_BRUSH_SIZE       (CACHED_BRUSH_WIDTH * CACHED_BRUSH_HEIGHT)

typedef struct _BrushEntry BrushEntry;

//
// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
// in i386/strucs.inc!
//
typedef struct _RBrush
{
    FLONG       fl;                 // Type flags
    DWORD       areaStippleMode;    // area stipple mode if 1bpp.

    //
    //??? get rid of bTransparent later. We need it now so everything
    // compiles OK
    //
    BOOL        bTransparent;       // TRUE if brush was realized for a
                                    // transparent blt (meaning colours are
                                    // white and black).
                                    // FALSE if not (meaning it's already been
                                    // colour-expanded to the correct colours).
                                    // Value is undefined if the brush isn't
                                    // 2 colour.
    ULONG       ulForeColor;        // Foreground colour if 1bpp
    ULONG       ulBackColor;        // Background colour if 1bpp
    POINTL      ptlBrushOrg;        // Brush origin of cached pattern.  Initial
                                    // value should be -1
    BrushEntry* pbe;                // Points to brush-entry that keeps track
                                    // of the cached off-screen brush bits
    ULONG       aulPattern[1];      // Open-ended array for keeping copy of the
                                    // actual pattern bits in case the brush
                                    // origin changes, or someone else steals
                                    // our brush entry (declared as a ULONG
                                    // for proper dword alignment)
    //
    // Don't put anything after here
    //
} RBrush;                           /* rb, prb */

typedef struct _BrushEntry
{
    RBrush*     prbVerify;          // We never dereference this pointer to
                                    // find a brush realization; it is only
                                    // ever used in a compare to verify that
                                    // for a given realized brush, our
                                    // off-screen brush entry is still valid.
    ULONG       ulPixelOffset;      // pixel offset in video memory to brush
                                    // partial product for this stride is
                                    // ppdev->ulBrushPackedPP
} BrushEntry;                       /* be, pbe */

typedef union _RBrushColor
{
    RBrush*     prb;
    ULONG       iSolidColor;
} RBrushColor;                     /* rbc, prbc */

BOOL    bEnableBrushCache(PDev* ppdev);
VOID    vAssertModeBrushCache(PDev* ppdev, BOOL bEnable);
VOID    vDisableBrushCache(PDev* ppdev);
VOID    vRealizeDitherPattern(HDEV hdev, RBrush* prb, ULONG ulRGBToDither);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\brush.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: brush.c
*
* Content:   Handles all brush/pattern initialization and realization. 
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#include "precomp.h"
#include "heap.h"

//-----------------------------------------------------------------------------
//
// VOID vRealizeDitherPattern
//
// Generates an 8x8 dither pattern, in our internal realization format, for
// the colour ulRGBToDither.
//
//-----------------------------------------------------------------------------
VOID
vRealizeDitherPattern(HDEV      hdev,
                      RBrush*   prb,
                      ULONG     ulRGBToDither)
{
    //
    // Do the actual dithering
    // Note: This function is NT5 only. If you want to write a NT4 driver,
    // you have to implement dither function in the driver
    //
    EngDitherColor(hdev, DM_DEFAULT, ulRGBToDither, &prb->aulPattern[0]);

    //
    // Initialize the fields we need
    //
    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe           = NULL;
}// vRealizeDitherPattern()

//---------------------------Public*Routine------------------------------------
//
// BOOL DrvRealizeBrush
//
// This function allows us to convert GDI brushes into an internal form
// we can use.  It is called by GDI when we've called BRUSHOBJ_pvGetRbrush
// in some other function like DrvBitBlt, and GDI doesn't happen have a cached
// realization lying around.
//
// Parameters:
// pbo----------Points to the BRUSHOBJ that is to be realized. All other
//              parameters, except for psoTarget, can be queried from this
//              object. Parameter specifications are provided as an
//              optimization. This parameter is best used only as a parameter
//              for BRUSHOBJ_pvAllocRBrush, which allocates the memory for the
//              realized brush. 
// psoTarget----Points to the surface for which the brush is to be realized.
//              This surface can be the physical surface for the device, a
//              device format bitmap, or a standard format bitmap. 
// psoPattern---Points to the surface that describes the pattern for the brush.
//              For a raster device, this is a bitmap. For a vector device,
//              this is one of the pattern surfaces provided by DrvEnablePDEV. 
// psoMask------Points to a transparency mask for the brush. This is a 1 bit
//              per pixel bitmap that has the same extent as the pattern. A
//              mask of zero means the pixel is considered a background pixel
//              for the brush. (In transparent background mode, the background
//              pixels are unaffected in a fill.) Plotters can ignore this
//              parameter because they never draw background information.
// pxlo---------Points to a XLATEOBJ that defines the interpretration of colors
//              in the pattern. A XLATEOBJXxx service routine can be called to
//              translate the colors to device color indices. Vector devices
//              should translate color zero through the XLATEOBJ to get the
//              foreground color for the brush. 
// ulHatch------Specifies whether psoPattern is one of the hatch brushes
//              returned by DrvEnablePDEV. This is true if the value of this
//              parameter is less than HS_API_MAX. 
//
// Return Value
//  The return value is TRUE if the brush was successfully realized. Otherwise,
//  it is FALSE, and an error code is logged.
//
// Comments
//  To realize a brush, the driver converts a GDI brush into a form that can be
//  used internally. A realized brush contains information and accelerators the
//  driver needs to fill an area with a pattern; information that is defined by
//  the driver and used only by the driver.
//
//  The driver's realization of a brush is written into the buffer allocated by
//  a call to BRUSHOBJ_pvAllocRbrush.
//
//  DrvRealizeBrush is required for a driver that does any drawing to any
//  surface.
//
//  ppdev->bRealizeTransparent -- Hint for whether or not the brush should be
//                              realized for transparency.  If this hint is
//                              wrong, there will be no error, but the brush
//                              will have to be unnecessarily re-realized.
//
// Note: You should always set 'ppdev->bRealizeTransparent' before calling
//       BRUSHOBJ_pvGetRbrush!
//
//-----------------------------------------------------------------------------
BOOL
DrvRealizeBrush(BRUSHOBJ*   pbo,
                SURFOBJ*    psoDst,
                SURFOBJ*    psoPattern,
                SURFOBJ*    psoMask,
                XLATEOBJ*   pxlo,
                ULONG       ulHatch)
{
    PDev*       ppdev = (PDev*)psoDst->dhpdev;
    
    BYTE*       pbDst;
    BYTE*       pbSrc;
    LONG        i;
    LONG        j;
    LONG        lNumPixelToBeCopied;
    LONG        lSrcDelta;
    RBrush*     prb;    
    ULONG*      pulXlate;
    ULONG       ulPatternFormat;

    PERMEDIA_DECL;

    DBG_GDI((6, "DrvRealizeBrush called for pbo 0x%x", pbo));

    //
    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:
    //
    if ( ulHatch & RB_DITHERCOLOR )
    {
        //
        // Move this test in here since we always support monochrome brushes
        // as they live in the on-chip area stipple. These dithered brushes
        // will always be colored requiring available off-screen memory.
        //
        if ( !(ppdev->flStatus & STAT_BRUSH_CACHE) )
        {
            //
            // We only handle brushes if we have an off-screen brush cache
            // available.  If there isn't one, we can simply fail the
            // realization, and eventually GDI will do the drawing for us
            // (although a lot slower than we could have done it)
            //
            DBG_GDI((6, "brush cache not enabled"));
            goto ReturnFalse;
        }

        DBG_GDI((7, "DITHERONREALIZE"));

        //
        // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE
        // First, we need to allocate memory for the realization of a brush
        // Note: actually we ask for allocation of a RBRUSH + the brush
        // stamp size
        //
        prb = (RBrush*)BRUSHOBJ_pvAllocRbrush(pbo,
                       sizeof(RBrush) + (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
        if ( prb == NULL )
        {
            DBG_GDI((1, "BRUSHOBJ_pvAllocRbrush() in dither return NULL\n"));
            goto ReturnFalse;
        }

        //
        // Dither and realize the brsuh pattern
        //
        vRealizeDitherPattern(psoDst->hdev, prb, ulHatch);

        goto ReturnTrue;
    }// if ( ulHatch & RB_DITHERCOLOR )

    //
    // We only handle brushes if we have an off-screen brush cache available
    // If there isn't one, we can simply fail the realization, and eventually
    // GDI will do the drawing for us (although a lot slower than we could have
    // done it). We always succeed for 1bpp patterns since we use the area
    // stipple unit to do these rather than off-screen memory.
    //
    ulPatternFormat = psoPattern->iBitmapFormat;

    if ( !(ppdev->flStatus & STAT_BRUSH_CACHE)
        &&(ulPatternFormat != BMF_1BPP) )
    {
        DBG_GDI((1, "brush cache not enabled, or Bitmap is not 1 BPP"));
        goto ReturnFalse;
    }

    //
    // We only accelerate 8x8 patterns since most of the video card can only
    // accelerate 8x8 brush
    //
    if ( (psoPattern->sizlBitmap.cx != 8)
       ||(psoPattern->sizlBitmap.cy != 8) )
    {
        DBG_GDI((1, "Brush Bitmap size is not 8x8"));
        goto ReturnFalse;
    }

    //    
    // We need to allocate memory for the realization of a brush
    // Note: actually we ask for allocation of a RBRUSH + the brush stamp size
    //
    prb = (RBrush*)BRUSHOBJ_pvAllocRbrush(pbo,
                   sizeof(RBrush) + (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
    if ( prb == NULL )
    {
        DBG_GDI((0, "BRUSHOBJ_pvAllocRbrush() failed"));
        goto ReturnFalse;
    }

    //
    // Initialize the fields we need
    //
    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;

    prb->pbe = NULL;

    lSrcDelta = psoPattern->lDelta;
    pbSrc     = (BYTE*)psoPattern->pvScan0;
    pbDst     = (BYTE*)&prb->aulPattern[0];

    //
    // At 8bpp, we handle patterns at 1bpp, 4bpp and 8bpp with/without an xlate
    // At 16bpp, we handle patterns at 16 bpp without an xlate.
    // At 32bpp, we handle patterns at 32bpp without an xlate.
    // We handle all the patterns at 1 bpp with/without an Xlate
    //
    // Check if the brush pattern has the same color depth as our current
    // display color depth
    //
    if ( ulPatternFormat == BMF_1BPP )
    {
        DWORD   Data;

        DBG_GDI((7, "Realizing 1bpp brush"));

        //
        // We dword align the monochrome bitmap so that every row starts
        // on a new long (so that we can do long writes later to transfer
        // the bitmap to the area stipple unit).
        //
        for ( i = 8; i != 0; i-- )
        {
            //
            // Replicate the brush to 32 bits wide, as the TX cannot
            // span fill 8 bit wide brushes
            //
            Data = (*pbSrc) & 0xff;
            Data |= Data << 8;
            Data |= Data << 16;
            *(DWORD*)pbDst = Data;

            //
            // Area stipple is loaded with DWORDS
            //
            pbDst += sizeof(DWORD);
            pbSrc += lSrcDelta;
        }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulForeColor = pulXlate[1];
        prb->ulBackColor = pulXlate[0];
    }// Pattern at 1 BPP
    else if ( (ulPatternFormat == BMF_4BPP)&&(ppdev->iBitmapFormat == BMF_8BPP))
    {
        DBG_GDI((7, "Realizing 4bpp brush"));

        //
        // The screen is 8bpp and the pattern is 4bpp:
        //            
        pulXlate = pxlo->pulXlate;

        for ( i = 8; i != 0; i-- )
        {
            //
            // Inner loop is repeated only 4 times because each loop
            // handles 2 pixels:
            //
            for ( j = 4; j != 0; j-- )
            {
                *pbDst++ = (BYTE)pulXlate[*pbSrc >> 4];
                *pbDst++ = (BYTE)pulXlate[*pbSrc & 15];
                pbSrc++;
            }

            pbSrc += lSrcDelta - 4;
        }
    }// Pattern 4BPP and Screen 8 BPP
    else if ( ( ppdev->iBitmapFormat == ulPatternFormat )
            &&( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) ) )
    {
        DBG_GDI((7, "Realizing un-translated brush"));

        //
        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done.
        // Here we first need to calculate how many pixel need to be
        // copied
        //
        lNumPixelToBeCopied = (8 << ppdev->cPelSize);

        for ( i = 8; i != 0; i-- )
        {
            RtlCopyMemory(pbDst, pbSrc, lNumPixelToBeCopied);

            pbSrc += lSrcDelta;
            pbDst += lNumPixelToBeCopied;
        }
    }// Pattern and Screen has same color depth, No Xlate
    else if ( (ppdev->iBitmapFormat == BMF_8BPP)
            &&(ulPatternFormat == BMF_8BPP) )
    {
        DBG_GDI((7, "Realizing 8bpp translated brush"));

        //
        // The screen is 8bpp, and there's translation to be done
        // So we have to do copy + Xlate one by one
        //
        pulXlate = pxlo->pulXlate;

        for ( i = 8; i != 0; i-- )
        {
            for ( j = 8; j != 0; j-- )
            {
                *pbDst++ = (BYTE)pulXlate[*pbSrc++];
            }

            pbSrc += lSrcDelta - 8;
        }
    }// Screen mode and pattern mode all at 8 BPP
    else
    {
        //
        // We've got a brush whose format we haven't special cased.
        //
        goto ReturnFalse;
    }

ReturnTrue:
    DBG_GDI((6, "DrvRealizeBrush returning true"));
    
    return(TRUE);

ReturnFalse:

    if ( psoPattern != NULL )
    {
        DBG_GDI((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                 psoPattern->iType, psoPattern->iBitmapFormat,
                 psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }
    DBG_GDI((6, "DrvRealizeBrush returning false"));

    return(FALSE);
}// DrvRealizeBrush()

//-----------------------------------------------------------------------------
//
// BOOL bEnableBrushCache
//
// Allocates off-screen memory for storing the brush cache.
//
//-----------------------------------------------------------------------------
BOOL
bEnableBrushCache(PDev* ppdev)
{
    BrushEntry* pbe;            // Pointer to the brush-cache entry
    LONG        i;
    LONG        lDelta;
    ULONG       ulPixOffset;

    DBG_GDI((6, "bEnableBrushCache"));

    ASSERTDD(!(ppdev->flStatus & STAT_BRUSH_CACHE),
                "bEnableBrushCache: unexpected already enabled brush cache");
    
    //
    // ENABLE_BRUSH_CACHE by default is on. It would be turned off in
    // bInitializeHw() if 3D buffers runs out of memory
    //
    if ( !(ppdev->flStatus & ENABLE_BRUSH_CACHE) )
    {
        DBG_GDI((1, "Brush cache not valid for creation"));
        goto ReturnTrue;
    }

    ppdev->ulBrushVidMem = ulVidMemAllocate(ppdev,
                                            CACHED_BRUSH_WIDTH,
                                            CACHED_BRUSH_HEIGHT
                                             *NUM_CACHED_BRUSHES,
                                             ppdev->cPelSize,
                                            &lDelta,
                                            &ppdev->pvmBrushHeap,
                                            &ppdev->ulBrushPackedPP,
                                            FALSE);

    if (ppdev->ulBrushVidMem == 0 )
    {
        DBG_GDI((0, "bEnableBrushCache: failed to allocate video memory"));
        goto ReturnTrue;    // See note about why we can return TRUE...
    }

    ASSERTDD(lDelta == (CACHED_BRUSH_WIDTH << ppdev->cPelSize),
             "bEnableBrushCache: unexpected stride does not match width");

    ppdev->cBrushCache = NUM_CACHED_BRUSHES;

    ulPixOffset = (ULONG) ppdev->ulBrushVidMem >> ppdev->cPelSize;
    pbe = &ppdev->abe[0];
    
    for (i = 0; i < NUM_CACHED_BRUSHES; i++, pbe++)
    {
        pbe->prbVerify = NULL;
        pbe->ulPixelOffset = ulPixOffset;
        ulPixOffset += CACHED_BRUSH_SIZE;

        memset((pbe->ulPixelOffset << ppdev->cPelSize) + ppdev->pjScreen, 
                    0x0, (CACHED_BRUSH_SIZE << ppdev->cPelSize)); 
    }
    
    //
    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:
    //
    DBG_GDI((6, "bEnableBrushCache: successfully allocated brush cache"));
    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:
    //
    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:
    //
    DBG_GDI((6, "Passed bEnableBrushCache"));

    return(TRUE);
}// bEnableBrushCache()

//-----------------------------------------------------------------------------
//
// VOID vDisableBrushCache
//
// Cleans up anything done in bEnableBrushCache.
//
//-----------------------------------------------------------------------------
VOID
vDisableBrushCache(PDev* ppdev)
{
    DBG_GDI((6,"vDisableBrushCache"));
    if(ppdev->flStatus & STAT_BRUSH_CACHE)
    {
        DBG_GDI((6,"vDisableBrushCache: freeing brush cache"));
        VidMemFree(ppdev->pvmBrushHeap->lpHeap,
                   (FLATPTR)(ppdev->ulBrushVidMem));
        ppdev->cBrushCache = 0;

        ppdev->flStatus &= ~STAT_BRUSH_CACHE;
        DBG_GDI((6,"vDisableBrushCache: freeing brush cache done"));
    }

}// vDisableBrushCache()

//-----------------------------------------------------------------------------
//
// VOID vAssertModeBrushCache
//
// Resets the brush cache when we exit out of full-screen.
//
//-----------------------------------------------------------------------------
VOID
vAssertModeBrushCache(PDev*   ppdev,
                      BOOL    bEnable)
{
    if ( bEnable )
    {
        bEnableBrushCache(ppdev);
    }
    else
    {
        vDisableBrushCache(ppdev);
    }
}// vAssertModeBrushCache()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\vss\schema.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Schema.cpp
//
//  Description:
//      Implementation of schema defined strings
//
//  Author:
//      Jim Benton (jbenton)  5-Nov-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////
//
// class
//

const WCHAR * const PVDR_CLASS_DIFFVOLUMESUPPORT   = L"Win32_ShadowDiffVolumeSupport";
const WCHAR * const PVDR_CLASS_PROVIDER          = L"Win32_ShadowProvider";
const WCHAR * const PVDR_CLASS_SHADOW            = L"Win32_ShadowCopy";
const WCHAR * const PVDR_CLASS_SHADOWBY          = L"Win32_ShadowBy";
const WCHAR * const PVDR_CLASS_SHADOWFOR         = L"Win32_ShadowFor";
const WCHAR * const PVDR_CLASS_SHADOWON          = L"Win32_ShadowOn";
const WCHAR * const PVDR_CLASS_VOLUMESUPPORT   = L"Win32_ShadowVolumeSupport";
const WCHAR * const PVDR_CLASS_STORAGE           = L"Win32_ShadowStorage";
const WCHAR * const PVDR_CLASS_VOLUME            = L"Win32_Volume";
const WCHAR * const PVDR_CLASS_WRITER            = L"Win32_ShadowWriter";

//
// Methods
//
const WCHAR * const PVDR_MTHD_CREATE             = L"Create";

//
// Properties
//
const WCHAR * const PVDR_PROP_ALLOCATEDSPACE     = L"AllocatedSpace";
const WCHAR * const PVDR_PROP_CLSID              = L"CLSID";
const WCHAR * const PVDR_PROP_CONTEXT             = L"Context";
const WCHAR * const PVDR_PROP_COUNT              = L"Count";
const WCHAR * const PVDR_PROP_DEVICEOBJECT       = L"DeviceObject";
const WCHAR * const PVDR_PROP_DEVICEID               = L"DeviceID";
const WCHAR * const PVDR_PROP_DIFFVOLUME         = L"DiffVolume";
const WCHAR * const PVDR_PROP_DISPLAYNAME        = L"DisplayName";
const WCHAR * const PVDR_PROP_EXPOSEDNAME        = L"ExposedName";
const WCHAR * const PVDR_PROP_EXPOSEDPATH        = L"ExposedPath";
const WCHAR * const PVDR_PROP_FREESPACE          = L"FreeSpace";
const WCHAR * const PVDR_PROP_ID                 = L"ID";
const WCHAR * const PVDR_PROP_LASTERROR          = L"LastError";
const WCHAR * const PVDR_PROP_MAXSPACE           = L"MaxSpace";
const WCHAR * const PVDR_PROP_NAME               = L"Name";
const WCHAR * const PVDR_PROP_ORIGINATINGMACHINE = L"OriginatingMachine";
const WCHAR * const PVDR_PROP_PROVIDER           = L"Provider";
const WCHAR * const PVDR_PROP_PROVIDERID         = L"ProviderID";
const WCHAR * const PVDR_PROP_SERVICEMACHINE     = L"ServiceMachine";
const WCHAR * const PVDR_PROP_SETID              = L"SetID";
const WCHAR * const PVDR_PROP_SHADOW             = L"ShadowCopy";
const WCHAR * const PVDR_PROP_SHADOWID           = L"ShadowID";
const WCHAR * const PVDR_PROP_STATE              = L"State";
const WCHAR * const PVDR_PROP_STORAGE            = L"Storage";
const WCHAR * const PVDR_PROP_TIMESTAMP          = L"InstallDate";
const WCHAR * const PVDR_PROP_TYPE               = L"Type";
const WCHAR * const PVDR_PROP_USEDSPACE          = L"UsedSpace";
const WCHAR * const PVDR_PROP_VERSION            = L"Version";
const WCHAR * const PVDR_PROP_VERSIONID          = L"VersionID";
const WCHAR * const PVDR_PROP_VOLUME             = L"Volume";
const WCHAR * const PVDR_PROP_VOLUMENAME         = L"VolumeName";

// Shadow Attributes
const WCHAR * const PVDR_PROP_PERSISTENT         = L"Persistent";
const WCHAR * const PVDR_PROP_CLIENTACCESSIBLE   = L"ClientAccessible";
const WCHAR * const PVDR_PROP_NOAUTORELEASE      = L"NoAutoRelease";
const WCHAR * const PVDR_PROP_NOWRITERS          = L"NoWriters";
const WCHAR * const PVDR_PROP_TRANSPORTABLE      = L"Transportable";
const WCHAR * const PVDR_PROP_NOTSURFACED        = L"NotSurfaced";
const WCHAR * const PVDR_PROP_HARDWAREASSISTED   = L"HardwareAssisted";
const WCHAR * const PVDR_PROP_DIFFERENTIAL       = L"Differential";
const WCHAR * const PVDR_PROP_PLEX               = L"Plex";
const WCHAR * const PVDR_PROP_IMPORTED           = L"Imported";
const WCHAR * const PVDR_PROP_EXPOSEDREMOTELY    = L"ExposedRemotely";
const WCHAR * const PVDR_PROP_EXPOSEDLOCALLY     = L"ExposedLocally";

// WBEM Properties
const WCHAR * const PVDR_PROP_RETURNVALUE     = L"ReturnValue";

// Shadow Context Names
const WCHAR * const VSS_CTX_NAME_BACKUP                         =  L"Backup"; 
const WCHAR * const VSS_CTX_NAME_FILESHAREBACKUP        = L"FileShareBackup"; 
const WCHAR * const VSS_CTX_NAME_NASROLLBACK                = L"NASRollBack"; 
const WCHAR * const VSS_CTX_NAME_APPROLLBACK                = L"AppRollBack"; 
const WCHAR * const VSS_CTX_NAME_CLIENTACCESSIBLE       = L"ClientAccessible"; 
const WCHAR * const VSS_CTX_NAME_ALL                                = L"All";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\clip.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: clip.c
 *
 * Clipping code.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "clip.h"

//----------------------------*Public*Routine-------------------------------
// BOOL bIntersect
//
// Function:
//      Check the integration of two input rectangles (RECTL* pRcl1,
//      RECTL* pRcl2) and set the intersection result in (RECTL* pRclResult)
//
// Return:
//      TRUE---If 'prcl1' and 'prcl2' intersect. The intersection will be in
//            'prclResult'
//      FALSE--If they don't intersect. 'prclResult' is undefined.
//
//---------------------------------------------------------------------------
BOOL
bIntersect(RECTL*  pRcl1,
           RECTL*  pRcl2,
           RECTL*  pRclResult)
{
    DBG_GDI((7, "bIntersect called--pRcl1=0x%x, pRcl2=0x%x, pRclResult=0x%x",
            pRcl1, pRcl2, pRclResult));
    
    pRclResult->left  = max(pRcl1->left,  pRcl2->left);
    pRclResult->right = min(pRcl1->right, pRcl2->right);

    //
    // Check if there an intersection horizontally
    //
    if ( pRclResult->left < pRclResult->right )
    {
        pRclResult->top    = max(pRcl1->top,    pRcl2->top);
        pRclResult->bottom = min(pRcl1->bottom, pRcl2->bottom);

        if (pRclResult->top < pRclResult->bottom)
        {
            //
            // Check if there an intersection vertically
            //
            return(TRUE);
        }
    }

    DBG_GDI((7, "bIntersect returned FALSE"));

    //
    // Return FALSE if there is no intersection
    //
    return(FALSE);
}// bIntersect()

//-----------------------------Public Routine-------------------------------
// LONG cIntersect
//
// This routine takes a list of rectangles from 'pRclIn' and clips them
// in-place to the rectangle 'pRclClip'.  The input rectangles don't
// have to intersect 'prclClip'; the return value will reflect the
// number of input rectangles that did intersect, and the intersecting
// rectangles will be densely packed.
//
//--------------------------------------------------------------------------
LONG
cIntersect(RECTL*  pRclClip,
           RECTL*  pRclIn,
           LONG    lNumOfRecs)
{
    LONG    cIntersections;
    RECTL*  pRclOut;

    DBG_GDI((7, "cIntersect called--pRclClip=0x%x, pRclIn=0x%x,lNumOfRecs=%ld",
             pRclClip, pRclIn, lNumOfRecs));

    cIntersections = 0;
    pRclOut        = pRclIn;        // Put the result in place as the input

    //
    // Validate input parameter
    //
    ASSERTDD( ((pRclIn != NULL ) && (pRclClip != NULL) && ( lNumOfRecs >= 0 )),
              "Wrong input to cIntersect" );    

    for (; lNumOfRecs != 0; pRclIn++, lNumOfRecs--)
    {
        pRclOut->left  = max(pRclIn->left,  pRclClip->left);
        pRclOut->right = min(pRclIn->right, pRclClip->right);

        if ( pRclOut->left < pRclOut->right )
        {
            //
            // Find intersection, horizontally, between current rectangle and
            // the clipping rectangle.
            //
            pRclOut->top    = max(pRclIn->top,    pRclClip->top);
            pRclOut->bottom = min(pRclIn->bottom, pRclClip->bottom);

            if ( pRclOut->top < pRclOut->bottom )
            {
                //
                // Find intersection, vertically, between current rectangle and
                // the clipping rectangle. Put this rectangle in the result
                // list and increment the counter. Ready for next input
                //
                pRclOut++;
                cIntersections++;
            }
        }
    }// loop through all the input rectangles

    DBG_GDI((7, "cIntersect found %d intersections", cIntersections));
    return(cIntersections);
}// cIntersect()

//-----------------------------Public Routine-------------------------------
// VOID vClipAndRender
//
// Clips the destination rectangle calling pfgn (the render function) as
// appropriate.
//
// Argumentes needed from function block (GFNPB)
// 
// pco------pointer to clip object
// prclDst--pointer to destination rectangle
// psurfDst-pointer to destination Surf
// psurfSrc-pointer to destination Surf (NULL if no source)
// pptlSrc--pointer to source point
// prclSrc--pointer to source rectangle (used if pptlSrc == NULL)
// pgfn-----pointer to render function
//
// NOTES:
//
// pptlSrc and prclSrc are only used if psurfSrc == psurfDst.  If there is
// no source psurfSrc must be set to NULL.  If prclSrc is specified, pptlSrc
// is not used.
//
//--------------------------------------------------------------------------

VOID vClipAndRender(GFNPB * ppb)
{
    CLIPOBJ * pco = ppb->pco;
    
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        ppb->pRects = ppb->prclDst;
        ppb->lNumRects = 1;
        ppb->pgfn(ppb);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL   rcl;

        if (bIntersect(ppb->prclDst, &pco->rclBounds, &rcl))
        {
            ppb->pRects = &rcl;
            ppb->lNumRects = 1;
            ppb->pgfn(ppb);
        }
    }
    else
    {
        ClipEnum    ce;
        LONG        c;
        BOOL        bMore;
        ULONG       ulDir = CD_ANY;

        // determine direction if operation on same surface
        if(ppb->psurfDst == ppb->psurfSrc)
        {
            LONG   lXSrc, lYSrc, offset;

            if(ppb->pptlSrc != NULL)
            {
                lXSrc = ppb->pptlSrc->x;
                lYSrc = ppb->pptlSrc->y;
            }
            else
            {
                lXSrc = ppb->prclSrc->left;
                lYSrc = ppb->prclSrc->top;
            }

            // NOTE: we can safely shift by 16 because the surface
            //       stride will never be greater the 2--16
            offset = (ppb->prclDst->top - lYSrc) << 16;
            offset += (ppb->prclDst->left - lXSrc);
            if(offset > 0)
                ulDir = CD_LEFTUP;
            else
                ulDir = CD_RIGHTDOWN;
        }


        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDir, 0);

        do
        {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

            c = cIntersect(ppb->prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                ppb->pRects = ce.arcl;
                ppb->lNumRects = c;
                ppb->pgfn(ppb);
            }

        } while (bMore);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3d.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3d.c
*
* Content: Main context and texture management callbacks for D3D
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "d3ddelta.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_3D2P
BOOL D3DInitialised = FALSE;

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DContextCreate
//
// The ContextCreate callback is invoked when a new Direct3D device is being 
// created by a Direct3D application. The driver is required to generate a 
// unique context id for this new context. Direct3D will then use this context 
// id in every subsequent callback invocation for this Direct3D device. 
//
// Context is the current rasterization state. For instance, if there are 3 
// applications running, each will have a different state at any point in time.
// When each one is running, the hardware has to make sure that the context, 
// (whether doing Gouraud shading, for example) is the same as the last time 
// that application got a time slice. 
//
// State is anything that the particular device needs to know per context 
// i.e. what surface is being rendered to, shading, texture, texture handles, 
// what physical surfaces those texture handles represent, etc. The context 
// encapsulates all state for the Direct3D device - state is not shared 
// between contexts. Therefore the driver needs to maintain full state 
// information for each context. This state will be changed by calls to the 
// RenderState callback. In the case of rasterization only hardware, the 
// driver need only maintain rasterization state. As well as state, the driver 
// will also want to store the lpDDS, lpDDSZ, and dwPid from the callback 
// data argument. 
//
// The driver should not create a context handle of zero. This is guaranteed 
// to be an invalid context handle. 
//
// Parameters
//      pccd
//           Pointer to a structure containing things including the current
//           rendering surface, the current Z surface, and the DirectX object
//           handle, etc.
//
//          .lpDDGbl    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDLcl(replaces lpDDGbl in DX7)    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDS      
//                This is the surface that is to be used as the rendering 
//                target, i.e., the 3D accelerator sprays its bits at this 
//                surface. 
//          .lpDDSZ     
//                The surface that is to be used as the Z buffer. If this 
//                is NULL, no Z buffering is to be performed. 
//          .dwPid      
//                The process id of the Direct3D application that initiated 
//                the creation of the Direct3D device. 
//          .dwhContext 
//                The driver should place the context ID that it wants Direct3D 
//                to use when communicating with the driver. This should be 
//                unique. 
//          .ddrval     
//                Return code. DD_OK indicates success. 
//
// Return Value
//      Returns one of the following values: 
//                DDHAL_DRIVER_HANDLED  
//                DDHAL_DRIVER_NOTHANDLED   
//
//-----------------------------------------------------------------------------

TextureCacheManager P2TextureManager;
DWORD   P2TMcount = 0;

DWORD CALLBACK 
D3DContextCreate(LPD3DHAL_CONTEXTCREATEDATA pccd)
{
    PERMEDIA_D3DCONTEXT* pContext;
    PermediaSurfaceData* pPrivateData;
    DWORD dwSlotNum;

    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl=pccd->lpDDLcl->lpGbl;

    // Remember the global data for this context.
    PPDev ppdev = (PPDev)lpDDGbl->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DBG_D3D((6,"Entering D3DContextCreate"));

    // Find an empty slot in the global D3D context table
    for (dwSlotNum = 1; dwSlotNum < MAX_CONTEXT_NUM; dwSlotNum++) 
    {
        if (ContextSlots[dwSlotNum] == 0) 
            break;
    }

    // return if we have no contexts left
    if (dwSlotNum == MAX_CONTEXT_NUM)
    {
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        return (DDHAL_DRIVER_HANDLED);
    }

    // Now allocate the drivers D3D context memory.  Simply a chunk of
    // RAM with the relevent data in it.
    pContext = (PERMEDIA_D3DCONTEXT *)
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(PERMEDIA_D3DCONTEXT), ALLOC_TAG);

    if (pContext == NULL)
    {
        DBG_D3D((0,"ERROR: Couldn't allocate Context mem"));
        pccd->ddrval = DDERR_OUTOFMEMORY;
        return (DDHAL_DRIVER_HANDLED);
    }
    else
    {
        DBG_D3D((4,"Allocated Context Mem"));
        memset((void *)pContext, 0, sizeof(PERMEDIA_D3DCONTEXT));
    }

    // Setup the drivers's D3D context
    pContext->Hdr.pSelf = (UINT_PTR)pContext;

    // Set up the DRIVER rendering context structure for sanity checks
    pContext->Hdr.MagicNo = RC_MAGIC_NO;

    // Remember the card we are running on
    pContext->ppdev = ppdev;

    // Set context handle in driver's D3D context
    pccd->dwhContext = dwSlotNum;                 //out:Context handle
    ContextSlots[dwSlotNum] = (UINT_PTR)pContext;

    DBG_D3D((4,"Allocated Direct3D context: 0x%x",pccd->dwhContext));

    // Allocate a register context
    P2CtxtPtr pP2ctxt;

    pP2ctxt = P2AllocateNewContext( pContext->ppdev, NULL, 0, P2CtxtWriteOnly);

    if (pP2ctxt == NULL)
    {
        DBG_D3D((0,"ERROR: Couldn't allocate Register Context"));
        CleanDirect3DContext(pContext, pccd->dwhContext);
        pccd->ddrval = DDERR_OUTOFMEMORY;
        return (DDHAL_DRIVER_HANDLED);
    }
    else
    {
        DBG_D3D((4,"Allocated Register context: 0x%x",pP2ctxt));

        // Record the register context in the window render context
        pContext->hPermediaContext = pP2ctxt;

    }

    // No texture at present
    pContext->CurrentTextureHandle = 0;

    // Initialize texture management for this context
    if (0 == P2TMcount)
    {
        if ( FAILED(TextureCacheManagerInitialize(&P2TextureManager)) )
        {
            DBG_D3D((0,"ERROR: Couldn't initialize TextureCacheManager"));
            CleanDirect3DContext(pContext, pccd->dwhContext);
            pccd->ddrval = DDERR_OUTOFMEMORY;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    P2TMcount++;
    pContext->pTextureManager = &P2TextureManager;

    // Remember the local DD object and get the 
    // correct array of surfaces for this context
    pContext->pDDLcl = pccd->lpDDLcl;
    pContext->pHandleList = GetSurfaceHandleList(pccd->lpDDLcl);
    if (pContext->pHandleList == NULL)
    {
        DBG_D3D((0,"ERROR: Couldn't get a surface handle for lpDDLcl"));
        CleanDirect3DContext(pContext, pccd->dwhContext);
        pccd->ddrval = DDERR_OUTOFMEMORY;
        return (DDHAL_DRIVER_HANDLED);
    }

    DBG_D3D((4,"Getting pHandleList=%08lx for pDDLcl %08lx",
                                 pContext->pHandleList,pccd->dwPID));

    pContext->RenderSurfaceHandle = DDS_LCL(pccd->lpDDS)->lpSurfMore->dwSurfaceHandle;
    if (NULL != pccd->lpDDSZ) 
        pContext->ZBufferHandle = DDS_LCL(pccd->lpDDSZ)->lpSurfMore->dwSurfaceHandle;
    else
        pContext->ZBufferHandle = 0;
    // Now write the default setup to the chip.
    if ( FAILED(InitPermediaContext(pContext)) )
    {
        DBG_D3D((0,"ERROR: D3DContextCreate receives bad parameters "));
        CleanDirect3DContext(pContext, pccd->dwhContext);
        pccd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    // ---------------- Setup default states in driver ------------------------

    // On context creation, no render states are overridden
    STATESET_INIT(pContext->overrides);

#if D3D_STATEBLOCKS
    // Default state block recording mode = no recording
    pContext->bStateRecMode = FALSE;
    pContext->pCurrSS = NULL;
    pContext->pIndexTableSS = NULL;
    pContext->dwMaxSSIndex = 0;
#endif //D3D_STATEBLOCKS

    pContext->Hdr.Flags = CTXT_HAS_GOURAUD_ENABLED ;
    pContext->CullMode = D3DCULL_CCW;

    // Set the last alpha value to 16 to force a new
    // send of the flat stipple patterns.
    pContext->LastAlpha = 16;

    pContext->bKeptStipple  = FALSE;  // By default, stippling is off
    pContext->bCanChromaKey = FALSE;  // Turn Chroma keying off by default
    pContext->LowerChromaColor = 0x0; // These are the default chromakey values
    pContext->UpperChromaColor = 0x0;

    pContext->FakeBlendNum = 0;       // No need to emulate any blend mode

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    pContext->bPointSpriteEnabled = FALSE; // Point sprite defaults
    pContext->fPointSize = 1.0f;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

    // Initialise the RenderCommand.  States will add to this
    pContext->RenderCommand = 0;
    RENDER_SUB_PIXEL_CORRECTION_ENABLE(pContext->RenderCommand);

    // Setup TSS defaults for stage 0
    pContext->TssStates[D3DTSS_TEXTUREMAP] = 0;
    pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
    pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
    pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_CURRENT;
    pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
    pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_CURRENT;
    pContext->TssStates[D3DTSS_TEXCOORDINDEX] = 0;
    pContext->TssStates[D3DTSS_ADDRESS] = D3DTADDRESS_WRAP;
    pContext->TssStates[D3DTSS_ADDRESSU] = D3DTADDRESS_WRAP;
    pContext->TssStates[D3DTSS_ADDRESSV] = D3DTADDRESS_WRAP;
    pContext->TssStates[D3DTSS_MAGFILTER] = D3DTFG_POINT;
    pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
    pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_NONE;

    pContext->TssStates[D3DTSS_BUMPENVMAT00] = 0;           // info we don't use
    pContext->TssStates[D3DTSS_BUMPENVMAT01] = 0;           // in this sample 
    pContext->TssStates[D3DTSS_BUMPENVMAT10] = 0;
    pContext->TssStates[D3DTSS_BUMPENVMAT11] = 0;
    pContext->TssStates[D3DTSS_BUMPENVLSCALE] = 0;
    pContext->TssStates[D3DTSS_BUMPENVLOFFSET] = 0;
    pContext->TssStates[D3DTSS_BORDERCOLOR] = 0x00000000;
    pContext->TssStates[D3DTSS_MAXMIPLEVEL] = 0;
    pContext->TssStates[D3DTSS_MAXANISOTROPY] = 1;

    // Force a change in texture before any 
    // rendering takes place for this context
    DIRTY_TEXTURE;

    DBG_D3D((6,"Exiting D3DContextCreate"));

    pccd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
} // D3DContextCreate

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DContextDestroy
//
// This callback is invoked when a Direct3D Device is being destroyed. As each 
// device is represented by a context ID, the driver is passed a context to 
// destroy. 
//
// The driver should free all resources it allocated to the context being 
// deleted. For example, the driver should free any texture resources it 
// associated with the context. The driver should not free the DirectDraw 
// surface(s) associated with the context because these will be freed by 
// DirectDraw in response to an application or Direct3D runtime request.
//
// Parameters
//     pcdd
//          Pointer to Context destroy information.
//
//          .dwhContext 
//               The ID of the context to be destroyed. 
//          .ddrval
//               Return code. DD_OK indicates success. 
//
// Return Value
//      Returns one of the following values: 
//                DDHAL_DRIVER_HANDLED   
//                DDHAL_DRIVER_NOTHANDLED    
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pcdd)
{
    PERMEDIA_D3DCONTEXT *pContext;

    // Deleting context
    DBG_D3D((6,"Entering D3DContextDestroy, context = %08lx",pcdd->dwhContext));

    pContext = (PERMEDIA_D3DCONTEXT *)ContextSlots[pcdd->dwhContext] ;

    if ( pContext != NULL && pContext->Hdr.MagicNo == RC_MAGIC_DISABLE)
        // render context has been deliberately disabled.
        // set the magic number back to valid to allow the cleanup
        // to proceed in the normal way.
        pContext->Hdr.MagicNo = RC_MAGIC_NO ;

    CHK_CONTEXT( pContext, pcdd->ddrval, "D3DContextDestroy");

    DBG_D3D((4,"Freeing context resources"));
    CleanDirect3DContext(pContext, pcdd->dwhContext);

    pcdd->ddrval = DD_OK;

    DBG_D3D((6,"Exiting D3DContextDestroy"));

    return (DDHAL_DRIVER_HANDLED);
} // D3DContextDestroy


//-----------------------------------------------------------------------------
//
// void __InitD3DTextureWithDDSurfInfo
//
//-----------------------------------------------------------------------------
void  
__InitD3DTextureWithDDSurfInfo(PPERMEDIA_D3DTEXTURE pTexture, 
                               LPDDRAWI_DDRAWSURFACE_LCL lpSurf, 
                               PPDev ppdev)
{
    DBG_D3D((10,"Entering lpSurf=%08lx %08lx",lpSurf,lpSurf->lpGbl->fpVidMem));
    
    pTexture->pTextureSurface = 
            (PermediaSurfaceData*)lpSurf->lpGbl->dwReserved1;

    if (NULL != pTexture->pTextureSurface)
    {
        pTexture->pTextureSurface->dwFlags |= P2_SURFACE_NEEDUPDATE;
        // need to recover this as CreateSurfaceEx may call us during TextureSwap()
        pTexture->dwPaletteHandle = pTexture->pTextureSurface->dwPaletteHandle;
    }
    // Need to remember the sizes and the log of the sizes of the maps
    pTexture->fpVidMem = lpSurf->lpGbl->fpVidMem;
    pTexture->lPitch = lpSurf->lpGbl->lPitch;
    pTexture->wWidth = (WORD)(lpSurf->lpGbl->wWidth);
    pTexture->wHeight = (WORD)(lpSurf->lpGbl->wHeight);
    pTexture->dwRGBBitCount=lpSurf->lpGbl->ddpfSurface.dwRGBBitCount;
    pTexture->m_dwBytes = pTexture->wHeight * pTexture->lPitch; 
    // Magic number for validity check
    pTexture->MagicNo = TC_MAGIC_NO;
    pTexture->dwFlags = lpSurf->dwFlags; 
    pTexture->dwCaps = lpSurf->ddsCaps.dwCaps;
    pTexture->dwCaps2= lpSurf->lpSurfMore->ddsCapsEx.dwCaps2;
    if (DDRAWISURF_HASCKEYSRCBLT & pTexture->dwFlags)
    {
         pTexture->dwKeyLow = lpSurf->ddckCKSrcBlt.dwColorSpaceLowValue;
         pTexture->dwKeyHigh = lpSurf->ddckCKSrcBlt.dwColorSpaceHighValue;
         DBG_D3D((4, "ColorKey exists (%08lx %08lx) on surface %d",
                     pTexture->dwKeyLow,pTexture->dwKeyHigh,
                     lpSurf->lpSurfMore->dwSurfaceHandle));
    }

    if (DD_P2AGPCAPABLE(ppdev) && pTexture->dwCaps & DDSCAPS_NONLOCALVIDMEM) 
    {
        pTexture->lSurfaceOffset = DD_AGPSURFBASEOFFSET(lpSurf->lpGbl);
    }

#if D3D_MIPMAPPING
    // Verify if texture has mip maps atteched
    if (lpSurf->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpNextSurf;
        int LOD;

        lpNextSurf = lpSurf;
        LOD = 0;

        pTexture->bMipMap = TRUE;

        // Calculate the number of mipmap levels (if this is a mipmap)
        pTexture->iMipLevels = (DWORD)((pTexture->wWidth > pTexture->wHeight) ?
                                                  log2((int)pTexture->wWidth) :
                                             log2((int)pTexture->wHeight)) + 1;

        // Walk the chain of surfaces and find all of the mipmap levels
        for (LOD = 0; LOD < pTexture->iMipLevels; LOD++)
        {
            DBG_D3D((4, "Loading texture LOD:%d, Ptr:0x%x",
                        LOD, lpNextSurf->lpGbl->fpVidMem));

            // Store the offsets for each of the mipmap levels
            StorePermediaLODLevel(ppdev, pTexture, lpNextSurf, LOD);

            // Is there another surface in the chain?
            if (lpNextSurf->lpAttachList)
            {
                lpNextSurf = lpNextSurf->lpAttachList->lpAttached;
                if (lpNextSurf == NULL)
                    break;
            }
            else 
                break;
        }

        // This isn't really a MipMap if LOD is 0
        if (LOD == 0)
        {
            DBG_D3D((4, "Texture was not a mipmap - only 1 level"));
            pTexture->bMipMap = FALSE;
            pTexture->iMipLevels = 1;
        }
        else
        {
            // Fill in the remaining levels with the smallest LOD
            // (this is for applications that haven't bothered to
            // pass us all of the LOD's).
            if (LOD < (pTexture->iMipLevels - 1))
            {
                int iLastLOD = LOD;

                DBG_D3D((4,"Filling in missing mipmaps!"));

                for (;LOD < MAX_MIP_LEVELS; LOD++)
                {
                    pTexture->MipLevels[LOD] = pTexture->MipLevels[iLastLOD];
                }
            }
        }
    }
    else 
#endif //D3D_MIPMAPPING
    {
        // NOT A MIPMAP, simply store away the offset of level 0
        pTexture->bMipMap = FALSE;
        pTexture->iMipLevels = 1;
        StorePermediaLODLevel(ppdev, pTexture, lpSurf, 0);
    }

    // If debugging show what has just been created
    DISPTEXTURE((ppdev, pTexture, &lpSurf->lpGbl->ddpfSurface));

    DBG_D3D((10,"Exiting __InitD3DTextureWithDDSurfInfo"));
} // __InitD3DTextureWithDDSurfInfo


//@@BEGIN_DDKSPLIT
#if MULTITHREADED

//-----------------------------------------------------------------------------
//
// Multithread support wrappers for D3D callback functions
//
//-----------------------------------------------------------------------------

//DWORD CALLBACK MtD3DContextCreate(LPD3DHAL_CONTEXTCREATEDATA pccd);
WRAPMTDXCALLBACK(D3D, D3DContextCreate, LPD3DHAL_CONTEXTCREATEDATA, pccd, 
                 pccd->lpDDLcl->lpGbl->dhpdev)

//DWORD CALLBACK MtD3DContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pcdd);
WRAPMTDXCALLBACK(D3D, D3DContextDestroy, LPD3DHAL_CONTEXTDESTROYDATA, pcdd, 
                 ((PERMEDIA_D3DCONTEXT *)ContextSlots[pcdd->dwhContext])->ppdev)

#endif  MULTITHREADED
//@@END_DDKSPLIT


//-----------------------------------------------------------------------------
// Direct3D HAL Table.
//
// This table contains all of the HAL calls that this driver supports in the 
// D3DHAL_Callbacks structure. These calls pertain to device context, scene 
// capture, execution, textures, transform, lighting, and pipeline state. 
// None of this is emulation code. The calls take the form of a return code 
// equal to: HalCall(HalCallData* lpData). All of the information in this 
// table will be implementation specific according to the specifications of 
// the hardware.
//
//-----------------------------------------------------------------------------

#define PermediaTriCaps {                                   \
    sizeof(D3DPRIMCAPS),                                    \
    D3DPMISCCAPS_CULLCCW    |        /* miscCaps */         \
    D3DPMISCCAPS_CULLCW     |                               \
    D3DPMISCCAPS_CULLNONE   |                               \
    D3DPMISCCAPS_MASKPLANES |                               \
    D3DPMISCCAPS_MASKZ,                                     \
    D3DPRASTERCAPS_DITHER    |          /* rasterCaps */    \
    D3DPRASTERCAPS_SUBPIXEL  |                              \
    D3DPRASTERCAPS_ZTEST     |                              \
    D3DPRASTERCAPS_FOGVERTEX |                              \
    D3DPRASTERCAPS_STIPPLE,                                 \
    D3DPCMPCAPS_NEVER        |                              \
    D3DPCMPCAPS_LESS         |                              \
    D3DPCMPCAPS_EQUAL        |                              \
    D3DPCMPCAPS_LESSEQUAL    |                              \
    D3DPCMPCAPS_GREATER      |                              \
    D3DPCMPCAPS_NOTEQUAL     |                              \
    D3DPCMPCAPS_GREATEREQUAL |                              \
    D3DPCMPCAPS_ALWAYS       |                              \
    D3DPCMPCAPS_LESSEQUAL,           /* zCmpCaps */         \
    D3DPBLENDCAPS_SRCALPHA |         /* sourceBlendCaps */  \
    D3DPBLENDCAPS_ONE,                                      \
    D3DPBLENDCAPS_INVSRCALPHA |      /* destBlendCaps */    \
    D3DPBLENDCAPS_ZERO        |                             \
    D3DPBLENDCAPS_ONE,                                      \
    0,                               /* alphatestCaps */    \
    D3DPSHADECAPS_COLORFLATRGB|      /* shadeCaps */        \
    D3DPSHADECAPS_COLORGOURAUDRGB |                         \
    D3DPSHADECAPS_SPECULARFLATRGB |                         \
    D3DPSHADECAPS_SPECULARGOURAUDRGB |                      \
    D3DPSHADECAPS_FOGFLAT        |                          \
    D3DPSHADECAPS_FOGGOURAUD     |                          \
    D3DPSHADECAPS_ALPHAFLATBLEND |                          \
    D3DPSHADECAPS_ALPHAFLATSTIPPLED,                        \
    D3DPTEXTURECAPS_PERSPECTIVE |   /* textureCaps */       \
    D3DPTEXTURECAPS_ALPHA       |                           \
    D3DPTEXTURECAPS_POW2        |                           \
    D3DPTEXTURECAPS_TRANSPARENCY,                           \
    D3DPTFILTERCAPS_NEAREST |       /* textureFilterCaps*/  \
    D3DPTFILTERCAPS_LINEAR,                                 \
    D3DPTBLENDCAPS_DECAL         |  /* textureBlendCaps */  \
    D3DPTBLENDCAPS_DECALALPHA    |                          \
    D3DPTBLENDCAPS_MODULATE      |                          \
    D3DPTBLENDCAPS_MODULATEALPHA |                          \
    D3DPTBLENDCAPS_COPY,                                    \
    D3DPTADDRESSCAPS_WRAP   |       /* textureAddressCaps */\
    D3DPTADDRESSCAPS_MIRROR |                               \
    D3DPTADDRESSCAPS_CLAMP  |                               \
    D3DPTADDRESSCAPS_INDEPENDENTUV,                         \
    8,                              /* stippleWidth */      \
    8                               /* stippleHeight */     \
}          

static D3DDEVICEDESC_V1 PermediaCaps = {
    sizeof(D3DDEVICEDESC_V1),                       /* dwSize */
    D3DDD_COLORMODEL           |                    /* dwFlags */
    D3DDD_DEVCAPS              |
    D3DDD_TRICAPS              |
    D3DDD_LINECAPS             |
    D3DDD_DEVICERENDERBITDEPTH |
    D3DDD_DEVICEZBUFFERBITDEPTH,
    D3DCOLOR_RGB /*| D3DCOLOR_MONO*/,              /* dcmColorModel */
    D3DDEVCAPS_FLOATTLVERTEX |                     /* devCaps */
    D3DDEVCAPS_DRAWPRIMITIVES2 |
    D3DDEVCAPS_DRAWPRIMITIVES2EX    |
#if D3DDX7_TL
    D3DDEVCAPS_HWTRANSFORMANDLIGHT  |
#endif //D3DDX7_TL
    D3DDEVCAPS_SORTINCREASINGZ  |
    D3DDEVCAPS_SORTEXACT |
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
    D3DDEVCAPS_EXECUTESYSTEMMEMORY |
    D3DDEVCAPS_TEXTUREVIDEOMEMORY,
    { sizeof(D3DTRANSFORMCAPS), 
      0 },                                         /* transformCaps */
    FALSE,                                         /* bClipping */
    { sizeof(D3DLIGHTINGCAPS), 
      0 },                                         /* lightingCaps */
    PermediaTriCaps,                               /* lineCaps */
    PermediaTriCaps,                               /* triCaps */
    DDBD_16 | DDBD_32,                             /* dwDeviceRenderBitDepth */
    DDBD_16,                                       /* Z Bit depths */
    0,                                             /* dwMaxBufferSize */
    0                                              /* dwMaxVertexCount */
};

// Alpha Stipple patterns from Foley And Van Dam

DWORD FlatStipplePatterns[128] =
{
    //Pattern 0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        
    // Pattern 1
    0x88, 0x00, 0x22, 0x00, 0x88, 0x00, 0x22, 0x00,

    // Pattern 2
    0xAA, 0x00, 0x22, 0x00, 0xAA, 0x00, 0x22, 0x00,

    // Pattern 3
    0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00,

    // Pattern 4
    0xAA, 0x44, 0xAA, 0x00, 0xAA, 0x44, 0xAA, 0x00,

    // Pattern 5
    0xAA, 0x44, 0xAA, 0x11, 0xAA, 0x44, 0xAA, 0x11,

    // Pattern 6
    0xAA, 0x55, 0xAA, 0x11, 0xAA, 0x55, 0xAA, 0x11,

    // Pattern 7
    0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,

    // Pattern 8
    0xEE, 0x55, 0xAA, 0x55, 0xEE, 0x55, 0xAA, 0x55,

    // Pattern 9
    0xEE, 0x55, 0xBB, 0x55, 0xEE, 0x55, 0xBB, 0x55,

    // Pattern 10
    0xFF, 0x55, 0xBB, 0x55, 0xFF, 0x55, 0xBB, 0x55,

    // Pattern 11
    0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55,

    // Pattern 12
    0xFF, 0xdd, 0xFF, 0x55, 0xFF, 0xdd, 0xFF, 0x55,

    // Pattern 13
    0xFF, 0xdd, 0xFF, 0x77, 0xFF, 0xdd, 0xFF, 0x77,

    // Pattern 14
    0xFF, 0xFF, 0xFF, 0x77, 0xFF, 0xFF, 0xFF, 0x77,

    // Pattern 15
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


//-----------------------------------------------------------------------------
// gD3DTextureFormats is a static structure which contains information 
// pertaining to pixel format, dimensions, bit depth, surface requirements, 
// overlays, and FOURCC codes of the supported texture formats.  These texture 
// formats will vary with the driver implementation according to the 
// capabilities of the hardware. 
//-----------------------------------------------------------------------------
DDSURFACEDESC gD3DTextureFormats [] = 
{
    // 5:5:5 RGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB,                         // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0x7c00,                           // ddpfPixelFormat.dwRBitMask
      0x03e0,                           // ddpfPixelFormat.dwGBitMask
      0x001f,                           // ddpfPixelFormat.dwBBitMask
      0                                 // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 1:5:5:5 ARGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_ALPHAPIXELS,      // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0x7c00,                           // ddpfPixelFormat.dwRBitMask
      0x03e0,                           // ddpfPixelFormat.dwGBitMask
      0x001f,                           // ddpfPixelFormat.dwBBitMask
      0x8000                            // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 5:6:5 RGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB,                         // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0xf800,                           // ddpfPixelFormat.dwRBitMask
      0x07e0,                           // ddpfPixelFormat.dwGBitMask
      0x001f,                           // ddpfPixelFormat.dwBBitMask
      0                                 // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 4:4:4:4 ARGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_ALPHAPIXELS,      // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0x0f00,                           // ddpfPixelFormat.dwRBitMask
      0x00f0,                           // ddpfPixelFormat.dwGBitMask
      0x000f,                           // ddpfPixelFormat.dwBBitMask
      0xf000                            // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 8:8:8 RGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB,                         // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      32,                               // ddpfPixelFormat.dwRGBBitCount
      0x00ff0000,                       // ddpfPixelFormat.dwRBitMask
      0x0000ff00,                       // ddpfPixelFormat.dwGBitMask
      0x000000ff,                       // ddpfPixelFormat.dwBBitMask
      0                                 // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 8:8:8:8 ARGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_ALPHAPIXELS,      // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      32,                               // ddpfPixelFormat.dwRGBBitCount
      0x00ff0000,                       // ddpfPixelFormat.dwRBitMask
      0x0000ff00,                       // ddpfPixelFormat.dwGBitMask
      0x000000ff,                       // ddpfPixelFormat.dwBBitMask
      0xff000000                        // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 4 bit palettized format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_PALETTEINDEXED4,  // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      4,                                // ddpfPixelFormat.dwRGBBitCount
      0x00,                             // ddpfPixelFormat.dwRBitMask
      0x00,                             // ddpfPixelFormat.dwGBitMask
      0x00,                             // ddpfPixelFormat.dwBBitMask
      0x00                              // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps
    },

    // 8 bit palettized format
    {
    sizeof(DDSURFACEDESC),              // dwSize
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags
    0,                                  // dwHeight
    0,                                  // dwWidth
    0,                                  // lPitch
    0,                                  // dwBackBufferCount
    0,                                  // dwZBufferBitDepth
    0,                                  // dwAlphaBitDepth
    0,                                  // dwReserved
    NULL,                               // lpSurface
    { 0, 0 },                           // ddckCKDestOverlay
    { 0, 0 },                           // ddckCKDestBlt
    { 0, 0 },                           // ddckCKSrcOverlay
    { 0, 0 },                           // ddckCKSrcBlt
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize
      DDPF_RGB | DDPF_PALETTEINDEXED8,  // ddpfPixelFormat.dwFlags
      0,                                // ddpfPixelFormat.dwFourCC
      8,                                // ddpfPixelFormat.dwRGBBitCount
      0x00,                             // ddpfPixelFormat.dwRBitMask
      0x00,                             // ddpfPixelFormat.dwGBitMask
      0x00,                             // ddpfPixelFormat.dwBBitMask
      0x00                              // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps
    },

};

ULONG gD3DNumberOfTextureFormats = 
                        sizeof(gD3DTextureFormats) / sizeof(DDSURFACEDESC);

//------------------------------------------------------------------------------
// D3D working structures for callbacks and global data
//------------------------------------------------------------------------------

// D3D callbacks and global data
D3DHAL_GLOBALDRIVERDATA gD3DGlobalDriverData;
D3DHAL_CALLBACKS        gD3DCallBacks;

// D3D contexts table
// each entry points to a valid PERMEDIA_D3DCONTEXT structure
UINT_PTR ContextSlots[MAX_CONTEXT_NUM] = {0};

// Handles table
// each entry is a DWLIST structure (*dwSurfaceList,*dwPaletteList;pDDLcl)
DWLIST  HandleList[MAX_CONTEXT_NUM] = {0}; 

//-----------------------------------------------------------------------------
//
// void D3DHALCreateDriver
//
// The main D3D Callback.  
//      Clears contexts 
//      Fills in entry points to D3D driver.  
//      Generates texture formats.
//
//-----------------------------------------------------------------------------
void CALLBACK 
D3DHALCreateDriver(PPDev ppdev, 
                   LPD3DHAL_GLOBALDRIVERDATA* lpD3DGlobalDriverData,
                   LPD3DHAL_CALLBACKS* lpD3DHALCallbacks,
                   LPDDHAL_D3DBUFCALLBACKS* lpDDExeBufCallbacks)
{
    D3DHAL_GLOBALDRIVERDATA deviceD3DGlobal;
    D3DHAL_CALLBACKS deviceD3DHALCallbacks;

    DBG_D3D((6,"Entering D3DHALCreateDriver"));

    // Contexts are cleared out. It is allright to use the D3DInitialised BOOL,
    // because it is global, and therefore forced into shared data segment by
    // the build.
    if (D3DInitialised == FALSE)
    {
        // Clear the contexts.
        memset(ContextSlots, 0, (sizeof(ContextSlots[0]) * MAX_CONTEXT_NUM) );
        memset(HandleList, 0, (sizeof(HandleList[0]) * MAX_CONTEXT_NUM) );

        D3DInitialised = TRUE;
    }

    // Here we fill in the supplied structures.
    // Can disable D3D HAL in registry if we are in the wrong mode
    if (ppdev->iBitmapFormat == BMF_8BPP )
    {
        *lpD3DGlobalDriverData = NULL;
        *lpD3DHALCallbacks = NULL;
        *lpDDExeBufCallbacks = NULL;
        DBG_D3D((0, "D3DHALCreateDriver: Disabled"));
        return;
    }


    // Set the pointers for D3D global data
    ppdev->pD3DDriverData32 = (UINT_PTR)&gD3DGlobalDriverData;
    ppdev->pD3DHALCallbacks32 = (UINT_PTR)&gD3DCallBacks;

    // Clear the global data
    memset(&deviceD3DGlobal, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    deviceD3DGlobal.dwSize = sizeof(D3DHAL_GLOBALDRIVERDATA);
    
    // Clear the call-backs
    memset(&deviceD3DHALCallbacks, 0, sizeof(D3DHAL_CALLBACKS));
    deviceD3DHALCallbacks.dwSize = sizeof(D3DHAL_CALLBACKS);

    deviceD3DGlobal.dwNumVertices = 0;        // We don't parse execute buffers
    deviceD3DGlobal.dwNumClipVertices = 0;

#if D3D_MIPMAPPING
    // Add mipmapping cap bits to our texturing capabilities
    PermediaCaps.dpcTriCaps.dwTextureFilterCaps |= 
                                D3DPTFILTERCAPS_MIPNEAREST |
                                D3DPTFILTERCAPS_MIPLINEAR |
                                D3DPTFILTERCAPS_LINEARMIPNEAREST |
                                D3DPTFILTERCAPS_LINEARMIPLINEAR;

    PermediaCaps.dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_MIPMAPLODBIAS;
#endif

    // Can do packed 24 bit on P2.
    PermediaCaps.dwDeviceRenderBitDepth |= DDBD_24;
    if (DD_P2AGPCAPABLE(ppdev))
        PermediaCaps.dwDevCaps |= D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
    PermediaCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMTLVERTEX;

    deviceD3DGlobal.hwCaps = PermediaCaps;
    deviceD3DGlobal.dwNumTextureFormats = gD3DNumberOfTextureFormats;
    deviceD3DGlobal.lpTextureFormats = &gD3DTextureFormats[0];

    // D3D Context callbacks
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    deviceD3DHALCallbacks.ContextCreate = MtD3DContextCreate;
    deviceD3DHALCallbacks.ContextDestroy = MtD3DContextDestroy;
#else
//@@END_DDKSPLIT
    deviceD3DHALCallbacks.ContextCreate = D3DContextCreate;
    deviceD3DHALCallbacks.ContextDestroy = D3DContextDestroy;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT

    //
    // Return the HAL table.
    //

    memcpy(&gD3DGlobalDriverData, &deviceD3DGlobal, sizeof(D3DHAL_GLOBALDRIVERDATA));
    memcpy(&gD3DCallBacks, &deviceD3DHALCallbacks, sizeof(D3DHAL_CALLBACKS));

    *lpD3DGlobalDriverData = &gD3DGlobalDriverData;
    *lpD3DHALCallbacks = &gD3DCallBacks;
    *lpDDExeBufCallbacks = NULL;

    DBG_D3D((6,"Exiting D3DHALCreateDriver"));

    return;
} // D3DHALCreateDriver

//-----------------------------------------------------------------------------
//
// void CleanDirect3DContext
//
// After it has been decided that a context is indeed still active
// and is being freed, this function walks along cleaning everything
// up.  Note it can be called either as a result of a D3DContextDestroy,
// or as a result of the app exiting without freeing the context, or
// as the result of an error whilst creating the context.
//
//-----------------------------------------------------------------------------
void 
CleanDirect3DContext(PERMEDIA_D3DCONTEXT* pContext, ULONG_PTR dwhContext)
{
    PERMEDIA_D3DTEXTURE* pTexture;
    DWORD dwSlotNum = 1;
    PPDev ppdev = pContext->ppdev;

    DBG_D3D((10,"Entering CleanDirect3DContext"));

    // free up Permedia register context id (resources)
    if (pContext->hPermediaContext)
    {
        P2FreeContext( ppdev, pContext->hPermediaContext);
    }

    // clean up texture manager stuff it is already allocated for this context
    if (pContext->pTextureManager)
    {
        pContext->pTextureManager = NULL;
        P2TMcount--;
        if (0 == P2TMcount)
        {
            if (0 != P2TextureManager.m_heap.m_data_p)
            {
                TextureCacheManagerEvictTextures(&P2TextureManager);
                ENGFREEMEM(P2TextureManager.m_heap.m_data_p);
                P2TextureManager.m_heap.m_data_p=NULL;
            }
        }
    }

#if D3D_STATEBLOCKS
    // Free up any remaining state sets
    __DeleteAllStateSets(pContext);
#endif //D3D_STATEBLOCKS

    // Finally, free up the rendering context structure itself
    ENGFREEMEM((PVOID)pContext->Hdr.pSelf);

    // Mark the context as now empty!
    ContextSlots[dwhContext] = 0;

    DBG_D3D((10,"Exiting CleanDirect3DContext, Context 0x%x deleted.",
                                                            dwhContext));

} // CleanDirect3DContext

//-----------------------------------------------------------------------------
//
// HRESULT InitPermediaContext
//
// Given a valid context, this sets up the rest of the chip, and
// enables the relevent units.  There is a software copy of most things.
//
//-----------------------------------------------------------------------------
HRESULT 
InitPermediaContext(PERMEDIA_D3DCONTEXT* pContext)
{
    PPDev ppdev = pContext->ppdev;

    DBG_D3D((10,"Entering InitPermediaContext"));

    SET_CURRENT_D3D_CONTEXT(pContext->hPermediaContext);

    // Initially turn off all.units
    __PermediaDisableUnits(pContext);

    // Setup initial state of Permedia 2 registers for this D3D context
    SetupDefaultsPermediaContext(pContext);

    DBG_D3D((10,"Exiting InitPermediaContext"));
    // Setup the correct surface (render & depth buffer) characteristics
    return SetupPermediaRenderTarget(pContext);

} // InitPermediaContext

//-----------------------------------------------------------------------------
//
// BOOL: SetupDefaultsPermediaContext
//
// Sets up the Permedia HW context(chip.registers) according to some D3D and
// some HW specific defaults. Done only when initializing the context
//
//-----------------------------------------------------------------------------
BOOL 
SetupDefaultsPermediaContext(PERMEDIA_D3DCONTEXT* pContext)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering SetupDefaultsPermediaContext"));

    //=========================================================================
    // Initialize our software copy of some registers for their default values 
    //=========================================================================

    // Setup the default & constant ( Z Buffer) LB settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->LBReadMode.WindowOrigin = __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN;
    pSoftPermedia->LBReadMode.DataType = __PERMEDIA_LBDEFAULT;     // default
    pSoftPermedia->LBReadMode.ReadSourceEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->LBReadMode.ReadDestinationEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->LBReadMode.PatchMode = 0;

    // Setup the default & constant FB settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->FBReadMode.ReadSourceEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->FBReadMode.ReadDestinationEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->FBReadMode.DataType = __PERMEDIA_FBDATA;
                                                    // Top Left for D3D origin
    pSoftPermedia->FBReadMode.WindowOrigin = __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN;
    pSoftPermedia->FBReadMode.PatchMode = 0;
    pSoftPermedia->FBReadMode.PackedData = 0;
    pSoftPermedia->FBReadMode.RelativeOffset = 0;

    // Setup the default & constant Alpha Blend Mode settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 0;
    pSoftPermedia->AlphaBlendMode.SourceBlend = __PERMEDIA_BLEND_FUNC_ONE;
    pSoftPermedia->AlphaBlendMode.DestinationBlend = __PERMEDIA_BLEND_FUNC_ZERO;
    pSoftPermedia->AlphaBlendMode.NoAlphaBuffer = 0;
    pSoftPermedia->AlphaBlendMode.ColorOrder = COLOR_MODE;
    pSoftPermedia->AlphaBlendMode.BlendType = 0;
    pSoftPermedia->AlphaBlendMode.ColorConversion = 1;
    pSoftPermedia->AlphaBlendMode.AlphaConversion = 1;

    // Setup the default & constant  Dither Mode settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->DitherMode.ColorOrder = COLOR_MODE;
    pSoftPermedia->DitherMode.XOffset = DITHER_XOFFSET;
    pSoftPermedia->DitherMode.YOffset = DITHER_YOFFSET;
    pSoftPermedia->DitherMode.UnitEnable = __PERMEDIA_ENABLE;
    pSoftPermedia->DitherMode.ForceAlpha = 0;

    //=========================================================================
    //  Find out info for memory widths
    //=========================================================================

    PPDev ppdev = pContext->ppdev;

    DBG_D3D((4, "ScreenWidth %d, ScreenHeight %d, Bytes/Pixel %d",
                ppdev->cxScreen, ppdev->cyScreen, 
                ppdev->ddpfDisplay.dwRGBBitCount >> 3));

    vCalcPackedPP( ppdev->cxMemory, NULL, &pContext->ulPackedPP);
    DBG_D3D((4, "PackedPP = %04x", pContext->ulPackedPP));

    //=========================================================================
    // Initialize hardware registers to their default values 
    //=========================================================================

    // Number of registers we are going to set up
    RESERVEDMAPTR(34);

    // ----------------- Render and Depth Buffer setup ----------------------

    // Setup default offset of render buffer in video memory
    SEND_PERMEDIA_DATA(FBWindowBase, 0x0);

    // Setup  offset from destination to source for copy operations
    SEND_PERMEDIA_DATA(FBSourceOffset, 0x0);

    // Render buffer Write Mode setup
    pSoftPermedia->FBWriteMode.UnitEnable = __PERMEDIA_ENABLE;
    COPY_PERMEDIA_DATA(FBWriteMode, pSoftPermedia->FBWriteMode);

    // Render buffer Write Masks (write to all bits in the pixel)
    SEND_PERMEDIA_DATA(FBSoftwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);

    // Set block fill colour to black
    SEND_PERMEDIA_DATA(FBBlockColor, 0x0);

    // Set window origin offsets to (0,0)
    SEND_PERMEDIA_DATA(WindowOrigin, 0x0);

    // WindowSetup
    pSoftPermedia->Window.ForceLBUpdate = 0;
    pSoftPermedia->Window.LBUpdateSource = 0;
    pSoftPermedia->Window.DisableLBUpdate = 0;
    COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);

    // Disable Screen Scissor unit
    SEND_PERMEDIA_DATA(ScissorMode, __PERMEDIA_DISABLE);

    // Depth Buffer offset
    SEND_PERMEDIA_DATA(LBSourceOffset, 0);

    // Depth Buffer Write mode (initially allow LB Writes)
    pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
    COPY_PERMEDIA_DATA(LBWriteMode, pSoftPermedia->LBWriteMode);

    // Depth comparisons
    pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_ENABLE;
    pSoftPermedia->DepthMode.CompareMode =
                                __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
    pSoftPermedia->DepthMode.NewDepthSource = __PERMEDIA_DEPTH_SOURCE_DDA;
    pSoftPermedia->DepthMode.UnitEnable = __PERMEDIA_DISABLE;
    COPY_PERMEDIA_DATA(DepthMode, pSoftPermedia->DepthMode);


    // ----------------- Texture units setup -----------------------------

    // Enable texture address unit, disable perspective correction
    pSoftPermedia->TextureAddressMode.Enable = 1;
    pSoftPermedia->TextureAddressMode.PerspectiveCorrection = 0;
    pSoftPermedia->TextureAddressMode.DeltaFormat = 0;
    COPY_PERMEDIA_DATA(TextureAddressMode, pSoftPermedia->TextureAddressMode);

    // Enable texture color mode unit, set modulation blending, no specular
    // as defaults
    pSoftPermedia->TextureColorMode.TextureEnable = 1;
    pSoftPermedia->TextureColorMode.ApplicationMode = _P2_TEXTURE_MODULATE;
    pSoftPermedia->TextureColorMode.TextureType = 0;
    pSoftPermedia->TextureColorMode.KdDDA = 0;
    pSoftPermedia->TextureColorMode.KsDDA = 0;
    COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);

    // Enable texture mapping unit, set frame buffer size as default texture
    // map size (to be oevrriden in EnableTexturePermedia)
    pSoftPermedia->TextureMapFormat.PackedPP = pContext->ulPackedPP;
    pSoftPermedia->TextureMapFormat.WindowOrigin =
                                __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN; //top left
    pSoftPermedia->TextureMapFormat.SubPatchMode = 0;
    pSoftPermedia->TextureMapFormat.TexelSize = 1;
    COPY_PERMEDIA_DATA(TextureMapFormat, pSoftPermedia->TextureMapFormat);

    // Setup Textura data format (to be oevrriden in EnableTexturePermedia)
    pSoftPermedia->TextureDataFormat.TextureFormat = 1;
    pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 1;
    pSoftPermedia->TextureDataFormat.ColorOrder = COLOR_MODE;
    COPY_PERMEDIA_DATA(TextureDataFormat, pSoftPermedia->TextureDataFormat);

    // Setup default texture map base address (in video memory)
    SEND_PERMEDIA_DATA(TextureBaseAddress, 0);

    // Setup texture reading defaults: Repeat s,t wrapping, 256x256 texture
    // no texture filtering set up.
    pSoftPermedia->TextureReadMode.PackedData = 0;
    pSoftPermedia->TextureReadMode.FilterMode = 0;
    pSoftPermedia->TextureReadMode.Height = 8;
    pSoftPermedia->TextureReadMode.Width = 8;
    pSoftPermedia->TextureReadMode.pad1 = 0;
    pSoftPermedia->TextureReadMode.pad2 = 0;
    pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_REPEAT;
    pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_REPEAT;
    pSoftPermedia->TextureReadMode.Enable = 1;
    COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);

    // Disable Texture LUT unit for palettized textures
    SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_DISABLE);

    // -------------- Other rendering units setup ----------------

    // Setup defaults of YUV units used for chromakey testing
    pSoftPermedia->YUVMode.Enable = __PERMEDIA_DISABLE;
    pSoftPermedia->YUVMode.TestMode = PM_YUVMODE_CHROMATEST_DISABLE;
    pSoftPermedia->YUVMode.TestData = PM_YUVMODE_TESTDATA_INPUT;
    pSoftPermedia->YUVMode.RejectTexel = FALSE;
    pSoftPermedia->YUVMode.TexelDisableUpdate = FALSE;
    COPY_PERMEDIA_DATA(YUVMode, pSoftPermedia->YUVMode);

    // Chromakey values initially black
    SEND_PERMEDIA_DATA(ChromaUpperBound, 0x00000000);
    SEND_PERMEDIA_DATA(ChromaLowerBound, 0x00000000);

    SEND_PERMEDIA_DATA(AlphaMapUpperBound, 0xFFFFFFFF);
    SEND_PERMEDIA_DATA(AlphaMapLowerBound, 0x11000000);

    // Default Fog color is white
    pSoftPermedia->FogColor = 0xFFFFFFFF;
    SEND_PERMEDIA_DATA(FogColor, pSoftPermedia->FogColor);

    // Fog setup
    pSoftPermedia->FogMode.FogEnable = 1;
    COPY_PERMEDIA_DATA(FogMode, pSoftPermedia->FogMode);

    // Stencil mode setup
    pSoftPermedia->StencilMode.DPFail = __PERMEDIA_STENCIL_METHOD_KEEP;
    pSoftPermedia->StencilMode.DPPass = __PERMEDIA_STENCIL_METHOD_KEEP;
    pSoftPermedia->StencilMode.UnitEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->StencilMode.StencilSource =
                                        __PERMEDIA_STENCIL_SOURCE_TEST_LOGIC;
    COPY_PERMEDIA_DATA(StencilMode, pSoftPermedia->StencilMode);

    // Host out unit , disable read backs
    SEND_PERMEDIA_DATA(FilterMode, __PERMEDIA_DISABLE);

    // Disable statistics unit
    SEND_PERMEDIA_DATA(StatisticMode, __PERMEDIA_DISABLE);


    // ----------------- Rasterization setup -----------------------------

    // Setup Rasterizer units defaults
    SEND_PERMEDIA_DATA(RasterizerMode, 0);

    // Setup a step of -1, as this doesn't change very much
    SEND_PERMEDIA_DATA(dY, 0xFFFF0000);

    // Setup for Gourand shaded colour model, and enable unit
    pContext->Hdr.SoftCopyP2Regs.ColorDDAMode.UnitEnable = 1;
    pContext->Hdr.SoftCopyP2Regs.ColorDDAMode.ShadeMode = 1;
    COPY_PERMEDIA_DATA(ColorDDAMode, pContext->Hdr.SoftCopyP2Regs.ColorDDAMode);

    // Disable stippling unit
    SEND_PERMEDIA_DATA(AreaStippleMode, 0x0); //AZN

    // Setup the Delta setup chip for rasterization
    pSoftPermedia->DeltaMode.TargetChip = 2;
    pSoftPermedia->DeltaMode.SpecularTextureEnable = 0;
    // The below changes to normalize in the perspective case
    // It must not be on in the non-perspective case as the bad Q's will
    // get used in the normalisation.
    pSoftPermedia->DeltaMode.TextureParameterMode = 1;
    pSoftPermedia->DeltaMode.TextureEnable = 1;
    pSoftPermedia->DeltaMode.DiffuseTextureEnable = 0;

    pSoftPermedia->DeltaMode.FogEnable = 1;
    pSoftPermedia->DeltaMode.SmoothShadingEnable = 1;
    pSoftPermedia->DeltaMode.DepthEnable = 0;
    pSoftPermedia->DeltaMode.SubPixelCorrectionEnable = 1;
    pSoftPermedia->DeltaMode.DiamondExit = 1;
    pSoftPermedia->DeltaMode.NoDraw = 0;
    pSoftPermedia->DeltaMode.ClampEnable = 0;
    pSoftPermedia->DeltaMode.FillDirection = 0;
#ifndef P2_CHIP_CULLING
    pSoftPermedia->DeltaMode.BackfaceCull = 0;
#else
    pSoftPermedia->DeltaMode.BackfaceCull = 1;
#endif
    pSoftPermedia->DeltaMode.ColorOrder = COLOR_MODE;
    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

    // Send all this data to Permedia2
    COMMITDMAPTR();
    FLUSHDMA();

    DBG_D3D((10,"Exiting SetupDefaultsPermediaContext"));

    return TRUE;
} // SetupDefaultsPermediaContext

//-----------------------------------------------------------------------------
//
// void SetupPermediaRenderTarget
//
// Sets up the correct surface characteristics (format, stride, etc) of the 
// render buffer and the depth buffer in the Permedia registers
//
//-----------------------------------------------------------------------------
HRESULT 
SetupPermediaRenderTarget(PERMEDIA_D3DCONTEXT* pContext)
{
    __P2RegsSoftwareCopy*   pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PPDev                   ppdev = pContext->ppdev;
    PPERMEDIA_D3DTEXTURE    pSurfRender,pSurfZBuffer;
    PermediaSurfaceData*    pPrivateRender;
    PERMEDIA_DEFS(pContext->ppdev);
    
    DBG_D3D((10,"Entering SetupPermediaRenderTarget"));

    pSurfRender = 
        TextureHandleToPtr(pContext->RenderSurfaceHandle, pContext);

    if (!CHECK_D3DSURFACE_VALIDITY(pSurfRender)) 
    {
        DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
            " Invalid pSurfRender handle=%08lx",
            pContext->RenderSurfaceHandle));
        return DDERR_INVALIDPARAMS;
    }

    if (DDSCAPS_SYSTEMMEMORY & pSurfRender->dwCaps)
    {
        DBG_D3D((0, "ERROR: SetupPermediaRenderTarget"
            " Render Surface in SYSTEMMEMORY handle=%08lx",
            pContext->RenderSurfaceHandle));
        return DDERR_INVALIDPARAMS;    
    }
    pPrivateRender=pSurfRender->pTextureSurface;
    if (!CHECK_P2_SURFACEDATA_VALIDITY(pPrivateRender))
    {
        DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
            " invalid pSurfRender->pTextureSurface handle=%08lx",
            pContext->RenderSurfaceHandle));
        return DDERR_INVALIDPARAMS;
    }
    if (0 != pContext->ZBufferHandle)
    {
        pSurfZBuffer = 
            TextureHandleToPtr(pContext->ZBufferHandle, pContext);

        if (!CHECK_D3DSURFACE_VALIDITY(pSurfZBuffer))
        {
            DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
                " invalid pSurfZBuffer handle=%08lx",
                pContext->ZBufferHandle));
            pContext->ZBufferHandle = 0;
        }
        else
        if (DDSCAPS_SYSTEMMEMORY & pSurfZBuffer->dwCaps)
        {
            DBG_D3D((0, "ERROR: SetupPermediaRenderTarget"
                " pSurfZBuffer in SYSTEMMEMORY  handle=%08lx",
                pContext->ZBufferHandle));
            pContext->ZBufferHandle = 0;
        }
        else
        if (!CHECK_P2_SURFACEDATA_VALIDITY(pSurfZBuffer->pTextureSurface))
        {
            DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
                " invalid pSurfZBuffer->pTextureSurface handle=%08lx",
                pContext->ZBufferHandle));
            pContext->ZBufferHandle = 0;
        }
    }

    // The default is linear surfaces...
    DBG_D3D((4,"Rendered surface Width: %d", pSurfRender->wWidth));
    pSoftPermedia->FBReadMode.PackedPP = pSurfRender->pTextureSurface->ulPackedPP;
    pContext->PixelOffset = 
        (DWORD)((UINT_PTR)pSurfRender->fpVidMem>>(pSurfRender->dwRGBBitCount>>4));

    DBG_D3D((4,"Setting FBReadMode: 0x%x",pSoftPermedia->FBReadMode));
    // Record the surface information
    RESERVEDMAPTR(10);
    // If there is a Z Buffer, then we must setup the Partial products to be
    // the same as those chosen when it was allocated.

    if (0 != pContext->ZBufferHandle)
    {
        PermediaSurfaceData* pPrivateZ = pSurfZBuffer->pTextureSurface;
        pSoftPermedia->LBReadMode.PackedPP = pPrivateZ->ulPackedPP;
        
        //actually check dwStencilBitMask 
        if (0==pPrivateZ->SurfaceFormat.BlueMask)
        {
            pSoftPermedia->LBReadFormat.DepthWidth = 0;                 // 16 bits
            pSoftPermedia->LBReadFormat.StencilWidth = 0;               // No Stencil
            pSoftPermedia->DeltaMode.DepthFormat = 1;   //PM_DELTAMODE_DEPTHWIDTH_16
        }
        else
        {
            pSoftPermedia->LBReadFormat.DepthWidth = 3;                 // 15 bits
            pSoftPermedia->LBReadFormat.StencilWidth = 3;               // 1 Stencil
            pSoftPermedia->DeltaMode.DepthFormat = 0;   //PM_DELTAMODE_DEPTHWIDTH_15
        }

        SEND_PERMEDIA_DATA(LBWindowBase, 
            (DWORD)((UINT_PTR)pSurfZBuffer->fpVidMem>>P2DEPTH16));
        COPY_PERMEDIA_DATA(LBReadFormat, pSoftPermedia->LBReadFormat);
        COPY_PERMEDIA_DATA(LBWriteFormat, pSoftPermedia->LBReadFormat);

        DBG_D3D((4,"Setting LBReadMode: 0x%x",pSoftPermedia->LBReadMode));
    }
    else
    {   // No Z Buffer, just stuff the same Partial products as the desktop.
        pSoftPermedia->LBReadMode.PackedPP = pContext->ulPackedPP;
    }

    COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
    COPY_PERMEDIA_DATA(LBReadMode, pSoftPermedia->LBReadMode);

    // Set up the screen dimensions to be the same size as the surface.
    SEND_PERMEDIA_DATA(ScreenSize, 
        (pSurfRender->wWidth & 0xFFFF) | (pSurfRender->wHeight << 16));

    // DitherMode and AlphaBlendMode both depend on the surface pixel format
    // being correct.
    pSoftPermedia->DitherMode.ColorFormat =
    pSoftPermedia->AlphaBlendMode.ColorFormat=
        pPrivateRender->SurfaceFormat.Format;
    pSoftPermedia->DitherMode.ColorFormatExtension = 
    pSoftPermedia->AlphaBlendMode.ColorFormatExtension =
        pPrivateRender->SurfaceFormat.FormatExtension;
    pSoftPermedia->FBReadPixel = pPrivateRender->SurfaceFormat.FBReadPixel;
    SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
    SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
    COPY_PERMEDIA_DATA(AlphaBlendMode, pSoftPermedia->AlphaBlendMode);
    COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting SetupPermediaRenderTarget"));
    return DD_OK;

} // SetupPermediaRenderTarget


//=============================================================================
//
// In the new DX7 DDI we don't have the Texture Create/Destroy/Swap calls
// anymore, so now we need a mechanism for generating texture handles. This
// is done by the runtime, which will associate a surface handle for each 
// surface created with the DD local object, and will get our D3DCreateSurfaceEx
// callback called. 
//
// Since this creation can very well happen before we create a D3D context, we
// need to keep track of this association, and when we do get called to create
// a D3D context, we will now be given the relevant DD local object pointer to
// resolve which handles are ours (and to which private texture structures we
// need to use).
//
// This mechanism is also used to associate a palette to a texture
//
//=============================================================================

//-----------------------------------------------------------------------------
//
// BOOL SetTextureSlot
//
// In the handle list element corresponding to this local DD object, store or
// update the pointer to the pTexture associated to the surface handle 
// from the lpDDSLcl surface.
//
//-----------------------------------------------------------------------------
BOOL
SetTextureSlot(LPVOID pDDLcl,
               LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl,
               PPERMEDIA_D3DTEXTURE pTexture)
{
    int   i,j= -1;
    DWORD dwSurfaceHandle;

    DBG_D3D((10,"Entering SetTextureSlot"));

    ASSERTDD(NULL != pDDLcl && NULL != lpDDSLcl && NULL != pTexture,
                                    "SetTextureSlot invalid input");
    dwSurfaceHandle = lpDDSLcl->lpSurfMore->dwSurfaceHandle;

    // Find the handle list element associated with the local DD object,
    // if there's none then select an empty one to be used
    for (i = 0; i < MAX_CONTEXT_NUM;i++)
    {
        if (pDDLcl == HandleList[i].pDDLcl)
        {
            break;  // found the right slot
        }
        else
        if (0 == HandleList[i].pDDLcl && -1 == j)
        {
            j=i;    // first empty slot !
        }
    }

    // If we overrun the existing handle list elements, we need to
    // initialize an existing empty slot or return an error.
    if (i >= MAX_CONTEXT_NUM)
    {
        if (-1 != j)
        {
            //has an empty slot for this process, so use it
            i = j;  
            HandleList[j].pDDLcl = pDDLcl;
            ASSERTDD(NULL == HandleList[j].dwSurfaceList,"in SetTextureSlot");
        }
        else
        {
            //all process slots has been used, fail
            DBG_D3D((0,"SetTextureSlot failed with pDDLcl=%x "
                       "dwSurfaceHandle=%08lx pTexture=%x",
                       pDDLcl,dwSurfaceHandle,pTexture));
            return false;
        }
    }

    ASSERTDD(i < MAX_CONTEXT_NUM, "in SetTextureSlot");

    if ( NULL == HandleList[i].dwSurfaceList ||
        dwSurfaceHandle >= PtrToUlong(HandleList[i].dwSurfaceList[0]))
    {
        // dwSurfaceHandle numbers are going to be ordinal numbers starting
        // at one, so we use this number to figure out a "good" size for
        // our new list.
        DWORD newsize = ((dwSurfaceHandle + LISTGROWSIZE) / LISTGROWSIZE)
                                                              * LISTGROWSIZE;
        PPERMEDIA_D3DTEXTURE *newlist= (PPERMEDIA_D3DTEXTURE *)
            ENGALLOCMEM( FL_ZERO_MEMORY,
                         sizeof(PPERMEDIA_D3DTEXTURE)*newsize,
                         ALLOC_TAG);
        DBG_D3D((4,"Growing pDDLcl=%x's SurfaceList[%x] size to %08lx",
                   pDDLcl,newlist,newsize));

        if (NULL == newlist)
        {
            DBG_D3D((0,"SetTextureSlot failed to increase "
                       "HandleList[%d].dwSurfaceList",i));
            return false;
        }

        memset(newlist,0,newsize);

        // we had a formerly valid surfacehandle list, so we now must 
        // copy it over and free the memory allocated for it
        if (NULL != HandleList[i].dwSurfaceList)
        {
            memcpy(newlist,HandleList[i].dwSurfaceList,
                PtrToUlong(HandleList[i].dwSurfaceList[0]) * 
                sizeof(PPERMEDIA_D3DTEXTURE));
            ENGFREEMEM(HandleList[i].dwSurfaceList);
            DBG_D3D((4,"Freeing pDDLcl=%x's old SurfaceList[%x]",
                       pDDLcl,HandleList[i].dwSurfaceList));
        }

        HandleList[i].dwSurfaceList = newlist;
         //store size in dwSurfaceList[0]
        *(DWORD*)HandleList[i].dwSurfaceList = newsize;
    }

    // Store a pointer to the pTexture associated to this surface handle
    HandleList[i].dwSurfaceList[dwSurfaceHandle] = pTexture;
    pTexture->HandleListIndex = i; //store index here to facilitate search
    DBG_D3D((4,"Set pDDLcl=%x Handle=%08lx pTexture = %x",
                pDDLcl, dwSurfaceHandle, pTexture));

    DBG_D3D((10,"Exiting SetTextureSlot"));

    return true;
} // SetTextureSlot

//-----------------------------------------------------------------------------
//
// PPERMEDIA_D3DTEXTURE GetTextureSlot
//
// Find the pointer to the PPERMEDIA_D3DTEXTURE associated to the 
// dwSurfaceHandle corresponding to the given local DD object
//
//-----------------------------------------------------------------------------
PPERMEDIA_D3DTEXTURE
GetTextureSlot(LPVOID pDDLcl, DWORD dwSurfaceHandle)
{
    DBG_D3D((10,"Entering GetTextureSlot"));

    DWORD   i;
    for (i = 0; i < MAX_CONTEXT_NUM; i++)
    {
        if (HandleList[i].pDDLcl == pDDLcl)
        {
            if (HandleList[i].dwSurfaceList &&
                PtrToUlong(HandleList[i].dwSurfaceList[0]) > dwSurfaceHandle )
            {
                return  HandleList[i].dwSurfaceList[dwSurfaceHandle];
            }
            else
                break;
        }
    }
    DBG_D3D((10,"Exiting GetTextureSlot"));

    return NULL;    //Not found
} // GetTextureSlot

//-----------------------------------------------------------------------------
//
// LPDWLIST GetSurfaceHandleList
//
// Get the handle list which is associated to a specific PDD_DIRECTDRAW_LOCAL
// pDDLcl. It is called from D3DContextCreate to get the handle list associated
// to the pDDLcl with which the context is being created.
//
//-----------------------------------------------------------------------------
LPDWLIST 
GetSurfaceHandleList(LPVOID pDDLcl)
{
    DWORD   i;

    DBG_D3D((10,"Entering GetSurfaceHandleList"));

    ASSERTDD(NULL != pDDLcl, "GetSurfaceHandleList get NULL==pDDLcl"); 
    for (i = 0; i < MAX_CONTEXT_NUM;i++)
    {
        if (HandleList[i].pDDLcl == pDDLcl)
        {
            DBG_D3D((4,"Getting pHandleList=%08lx for pDDLcl %x",
                &HandleList[i],pDDLcl));
            return &HandleList[i];
        }
    }

    DBG_D3D((10,"Exiting GetSurfaceHandleList"));

    return NULL;   //No surface handle available yet
} // GetSurfaceHandleList

//-----------------------------------------------------------------------------
//
// void ReleaseSurfaceHandleList
//
// Free all the associated surface handle and palette memory pools associated
// to a given DD local object.
//
//-----------------------------------------------------------------------------
void 
ReleaseSurfaceHandleList(LPVOID pDDLcl)
{
    DWORD   i;

    DBG_D3D((10,"Entering ReleaseSurfaceHandleList"));

    ASSERTDD(NULL != pDDLcl, "ReleaseSurfaceHandleList get NULL==pDDLcl"); 
    for (i = 0; i < MAX_CONTEXT_NUM; i++)
    {
        if (HandleList[i].pDDLcl == pDDLcl)
        {
            DWORD j;

            if (NULL != HandleList[i].dwSurfaceList)
            {
                DBG_D3D((4,"Releasing HandleList[%d].dwSurfaceList[%x] "
                           "for pDDLcl %x", i, HandleList[i].dwSurfaceList,
                           pDDLcl));

                for (j = 1; j < PtrToUlong(HandleList[i].dwSurfaceList[0]); j++)
                {
                    PERMEDIA_D3DTEXTURE* pTexture = 
                        (PERMEDIA_D3DTEXTURE*)HandleList[i].dwSurfaceList[j];
                    if (NULL != pTexture)
                    {
                        PermediaSurfaceData *pPrivateData=
                            pTexture->pTextureSurface;
                        if (CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData) &&
                            (pPrivateData->fpVidMem))
                        {
                            TextureCacheManagerRemove(&P2TextureManager,
                                pTexture);
                        }
                        ENGFREEMEM(pTexture);
                    }
                }

                ENGFREEMEM(HandleList[i].dwSurfaceList);
                HandleList[i].dwSurfaceList = NULL;
            }

            HandleList[i].pDDLcl = NULL;

            if (NULL != HandleList[i].dwPaletteList)
            {
                DBG_D3D((4,"Releasing dwPaletteList %x for pDDLcl %x",
                    HandleList[i].dwPaletteList,pDDLcl));

                for (j = 1; j < PtrToUlong(HandleList[i].dwPaletteList[0]); j++)
                {
                    LPVOID pPalette = (LPVOID)HandleList[i].dwPaletteList[j];
                    if (NULL != pPalette)
                        ENGFREEMEM(pPalette);
                }

                ENGFREEMEM(HandleList[i].dwPaletteList);
                HandleList[i].dwPaletteList = NULL;
            }

            break;
        }
    }

    DBG_D3D((10,"Exiting ReleaseSurfaceHandleList"));
} // ReleaseSurfaceHandleList

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DGetDriverState
//
// This callback is used by both the DirectDraw and Direct3D runtimes to obtain
// information from the driver about its current state.
//
// Parameters
//
//     lpgdsd   
//           pointer to GetDriverState data structure
//
//           dwFlags
//                   Flags to indicate the data required
//           dwhContext
//                   The ID of the context for which information 
//                   is being requested
//           lpdwStates
//                   Pointer to the state data to be filled in by the driver
//           dwLength
//                   Length of the state data buffer to be filled 
//                   in by the driver
//           ddRVal
//                   Return value
//
// Return Value
//
//      DDHAL_DRIVER_HANDLED
//      DDHAL_DRIVER_NOTHANDLED
//-----------------------------------------------------------------------------
DWORD CALLBACK  
D3DGetDriverState( LPDDHAL_GETDRIVERSTATEDATA lpgdsd )
{
    PERMEDIA_D3DCONTEXT *pContext;
    DBG_D3D((6,"Entering D3DGetDriverState"));
    if (lpgdsd->dwFlags != D3DDEVINFOID_TEXTUREMANAGER)
    {
        DBG_D3D((0,"D3DGetDriverState DEVICEINFOID=%08lx not supported",
            lpgdsd->dwFlags));
        return DDHAL_DRIVER_NOTHANDLED;
    }
    if (lpgdsd->dwLength < sizeof(D3DDEVINFO_TEXTUREMANAGER))
    {
        DBG_D3D((0,"D3DGetDriverState dwLength=%d is not sufficient",
            lpgdsd->dwLength));
        return DDHAL_DRIVER_NOTHANDLED;
    }
    pContext = (PERMEDIA_D3DCONTEXT *)ContextSlots[lpgdsd->dwhContext] ;
    // Check if we got a valid context handle.
    CHK_CONTEXT(pContext, lpgdsd->ddRVal, "D3DGetDriverState");

    TextureCacheManagerGetStats(pContext,
           (LPD3DDEVINFO_TEXTUREMANAGER)lpgdsd->lpdwStates);

    lpgdsd->ddRVal = DD_OK;

    DBG_D3D((6,"Exiitng D3DGetDriverState"));

    return DDHAL_DRIVER_HANDLED;
} // D3DGetDriverState

//-----------------------------------------------------------------------------
//
//  __CreateSurfaceHandle
//
//  allocate a new surface handle
//
//  return value
//
//      DD_OK   -- no error
//      DDERR_OUTOFMEMORY -- allocation of texture handle failed
//
//-----------------------------------------------------------------------------

DWORD __CreateSurfaceHandle( PPDev ppdev,
                             LPVOID pDDLcl,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl)
{
    PPERMEDIA_D3DTEXTURE pTexture;

    DUMPSURFACE(10, lpDDSLcl, NULL);

    if (0 == lpDDSLcl->lpSurfMore->dwSurfaceHandle)
    {
        DBG_D3D((0,"D3DCreateSurfaceEx got 0 surfacehandle dwCaps=%08lx",
            lpDDSLcl->ddsCaps.dwCaps));
        return DD_OK;
    }

    pTexture = 
        GetTextureSlot(pDDLcl,lpDDSLcl->lpSurfMore->dwSurfaceHandle);

    if ((0 == lpDDSLcl->lpGbl->fpVidMem) && 
        (DDSCAPS_SYSTEMMEMORY & lpDDSLcl->ddsCaps.dwCaps))
    {
        // this is a system memory destroy notification
        // so go ahead free the slot for this surface if we have it
        if (NULL != pTexture)
        {
            ASSERTDD(HandleList[pTexture->HandleListIndex].dwSurfaceList
                [lpDDSLcl->lpSurfMore->dwSurfaceHandle] == pTexture,
                "__CreateSurfaceHandle: mismatching pTexture in HandleList");
            HandleList[pTexture->HandleListIndex].dwSurfaceList
                [lpDDSLcl->lpSurfMore->dwSurfaceHandle]=0;
            ENGFREEMEM(pTexture);
            DBG_D3D((8,"D3DCreateSurfaceEx freeing handle=%08lx dwCaps=%08lx",
            lpDDSLcl->lpSurfMore->dwSurfaceHandle,lpDDSLcl->ddsCaps.dwCaps));
        }
        return DD_OK;
    }
    if (NULL == pTexture)
    {
        pTexture =
            (PERMEDIA_D3DTEXTURE*)ENGALLOCMEM( FL_ZERO_MEMORY,
                                               sizeof(PERMEDIA_D3DTEXTURE),
                                               ALLOC_TAG);

        if (NULL != pTexture) 
        {
            if (!SetTextureSlot(pDDLcl,lpDDSLcl,pTexture))
            {
                // Free texture structure since we won't be able to remember it
                // in order to later delete it. We must do it now.
                ENGFREEMEM(pTexture);
                return DDERR_OUTOFMEMORY;
            }
        }
        else
        {
            DBG_D3D((0,"ERROR: Couldn't allocate Texture data mem"));
            return DDERR_OUTOFMEMORY;
        } 
    }

    lpDDSLcl->dwReserved1=pTexture->HandleListIndex;    
    __InitD3DTextureWithDDSurfInfo(pTexture,lpDDSLcl,ppdev);

    if (pTexture->dwCaps & DDSCAPS_TEXTURE)
    {
        for (int i = 1; i < MAX_CONTEXT_NUM; i++)
        {
            PERMEDIA_D3DCONTEXT *pContext =
                                     (PERMEDIA_D3DCONTEXT *)ContextSlots[i];
            if (IS_D3DCONTEXT_VALID(pContext))
            {
                DBG_D3D((4,"   Context 0x%x, Pointer 0x%x",
                                                (DWORD)i, pContext));
                if ((pContext->pDDLcl == pDDLcl)
                    && (pContext->CurrentTextureHandle == 
                        lpDDSLcl->lpSurfMore->dwSurfaceHandle) 
                   )
                {
                    // If the texture being swapped is 
                    // currently being used then we need 
                    // to change the chip setup to reflect this.
                    DIRTY_TEXTURE;
                }
            }
        }
    }

    return DD_OK;
}


//-----------------------------------------------------------------------------
//
//  __CreateSurfaceHandleLoop
//
//  allocate a list of new surface handles by traversing AttachList
//      recursively and calling __CreateSurfaceHandle()
//      only exceptions are for MIPMAP and CUBMAP, which we only
//      use one handle to the root to represent the whole surface
//  return value
//
//      DD_OK   -- no error
//      DDERR_OUTOFMEMORY -- allocation of texture handle failed
//
//-----------------------------------------------------------------------------

DWORD __CreateSurfaceHandleLoop( PPDev ppdev,
                             LPVOID pDDLcl,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSLclroot,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl)
{
    LPATTACHLIST    curr;
    DWORD ddRVal=DD_OK;
    // Now allocate the texture data space
    if (0 == lpDDSLcl->lpSurfMore->dwSurfaceHandle)
    {
        DBG_D3D((0,"__CreateSurfaceHandleLoop got 0 handle dwCaps=%08lx",
            lpDDSLcl->ddsCaps.dwCaps));
        return DD_OK;
    }

    if ((0 == lpDDSLcl->lpGbl->dwReserved1) && 
        (DDSCAPS_VIDEOMEMORY & lpDDSLcl->ddsCaps.dwCaps)
        )
    {
        DBG_D3D((4,"__CreateSurfaceHandleLoop got "
            "handle=%08lx dwCaps=%08lx not yet created",
            lpDDSLcl->lpSurfMore->dwSurfaceHandle,lpDDSLcl->ddsCaps.dwCaps));
        return DD_OK;
    }

    DBG_D3D((4,"** In __CreateSurfaceHandleLoop %08lx %08lx %08lx %08lx %x",
        lpDDSLcl->ddsCaps.dwCaps,lpDDSLcl->lpSurfMore->dwSurfaceHandle,
        lpDDSLcl->dwFlags,lpDDSLcl->lpGbl->dwReserved1,
        lpDDSLcl->lpGbl->fpVidMem));

    ddRVal=__CreateSurfaceHandle( ppdev, pDDLcl, lpDDSLcl);
    if (DD_OK != ddRVal)
    {
        return ddRVal;
    }

    // for some surfaces other than MIPMAP or CUBEMAP, such as
    // flipping chains, we make a slot for every surface, as
    // they are not as interleaved
    if ((lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) ||
        (lpDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
       )
    {
        return DD_OK;
    }
    curr = lpDDSLcl->lpAttachList;
    if (NULL == curr) 
        return DD_OK;

    // check if there is another surface attached!
    if (curr->lpLink)
    {
        lpDDSLcl=curr->lpLink->lpAttached; 
        if (NULL != lpDDSLcl && lpDDSLcl != lpDDSLclroot)
        {
            ddRVal=__CreateSurfaceHandleLoop( ppdev, pDDLcl, 
                 lpDDSLclroot, lpDDSLcl);
            if (DD_OK != ddRVal)
            {
                return ddRVal;
            }
        }
    }
    lpDDSLcl=curr->lpAttached;
    if (NULL != lpDDSLcl && lpDDSLcl != lpDDSLclroot)
        ddRVal=__CreateSurfaceHandleLoop( ppdev, pDDLcl, 
            lpDDSLclroot, lpDDSLcl);
    return ddRVal;
}
//-----------------------------Public Routine----------------------------------
//
// DWORD D3DCreateSurfaceEx
//
// D3dCreateSurfaceEx creates a Direct3D surface from a DirectDraw surface and 
// associates a requested handle value to it.
//
// All Direct3D drivers must support D3dCreateSurfaceEx.
//
// D3dCreateSurfaceEx creates an association between a DirectDraw surface and 
// a small integer surface handle. By creating these associations between a
// handle and a DirectDraw surface, D3dCreateSurfaceEx allows a surface handle
// to be imbedded in the Direct3D command stream. For example when the
// D3DDP2OP_TEXBLT command token is sent to D3dDrawPrimitives2 to load a texture
// map, it uses a source handle and destination handle which were associated
//  with a DirectDraw surface through D3dCreateSurfaceEx.
//
// For every DirectDraw surface created under the local DirectDraw object, the
// runtime generates a valid handle that uniquely identifies the surface and
// places it in pcsxd->lpDDSLcl->lpSurfMore->dwSurfaceHandle. This handle value
// is also used with the D3DRENDERSTATE_TEXTUREHANDLE render state to enable
// texturing, and with the D3DDP2OP_SETRENDERTARGET and D3DDP2OP_CLEAR commands
// to set and/or clear new rendering and depth buffers. The driver should fail
// the call and return DDHAL_DRIVER_HANDLE if it cannot create the Direct3D
// surface. 
//
// As appropriate, the driver should also store any surface-related information
// that it will subsequently need when using the surface. The driver must create
// a new surface table for each new lpDDLcl and implicitly grow the table when
// necessary to accommodate more surfaces. Typically this is done with an
// exponential growth algorithm so that you don't have to grow the table too
// often. Direct3D calls D3dCreateSurfaceEx after the surface is created by
// DirectDraw by request of the Direct3D runtime or the application.
//
// Parameters
//
//      lpcsxd
//           pointer to CreateSurfaceEx structure that contains the information
//           required for the driver to create the surface (described below). 
//
//           dwFlags
//                   Currently unused
//           lpDDLcl
//                   Handle to the DirectDraw object created by the application.
//                   This is the scope within which the lpDDSLcl handles exist.
//                   A DD_DIRECTDRAW_LOCAL structure describes the driver.
//           lpDDSLcl
//                   Handle to the DirectDraw surface we are being asked to
//                   create for Direct3D. These handles are unique within each
//                   different DD_DIRECTDRAW_LOCAL. A DD_SURFACE_LOCAL structure
//                   represents the created surface object.
//           ddRVal
//                   Specifies the location in which the driver writes the return
//                   value of the D3dCreateSurfaceEx callback. A return code of
//                   DD_OK indicates success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLE
//      DDHAL_DRIVER_NOTHANDLE
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DCreateSurfaceEx( LPDDHAL_CREATESURFACEEXDATA lpcsxd )
{
    PPERMEDIA_D3DTEXTURE pTexture;
    LPVOID pDDLcl= (LPVOID)lpcsxd->lpDDLcl;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSLcl=lpcsxd->lpDDSLcl;
    LPATTACHLIST    curr;

    DBG_D3D((6,"Entering D3DCreateSurfaceEx"));

    lpcsxd->ddRVal = DD_OK;

    if (NULL == lpDDSLcl || NULL == pDDLcl)
    {
        DBG_D3D((0,"D3DCreateSurfaceEx received 0 lpDDLcl or lpDDSLcl pointer"));
        return DDHAL_DRIVER_HANDLED;
    }


    // We check that what we are handling is a texture, zbuffer or a rendering
    // target buffer. We don't check if it is however stored in local video
    // memory since it might also be a system memory texture that we will later
    // blt with __TextureBlt.
    // also if your driver supports DDSCAPS_EXECUTEBUFFER create itself, it must 
    // process DDSCAPS_EXECUTEBUFFER here as well.
    if (!(lpDDSLcl->ddsCaps.dwCaps & 
             (DDSCAPS_TEXTURE       | 
              DDSCAPS_3DDEVICE      | 
              DDSCAPS_ZBUFFER))
       )
    {
        DBG_D3D((2,"D3DCreateSurfaceEx w/o "
             "DDSCAPS_TEXTURE/3DDEVICE/ZBUFFER Ignored"
             "dwCaps=%08lx dwSurfaceHandle=%08lx",
             lpDDSLcl->ddsCaps.dwCaps,
             lpDDSLcl->lpSurfMore->dwSurfaceHandle));
        return DDHAL_DRIVER_HANDLED;
    }

    DBG_D3D((4,"Entering D3DCreateSurfaceEx handle=%08lx",
        lpDDSLcl->lpSurfMore->dwSurfaceHandle));
    PPDev ppdev=(PPDev)lpcsxd->lpDDLcl->lpGbl->dhpdev;
    PERMEDIA_DEFS(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_D3D((MT_LOG_LEVEL, "D3DCreateSurfaceEx: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    // Now allocate the texture data space
    lpcsxd->ddRVal = __CreateSurfaceHandleLoop( ppdev, pDDLcl, lpDDSLcl, lpDDSLcl);
    DBG_D3D((4,"Exiting D3DCreateSurfaceEx"));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return DDHAL_DRIVER_HANDLED;
} // D3DCreateSurfaceEx

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DDestroyDDLocal
//
// D3dDestroyDDLocal destroys all the Direct3D surfaces previously created by
// D3DCreateSurfaceEx that belong to the same given local DirectDraw object.
//
// All Direct3D drivers must support D3dDestroyDDLocal.
// Direct3D calls D3dDestroyDDLocal when the application indicates that the
// Direct3D context is no longer required and it will be destroyed along with
// all surfaces associated to it. The association comes through the pointer to
// the local DirectDraw object. The driver must free any memory that the
// driver's D3dCreateSurfaceExDDK_D3dCreateSurfaceEx_GG callback allocated for
// each surface if necessary. The driver should not destroy the DirectDraw
// surfaces associated with these Direct3D surfaces; this is the application's
// responsibility.
//
// Parameters
//
//      lpdddd
//            Pointer to the DestoryLocalDD structure that contains the
//            information required for the driver to destroy the surfaces.
//
//            dwFlags
//                  Currently unused
//            pDDLcl
//                  Pointer to the local Direct Draw object which serves as a
//                  reference for all the D3D surfaces that have to be destroyed.
//            ddRVal
//                  Specifies the location in which the driver writes the return
//                  value of D3dDestroyDDLocal. A return code of DD_OK indicates
//                   success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLED
//      DDHAL_DRIVER_NOTHANDLED
//-----------------------------------------------------------------------------
DWORD CALLBACK  
D3DDestroyDDLocal( LPDDHAL_DESTROYDDLOCALDATA lpdddd )
{
    DBG_D3D((6,"Entering D3DDestroyDDLocal"));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    PPDev ppdev=(PPDev)lpdddd->pDDLcl->lpGbl->dhpdev;
    
    if(ppdev->ulLockCount)
    {
         DBG_D3D((MT_LOG_LEVEL, "D3DCreateSurfaceEx: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    ReleaseSurfaceHandleList(LPVOID(lpdddd->pDDLcl));
    lpdddd->ddRVal = DD_OK;

    DBG_D3D((6,"Exiting D3DDestroyDDLocal"));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return DDHAL_DRIVER_HANDLED;
} // D3DDestroyDDLocal

//-----------------------------Public Routine----------------------------------
//
//  DdSetColorkey
//
//  DirectDraw SetColorkey callback
//
//  Parameters
//       lpSetColorKey
//             Pointer to the LPDDHAL_SETCOLORKEYDATA parameters structure 
//
//             lpDDSurface
//                  Surface struct
//             dwFlags
//                  Flags
//             ckNew
//                  New chroma key color values
//             ddRVal
//                  Return value
//             SetColorKey
//                  Unused: Win95 compatibility
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSetColorKey(LPDDHAL_SETCOLORKEYDATA lpSetColorKey)
{
    DWORD dwSurfaceHandle =
                        lpSetColorKey->lpDDSurface->lpSurfMore->dwSurfaceHandle;
    DWORD index = (DWORD)lpSetColorKey->lpDDSurface->dwReserved1;

    DBG_D3D((6,"Entering DdSetColorKey dwSurfaceHandle=%d index=%d",
        dwSurfaceHandle, index));

    lpSetColorKey->ddRVal = DD_OK;
    // We don't have to do anything for normal blt source colour keys:
    if (!(DDSCAPS_TEXTURE & lpSetColorKey->lpDDSurface->ddsCaps.dwCaps) ||
        !(DDSCAPS_VIDEOMEMORY & lpSetColorKey->lpDDSurface->ddsCaps.dwCaps) 
       )
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    if (0 != dwSurfaceHandle && NULL != HandleList[index].dwSurfaceList)
    {
        PERMEDIA_D3DTEXTURE *pTexture =
                                HandleList[index].dwSurfaceList[dwSurfaceHandle];

        ASSERTDD(PtrToUlong(HandleList[index].dwSurfaceList[0]) > dwSurfaceHandle,
            "SetColorKey: incorrect dwSurfaceHandle");

        if (NULL != pTexture)
        {
            DBG_D3D((4, "DdSetColorKey surface=%08lx KeyLow=%08lx",
                dwSurfaceHandle,pTexture->dwKeyLow));
            pTexture->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
            pTexture->dwKeyLow = lpSetColorKey->ckNew.dwColorSpaceLowValue;
            pTexture->dwKeyHigh = lpSetColorKey->ckNew.dwColorSpaceHighValue;
        }
    }
    else
    {
        lpSetColorKey->ddRVal = DDERR_INVALIDPARAMS;
    }
    DBG_D3D((6,"Exiting DdSetColorKey"));

    return DDHAL_DRIVER_HANDLED;
}   // DdSetColorKey


//@@BEGIN_DDKSPLIT
#if MULTITHREADED

//-----------------------------------------------------------------------------
//
// Multithread support wrappers for D3D callback functions
//
//-----------------------------------------------------------------------------

//DWORD CALLBACK MtD3DDrawPrimitives2(LPD3DNTHAL_DRAWPRIMITIVES2DATA pdp2);, 
WRAPMTDXCALLBACK(D3D, D3DDrawPrimitives2, LPD3DNTHAL_DRAWPRIMITIVES2DATA, pdp2, 
                 ((PERMEDIA_D3DCONTEXT *)ContextSlots[pdp2->dwhContext])->ppdev)

//DWORD CALLBACK MtDdSetColorKey(LPDDHAL_SETCOLORKEYDATA lpSetColorKey);
WRAPMTDXCALLBACK(D3D, DdSetColorKey, LPDDHAL_SETCOLORKEYDATA, lpSetColorKey,
                 lpSetColorKey->lpDD->dhpdev);

#endif  MULTITHREADED

//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dcntxt.h ===
/******************************Module*Header*********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dcntxt.h
*
*  Content: D3D Context management related definitions and macros
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifdef __DCONTEXT
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __DCONTEXT

#ifndef __SOFTCOPY
#include "d3dsoft.h"
#endif

#ifndef __TEXTURES
#include "d3dtext.h"
#endif

//-----------------------------------------------------------------------------
//                       Context indexing structure
//-----------------------------------------------------------------------------
#define MAX_CONTEXT_NUM 200
extern  UINT_PTR ContextSlots[];

//-----------------------------------------------------------------------------
//                       Context validation macros
//-----------------------------------------------------------------------------
#define RC_MAGIC_DISABLE 0xd3d00000
#define RC_MAGIC_NO 0xd3d00100

#define IS_D3DCONTEXT_VALID(ptr)          \
    ( ((ptr) != NULL) && ((ptr)->Hdr.MagicNo == RC_MAGIC_NO) )

#define CHK_CONTEXT(pCtxt, retVar, funcname)             \
    if (!IS_D3DCONTEXT_VALID(pCtxt)) {                   \
        retVar = D3DHAL_CONTEXT_BAD;                     \
        DBG_D3D((0,"Context not valid in %s",funcname)); \
        return (DDHAL_DRIVER_HANDLED);                   \
    }

// Defines for the dwDirtyFlags field of our context
#define CONTEXT_DIRTY_ALPHABLEND          2
#define CONTEXT_DIRTY_ZBUFFER             4
#define CONTEXT_DIRTY_TEXTURE             8
#define CONTEXT_DIRTY_MULTITEXTURE       16

#define DIRTY_ALPHABLEND     pContext->dwDirtyFlags |= CONTEXT_DIRTY_ALPHABLEND;
#define DIRTY_TEXTURE        pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;
#define DIRTY_ZBUFFER        pContext->dwDirtyFlags |= CONTEXT_DIRTY_ZBUFFER;
#define DIRTY_MULTITEXTURE   pContext->dwDirtyFlags |= CONTEXT_DIRTY_MULTITEXTURE;


//-----------------------------------------------------------------------------
//                    Context rendering state tracking
//-----------------------------------------------------------------------------
// Flags to keep track of various rendering states or conditions in a D3D context
// these are tracked in the Hdr.Flags field
#define CTXT_HAS_GOURAUD_ENABLED      (1 << 0)
#define CTXT_HAS_ZBUFFER_ENABLED      (1 << 1)
#define CTXT_HAS_SPECULAR_ENABLED     (1 << 2)
#define CTXT_HAS_FOGGING_ENABLED      (1 << 3)
#define CTXT_HAS_PERSPECTIVE_ENABLED  (1 << 4)
#define CTXT_HAS_TEXTURE_ENABLED      (1 << 5)
#define CTXT_HAS_ALPHABLEND_ENABLED   (1 << 6)
#define CTXT_HAS_MONO_ENABLED         (1 << 7)
#define CTXT_HAS_WRAPU_ENABLED        (1 << 8)
#define CTXT_HAS_WRAPV_ENABLED        (1 << 9)
    // Use the alpha value to calculate a stipple pattern
#define CTXT_HAS_ALPHASTIPPLE_ENABLED (1 << 10)
#define CTXT_HAS_ZWRITE_ENABLED       (1 << 11)
    // Enable last point on lines
#define CTXT_HAS_LASTPIXEL_ENABLED    (1 << 12)

#if D3D_STATEBLOCKS
//-----------------------------------------------------------------------------
//                     State sets structure definitions
//-----------------------------------------------------------------------------
#define FLAG DWORD
#define FLAG_SIZE (8*sizeof(DWORD))

typedef struct _P2StateSetRec {
    DWORD                   dwHandle;
    DWORD                   bCompressed;

    union {
        struct {
            // Stored state block info (uncompressed)
            DWORD RenderStates[MAX_STATE];
            DWORD TssStates[D3DTSS_TEXTURETRANSFORMFLAGS+1];

            FLAG bStoredRS[(MAX_STATE + FLAG_SIZE)/ FLAG_SIZE];
            FLAG bStoredTSS[(D3DTSS_TEXTURETRANSFORMFLAGS + FLAG_SIZE) / FLAG_SIZE];
        } uc;
        struct {
            // Stored state block info (compressed)
            DWORD dwNumRS;
            DWORD dwNumTSS;
            struct {
                DWORD dwType;
                DWORD dwValue;
            } pair[1];
        } cc;
    } u;

} P2StateSetRec;

#define SSPTRS_PERPAGE (4096/sizeof(P2StateSetRec *))

#define FLAG_SET(flag, number)     \
    flag[ (number) / FLAG_SIZE ] |= (1 << ((number) % FLAG_SIZE))

#define IS_FLAG_SET(flag, number)  \
    (flag[ (number) / FLAG_SIZE ] & (1 << ((number) % FLAG_SIZE) ))
#endif //D3D_STATEBLOCKS

//-----------------------------------------------------------------------------
//                     Context structure definitions
//-----------------------------------------------------------------------------

typedef struct _D3DContextHeader {
    
    unsigned long MagicNo;   // Magic number to verify validity of pointer
    UINT_PTR pSelf;          // 32 Bit pointer to this structure
    unsigned long Flags;
    unsigned long FillMode;

    // Software copy of Registers for permedia
    __P2RegsSoftwareCopy SoftCopyP2Regs;  

} D3DCONTEXTHEADER;

typedef struct _TextureCacheManager *PTextureCacheManager;

typedef struct _permedia_d3dcontext {

    // The magic number MUST come at the start of the structure
    D3DCONTEXTHEADER    Hdr;

    // Stored surface info
    UINT_PTR             RenderSurfaceHandle;
    UINT_PTR             ZBufferHandle;
    ULONG                ulPackedPP;

                         // handle on Permedia register state context
    P2CtxtPtr            hPermediaContext; 

    PPDev ppdev;            // The card we are running on.

    BOOL bCanChromaKey;

    // Stippling state
    BOOL bKeptStipple;
    DWORD LastAlpha;
    BYTE CurrentStipple[8];

    DWORD RenderCommand;

    DWORD RenderStates[MAX_STATE];
    DWORD TssStates[D3DTSS_TEXTURETRANSFORMFLAGS+1]; // D3D DX6 TSS States
    DWORD dwWrap[8]; // D3D DX6 Wrap flags

    DWORD dwDirtyFlags;

    // Texture filtering modes
    BOOL bMagFilter;        // Filter the magnified textures
    BOOL bMinFilter;        // Filter the minified textures

    // Misc. state
    D3DCULL CullMode;
    DWORD FakeBlendNum;

    D3DStateSet     overrides;     // To overide states in rendering
    
    // Texture data & sizes (for Permedia setup) of our CurrentTextureHandle
    FLOAT DeltaHeightScale;
    FLOAT DeltaWidthScale;
    DWORD MaxTextureXi;
    FLOAT MaxTextureXf;
    DWORD MaxTextureYi;
    FLOAT MaxTextureYf;

    DWORD CurrentTextureHandle;

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    // Point sprite support
    BOOL bPointSpriteEnabled;
    FLOAT fPointSize;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

#if D3D_STATEBLOCKS
    BOOL bStateRecMode;            // Toggle for executing or recording states
    P2StateSetRec   *pCurrSS;      // Ptr to SS currently being recorded
    P2StateSetRec   **pIndexTableSS; // Pointer to table of indexes
    DWORD           dwMaxSSIndex;    // size of table of indexes
#endif

    DWORD PixelOffset;     // Offset in pixels to start of the rendering buffer

    DWORD LowerChromaColor;    // Last lower bound chroma key for this context
    DWORD UpperChromaColor;    // Last upper bound chroma key for this context

    PTextureCacheManager   pTextureManager;
    LPDWLIST    pHandleList;
    LPVOID      pDDLcl;                   // Local surface pointer used as a ID
} PERMEDIA_D3DCONTEXT ;


//-----------------------------------------------------------------------------
//                          Context switching
//-----------------------------------------------------------------------------
// Code to do a context switch.  If we aren't DMAing we need to resend the 
// registers on each context switch to work around the Permedia bug.  In the 
// DMA case, these registers will be inserted at the start of the buffer.
#define SET_CURRENT_D3D_CONTEXT(ctxt)        \
    if(ctxt != ppdev->permediaInfo->pCurrentCtxt)   \
    {                                       \
        P2SwitchContext(ppdev,  ctxt);   \
    }

HRESULT 
SetupPermediaRenderTarget(PERMEDIA_D3DCONTEXT* pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3ddelta.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddelta.h
*
*  Content: 3DLabs Delta unit related defines. Used only by D3D.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifdef __D3DDELTA
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __D3DDELTA

//-----------------------------------------------------------------------------
//   Conversion macros from ARGB values into Delta Gambit registers format
//-----------------------------------------------------------------------------
#define RGB_GET_GAMBIT_ALPHA(ci)  (((ci) & 0xff000000) >> 2)
#define RGB_GET_GAMBIT_RED(ci)	  (((ci) & 0xff0000) << 6)
#define RGB_GET_GAMBIT_GREEN(ci)  (((ci) & 0xff00) << 14)
#define RGB_GET_GAMBIT_BLUE(ci)	  (((ci) & 0xff) << 22)

#define RGB_GET_GAMBIT_FOG(ci)	  (((ci) & 0xff000000) >> 10)

#define AS_ULONG(val)   *((volatile DWORD *) &(val))


//-----------------------------------------------------------------------------
//     Macros defining the different Vertex types.tags for the Delta unit
//-----------------------------------------------------------------------------

#define VTX_FOG     (0x1 << 25)     
#define VTX_RGB     (0x7 << 21)
#define VTX_R       (0x1 << 21)
#define VTX_RGBA    (0xF << 21)
#define VTX_COLOR   (0x1 << 30)
#define VTX_STQ     (0x7 << 16)
#define VTX_KSKD    (0x3 << 19)
#define VTX_KS      (0x1 << 19)
#define VTX_XYZ     (0x7 << 26)
#define VTX_XY      (0x3 << 26)
#define VTX_GRP     (0x2 << 14)

#define GAMBIT_RGB_VTX                (VTX_GRP | VTX_RGB | VTX_XYZ)   
#define GAMBIT_RGB_F_VTX              (VTX_GRP | VTX_RGB | VTX_XYZ | VTX_FOG) 
#define GAMBIT_RGB_TEX_VTX            (VTX_GRP | VTX_RGB | VTX_XYZ | VTX_STQ)
#define GAMBIT_RGB_F_TEX_VTX          (VTX_GRP | VTX_RGB | VTX_XYZ |         \
                                                 VTX_STQ | VTX_FOG)
#define GAMBIT_RGBA_VTX               (VTX_GRP | VTX_RGBA | VTX_XYZ)  
#define GAMBIT_RGBA_F_VTX             (VTX_GRP | VTX_RGBA | VTX_XYZ | VTX_FOG)
#define GAMBIT_RGBA_TEX_VTX           (VTX_GRP | VTX_RGBA | VTX_XYZ | VTX_STQ)
#define GAMBIT_RGBA_F_TEX_VTX         (VTX_GRP | VTX_RGBA | VTX_XYZ |        \
                                                 VTX_STQ | VTX_FOG)
#define GAMBIT_FLAT_VTX               (VTX_GRP | VTX_XYZ)
#define GAMBIT_XYZ_VTX                (VTX_GRP | VTX_XYZ)
#define GAMBIT_XYZ_COLOR_VTX          (VTX_GRP | VTX_XYZ | VTX_COLOR)
#define GAMBIT_XYZ_STQ_VTX            (VTX_GRP | VTX_XYZ | VTX_STQ)
#define GAMBIT_XYZ_STQ_FOG_VTX        (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_FOG)
#define GAMBIT_XYZ_STQ_KSKD_VTX       (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_KSKD)
#define GAMBIT_XYZ_STQ_KS_VTX         (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_KS)
#define GAMBIT_XYZ_STQ_KS_COL_VTX     (VTX_GRP | VTX_XYZ | VTX_STQ |         \
                                                 VTX_KS | VTX_COLOR)
#define GAMBIT_XYZ_STQ_KS_COL_FOG_VTX (VTX_GRP | VTX_XYZ | VTX_STQ |         \
                                                 VTX_KS | VTX_COLOR | VTX_FOG)
#define GAMBIT_XY_VTX                 (VTX_GRP | VTX_XY)
#define GAMBIT_XY_STQ_VTX             (VTX_GRP | VTX_XY | VTX_STQ)
#define GAMBIT_XY_STQ_FOG_VTX         (VTX_GRP | VTX_XY | VTX_STQ | VTX_FOG)
#define GAMBIT_XY_STQ_KSKD_VTX        (VTX_GRP | VTX_XY | VTX_STQ | VTX_KSKD)
#define GAMBIT_COLS_VTX               (VTX_GRP | VTX_RGB)
#define GAMBIT_PACKED_COLS_VTX        (VTX_GRP | VTX_COLOR)
#define GAMBIT_COLS_ALPHA_VTX         (VTX_GRP | VTX_RGBA)
#define GAMBIT_COLS_KSKD_VTX          (VTX_GRP | VTX_RGB | VTX_KSKD)
#define GAMBIT_FLAT_F_VTX             (VTX_GRP | VTX_XYZ | VTX_FOG)
#define GAMBIT_FLAT_TEX_VTX           (VTX_GRP | VTX_XYZ | VTX_STQ)
#define GAMBIT_FLAT_F_TEX_VTX         (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_FOG)
#define GAMBIT_CI_VTX                 (VTX_GRP | VTX_R | VTX_XYZ) 
#define GAMBIT_CI_F_VTX               (VTX_GRP | VTX_R | VTX_XYZ | VTX_FOG)

//-----------------------------------------------------------------------------
//                     Vertex Data downloading macros
//-----------------------------------------------------------------------------
// 4 Entries
#define SEND_VERTEX_XYZ(Num, x_value, y_value, z_value)     \
{                                                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_XYZ_VTX | Num));          \
    LD_INPUT_FIFO_DATA( AS_ULONG(x_value) );                \
    LD_INPUT_FIFO_DATA( AS_ULONG(y_value) );                \
    LD_INPUT_FIFO_DATA( AS_ULONG(z_value) );                \
}

// 7 Entries
#define SEND_VERTEX_STQ_XYZ(Num, s_value, t_value, q_value,  \
                                 x_value, y_value, z_value)  \
{                                                            \
    LD_INPUT_FIFO_DATA( (GAMBIT_XYZ_STQ_VTX | Num));       \
    LD_INPUT_FIFO_DATA(AS_ULONG(s_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(t_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(q_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(x_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(y_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(z_value));                   \
}

// 8 Entries
#define SEND_VERTEX_STQ_KS_XYZ(Num, s_value, t_value, q_value,             \
                                    Ks_value, x_value, y_value, z_value)   \
{                                                                          \
    LD_INPUT_FIFO_DATA(  (GAMBIT_XYZ_STQ_KS_VTX | Num));                 \
    LD_INPUT_FIFO_DATA( AS_ULONG(s_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(t_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(q_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(Ks_value));                               \
    LD_INPUT_FIFO_DATA( AS_ULONG(x_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(y_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(z_value));                                \
}

// 2 Entries
#define SEND_VERTEX_FOG(vNo, fog_value)        \
{                                              \
    LD_INPUT_FIFO_DATA( vNo);                 \
    LD_INPUT_FIFO_DATA(fog_value);             \
}

// 4 Entries
#define SEND_VERTEX_RGB_MONO(vNo, Color)                \
{                                                       \
    LD_INPUT_FIFO_DATA( (GAMBIT_COLS_VTX | vNo));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
}

// 4 Entries
#define SEND_VERTEX_RGB(vNo, Color)                     \
{                                                       \
    LD_INPUT_FIFO_DATA( (GAMBIT_COLS_VTX | vNo));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_RED(Color));      \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_GREEN(Color));    \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
}

// 2 Entries
#define SEND_VERTEX_RGBA_P2(vNo, Color)                     \
{                                                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_PACKED_COLS_VTX | vNo));  \
    LD_INPUT_FIFO_DATA(Color);                              \
}

// 2 Entries
#define SEND_VERTEX_RGB_MONO_P2(vNo, Color)                                 \
{                                                                           \
    DWORD dwBlueVal = RGB_GET_GAMBIT_BLUE(Color);                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_PACKED_COLS_VTX | vNo));                  \
    LD_INPUT_FIFO_DATA( dwBlueVal | (dwBlueVal << 8) | (dwBlueVal << 16));  \
}

// 5 Entries
#define SEND_VERTEX_RGBA(vNo, Color)                        \
{                                                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_COLS_ALPHA_VTX | vNo));   \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_RED(Color));          \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_GREEN(Color));        \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));         \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_ALPHA(Color));        \
}

//-----------------------------------------------------------------------------
//                        HW Alpha stippling macros
//-----------------------------------------------------------------------------

extern DWORD FlatStipplePatterns[128];

#define SET_STIPPLED_ALPHA(AlphaValue)                                      \
{                                                                           \
    DWORD* pStipple;                                                        \
    DWORD NewAlpha = AlphaValue;                                            \
    if (NewAlpha != pContext->LastAlpha)                                    \
    {                                                                       \
        pContext->LastAlpha = NewAlpha;                                     \
        pStipple = FlatStipplePatterns + (NewAlpha << 3);                   \
        LD_INPUT_FIFO_DATA((0x00ff8000 | __Permedia2TagAreaStipplePattern0));  \
        LD_INPUT_FIFO_DATA( pStipple[0]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[1]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[2]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[3]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[4]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[5]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[6]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[7]);                                   \
                                                                            \
    }                                                                       \
    RENDER_AREA_STIPPLE_ENABLE(ulRenderCmd);                                \
}

//-----------------------------------------------------------------------------
//                        Rendering command setup macros
//-----------------------------------------------------------------------------

#define RENDER_AREA_STIPPLE_ENABLE(a) a |= __RENDER_AREA_STIPPLE_ENABLE;
#define RENDER_AREA_STIPPLE_DISABLE(a) a &= ~__RENDER_AREA_STIPPLE_ENABLE;

#define RENDER_TEXTURE_ENABLE(a) a |= __RENDER_TEXTURE_ENABLE;
#define RENDER_TEXTURE_DISABLE(a) a &= ~__RENDER_TEXTURE_ENABLE;

#define RENDER_FOG_ENABLE(a) a |= (1 << 14);
#define RENDER_FOG_DISABLE(a) a &= ~(1 << 14);

#define RENDER_SUB_PIXEL_CORRECTION_ENABLE(a) a |= (1 << 16);
#define RENDER_SUB_PIXEL_CORRECTION_DISABLE(a) a &= ~(1 << 16);


#define RENDER_LINE(a) a &= ~(0xC0);
#define RENDER_TRAPEZOID(a) {a &= ~(0xC0); a |= (0x40);}
#define RENDER_POINT(a) {a &= ~(0xC0);a |= (0x80);}

#define RENDER_NEGATIVE_CULL(a) a |= (1 << 20);
#define RENDER_POSITIVE_CULL(a) a &= ~(1 << 20);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dhw.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dhw.c
*
*  Content: Hardware dependent texture setup for D3D 
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "d3ddelta.h"
#include "dd.h"
#include "heap.h"
#include "d3dtxman.h"


//-----------------------------------------------------------------------------
//
// PERMEDIA_D3DTEXTURE *TextureHandleToPtr
//
// Find the texture associated to a given texture handle vale (which is to
// say , to a surface handle )
//
//-----------------------------------------------------------------------------

PERMEDIA_D3DTEXTURE *
TextureHandleToPtr(UINT_PTR thandle, PERMEDIA_D3DCONTEXT* pContext)
{

    //  only a DX7 context can get here
    ASSERTDD(NULL != pContext->pHandleList,
                       "pHandleList==NULL in TextureHandleToPtr");

    if (pContext->pHandleList->dwSurfaceList == NULL)
    {
        // avoid AV if our surface list is missing
        return NULL;
    }

    if ((PtrToUlong(pContext->pHandleList->dwSurfaceList[0]) > thandle) && 
        (0 != thandle))
    {
        return pContext->pHandleList->dwSurfaceList[(DWORD)thandle];
    }

    // Request for pointer for an invalid handle returns NULL
    return NULL;               
} // TextureHandleToPtr

//-----------------------------------------------------------------------------
//
// PERMEDIA_D3DTEXTURE *PaletteHandleToPtr
//
//-----------------------------------------------------------------------------

PERMEDIA_D3DPALETTE *
PaletteHandleToPtr(UINT_PTR phandle, PERMEDIA_D3DCONTEXT* pContext)
{
    ASSERTDD(NULL != pContext->pHandleList,
               "pHandleList==NULL in PaletteHandleToPtr");

    if ( (NULL != pContext->pHandleList->dwPaletteList) &&
         (PtrToUlong(pContext->pHandleList->dwPaletteList[0]) > phandle) &&
         (0 != phandle)
       )
    {
        return pContext->pHandleList->dwPaletteList[(DWORD)phandle];
    }
    return NULL;               
} // PaletteHandleToPtr


//-----------------------------------------------------------------------------
//
//void StorePermediaLODLevel
//
// Store private data specific to a level of detail
//
//-----------------------------------------------------------------------------
void 
StorePermediaLODLevel(PPDev ppdev, 
                      PERMEDIA_D3DTEXTURE* pTexture, 
                      LPDDRAWI_DDRAWSURFACE_LCL pSurf, 
                      int LOD)
{
    DWORD dwPartialWidth;
    int iPixelSize;

    DBG_D3D((10,"Entering StorePermediaLODLevel"));

    // if it's any surface type that's not created by driver
    // certainly there's no need to texture it
    if (NULL == pTexture->pTextureSurface)
        return; 

    // Get the BYTE Offset to the texture map
    if (DDSCAPS_NONLOCALVIDMEM & pTexture->dwCaps)
    {
        pTexture->MipLevels[LOD].PixelOffset = 
                (DWORD)(DD_AGPSURFACEPHYSICAL(pSurf->lpGbl) - ppdev->dwGARTDev);
    }
    else 
    {
        pTexture->MipLevels[LOD].PixelOffset = (DWORD)pSurf->lpGbl->fpVidMem;  
    }
    // .. Convert it to Pixels
    switch(pTexture->pTextureSurface->SurfaceFormat.PixelSize) 
    {
        case __PERMEDIA_4BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset <<= 1;
            break;
        case __PERMEDIA_8BITPIXEL: /* No Change*/
            break;
        case __PERMEDIA_16BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset >>= 1;
            break;
        case __PERMEDIA_24BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset /= 3;
            break;
        case __PERMEDIA_32BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset >>= 2;
            break;
        default:
            ASSERTDD(0,"Invalid Texture Pixel Size!");
            pTexture->MipLevels[LOD].PixelOffset >>= 1;
            break;
    }
    // P2 recognises that the texture is AGP if you set bit 30 to be 1.
    if (DDSCAPS_NONLOCALVIDMEM & pTexture->dwCaps)
    {
        pTexture->MipLevels[LOD].PixelOffset |= (1 << 30);
    }
    DBG_D3D((4,"Storing LOD: %d, Pitch: %d, Width: %d PixelOffset=%08lx", 
                LOD, pSurf->lpGbl->lPitch, 
                pSurf->lpGbl->wWidth,pTexture->MipLevels[LOD].PixelOffset));
    

    // Get the Partial Products for this LOD
    iPixelSize = pTexture->pTextureSurface->SurfaceFormat.PixelSize;

    if (iPixelSize == __PERMEDIA_4BITPIXEL)
    {
        dwPartialWidth = (pSurf->lpGbl->lPitch << 1);
    } 
    else 
    {
        if (iPixelSize != __PERMEDIA_24BITPIXEL)
        {
            dwPartialWidth = (pSurf->lpGbl->lPitch >> iPixelSize);
        } 
        else 
        {
            dwPartialWidth = pSurf->lpGbl->lPitch / 3;
        }
    }

    if (dwPartialWidth < 32) 
        dwPartialWidth = 32;

    vCalcPackedPP( dwPartialWidth, NULL, &pTexture->MipLevels[LOD].ulPackedPP);

    pTexture->MipLevels[LOD].logWidth = log2((int)pSurf->lpGbl->wWidth);
    pTexture->MipLevels[LOD].logHeight = log2((int)pSurf->lpGbl->wHeight);

    DBG_D3D((10,"Exiting StorePermediaLODLevel"));

} // StorePermediaLODLevel

//@@BEGIN_DDKSPLIT
// Note: we are currently not using more than 8MB of AGP memory
#if 0
//-----------------------------------------------------------------------------
//
//  BOOL CheckAGPTexturePage
//
// Check that the AGP texture we are about to use hasn't been placed
// in a different 8MB page. 
// dwGARTDev represents our current base address for the AGP texture memory
// dwGARTDevBase is the value we were passed at start of day
//-----------------------------------------------------------------------------

BOOL CheckAGPTexturePage(PPDev ppdev,
                         PERMEDIA_D3DCONTEXT* pContext,
                         PERMEDIA_D3DTEXTURE* pTexture,
                         LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    BOOL bChanged = FALSE;

    DBG_D3D((10,"Entering CheckAGPTexturePage"));

    ASSERTDD(pSurf, "ERROR: NULL Surface passed to CheckAGPTexturePage!");
 
        // Calculate the offset to the texture from the current 
        // base pointer in AGP memory
        UINT_PTR lSurfaceOffset = pTexture->lSurfaceOffset;
        UINT_PTR lTextureSize = pTexture->wHeight * pTexture->lPitch;

        // Account for a potential LUT added to the end of the surface
        lTextureSize += (256 * sizeof(DWORD));
        
        // If the texture falls outside the current 8Mb window 
        // then adjust the AGP base address
        if (lSurfaceOffset < ppdev->dwGARTLin ||
            ((lSurfaceOffset + lTextureSize - ppdev->dwGARTLin) >= 0x800000))
        {
            UINT_PTR dwNewGARTOffset = lSurfaceOffset;
            bChanged = TRUE;
        
            ppdev->dwGARTDev = ppdev->dwGARTDevBase + dwNewGARTOffset;
            ppdev->dwGARTLin = ppdev->dwGARTLinBase + dwNewGARTOffset;

            DBG_D3D((4,"Relocated AGP TextureBase Address "
                       "to : 0x%x (Base: 0x%x)", 
                       ppdev->dwGARTDev, ppdev->dwGARTDevBase));
        }

        //If the texture is in a different place relative to the base of 
        // AGP memory that we are using then update it
        if (pTexture->dwGARTDevLast != ppdev->dwGARTDev)
        {
            pTexture->dwGARTDevLast = ppdev->dwGARTDev;
            StorePermediaLODLevel(ppdev, pTexture, pSurf, 0);
        }

    DBG_D3D((10,"Exiting CheckAGPTexturePage"));

    return bChanged;
}
#endif
//@@END_DDKSPLIT

//-----------------------------------------------------------------------------
//
// void DisableTexturePermedia
//
// Disable texturing in P2
//
//-----------------------------------------------------------------------------
void 
DisableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext)
{
    DWORD* pFlags = &pContext->Hdr.Flags;
    PERMEDIA_D3DTEXTURE* pTexture = NULL;
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering DisableTexturePermedia"));

    pContext->FakeBlendNum &= ~FAKE_ALPHABLEND_MODULATE;
    
    // The textures have been turned off, so...
    ASSERTDD(pContext->CurrentTextureHandle == 0,
        "DisableTexturePermedia expected zero texture handle");

    DBG_D3D((4, "Disabling Texturing"));
    
    RESERVEDMAPTR(8);
    // Turn off texture address generation
    pSoftPermedia->TextureAddressMode.Enable = 0;
    COPY_PERMEDIA_DATA(TextureAddressMode, pSoftPermedia->TextureAddressMode);

    // Turn off texture reads
    pSoftPermedia->TextureReadMode.Enable = 0;
    COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
    
    // Turn off textures
    pSoftPermedia->TextureColorMode.TextureEnable = 0;
    COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);

    // Set the texture base address to 0
    // (turning off the 'AGP' bit in the process)
    // Also stop TexelLUTTransfer messages
    SEND_PERMEDIA_DATA(TextureBaseAddress, 0);
    SEND_PERMEDIA_DATA(TexelLUTTransfer, __PERMEDIA_DISABLE);


    // Set current texture to 0
    pContext->CurrentTextureHandle = 0;
    *pFlags &= ~CTXT_HAS_TEXTURE_ENABLED;
    RENDER_TEXTURE_DISABLE(pContext->RenderCommand);
    
    // If textures were in copy mode, we may have fiddled with the DDA,
    // to improve performance.
    if ((unsigned int)pSoftPermedia->TextureColorMode.ApplicationMode ==
        _P2_TEXTURE_COPY) 
    {
        if (*pFlags & CTXT_HAS_GOURAUD_ENABLED) 
        {
            pSoftPermedia->DeltaMode.SmoothShadingEnable = 1;

            COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
            pSoftPermedia->ColorDDAMode.UnitEnable = 1;
             // Smooth shade, DDA Enable
            COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);

        }
        else 
        {
            pSoftPermedia->DeltaMode.SmoothShadingEnable = 0;

            COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
            pSoftPermedia->ColorDDAMode.UnitEnable = 1;
             // Flat shade, DDA Enable
            COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);

        }
    }

    if (pContext->bCanChromaKey == TRUE) 
    {
        // Turn off Chroma Keying
        
        pSoftPermedia->YUVMode.TestMode = PM_YUVMODE_CHROMATEST_DISABLE;
        pSoftPermedia->YUVMode.Enable = __PERMEDIA_DISABLE;

        COPY_PERMEDIA_DATA(YUVMode, pSoftPermedia->YUVMode);

        pContext->bCanChromaKey = FALSE;
    }

    COMMITDMAPTR();

    DBG_D3D((10,"Exiting DisableTexturePermedia"));

    return;

} // DisableTexturePermedia

//-----------------------------------------------------------------------------
//
// void Convert_Chroma_2_8888ARGB
//
// Conversion of a chroma value into 32bpp ARGB
//
//-----------------------------------------------------------------------------
void
Convert_Chroma_2_8888ARGB(DWORD *pdwLowerBound, DWORD *pdwUpperBound,
                          DWORD dwRedMask, DWORD dwAlphaMask, DWORD dwPixelSize)
{
    DBG_D3D((10,"Entering Convert_Chroma_2_8888ARGB"));

    switch (dwPixelSize) {
    case __PERMEDIA_8BITPIXEL:
        if (dwRedMask == 0xE0)
        {
            // Never any alpha
            *pdwLowerBound = 
                CHROMA_LOWER_ALPHA(FORMAT_332_32BIT_BGR(*pdwLowerBound));
            *pdwUpperBound = 
                CHROMA_UPPER_ALPHA(FORMAT_332_32BIT_BGR(*pdwUpperBound));
        }
        else
        {
            *pdwLowerBound = FORMAT_2321_32BIT_BGR(*pdwLowerBound);
            *pdwUpperBound = FORMAT_2321_32BIT_BGR(*pdwUpperBound);
            if (!dwAlphaMask)
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
        }

        break;

    case __PERMEDIA_16BITPIXEL:
        switch (dwRedMask)
        {
        case 0xf00:
            *pdwLowerBound = (FORMAT_4444_32BIT_BGR(*pdwLowerBound));
            *pdwUpperBound = (FORMAT_4444_32BIT_BGR(*pdwUpperBound));
            if (!dwAlphaMask) 
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
            // Acount for the internal 8888 -> 4444 translation
            // which causes bilinear chroma keying to fail in
            // some cases
            *pdwLowerBound = *pdwLowerBound & 0xF0F0F0F0;
            *pdwUpperBound = *pdwUpperBound | 0x0F0F0F0F;

            break;
        case 0x7c00:
            *pdwLowerBound = FORMAT_5551_32BIT_BGR(*pdwLowerBound);
            *pdwUpperBound = FORMAT_5551_32BIT_BGR(*pdwUpperBound);
            if (!dwAlphaMask) 
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
            // Acount for the internal 8888 -> 5551 translation
            // which causes bilinear chroma keying to fail in
            // some cases
            *pdwLowerBound = *pdwLowerBound & 0x80F8F8F8;
            *pdwUpperBound = *pdwUpperBound | 0x7F070707;
            break;
        default:
            // Always supply full range of alpha values to ensure test 
            // is done
            *pdwLowerBound = 
                CHROMA_LOWER_ALPHA(FORMAT_565_32BIT_BGR(*pdwLowerBound));
            *pdwUpperBound = 
                CHROMA_UPPER_ALPHA(FORMAT_565_32BIT_BGR(*pdwUpperBound));
            if (!dwAlphaMask)
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
            // Acount for the internal 888 -> 565 translation
            // which causes bilinear chroma keying to fail in
            // some cases
            *pdwLowerBound = *pdwLowerBound & 0xF8F8FCF8;
            *pdwUpperBound = *pdwUpperBound | 0x07070307;
            break;
        }
        break;
    case __PERMEDIA_24BITPIXEL:
    case __PERMEDIA_32BITPIXEL:
        *pdwLowerBound = FORMAT_8888_32BIT_BGR(*pdwLowerBound);
        *pdwUpperBound = FORMAT_8888_32BIT_BGR(*pdwUpperBound);
        // If the surface isn't alpha'd then set a valid
        // range of alpha to catch all cases.
        if (!dwAlphaMask)
        {
            *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
            *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
        }
        break;
    }

    DBG_D3D((10,"Exiting Convert_Chroma_2_8888ARGB"));

} // Convert_Chroma_2_8888ARGB


//-----------------------------------------------------------------------------
//
// void EnableTexturePermedia
//
// Enable and setup texturing for pContext->CurrentTextureHandle
//
//-----------------------------------------------------------------------------
void 
EnableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext)
{
    DWORD* pFlags = &pContext->Hdr.Flags;
    PERMEDIA_D3DTEXTURE* pTexture = NULL;
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);
    PERMEDIA_D3DPALETTE* pPalette=NULL;
    LPPALETTEENTRY lpColorTable=NULL;   // array of palette entries
    PPDev   ppdev = pContext->ppdev;

    DBG_D3D((10,"Entering EnableTexturePermedia %d",
        pContext->CurrentTextureHandle));

    pContext->FakeBlendNum &= ~FAKE_ALPHABLEND_MODULATE;

    // A texture has been turned on so ...
    ASSERTDD(pContext->CurrentTextureHandle != 0,
        "EnableTexturePermedia expected non zero texture handle");

    // We must be texturing so...
    pTexture = TextureHandleToPtr(pContext->CurrentTextureHandle, pContext);
    
    if (CHECK_D3DSURFACE_VALIDITY(pTexture)) 
    {
        PermediaSurfaceData* pPrivateData;
        DWORD cop = pContext->TssStates[D3DTSS_COLOROP];
        DWORD ca1 = pContext->TssStates[D3DTSS_COLORARG1];
        DWORD ca2 = pContext->TssStates[D3DTSS_COLORARG2];
        DWORD aop = pContext->TssStates[D3DTSS_ALPHAOP];
        DWORD aa1 = pContext->TssStates[D3DTSS_ALPHAARG1];

        // Current is the same as diffuse in stage 0
        if (ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;

        pPrivateData = pTexture->pTextureSurface;

        if (!CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData))
        {
            DBG_D3D((0,"EnableTexturePermedia get invalid pPrivateData=0x%x"
                " from SurfaceHandle=%d", pPrivateData,
                pContext->CurrentTextureHandle));
            pContext->CurrentTextureHandle = 0;

            // If the texture is bad, let's ensure it's marked as such. 
            pTexture->MagicNo = TC_MAGIC_DISABLE;

            goto Exit_EnableTexturePermedia;
        }

        if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            if (NULL==pPrivateData->fpVidMem)
            {
                TextureCacheManagerAllocNode(pContext,pTexture);
                if (NULL==pPrivateData->fpVidMem)
                {
                    DBG_D3D((0,"EnableTexturePermedia unable to allocate memory from heap"));
                    pContext->CurrentTextureHandle = 0;
                    goto Exit_EnableTexturePermedia;
                }
                pPrivateData->dwFlags |= P2_SURFACE_NEEDUPDATE;
            }
            TextureCacheManagerTimeStamp(pContext->pTextureManager,pTexture);
            if (pPrivateData->dwFlags & P2_SURFACE_NEEDUPDATE)
            {
                RECTL   rect;
                rect.left=rect.top=0;
                rect.right=pTexture->wWidth;
                rect.bottom=pTexture->wHeight;
                // texture download
                // Switch to DirectDraw context
                pPrivateData->dwFlags &= ~P2_SURFACE_NEEDUPDATE;
                // .. Convert it to Pixels

                pTexture->MipLevels[0].PixelOffset = 
                    (DWORD)(pPrivateData->fpVidMem);

                switch(pTexture->pTextureSurface->SurfaceFormat.PixelSize) 
                {
                    case __PERMEDIA_4BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset <<= 1;
                        break;
                    case __PERMEDIA_8BITPIXEL: /* No Change*/
                        break;
                    case __PERMEDIA_16BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset >>= 1;
                        break;
                    case __PERMEDIA_24BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset /= 3;
                        break;
                    case __PERMEDIA_32BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset >>= 2;
                        break;
                    default:
                        ASSERTDD(0,"Invalid Texture Pixel Size!");
                        pTexture->MipLevels[0].PixelOffset >>= 1;
                        break;
                }
                PermediaPatchedTextureDownload(pContext->ppdev, 
                                           pPrivateData,
                                           pTexture->fpVidMem,
                                           pTexture->lPitch,
                                           &rect,
                                           pPrivateData->fpVidMem,
                                           pTexture->lPitch,
                                           &rect);

                //need to restore following registers
                RESERVEDMAPTR(7);
                SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
                COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
                SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
                SEND_PERMEDIA_DATA(FBWindowBase,0);   
                COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);
                COPY_PERMEDIA_DATA(AlphaBlendMode, pSoftPermedia->AlphaBlendMode);
                COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
                COMMITDMAPTR();

                DBG_D3D((10, "Copy from %08lx to %08lx w=%08lx h=%08lx p=%08lx b=%08lx",
                    pTexture->fpVidMem,pPrivateData->fpVidMem,pTexture->wWidth,
                    pTexture->wHeight,pTexture->lPitch,pTexture->dwRGBBitCount));
            }
        }        
        // If it is a palette indexed texture, we simply follow the chain
        // down from the surface to it's palette and pull out the LUT values
        // from the PALETTEENTRY's in the palette.
        if (pPrivateData->SurfaceFormat.Format == PERMEDIA_8BIT_PALETTEINDEX ||
            pPrivateData->SurfaceFormat.Format == PERMEDIA_4BIT_PALETTEINDEX) 
        {
            pPalette = 
                    PaletteHandleToPtr(pTexture->dwPaletteHandle,pContext);
            if (NULL != pPalette)
            {
                //some apps are not setting their alpha correctly with palette
                //then it's up to palette to tell us
                pPrivateData->SurfaceFormat.bAlpha =
                    pPalette->dwFlags & DDRAWIPAL_ALPHA;
            }
        }

        if ((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) &&
             cop == D3DTOP_MODULATE &&
             (aa1 == D3DTA_TEXTURE && aop == D3DTOP_LEGACY_ALPHAOVR)) 
        {
            // if this is legacy modulation then we take the texture alpha
            // only if the texure format has it
            if (pPrivateData->SurfaceFormat.bAlpha)
                pContext->FakeBlendNum |= FAKE_ALPHABLEND_MODULATE;
        }
        else if ((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) &&
             cop == D3DTOP_MODULATE &&
             (aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1)) 
        {
            // if this is DX6 modulation then we take the texture alpha
            // no matter what ( it will be xFF if it doesn't exist)
            pContext->FakeBlendNum |= FAKE_ALPHABLEND_MODULATE;
        }

        // Enable Texture Address calculation
        pSoftPermedia->TextureAddressMode.Enable = 1;
            
        // Enable Textures
        pSoftPermedia->TextureColorMode.TextureEnable = 1;
        if (*pFlags & CTXT_HAS_SPECULAR_ENABLED)
        {
            pSoftPermedia->DeltaMode.SpecularTextureEnable = 1;
            pSoftPermedia->TextureColorMode.KsDDA = 1; 
            pSoftPermedia->TextureColorMode.ApplicationMode |= 
                                                         _P2_TEXTURE_SPECULAR;
        } 
        else 
        {
            pSoftPermedia->DeltaMode.SpecularTextureEnable = 0;
            pSoftPermedia->TextureColorMode.KsDDA = 0; 
            pSoftPermedia->TextureColorMode.ApplicationMode &= 
                                                        ~_P2_TEXTURE_SPECULAR;
        }

        // reserve here for all cases in this function!!
        RESERVEDMAPTR(272);
        
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

        // Set Partial products for texture (assume no mipmapping).
        pSoftPermedia->TextureMapFormat.PackedPP = 
            pTexture->MipLevels[0].ulPackedPP;

        pSoftPermedia->TextureMapFormat.TexelSize = 
                                        pPrivateData->SurfaceFormat.PixelSize;

        if (pPrivateData->dwFlags & P2_ISPATCHED)
        {
            DBG_D3D((4,"   Enabling Patching for this texture"));
            pSoftPermedia->TextureMapFormat.SubPatchMode = 1;
        } 
        else 
        {
            pSoftPermedia->TextureMapFormat.SubPatchMode = 0;
        }

        DBG_D3D((4, "    Texel Size: 0x%x", 
                 pPrivateData->SurfaceFormat.PixelSize));

        // Set texture size
        DBG_D3D((4,"     Texture Width: 0x%x", 
                 pTexture->MipLevels[0].logWidth));
        DBG_D3D((4,"     Texture Height: 0x%x", 
                 pTexture->MipLevels[0].logHeight));

        pSoftPermedia->TextureReadMode.Width = 
                                       pTexture->MipLevels[0].logWidth;
        pSoftPermedia->TextureReadMode.Height = 
                                       pTexture->MipLevels[0].logHeight;

        pSoftPermedia->TextureReadMode.Enable = 1;
        pContext->DeltaWidthScale = (float)pTexture->wWidth * (1 / 2048.0f);
        pContext->DeltaHeightScale = (float)pTexture->wHeight * (1 / 2048.0f);

        pContext->MaxTextureXf = (float)(2048 / pTexture->wWidth);
        pContext->MaxTextureYf = (float)(2048 / pTexture->wHeight);

        myFtoui(&pContext->MaxTextureXi, pContext->MaxTextureXf);
        pContext->MaxTextureXi -= 1;
        myFtoui(&pContext->MaxTextureYi, pContext->MaxTextureYf);
        pContext->MaxTextureYi -= 1;

        *pFlags |= CTXT_HAS_TEXTURE_ENABLED;
        RENDER_TEXTURE_ENABLE(pContext->RenderCommand);
        
        DBG_D3D((4,"     Texture Format: 0x%x", 
                 pPrivateData->SurfaceFormat.Format));
        DBG_D3D((4,"     Texture Format Extension: 0x%x", 
                 pPrivateData->SurfaceFormat.FormatExtension));

        pSoftPermedia->TextureDataFormat.TextureFormat = 
                                            pPrivateData->SurfaceFormat.Format;
        pSoftPermedia->TextureDataFormat.TextureFormatExtension = 
                                   pPrivateData->SurfaceFormat.FormatExtension;

        if (pPrivateData->SurfaceFormat.bAlpha) 
        {
            pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 0;
        } 
        else 
        {
            pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 1;
        }

        // If we are copying textures, there is no need for colour data
        // to be generated, so we turn off the DDA
        if (((unsigned int)pSoftPermedia->TextureColorMode.ApplicationMode) == 
                                                              _P2_TEXTURE_COPY)
        {
            pSoftPermedia->ColorDDAMode.UnitEnable = 0;
            DBG_D3D((4, "    Disabling DDA"));
        }
        else
        {
            pSoftPermedia->ColorDDAMode.UnitEnable = 1;
            DBG_D3D((4, "    Enabling DDA"));
        }
        
        // Load the texture base address BEFORE the TexelLUTTransfer message 
        // to ensure we load the LUT from the right sort of memory (AGP or not)
        // Always set the base address at the root texture (not the miplevels 
        // if there are any)
        DBG_D3D((4, "Setting texture base address to 0x%08X", 
                 pTexture->MipLevels[0].PixelOffset));
        SEND_PERMEDIA_DATA(TextureBaseAddress, 
                           pTexture->MipLevels[0].PixelOffset);

        // If it is a palette indexed texture, we simply follow the chain
        // down from the surface to it's palette and pull out the LUT values
        // from the PALETTEENTRY's in the palette.
        if (pPrivateData->SurfaceFormat.Format == PERMEDIA_8BIT_PALETTEINDEX) 
        {

            if (NULL != pPalette)
            {
                int i;
                lpColorTable = pPalette->ColorTable;
                

                if (pPalette->dwFlags & DDRAWIPAL_ALPHA)
                {
                    for (i = 0; i < 256; i++)
                    {
                        SEND_PERMEDIA_DATA(TexelLUTData, *(DWORD*)lpColorTable);
                        lpColorTable++;
                    }
                }
                else
                {
                    for (i = 0; i < 256; i++)
                    {
                        SEND_PERMEDIA_DATA(TexelLUTData,
                            CHROMA_UPPER_ALPHA(*(DWORD*)lpColorTable));
                        lpColorTable++;
                    }
                }

                SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_ENABLE);

                DBG_D3D((4,"Texel LUT pPalette->dwFlags=%08lx bAlpha=%d", 
                    pPalette->dwFlags,pPrivateData->SurfaceFormat.bAlpha));

                // Must reset the LUT index on Permedia P2
                SEND_PERMEDIA_DATA(TexelLUTIndex, 0);
                
            }
            else
            {
                DBG_D3D((0, "NULL == pPalette in EnableTexturePermedia"
                    "dwPaletteHandle=%08lx dwSurfaceHandle=%08lx",
                    pTexture->dwPaletteHandle,
                    pContext->CurrentTextureHandle)); 
            }
        } 
        else if (pPrivateData->SurfaceFormat.Format == 
                                                    PERMEDIA_4BIT_PALETTEINDEX)
        {
            if (NULL != pPalette)
            {
                int i;
                lpColorTable = pPalette->ColorTable;
                
                SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_ENABLE);

                if (pPalette->dwFlags & DDRAWIPAL_ALPHA)
                {
                    for (i = 0; i < 16; i++)
                    {
                        SEND_PERMEDIA_DATA_OFFSET(TexelLUT0,
                                                *(DWORD*)lpColorTable,i);
                        lpColorTable++;
                    }
                }
                else
                {
                    for (i = 0; i < 16; i++)
                    {
                        SEND_PERMEDIA_DATA_OFFSET(TexelLUT0,
                            CHROMA_UPPER_ALPHA(*(DWORD*)lpColorTable),i);
                        lpColorTable++;
                    }
                }
                

                // Must reset the LUT index on Permedia P2
                
                SEND_PERMEDIA_DATA(TexelLUTIndex, 0);
                SEND_PERMEDIA_DATA(TexelLUTTransfer, __PERMEDIA_DISABLE);
            
            }
            else
            {
                DBG_D3D((0, "NULL == pPalette in EnableTexturePermedia"
                    "dwPaletteHandle=%08lx dwSurfaceHandle=%08lx",
                    pTexture->dwPaletteHandle,
                    pContext->CurrentTextureHandle)); 
            }
        }
        else
        {
            // Not palette indexed
            
            SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_DISABLE);
            
        }

        if ((pTexture->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
            && (pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])) 
        {
            DWORD LowerBound = pTexture->dwKeyLow;
            DWORD UpperBound = pTexture->dwKeyHigh;
            DWORD dwLowIndexColor;

            pContext->bCanChromaKey = TRUE;
            
            DBG_D3D((4,"    Can Chroma Key the texture"));
            // Enable Chroma keying for the texture
            // ..and set the correct colour

            // Evaluate the new chroma key value.  Shouldn't be too expensive,
            // as it is only bit shifts and a couple of tests.
            // We also change only when the texture map has changed.
            DBG_D3D((4, "dwColorSpaceLow = 0x%08X", LowerBound));
            DBG_D3D((4, "dwColorSpaceHigh = 0x%08X", UpperBound));

            if (NULL != pPalette) 
            {
                if (pPrivateData->SurfaceFormat.Format == 
                                                    PERMEDIA_4BIT_PALETTEINDEX)
                {
                    LowerBound &= 0x0F;
                }
                else
                {
                    LowerBound &= 0xFF;
                }
                lpColorTable = pPalette->ColorTable;

                // ChromaKeying for 4/8 Bit textures is done on the looked up 
                // color, not the index. This means using a range is 
                // meaningless and we have to lookup the color from the 
                // palette.  Make sure the user doesn't force us to access 
                // invalid memory.
                dwLowIndexColor = *(DWORD*)(&lpColorTable[LowerBound]);
                if (pPalette->dwFlags & DDRAWIPAL_ALPHA)
                {
                    LowerBound = UpperBound = dwLowIndexColor;
                }
                else
                {
                    LowerBound = CHROMA_LOWER_ALPHA(dwLowIndexColor);
                    UpperBound = CHROMA_UPPER_ALPHA(dwLowIndexColor);
                }
                DBG_D3D((4,"PaletteHandle=%08lx Lower=%08lx ChromaColor=%08lx"
                    "lpColorTable=%08lx dwFlags=%08lx",
                    pTexture->dwPaletteHandle, LowerBound, dwLowIndexColor,
                    lpColorTable, pPalette->dwFlags));
            }
            else 
                Convert_Chroma_2_8888ARGB(&LowerBound,
                                      &UpperBound,
                                      pPrivateData->SurfaceFormat.RedMask,
                                      pPrivateData->SurfaceFormat.AlphaMask,
                                      pPrivateData->SurfaceFormat.PixelSize);

            DBG_D3D((4,"LowerBound Selected: 0x%x", LowerBound));
            DBG_D3D((4,"UpperBound Selected: 0x%x", UpperBound));

            // If it's a P2 we can use alpha mapping to 
            // improve bilinear chroma keying.
            if (0/*(unsigned int)pSoftPermedia->TextureReadMode.FilterMode == 1*/)
            {
                pSoftPermedia->TextureDataFormat.AlphaMap = 
                                             PM_TEXDATAFORMAT_ALPHAMAP_EXCLUDE;
                pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 1;
                
                SEND_PERMEDIA_DATA(AlphaMapUpperBound, UpperBound);
                SEND_PERMEDIA_DATA(AlphaMapLowerBound, LowerBound);
                SEND_PERMEDIA_DATA(ChromaUpperBound, 0xFFFFFFFF);
                SEND_PERMEDIA_DATA(ChromaLowerBound, 0xFF000000);
                
                pSoftPermedia->YUVMode.TestMode = 
                                               PM_YUVMODE_CHROMATEST_PASSWITHIN;
            }
            else
            {
                pSoftPermedia->TextureDataFormat.AlphaMap =  
                                              PM_TEXDATAFORMAT_ALPHAMAP_DISABLE;
                
                SEND_PERMEDIA_DATA(ChromaUpperBound, UpperBound);
                SEND_PERMEDIA_DATA(ChromaLowerBound, LowerBound);
                

                pSoftPermedia->YUVMode.TestMode = 
                                               PM_YUVMODE_CHROMATEST_FAILWITHIN;
            }
        }
        else
        {
            DBG_D3D((2,"    Can't Chroma Key the texture"));
            pContext->bCanChromaKey = FALSE;
            pSoftPermedia->TextureDataFormat.AlphaMap = __PERMEDIA_DISABLE;
            pSoftPermedia->YUVMode.TestMode = PM_YUVMODE_CHROMATEST_DISABLE;
        }
        

        // Restore the filter mode from the mag filter.
        if (pContext->bMagFilter) 
        {
            pSoftPermedia->TextureReadMode.FilterMode = 1;
        }
        else 
        {
            pSoftPermedia->TextureReadMode.FilterMode = 0;
        }

        // If the texture is a YUV texture we need to change the color order
        // of the surface and turn on the YUV->RGB conversoin
        if (pPrivateData->SurfaceFormat.Format == PERMEDIA_YUV422) 
        {
            pSoftPermedia->YUVMode.Enable = __PERMEDIA_ENABLE;
            pSoftPermedia->TextureDataFormat.ColorOrder = INV_COLOR_MODE;
        }
        else 
        {
            pSoftPermedia->YUVMode.Enable = __PERMEDIA_DISABLE;
            pSoftPermedia->TextureDataFormat.ColorOrder = COLOR_MODE;
        }   

        // Send the Commands at the end (except the texture base address!!)
        
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COPY_PERMEDIA_DATA(TextureDataFormat, pSoftPermedia->TextureDataFormat);
        COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
        COPY_PERMEDIA_DATA(TextureMapFormat, pSoftPermedia->TextureMapFormat);
        COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);
        COPY_PERMEDIA_DATA(YUVMode, pSoftPermedia->YUVMode);
        COPY_PERMEDIA_DATA(TextureAddressMode, 
                                             pSoftPermedia->TextureAddressMode);

        COMMITDMAPTR();
        FLUSHDMA();
    }
    else 
    {
        DBG_D3D((0,"Invalid Texture handle (%d)!, doing nothing", 
                 pContext->CurrentTextureHandle));
        pContext->CurrentTextureHandle = 0;

        // If the texture is bad, let's ensure it's marked as such.
        // But only if the texture is actually there!!
        if (pTexture) 
            pTexture->MagicNo = TC_MAGIC_DISABLE;     
    }


Exit_EnableTexturePermedia:

    DBG_D3D((10,"Exiting EnableTexturePermedia"));

} // EnableTexturePermedia

//-----------------------------------------------------------------------------
//
// void: __PermediaDisableUnits
//
// Disables all the mode registers to give us a clean start.
//
//-----------------------------------------------------------------------------
void 
__PermediaDisableUnits(PERMEDIA_D3DCONTEXT* pContext)
{
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering __PermediaDisableUnits"));

    RESERVEDMAPTR(28);

    SEND_PERMEDIA_DATA(RasterizerMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AreaStippleMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ScissorMode,          __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(ColorDDAMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FogMode,              __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(LBReadMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(Window,               __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(StencilMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(DepthMode,            __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(LBWriteMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBReadMode,           __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(DitherMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AlphaBlendMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LogicalOpMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBWriteMode,          __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(StatisticMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FilterMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBSourceData,         __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(LBWriteFormat,        __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(TextureReadMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureMapFormat,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureDataFormat,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTMode,         __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(TextureColorMode,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AStart,               PM_BYTE_COLOR(0xFF));

    // Ensure AGP bit not set.
    SEND_PERMEDIA_DATA(TextureBaseAddress,   0);
    SEND_PERMEDIA_DATA(TexelLUTIndex,        0);
    SEND_PERMEDIA_DATA(TexelLUTTransfer,     __PERMEDIA_DISABLE);

    COMMITDMAPTR();
    FLUSHDMA();

    DBG_D3D((10,"Exiting __PermediaDisableUnits"));

} // __PermediaDisableUnits


#ifdef DBG

//-----------------------------------------------------------------------------
//
// void DumpTexture
//
// Debug dump of texture information
//
//-----------------------------------------------------------------------------
void 
DumpTexture(PPDev ppdev, 
            PERMEDIA_D3DTEXTURE* pTexture, 
            DDPIXELFORMAT* pPixelFormat)
{
    DBG_D3D((4, "\n** Texture Dump:"));

    DBG_D3D((4,"  Texture Width: %d", pTexture->wWidth));
    DBG_D3D((4,"  Texture Height: %d", pTexture->wHeight));

    if (NULL != pTexture->pTextureSurface)
    {
        DBG_D3D((4,"  LogWidth: %d", 
                 pTexture->MipLevels[0].logWidth));
        DBG_D3D((4,"  LogHeight: %d", 
                 pTexture->MipLevels[0].logHeight));
        DBG_D3D((4,"  PackedPP0: 0x%x", 
            pTexture->pTextureSurface->ulPackedPP));
    }
    DBG_D3D((4,"  Pixel Offset of Texture (PERMEDIA Chip): 0x%x", 
             pTexture->MipLevels[0].PixelOffset));
    
    // Show texture format
    if (pPixelFormat->dwRGBAlphaBitMask == 0xf000) 
    {
        DBG_D3D((4,"  Texture is 4:4:4:4"));
    }
    else if (pPixelFormat->dwRBitMask == 0xff0000) 
    {
        if (pPixelFormat->dwRGBAlphaBitMask != 0) 
        {
            DBG_D3D((4,"  Texture is 8:8:8:8"));
        }
        else 
        {
            DBG_D3D((4,"  Texture is 8:8:8"));
        }
    }
    else if (pPixelFormat->dwRBitMask == 0x7c00) 
    {
        if (pPixelFormat->dwRGBAlphaBitMask != 0) 
        {
            DBG_D3D((4,"  Texture is 1:5:5:5"));
        }
        else 
        {
            DBG_D3D((4,"  Texture is 5:5:5"));
        }
    }
    else if (pPixelFormat->dwRBitMask == 0xf800) 
    {
        DBG_D3D((4,"  Texture is 5:6:5"));
    }
    else if (pPixelFormat->dwRBitMask == 0xe0) 
    {
        DBG_D3D((4,"  Texture is 3:3:2"));
    }
} // DumpTexture
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3ddx6.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddx6.c
*
*  Content:    Direct3D DX6 Callback function interface
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "dd.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_6D2P
//-----------------------------------------------------------------------------
//
// DX6 allows driver-level acceleration of the new vertex-buffer API. It 
// allows data and commands, indices and statechanges to be contained in 
// two separate DirectDraw surfaces. The DirectDraw surfaces can reside 
// in system, AGP, or video memory depending on the type of allocation
// requested by the user  The interface is designed to accomodate legacy
// ExecuteBuffer applications with no driver impact. This allows higher 
// performance on both legacy applications as well as the highest 
// possible performance through the vertex buffer API.
//
//-----------------------------------------------------------------------------

#define STARTVERTEXSIZE (sizeof(D3DHAL_DP2STARTVERTEX))

// Macros for updating properly our instruction pointer to our next instruction
// in the command buffer
#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                            \
        NEXTINSTRUCTION_S(ptr, sizeof(type), num, extrabytes)

#define NEXTINSTRUCTION_S(ptr, typesize, num, extrabytes)                      \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +      \
                                ((num) * (typesize)) + (extrabytes))

// Error reporting macro , sets up error code and exits DrawPrimitives2
#define PARSE_ERROR_AND_EXIT( pDP2Data, pIns, pStartIns, ddrvalue)             \
   {                                                                           \
            pDP2Data->dwErrorOffset = (DWORD)((LPBYTE)pIns-(LPBYTE)pStartIns); \
            pDP2Data->ddrval = ddrvalue;                                       \
            goto Exit_DrawPrimitives2;                                         \
   }

// Macros for verifying validity of the command and vertex buffers. This MUST
// be done by the driver even on free builds as the runtime avoids this check
// in order to not parse the command buffer too. 
#define CHECK_CMDBUF_LIMITS( pDP2Data, pBuf, type, num, extrabytes)            \
        CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, sizeof(type), num, extrabytes)

#define CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, typesize, num, extrabytes)      \
   {                                                                           \
        LPBYTE pBase,pEnd,pBufEnd;                                             \
        pBase = (LPBYTE)(pDP2Data->lpDDCommands->lpGbl->fpVidMem +             \
                        pDP2Data->dwCommandOffset);                            \
        pEnd  = pBase + pDP2Data->dwCommandLength;                             \
        pBufEnd = ((LPBYTE)pBuf + ((num) * (typesize)) + (extrabytes) - 1);    \
        if (! ((LPBYTE)pBufEnd < pEnd) && ( pBase <= (LPBYTE)pBuf))            \
        {                                                                      \
            DBG_D3D((0,"DX6 D3D: Trying to read past Command Buffer limits "   \
                    "%x %x %x %x",pBase ,(LPBYTE)pBuf, pBufEnd, pEnd ));       \
            PARSE_ERROR_AND_EXIT( pDP2Data, lpIns, lpInsStart,                 \
                                  D3DERR_COMMAND_UNPARSED      );              \
        }                                                                      \
    }

#define CHECK_DATABUF_LIMITS( pDP2Data, iIndex)                                \
   {                                                                           \
        if (! (((LONG)iIndex >= 0) &&                                          \
               ((LONG)iIndex <(LONG)pDP2Data->dwVertexLength)))                \
        {                                                                      \
            DBG_D3D((0,"DX6 D3D: Trying to read past Vertex Buffer limits "    \
                "%d limit= %d ",(LONG)iIndex, (LONG)pDP2Data->dwVertexLength));\
            PARSE_ERROR_AND_EXIT( pDP2Data, lpIns, lpInsStart,                 \
                                  D3DERR_COMMAND_UNPARSED      );              \
        }                                                                      \
    }

// Macros for accessing vertexes in the vertex buffer based on an index or on
// a previous accessed vertex
#define LP_FVF_VERTEX(lpBaseAddr, wIndex, P2FVFOffs)                           \
         (LPD3DTLVERTEX)((LPBYTE)(lpBaseAddr) + (wIndex) * (P2FVFOffs).dwStride)

#define LP_FVF_NXT_VTX(lpVtx, P2FVFOffs )                                      \
         (LPD3DTLVERTEX)((LPBYTE)(lpVtx) + (P2FVFOffs).dwStride)


// Forward declaration of utility functions
DWORD __CheckFVFRequest(DWORD dwFVF, LPP2FVFOFFSETS lpP2FVFOff);

D3DFVFDRAWTRIFUNCPTR __HWSetTriangleFunc(PERMEDIA_D3DCONTEXT *pContext);

HRESULT  __Clear( PERMEDIA_D3DCONTEXT* pContext,
              DWORD   dwFlags,
              DWORD   dwFillColor,
              D3DVALUE dvFillDepth,
              DWORD   dwFillStencil,
              LPD3DRECT lpRects,
              DWORD   dwNumRects);

HRESULT  __TextureBlt(PERMEDIA_D3DCONTEXT* pContext,
                D3DHAL_DP2TEXBLT* lpdp2texblt);

HRESULT  __SetRenderTarget(PERMEDIA_D3DCONTEXT* pContext,
                     DWORD hRenderTarget,
                     DWORD hZBuffer);

HRESULT  __PaletteUpdate(PERMEDIA_D3DCONTEXT* pContext,
                     DWORD dwPaletteHandle, 
                     WORD wStartIndex, 
                     WORD wNumEntries,
                     BYTE * pPaletteData);

HRESULT  __PaletteSet(PERMEDIA_D3DCONTEXT* pContext,
                  DWORD dwSurfaceHandle,
                  DWORD dwPaletteHandle,
                  DWORD dwPaletteFlags);

void __BeginStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __EndStateSet(PERMEDIA_D3DCONTEXT*);

void __DeleteStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __ExecuteStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __CaptureStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __RestoreD3DContext(PPDev ppdev, PERMEDIA_D3DCONTEXT* pContext);

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DDrawPrimitives2
//
// The D3DDrawPrimitives2 callback is filled in by drivers which directly 
// support the rendering primitives using the new DDI. If this entry is
// left as NULL, the API will be emulated through DX5-level HAL interfaces.
//
// PARAMETERS
//
//      lpdp2d   This structure is used when D3DDrawPrimitives2 is called 
//               to draw a set of primitives using a vertex buffer. The
//               surface specified by the lpDDCommands in 
//               D3DHAL_DRAWPRIMITIVES2DATA contains a sequence of 
//               D3DHAL_DP2COMMAND structures. Each D3DHAL_DP2COMMAND 
//               specifies either a primitive to draw, a state change to
//               process, or a re-base command.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
D3DDrawPrimitives2_P2( LPD3DHAL_DRAWPRIMITIVES2DATA lpdp2d );

DWORD CALLBACK
D3DDrawPrimitives2( LPD3DHAL_DRAWPRIMITIVES2DATA lpdp2d )
{
    // User memory might become invalid under some circumstances,
    // exception handler is used for protection
    __try
    {
        return (D3DDrawPrimitives2_P2(lpdp2d));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // On Perm2 driver, no special handling is done
        DBG_D3D((0, "D3DDrawPrimitives2 : exception happened."));

        lpdp2d->ddrval = DDERR_EXCEPTION;
        return (DDHAL_DRIVER_HANDLED);
    }
}

DWORD CALLBACK 
D3DDrawPrimitives2_P2( LPD3DHAL_DRAWPRIMITIVES2DATA lpdp2d )
{
    LPDDRAWI_DDRAWSURFACE_LCL       lpCmdLcl, lpDataLcl;
    LPD3DHAL_DP2COMMAND             lpIns, lpResumeIns;  
    LPD3DTLVERTEX                   lpVertices=NULL, lpV0, lpV1, lpV2, lpV3;
    LPBYTE                          lpInsStart, lpPrim;
    PERMEDIA_D3DCONTEXT            *pContext;
    UINT                            i,j;
    WORD                            wCount, wIndex, wIndex1, wIndex2, wIndex3,
                                    wFlags, wIndxBase;
    HRESULT                         ddrval;
    P2FVFOFFSETS                    P2FVFOff;
    D3DHAL_DP2TEXTURESTAGESTATE    *lpRState;
    D3DFVFDRAWTRIFUNCPTR            pTriangle;
    D3DFVFDRAWPNTFUNCPTR            pPoint;
    DWORD                           dwEdgeFlags;

    DBG_D3D((6,"Entering D3DDrawPrimitives2"));

    DBG_D3D((8,"  dwhContext = %x",lpdp2d->dwhContext));
    DBG_D3D((8,"  dwFlags = %x",lpdp2d->dwFlags));
    DBG_D3D((8,"  dwVertexType = %d",lpdp2d->dwVertexType));
    DBG_D3D((8,"  dwCommandOffset = %d",lpdp2d->dwCommandOffset));
    DBG_D3D((8,"  dwCommandLength = %d",lpdp2d->dwCommandLength));
    DBG_D3D((8,"  dwVertexOffset = %d",lpdp2d->dwVertexOffset));
    DBG_D3D((8,"  dwVertexLength = %d",lpdp2d->dwVertexLength));

    // Retrieve permedia d3d context from context handle
    pContext = (PERMEDIA_D3DCONTEXT*)ContextSlots[lpdp2d->dwhContext];

    // Check if we got a valid context
    CHK_CONTEXT(pContext, lpdp2d->ddrval, "DrawPrimitives2");

    PPDev ppdev = pContext->ppdev;
    PERMEDIA_DEFS(ppdev);
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    
    // Switch hw context, and force the next switch to wait for the Permedia
    SET_CURRENT_D3D_CONTEXT(pContext->hPermediaContext);

    // Restore our D3D rendering context
    __RestoreD3DContext(ppdev, pContext);

    // Get appropriate pointers to command buffer
    lpInsStart = (LPBYTE)(lpdp2d->lpDDCommands->lpGbl->fpVidMem);
    if (lpInsStart == NULL)
    {
        DBG_D3D((0,"DX6 Command Buffer pointer is null"));
        lpdp2d->ddrval = DDERR_INVALIDPARAMS;
        goto Exit_DrawPrimitives2;
    }
    lpIns = (LPD3DHAL_DP2COMMAND)(lpInsStart + lpdp2d->dwCommandOffset);

    // Check if the FVF format being passed is valid. 
    if (__CheckFVFRequest(lpdp2d->dwVertexType, &P2FVFOff) != DD_OK)
    {
        DBG_D3D((0,"DrawPrimitives2 cannot handle "
                   "Flexible Vertex Format requested"));
        PARSE_ERROR_AND_EXIT(lpdp2d, lpIns, lpInsStart,
                             D3DERR_COMMAND_UNPARSED);
    }
    // Check if vertex size calculated from dwVertexType is the same as
    // dwVertexSize, this is to make sure that CHECK_DATABUF_LIMITS's index
    // checking is done using the correct step size
    if (lpdp2d->dwVertexSize != P2FVFOff.dwStride)
    {
        DBG_D3D((0,"DrawPrimitives2 : invalid vertex size from runtime."));
        PARSE_ERROR_AND_EXIT(lpdp2d, lpIns, lpInsStart,
                             D3DERR_COMMAND_UNPARSED);
    }

    // Process commands while we haven't exhausted the command buffer
    while ((LPBYTE)lpIns < 
           (lpInsStart + lpdp2d->dwCommandLength + lpdp2d->dwCommandOffset))  
    {
        // Get pointer to first primitive structure past the D3DHAL_DP2COMMAND
        lpPrim = (LPBYTE)lpIns + sizeof(D3DHAL_DP2COMMAND);

        DBG_D3D((4,"D3DDrawPrimitive2: parsing instruction %d count = %d @ %x", 
                lpIns->bCommand, lpIns->wPrimitiveCount, lpIns));

        // If our next command involves some actual rendering, we have to make
        // sure that our rendering context is realized
        switch( lpIns->bCommand )
        {
        case D3DDP2OP_POINTS:
        case D3DDP2OP_LINELIST:
        case D3DDP2OP_INDEXEDLINELIST:
        case D3DDP2OP_INDEXEDLINELIST2:
        case D3DDP2OP_LINESTRIP:
        case D3DDP2OP_INDEXEDLINESTRIP:
        case D3DDP2OP_TRIANGLELIST:
        case D3DDP2OP_INDEXEDTRIANGLELIST:
        case D3DDP2OP_INDEXEDTRIANGLELIST2:
        case D3DDP2OP_TRIANGLESTRIP:
        case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        case D3DDP2OP_TRIANGLEFAN:
        case D3DDP2OP_INDEXEDTRIANGLEFAN:
            
            // Check if vertex buffer resides in user memory or in a DDraw surface
            if (NULL == lpVertices)
            {
                if (NULL == lpdp2d->lpVertices)
                {
                    DBG_D3D((0,"DX6 Vertex Buffer pointer is null"));
                    lpdp2d->ddrval = DDERR_INVALIDPARAMS;
                    goto Exit_DrawPrimitives2;
                }            
                if (lpdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
                {
                    // Get appropriate pointer to vertices , memory is already secured
                    lpVertices = (LPD3DTLVERTEX)((LPBYTE)lpdp2d->lpVertices + 
                                                         lpdp2d->dwVertexOffset);
                } 
                else 
                {
                    // Get appropriate pointer to vertices 
                    lpVertices = 
                       (LPD3DTLVERTEX)((LPBYTE)lpdp2d->lpDDVertex->lpGbl->fpVidMem
                                                                 + lpdp2d->dwVertexOffset);
                }

                if (NULL == lpVertices)
                {
                    DBG_D3D((0,"DX6 Vertex Buffer pointer is null"));
                    lpdp2d->ddrval = DDERR_INVALIDPARAMS;
                    goto Exit_DrawPrimitives2;
                }            
            }
            // fall through intentionally, no break here
        case D3DDP2OP_LINELIST_IMM:
        case D3DDP2OP_TRIANGLEFAN_IMM:
            // Update triangle rendering function
            pTriangle = __HWSetTriangleFunc(pContext);
            pPoint    = __HWSetPointFunc(pContext, &P2FVFOff);      

            // Handle State changes that may need to update the chip
            if (pContext->dwDirtyFlags)
            {
                // Handle the dirty states
                __HandleDirtyPermediaState(ppdev, pContext, &P2FVFOff);
            }
            break;
        }

        // Execute the current command buffer command
        switch( lpIns->bCommand )
        {

        case D3DDP2OP_RENDERSTATE:

            // Specifies a render state change that requires processing. 
            // The rendering state to change is specified by one or more 
            // D3DHAL_DP2RENDERSTATE structures following D3DHAL_DP2COMMAND.
            
            DBG_D3D((8,"D3DDP2OP_RENDERSTATE "
                    "state count = %d", lpIns->wStateCount));

            // Check we are in valid buffer memory
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2RENDERSTATE, lpIns->wStateCount, 0);

            lpdp2d->ddrval = __ProcessPermediaStates(pContext,
                                                     lpIns->wStateCount,
                                                     (LPD3DSTATE) (lpPrim),
                                                     lpdp2d->lpdwRStates);

            if ( FAILED(lpdp2d->ddrval) )
            {
                DBG_D3D((2,"Error processing D3DDP2OP_RENDERSTATE"));
                PARSE_ERROR_AND_EXIT(lpdp2d, lpIns, lpInsStart, ddrval);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2RENDERSTATE, 
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_TEXTURESTAGESTATE:
            // Specifies texture stage state changes, having wStateCount 
            // D3DNTHAL_DP2TEXTURESTAGESTATE structures follow the command
            // buffer. For each, the driver should update its internal 
            // texture state associated with the texture at dwStage to 
            // reflect the new value based on TSState.

            DBG_D3D((8,"D3DDP2OP_TEXTURESTAGESTATE"));

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2TEXTURESTAGESTATE, lpIns->wStateCount, 0);

            lpRState = (D3DHAL_DP2TEXTURESTAGESTATE *)(lpPrim);
            for (i = 0; i < lpIns->wStateCount; i++)
            {
                if (0 == lpRState->wStage)
                {

                   // Tell __HWSetupPrimitive to look at stage state data
                   DIRTY_MULTITEXTURE;

                   if ((lpRState->TSState >= D3DTSS_TEXTUREMAP) &&
                        (lpRState->TSState <= D3DTSS_TEXTURETRANSFORMFLAGS))
                   {
#if D3D_STATEBLOCKS
                        if (!pContext->bStateRecMode)
                        {
#endif //D3D_STATEBLOCKS
                            if (pContext->TssStates[lpRState->TSState] !=
                                                          lpRState->dwValue)
                            {
                                // Store value associated to this stage state
                                pContext->TssStates[lpRState->TSState] =
                                                             lpRState->dwValue;

                                // Perform any necessary preprocessing of it
                                __HWPreProcessTSS(pContext,
                                                  0,
                                                  lpRState->TSState,
                                                  lpRState->dwValue);

                                DBG_D3D((8,"TSS State Chg , Stage %d, "
                                           "State %d, Value %d",
                                        (LONG)lpRState->wStage, 
                                        (LONG)lpRState->TSState, 
                                        (LONG)lpRState->dwValue));
                                DIRTY_TEXTURE; //AZN5
                            }
#if D3D_STATEBLOCKS
                        } 
                        else
                        {
                            if (pContext->pCurrSS != NULL)
                            {
                                DBG_D3D((6,"Recording RS %x = %x",
                                         lpRState->TSState, lpRState->dwValue));

                                // Recording the state in a stateblock
                                pContext->pCurrSS->u.uc.TssStates[lpRState->TSState] =
                                                                    lpRState->dwValue;
                                FLAG_SET(pContext->pCurrSS->u.uc.bStoredTSS,
                                         lpRState->TSState);
                            }
                        }
#endif //D3D_STATEBLOCKS
                   }
                   else
                   {
                        DBG_D3D((2,"Unhandled texture stage state %d value %d",
                            (LONG)lpRState->TSState, (LONG)lpRState->dwValue));
                   }
                }
                else
                {
                    DBG_D3D((0,"Texture Stage other than 0 received,"
                               " not supported in hw"));
                }
                lpRState ++;
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TEXTURESTAGESTATE, 
                            lpIns->wStateCount, 0); 
            break;

        case D3DNTDP2OP_VIEWPORTINFO:
            // Specifies the clipping rectangle used for guard-band 
            // clipping by guard-band aware drivers. The clipping 
            // rectangle (i.e. the viewing rectangle) is specified 
            // by the D3DHAL_DP2 VIEWPORTINFO structures following 
            // D3DHAL_DP2COMMAND

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2VIEWPORTINFO, lpIns->wStateCount, 0);

            // We don't implement guard band clipping in this driver so
            // we just skip any of this data that might be sent to us
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2VIEWPORTINFO,
                            lpIns->wStateCount, 0); 
            break;

        case D3DNTDP2OP_WINFO:
            // Specifies the w-range for W buffering. It is specified
            // by one or more D3DHAL_DP2WINFO structures following
            // D3DHAL_DP2COMMAND.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2WINFO, lpIns->wStateCount, 0);

            // We dont implement a w-buffer in this driver so we just 
            // skip any of this data that might be sent to us 
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2WINFO,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_POINTS:

            DBG_D3D((8,"D3DDP2OP_POINTS"));

            // Point primitives in vertex buffers are defined by the 
            // D3DHAL_DP2POINTS structure. The driver should render
            // wCount points starting at the initial vertex specified 
            // by wFirst. Then for each D3DHAL_DP2POINTS, the points
            // rendered will be (wFirst),(wFirst+1),...,
            // (wFirst+(wCount-1)). The number of D3DHAL_DP2POINTS
            // structures to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2POINTS, lpIns->wPrimitiveCount, 0);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                wIndex = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
                wCount = ((D3DHAL_DP2POINTS*)lpPrim)->wCount;

                lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);

                // Check first & last vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
                CHECK_DATABUF_LIMITS(lpdp2d, ((LONG)wIndex + wCount - 1));
                for (j = 0; j < wCount; j++)
                {
                    (*pPoint)(pContext, lpV0, &P2FVFOff);
                    lpV0 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
                }

                lpPrim += sizeof(D3DHAL_DP2POINTS);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2POINTS, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_LINELIST:

            DBG_D3D((8,"D3DDP2OP_LINELIST"));

            // Non-indexed vertex-buffer line lists are defined by the 
            // D3DHAL_DP2LINELIST structure. Given an initial vertex, 
            // the driver will render a sequence of independent lines, 
            // processing two new vertices with each line. The number 
            // of lines to render is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be 
            // (wVStart, wVStart+1),(wVStart+2, wVStart+3),...,
            // (wVStart+(wPrimitiveCount-1)*2), wVStart+wPrimitiveCount*2 - 1).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2LINELIST, 1, 0);

            wIndex = ((D3DHAL_DP2LINELIST*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d,
                                   ((LONG)wIndex + 2*lpIns->wPrimitiveCount - 1) );
            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, &P2FVFOff);

                lpV0 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
                lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST:

            DBG_D3D((8,"D3DDP2OP_INDEXEDLINELIST"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),...
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, 
                D3DHAL_DP2INDEXEDLINELIST, lpIns->wPrimitiveCount, 0);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            { 
                wIndex1 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV2;

                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1, P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2, P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2);
                P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV1, &P2FVFOff);

                lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST2:

            DBG_D3D((8,"D3DDP2OP_INDEXEDLINELIST2"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, 
                    D3DHAL_DP2INDEXEDLINELIST, lpIns->wPrimitiveCount,
                    STARTVERTEXSIZE);

            // Access base index
            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                wIndex1 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV2;

                lpV1 = LP_FVF_VERTEX(lpVertices, (wIndex1+wIndxBase), P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, (wIndex2+wIndxBase), P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);
                P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV1, &P2FVFOff);

                lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINESTRIP:

            DBG_D3D((8,"D3DDP2OP_LINESTRIP"));

            // Non-index line strips rendered with vertex buffers are
            // specified using D3DHAL_DP2LINESTRIP. The first vertex 
            // in the line strip is specified by wVStart. The 
            // number of lines to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of lines rendered will be (wVStart, wVStart+1),
            // (wVStart+1, wVStart+2),(wVStart+2, wVStart+3),...,
            // (wVStart+wPrimitiveCount, wVStart+wPrimitiveCount+1).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2LINESTRIP, 1, 0);

            wIndex = ((D3DHAL_DP2LINESTRIP*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex + lpIns->wPrimitiveCount);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, &P2FVFOff);

                lpV0 = lpV1;
                lpV1 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINESTRIP:

            DBG_D3D((8,"D3DDP2OP_INDEXEDLINESTRIP"));

            // Indexed line strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDLINESTRIP. The number
            // of lines to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[1], wV[2]),
            // (wV[2], wV[3]), ...
            // (wVStart[wPrimitiveCount-1], wVStart[wPrimitiveCount]). 
            // Although the D3DHAL_DP2INDEXEDLINESTRIP structure only
            // has enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+1 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, 
                    WORD, lpIns->wPrimitiveCount + 1, STARTVERTEXSIZE);

            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex1 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[0];
                wIndex2 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[1];
                lpV1 = 
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex1+wIndxBase, P2FVFOff);

                //We need to check each vertex separately
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                lpV1 = lpV2;
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2 + wIndxBase, P2FVFOff);

                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);
                P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV1, &P2FVFOff);

                if ( i % 2 )
                {
                    wIndex2 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[1];
                } 
                else if ( (i+1) < lpIns->wPrimitiveCount )
                {
                    // advance to the next element only if we're not done yet
                    lpPrim += sizeof(D3DHAL_DP2INDEXEDLINESTRIP);
                    wIndex2 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[0];
                }
            }

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            // Advance only as many vertex indices there are, with no padding!
            NEXTINSTRUCTION(lpIns, WORD, 
                            lpIns->wPrimitiveCount + 1, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLELIST:

            DBG_D3D((8,"D3DDP2OP_TRIANGLELIST"));

            // Non-indexed vertex buffer triangle lists are defined by 
            // the D3DHAL_DP2TRIANGLELIST structure. Given an initial
            // vertex, the driver will render independent triangles, 
            // processing three new vertices with each triangle. The
            // number of triangles to render is specified by the 
            // wPrimitveCount field of D3DHAL_DP2COMMAND. The sequence
            // of vertices processed will be  (wVStart, wVStart+1, 
            // vVStart+2), (wVStart+3, wVStart+4, vVStart+5),...,
            // (wVStart+(wPrimitiveCount-1)*3), wVStart+wPrimitiveCount*3-2, 
            // vStart+wPrimitiveCount*3-1).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2TRIANGLELIST, 1, 0);

            wIndex = ((D3DHAL_DP2TRIANGLELIST*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d, 
                         ((LONG)wIndex + 3*lpIns->wPrimitiveCount - 1) );

            
            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV0, lpV1, lpV2, &P2FVFOff);

                lpV0 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
                lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
                lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
            }
            

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLELIST"));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.

            // This is the only indexed primitive where we don't get 
            // an offset into the vertex buffer in order to maintain
            // DX3 compatibility. A new primitive 
            // (D3DDP2OP_INDEXEDTRIANGLELIST2) has been added to handle
            // the corresponding DX6 primitive.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2INDEXEDTRIANGLELIST, lpIns->wPrimitiveCount, 0);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            { 
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV2;
                wIndex3 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV3;
                wFlags  = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wFlags;


                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1, P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2, P2FVFOff);
                lpV3 = LP_FVF_VERTEX(lpVertices, wIndex3, P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex3);
                if (!CULL_TRI(pContext,lpV1,lpV2,lpV3))
                {

                    if (pContext->Hdr.FillMode == D3DFILL_POINT)
                    {
                        (*pPoint)( pContext, lpV1, &P2FVFOff);
                        (*pPoint)( pContext, lpV2, &P2FVFOff);
                        (*pPoint)( pContext, lpV3, &P2FVFOff);
                    } 
                    else if (pContext->Hdr.FillMode == D3DFILL_WIREFRAME)
                    {
                        if ( wFlags & D3DTRIFLAG_EDGEENABLE1 )
                            P2_Draw_FVF_Line( pContext,
                                              lpV1, lpV2, lpV1, &P2FVFOff);
                        if ( wFlags & D3DTRIFLAG_EDGEENABLE2 )
                            P2_Draw_FVF_Line( pContext,
                                              lpV2, lpV3, lpV1, &P2FVFOff);
                        if ( wFlags & D3DTRIFLAG_EDGEENABLE3 )
                            P2_Draw_FVF_Line( pContext,
                                              lpV3, lpV1, lpV1, &P2FVFOff);
                    }
                    else
                        (*pTriangle)(pContext, lpV1, lpV2, lpV3, &P2FVFOff);
                }

                lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST2:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLELIST2 "));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST2 structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2INDEXEDTRIANGLELIST2, lpIns->wPrimitiveCount,
                    STARTVERTEXSIZE);

            // Access base index here
            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            { 
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV2;
                wIndex3 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV3;

                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1+wIndxBase, P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2+wIndxBase, P2FVFOff);
                lpV3 = LP_FVF_VERTEX(lpVertices, wIndex3+wIndxBase, P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex3 + wIndxBase);

                if (!CULL_TRI(pContext,lpV1,lpV2,lpV3)) 
                {
                    if (pContext->Hdr.FillMode == D3DFILL_POINT)
                    {
                        (*pPoint)( pContext, lpV1, &P2FVFOff);
                        (*pPoint)( pContext, lpV2, &P2FVFOff);
                        (*pPoint)( pContext, lpV3, &P2FVFOff);
                    }
                    else if (pContext->Hdr.FillMode == D3DFILL_WIREFRAME)
                    {
                            P2_Draw_FVF_Line( pContext,
                                              lpV1, lpV2, lpV1, &P2FVFOff);
                            P2_Draw_FVF_Line( pContext,
                                              lpV2, lpV3, lpV1, &P2FVFOff);
                            P2_Draw_FVF_Line( pContext,
                                              lpV3, lpV1, lpV1, &P2FVFOff);
                    } 
                    else
                        (*pTriangle)(pContext, lpV1, lpV2, lpV3, &P2FVFOff);
                }

                lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST2, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLESTRIP:

            DBG_D3D((8,"D3DDP2OP_TRIANGLESTRIP"));

            // Non-index triangle strips rendered with vertex buffers 
            // are specified using D3DHAL_DP2TRIANGLESTRIP. The first 
            // vertex in the triangle strip is specified by wVStart. 
            // The number of triangles to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of triangles rendered for the odd-triangles case will 
            // be (wVStart, wVStart+1, vVStart+2), (wVStart+1, 
            // wVStart+3, vVStart+2),.(wVStart+2, wVStart+3, 
            // vVStart+4),.., (wVStart+wPrimitiveCount-1), 
            // wVStart+wPrimitiveCount, vStart+wPrimitiveCount+1). For an
            // even number of , the last triangle will be .,
            // (wVStart+wPrimitiveCount-1, vStart+wPrimitiveCount+1,
            // wVStart+wPrimitiveCount).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2TRIANGLESTRIP, 1, 0);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex = ((D3DHAL_DP2TRIANGLESTRIP*)lpPrim)->wVStart;
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
                lpV1 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);

                // Check first and last vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
                CHECK_DATABUF_LIMITS(lpdp2d,
                                     wIndex + lpIns->wPrimitiveCount + 1);
            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                if ( i % 2 )
                {
                    lpV0 = lpV1;
                    lpV1 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
                }
                else
                {
                    lpV0 = lpV2;
                    lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
                }

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV0, lpV1, lpV2, &P2FVFOff);
            }
            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLESTRIP:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLESTRIP"));

            // Indexed triangle strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDTRIANGLESTRIP. The number
            // of triangles to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of triangles 
            // rendered for the odd-triangles case will be 
            // (wV[0],wV[1],wV[2]),(wV[1],wV[3],wV[2]),
            // (wV[2],wV[3],wV[4]),...,(wV[wPrimitiveCount-1],
            // wV[wPrimitiveCount],wV[wPrimitiveCount+1]). For an even
            // number of triangles, the last triangle will be
            // (wV[wPrimitiveCount-1],wV[wPrimitiveCount+1],
            // wV[wPrimitiveCount]).Although the 
            // D3DHAL_DP2INDEXEDTRIANGLESTRIP structure only has 
            // enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+2 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command


            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    WORD, lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            // Access base index
            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex  = ((D3DHAL_DP2INDEXEDTRIANGLESTRIP*)lpPrim)->wV[0];
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLESTRIP*)lpPrim)->wV[1];

                // We need to check each vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);

                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex + wIndxBase, P2FVFOff);
                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1 + wIndxBase, P2FVFOff);

            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLESTRIP*)lpPrim)->wV[2];
                // We need to check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2+wIndxBase);
                if ( i % 2 )
                {
                    lpV0 = lpV1;
                    lpV1 = LP_FVF_VERTEX(lpVertices, wIndex2+wIndxBase, P2FVFOff);
                }
                else
                {
                    lpV0 = lpV2;
                    lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2+wIndxBase, P2FVFOff);
                }

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV0, lpV1, lpV2, &P2FVFOff);

                // We will advance our pointer only one WORD in order 
                // to fetch the next index
                lpPrim += sizeof(WORD);
            }
 
            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, WORD , 
                            lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLEFAN:

            DBG_D3D((8,"D3DDP2OP_TRIANGLEFAN"));

            // The D3DHAL_DP2TRIANGLEFAN structure is used to draw 
            // non-indexed triangle fans. The sequence of triangles
            // rendered will be (wVstart+1, wVStart+2, wVStart),
            // (wVStart+2,wVStart+3,wVStart), (wVStart+3,wVStart+4
            // wVStart),...,(wVStart+wPrimitiveCount,
            // wVStart+wPrimitiveCount+1,wVStart).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2TRIANGLEFAN, 1, 0);

            wIndex = ((D3DHAL_DP2TRIANGLEFAN*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex + lpIns->wPrimitiveCount + 1);

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            {
                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV1, lpV2, lpV0, &P2FVFOff);

                lpV1 = lpV2;
                lpV2 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLEFAN, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLEFAN:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLEFAN"));

            // The D3DHAL_DP2INDEXEDTRIANGLEFAN structure is used to 
            // draw indexed triangle fans. The sequence of triangles
            // rendered will be (wV[1], wV[2],wV[0]), (wV[2], wV[3],
            // wV[0]), (wV[3], wV[4], wV[0]),...,
            // (wV[wPrimitiveCount], wV[wPrimitiveCount+1],wV[0]).
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    WORD, lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex  = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[0];
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[1];
                lpV0 = LP_FVF_VERTEX(lpVertices, wIndex + wIndxBase, P2FVFOff);
                lpV1 = 
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex1 + wIndxBase, P2FVFOff);

                // We need to check each vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];
                lpV1 = lpV2;
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2 + wIndxBase, P2FVFOff);

                // We need to check each vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV1, lpV2, lpV0, &P2FVFOff);

                // We will advance our pointer only one WORD in order 
                // to fetch the next index
                lpPrim += sizeof(WORD);
            }

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, WORD , 
                            lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINELIST_IMM:

            DBG_D3D((8,"D3DDP2OP_LINELIST_IMM"));

            // Draw a set of lines specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of lines that follow. The type and size of the
            // vertices are determined by the dwVertexType member
            // of the D3DHAL_DRAWPRIMITIVES2DATA structure.

            // Primitives in an IMM instruction are stored in the
            // command buffer and are DWORD aligned
            lpPrim = (LPBYTE)((ULONG_PTR)(lpPrim + 3 ) & ~3 );

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS_S(lpdp2d, lpPrim,
                    P2FVFOff.dwStride, lpIns->wPrimitiveCount + 1, 0);

            // Get vertex pointers
            lpV0 = (LPD3DTLVERTEX)lpPrim;
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            {
                P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, &P2FVFOff);

                lpV0 = lpV1;
                lpV1 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
            }

            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            wCount = lpIns->wPrimitiveCount;
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);

            NEXTINSTRUCTION_S(lpIns, P2FVFOff.dwStride, wCount + 1, 0);

            break;

        case D3DDP2OP_TRIANGLEFAN_IMM:

            DBG_D3D((8,"D3DDP2OP_TRIANGLEFAN_IMM"));

            // Draw a triangle fan specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of triangles that follow. The type and size of the
            // vertices are determined by the dwVertexType member
            // of the D3DHAL_DRAWPRIMITIVES2DATA structure.

            // Verify the command buffer validity for the first structure
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    BYTE , 0 , sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));

            // Get Edge flags (we still have to process them)
            dwEdgeFlags = ((D3DHAL_DP2TRIANGLEFAN_IMM *)lpPrim)->dwEdgeFlags;
            lpPrim = (LPBYTE)lpPrim + sizeof(D3DHAL_DP2TRIANGLEFAN_IMM); 

            // Vertices in an IMM instruction are stored in the
            // command buffer and are DWORD aligned
            lpPrim = (LPBYTE)((ULONG_PTR)(lpPrim + 3 ) & ~3 );

            // Verify the rest of the command buffer
            CHECK_CMDBUF_LIMITS_S(lpdp2d, lpPrim,
                    P2FVFOff.dwStride, lpIns->wPrimitiveCount + 2, 0);

            // Get vertex pointers
            lpV0 = (LPD3DTLVERTEX)lpPrim;
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);

            for (i = 0 ; i < lpIns->wPrimitiveCount ; i++)
            {

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                {
                    if (pContext->Hdr.FillMode == D3DFILL_POINT)
                    {
                        if (0 == i)
                        {
                            (*pPoint)( pContext, lpV0, &P2FVFOff);
                            (*pPoint)( pContext, lpV1, &P2FVFOff);
                        }
                        (*pPoint)( pContext, lpV2, &P2FVFOff);
                    } 
                    else if (pContext->Hdr.FillMode == D3DFILL_WIREFRAME)
                    {
                        // dwEdgeFlags is a bit sequence representing the edge
                        // flag for each one of the outer edges of the 
                        // triangle fan
                        if (0 == i)
                        {
                            if (dwEdgeFlags & 0x0001)
                                P2_Draw_FVF_Line( pContext, lpV0, lpV1, lpV0,
                                                  &P2FVFOff);

                            dwEdgeFlags >>= 1;
                        }

                        if (dwEdgeFlags & 0x0001)
                            P2_Draw_FVF_Line( pContext, lpV1, lpV2, lpV0,
                                              &P2FVFOff);

                        dwEdgeFlags >>= 1;

                        if (i == (UINT)lpIns->wPrimitiveCount - 1)
                        {
                            // last triangle fan edge
                            if (dwEdgeFlags & 0x0001)
                                P2_Draw_FVF_Line( pContext, lpV2, lpV0, lpV0,
                                                  &P2FVFOff);
                        }
                    }
                    else
                        (*pTriangle)(pContext, lpV1, lpV2, lpV0, &P2FVFOff);
                }

                lpV1 = lpV2;
                lpV2 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
            }
 
            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            wCount = lpIns->wPrimitiveCount;
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);

            NEXTINSTRUCTION_S(lpIns, P2FVFOff.dwStride, 
                              wCount + 2, sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
            break;

        case D3DDP2OP_TEXBLT:
            // Inform the drivers to perform a BitBlt operation from a source
            // texture to a destination texture. A texture can also be cubic
            // environment map. The driver should copy a rectangle specified
            // by rSrc in the source texture to the location specified by pDest
            // in the destination texture. The destination and source textures
            // are identified by handles that the driver was notified with
            // during texture creation time. If the driver is capable of
            // managing textures, then it is possible that the destination
            // handle is 0. This indicates to the driver that it should preload
            // the texture into video memory (or wherever the hardware
            // efficiently textures from). In this case, it can ignore rSrc and
            // pDest. Note that for mipmapped textures, only one D3DDP2OP_TEXBLT
            // instruction is inserted into the D3dDrawPrimitives2 command stream.
            // In this case, the driver is expected to BitBlt all the mipmap
            // levels present in the texture.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                     D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);

            DBG_D3D((8,"D3DDP2OP_TEXBLT"));

            for ( i = 0; i < lpIns->wStateCount; i++)
            {
                __TextureBlt(pContext, (D3DHAL_DP2TEXBLT*)(lpPrim));
                lpPrim += sizeof(D3DHAL_DP2TEXBLT);
            }

            //need to restore following registers
            RESERVEDMAPTR(15);
            SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
            COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
            SEND_PERMEDIA_DATA(FBSourceOffset, 0x0);
            SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
            SEND_PERMEDIA_DATA(FBWindowBase,0);   
            COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);
            COPY_PERMEDIA_DATA(AlphaBlendMode, pSoftPermedia->AlphaBlendMode);
            COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
            COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
            COPY_PERMEDIA_DATA(TextureColorMode, 
                pSoftPermedia->TextureColorMode);
            COPY_PERMEDIA_DATA(TextureReadMode, 
                pSoftPermedia->TextureReadMode);
            COPY_PERMEDIA_DATA(TextureAddressMode,  
                pSoftPermedia->TextureAddressMode); 
            COPY_PERMEDIA_DATA(TextureDataFormat, 
                pSoftPermedia->TextureDataFormat);
            COPY_PERMEDIA_DATA(TextureMapFormat, 
                pSoftPermedia->TextureMapFormat);
                                           
            if (pContext->CurrentTextureHandle)
            {
                PERMEDIA_D3DTEXTURE* pTexture;
                pTexture = TextureHandleToPtr(pContext->CurrentTextureHandle,
                    pContext);
                if (NULL != pTexture)
                {
                    SEND_PERMEDIA_DATA(TextureBaseAddress, 
                           pTexture->MipLevels[0].PixelOffset);
                }
            }
            COMMITDMAPTR();

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_STATESET:
            {
                P2D3DHAL_DP2STATESET *pStateSetOp = (P2D3DHAL_DP2STATESET*)(lpPrim);
                DBG_D3D((8,"D3DDP2OP_STATESET"));
#if D3D_STATEBLOCKS
                for (i = 0; i < lpIns->wStateCount; i++, pStateSetOp++)
                {
                    switch (pStateSetOp->dwOperation)
                    {
                    case D3DHAL_STATESETBEGIN  :
                        __BeginStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEND    :
                        __EndStateSet(pContext);
                        break;
                    case D3DHAL_STATESETDELETE :
                        __DeleteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEXECUTE:
                        __ExecuteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETCAPTURE:
                        __CaptureStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    default :
                        DBG_D3D((0,"D3DDP2OP_STATESET has invalid"
                            "dwOperation %08lx",pStateSetOp->dwOperation));
                    }
                }
#endif //D3D_STATEBLOCKS
                // Update the command buffer pointer
                NEXTINSTRUCTION(lpIns, P2D3DHAL_DP2STATESET, 
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_SETPALETTE:
            // Attach a palette to a texture, that is , map an association
            // between a palette handle and a surface handle, and specify
            // the characteristics of the palette. The number of
            // D3DNTHAL_DP2SETPALETTE structures to follow is specified by
            // the wStateCount member of the D3DNTHAL_DP2COMMAND structure

            {
                D3DHAL_DP2SETPALETTE* lpSetPal =
                                            (D3DHAL_DP2SETPALETTE*)(lpPrim);

                DBG_D3D((8,"D3DDP2OP_SETPALETTE"));

                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                          D3DHAL_DP2SETPALETTE, lpIns->wStateCount, 0);

                for (i = 0; i < lpIns->wStateCount; i++, lpSetPal++)
                {
                    __PaletteSet(pContext,
                                lpSetPal->dwSurfaceHandle,
                                lpSetPal->dwPaletteHandle,
                                lpSetPal->dwPaletteFlags );
                }
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETPALETTE, 
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_UPDATEPALETTE:
            // Perform modifications to the palette that is used for palettized
            // textures. The palette handle attached to a surface is updated
            // with wNumEntries PALETTEENTRYs starting at a specific wStartIndex
            // member of the palette. (A PALETTENTRY (defined in wingdi.h and
            // wtypes.h) is actually a DWORD with an ARGB color for each byte.) 
            // After the D3DNTHAL_DP2UPDATEPALETTE structure in the command
            // stream the actual palette data will follow (without any padding),
            // comprising one DWORD per palette entry. There will only be one
            // D3DNTHAL_DP2UPDATEPALETTE structure (plus palette data) following
            // the D3DNTHAL_DP2COMMAND structure regardless of the value of
            // wStateCount.

            {
                D3DHAL_DP2UPDATEPALETTE* lpUpdatePal =
                                          (D3DHAL_DP2UPDATEPALETTE*)(lpPrim);
                PERMEDIA_D3DPALETTE* pPalette;

                DBG_D3D((8,"D3DDP2OP_UPDATEPALETTE"));

                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                           D3DHAL_DP2UPDATEPALETTE, 1,
                           lpUpdatePal->wNumEntries * sizeof(PALETTEENTRY));

                // We will ALWAYS have only 1 palette update structure + palette
                // following the D3DDP2OP_UPDATEPALETTE token
                ASSERTDD(1 == lpIns->wStateCount,
                         "1 != wStateCount in D3DDP2OP_UPDATEPALETTE");

                __PaletteUpdate(pContext,
                                        lpUpdatePal->dwPaletteHandle,
                                        lpUpdatePal->wStartIndex,
                                        lpUpdatePal->wNumEntries,
                                        (BYTE*)(lpUpdatePal+1) );

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2UPDATEPALETTE, 
                                1,
                                (DWORD)lpUpdatePal->wNumEntries * 
                                     sizeof(PALETTEENTRY));
            }
            break;

        case D3DDP2OP_SETRENDERTARGET:
            // Map a new rendering target surface and depth buffer in
            // the current context.  This replaces the old D3dSetRenderTarget
            // callback. 

            {
                D3DHAL_DP2SETRENDERTARGET* pSRTData;

                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                        D3DHAL_DP2SETRENDERTARGET, lpIns->wStateCount, 0);

                // Get new data by ignoring all but the last structure
                pSRTData = (D3DHAL_DP2SETRENDERTARGET*)lpPrim +
                           (lpIns->wStateCount - 1);

                __SetRenderTarget(pContext,
                                          pSRTData->hRenderTarget,
                                          pSRTData->hZBuffer);

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETRENDERTARGET,
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_CLEAR:
            // Perform hardware-assisted clearing on the rendering target,
            // depth buffer or stencil buffer. This replaces the old D3dClear
            // and D3dClear2 callbacks. 

            {
                D3DHAL_DP2CLEAR* pClear;
                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                        RECT, lpIns->wStateCount, 
                        (sizeof(D3DHAL_DP2CLEAR) - sizeof(RECT)));

                // Get new data by ignoring all but the last structure
                pClear = (D3DHAL_DP2CLEAR*)lpPrim;

                DBG_D3D((8,"D3DDP2OP_CLEAR dwFlags=%08lx dwColor=%08lx "
                           "dvZ=%08lx dwStencil=%08lx",
                           pClear->dwFlags,
                           pClear->dwFillColor,
                           (DWORD)(pClear->dvFillDepth*0x0000FFFF),
                           pClear->dwFillStencil));

                __Clear(pContext, 
                                pClear->dwFlags,        // in:  surfaces to clear
                                pClear->dwFillColor,    // in:  Color value for rtarget
                                pClear->dvFillDepth,    // in:  Depth value for
                                                        //      Z-buffer (0.0-1.0)
                                pClear->dwFillStencil,  // in:  value used to clear stencil
                                                        // in:  Rectangles to clear
                                (LPD3DRECT)((LPBYTE)pClear + 
                                         sizeof(D3DHAL_DP2CLEAR) -
                                         sizeof(RECT)),
                                (DWORD)lpIns->wStateCount); // in:  Number of rectangles
                //need to restore following registers
                RESERVEDMAPTR(4);
                SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
                COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
                SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
                SEND_PERMEDIA_DATA(FBWindowBase,0);   
                COMMITDMAPTR();
                NEXTINSTRUCTION(lpIns, RECT, lpIns->wStateCount, 
                                (sizeof(D3DHAL_DP2CLEAR) - sizeof(RECT))); 
            }
            break;

#if D3DDX7_TL
        case D3DDP2OP_SETMATERIAL:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETMATERIAL,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_SETLIGHT:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETLIGHT,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_CREATELIGHT:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2CREATELIGHT,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_SETTRANSFORM:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETTRANSFORM,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_ZRANGE:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2ZRANGE,
                            lpIns->wStateCount, 0);
            break;
#endif //D3DDX7_TL

        default:

            ASSERTDD((pContext->ppdev->pD3DParseUnknownCommand),
                     "D3D DX6 ParseUnknownCommand callback == NULL");

            // Call the ParseUnknown callback to process 
            // any unidentifiable token
            ddrval = (pContext->ppdev->pD3DParseUnknownCommand)
                                 ( (VOID **) lpIns , (VOID **) &lpResumeIns);
            if ( SUCCEEDED(ddrval) )
            {
                // Resume buffer processing after D3DParseUnknownCommand
                // was succesful in processing an unknown command
                lpIns = lpResumeIns;
                break;
            }

            DBG_D3D((2,"unhandled opcode (%d)- returning "
                        "D3DERR_COMMAND_UNPARSED @ addr %x",
                        lpIns->bCommand,lpIns));

            PARSE_ERROR_AND_EXIT( lpdp2d, lpIns, lpInsStart, ddrval);
        } // switch

    } //while

    lpdp2d->ddrval = DD_OK;

Exit_DrawPrimitives2:

    // any necessary housekeeping can be done here before leaving

    DBG_D3D((6,"Exiting D3DDrawPrimitives2"));

    return DDHAL_DRIVER_HANDLED;
} // D3DDrawPrimitives2


//-----------------------------Public Routine----------------------------------
//
// DWORD D3DValidateTextureStageState
//
// ValidateTextureStageState evaluates the current state for blending 
// operations (including multitexture) and returns the number of passes the 
// hardware can do it in. This is a mechanism to query the driver about 
// whether it is able to handle the current stage state setup that has been 
// set up in hardware.  For example, some hardware cannot do two simultaneous 
// modulate operations because they have only one multiplication unit and one 
// addition unit.  
//
// The other reason for this function is that some hardware may not map 
// directly onto the Direct3D state architecture. This is a mechanism to map 
// the hardware's capabilities onto what the Direct3D DDI expects.
//
// Parameters
//
//      lpvtssd
//
//          .dwhContext
//               Context handle
//          .dwFlags
//               Flags, currently set to 0
//          .dwReserved
//               Reserved
//          .dwNumPasses
//               Number of passes the hardware can perform the operation in
//          .ddrval
//               return value
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DValidateTextureStageState( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA lpvtssd )
{
    PERMEDIA_D3DTEXTURE *lpTexture;
    PERMEDIA_D3DCONTEXT *pContext;
    DWORD mag, min, cop, ca1, ca2, aop, aa1, aa2;

    DBG_D3D((6,"Entering D3DValidateTextureStageState"));

    pContext = (PERMEDIA_D3DCONTEXT*)ContextSlots[lpvtssd->dwhContext];

    // Check if we got a valid context handle.
    CHK_CONTEXT(pContext, lpvtssd->ddrval, "D3DValidateTextureStageState");

    lpvtssd->dwNumPasses = 0;
    lpvtssd->ddrval =  DD_OK;

    mag = pContext->TssStates[D3DTSS_MAGFILTER];
    min = pContext->TssStates[D3DTSS_MINFILTER];
    cop = pContext->TssStates[D3DTSS_COLOROP];
    ca1 = pContext->TssStates[D3DTSS_COLORARG1];
    ca2 = pContext->TssStates[D3DTSS_COLORARG2];
    aop = pContext->TssStates[D3DTSS_ALPHAOP];
    aa1 = pContext->TssStates[D3DTSS_ALPHAARG1];
    aa2 = pContext->TssStates[D3DTSS_ALPHAARG2];

    if (!pContext->TssStates[D3DTSS_TEXTUREMAP])
    {
        lpvtssd->dwNumPasses = 1;

        // Current is the same as diffuse in stage 0
        if (ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if (aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        // Check TSS even with texture handle = 0 since
        // certain operations with the fragments colors might
        // be  possible. Here we only allow plain "classic" rendering

        if ((ca1 == D3DTA_DIFFUSE )    && 
            (cop == D3DTOP_SELECTARG1) &&
            (aa1 == D3DTA_DIFFUSE )    &&
            (aop == D3DTOP_SELECTARG1))
        {
        }
        else if ((ca2 == D3DTA_DIFFUSE )    && 
                 (cop == D3DTOP_SELECTARG2) &&
                 (aa2 == D3DTA_DIFFUSE) &&
                 (aop == D3DTOP_SELECTARG2))
        {
        } 
        // Default modulation
        else if ((ca2 == D3DTA_DIFFUSE)   && 
                 (ca1 == D3DTA_TEXTURE)   && 
                 (cop == D3DTOP_MODULATE) &&
                 (aa1 == D3DTA_TEXTURE)   && 
                 (aop == D3DTOP_SELECTARG1)) 
        {
        }
        // Check disable
        else if (cop == D3DTOP_DISABLE) 
        {
        }
        else
            goto Fail_Validate;
    }
    else
    if ((mag != D3DTFG_POINT && mag != D3DTFG_LINEAR) || 
        (min != D3DTFG_POINT && min != D3DTFG_LINEAR)
       )
    {
        lpvtssd->ddrval = D3DERR_CONFLICTINGTEXTUREFILTER;
        DBG_D3D((2,"D3DERR_CONFLICTINGTEXTUREFILTER"));
    }
    else
    {
        lpvtssd->dwNumPasses = 1;

        // Current is the same as diffuse in stage 0
        if (ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if (aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        // Check decal
        if ((ca1 == D3DTA_TEXTURE )    && 
           (cop == D3DTOP_SELECTARG1) &&
           (aa1 == D3DTA_TEXTURE)     && 
           (aop == D3DTOP_SELECTARG1))
        {
        }
        // Check all modulate variations
        else if ((ca2 == D3DTA_DIFFUSE)   && 
                 (ca1 == D3DTA_TEXTURE)   && 
                 (cop == D3DTOP_MODULATE))
        {
            if (
                // legacy (DX5) mode
                ((aa1 == D3DTA_TEXTURE)   && 
                (aop == D3DTOP_LEGACY_ALPHAOVR)) ||
                // modulate color & pass diffuse alpha
                ((aa2 == D3DTA_DIFFUSE)   && 
                     (aop == D3DTOP_SELECTARG2))
               )

            {
                PermediaSurfaceData* pPrivateData;

                // Get Texture for current stage (0) to verify properties
                lpTexture = TextureHandleToPtr(
                                    pContext->TssStates[D3DTSS_TEXTUREMAP],
                                    pContext);

                if (!CHECK_D3DSURFACE_VALIDITY(lpTexture))
                {
                    // we're lacking key information about the texture
                    DBG_D3D((0,"D3DValidateTextureStageState gets "
                               "NULL == lpTexture"));
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    goto Exit_ValidateTSS;
                }

                pPrivateData = lpTexture->pTextureSurface;

                if (NULL == pPrivateData)
                {
                    // we're lacking key information about the texture
                    DBG_D3D((0,"D3DValidateTextureStageState gets "
                               "NULL == lpTexture->pTextureSurface"));
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    goto Exit_ValidateTSS;
                }

                // legacy texture modulation must have texture alpha
                if (!pPrivateData->SurfaceFormat.bAlpha &&
                    (aop == D3DTOP_LEGACY_ALPHAOVR))
                {
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    DBG_D3D((2,"D3DERR_WRONGTEXTUREFORMAT a format "
                               "with alpha must be used"));
                    goto Exit_ValidateTSS;
                }

                // modulation w diffuse alpha channel must lack texture
                // alpha channel due to Permedia2 limitations on 
                // texture blending operations
                if (pPrivateData->SurfaceFormat.bAlpha &&
                    (aop == D3DTOP_SELECTARG2))
                {
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    DBG_D3D((2,"D3DERR_WRONGTEXTUREFORMAT a format "
                               "with alpha must be used"));
                    goto Exit_ValidateTSS;
                }
            }
            // modulate alpha
            else if ((aa2 == D3DTA_DIFFUSE)   && 
                     (aa1 == D3DTA_TEXTURE)   && 
                     (aop == D3DTOP_MODULATE))
            {
            }
            // modulate color & pass texture alpha
            else if ((aa1 == D3DTA_TEXTURE)   && 
                     (aop == D3DTOP_SELECTARG1)) 
            {
            }
            else
            {
                goto Fail_Validate;
            }
        }
        // Check decal alpha
        else if ((ca2 == D3DTA_DIFFUSE)            && 
                 (ca1 == D3DTA_TEXTURE)            && 
                 (cop == D3DTOP_BLENDTEXTUREALPHA) &&
                 (aa2 == D3DTA_DIFFUSE)            && 
                 (aop == D3DTOP_SELECTARG2))
        {
        }

        // Check add
        else if ((ca2 == D3DTA_DIFFUSE) && 
                 (ca1 == D3DTA_TEXTURE) && 
                 (cop == D3DTOP_ADD)    &&
                 (aa2 == D3DTA_DIFFUSE) && 
                 (aop == D3DTOP_SELECTARG2))
        {
        }
        // Check disable
        else if ((cop == D3DTOP_DISABLE) || 
                  (cop == D3DTOP_SELECTARG2 && 
                   ca2 == D3DTA_DIFFUSE     && 
                   aop == D3DTOP_SELECTARG2 && 
                   aa2 == D3DTA_DIFFUSE)       )
        {
        }
        // Don't understand
        else {
Fail_Validate:
            DBG_D3D((4,"Failing with cop=%d ca1=%d ca2=%d aop=%d aa1=%d aa2=%d",
                       cop,ca1,ca2,aop,aa1,aa2));

            if (!((cop == D3DTOP_DISABLE)           ||
                  (cop == D3DTOP_ADD)               ||
                  (cop == D3DTOP_MODULATE)          ||
                  (cop == D3DTOP_BLENDTEXTUREALPHA) ||
                  (cop == D3DTOP_SELECTARG2)        ||
                  (cop == D3DTOP_SELECTARG1)))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLOROPERATION;
            
            else if (!((aop == D3DTOP_SELECTARG1)      ||
                       (aop == D3DTOP_SELECTARG2)      ||
                       (aop == D3DTOP_MODULATE)        ||
                       (aop == D3DTOP_LEGACY_ALPHAOVR)))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAOPERATION;

            else if (!(ca1 == D3DTA_TEXTURE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLORARG;

            else if (!(ca2 == D3DTA_DIFFUSE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLORARG;

            else if (!(aa1 == D3DTA_TEXTURE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAARG;

            else if (!(aa2 == D3DTA_DIFFUSE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAARG;
            else
                 lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLOROPERATION;

            lpvtssd->dwNumPasses = 0;
            DBG_D3D((2,"D3DERR_UNSUPPORTEDCOLOROPERATION"));
            goto Exit_ValidateTSS;
        }
    }
Exit_ValidateTSS:
    DBG_D3D((6,"Exiting D3DValidateTextureStageState with dwNumPasses=%d",
                                                    lpvtssd->dwNumPasses));

    return DDHAL_DRIVER_HANDLED;
} // D3DValidateTextureStageState

//-----------------------------Public Routine----------------------------------
//
// DWORD __CheckFVFRequest
//
// This utility function verifies that the requested FVF format makes sense
// and computes useful offsets into the data and a stride between succesive
// vertices.
//
//-----------------------------------------------------------------------------
DWORD 
__CheckFVFRequest(DWORD dwFVF, LPP2FVFOFFSETS lpP2FVFOff)
{
    DWORD stride;
    UINT iTexCount; 

    DBG_D3D((10,"Entering __CheckFVFRequest"));

    memset(lpP2FVFOff, 0, sizeof(P2FVFOFFSETS));

    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    lpP2FVFOff->dwStride = sizeof(D3DVALUE) * 3;

    if (dwFVF & D3DFVF_XYZRHW)
    {
        lpP2FVFOff->dwStride += sizeof(D3DVALUE);
    }

    if (dwFVF & D3DFVF_DIFFUSE)
    {
        lpP2FVFOff->dwColOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwStride += sizeof(D3DCOLOR);
    }

    if (dwFVF & D3DFVF_SPECULAR)
    {
        lpP2FVFOff->dwSpcOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwStride  += sizeof(D3DCOLOR);
    }


//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    if (dwFVF & D3DFVF_S)
    {
        lpP2FVFOff->dwPntSizeOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwStride  += sizeof(D3DVALUE);
    }
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

    iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    if (iTexCount >= 1)
    {
        lpP2FVFOff->dwTexBaseOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwTexOffset = lpP2FVFOff->dwTexBaseOffset;

        if (0xFFFF0000 & dwFVF)
        {
            //expansion of FVF, these 16 bits are designated for up to 
            //8 sets of texture coordinates with each set having 2bits
            //Normally a capable driver has to process all coordinates
            //However, code below only show correct parsing w/o really
            //observing all the texture coordinates.In reality,this would 
            //result in incorrect result.
            UINT i,numcoord;
            DWORD extrabits;
            for (i = 0; i < iTexCount; i++)
            {
                extrabits= (dwFVF >> (16+2*i)) & 0x0003;
                switch(extrabits)
                {
                case    1:
                    // one more D3DVALUE for 3D textures
                    numcoord = 3;
                    break;
                case    2:
                    // two more D3DVALUEs for 4D textures
                    numcoord = 4;
                    break;
                case    3:
                    // one less D3DVALUE for 1D textures
                    numcoord = 1;
                    break;
                default:
                    // i.e. case 0 regular 2 D3DVALUEs
                    numcoord = 2;
                    break;
                }

                DBG_D3D((0,"Expanded TexCoord set %d has a offset %8lx",
                           i,lpP2FVFOff->dwStride));
                lpP2FVFOff->dwStride += sizeof(D3DVALUE) * numcoord;
            }
            DBG_D3D((0,"Expanded dwVertexType=0x%08lx has %d Texture Coords "
                       "with total stride=0x%08lx",
                       dwFVF, iTexCount, lpP2FVFOff->dwStride));
        }
        else
            lpP2FVFOff->dwStride   += iTexCount * sizeof(D3DVALUE) * 2;
    } 
    else
    {
        lpP2FVFOff->dwTexBaseOffset = 0;
        lpP2FVFOff->dwTexOffset = 0;
    }

    DBG_D3D((10,"Exiting __CheckFVFRequest"));
    return DD_OK;
} // __CheckFVFRequest

//-----------------------------------------------------------------------------
//
// D3DFVFDRAWTRIFUNCPTR __HWSetTriangleFunc
//
// Select the appropiate triangle rendering function depending on the
// current fillmode set for the current context
//
//-----------------------------------------------------------------------------
D3DFVFDRAWTRIFUNCPTR 
__HWSetTriangleFunc(PERMEDIA_D3DCONTEXT *pContext)
{

    if ( pContext->Hdr.FillMode == D3DFILL_SOLID )
        return P2_Draw_FVF_Solid_Tri;
    else
    {
        if ( pContext->Hdr.FillMode == D3DFILL_WIREFRAME )
            return P2_Draw_FVF_Wire_Tri;
        else
            // if it isn't solid nor line it must be a point filled triangle
            return P2_Draw_FVF_Point_Tri;
    }
}


//-----------------------------------------------------------------------------
//
// D3DFVFDRAWPNTFUNCPTR __HWSetPointFunc
//
// Select the appropiate point rendering function depending on the
// current point sprite mode  set for the current context
//
//-----------------------------------------------------------------------------
D3DFVFDRAWPNTFUNCPTR 
__HWSetPointFunc(PERMEDIA_D3DCONTEXT *pContext, LPP2FVFOFFSETS lpP2FVFOff)
{
//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    // Only if we are not enabling point sprites and the default point size
    // is 1.0f and vertexes don't have their own point size, then use 
    // classical points for rendering
    if ( pContext->bPointSpriteEnabled ||
         (pContext->fPointSize != 1.0f) ||
         (lpP2FVFOff->dwPntSizeOffset) )
        return P2_Draw_FVF_Point_Sprite;
    else
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT
        return P2_Draw_FVF_Point;
}


//-----------------------------------------------------------------------------
//
// void __TextureBlt
//
// Transfer a texture from system memory into AGP or video memory
//-----------------------------------------------------------------------------
HRESULT 
__TextureBlt(PERMEDIA_D3DCONTEXT* pContext,
             D3DHAL_DP2TEXBLT* lpdp2texblt)
{
    PPERMEDIA_D3DTEXTURE dsttex,srctex;
    RECTL rDest;
    PPDev ppdev=pContext->ppdev;

    DBG_D3D((10,"Entering __TextureBlt"));

    if (0 == lpdp2texblt->dwDDSrcSurface)
    {
        DBG_D3D((0,"Inavlid handle TexBlt from %08lx to %08lx",
            lpdp2texblt->dwDDSrcSurface,lpdp2texblt->dwDDDestSurface));
        return DDERR_INVALIDPARAMS;
    }

    srctex = TextureHandleToPtr(lpdp2texblt->dwDDSrcSurface,pContext);

    if(!CHECK_D3DSURFACE_VALIDITY(srctex))
    {
        DBG_D3D((0,"D3DDP2OP_TEXBLT: invalid dwDDSrcSurface !"));
        return DDERR_INVALIDPARAMS;
    }

    if (0 == lpdp2texblt->dwDDDestSurface)
    {
        PPERMEDIA_D3DTEXTURE pTexture = srctex;
        PermediaSurfaceData* pPrivateData = pTexture->pTextureSurface;
        if (!(pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
        {
            DBG_D3D((0,"Must be a managed texture to do texture preload"));
            return DDERR_INVALIDPARAMS;
        }
        if (NULL==pPrivateData->fpVidMem)
        {
            TextureCacheManagerAllocNode(pContext,pTexture);
            if (NULL==pPrivateData->fpVidMem)
            {
                DBG_D3D((0,"EnableTexturePermedia unable to "
                    "allocate memory from heap"));
                return DDERR_OUTOFVIDEOMEMORY;
            }
            pPrivateData->dwFlags |= P2_SURFACE_NEEDUPDATE;
        }
        if (pPrivateData->dwFlags & P2_SURFACE_NEEDUPDATE)
        {
            RECTL   rect;
            rect.left=rect.top=0;
            rect.right=pTexture->wWidth;
            rect.bottom=pTexture->wHeight;
            // texture download
            // Switch to DirectDraw context
            pPrivateData->dwFlags &= ~P2_SURFACE_NEEDUPDATE;
            // .. Convert it to Pixels

            pTexture->MipLevels[0].PixelOffset = 
                (ULONG)(pPrivateData->fpVidMem);
            switch(pTexture->pTextureSurface->SurfaceFormat.PixelSize) 
            {
                case __PERMEDIA_4BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset <<= 1;
                    break;
                case __PERMEDIA_8BITPIXEL: /* No Change*/
                    break;
                case __PERMEDIA_16BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset >>= 1;
                    break;
                case __PERMEDIA_24BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset /=  3;
                    break;
                case __PERMEDIA_32BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset >>= 2;
                    break;
                default:
                    ASSERTDD(0,"Invalid Texture Pixel Size!");
                    pTexture->MipLevels[0].PixelOffset >>=  1;
                    break;
            }
            PermediaPatchedTextureDownload(pContext->ppdev, 
                                       pPrivateData,
                                       pTexture->fpVidMem,
                                       pTexture->lPitch,
                                       &rect,
                                       pPrivateData->fpVidMem,
                                       pTexture->lPitch,
                                       &rect);
            DBG_D3D((10, "Copy from %08lx to %08lx w=%08lx h=%08lx "
                "p=%08lx b=%08lx",
                pTexture->fpVidMem,pPrivateData->fpVidMem,pTexture->wWidth,
                pTexture->wHeight,pTexture->lPitch,pTexture->dwRGBBitCount));
        }
        return DD_OK;
    }
    else
    {
        dsttex = TextureHandleToPtr(lpdp2texblt->dwDDDestSurface,pContext);

        if(!CHECK_D3DSURFACE_VALIDITY(dsttex))
        {
            DBG_D3D((0,"D3DDP2OP_TEXBLT: invalid dwDDDestSurface !"));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (NULL != dsttex && NULL != srctex)
    {
        rDest.left = lpdp2texblt->pDest.x;
        rDest.top = lpdp2texblt->pDest.y;
        rDest.right = rDest.left + lpdp2texblt->rSrc.right
                                         - lpdp2texblt->rSrc.left;
        rDest.bottom = rDest.top + lpdp2texblt->rSrc.bottom 
                                         - lpdp2texblt->rSrc.top;

        DBG_D3D((4,"TexBlt from %d %08lx %08lx to %d %08lx %08lx",
            lpdp2texblt->dwDDSrcSurface,srctex->dwCaps,srctex->dwCaps2,
            lpdp2texblt->dwDDDestSurface,dsttex->dwCaps,dsttex->dwCaps2));

        dsttex->dwPaletteHandle = srctex->dwPaletteHandle;
        dsttex->pTextureSurface->dwPaletteHandle = srctex->dwPaletteHandle;
        if ((DDSCAPS_VIDEOMEMORY & srctex->dwCaps) &&
            !(DDSCAPS2_TEXTUREMANAGE & srctex->dwCaps2))
        {
            PermediaSurfaceData* pPrivateDest = dsttex->pTextureSurface;
            PermediaSurfaceData* pPrivateSource = srctex->pTextureSurface;
            // If the surface sizes don't match, then we are stretching.
            // Also the blits from Nonlocal- to Videomemory have to go through
            // the texture unit!
            if (!(DDSCAPS_VIDEOMEMORY & dsttex->dwCaps) ||
                (DDSCAPS2_TEXTUREMANAGE & dsttex->dwCaps2))
            {
                DBG_DD((0,"DDBLT_ROP: NOT ABLE TO BLT FROM "
                          "VIDEO TO NON-VIDEO SURFACE"));
                return DDERR_INVALIDPARAMS;
            }
            if ( DDSCAPS_NONLOCALVIDMEM & srctex->dwCaps)
            {
                DBG_DD((3,"DDBLT_ROP: STRETCHCOPYBLT OR "
                          "MIRROR OR BOTH OR AGPVIDEO"));

                PermediaStretchCopyBlt( ppdev, 
                                        NULL, 
                                        pPrivateDest,
                                        pPrivateSource,
                                        &rDest,
                                        &lpdp2texblt->rSrc, 
                                        dsttex->MipLevels[0].PixelOffset, 
                                        srctex->MipLevels[0].PixelOffset);
            }
            else
            {
                ULONG   ulDestPixelShift=ShiftLookup[dsttex->dwRGBBitCount>>3];
                LONG    lPixPitchDest = dsttex->lPitch >> ulDestPixelShift;
                LONG    lPixPitchSrc = srctex->lPitch >> ulDestPixelShift;
                LONG    srcOffset=(LONG)((srctex->fpVidMem - dsttex->fpVidMem)
                                >> ulDestPixelShift);
                DBG_DD((3,"DDBLT_ROP:  COPYBLT %08lx %08lx %08lx",
                    srctex->fpVidMem, dsttex->fpVidMem, ulDestPixelShift));

                // For some reason, the user might want 
                // to do a conversion on the data as it is
                // blitted from VRAM->VRAM by turning on Patching. 
                // If Surf1Patch XOR Surf2Patch then
                // do a special blit that isn't packed and does patching.
                if (((pPrivateDest->dwFlags & P2_CANPATCH) ^ 
                     (pPrivateSource->dwFlags & P2_CANPATCH)) 
                       & P2_CANPATCH)
                {
                    DBG_DD((4,"Doing Patch-Conversion!"));

                    PermediaPatchedCopyBlt( ppdev, 
                                            lPixPitchDest, 
                                            lPixPitchSrc, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &lpdp2texblt->rSrc, 
                                            dsttex->MipLevels[0].PixelOffset, 
                                            srcOffset);
                }
                else
                {
                    DBG_DD((4,"Doing PermediaPackedCopyBlt!"));
                    PermediaPackedCopyBlt(  ppdev, 
                                            lPixPitchDest, 
                                            lPixPitchSrc, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &lpdp2texblt->rSrc, 
                                            dsttex->MipLevels[0].PixelOffset, 
                                            srcOffset);
                }
            }
        }
        else
        if (dsttex->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            // texture download
            if (pContext->CurrentTextureHandle == lpdp2texblt->dwDDDestSurface) 
                DIRTY_TEXTURE;
            dsttex->pTextureSurface->dwFlags |= P2_SURFACE_NEEDUPDATE;
            SysMemToSysMemSurfaceCopy(
                srctex->fpVidMem,
                srctex->lPitch,
                srctex->dwRGBBitCount,
                dsttex->fpVidMem,
                dsttex->lPitch,
                dsttex->dwRGBBitCount, 
                &lpdp2texblt->rSrc, 
                &rDest);
        }
        else
        if (DDSCAPS_NONLOCALVIDMEM & dsttex->dwCaps)
        {
            // Blt from system to AGP memory
            SysMemToSysMemSurfaceCopy(srctex->fpVidMem,
                                      srctex->lPitch,
                                      srctex->dwRGBBitCount,
                                      dsttex->fpVidMem,
                                      dsttex->lPitch,
                                      dsttex->dwRGBBitCount,
                                      &lpdp2texblt->rSrc,
                                      &rDest);
        }
        else
        if (DDSCAPS_LOCALVIDMEM & dsttex->dwCaps)
        {
            // texture download
            PermediaPatchedTextureDownload(ppdev, 
                                           dsttex->pTextureSurface,
                                           srctex->fpVidMem,
                                           srctex->lPitch,
                                           &lpdp2texblt->rSrc,
                                           dsttex->fpVidMem,
                                           dsttex->lPitch,
                                           &rDest);
        }
        else
        {
            DBG_DD((0,"DDBLT_ROP: NOT ABLE TO BLT FROM "
                      "SYSTEM TO NON-VIDEO SURFACE"));
            return DDERR_INVALIDPARAMS;
        }
    }

    DBG_D3D((10,"Exiting __TextureBlt"));
    return DD_OK;
}   //__TextureBlt

//-----------------------------------------------------------------------------
//
// void __SetRenderTarget
//
// Set new render and z buffer target surfaces
//-----------------------------------------------------------------------------
            
HRESULT  __SetRenderTarget(PERMEDIA_D3DCONTEXT* pContext,
                       DWORD hRenderTarget,
                       DWORD hZBuffer)
{
    DBG_D3D((10,"Entering __SetRenderTarget Target=%d Z=%d",
                                        hRenderTarget,hZBuffer));
    // Call a function to initialise registers that will setup the rendering
    pContext->RenderSurfaceHandle = hRenderTarget;
    pContext->ZBufferHandle = hZBuffer;
    SetupPermediaRenderTarget(pContext);

    // The AlphaBlending may need to be changed.
    DIRTY_ALPHABLEND;

    // Dirty the Z Buffer (the new target may not have one)
    DIRTY_ZBUFFER;

    DBG_D3D((10,"Exiting __SetRenderTarget"));

    return DD_OK;
} // __SetRenderTarget


//-----------------------------------------------------------------------------
//
// void __Clear
//
// Clears selectively the frame buffer, z buffer and stencil buffer for the 
// D3D Clear2 callback and for the D3DDP2OP_CLEAR command token.
//
//-----------------------------------------------------------------------------
HRESULT  __Clear( PERMEDIA_D3DCONTEXT* pContext,
              DWORD   dwFlags,        // in:  surfaces to clear
              DWORD   dwFillColor,    // in:  Color value for rtarget
              D3DVALUE dvFillDepth,   // in:  Depth value for
                                      //      Z-buffer (0.0-1.0)
              DWORD   dwFillStencil,  // in:  value used to clear stencil buffer
              LPD3DRECT lpRects,      // in:  Rectangles to clear
              DWORD   dwNumRects)     // in:  Number of rectangles
{
    int i;
    PermediaSurfaceData*    pPrivateData;
    RECTL*  pRect;
    PPDev   ppdev=pContext->ppdev;
    PERMEDIA_DEFS(pContext->ppdev);

    if (D3DCLEAR_TARGET & dwFlags)
    {
        DWORD   a,r,g,b;

        PPERMEDIA_D3DTEXTURE    pSurfRender = 
            TextureHandleToPtr(pContext->RenderSurfaceHandle, pContext);

        if(!CHECK_D3DSURFACE_VALIDITY(pSurfRender))
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: invalid RenderSurfaceHandle !"));
            return DDERR_INVALIDPARAMS;
        }

        pPrivateData = pSurfRender->pTextureSurface;

        if( NULL == pPrivateData)
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: NULL == pPrivateData(pSurfRender)!"));
            return DDERR_INVALIDPARAMS;
        }

        // Translate into HW specific format
        a = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.AlphaMask, 0x80000000);
        r = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.RedMask, 0x00800000);
        g = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.GreenMask, 0x00008000);
        b = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.BlueMask, 0x00000080);

        dwFillColor = a | r | g | b;

        DBG_D3D((8,"D3DDP2OP_CLEAR convert to %08lx with Mask %8lx %8lx %8lx",
                   dwFillColor,
                   pPrivateData->SurfaceFormat.RedMask,
                   pPrivateData->SurfaceFormat.GreenMask,
                   pPrivateData->SurfaceFormat.BlueMask));

        pRect = (RECTL*)lpRects;

        // Do clear for each Rect that we have
        for (i = dwNumRects; i > 0; i--)
        {
            PermediaFastClear(ppdev, pPrivateData,  
                pRect, pContext->PixelOffset, dwFillColor);
            pRect++;
        }
    }

    if (((D3DCLEAR_ZBUFFER
#if D3D_STENCIL
        | D3DCLEAR_STENCIL
#endif  //D3D_STENCIL
        ) & dwFlags) 
        && (0 != pContext->ZBufferHandle))
    {
        DWORD   dwZbufferClearValue = 0x0000FFFF; //no stencil case
        DWORD   dwWriteMask;
        PPERMEDIA_D3DTEXTURE    pSurfZBuffer = 
            TextureHandleToPtr(pContext->ZBufferHandle, pContext);

        if(!CHECK_D3DSURFACE_VALIDITY(pSurfZBuffer))
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: invalid ZBufferHandle !"));
            return DDERR_INVALIDPARAMS;
        }

        // get z buffer pixelformat info
        pPrivateData = pSurfZBuffer->pTextureSurface;

        if( NULL == pPrivateData)
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: NULL == pPrivateData(pSurfZBuffer)!"));
            return DDERR_INVALIDPARAMS;
        }

#if D3D_STENCIL
        //actually check dwStencilBitMask
        if (0 == pPrivateData->SurfaceFormat.BlueMask)
        {
            dwWriteMask = 0xFFFFFFFF;   //all 16bits are for Z
            dwZbufferClearValue = (DWORD)(dvFillDepth*0x0000FFFF);
        }
        else
        {
            dwWriteMask = 0;
            dwZbufferClearValue = (DWORD)(dvFillDepth*0x00007FFF);

            if (D3DCLEAR_ZBUFFER & dwFlags)
                dwWriteMask |= 0x7FFF7FFF;

            if (D3DCLEAR_STENCIL & dwFlags)
            {
                dwWriteMask |= 0x80008000;
                if (0 != dwFillStencil)
                {
                    dwZbufferClearValue |= 0x8000;  //or stencil bit
                }
            }
            if (0xFFFFFFFF != dwWriteMask)
            {
                RESERVEDMAPTR(1);
                SEND_PERMEDIA_DATA(FBHardwareWriteMask, dwWriteMask);
                COMMITDMAPTR();
            }
        }
#endif  //D3D_STENCIL

        pRect = (RECTL*)lpRects;

        for (i = dwNumRects; i > 0; i--)
        {                
            PermediaFastLBClear(ppdev, pPrivateData, pRect,
                (DWORD)((UINT_PTR)pSurfZBuffer->fpVidMem >> P2DEPTH16), 
                dwZbufferClearValue);
            pRect++;
        }

#if D3D_STENCIL
        // Restore the LB write mask is we didn't clear stencil & zbuffer
        if (0xFFFFFFFF != dwWriteMask)
        {
            RESERVEDMAPTR(1);
            SEND_PERMEDIA_DATA(FBHardwareWriteMask, 0xFFFFFFFF);    //restore
            COMMITDMAPTR();
        }
#endif  //D3D_STENCIL
    }
    
    return DD_OK;

} // __Clear

//-----------------------------------------------------------------------------
//
// void __PaletteSet
//
// Attaches a palette handle to a texture in the given context
// The texture is the one associated to the given surface handle.
//
//-----------------------------------------------------------------------------
HRESULT 
__PaletteSet(PERMEDIA_D3DCONTEXT* pContext,
             DWORD dwSurfaceHandle,
             DWORD dwPaletteHandle,
             DWORD dwPaletteFlags)
{
    PERMEDIA_D3DTEXTURE * pTexture;

    ASSERTDD(0 != dwSurfaceHandle, "dwSurfaceHandle==0 in D3DDP2OP_SETPALETTE");

    DBG_D3D((8,"SETPALETTE %d to %d", dwPaletteHandle, dwSurfaceHandle));

    pTexture = TextureHandleToPtr(dwSurfaceHandle, pContext);

    if (!CHECK_D3DSURFACE_VALIDITY(pTexture))
    {
        DBG_D3D((0,"__PaletteSet:NULL==pTexture Palette=%08lx Surface=%08lx", 
            dwPaletteHandle, dwSurfaceHandle));
        return DDERR_INVALIDPARAMS;   // invalid dwSurfaceHandle, skip it
    }

    pTexture->dwPaletteHandle = dwPaletteHandle;
    // need to make it into private data if driver created this surface
    if (NULL != pTexture->pTextureSurface)
        pTexture->pTextureSurface->dwPaletteHandle = dwPaletteHandle;
    if (pContext->CurrentTextureHandle == dwSurfaceHandle) 
        DIRTY_TEXTURE;
    if (0 == dwPaletteHandle)
    {
        return D3D_OK;  //palette association is OFF
    }

    // Check if we need to grow our palette list for this handle element
    if (NULL == pContext->pHandleList->dwPaletteList ||
        dwPaletteHandle >= PtrToUlong(pContext->pHandleList->dwPaletteList[0]))
    {
        DWORD newsize = ((dwPaletteHandle + 
                                LISTGROWSIZE)/LISTGROWSIZE)*LISTGROWSIZE;
        PPERMEDIA_D3DPALETTE *newlist = (PPERMEDIA_D3DPALETTE *)
                  ENGALLOCMEM( FL_ZERO_MEMORY, 
                               sizeof(PPERMEDIA_D3DPALETTE)*newsize,
                               ALLOC_TAG);

        DBG_D3D((8,"Growing pDDLcl=%x's "
                   "PaletteList[%x] size to %08lx",
                  pContext->pDDLcl, newlist, newsize));

        if (NULL == newlist)
        {
            DBG_D3D((0,"D3DDP2OP_SETPALETTE Out of memory."));
            return DDERR_OUTOFMEMORY;
        }

        memset(newlist,0,newsize);

        if (NULL != pContext->pHandleList->dwPaletteList)
        {
            memcpy(newlist,pContext->pHandleList->dwPaletteList,
                   PtrToUlong(pContext->pHandleList->dwPaletteList[0]) *
                         sizeof(PPERMEDIA_D3DPALETTE));
            ENGFREEMEM(pContext->pHandleList->dwPaletteList);
            DBG_D3D((8,"Freeing pDDLcl=%x's old PaletteList[%x]",
                       pContext->pDDLcl,
                       pContext->pHandleList->dwPaletteList));
        }

        pContext->pHandleList->dwPaletteList = newlist;
         //store size in dwSurfaceList[0]
        *(DWORD*)pContext->pHandleList->dwPaletteList = newsize;
    }

    // If we don't have a palette hanging from this palette list
    // element we have to create one. The actual palette data will
    // come down in the D3DDP2OP_UPDATEPALETTE command token.
    if (NULL == pContext->pHandleList->dwPaletteList[dwPaletteHandle])
    {
        pContext->pHandleList->dwPaletteList[dwPaletteHandle] = 
            (PERMEDIA_D3DPALETTE*)ENGALLOCMEM( FL_ZERO_MEMORY,
                                               sizeof(PERMEDIA_D3DPALETTE),
                                               ALLOC_TAG);
        if (NULL == pContext->pHandleList->dwPaletteList[dwPaletteHandle])
        {
            DBG_D3D((0,"D3DDP2OP_SETPALETTE Out of memory."));
            return DDERR_OUTOFMEMORY;
        }
    }

    // driver may store this dwFlags to decide whether 
    // ALPHA exists in Palette
    pContext->pHandleList->dwPaletteList[dwPaletteHandle]->dwFlags =
                                                            dwPaletteFlags;

    return DD_OK;

} // PaletteSet

//-----------------------------------------------------------------------------
//
// void __PaletteUpdate
//
// Updates the entries of a palette attached to a texture in the given context
//
//-----------------------------------------------------------------------------
HRESULT 
__PaletteUpdate(PERMEDIA_D3DCONTEXT* pContext,
                DWORD dwPaletteHandle, 
                WORD wStartIndex, 
                WORD wNumEntries,
                BYTE * pPaletteData)

{
    PERMEDIA_D3DPALETTE* pPalette;

    DBG_D3D((8,"UPDATEPALETTE %d (%d,%d) %d",
              dwPaletteHandle,
              wStartIndex,
              wNumEntries,
              pContext->CurrentTextureHandle));

    pPalette = PaletteHandleToPtr(dwPaletteHandle,pContext);

    if (NULL != pPalette)
    {
        ASSERTDD(256 >= wStartIndex + wNumEntries,
                 "wStartIndex+wNumEntries>256 in D3DDP2OP_UPDATEPALETTE");

        // Copy the palette & associated data
        pPalette->wStartIndex = wStartIndex;
        pPalette->wNumEntries = wNumEntries;

        memcpy((LPVOID)&pPalette->ColorTable[wStartIndex],
               (LPVOID)pPaletteData,
               (DWORD)wNumEntries*sizeof(PALETTEENTRY));

        // If we are currently texturing and the texture is using the
        // palette we just updated, dirty the texture flag so that
        // it set up with the right (updated) palette
        if (pContext->CurrentTextureHandle)
        {
            PERMEDIA_D3DTEXTURE * pTexture=
                TextureHandleToPtr(pContext->CurrentTextureHandle,pContext);

            if (pTexture && pTexture->pTextureSurface)
            {
                if (pTexture->dwPaletteHandle == dwPaletteHandle)
                {
                    DIRTY_TEXTURE;
                    DBG_D3D((8,"UPDATEPALETTE DIRTY_TEXTURE"));
                }
            }
        }
    }
    else
    {
        return DDERR_INVALIDPARAMS;
    }
    return DD_OK;

} // __PaletteUpdate


//-----------------------------------------------------------------------------
//
// void __RestoreD3DContext
//
// Restores the P2 registers to what they were when we last left this D3D context
//
//-----------------------------------------------------------------------------
void __RestoreD3DContext(PPDev ppdev, PERMEDIA_D3DCONTEXT* pContext)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(ppdev);

    // Dirty everything in order to restore the D3D state
    DIRTY_TEXTURE;
    DIRTY_ZBUFFER;
    DIRTY_ALPHABLEND;

    // Restore the correct surface (render & depth buffer) characteristics
    SetupPermediaRenderTarget(pContext);

    //Bring back manually some registers which we care about
    RESERVEDMAPTR(5);
    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
    COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
    COPY_PERMEDIA_DATA(FogColor, pSoftPermedia->FogColor);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, -1 );
    COMMITDMAPTR();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dhw.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dhw.h
*
* Content:  D3D Global definitions and macros.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/

#ifdef __D3DHW
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __D3DHW


#ifndef __DIRECTX
#include "directx.h"
#endif

//-----------------------------------------------------------------------------
//               Known Issues in current version of the D3D driver
//-----------------------------------------------------------------------------
//
// Stencil support is not yet completed
//
// Some games may have some issues when running under a Permedia 2 since this
// hw has some limitations, namely:
//   1) Alpha blending modes available
//   2) Alpha channel interpolation is not possible
//   3) There is no mip mapping support
//   4) Texture filtering is applied only to textures being magnified
//
//  Also, the fill rules of the Delta setup unit don't follow exactly the D3D
//  fill rules, though in practice this shouldn't be a much of a problem for
//  most apps.


//-----------------------------------------------------------------------------
//                      Global enabling/disabling definitions
//-----------------------------------------------------------------------------
// Set to 1 to enable stencil buffer support in the driver
#define D3D_STENCIL         1

// Code stubs to implement a T&L driver. Since the P2 does not support this
// in hw, this symbol should always be set to zero.
#define D3DDX7_TL           0

// Code stubs to implement mip mapping, Since the P2 does not support this 
// natively in hw, this symbols should always be set to zero. Only shows
// how/where to grab DDI info to implement it.
#define D3D_MIPMAPPING      0

// This code shows how to add stateblock support into your DX7 driver. It is
// functional code, so this symbols should be set to one.
#define D3D_STATEBLOCKS     1


//-----------------------------------------------------------------------------
//                         DX6 FVF Support declarations
//-----------------------------------------------------------------------------
typedef struct _P2TEXCOORDS{
    D3DVALUE tu;
    D3DVALUE tv;
} P2TEXCOORDS, *LPP2TEXCOORDS;

typedef struct _P2COLOR {
    D3DCOLOR color;
} P2COLOR, *LPP2COLOR;

typedef struct _P2SPECULAR {
    D3DCOLOR specular;
} P2SPECULAR, *LPP2SPECULAR;

typedef struct _P2PSIZE{
    D3DVALUE psize;
} P2PSIZE, *LPP2PSIZE;

typedef struct _P2FVFOFFSETS{ 
        DWORD dwColOffset;
        DWORD dwSpcOffset;
        DWORD dwTexOffset;
        DWORD dwTexBaseOffset;
//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
        DWORD dwPntSizeOffset;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT
        DWORD dwStride;
} P2FVFOFFSETS , *LPP2FVFOFFSETS;

    // track appropriate pointers to fvf vertex components
__inline void __SetFVFOffsets (DWORD  *lpdwColorOffs, 
                               DWORD  *lpdwSpecularOffs, 
                               DWORD  *lpdwTexOffs, 
                               LPP2FVFOFFSETS lpP2FVFOff)
{
    if (lpP2FVFOff == NULL) {
        // Default non-FVF case , we just set up everything as for a D3DTLVERTEX
        *lpdwColorOffs    = offsetof( D3DTLVERTEX, color);
        *lpdwSpecularOffs = offsetof( D3DTLVERTEX, specular);
        *lpdwTexOffs      = offsetof( D3DTLVERTEX, tu);
    } else {
        // Use the offsets info to setup the corresponding fields
        *lpdwColorOffs    = lpP2FVFOff->dwColOffset;
        *lpdwSpecularOffs = lpP2FVFOff->dwSpcOffset;
        *lpdwTexOffs      = lpP2FVFOff->dwTexOffset;
    }
}

//Size of maximum FVF that we can get. Used for temporary storage
typedef BYTE P2FVFMAXVERTEX[ 3 * sizeof( D3DVALUE ) +    // Position coordinates
                             5 * 4                  +    // D3DFVF_XYZB5
                                 sizeof( D3DVALUE ) +    // FVF_TRANSFORMED
                             3 * sizeof( D3DVALUE ) +    // Normals
                                 sizeof( DWORD )    +    // RESERVED1
                                 sizeof( DWORD )    +    // Diffuse color
                                 sizeof( D3DCOLOR ) +    // Specular color
                                 sizeof( D3DVALUE ) +    // Point sprite size
                             4 * 8 * sizeof( D3DVALUE )  // 8 sets of 4D texture coordinates
                           ];

#define FVFTEX( lpVtx , dwOffs )     ((LPP2TEXCOORDS)((LPBYTE)(lpVtx) + dwOffs))
#define FVFCOLOR( lpVtx, dwOffs )    ((LPP2COLOR)((LPBYTE)(lpVtx) + dwOffs))
#define FVFSPEC( lpVtx, dwOffs)      ((LPP2SPECULAR)((LPBYTE)(lpVtx) + dwOffs))
#define FVFPSIZE( lpVtx, dwOffs)     ((LPP2PSIZE)((LPBYTE)(lpVtx) + dwOffs))

//-----------------------------------------------------------------------------
//                           Miscelaneous definitions
//-----------------------------------------------------------------------------

//AZN9
#ifdef SUPPORTING_MONOFLAG
#define RENDER_MONO (Flags & CTXT_HAS_MONO_ENABLED)
#else
#define RENDER_MONO 0
#endif

// Defines used in the FakeBlendNum field of the P2 D3D context in order to
// make up for missing features in the hw that can be easily simulated
#define FAKE_ALPHABLEND_ONE_ONE     1
#define FAKE_ALPHABLEND_MODULATE    2

#define NOT_HANDLED DBG_D3D((4, "    **Not Currently Handled**"));

// This is defined in the the d3dcntxt.h header, we use it to declare functions
struct _permedia_d3dcontext;
typedef struct _permedia_d3dcontext PERMEDIA_D3DCONTEXT;

//-----------------------------------------------------------------------------
//                       D3D global functions and callbacks
//-----------------------------------------------------------------------------


// Render state processing
DWORD 
__ProcessPermediaStates(PERMEDIA_D3DCONTEXT* pContext, 
                      DWORD Count,
                      LPD3DSTATE lpState, 
                      LPDWORD lpStateMirror);

void 
__HandleDirtyPermediaState(PPDev ppdev, 
                         PERMEDIA_D3DCONTEXT* pContext, 
                         LPP2FVFOFFSETS lpP2FVFOff);

void __HWPreProcessTSS(PERMEDIA_D3DCONTEXT *pContext, 
                      DWORD dwStage, 
                      DWORD dwState, 
                      DWORD dwValue);

// Texture functions
void 
EnableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext);

void 
DisableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext);

void 
P2LUTDownload(PPDev ppdev, 
              PermediaSurfaceData* pPrivateDest, 
              PERMEDIA_D3DCONTEXT* pContext, 
              LPDDRAWI_DDRAWSURFACE_LCL pTexture);

// Chip specific
BOOL 
SetupDefaultsPermediaContext(PERMEDIA_D3DCONTEXT* pContext);

void 
CleanDirect3DContext(PERMEDIA_D3DCONTEXT* pContext, ULONG_PTR dwhContext);

HRESULT 
InitPermediaContext(PERMEDIA_D3DCONTEXT* Context);

void 
SetupCommonContext(PERMEDIA_D3DCONTEXT* pContext);

void 
__PermediaDisableUnits(PERMEDIA_D3DCONTEXT* pContext);

void 
DisableAllUnits(PPDev ppdev);

void __DeleteAllStateSets(PERMEDIA_D3DCONTEXT* pContext);

// Hardware primitive setup functions
void 
P2_Draw_FVF_Line(PERMEDIA_D3DCONTEXT *pContext, 
                 LPD3DTLVERTEX lpV0, 
                 LPD3DTLVERTEX lpV1,
                 LPD3DTLVERTEX lpVFlat, 
                 LPP2FVFOFFSETS lpFVFOff);

void 
P2_Draw_FVF_Point(PERMEDIA_D3DCONTEXT *pContext, 
                  LPD3DTLVERTEX lpV0, 
                  LPP2FVFOFFSETS lpFVFOff);

void 
P2_Draw_FVF_Point_Sprite(PERMEDIA_D3DCONTEXT *pContext, 
                         LPD3DTLVERTEX lpV0, 
                         LPP2FVFOFFSETS lpFVFOff);

typedef void (D3DFVFDRAWTRIFUNC)(PERMEDIA_D3DCONTEXT *, 
                                 LPD3DTLVERTEX, 
                                 LPD3DTLVERTEX,
                                 LPD3DTLVERTEX, 
                                 LPP2FVFOFFSETS);

typedef D3DFVFDRAWTRIFUNC *D3DFVFDRAWTRIFUNCPTR;

typedef void (D3DFVFDRAWPNTFUNC)(PERMEDIA_D3DCONTEXT *, 
                                 LPD3DTLVERTEX, 
                                 LPP2FVFOFFSETS);

typedef D3DFVFDRAWPNTFUNC *D3DFVFDRAWPNTFUNCPTR;

D3DFVFDRAWPNTFUNCPTR __HWSetPointFunc(PERMEDIA_D3DCONTEXT *pContext,
                                       LPP2FVFOFFSETS lpP2FVFOff);

D3DFVFDRAWTRIFUNC P2_Draw_FVF_Solid_Tri;
D3DFVFDRAWTRIFUNC P2_Draw_FVF_Wire_Tri;
D3DFVFDRAWTRIFUNC P2_Draw_FVF_Point_Tri;

// Driver callbacks
void CALLBACK 
D3DHALCreateDriver(PPDev ppdev, 
                   LPD3DHAL_GLOBALDRIVERDATA* lpD3DGlobalDriverData,
                   LPD3DHAL_CALLBACKS* lpD3DHALCallbacks,
                   LPDDHAL_D3DBUFCALLBACKS* lpDDExeBufCallbacks);

DWORD CALLBACK 
D3DValidateTextureStageState( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA lpvtssd );

DWORD CALLBACK 
D3DDrawPrimitives2( LPD3DNTHAL_DRAWPRIMITIVES2DATA pd );

DWORD CALLBACK 
D3DGetDriverState( LPDDHAL_GETDRIVERSTATEDATA);

DWORD CALLBACK 
D3DCreateSurfaceEx( LPDDHAL_CREATESURFACEEXDATA);

DWORD CALLBACK 
D3DDestroyDDLocal( LPDDHAL_DESTROYDDLOCALDATA);

DWORD CALLBACK 
DdSetColorKey(LPDDHAL_SETCOLORKEYDATA psckd);

//-----------------------------------------------------------------------------
//                    Conversion, math and culling macros
//-----------------------------------------------------------------------------
/*
 * This loses one bit of accuracy, but adds and clamps without ifs.
 * We first mask all channels with 0xfe.  This leaves the lsb of
 * each channel clear, so when the terms are added, any carry goes
 * into the new highest bit.  Now all we have to do is generate a
 * mask for any channels that have overflowed.  So we shift right
 * and eliminate everything but the overflow bits, so each channel
 * contains either 0x00 or 0x01.  Subtracting each channel from 0x80
 * produces 0x7f or 0x80.  We just shift this left once and mask to
 * give 0xfe or 0x00.  (We could eliminate the final mask here, but
 * it would introduce noise into the low-bit of every channel..)
 */
#define CLAMP8888(result, color, specular) \
     result = (color & 0xfefefefe) + (specular & 0xfefefe); \
     result |= ((0x808080 - ((result >> 8) & 0x010101)) & 0x7f7f7f) << 1;

#define RGB256_TO_LUMA(r,g,b) (float)(((float)r * 0.001172549019608) + \
                                      ((float)g * 0.002301960784314) + \
                                      ((float)b * 0.000447058823529));

#define LONG_AT(flt) (*(long *)(&flt))
#define ULONG_AT(flt) (*(unsigned long *)(&flt))

//Triangle culling macro
#define CULL_TRI(pCtxt,p0,p1,p2)                                         \
    ((pCtxt->CullMode != D3DCULL_NONE) &&                                \
     (((p1->sx - p0->sx)*(p2->sy - p0->sy) <=                            \
       (p2->sx - p0->sx)*(p1->sy - p0->sy)) ?                            \
      (pCtxt->CullMode == D3DCULL_CCW)     :                             \
      (pCtxt->CullMode == D3DCULL_CW) ) )

ULONG inline RGB888ToHWFmt(ULONG dwRGB888Color, ULONG ColorMask, ULONG RGB888Mask)
{
    unsigned long m;
    int s = 0;

    if (ColorMask)
        for (s = 0, m = ColorMask; !(m & RGB888Mask);  s++)
            m <<= 1;

    return ((dwRGB888Color >> s) & ColorMask);
}

//-----------------------------------------------------------------------------
//                              State Set overrides
//-----------------------------------------------------------------------------

#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define MAX_STATE       D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS      32
#define DWORD_SHIFT     5

#define VALID_STATE(type)       ((DWORD)(type) < 2*D3DSTATE_OVERRIDE_BIAS)

typedef struct _D3DStateSet {
    DWORD               bits[MAX_STATE >> DWORD_SHIFT];
} D3DStateSet;

#define STATESET_MASK(set, state)       \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))


//-----------------------------------------------------------------------------
//  One special legacy texture op we can;t easily map into the new texture ops
//-----------------------------------------------------------------------------
#define D3DTOP_LEGACY_ALPHAOVR (0x7fffffff)

// Temporary data structure we are using here until d3dnthal.h gets updated AZN
typedef struct {
    DWORD       dwOperation;
    DWORD       dwParam; 
    DWORD       dwReserved;
} P2D3DHAL_DP2STATESET;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dline.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dline.c
*
* Content:    Direct3D hw line rasterization code.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3ddelta.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#if defined(_ALPHA_)
#include <math.h>
#endif


//-----------------------------------------------------------------------------
//
// VOID P2_Draw_FVF_Line
//
// Hardare render a single line coming from two FVF vertices
//
// Primitive rendering at this stage is dependent upon the current value/setting
// of texturing, perspective correction, fogging, gouraud/flat shading, and
// specular highlights.
//
//-----------------------------------------------------------------------------
VOID
P2_Draw_FVF_Line(PERMEDIA_D3DCONTEXT   *pContext, 
                 LPD3DTLVERTEX    lpV0, 
                 LPD3DTLVERTEX    lpV1,
                 LPD3DTLVERTEX    lpVFlat,
                 LPP2FVFOFFSETS   lpFVFOff)
{
    DWORD       dwFlags = pContext->Hdr.Flags;
    ULONG       ulRenderCmd = pContext->RenderCommand;
    DWORD       dwColorOffs,dwSpecularOffs,dwTexOffs;
    D3DCOLOR    dwColor0, dwColor1;
    D3DCOLOR    dwSpec0, dwSpec1;
    D3DVALUE    fS0, fS1, fT0, fT1, fQ0, fQ1;
    D3DVALUE    fKs0, fKs1;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering P2_Draw_FVF_Line"));

    // Set line rendering mode
    RENDER_LINE(ulRenderCmd);

    // Fix up the biasing in delta because delta doesn't do it for us for lines.
    RESERVEDMAPTR(0x80);
    SEND_PERMEDIA_DATA(RasterizerMode, BIAS_NONE);

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    // Get vertex color value (FVF based)
    if (dwColorOffs)
    {
        dwColor0  = FVFCOLOR(lpV0, dwColorOffs)->color;
        dwColor1  = FVFCOLOR(lpV1, dwColorOffs)->color;
        if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
        {
            dwColor0  |= 0xFF000000;
            dwColor1  |= 0xFF000000;
        }
    }
    else
    {
        // must set default in case no D3DFVF_DIFFUSE
        dwColor0  = 0xFFFFFFFF;
        dwColor1  = 0xFFFFFFFF;
    }

    // Get vertex specular value (FVF based) if necessary
    if ((dwFlags & (CTXT_HAS_SPECULAR_ENABLED | CTXT_HAS_FOGGING_ENABLED))
        && (dwSpecularOffs!=0))
    {
        dwSpec0   = FVFSPEC(lpV0, dwSpecularOffs)->specular;
        dwSpec1   = FVFSPEC(lpV1, dwSpecularOffs)->specular;
    }

    if ((dwFlags & CTXT_HAS_TEXTURE_ENABLED) && (dwTexOffs != 0))
    {
         // Get s,t texture coordinates (FVF based)
        fS0 = FVFTEX(lpV0,dwTexOffs)->tu;
        fT0 = FVFTEX(lpV0,dwTexOffs)->tv;
        fS1 = FVFTEX(lpV1,dwTexOffs)->tu;
        fT1 = FVFTEX(lpV1,dwTexOffs)->tv;

        // Wrap texture coordinates if necessary
        WRAP_LINE(fS, dwFlags & CTXT_HAS_WRAPU_ENABLED);
        WRAP_LINE(fT, dwFlags & CTXT_HAS_WRAPV_ENABLED);

        // Scale s,t coordinate values
        fS0 *= pContext->DeltaWidthScale;
        fS1 *= pContext->DeltaWidthScale;
        fT0 *= pContext->DeltaHeightScale;
        fT1 *= pContext->DeltaHeightScale;

        // Apply perpspective corrections if necessary
        if (dwFlags & CTXT_HAS_PERSPECTIVE_ENABLED)
        {
            fQ0 = lpV0->rhw;
            fQ1 = lpV1->rhw;
            fS0 *= fQ0;
            fT0 *= fQ0;
            fS1 *= fQ1;
            fT1 *= fQ1;
        }
        else
        {
            fQ0 = fQ1 = 1.0;
        }

        // Send lines s,t,q,ks (conditionaly),x,y,z values
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            fKs0 = RGB256_TO_LUMA(RGB_GETRED(dwSpec0),
                                    RGB_GETGREEN(dwSpec0),
                                    RGB_GETBLUE(dwSpec0));
            
            if (dwFlags & CTXT_HAS_GOURAUD_ENABLED) 
            {
                fKs1 = RGB256_TO_LUMA(RGB_GETRED(dwSpec1),
                                        RGB_GETGREEN(dwSpec1),
                                        RGB_GETBLUE(dwSpec1));
            } 
            else
            {
                fKs1 = fKs0;
            }

            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0, fKs0,
                                                lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1, fKs1,
                                                lpV1->sx, lpV1->sy, lpV1->sz);
        }
        else
        {
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0,
                                                lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1,
                                                lpV1->sx, lpV1->sy, lpV1->sz);
        }
    }
    else    // not textured line
    {
        // If specular is enabled, change the colours
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            CLAMP8888(dwColor0, dwColor0, dwSpec0 );
            CLAMP8888(dwColor1, dwColor1, dwSpec1 );
        }

        // Send lines x,y,z values
        SEND_VERTEX_XYZ(__Permedia2TagV0FloatS, lpV0->sx, lpV0->sy, lpV0->sz);
        SEND_VERTEX_XYZ(__Permedia2TagV1FloatS, lpV1->sx, lpV1->sy, lpV1->sz);
    }

    // If fog is set, send the appropriate values
    if ((dwFlags & CTXT_HAS_FOGGING_ENABLED) && (dwSpecularOffs!=0))
    {
        SEND_VERTEX_FOG(__Permedia2TagV0FixedF, RGB_GET_GAMBIT_FOG(dwSpec0));
        SEND_VERTEX_FOG(__Permedia2TagV1FixedF, RGB_GET_GAMBIT_FOG(dwSpec1));
    }

    // Send appropriate color depending on Gouraud , Mono, & Alpha
    if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
    {
        // Gouraud shading
        if (RENDER_MONO)
        {
            SEND_VERTEX_RGB_MONO_P2(__Permedia2TagV0FixedS, dwColor0);
            SEND_VERTEX_RGB_MONO_P2(__Permedia2TagV1FixedS, dwColor1);
        }
        else
        {
            if (dwFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
                {
                    dwColor0 &= 0xFFFFFF;     // supress color's alpha value
                    dwColor1 &= 0xFFFFFF;
                }
            }
            SEND_VERTEX_RGBA_P2(__Permedia2TagV0FixedS, dwColor0);
            SEND_VERTEX_RGBA_P2(__Permedia2TagV1FixedS, dwColor1);
        }
    }
    else   // Flat shading
    {
        // Get vertex color value (FVF based) from the right vertex!
        if (dwColorOffs)
        {
            dwColor0  = FVFCOLOR(lpVFlat, dwColorOffs)->color;
            if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
            {
                dwColor0  |= 0xFF000000;
            }
        }
        else
        {
            // must set default in case no D3DFVF_DIFFUSE
            dwColor0  = 0xFFFFFFFF;
        }

        
        if (RENDER_MONO)
        {
            // Get constant color from the blue channel
            DWORD BlueChannel;
            BlueChannel = RGBA_GETBLUE(dwColor0);
            SEND_PERMEDIA_DATA(ConstantColor,
                            RGB_MAKE(BlueChannel, BlueChannel, BlueChannel));
        }
        else
        {
            if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
            {
                dwColor0 &= 0xFFFFFF;
            }
            SEND_PERMEDIA_DATA(ConstantColor,
                            RGBA_MAKE(RGBA_GETBLUE(dwColor0), 
                                      RGBA_GETGREEN(dwColor0),
                                      RGBA_GETRED(dwColor0), 
                                      RGBA_GETALPHA(dwColor0)));
        }
    }

    SEND_PERMEDIA_DATA(DrawLine01, ulRenderCmd);
    SEND_PERMEDIA_DATA(RasterizerMode, 0);
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting P2_Draw_FVF_Line"));
} // P2_Draw_FVF_Line

//-----------------------------------------------------------------------------
//
// void P2_Draw_FVF_Wire_Tri
//
//-----------------------------------------------------------------------------
void 
P2_Draw_FVF_Wire_Tri(PERMEDIA_D3DCONTEXT *pContext, 
                     LPD3DTLVERTEX lpV0, 
                     LPD3DTLVERTEX lpV1,
                     LPD3DTLVERTEX lpV2, 
                     LPP2FVFOFFSETS lpFVFOff)
{
    DBG_D3D((10,"Entering P2_Draw_FVF_Wire_Tri"));

    P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, lpFVFOff);
    P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV0, lpFVFOff);
    P2_Draw_FVF_Line(pContext, lpV2, lpV0, lpV0, lpFVFOff);

    DBG_D3D((10,"Exiting P2_Draw_FVF_Wire_Tri"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtext.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtext.h
*
*  Content:  D3D Texture management related definitions and macros
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifdef __TEXTURES
#pragma message ("FILE : "__FILE__" : Multiple Inclusion");
#endif

#define __TEXTURES


//-----------------------------------------------------------------------------
//                        Texture validation macros 
//-----------------------------------------------------------------------------
#define TC_MAGIC_DISABLE 0xd3d10000
#define TC_MAGIC_NO 0xd3d10100

#define CHECK_D3DSURFACE_VALIDITY(ptr)               \
    ((ptr) != NULL && (ptr)->MagicNo == TC_MAGIC_NO)

#define CHECK_TEXTURESTRUCT_VALIDITY(ptr)         \
    ( ((ptr) != NULL) &&                          \
      ( ((ptr)->MagicNo == TC_MAGIC_NO) ||        \
        ((ptr)->MagicNo == TC_MAGIC_DISABLE) )    \
    )

//-----------------------------------------------------------------------------
//                       Texture structure definitions
//-----------------------------------------------------------------------------

// We only handle one single mipmap on this sample driver since the P2 doesn't
// natively support them
#if D3D_MIPMAPPING
#define MAX_MIP_LEVELS 12
#else
#define MAX_MIP_LEVELS 1
#endif // D3D_MIPMAPPING

// stores information needed to quickly setup a mipmap level on
// the chip.  At the moment this is Partial Products and widths/heights
typedef struct tagMIPTEXTURE {

    // Widths and heights for this mip level
    INT logWidth;
    INT logHeight;

    // Partial products for this mip level
    ULONG ulPackedPP;

    // Offset in pixels to start of the texture
    // for the current miplevel
    DWORD PixelOffset;

} MIPTEXTURE;

typedef struct _permedia_d3dtexture 
{
    // Magic number to verify validity of pointer
    ULONG MagicNo ;

    // the following four memebers are exact replicates
    // of those in DDRAWI_DDRAWSURFACE_GBL
    DWORD       dwCaps;
    DWORD       dwCaps2;
    FLATPTR     fpVidMem;                  // pointer to video memory
    LONG        lPitch;                    // pitch of surface
    DWORD       dwRGBBitCount;
    UINT_PTR    lSurfaceOffset;

    // Width and Height of texture
    WORD    wWidth;
    WORD    wHeight;

    // The AGP that the last texture came from
    DWORD dwGARTDevLast;

    BOOL bMipMap;
    DWORD                   m_dwBytes;
    DWORD                   m_dwPriority;
    DWORD                   m_dwTicks;
    DWORD                   m_dwHeapIndex;
    ULONG       HandleListIndex;    // indicating which list it's with
    // For setting up MipMaps 
    MIPTEXTURE MipLevels[MAX_MIP_LEVELS];

    DWORD       dwFlags;
    DWORD       dwKeyLow;
    DWORD       dwKeyHigh;
    PermediaSurfaceData* pTextureSurface;
    DWORD       dwPaletteHandle;

    // The number of mipmap levels this texture should have
    int iMipLevels;
} PERMEDIA_D3DTEXTURE, *PPERMEDIA_D3DTEXTURE;

//-----------------------------------------------------------------------------
//                       DX7 Texture management definitions
//-----------------------------------------------------------------------------

typedef struct _permedia_d3dpalette 
{
    DWORD   dwFlags;
    WORD    wStartIndex;
    WORD    wNumEntries;
    PALETTEENTRY ColorTable[256];   // array of palette entries, could be dynamic later
} PERMEDIA_D3DPALETTE, *PPERMEDIA_D3DPALETTE;

#define LISTGROWSIZE    1024
typedef struct _DWLIST
{
    PPERMEDIA_D3DTEXTURE   *dwSurfaceList;    // array to hold handles, 
                                              // dynamically allocated 
                                              // dwSurfaceList[0] is the number 
                                              // of entries in dwSurfaceList 
                                              // if allocated
    PPERMEDIA_D3DPALETTE   *dwPaletteList;    // array to hold handles, 
                                              // dynamically allocated 
                                              // dwPaletteList[0] is the number
                                              // of entries in dwPaletteList
                                              // if allocated
    LPVOID  pDDLcl;                           // owning ddraw pointer as a key
} DWLIST;
typedef DWLIST FAR* LPDWLIST;
extern DWLIST  HandleList[]; 
extern LPDWLIST GetSurfaceHandleList(LPVOID);
void ReleaseSurfaceHandleList(LPVOID);
PERMEDIA_D3DPALETTE *PaletteHandleToPtr(UINT_PTR phandle,
                                        PERMEDIA_D3DCONTEXT* pContext);

//-----------------------------------------------------------------------------
//                              Texture debugging
//-----------------------------------------------------------------------------
// Tracing/Debugging functions
void DumpTexture(PPDev ppdev,
                 PERMEDIA_D3DTEXTURE* pTexture,
                 DDPIXELFORMAT* pPixelFormat);


#ifdef DBG
#define DISPTEXTURE(arg) DumpTexture arg
#else
#define DISPTEXTURE(arg)
#endif

//-----------------------------------------------------------------------------
//                      Texture hash table definitions
//-----------------------------------------------------------------------------
#define TEXTURE_HASH_SIZE   256     // these many entries in the hash table

void InitTextureHashTable(PERMEDIA_D3DCONTEXT   *pContext);

// Then the hash funtion is just an 'and'
#define TEXTURE_HASH_OF(i)  ((i) & 0xff)

PERMEDIA_D3DTEXTURE *TextureHandleToPtr(UINT_PTR thandle,
                                        PERMEDIA_D3DCONTEXT* pContext);

void StorePermediaLODLevel(PPDev ppdev,
                           PERMEDIA_D3DTEXTURE* pTexture,
                           LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                           int LOD);

//-----------------------------------------------------------------------------
//                  Texture coordinate wrapping macros
//-----------------------------------------------------------------------------
#define FLUSH_DUE_TO_WRAP(par)
#define DONT_FLUSH_DUE_TO_WRAP(par)
#define WRAP(par, wrapit) if(wrapit) {                      \
    float elp;                                              \
    float erp;                                              \
    float emp;                                              \
    elp = (float)fabs(par##1 - par##0);                     \
    erp = (float)fabs(par##2 - par##1);                     \
    emp = (float)fabs(par##0 - par##2);                     \
    if( (elp > (float)0.5) && (erp > (float)0.5) )          \
    {                                                       \
        if (par##1 < par##2) { par##1 += 1.0; }             \
        else { par##2 += 1.0; par##0 += 1.0; }              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else if( (erp > (float)0.5) && (emp > (float)0.5) )     \
    {                                                       \
        if (par##2 < par##0) { par##2 += 1.0; }             \
        else { par##0 += 1.0; par##1 += 1.0; }              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else if( (emp > (float)0.5) && (elp > (float)0.5) )     \
    {                                                       \
        if(par##0 < par##1) { par##0 += 1.0; }              \
        else { par##1 += 1.0; par##2 += 1.0; }              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else                                                    \
    {                                                       \
        DONT_FLUSH_DUE_TO_WRAP(par);                        \
    }                                                       \
} else {                                                    \
    DONT_FLUSH_DUE_TO_WRAP(par);                            \
}

 
#define WRAP_LINE(par, wrapit) if(wrapit) {                 \
    float elp;                                              \
    elp = (float)fabs(par##1 - par##0);                     \
    if(elp > (float)0.5)                                    \
    {                                                       \
        if (par##1 < par##0) { par##1 += 1.0; }             \
        else { par##0 += 1.0;}                              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else                                                    \
    {                                                       \
        DONT_FLUSH_DUE_TO_WRAP(par);                        \
    }                                                       \
} else {                                                    \
    DONT_FLUSH_DUE_TO_WRAP(par);                            \
}


//-----------------------------------------------------------------------------
//                  Texture coordinate recentering macros
//-----------------------------------------------------------------------------

// Keeps the texture coordinates centered around 0 
// and avoid exceeding the texel wrapping limit.
#define RECENTER_TEX_COORDS(Maxf, Maxi, fTC0, fTC1, fTC2)                \
{                                                                        \
    long tcmax;                                                          \
    unsigned long tcmin;                                                 \
    int i;                                                               \
                                                                         \
    tcmax = LONG_AT(fTC0);                                               \
    if (tcmax < LONG_AT(fTC1)) tcmax = LONG_AT(fTC1);                    \
    if (tcmax < LONG_AT(fTC2)) tcmax = LONG_AT(fTC2);                    \
    if (tcmax >= *(long *)&Maxf)                                         \
    {                                                                    \
        myFtoi(&i, *(float *)&tcmax);                                    \
        i -= Maxi;                                                       \
        fTC0 -= i;                                                       \
        fTC1 -= i;                                                       \
        fTC2 -= i;                                                       \
    }                                                                    \
    else                                                                 \
    {                                                                    \
        tcmin = ULONG_AT(fTC0);                                          \
        if (tcmin < ULONG_AT(fTC1)) tcmin = ULONG_AT(fTC1);              \
        if (tcmin < ULONG_AT(fTC2)) tcmin = ULONG_AT(fTC2);              \
        if (*(float *)&tcmin <= -Maxf)                                   \
        {                                                                \
            myFtoi(&i, *(float *)&tcmin);                                \
            i += Maxi;                                                   \
            fTC0 -= i;                                                   \
            fTC1 -= i;                                                   \
            fTC2 -= i;                                                   \
        }                                                                \
    }                                                                    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dstate.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstate.c
*
*       Contains code to translate D3D renderstates and texture stage
*       states into hardware specific settings.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "d3ddelta.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_SD2P
//-----------------------------------------------------------------------------
//
// void __SelectFVFTexCoord
//
// This utility function sets the correct texture offset depending on the
// texturing coordinate set wished to be used from the FVF vertexes
//
//-----------------------------------------------------------------------------
void 
__SelectFVFTexCoord(LPP2FVFOFFSETS lpP2FVFOff, DWORD dwTexCoord)
{
    DBG_D3D((10,"Entering __SelectFVFTexCoord"));

    lpP2FVFOff->dwTexOffset = lpP2FVFOff->dwTexBaseOffset + 
                                dwTexCoord * 2 * sizeof(D3DVALUE);

    // verify the requested texture coordinate doesn't exceed the FVF 
    // vertex structure provided , if so go down to set 0 as a 
    // crash-avoiding alternative
    if (lpP2FVFOff->dwTexOffset >= lpP2FVFOff->dwStride)
        lpP2FVFOff->dwTexOffset = lpP2FVFOff->dwTexBaseOffset;

    DBG_D3D((10,"Exiting __SelectFVFTexCoord"));
} // __SelectFVFTexCoord


//-----------------------------------------------------------------------------
//
// HRESULT __HWPreProcessTSS
//
// Processes the state changes that must be done as soon as they arrive
//
//-----------------------------------------------------------------------------
void __HWPreProcessTSS(PERMEDIA_D3DCONTEXT *pContext, 
                      DWORD dwStage, 
                      DWORD dwState, 
                      DWORD dwValue)
{
    DBG_D3D((10,"Entering __HWPreProcessTSS"));

    if (D3DTSS_ADDRESS == dwState)
    {
        pContext->TssStates[D3DTSS_ADDRESSU] = dwValue;
        pContext->TssStates[D3DTSS_ADDRESSV] = dwValue;
    }
    else
    if (D3DTSS_TEXTUREMAP == dwState && 0 != dwValue)
    {
        PPERMEDIA_D3DTEXTURE   pTexture=TextureHandleToPtr(dwValue, pContext);
        if (CHECK_D3DSURFACE_VALIDITY(pTexture) &&
            (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) 
        {
            TextureCacheManagerIncNumTexturesSet(pContext->pTextureManager);
            if (pTexture->m_dwHeapIndex)
                TextureCacheManagerIncNumSetTexInVid(pContext->pTextureManager);
        }
    }
    DBG_D3D((10,"Exiting __HWPreProcessTSS"));
} // __HWPreProcessTSS

//-----------------------------------------------------------------------------
//
// HRESULT __HWSetupStageStates
//
// Processes the state changes related to the DX6 texture stage states in the 
// current rendering context
//
//-----------------------------------------------------------------------------
HRESULT WINAPI __HWSetupStageStates(PERMEDIA_D3DCONTEXT *pContext, 
                                    LPP2FVFOFFSETS lpP2FVFOff)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    DWORD           *pFlags = &pContext->Hdr.Flags;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering __HWSetupStageStates"));

    
    // If we are to texture map our primitives
    if (pContext->TssStates[D3DTSS_TEXTUREMAP])
    {
        DWORD dwMag = pContext->TssStates[D3DTSS_MAGFILTER];
        DWORD dwMin = pContext->TssStates[D3DTSS_MINFILTER];
        DWORD dwMip = pContext->TssStates[D3DTSS_MIPFILTER];
        DWORD dwCop = pContext->TssStates[D3DTSS_COLOROP];
        DWORD dwCa1 = pContext->TssStates[D3DTSS_COLORARG1];
        DWORD dwCa2 = pContext->TssStates[D3DTSS_COLORARG2];
        DWORD dwAop = pContext->TssStates[D3DTSS_ALPHAOP];
        DWORD dwAa1 = pContext->TssStates[D3DTSS_ALPHAARG1];
        DWORD dwAa2 = pContext->TssStates[D3DTSS_ALPHAARG2];
        DWORD dwTau = pContext->TssStates[D3DTSS_ADDRESSU];
        DWORD dwTav = pContext->TssStates[D3DTSS_ADDRESSV];
        DWORD dwTxc = pContext->TssStates[D3DTSS_TEXCOORDINDEX];

        DBG_D3D((6,"Setting up w TSS:"
                   "dwCop=%x dwCa1=%x dwCa2=%x dwAop=%x dwAa1=%x dwAa2=%x "
                   "dwMag=%x dwMin=%x dwMip=%x dwTau=%x dwTav=%x dwTxc=%x",
                   dwCop, dwCa1, dwCa2, dwAop, dwAa1, dwAa2,
                   dwMag, dwMin, dwMip, dwTau, dwTav, dwTxc));

        // Choose texture coord to use
        __SelectFVFTexCoord( lpP2FVFOff, dwTxc);

        // Current is the same as diffuse in stage 0
        if (dwCa2 == D3DTA_CURRENT)
            dwCa2 = D3DTA_DIFFUSE;
        if (dwAa2 == D3DTA_CURRENT)
            dwAa2 = D3DTA_DIFFUSE;

        // Check if we need to disable texturing 
        if (dwCop == D3DTOP_DISABLE || 
            (dwCop == D3DTOP_SELECTARG2 && dwCa2 == D3DTA_DIFFUSE && 
             dwAop == D3DTOP_SELECTARG2 && dwAa2 == D3DTA_DIFFUSE))
        {
            //Please don't clear pContext->TssStates[D3DTSS_TEXTUREMAP] though
           pContext->CurrentTextureHandle = 0;
            DBG_D3D((10,"Exiting __HWSetupStageStates , texturing disabled"));
            return DD_OK;
        }

        // setup the address mode
        switch (dwTau) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to TSS U address mode = %d"
                                                                      ,dwTau));
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_REPEAT;
                break;
        }
        switch (dwTav) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to TSS V address mode = %d"
                                                                      ,dwTav));
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_REPEAT;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();

        // Enable-disable wrapping flags for U & V       
        if (pContext->dwWrap[dwTxc] &  D3DWRAPCOORD_0)
        {
            *pFlags |= CTXT_HAS_WRAPU_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPU_ENABLED;
        }

        if (pContext->dwWrap[dwTxc] &  D3DWRAPCOORD_1)
        {
            *pFlags |= CTXT_HAS_WRAPV_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPV_ENABLED;
        }

        // Setup the equivalent texture filtering state
        if (dwMip == D3DTFP_NONE) 
        {
            // We can only take care of magnification filtering on the P2
            if (dwMag == D3DTFG_LINEAR)
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_LINEAR;
            }
            else if (dwMag == D3DTFG_POINT)
            {
                pContext->bMagFilter = FALSE; // D3DFILTER_NEAREST;
            }
        }
        else if (dwMip == D3DTFP_POINT) 
        {
            if (dwMin == D3DTFN_POINT) 
            {
                pContext->bMagFilter = FALSE; // D3DFILTER_MIPNEAREST;
            }
            else if (dwMin == D3DTFN_LINEAR) 
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_MIPLINEAR;
            }
        }
        else 
        { // dwMip == D3DTFP_LINEAR
            if (dwMin == D3DTFN_POINT) 
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_LINEARMIPNEAREST;
            }
            else if (dwMin == D3DTFN_LINEAR) 
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_LINEARMIPLINEAR;
            }
        }

        // Setup the equivalent texture blending state
        // Check if we need to decal
        if ((dwCa1 == D3DTA_TEXTURE && dwCop == D3DTOP_SELECTARG1) &&
             (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_SELECTARG1)) 
        {
            // D3DTBLEND_COPY;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_COPY;
        }
        // check if we the app modified the TSS for decaling after first
        // setting it up for modulating via the legacy renderstates
        // this is a Permedia2 specific optimization.
        else if ((dwCa1 == D3DTA_TEXTURE && dwCop == D3DTOP_SELECTARG1) &&
             (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_LEGACY_ALPHAOVR)) 
        {
            // D3DTBLEND_COPY;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_COPY;
        }
        // Check if we need to modulate & pass texture alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) &&
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_SELECTARG1)) 
        {
            // D3DTBLEND_MODULATE;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        }
        // Check if we need to modulate & pass diffuse alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) &&
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa2 == D3DTA_DIFFUSE && dwAop == D3DTOP_SELECTARG2)) 
        {
            // D3DTBLEND_MODULATE;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        }
        // Check if we need to do legacy modulate
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) &&
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_LEGACY_ALPHAOVR)) 
        {
            // D3DTBLEND_MODULATE;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        }
        // Check if we need to decal alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) && 
                  dwCop == D3DTOP_BLENDTEXTUREALPHA &&
                 (dwAa2 == D3DTA_DIFFUSE && dwAop == D3DTOP_SELECTARG2)) 
        {
            // D3DTBLEND_DECALALPHA;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_DECAL;
        }
        // Check if we need to modulate alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) && 
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa2 == D3DTA_DIFFUSE && dwAa1 == D3DTA_TEXTURE) && 
                  dwAop == D3DTOP_MODULATE) 
        {
            // D3DTBLEND_MODULATEALPHA;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        } else
        {
            DBG_D3D((0,"Trying to setup a state we don't understand!"));
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);
        COMMITDMAPTR();

        pContext->CurrentTextureHandle = pContext->TssStates[D3DTSS_TEXTUREMAP];
    }
    else
        // No texturing
        pContext->CurrentTextureHandle = 0;

    DIRTY_TEXTURE;

    DBG_D3D((10,"Exiting __HWSetupStageStates"));

    return DD_OK;
} //__HWSetupStageStates

//-----------------------------------------------------------------------------
//
// void __HandleDirtyPermediaState
// 
// Setup of context that is deferred until just before 
// rendering an actual rendering primitive
//
//-----------------------------------------------------------------------------
void 
__HandleDirtyPermediaState(PPDev ppdev, 
                           PERMEDIA_D3DCONTEXT* pContext,
                           LPP2FVFOFFSETS lpP2FVFOff)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);

    ULONG AlphaBlendSend;

    DBG_D3D((10,"Entering __HandleDirtyPermediaState"));

    // We need to keep this ordering of evaluation on the P2

    // --------------Have the texture or the stage states changed ? -----------

    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_TEXTURE)
    {
        DBG_D3D((4,"preparing to handle CONTEXT_DIRTY_TEXTURE"));
        // Choose between legacy Texture Handle or TSS
        if (pContext->dwDirtyFlags & CONTEXT_DIRTY_MULTITEXTURE)
        {
            pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_MULTITEXTURE;
            //Setup TSS state AND textures
            if ( SUCCEEDED(__HWSetupStageStates(pContext, lpP2FVFOff)) )
            {
                // if this FVF has no tex coordinates at all disable texturing
                if (lpP2FVFOff->dwTexBaseOffset == 0)
                {
                    pContext->CurrentTextureHandle = 0;
                    DBG_D3D((2,"No texture coords present in FVF "
                               "to texture map primitives"));
                }
            }
            else
            {
                pContext->CurrentTextureHandle = 0;
                DBG_D3D((0,"TSS Setup failed"));
            }
        }
        else
        {   
            // select default texture coordinate index
             __SelectFVFTexCoord( lpP2FVFOff, 0);
        }
    }

    // --------------Has the state of the LB changed ? ------------------------

    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ZBUFFER)
    {
        DBG_D3D((4,"CONTEXT_DIRTY_ZBUFFER handled"));
        pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_ZBUFFER;

        if ((pContext->Hdr.Flags & CTXT_HAS_ZBUFFER_ENABLED) && 
            (pContext->ZBufferHandle))
        {
            if (pContext->Hdr.Flags & CTXT_HAS_ZWRITE_ENABLED)
            {
                if (__PERMEDIA_DEPTH_COMPARE_MODE_NEVER ==
                    (int)pSoftPermedia->DepthMode.CompareMode)
                {
                    pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                             __PERMEDIA_DISABLE;
                    pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                }
                else
                {
                    pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                             __PERMEDIA_ENABLE;
                    pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
                }
                pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_ENABLE;
            } 
            else 
            {
                pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                         __PERMEDIA_ENABLE;
                pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_DISABLE;
            }

            // We are Z Buffering 

            // Enable Z test
            pSoftPermedia->DepthMode.UnitEnable = __PERMEDIA_ENABLE;

            // Tell delta we are Z Buffering.
            pSoftPermedia->DeltaMode.DepthEnable = 1;
        }
        else
        {
            // We are NOT Z Buffering

            // Disable Writes
            pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;

            // Disable Z test
            pSoftPermedia->DepthMode.UnitEnable = __PERMEDIA_DISABLE;
            pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_DISABLE;

            // No reads, no writes
            pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                         __PERMEDIA_DISABLE;
            // Tell delta we aren't Z Buffering.
            pSoftPermedia->DeltaMode.DepthEnable = 0;
        }

        if (__PERMEDIA_ENABLE == pSoftPermedia->StencilMode.UnitEnable)
        {
            pSoftPermedia->LBReadMode.ReadDestinationEnable = __PERMEDIA_ENABLE;

            pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
        }

        RESERVEDMAPTR(7);
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
        COPY_PERMEDIA_DATA(StencilMode, pSoftPermedia->StencilMode);
        COPY_PERMEDIA_DATA(StencilData, pSoftPermedia->StencilData);
        COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);
        COPY_PERMEDIA_DATA(DepthMode, pSoftPermedia->DepthMode);
        COPY_PERMEDIA_DATA(LBReadMode, pSoftPermedia->LBReadMode);
        COPY_PERMEDIA_DATA(LBWriteMode, pSoftPermedia->LBWriteMode);
        COMMITDMAPTR();

    } // if CONTEXT_DIRTY_ZBUFFER

    // ----------------Has the alphablend type changed ? ----------------------


    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ALPHABLEND)
    {
        // Only clear when we have an alphablend dirty context
        pContext->FakeBlendNum &= ~FAKE_ALPHABLEND_ONE_ONE;

        pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_ALPHABLEND;

        // Verify that requested blend mode is HW supported
        DWORD dwBlendMode;
        dwBlendMode = 
            (((DWORD)pSoftPermedia->AlphaBlendMode.SourceBlend) |
             ((DWORD)pSoftPermedia->AlphaBlendMode.DestinationBlend) << 4);

        DBG_D3D((4,"CONTEXT_DIRTY_ALPHABLEND handled: Blend mode = %08lx",
                                                              dwBlendMode));

        switch (dwBlendMode) {

            // In this case, we set the bit to the QuickDraw mode
            case __PERMEDIA_BLENDOP_ONE_AND_INVSRCALPHA:
                DBG_D3D((4,"Blend Operation is PreMult"));
                pSoftPermedia->AlphaBlendMode.BlendType = 1;
                break;
            // This is the standard blend
            case __PERMEDIA_BLENDOP_SRCALPHA_AND_INVSRCALPHA:
                DBG_D3D((4,"Blend Operation is Blend"));
                pSoftPermedia->AlphaBlendMode.BlendType = 0;
                break;
            case ((__PERMEDIA_BLEND_FUNC_ZERO << 4) | 
                   __PERMEDIA_BLEND_FUNC_SRC_ALPHA):
                // we substitute the SrcBlend = SrcAlpha DstBlend = 1
                // with the 1,0 mode since we really dont' support
                // it, just so apps perform reasonably
                pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 0;

            case ((__PERMEDIA_BLEND_FUNC_ONE << 4) 
                 | __PERMEDIA_BLEND_FUNC_ZERO):

            case __PERMEDIA_BLENDOP_ONE_AND_ZERO:
            // This is code for 'no blending'
                DBG_D3D((4,"Blend Operation is validly None"));
                break;
            case ((__PERMEDIA_BLEND_FUNC_ONE << 4) | 
                   __PERMEDIA_BLEND_FUNC_SRC_ALPHA):
                // we substitute the SrcBlend = SrcAlpha DstBlend = 1
                // with the 1,1 mode since we really dont' support
                // it, just so apps perform reasonably
            case __PERMEDIA_BLENDOP_ONE_AND_ONE:
                DBG_D3D((4,"BlendOperation is 1 Source, 1 Dest"));
                pSoftPermedia->AlphaBlendMode.BlendType = 1;
                pContext->FakeBlendNum |= FAKE_ALPHABLEND_ONE_ONE;
                break;
            default:
                DBG_D3D((2,"Blend Operation is invalid! BlendOp == %x",
                                                              dwBlendMode));
                // This is a fallback blending mode 
                dwBlendMode = __PERMEDIA_BLENDOP_ONE_AND_ZERO;
                break;
        }


        if ((pContext->Hdr.Flags & CTXT_HAS_ALPHABLEND_ENABLED) && 
            (dwBlendMode != __PERMEDIA_BLENDOP_ONE_AND_ZERO))
        {
            // Set the AlphaBlendMode register on Permedia
            pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 1;
            // Turn on destination read in the FBReadMode register
            pSoftPermedia->FBReadMode.ReadDestinationEnable = 1;
        }
        else
        {
            // Set the AlphaBlendMode register on Permedia
            pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 0;
            // Turn off the destination read in FbReadMode register
            pSoftPermedia->FBReadMode.ReadDestinationEnable = 0;

            // if not sending alpha, turn alpha to 1
            RESERVEDMAPTR(1);
            SEND_PERMEDIA_DATA(AStart,      PM_BYTE_COLOR(0xFF));
            COMMITDMAPTR();
        }

        AlphaBlendSend = ((DWORD)*(DWORD*)(&pSoftPermedia->AlphaBlendMode));

        // Insert changes in blend mode for unsupported blend operations
        // in this function
        if (FAKE_ALPHABLEND_ONE_ONE & pContext->FakeBlendNum)
        {
            AlphaBlendSend &= 0xFFFFFF01;
            AlphaBlendSend |= (__PERMEDIA_BLENDOP_ONE_AND_INVSRCALPHA << 1);
        }

        RESERVEDMAPTR(2);
        COPY_PERMEDIA_DATA(FBReadMode,     pSoftPermedia->FBReadMode);
        COPY_PERMEDIA_DATA(AlphaBlendMode, AlphaBlendSend);
        COMMITDMAPTR();

    }

    // --------------------Has the texture handle changed ? -------------------

    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_TEXTURE)
    {
        pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_TEXTURE;
        DBG_D3D((4,"CONTEXT_DIRTY_TEXTURE handled"));
        if (pContext->CurrentTextureHandle == 0)
            DisableTexturePermedia(pContext);
        else
            EnableTexturePermedia(pContext);
    }

    DBG_D3D((10,"Exiting __HandleDirtyPermediaState"));

} // __HandleDirtyPermediaState

//-----------------------------------------------------------------------------
//
// void __MapRS_Into_TSS0
//
// Map Renderstate changes into the corresponding change in the Texture Stage
// State #0 .
//
//-----------------------------------------------------------------------------
void 
__MapRS_Into_TSS0(PERMEDIA_D3DCONTEXT* pContext,
                  DWORD dwRSType,
                  DWORD dwRSVal)
{
    DBG_D3D((10,"Entering __MapRS_Into_TSS0"));

    // Process each specific renderstate
    switch (dwRSType)
    {

    case D3DRENDERSTATE_TEXTUREHANDLE:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_TEXTUREMAP] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        switch (dwRSVal)
        {
            case D3DTBLEND_DECALALPHA:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] =
                                               D3DTOP_BLENDTEXTUREALPHA;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG2;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                break;
            case D3DTBLEND_MODULATE:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_MODULATE;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                // a special legacy alpha operation is called for
                // that depends on the format of the texture
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_LEGACY_ALPHAOVR;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                break;
            case D3DTBLEND_MODULATEALPHA:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_MODULATE;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_MODULATE;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                break;
            case D3DTBLEND_COPY:
            case D3DTBLEND_DECAL:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_SELECTARG1;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                break;
            case D3DTBLEND_ADD:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_ADD;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG2;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        }
        break;

    case D3DRENDERSTATE_BORDERCOLOR:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_BORDERCOLOR] = dwRSVal;
        break;

    case D3DRENDERSTATE_MIPMAPLODBIAS:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_MIPMAPLODBIAS] = dwRSVal;
        break;

    case D3DRENDERSTATE_ANISOTROPY:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_MAXANISOTROPY] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREADDRESS:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_ADDRESSU] =
        pContext->TssStates[D3DTSS_ADDRESSV] = dwRSVal; 
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSU:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_ADDRESSU] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSV:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_ADDRESSV] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
        switch(dwRSVal)
        {
            case D3DFILTER_NEAREST:
                pContext->TssStates[D3DTSS_MAGFILTER] = D3DTFG_POINT;
                break;
            case D3DFILTER_LINEAR:
            case D3DFILTER_MIPLINEAR:
            case D3DFILTER_MIPNEAREST:
            case D3DFILTER_LINEARMIPNEAREST:
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->TssStates[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                break;
            default:
                break;
        }
        break;

    case D3DRENDERSTATE_TEXTUREMIN:
        switch(dwRSVal)
        {
            case D3DFILTER_NEAREST:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                break;
            case D3DFILTER_LINEAR:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                break;
            case D3DFILTER_MIPNEAREST:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                break;
            case D3DFILTER_MIPLINEAR:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                break;
            case D3DFILTER_LINEARMIPNEAREST:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                break;
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                break;;
            default:
                break;
        }
        break;

    default:
        // All other renderstates don't have a corresponding TSS state so
        // we don't have to worry about mapping them.
        break;

    } // switch (dwRSType of renderstate)

    DBG_D3D((10,"Exiting __MapRS_Into_TSS0"));

} // __MapRS_Into_TSS0


//-----------------------------------------------------------------------------
//
// void __ProcessRenderState
//
// Handle a single render state change
//
//-----------------------------------------------------------------------------
void
__ProcessRenderStates(PERMEDIA_D3DCONTEXT* pContext, 
                      DWORD dwRSType,
                      DWORD dwRSVal)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    DWORD* pFlags = &pContext->Hdr.Flags;

    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering __ProcessRenderStates"));

    // Process each specific renderstate
    switch (dwRSType) {

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        DBG_D3D((8, "ChangeState: Texture Blend Mode 0x%x "
                                  "(D3DTEXTUREBLEND)", dwRSVal));
        switch (dwRSVal) {
            case D3DTBLEND_DECALALPHA:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_DECAL;
                break;
            case D3DTBLEND_MODULATE:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_MODULATE;
                break;
            case D3DTBLEND_MODULATEALPHA:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_MODULATE;
                break;
            case D3DTBLEND_COPY:
            case D3DTBLEND_DECAL:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_COPY;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureColorMode,
                                       pSoftPermedia->TextureColorMode);
        COMMITDMAPTR();
        DIRTY_TEXTURE;          // May need to change DDA
        break;

    case D3DRENDERSTATE_TEXTUREADDRESS:
        DBG_D3D((8, "ChangeState: Texture address 0x%x "
                    "(D3DTEXTUREADDRESS)", dwRSVal));
        switch (dwRSVal) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to ChangeState "
                            " D3DRENDERSTATE_TEXTUREADDRESS = %d",
                                                    dwRSVal));
                // set a fallback value
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode,
                                         pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSU:
        DBG_D3D((8, "ChangeState: Texture address 0x%x "
                    "(D3DTEXTUREADDRESSU)", dwRSVal));
        switch (dwRSVal) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to ChangeState "
                            " D3DRENDERSTATE_TEXTUREADDRESSU = %d",
                                                      dwRSVal));
                // set a fallback value
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
        }
        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSV:
        DBG_D3D((8, "ChangeState: Texture address 0x%x "
                    "(D3DTEXTUREADDRESSV)", dwRSVal));
        switch (dwRSVal) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to ChangeState "
                            " D3DRENDERSTATE_TEXTUREADDRESSV = %d",
                                                   dwRSVal));
                // set a fallback value
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREHANDLE:
        DBG_D3D((8, "ChangeState: Texture Handle 0x%x",dwRSVal));
        if (dwRSVal != pContext->CurrentTextureHandle)
        {
            pContext->CurrentTextureHandle = dwRSVal;
            DIRTY_TEXTURE;
        }
        break;

    case D3DRENDERSTATE_ANTIALIAS:
        DBG_D3D((8, "ChangeState: AntiAlias 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_WRAPU:
        DBG_D3D((8, "ChangeState: Wrap_U "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_WRAPU_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPU_ENABLED;
        }
        break;


    case D3DRENDERSTATE_WRAPV:
        DBG_D3D((8, "ChangeState: Wrap_V "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_WRAPV_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPV_ENABLED;
        }
        break;

    case D3DRENDERSTATE_LINEPATTERN:
        DBG_D3D((8, "ChangeState: Line Pattern "
                    "(D3DLINEPATTERN) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ZWRITEENABLE:
        DBG_D3D((8, "ChangeState: Z Write Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            // Local Buffer Write mode
            if (!(*pFlags & CTXT_HAS_ZWRITE_ENABLED))
            {
                DBG_D3D((8, "   Enabling Z Writes"));
                *pFlags |= CTXT_HAS_ZWRITE_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ZWRITE_ENABLED)
            {
                DBG_D3D((8, "   Disabling Z Writes"));
                *pFlags &= ~CTXT_HAS_ZWRITE_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        break;

    case D3DRENDERSTATE_ALPHATESTENABLE:
        DBG_D3D((8, "ChangeState: Alpha Test Enable "
                    "(BOOL) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_LASTPIXEL:
        // True for last pixel on lines
        DBG_D3D((8, "ChangeState: Last Pixel "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_LASTPIXEL_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_LASTPIXEL_ENABLED;
        }
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
        DBG_D3D((8, "ChangeState: Texture magnification "
                    "(D3DTEXTUREFILTER) 0x%x",dwRSVal));
        switch(dwRSVal) {
            case D3DFILTER_NEAREST:
            case D3DFILTER_MIPNEAREST:
                pContext->bMagFilter = FALSE;
                pSoftPermedia->TextureReadMode.FilterMode = 0;
                break;
            case D3DFILTER_LINEAR:
            case D3DFILTER_MIPLINEAR:
            case D3DFILTER_LINEARMIPNEAREST:
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->bMagFilter = TRUE;
                pSoftPermedia->TextureReadMode.FilterMode = 1;
                break;
            default:
                break;
        }
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_TEXTUREMIN:
        DBG_D3D((8, "ChangeState: Texture minification "
                    "(D3DTEXTUREFILTER) 0x%x",dwRSVal));
        switch(dwRSVal) {
            case D3DFILTER_NEAREST:
            case D3DFILTER_MIPNEAREST:
                pContext->bMinFilter = FALSE;
                break;
            case D3DFILTER_MIPLINEAR:
            case D3DFILTER_LINEAR:
            case D3DFILTER_LINEARMIPNEAREST:
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->bMinFilter = TRUE;
                break;
            default:
                break;
        }
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_SRCBLEND:
        DBG_D3D((8, "ChangeState: Source Blend (D3DBLEND):"));
        DECODEBLEND(4, dwRSVal);
        switch (dwRSVal) {
            case D3DBLEND_ZERO:
                pSoftPermedia->AlphaBlendMode.SourceBlend =
                                  __PERMEDIA_BLEND_FUNC_ZERO;
                break;
            case D3DBLEND_ONE:
                pSoftPermedia->AlphaBlendMode.SourceBlend =
                                  __PERMEDIA_BLEND_FUNC_ONE;
                break;
            case D3DBLEND_SRCALPHA:
                pSoftPermedia->AlphaBlendMode.SourceBlend =
                                  __PERMEDIA_BLEND_FUNC_SRC_ALPHA;
                break;
            default:
                DBG_D3D((2,"Invalid Source Blend! - %d",
                                              dwRSVal));
                break;
        }

        // If alpha is on, we may need to validate the chosen blend
        if (*pFlags & CTXT_HAS_ALPHABLEND_ENABLED) 
            DIRTY_ALPHABLEND;

        break;

    case D3DRENDERSTATE_DESTBLEND:
        DBG_D3D((8, "ChangeState: Destination Blend (D3DBLEND):"));
        DECODEBLEND(4, dwRSVal);
        switch (dwRSVal) {
            case D3DBLEND_ZERO:
                pSoftPermedia->AlphaBlendMode.DestinationBlend =
                             __PERMEDIA_BLEND_FUNC_ZERO;
                break;
            case D3DBLEND_ONE:
                pSoftPermedia->AlphaBlendMode.DestinationBlend =
                             __PERMEDIA_BLEND_FUNC_ONE;
                break;
            case D3DBLEND_INVSRCALPHA:
                pSoftPermedia->AlphaBlendMode.DestinationBlend =
                             __PERMEDIA_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                break;
            default:
                DBG_D3D((2,"Invalid Dest Blend! - %d", dwRSVal));
                break;
        }

        // If alpha is on, we may need to validate the chosen blend
        if (*pFlags & CTXT_HAS_ALPHABLEND_ENABLED) 
            DIRTY_ALPHABLEND;

        break;

    case D3DRENDERSTATE_CULLMODE:
        DBG_D3D((8, "ChangeState: Cull Mode "
                    "(D3DCULL) 0x%x",dwRSVal));
        pContext->CullMode = (D3DCULL) dwRSVal;
        switch(dwRSVal) {
            case D3DCULL_NONE:
#ifdef P2_CHIP_CULLING
                pSoftPermedia->DeltaMode.BackfaceCull = 0;
#endif
                break;

            case D3DCULL_CCW:
#ifdef P2_CHIP_CULLING
                RENDER_NEGATIVE_CULL(pContext->RenderCommand);
                pSoftPermedia->DeltaMode.BackfaceCull = 1;
#endif
                break;

            case D3DCULL_CW:
#ifdef P2_CHIP_CULLING
                RENDER_POSITIVE_CULL(pContext->RenderCommand);
                pSoftPermedia->DeltaMode.BackfaceCull = 1;
#endif
                break;
        }
        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_ZFUNC:
        DBG_D3D((8, "ChangeState: Z Compare function "
                    "(D3DCMPFUNC) 0x%x",dwRSVal));
        switch (dwRSVal) {
            case D3DCMP_NEVER:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_NEVER;
                break;
            case D3DCMP_LESS:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_LESS;
                break;
            case D3DCMP_EQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_EQUAL;
                break;
            case D3DCMP_LESSEQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                break;
            case D3DCMP_GREATER:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_GREATER;
                break;
            case D3DCMP_NOTEQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_NOT_EQUAL;
                break;
            case D3DCMP_GREATEREQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL;
                break;
            case D3DCMP_ALWAYS:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_ALWAYS;
                break;
            default:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                break;
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_ALPHAREF:
        DBG_D3D((8, "ChangeState: Alpha Reference "
                    "(D3DFIXED) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ALPHAFUNC:
        DBG_D3D((8, "ChangeState: Alpha compare function "
                    "(D3DCMPFUNC) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_DITHERENABLE:
        DBG_D3D((8, "ChangeState: Dither Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            pSoftPermedia->DitherMode.DitherEnable = DITHER_ENABLE;
        }
        else
        {
            pSoftPermedia->DitherMode.DitherEnable = 0;
        }
        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_COLORKEYENABLE:
        DBG_D3D((8, "ChangeState: ColorKey Enable "
                    "(BOOL) 0x%x",dwRSVal));
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_MIPMAPLODBIAS:
        DBG_D3D((8, "ChangeState: Mipmap LOD Bias "
                    "(INT) 0x%x", dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ALPHABLENDENABLE:
        DBG_D3D((8, "ChangeState: Blend Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            if (!(*pFlags & CTXT_HAS_ALPHABLEND_ENABLED))
            {
                // Set the blend enable flag in the render context struct
                *pFlags |= CTXT_HAS_ALPHABLEND_ENABLED;
                DIRTY_ALPHABLEND;
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                // Turn off blend enable flag in render context struct
                *pFlags &= ~CTXT_HAS_ALPHABLEND_ENABLED;
                DIRTY_ALPHABLEND;
            }
        }
        break;

    case D3DRENDERSTATE_FOGENABLE:
        DBG_D3D((8, "ChangeState: Fog Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
                *pFlags |= CTXT_HAS_FOGGING_ENABLED;
                RENDER_FOG_ENABLE(pContext->RenderCommand);
        }
        else
        {
                *pFlags &= ~CTXT_HAS_FOGGING_ENABLED;
                RENDER_FOG_DISABLE(pContext->RenderCommand);
        }
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_FOGCOLOR:
        DBG_D3D((8, "ChangeState: Fog Color "
                    "(D3DCOLOR) 0x%x",dwRSVal));
        {
            BYTE red, green, blue, alpha;

            red = (BYTE)RGBA_GETRED(dwRSVal);
            green = (BYTE)RGBA_GETGREEN(dwRSVal);
            blue = (BYTE)RGBA_GETBLUE(dwRSVal);
            alpha = (BYTE)RGBA_GETALPHA(dwRSVal);
            DBG_D3D((4,"FogColor: Red 0x%x, Green 0x%x, Blue 0x%x",
                                                 red, green, blue));
            RESERVEDMAPTR(1);
            pSoftPermedia->FogColor = RGBA_MAKE(blue, green, red, alpha);
            SEND_PERMEDIA_DATA(FogColor, pSoftPermedia->FogColor);
            COMMITDMAPTR();
        }
        break;

    case D3DRENDERSTATE_SPECULARENABLE:
        DBG_D3D((8, "ChangeState: Specular Lighting "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_SPECULAR_ENABLED;
        } 
        else
        {
            *pFlags &= ~CTXT_HAS_SPECULAR_ENABLED;
        }
        break;

    case D3DRENDERSTATE_FILLMODE:
        DBG_D3D((8, "ChangeState: Fill Mode 0x%x",dwRSVal));
        pContext->Hdr.FillMode = dwRSVal;
        RESERVEDMAPTR(1);
        switch (dwRSVal) {
            case D3DFILL_POINT:
                DBG_D3D((4, "RM = Point"));
                // Restore the RasterizerMode
                SEND_PERMEDIA_DATA(RasterizerMode, 0);
                break;
            case D3DFILL_WIREFRAME:
                DBG_D3D((4, "RM = Wire"));
                // Add nearly a half in the delta case for lines
                // (lines aren't biased on a delta).
                SEND_PERMEDIA_DATA(RasterizerMode, BIAS_NEARLY_HALF);
                break;
            case D3DFILL_SOLID:
                DBG_D3D((4, "RM = Solid"));
                // Restore the RasterizerMode
                SEND_PERMEDIA_DATA(RasterizerMode, 0);
                break;
            default:
                // Illegal value
                DBG_D3D((4, "RM = Nonsense"));
                pContext->Hdr.FillMode = D3DFILL_SOLID;
                // Restore the RasterizerMode
                SEND_PERMEDIA_DATA(RasterizerMode, 0);
                break;
        }
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREPERSPECTIVE:
        DBG_D3D((8, "ChangeState: Texture Perspective "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            pSoftPermedia->TextureAddressMode.PerspectiveCorrection = 1;
            pSoftPermedia->DeltaMode.TextureParameterMode = 2; // Normalise
            *pFlags |= CTXT_HAS_PERSPECTIVE_ENABLED;
        }
        else
        {
            pSoftPermedia->TextureAddressMode.PerspectiveCorrection = 0;
            pSoftPermedia->DeltaMode.TextureParameterMode = 1; // Clamp
            *pFlags &= ~CTXT_HAS_PERSPECTIVE_ENABLED;
        }

        RESERVEDMAPTR(3);
        // Just to ensure that the texture unit 
        // can take the perspective change
        COPY_PERMEDIA_DATA(LBWriteMode, pSoftPermedia->LBWriteMode);
        COPY_PERMEDIA_DATA(TextureAddressMode,
                                 pSoftPermedia->TextureAddressMode);
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_ZENABLE:
        DBG_D3D((8, "ChangeState: Z Enable "
                    "(TRUE) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            if ( (!(*pFlags & CTXT_HAS_ZBUFFER_ENABLED)) &&
                 (pContext->ZBufferHandle) )
            {
                // Local Buffer Write mode
                DBG_D3D((4, "       Enabling Z Buffer"));

                *pFlags |= CTXT_HAS_ZBUFFER_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ZBUFFER_ENABLED)
            {
                DBG_D3D((4, "  Disabling Z Buffer"));
                *pFlags &= ~CTXT_HAS_ZBUFFER_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        break;

    case D3DRENDERSTATE_SHADEMODE:
        DBG_D3D((8, "ChangeState: Shade mode "
                    "(D3DSHADEMODE) 0x%x",dwRSVal));
        RESERVEDMAPTR(2);
        switch(dwRSVal) {
            case D3DSHADE_PHONG:
            case D3DSHADE_GOURAUD:
                if (!(*pFlags & CTXT_HAS_GOURAUD_ENABLED))
                {
                    pSoftPermedia->ColorDDAMode.ShadeMode = 1;

                    // Set DDA to gouraud
                    COPY_PERMEDIA_DATA(ColorDDAMode,
                                               pSoftPermedia->ColorDDAMode);
                    pSoftPermedia->DeltaMode.SmoothShadingEnable = 1;
                    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

                    *pFlags |= CTXT_HAS_GOURAUD_ENABLED;
                    // If we are textureing, some changes may need to be made
                    if (pContext->CurrentTextureHandle != 0)
                        DIRTY_TEXTURE;
                }
                break;
            case D3DSHADE_FLAT:
                if (*pFlags & CTXT_HAS_GOURAUD_ENABLED)
                {
                    pSoftPermedia->ColorDDAMode.ShadeMode = 0;

                    // Set DDA to flat
                    COPY_PERMEDIA_DATA(ColorDDAMode,
                                               pSoftPermedia->ColorDDAMode);
                    pSoftPermedia->DeltaMode.SmoothShadingEnable = 0;
                    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

                    *pFlags &= ~CTXT_HAS_GOURAUD_ENABLED;
                    // If we are textureing, some changes may need to be made
                    if (pContext->CurrentTextureHandle != 0) 
                        DIRTY_TEXTURE;
                }
                break;
        }
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_ROP2:
        DBG_D3D((8, "ChangeState: ROP (D3DROP2) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ZVISIBLE:
        // From DX6 onwards this is an obsolete render state. 
        // The D3D runtime does not support it anymore so drivers 
        // don't need to implement it
        DBG_D3D((8, "ChangeState: Z Visible 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_PLANEMASK:
        DBG_D3D((8, "ChangeState: Plane Mask "
                    "(ULONG) 0x%x",dwRSVal));
        RESERVEDMAPTR(1);
        SEND_PERMEDIA_DATA(FBHardwareWriteMask, (DWORD)dwRSVal);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_MONOENABLE:
        DBG_D3D((8, "ChangeState: Mono Raster enable "
                    "(BOOL) 0x%x", dwRSVal));
        if (dwRSVal)
        {
                *pFlags |= CTXT_HAS_MONO_ENABLED;
        }
        else
        {
                *pFlags &= ~CTXT_HAS_MONO_ENABLED;
        }
        break;

    case D3DRENDERSTATE_SUBPIXEL:
        DBG_D3D((8, "ChangeState: SubPixel Correction "
                    "(BOOL) 0x%x", dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_SUBPIXELX:
        DBG_D3D((8, "ChangeState: SubPixel Correction (xOnly) "
                    "(BOOL) 0x%x", dwRSVal));
        NOT_HANDLED;
        break;

#if D3D_STENCIL
    //
    // Stenciling Render States
    //
    case D3DRENDERSTATE_STENCILENABLE:
        DBG_D3D((8, "ChangeState: Stencil Enable "
                    "(ULONG) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            pSoftPermedia->StencilMode.UnitEnable = __PERMEDIA_ENABLE;
        }
        else
        {
            pSoftPermedia->StencilMode.UnitEnable = __PERMEDIA_DISABLE;
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILFAIL:
        DBG_D3D((8, "ChangeState: Stencil Fail Method "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DSTENCILOP_KEEP:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_KEEP;
            break;
        case D3DSTENCILOP_ZERO:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_ZERO;
            break;
        case D3DSTENCILOP_REPLACE:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_REPLACE;
            break;
        case D3DSTENCILOP_INCRSAT:
        case D3DSTENCILOP_INCR:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_INCR;
            break;
        case D3DSTENCILOP_DECR:
        case D3DSTENCILOP_DECRSAT:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_DECR;
            break;
        case D3DSTENCILOP_INVERT:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_INVERT;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil method 0x%x",
                                                   dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILZFAIL:
        DBG_D3D((8, "ChangeState: Stencil Pass Depth Fail Method "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DSTENCILOP_KEEP:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_KEEP;
            break;
        case D3DSTENCILOP_ZERO:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_ZERO;
            break;
        case D3DSTENCILOP_REPLACE:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_REPLACE;
            break;
        case D3DSTENCILOP_INCRSAT:
        case D3DSTENCILOP_INCR:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_INCR;
            break;
        case D3DSTENCILOP_DECR:
        case D3DSTENCILOP_DECRSAT:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_DECR;
            break;
        case D3DSTENCILOP_INVERT:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_INVERT;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil method 0x%x",
                                                   dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILPASS:
        DBG_D3D((8, "ChangeState: Stencil Pass Method "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DSTENCILOP_KEEP:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_KEEP;
            break;
        case D3DSTENCILOP_ZERO:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_ZERO;
            break;
        case D3DSTENCILOP_REPLACE:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_REPLACE;
            break;
        case D3DSTENCILOP_INCRSAT:
        case D3DSTENCILOP_INCR:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_INCR;
            break;
        case D3DSTENCILOP_DECR:
        case D3DSTENCILOP_DECRSAT:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_DECR;
            break;
        case D3DSTENCILOP_INVERT:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_INVERT;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil method 0x%x",
                                                dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILFUNC:
        DBG_D3D((8, "ChangeState: Stencil Comparison Function "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DCMP_NEVER:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_NEVER;
            break;
        case D3DCMP_LESS:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_LESS;
            break;
        case D3DCMP_EQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_EQUAL;
            break;
        case D3DCMP_LESSEQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_LESS_OR_EQUAL;
            break;
        case D3DCMP_GREATER:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_GREATER;
            break;
        case D3DCMP_NOTEQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_NOT_EQUAL;
            break;
        case D3DCMP_GREATEREQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL;
            break;
        case D3DCMP_ALWAYS:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_ALWAYS;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil comparison function 0x%x",
                                                       dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILREF:
        DBG_D3D((8, "ChangeState: Stencil Reference Value "
                    "(ULONG) 0x%x",dwRSVal));
        pSoftPermedia->StencilData.ReferenceValue =
                                     ( dwRSVal & 0x0001 );
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILMASK:
        DBG_D3D((8, "ChangeState: Stencil Compare Mask "
                    "(ULONG) 0x%x",dwRSVal));
        pSoftPermedia->StencilData.CompareMask =
                                    ( dwRSVal & 0x0001 );
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILWRITEMASK:
        DBG_D3D((8, "ChangeState: Stencil Write Mask "
                    "(ULONG) 0x%x",dwRSVal));
        pSoftPermedia->StencilData.WriteMask =
                                    ( dwRSVal & 0x0001 );
        DIRTY_ZBUFFER;
        break;
#endif // D3D_STENCIL

    //
    // Stippling
    //
    case D3DRENDERSTATE_STIPPLEDALPHA:
        DBG_D3D((8, "ChangeState: Stippled Alpha "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            if (!(*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED))
            {
                // Force a new start on the Alpha pattern
                pContext->LastAlpha = 16;

                *pFlags |= CTXT_HAS_ALPHASTIPPLE_ENABLED;
                if (pContext->bKeptStipple == TRUE)
                {
                    RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
                }
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED)
            {
                // If Alpha Stipple is being turned off, turn the normal
                // stipple back on, and enable it.
                int i;
                RESERVEDMAPTR(8);
                for (i = 0; i < 8; i++)
                {
                    SEND_PERMEDIA_DATA_OFFSET(AreaStipplePattern0, 
                                  (DWORD)pContext->CurrentStipple[i], i);
                }
                COMMITDMAPTR();
                *pFlags &= ~CTXT_HAS_ALPHASTIPPLE_ENABLED;

                if (pContext->bKeptStipple == TRUE)
                {
                    RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
                }
            }
        }
        break;

    case D3DRENDERSTATE_STIPPLEENABLE:
        DBG_D3D((8, "ChangeState: Stipple Enable "
                    "(BOOL) 0x%x", dwRSVal));
        if (dwRSVal)
        {
            if (!(*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED))
            {
                    RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
            }
            pContext->bKeptStipple = TRUE;
        }
        else
        {
            RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
            pContext->bKeptStipple = FALSE;
        }
        break;

    case D3DRENDERSTATE_CLIPPING:
        DBG_D3D((8, "ChangeState: Clipping 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_LIGHTING:
        DBG_D3D((8, "ChangeState: Lighting 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_EXTENTS:
        DBG_D3D((8, "ChangeState: Extents 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_AMBIENT:
        DBG_D3D((8, "ChangeState: Ambient 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_FOGVERTEXMODE:
        DBG_D3D((8, "ChangeState: Fog Vertex Mode 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_COLORVERTEX:
        DBG_D3D((8, "ChangeState: Color Vertex 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_LOCALVIEWER:
        DBG_D3D((8, "ChangeState: LocalViewer 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_NORMALIZENORMALS:
        DBG_D3D((8, "ChangeState: Normalize Normals 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_COLORKEYBLENDENABLE:
        DBG_D3D((8, "ChangeState: Colorkey Blend Enable 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Diffuse Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Specular Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Ambient Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Emmisive Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;
    case D3DRENDERSTATE_VERTEXBLEND:
        DBG_D3D((8, "ChangeState: Vertex Blend 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_CLIPPLANEENABLE:
        DBG_D3D((8, "ChangeState: Clip Plane Enable 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_SCENECAPTURE:
        // This state pass TRUE or FALSE to replace the functionality
        // of D3DHALCallbacks->SceneCapture(), Permedia2 Hardware doesn't
        // need begin/end scene information, therefore it's a NOOP here.
        if (dwRSVal)
            TextureCacheManagerResetStatCounters(pContext->pTextureManager);

        DBG_D3D((8,"D3DRENDERSTATE_SCENECAPTURE=%x", (DWORD)dwRSVal));
        NOT_HANDLED;
        break;
    case D3DRENDERSTATE_EVICTMANAGEDTEXTURES:
        DBG_D3D((8,"D3DRENDERSTATE_EVICTMANAGEDTEXTURES=%x", (DWORD)dwRSVal));
        if (NULL != pContext->pTextureManager)
            TextureCacheManagerEvictTextures(pContext->pTextureManager);
        break;

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    case D3DRENDERSTATE_POINTSIZE:
        DBG_D3D((8, "ChangeState: Point size 0x%x",dwRSVal));
        (DWORD&)(pContext->fPointSize) = dwRSVal;
        break;

    case D3DRENDERSTATE_POINTSPRITE_ENABLE:
        DBG_D3D((8, "ChangeState: Point Sprite Enable 0x%x",dwRSVal));
        pContext->bPointSpriteEnabled = dwRSVal;
        break;

    // All of the following point sprite related render states are
    // ignored by this driver since we are a Non-TnLHal driver.
    case D3DRENDERSTATE_POINTATTENUATION_A:
        DBG_D3D((8, "ChangeState: Point Attenuation A 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_POINTATTENUATION_B:
        DBG_D3D((8, "ChangeState: Point Attenuation B 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_POINTATTENUATION_C:
        DBG_D3D((8, "ChangeState: Point Attenuation C 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_POINTSIZEMIN:
        DBG_D3D((8, "ChangeState: Point Size Min 0x%x",dwRSVal));
        NOT_HANDLED;
        break;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

    case D3DRENDERSTATE_WRAP0:
    case D3DRENDERSTATE_WRAP1:
    case D3DRENDERSTATE_WRAP2:
    case D3DRENDERSTATE_WRAP3:
    case D3DRENDERSTATE_WRAP4:
    case D3DRENDERSTATE_WRAP5:
    case D3DRENDERSTATE_WRAP6:
    case D3DRENDERSTATE_WRAP7:
        DBG_D3D((8, "ChangeState: Wrap(%x) "
                    "(BOOL) 0x%x",(dwRSType - D3DRENDERSTATE_WRAPBIAS ),dwRSVal));
        pContext->dwWrap[dwRSType - D3DRENDERSTATE_WRAPBIAS] = dwRSVal;
        break;

    default:
        if ((dwRSType >= D3DRENDERSTATE_STIPPLEPATTERN00) && 
            (dwRSType <= D3DRENDERSTATE_STIPPLEPATTERN07))
        {
            DBG_D3D((8, "ChangeState: Loading Stipple0x%x with 0x%x",
                                    dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00,
                                    (DWORD)dwRSVal));

            pContext->CurrentStipple[(dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00)] =
                                                         (BYTE)dwRSVal;

            if (!(*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED))
            {
                // Flat-Stippled Alpha is not on, so use the 
                // current stipple pattern
                RESERVEDMAPTR(1);
                SEND_PERMEDIA_DATA_OFFSET(AreaStipplePattern0,
                                    (DWORD)dwRSVal,
                                    dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00);
                COMMITDMAPTR();
            }
        }
        else
        {
            DBG_D3D((2, "ChangeState: Unhandled opcode = %d", dwRSType));
        }
        break;
    } // switch (dwRSType of renderstate)

    // Mirror any change that happened in the render states into TSS 0
    __MapRS_Into_TSS0(pContext, dwRSType, dwRSVal);

    DBG_D3D((10,"Exiting __ProcessRenderStates"));
}

//-----------------------------------------------------------------------------
//
// DWORD __ProcessPermediaStates
//
// Handle render state changes that arrive through the D3DDP2OP_RENDERSTATE
// token in the DP2 command stream.
//
//-----------------------------------------------------------------------------
DWORD 
__ProcessPermediaStates(PERMEDIA_D3DCONTEXT* pContext, 
                        DWORD dwCount,
                        LPD3DSTATE lpState,
                        LPDWORD lpStateMirror)
{

    DWORD dwRSType, dwRSVal, i;

    DBG_D3D((10,"Entering __ProcessPermediaStates"));
    DBG_D3D((4, "__ProcessPermediaStates: Processing %d State changes", dwCount));

    // Loop through all renderstates passed in the DP2 command stream
    for (i = 0; i < dwCount; i++, lpState++)
    {
        dwRSType = (DWORD) lpState->drstRenderStateType;
        dwRSVal  = (DWORD) lpState->dwArg[0];

        DBG_D3D((8, "__ProcessPermediaStates state %d value = %d",
                                          dwRSType, dwRSVal));

        // Check validity of the render state
        if (!VALID_STATE(dwRSType))
        {
            DBG_D3D((0, "state 0x%08x is invalid", dwRSType));
            return DDERR_INVALIDPARAMS;
        }

        // Verify if state needs to be overrided or ignored
        if (IS_OVERRIDE(dwRSType))
        {
            DWORD override = GET_OVERRIDE(dwRSType);
            if (dwRSVal)
            {
                DBG_D3D((4, "in RenderState, setting override for state %d",
                                                                   override));
                STATESET_SET(pContext->overrides, override);
            }
            else
            {
                DBG_D3D((4, "in RenderState, clearing override for state %d",
                                                                    override));
                STATESET_CLEAR(pContext->overrides, override);
            }
            continue;
        }

        if (STATESET_ISSET(pContext->overrides, dwRSType))
        {
            DBG_D3D((4, "in RenderState, state %d is overridden, ignoring",
                                                                      dwRSType));
            continue;
        }

#if D3D_STATEBLOCKS
        if (!pContext->bStateRecMode)
        {
#endif D3D_STATEBLOCKS
            // Store the state in the context
            pContext->RenderStates[dwRSType] = dwRSVal;

            // Mirror value
            if ( lpStateMirror )
                lpStateMirror[dwRSType] = dwRSVal;


            __ProcessRenderStates(pContext, dwRSType, dwRSVal);
#if D3D_STATEBLOCKS
        }
        else
        {
            if (pContext->pCurrSS != NULL)
            {
                DBG_D3D((6,"Recording RS %x = %x",dwRSType,dwRSVal));

                // Recording the state in a stateblock
                pContext->pCurrSS->u.uc.RenderStates[dwRSType] = dwRSVal;
                FLAG_SET(pContext->pCurrSS->u.uc.bStoredRS,dwRSType);
            }
        }
#endif D3D_STATEBLOCKS

    } // for (i)

    DBG_D3D((10,"Exiting __ProcessPermediaStates"));

    return DD_OK;
} // __ProcessPermediaStates

#if D3D_STATEBLOCKS
//-----------------------------------------------------------------------------
//
// P2StateSetRec *FindStateSet
//
// Find a state identified by dwHandle starting from pRootSS.
// If not found, returns NULL.
//
//-----------------------------------------------------------------------------
P2StateSetRec *FindStateSet(PERMEDIA_D3DCONTEXT* pContext,
                            DWORD dwHandle)
{
    if (dwHandle <= pContext->dwMaxSSIndex)
        return pContext->pIndexTableSS[dwHandle - 1];
    else
    {
        DBG_D3D((2,"State set %x not found (Max = %x)",
                    dwHandle, pContext->dwMaxSSIndex));
        return NULL;
    }
}

//-----------------------------------------------------------------------------
//
// void DumpStateSet
//
// Dump info stored in a state set
//
//-----------------------------------------------------------------------------
#define ELEMS_IN_ARRAY(a) ((sizeof(a)/sizeof(a[0])))

void DumpStateSet(P2StateSetRec *pSSRec)
{
    DWORD i;

    DBG_D3D((0,"DumpStateSet %x, Id=%x bCompressed=%x",
                pSSRec,pSSRec->dwHandle,pSSRec->bCompressed));

    if (!pSSRec->bCompressed)
    {
        // uncompressed state set

        // Dump render states values
        for (i=0; i< MAX_STATE; i++)
        {
            DBG_D3D((0,"RS %x = %x",i, pSSRec->u.uc.RenderStates[i]));
        }

        // Dump TSS's values
        for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
        {
            DBG_D3D((0,"TSS %x = %x",i, pSSRec->u.uc.TssStates[i]));
        }

        // Dump RS bit masks
        for (i=0; i< ELEMS_IN_ARRAY(pSSRec->u.uc.bStoredRS); i++)
        {
            DBG_D3D((0,"bStoredRS[%x] = %x",i, pSSRec->u.uc.bStoredRS[i]));
        }

        // Dump TSS bit masks
        for (i=0; i< ELEMS_IN_ARRAY(pSSRec->u.uc.bStoredTSS); i++)
        {
            DBG_D3D((0,"bStoredTSS[%x] = %x",i, pSSRec->u.uc.bStoredTSS[i]));
        }

    }
    else
    {
        // compressed state set

        DBG_D3D((0,"dwNumRS =%x  dwNumTSS=%x",
                    pSSRec->u.cc.dwNumRS,pSSRec->u.cc.dwNumTSS));

        // dump compressed state
        for (i=0; i< pSSRec->u.cc.dwNumTSS + pSSRec->u.cc.dwNumRS; i++)
        {
            DBG_D3D((0,"RS/TSS %x = %x",
                        pSSRec->u.cc.pair[i].dwType, 
                        pSSRec->u.cc.pair[i].dwValue));
        }

    }

}

//-----------------------------------------------------------------------------
//
// void AddStateSetIndexTableEntry
//
// Add an antry to the index table. If necessary, grow it.
//-----------------------------------------------------------------------------
void AddStateSetIndexTableEntry(PERMEDIA_D3DCONTEXT* pContext,
                                DWORD dwNewHandle,
                                P2StateSetRec *pNewSSRec)
{
    DWORD dwNewSize;
    P2StateSetRec **pNewIndexTableSS;

    // If the current list is not large enough, we'll have to grow a new one.
    if (dwNewHandle > pContext->dwMaxSSIndex)
    {
        // New size of our index table
        // (round up dwNewHandle in steps of SSPTRS_PERPAGE)
        dwNewSize = ((dwNewHandle -1 + SSPTRS_PERPAGE) / SSPTRS_PERPAGE)
                      * SSPTRS_PERPAGE;

        // we have to grow our list
        pNewIndexTableSS = (P2StateSetRec **)
                                ENGALLOCMEM( FL_ZERO_MEMORY,
                                             dwNewSize*sizeof(P2StateSetRec *),
                                             ALLOC_TAG);

        if (!pNewIndexTableSS)
        {
            // we weren't able to grow the list so we will keep the old one
            // and (sigh) forget about this state set since that is the 
            // safest thing to do. We will delete also the state set structure
            // since no one will otherwise be able to find it later.
            DBG_D3D((0,"Out of mem growing state set list,"
                       " droping current state set"));
            ENGFREEMEM(pNewSSRec);
            return;
        }

        if (pContext->pIndexTableSS)
        {
            // if we already had a previous list, we must transfer its data
            memcpy(pNewIndexTableSS, 
                   pContext->pIndexTableSS,
                   pContext->dwMaxSSIndex*sizeof(P2StateSetRec *));
            
            //and get rid of it
            ENGFREEMEM(pContext->pIndexTableSS);
        }

        // New index table data
        pContext->pIndexTableSS = pNewIndexTableSS;
        pContext->dwMaxSSIndex = dwNewSize;
    }

    // Store our state set pointer into our access list
    pContext->pIndexTableSS[dwNewHandle - 1] = pNewSSRec;
}

//-----------------------------------------------------------------------------
//
// void CompressStateSet
//
// Compress a state set so it uses the minimum necessary space. Since we expect 
// some apps to make extensive use of state sets we want to keep things tidy.
// Returns address of new structure (ir old, if it wasn't compressed)
//
//-----------------------------------------------------------------------------
P2StateSetRec * CompressStateSet(PERMEDIA_D3DCONTEXT* pContext,
                                 P2StateSetRec *pUncompressedSS)
{
    P2StateSetRec *pCompressedSS;
    DWORD i, dwSize, dwIndex, dwCount;

    // Create a new state set of just the right size we need

    // Calculate how large 
    dwCount = 0;
    for (i=0; i< MAX_STATE; i++)
        if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredRS , i))
        {
            dwCount++;
        };

    for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
        if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredTSS , i))
        {
            dwCount++;
        };

    // Create a new state set of just the right size we need
    // ANY CHANGE MADE TO THE P2StateSetRec structure MUST BE REFLECTED HERE!
    dwSize = 2*sizeof(DWORD) +                          // handle , flags
             2*sizeof(DWORD) +                          // # of RS & TSS
             2*dwCount*sizeof(DWORD);                   // compressed structure

    if (dwSize >= sizeof(P2StateSetRec))
    {
        // it is not efficient to compress, leave uncompressed !
        pUncompressedSS->bCompressed = FALSE;
        return pUncompressedSS;
    }

    pCompressedSS = (P2StateSetRec *)ENGALLOCMEM( FL_ZERO_MEMORY,
                                                    dwSize, ALLOC_TAG);

    if (pCompressedSS)
    {
        // adjust data in new compressed state set
        pCompressedSS->bCompressed = TRUE;
        pCompressedSS->dwHandle = pUncompressedSS->dwHandle;

        // Transfer our info to this new state set
        pCompressedSS->u.cc.dwNumRS = 0;
        pCompressedSS->u.cc.dwNumTSS = 0;
        dwIndex = 0;

        for (i=0; i< MAX_STATE; i++)
            if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredRS , i))
            {
                pCompressedSS->u.cc.pair[dwIndex].dwType = i;
                pCompressedSS->u.cc.pair[dwIndex].dwValue = 
                                    pUncompressedSS->u.uc.RenderStates[i];
                pCompressedSS->u.cc.dwNumRS++;
                dwIndex++;
            }

        for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
            if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredTSS , i))
            {
                pCompressedSS->u.cc.pair[dwIndex].dwType = i;
                pCompressedSS->u.cc.pair[dwIndex].dwValue = 
                                    pUncompressedSS->u.uc.TssStates[i];
                pCompressedSS->u.cc.dwNumTSS++;
                dwIndex++;
            }

        // Get rid of the old(uncompressed) one
        ENGFREEMEM(pUncompressedSS);
        return pCompressedSS;

    }
    else
    {
        DBG_D3D((0,"Not enough memory left to compress D3D state set"));
        pUncompressedSS->bCompressed = FALSE;
        return pUncompressedSS;
    }

}

//-----------------------------------------------------------------------------
//
// void __DeleteAllStateSets
//
// Delete any remaining state sets for cleanup purpouses
//
//-----------------------------------------------------------------------------
void __DeleteAllStateSets(PERMEDIA_D3DCONTEXT* pContext)
{
    P2StateSetRec *pSSRec;
    DWORD dwSSIndex;

    DBG_D3D((10,"Entering __DeleteAllStateSets"));

    if (pContext->pIndexTableSS)
    {
        for(dwSSIndex = 0; dwSSIndex < pContext->dwMaxSSIndex; dwSSIndex++)
        {
            if (pSSRec = pContext->pIndexTableSS[dwSSIndex])
            {
                ENGFREEMEM(pSSRec);
            }
        }

        // free fast index table
        ENGFREEMEM(pContext->pIndexTableSS);
    }

    DBG_D3D((10,"Exiting __DeleteAllStateSets"));
}

//-----------------------------------------------------------------------------
//
// void __BeginStateSet
//
// Create a new state set identified by dwParam and start recording states
//
//-----------------------------------------------------------------------------
void __BeginStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __BeginStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;

    // Create a new state set
    pSSRec = (P2StateSetRec *)ENGALLOCMEM( FL_ZERO_MEMORY,
                                           sizeof(P2StateSetRec), ALLOC_TAG);
    if (!pSSRec)
    {
        DBG_D3D((0,"Run out of memory for additional state sets"));
        return;
    }

    // remember handle to current state set
    pSSRec->dwHandle = dwParam;
    pSSRec->bCompressed = FALSE;

    // Get pointer to current recording state set
    pContext->pCurrSS = pSSRec;

    // Start recording mode
    pContext->bStateRecMode = TRUE;

    DBG_D3D((10,"Exiting __BeginStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __EndStateSet
//
// stop recording states - revert to executing them.
//
//-----------------------------------------------------------------------------
void __EndStateSet(PERMEDIA_D3DCONTEXT* pContext)
{
    DWORD dwHandle;
    P2StateSetRec *pNewSSRec;

    DBG_D3D((10,"Entering __EndStateSet"));

    if (pContext->pCurrSS)
    {
        dwHandle = pContext->pCurrSS->dwHandle;

        // compress the current state set
        // Note: after being compressed the uncompressed version is free'd.
        pNewSSRec = CompressStateSet(pContext, pContext->pCurrSS);

        AddStateSetIndexTableEntry(pContext, dwHandle, pNewSSRec);
    }

    // No state set being currently recorded
    pContext->pCurrSS = NULL;

    // End recording mode
    pContext->bStateRecMode = FALSE;


    DBG_D3D((10,"Exiting __EndStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __DeleteStateSet
//
// Delete the recorder state ste identified by dwParam
//
//-----------------------------------------------------------------------------
void __DeleteStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __DeleteStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;
    DWORD i;

    if (pSSRec = FindStateSet(pContext, dwParam))
    {
        // Clear index table entry
        pContext->pIndexTableSS[dwParam - 1] = NULL;

        // Now delete the actual state set structure
        ENGFREEMEM(pSSRec);
    }

    DBG_D3D((10,"Exiting __DeleteStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __ExecuteStateSet
//
//
//-----------------------------------------------------------------------------
void __ExecuteStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __ExecuteStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;
    DWORD i;

    if (pSSRec = FindStateSet(pContext, dwParam))
    {

        if (!pSSRec->bCompressed)
        {
            // uncompressed state set

            // Execute any necessary render states
            for (i=0; i< MAX_STATE; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredRS , i))
                {
                    DWORD dwRSType, dwRSVal;

                    dwRSType = i;
                    dwRSVal = pSSRec->u.uc.RenderStates[dwRSType];

                    // Store the state in the context
                    pContext->RenderStates[dwRSType] = dwRSVal;

                    DBG_D3D((6,"__ExecuteStateSet RS %x = %x",
                                dwRSType, dwRSVal));

                    // Process it
                    __ProcessRenderStates(pContext, dwRSType, dwRSVal);

                    DIRTY_TEXTURE;
                    DIRTY_ZBUFFER;
                    DIRTY_ALPHABLEND;
                }

            // Execute any necessary TSS's
            for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredTSS , i))
                {
                    DWORD dwTSState, dwValue;

                    dwTSState = i;
                    dwValue = pSSRec->u.uc.TssStates[dwTSState];

                    DBG_D3D((6,"__ExecuteStateSet TSS %x = %x",
                                dwTSState, dwValue));

                    // Store value associated to this stage state
                    pContext->TssStates[dwTSState] = dwValue;

                    // Perform any necessary preprocessing of it
                    __HWPreProcessTSS(pContext, 0, dwTSState, dwValue);

                    DIRTY_TEXTURE;
                }

            // Execute any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -
        }
        else
        {
            // compressed state set

            // Execute any necessary render states
            for (i=0; i< pSSRec->u.cc.dwNumRS; i++)
            {
                DWORD dwRSType, dwRSVal;

                dwRSType = pSSRec->u.cc.pair[i].dwType;
                dwRSVal = pSSRec->u.cc.pair[i].dwValue;

                // Store the state in the context
                pContext->RenderStates[dwRSType] = dwRSVal;

                DBG_D3D((6,"__ExecuteStateSet RS %x = %x",
                            dwRSType, dwRSVal));

                // Process it
                __ProcessRenderStates(pContext, dwRSType, dwRSVal);

                DIRTY_TEXTURE;
                DIRTY_ZBUFFER;
                DIRTY_ALPHABLEND;
            }

            // Execute any necessary TSS's
            for (; i< pSSRec->u.cc.dwNumTSS + pSSRec->u.cc.dwNumRS; i++)
            {
                DWORD dwTSState, dwValue;

                dwTSState = pSSRec->u.cc.pair[i].dwType;
                dwValue = pSSRec->u.cc.pair[i].dwValue;

                DBG_D3D((6,"__ExecuteStateSet TSS %x = %x",
                            dwTSState, dwValue));

                // Store value associated to this stage state
                pContext->TssStates[dwTSState] = dwValue;

                // Perform any necessary preprocessing of it
                __HWPreProcessTSS(pContext, 0, dwTSState, dwValue);

                DIRTY_TEXTURE;
            }

            // Execute any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -

        }
    }

    DBG_D3D((10,"Exiting __ExecuteStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __CaptureStateSet
//
//
//-----------------------------------------------------------------------------
void __CaptureStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __CaptureStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;
    DWORD i;

    if (pSSRec = FindStateSet(pContext, dwParam))
    {
        if (!pSSRec->bCompressed)
        {
            // uncompressed state set

            // Capture any necessary render states
            for (i=0; i< MAX_STATE; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredRS , i))
                {
                    pSSRec->u.uc.RenderStates[i] = pContext->RenderStates[i];
                }

            // Capture any necessary TSS's
            for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredTSS , i))
                {
                    pSSRec->u.uc.TssStates[i] = pContext->TssStates[i];
                }

            // Capture any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -
        }
        else
        {
            // compressed state set

            // Capture any necessary render states
            for (i=0; i< pSSRec->u.cc.dwNumRS; i++)
            {
                DWORD dwRSType;

                dwRSType = pSSRec->u.cc.pair[i].dwType;
                pSSRec->u.cc.pair[i].dwValue = pContext->RenderStates[dwRSType];

            }

            // Capture any necessary TSS's
            for (; i< pSSRec->u.cc.dwNumTSS + pSSRec->u.cc.dwNumRS; i++)
                {
                    DWORD dwTSState;

                    dwTSState = pSSRec->u.cc.pair[i].dwType;
                    pSSRec->u.cc.pair[i].dwValue = pContext->TssStates[dwTSState];
                }

            // Capture any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -

        }
    }

    DBG_D3D((10,"Exiting __CaptureStateSet"));
}
#endif //D3D_STATEBLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dpoint.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dpoint.c
*
* Content:    Direct3D hw point rasterization code.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3ddelta.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#if defined(_ALPHA_)
#include <math.h>
#endif

//-----------------------------------------------------------------------------
//
// VOID P2_Draw_FVF_Point
//
// Hardare render a single point coming from a FVF vertex
// 
// Primitive rendering at this stage is dependent upon the current value/setting
// of texturing, perspective correction, fogging, gouraud/flat shading, and
// specular highlights.
//
//-----------------------------------------------------------------------------
VOID
P2_Draw_FVF_Point(PERMEDIA_D3DCONTEXT  *pContext,
                  LPD3DTLVERTEX        lpV0, 
                  LPP2FVFOFFSETS       lpFVFOff)
{
    PPDev       pPdev       = pContext->ppdev;
    DWORD       dwFlags     = pContext->Hdr.Flags;
    ULONG       ulRenderCmd = pContext->RenderCommand;
    DWORD       dwColorOffs,dwSpecularOffs,dwTexOffs;
    D3DCOLOR    dwColor, dwSpecular;
    D3DVALUE    fKs, fS, fT, fQ;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering P2_Draw_FVF_Point"));

    // Set point rendering mode
    RENDER_POINT(ulRenderCmd);

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    RESERVEDMAPTR(0x80);
    SEND_PERMEDIA_DATA(RasterizerMode, BIAS_NEARLY_HALF);

    // Get vertex color value (FVF based)
    if (dwColorOffs)
    {
        dwColor = FVFCOLOR(lpV0, dwColorOffs)->color;
        if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
        {
            dwColor  |= 0xFF000000;
        }
    }
    else
    {
        // must set default in case no D3DFVF_DIFFUSE
        dwColor = 0xFFFFFFFF;
    }

    // Get vertex specular value (FVF based) if necessary
    if ((dwFlags & (CTXT_HAS_SPECULAR_ENABLED | CTXT_HAS_FOGGING_ENABLED))
        && (dwSpecularOffs != 0))
    {
        dwSpecular = FVFSPEC(lpV0, dwSpecularOffs)->specular;
    }

    if ((dwFlags & CTXT_HAS_TEXTURE_ENABLED) && (dwTexOffs != 0))
    {
        // Get s,t texture coordinates (FVF based)
        fS = FVFTEX(lpV0,dwTexOffs)->tu;
        fT = FVFTEX(lpV0,dwTexOffs)->tv;

        // Scale s,t coordinate values
        fS *= pContext->DeltaWidthScale;
        fT *= pContext->DeltaHeightScale;

        // Apply perpspective corrections if necessary
        if (dwFlags & CTXT_HAS_PERSPECTIVE_ENABLED)
        {
            fQ = lpV0->rhw;
            fS *= fQ;
            fT *= fQ;
        }
        else
        {
            fQ = 1.0;
        }

        // Send points s,t,q,ks (conditionaly),x,y,z values
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs != 0))
        {
            fKs = RGB256_TO_LUMA(RGB_GETRED(dwSpecular),
                                 RGB_GETGREEN(dwSpecular),
                                 RGB_GETBLUE(dwSpecular));

            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV0FloatS, fS, fT, fQ, fKs,
                                                  lpV0->sx, lpV0->sy, lpV0->sz);
        } 
        else 
        {
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV0FloatS, fS, fT, fQ, 
                                                  lpV0->sx, lpV0->sy, lpV0->sz);
        }
    }
    else // not textured point
    {
        // If specular is enabled, change the colours
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs != 0))
        {
            CLAMP8888(dwColor, dwColor, dwSpecular);
        }

        // Send lines x,y,z values
        SEND_VERTEX_XYZ(__Permedia2TagV0FloatS, lpV0->sx, lpV0->sy, lpV0->sz);
    }

    // If fog is set, send the appropriate value
    if ((dwFlags & CTXT_HAS_FOGGING_ENABLED) && (dwSpecularOffs != 0))
    {
        SEND_VERTEX_FOG(__Permedia2TagV0FixedF, RGB_GET_GAMBIT_FOG(dwSpecular));
    }

    // Send appropriate color depending on Gouraud , Mono, & Alpha
    if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
    {
        // Gouraud shading
        if (RENDER_MONO)
        {
            SEND_VERTEX_RGB_MONO_P2(__Permedia2TagV0FixedS, dwColor);
        }
        else
        {
            if (dwFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
                {
                    dwColor &= 0xFFFFFF;  // supress color's alpha value
                }
            }
            SEND_VERTEX_RGBA_P2(__Permedia2TagV0FixedS, dwColor);
        }
    }
    else        // Flat shading
    {
        if (RENDER_MONO)
        {
            // Get constant color from the blue channel
            DWORD BlueChannel = RGBA_GETBLUE(dwColor);
            SEND_PERMEDIA_DATA(ConstantColor,
                RGB_MAKE(BlueChannel, BlueChannel, BlueChannel));
        }
        else
        {
            if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
            {
                dwColor &= 0xFFFFFF;
            }
            SEND_PERMEDIA_DATA(ConstantColor,
                RGBA_MAKE(RGBA_GETBLUE(dwColor),
                          RGBA_GETGREEN(dwColor), 
                          RGBA_GETRED(dwColor), 
                          RGBA_GETALPHA(dwColor)));
        }
    }

    SEND_PERMEDIA_DATA(DrawLine01, ulRenderCmd);
    SEND_PERMEDIA_DATA(RasterizerMode, 0);
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting P2_Draw_FVF_Point"));

} // P2_Draw_FVF_Point

//-----------------------------------------------------------------------------
//
// void P2_Draw_FVF_Point_Tri
//
// Render a triangle with FVF vertexes when the point fillmode is active
//
//-----------------------------------------------------------------------------
void 
P2_Draw_FVF_Point_Tri(PERMEDIA_D3DCONTEXT *pContext, 
                      LPD3DTLVERTEX lpV0, 
                      LPD3DTLVERTEX lpV1,
                      LPD3DTLVERTEX lpV2, 
                      LPP2FVFOFFSETS lpFVFOff)
{
    D3DFVFDRAWPNTFUNCPTR       pPoint;

    DBG_D3D((10,"Entering P2_Draw_FVF_Point_Tri"));

    pPoint = __HWSetPointFunc(pContext, lpFVFOff);
    (*pPoint)(pContext, lpV0, lpFVFOff);
    (*pPoint)(pContext, lpV1, lpFVFOff);
    (*pPoint)(pContext, lpV2, lpFVFOff);

    DBG_D3D((10,"Exiting P2_Draw_FVF_Point_Tri"));

} // P2_Draw_FVF_Point_Tri

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
//-----------------------------------------------------------------------------
//
// void P2_Draw_FVF_Point_Sprite
//
// Render a point sprite with FVF vertexes when the point sprite enable is on
//
//-----------------------------------------------------------------------------
#define SPRITETEXCOORDMAX (4095.75F/4096.F)

void 
P2_Draw_FVF_Point_Sprite(PERMEDIA_D3DCONTEXT *pContext, 
                         LPD3DTLVERTEX lpV0, 
                         LPP2FVFOFFSETS lpFVFOff)
{
    P2FVFMAXVERTEX fvfVUL, fvfVUR, fvfVLL, fvfVLR;
    DWORD       dwColorOffs,dwSpecularOffs,dwTexOffs;
    D3DVALUE fPntSize, fPntSizeHalf;

    DBG_D3D((10,"Entering P2_Draw_FVF_Point_Sprite"));

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    // Compute point sprite size
    if (lpFVFOff->dwPntSizeOffset)
    {
        fPntSize = FVFPSIZE(lpV0, lpFVFOff->dwPntSizeOffset)->psize;
    }
    else
    {
        fPntSize = pContext->fPointSize;
    }

    // Initialize square values
    memcpy( &fvfVUL, lpV0, lpFVFOff->dwStride);
    memcpy( &fvfVUR, lpV0, lpFVFOff->dwStride);
    memcpy( &fvfVLL, lpV0, lpFVFOff->dwStride);
    memcpy( &fvfVLR, lpV0, lpFVFOff->dwStride);

    // Clamp point size to zero
    if (fPntSize > 0.0f)
        fPntSizeHalf =  fPntSize * 0.5f;
    else
        fPntSizeHalf = 0.0f;

    // Make this a square of size fPntSize
    ((D3DTLVERTEX *)&fvfVUL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVUL)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVUR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVUR)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVLL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVLL)->sy += fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVLR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVLR)->sy += fPntSizeHalf;

    if ((pContext->bPointSpriteEnabled) && (dwTexOffs))
    {
        // Modify texture coordinates according to spec
        FVFTEX(&fvfVUL, dwTexOffs)->tu = 0.0f;
        FVFTEX(&fvfVUL, dwTexOffs)->tv = 0.0f;

        FVFTEX(&fvfVUR, dwTexOffs)->tu = SPRITETEXCOORDMAX;
        FVFTEX(&fvfVUR, dwTexOffs)->tv = 0.0f;

        FVFTEX(&fvfVLL, dwTexOffs)->tu = 0.0f;
        FVFTEX(&fvfVLL, dwTexOffs)->tv = SPRITETEXCOORDMAX;

        FVFTEX(&fvfVLR, dwTexOffs)->tu = SPRITETEXCOORDMAX;
        FVFTEX(&fvfVLR, dwTexOffs)->tv = SPRITETEXCOORDMAX;
    }


   // here we are going to send the required quad
    P2_Draw_FVF_Solid_Tri(pContext, (D3DTLVERTEX *)&fvfVUL,
                                    (D3DTLVERTEX *)&fvfVUR,
                                    (D3DTLVERTEX *)&fvfVLL, lpFVFOff);

    P2_Draw_FVF_Solid_Tri(pContext, (D3DTLVERTEX *)&fvfVLL,
                                    (D3DTLVERTEX *)&fvfVUR,
                                    (D3DTLVERTEX *)&fvfVLR, lpFVFOff);

    DBG_D3D((10,"Exiting P2_Draw_FVF_Point_Sprite"));
}
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dsoft.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsoft.h
*
*  Content:  D3D hw register value tracking mechanism.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifdef __SOFTCOPY
#pragma message ("FILE : "__FILE__" : Multiple Inclusion");
#endif

#define __SOFTCOPY


// For the Permedia 2 specific registers.
#include "p2regs.h"


//-----------------------------------------------------------------------------
//     Permedia 2 hardware registers software copy structure definition
//-----------------------------------------------------------------------------
typedef struct {
    // Common Local Buffer Registers
    __Permedia2LBReadModeFmat                LBReadMode;
    __Permedia2LBReadFormatFmat              LBReadFormat;
    __Permedia2LBWriteModeFmat               LBWriteMode;

    // Common Frame Buffer Registers
    __Permedia2FBReadModeFmat                FBReadMode;
    __Permedia2FBWriteModeFmat               FBWriteMode;
    DWORD                                    FBReadPixel;
    __Permedia2LogicalOpModeFmat             LogicalOpMode;
    __Permedia2DitherModeFmat                DitherMode;
    __Permedia2ColorDDAModeFmat              ColorDDAMode;

    // Common Depth/Stencil/Window Registers
    __Permedia2DepthModeFmat                 DepthMode;
    __Permedia2StencilModeFmat               StencilMode;
    __Permedia2StencilDataFmat               StencilData;
    __Permedia2WindowFmat                    Window;

    // Alpha/Fog registers
    __Permedia2AlphaBlendModeFmat            AlphaBlendMode;
    __Permedia2FogModeFmat                   FogMode;
    DWORD                                    FogColor;

    // Delta Register
    __Permedia2DeltaModeFmat                 DeltaMode;

    // Chroma testing register
    __Permedia2YUVModeFmat                   YUVMode;

    // Texture Registers
    __Permedia2TextureColorModeFmat          TextureColorMode;
    __Permedia2TextureAddrModeFmat           TextureAddressMode;
    __Permedia2TextureReadModeFmat           TextureReadMode;
    __Permedia2TextureDataFormatFmat         TextureDataFormat;
    __Permedia2TextureMapFormatFmat          TextureMapFormat;

} __P2RegsSoftwareCopy;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtri.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtri.c
*
*  Content:    Direct3D hw triangle rasterization code.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3ddelta.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#if defined(_ALPHA_)
#include <math.h>
#endif

//-----------------------------------------------------------------------------
//
// VOID P2_Draw_FVF_Solid_Tri
//
// Hardware render a single triangle coming from three FVF vertices
//
//-----------------------------------------------------------------------------
VOID
P2_Draw_FVF_Solid_Tri(PERMEDIA_D3DCONTEXT  *pContext,
                      LPD3DTLVERTEX    lpV0, 
                      LPD3DTLVERTEX    lpV1,
                      LPD3DTLVERTEX    lpV2, 
                      LPP2FVFOFFSETS   lpFVFOff)
{
    DWORD           dwFlags = pContext->Hdr.Flags;
    DWORD           dwColorOffs,dwSpecularOffs,dwTexOffs;
    ULONG           ulRenderCmd = pContext->RenderCommand;
    D3DCOLOR        dwColor0, dwColor1, dwColor2;
    D3DCOLOR        dwSpec0, dwSpec1, dwSpec2;
    D3DVALUE        fS0, fS1, fS2, fT0, fT1, fT2, fQ0, fQ1, fQ2;
    D3DVALUE        fKs0, fKs1, fKs2;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering P2_Draw_FVF_Solid_Tri"));

    // Set triangle rendering mode
    RENDER_TRAPEZOID(ulRenderCmd);

    RESERVEDMAPTR(0x80);

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    // Get vertex color value (FVF based)
    if (dwColorOffs)
    {
        dwColor0  = FVFCOLOR(lpV0, dwColorOffs)->color;
        dwColor1  = FVFCOLOR(lpV1, dwColorOffs)->color;
        dwColor2  = FVFCOLOR(lpV2, dwColorOffs)->color;
        if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
        {
            dwColor0  |= 0xFF000000;
            dwColor1  |= 0xFF000000;
            dwColor2  |= 0xFF000000;
        }
    }
    else
    {
        // must set default in case no D3DFVF_DIFFUSE
        dwColor0  = 0xFFFFFFFF;
        dwColor1  = 0xFFFFFFFF;
        dwColor2  = 0xFFFFFFFF;
    }
    // Get vertex specular value (FVF based) if necessary
    if ((dwFlags & (CTXT_HAS_SPECULAR_ENABLED | CTXT_HAS_FOGGING_ENABLED))
        && (dwSpecularOffs!=0))
    {
        dwSpec0   = FVFSPEC(lpV0, dwSpecularOffs)->specular;
        dwSpec1   = FVFSPEC(lpV1, dwSpecularOffs)->specular;
        dwSpec2   = FVFSPEC(lpV2, dwSpecularOffs)->specular;
    }

    if ( (dwFlags & CTXT_HAS_TEXTURE_ENABLED) && (dwTexOffs != 0) )
    {
         // Get s,t texture coordinates (FVF based)
        fS0 = FVFTEX(lpV0,dwTexOffs)->tu; 
        fT0 = FVFTEX(lpV0,dwTexOffs)->tv;
        
        fS1 = FVFTEX(lpV1,dwTexOffs)->tu; 
        fT1 = FVFTEX(lpV1,dwTexOffs)->tv;
        
        fS2 = FVFTEX(lpV2,dwTexOffs)->tu; 
        fT2 = FVFTEX(lpV2,dwTexOffs)->tv;

        // The hw requires us to keep the texture coordinates centered around 0
        // and avoid exceeding the texel wrapping limit.
        RECENTER_TEX_COORDS(pContext->MaxTextureXf, 
                            pContext->MaxTextureXi, fS0, fS1, fS2);
        RECENTER_TEX_COORDS(pContext->MaxTextureYf, 
                            pContext->MaxTextureYi, fT0, fT1, fT2);

        // Wrap texture coordinates if necessary
        WRAP(fS,dwFlags & CTXT_HAS_WRAPU_ENABLED);
        WRAP(fT,dwFlags & CTXT_HAS_WRAPV_ENABLED);

        // Scale s,t coordinate values
        fS0 *= pContext->DeltaWidthScale;
        fS1 *= pContext->DeltaWidthScale;
        fS2 *= pContext->DeltaWidthScale;
        fT0 *= pContext->DeltaHeightScale;
        fT1 *= pContext->DeltaHeightScale;
        fT2 *= pContext->DeltaHeightScale;

        // Apply perspective corrections if necessary
        if (dwFlags & CTXT_HAS_PERSPECTIVE_ENABLED)
        {
            fQ0 = lpV0->rhw; 
            fQ1 = lpV1->rhw;
            fQ2 = lpV2->rhw;

            fS0 *= fQ0;
            fT0 *= fQ0;

            fS1 *= fQ1;
            fT1 *= fQ1;

            fS2 *= fQ2;
            fT2 *= fQ2;
        }
        else
        {
            fQ0 = fQ1 = fQ2 = 1.0;
        }

        // Send lines s,t,q,ks (conditionaly),x,y,z values
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            fKs0   = RGB256_TO_LUMA(RGB_GETRED(dwSpec0),
                                        RGB_GETGREEN(dwSpec0),
                                        RGB_GETBLUE(dwSpec0));
            if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
            {
                fKs1 = RGB256_TO_LUMA(RGB_GETRED(dwSpec1),
                                        RGB_GETGREEN(dwSpec1),
                                        RGB_GETBLUE(dwSpec1));
                fKs2 = RGB256_TO_LUMA(RGB_GETRED(dwSpec2),
                                        RGB_GETGREEN(dwSpec2),
                                        RGB_GETBLUE(dwSpec2));
            }   
            else 
            {
                fKs2 = fKs1 = fKs0; 
            }

            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0, fKs0,
                                                  lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1, fKs1,
                                                  lpV1->sx, lpV1->sy, lpV1->sz);
            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV2FloatS, fS2, fT2, fQ2, fKs2,
                                                  lpV2->sx, lpV2->sy, lpV2->sz);
        }
        else
        {
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0,
                                                lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1,
                                                lpV1->sx, lpV1->sy, lpV1->sz);
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV2FloatS, fS2, fT2, fQ2,
                                                lpV2->sx, lpV2->sy, lpV2->sz);
        }

    }
    else     // not textured triangle
    {
        // If specular is enabled, change the colours
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            CLAMP8888(dwColor0, dwColor0, dwSpec0);
            CLAMP8888(dwColor1, dwColor1, dwSpec1);
            CLAMP8888(dwColor2, dwColor2, dwSpec2);
        }

        // Send triangles x,y,z values
        SEND_VERTEX_XYZ(__Permedia2TagV0FloatS, lpV0->sx, lpV0->sy, lpV0->sz);
        SEND_VERTEX_XYZ(__Permedia2TagV1FloatS, lpV1->sx, lpV1->sy, lpV1->sz);
        SEND_VERTEX_XYZ(__Permedia2TagV2FloatS, lpV2->sx, lpV2->sy, lpV2->sz);
    }

    // If fog is set, send the appropriate values
    if ((dwFlags & CTXT_HAS_FOGGING_ENABLED) && (dwSpecularOffs!=0))
    {
        SEND_VERTEX_FOG(__Permedia2TagV0FixedF, RGB_GET_GAMBIT_FOG(dwSpec0));
        SEND_VERTEX_FOG(__Permedia2TagV1FixedF, RGB_GET_GAMBIT_FOG(dwSpec1));
        SEND_VERTEX_FOG(__Permedia2TagV2FixedF, RGB_GET_GAMBIT_FOG(dwSpec2));
    }

    // Set alpha stippling if required by context
    if (dwFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED)
    {
        SET_STIPPLED_ALPHA( (RGBA_GETALPHA(lpV0->color) >> 4) );
    }

    // Send appropriate color depending on Gouraud , Mono, & Alpha
    if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
    {
        // Gouraud shading
        if (RENDER_MONO)
        {
            SEND_VERTEX_RGB_MONO(__Permedia2TagV0FixedS, dwColor0);
            SEND_VERTEX_RGB_MONO(__Permedia2TagV1FixedS, dwColor1);
            SEND_VERTEX_RGB_MONO(__Permedia2TagV2FixedS, dwColor2);
        }
        else
        {
            if (dwFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
                {
                    dwColor0 &= 0xFFFFFF;     // supress color's alpha value
                    dwColor1 &= 0xFFFFFF;
                    dwColor2 &= 0xFFFFFF;
                }
                SEND_VERTEX_RGBA(__Permedia2TagV0FixedS, dwColor0);
                SEND_VERTEX_RGBA(__Permedia2TagV1FixedS, dwColor1);
                SEND_VERTEX_RGBA(__Permedia2TagV2FixedS, dwColor2);
            }
            else
            {
                SEND_VERTEX_RGB(__Permedia2TagV0FixedS, dwColor0);
                SEND_VERTEX_RGB(__Permedia2TagV1FixedS, dwColor1);
                SEND_VERTEX_RGB(__Permedia2TagV2FixedS, dwColor2);
            }
        }
    }
    else    // Flat shading
    {
        if (RENDER_MONO)
        {
            // Get constant color from the blue channel
            DWORD BlueChannel = RGBA_GETBLUE(dwColor0);
            SEND_PERMEDIA_DATA( ConstantColor,
                            RGB_MAKE(BlueChannel, BlueChannel, BlueChannel));
        }
        else
        {
            if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
            {
                dwColor0 &= 0xFFFFFF;
            }

            SEND_PERMEDIA_DATA( ConstantColor,
                                   RGBA_MAKE(RGBA_GETBLUE(dwColor0),
                                             RGBA_GETGREEN(dwColor0),
                                             RGBA_GETRED(dwColor0), 
                                             RGBA_GETALPHA(dwColor0)));
        }
    }

    SEND_PERMEDIA_DATA(DrawTriangle, ulRenderCmd); 
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting P2_Draw_FVF_Solid_Tri"));

} // P2_Draw_FVF_Solid_Tri
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtxman.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.c
*
* Content:  D3D Texture manager
*
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#include "precomp.h"
#include "d3dtxman.h"
#include "dd.h"
#include "heap.h"
#define ALLOC_TAG ALLOC_TAG_TD2P
//-----------------------------------------------------------------------------
//
// void TextureHeapHeapify
//
//-----------------------------------------------------------------------------
void TextureHeapHeapify(PTextureHeap pTextureHeap, DWORD k)
{
    while(true) 
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);
        if(l < pTextureHeap->m_next)
            if(TextureCost(pTextureHeap->m_data_p[l]) <
                             TextureCost(pTextureHeap->m_data_p[k]))
                smallest = l;
            else
                smallest = k;
        else
            smallest = k;
        if(r < pTextureHeap->m_next)
            if(TextureCost(pTextureHeap->m_data_p[r]) <
                             TextureCost(pTextureHeap->m_data_p[smallest]))
                smallest = r;
        if(smallest != k) 
        {
            PPERMEDIA_D3DTEXTURE t = pTextureHeap->m_data_p[k];
            pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[smallest];
            pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            pTextureHeap->m_data_p[smallest] = t;
            t->m_dwHeapIndex = smallest;
            k = smallest;
        }
        else
            break;
    }
}

//-----------------------------------------------------------------------------
//
// bool TextureHeapAdd
//
//-----------------------------------------------------------------------------
bool TextureHeapAdd(PTextureHeap pTextureHeap, PPERMEDIA_D3DTEXTURE lpD3DTexI)
{
    if(pTextureHeap->m_next == pTextureHeap->m_size) 
    {
        pTextureHeap->m_size = pTextureHeap->m_size * 2 - 1;
        PPERMEDIA_D3DTEXTURE *p = (PPERMEDIA_D3DTEXTURE *)
            ENGALLOCMEM( FL_ZERO_MEMORY, 
                sizeof(PPERMEDIA_D3DTEXTURE)*pTextureHeap->m_size,ALLOC_TAG);

        if(p == 0)
        {
            DBG_D3D((0,"Failed to allocate memory to grow heap."));
            pTextureHeap->m_size = (pTextureHeap->m_size + 1) / 2; // restore size
            return false;
        }
        memcpy(p + 1, pTextureHeap->m_data_p + 1, 
            sizeof(PPERMEDIA_D3DTEXTURE) * (pTextureHeap->m_next - 1));
        ENGFREEMEM( pTextureHeap->m_data_p);
        pTextureHeap->m_data_p = p;
    }
    ULONGLONG Cost = TextureCost(lpD3DTexI);
    for(DWORD k = pTextureHeap->m_next; k > 1; k = parent(k))
        if(Cost < TextureCost(pTextureHeap->m_data_p[parent(k)])) 
        {
            pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
            pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
        }
        else
            break;
    pTextureHeap->m_data_p[k] = lpD3DTexI;
    lpD3DTexI->m_dwHeapIndex = k;
    ++pTextureHeap->m_next;
    return true;
}

//-----------------------------------------------------------------------------
//
// PPERMEDIA_D3DTEXTURE TextureHeapExtractMin
//
//-----------------------------------------------------------------------------
PPERMEDIA_D3DTEXTURE TextureHeapExtractMin(PTextureHeap pTextureHeap)
{
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[1];
    --pTextureHeap->m_next;
    pTextureHeap->m_data_p[1] = pTextureHeap->m_data_p[pTextureHeap->m_next];
    pTextureHeap->m_data_p[1]->m_dwHeapIndex = 1;
    TextureHeapHeapify(pTextureHeap,1);
    lpD3DTexI->m_dwHeapIndex = 0;
    return lpD3DTexI;
}

//-----------------------------------------------------------------------------
//
// PPERMEDIA_D3DTEXTURE TextureHeapExtractMax
//
//-----------------------------------------------------------------------------
PPERMEDIA_D3DTEXTURE TextureHeapExtractMax(PTextureHeap pTextureHeap)
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper. 
    // NOTE: (lchild(i) >= m_next) is true only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    unsigned max = pTextureHeap->m_next - 1;
    ULONGLONG maxcost = 0;
    for(unsigned i = max; lchild(i) >= pTextureHeap->m_next; --i)
    {
        ULONGLONG Cost = TextureCost(pTextureHeap->m_data_p[i]);
        if(maxcost < Cost)
        {
            maxcost = Cost;
            max = i;
        }
    }
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[max];
    TextureHeapDel(pTextureHeap,max);
    return lpD3DTexI;
}

//-----------------------------------------------------------------------------
//
// void TextureHeapDel
//
//-----------------------------------------------------------------------------
void TextureHeapDel(PTextureHeap pTextureHeap, DWORD k)
{
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[k];
    --pTextureHeap->m_next;
    ULONGLONG Cost = TextureCost(pTextureHeap->m_data_p[pTextureHeap->m_next]);
    if(Cost < TextureCost(lpD3DTexI))
    {
        while(k > 1)
        {
            if(Cost < TextureCost(pTextureHeap->m_data_p[parent(k)]))
            {
                pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
                pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
    }
    else
    {
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
        TextureHeapHeapify(pTextureHeap,k);
    }
    lpD3DTexI->m_dwHeapIndex = 0;
}

//-----------------------------------------------------------------------------
//
// void TextureHeapUpdate
//
//-----------------------------------------------------------------------------
void TextureHeapUpdate(PTextureHeap pTextureHeap, DWORD k,
                       DWORD priority, DWORD ticks) 
{
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[k];
    ULONGLONG Cost = 0;
#ifdef _X86_
    _asm
    {
        mov     edx, 0;
        shl     edx, 31;
        mov     eax, priority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR Cost + 4, edx;
        shl     ecx, 31;
        mov     eax, ticks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR Cost, eax;
    }
#else
    Cost = ((ULONGLONG)priority << 31) + ((ULONGLONG)(ticks >> 1));
#endif
    if(Cost < TextureCost(lpD3DTexI))
    {
        while(k > 1)
        {
            if(Cost < TextureCost(pTextureHeap->m_data_p[parent(k)]))
            {
                pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
                pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        lpD3DTexI->m_dwHeapIndex = k;
        pTextureHeap->m_data_p[k] = lpD3DTexI;
    }
    else
    {
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        TextureHeapHeapify(pTextureHeap,k);
    }
}

//-----------------------------------------------------------------------------
//
// HRESULT TextureCacheManagerInitialize
//
//-----------------------------------------------------------------------------
HRESULT TextureCacheManagerInitialize(
    PTextureCacheManager pTextureCacheManager)
{
    pTextureCacheManager->tcm_ticks = 0;
    pTextureCacheManager->m_heap.m_next = 1;
    pTextureCacheManager->m_heap.m_size = 1024;
    pTextureCacheManager->m_heap.m_data_p = (PPERMEDIA_D3DTEXTURE *)
        ENGALLOCMEM( FL_ZERO_MEMORY, 
            sizeof(PPERMEDIA_D3DTEXTURE)*pTextureCacheManager->m_heap.m_size,
            ALLOC_TAG);
    if(pTextureCacheManager->m_heap.m_data_p == 0)
    {
        DBG_D3D((0,"Failed to allocate texture heap."));
        return E_OUTOFMEMORY;
    }
    memset(pTextureCacheManager->m_heap.m_data_p, 0, 
        sizeof(PPERMEDIA_D3DTEXTURE) * pTextureCacheManager->m_heap.m_size);
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// BOOL TextureCacheManagerFreeTextures
//
//-----------------------------------------------------------------------------
BOOL TextureCacheManagerFreeTextures(
    PTextureCacheManager pTextureCacheManager,DWORD dwStage, DWORD dwBytes)
{
    if(pTextureCacheManager->m_heap.m_next <= 1)
        return false;
    PPERMEDIA_D3DTEXTURE rc;
    for(unsigned i = 0; 
        pTextureCacheManager->m_heap.m_next > 1 && i < dwBytes; 
        i += rc->m_dwBytes)
    {
        // Find the LRU texture and remove it.
        rc = TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        TextureCacheManagerRemove(pTextureCacheManager,rc);
        pTextureCacheManager->m_stats.dwLastPri = rc->m_dwPriority;
        ++pTextureCacheManager->m_stats.dwNumEvicts;
        DBG_D3D((2, "Removed texture with timestamp %u,%u (current = %u).", 
            rc->m_dwPriority, rc->m_dwTicks, pTextureCacheManager->tcm_ticks));
    }
    return true;
}

//-----------------------------------------------------------------------------
//
// HRESULT TextureCacheManagerAllocNode
//
//-----------------------------------------------------------------------------
HRESULT TextureCacheManagerAllocNode(
    PERMEDIA_D3DCONTEXT* pContext,
    PPERMEDIA_D3DTEXTURE pTexture)
{
    DWORD trycount = 0, bytecount = pTexture->m_dwBytes;
    PermediaSurfaceData* pPrivateData=pTexture->pTextureSurface;
    PTextureCacheManager pTextureCacheManager=pContext->pTextureManager;
    if (NULL == pPrivateData)
    {
        DBG_D3D((0,"pTextureSurface==NULL invalid texture"));
        return D3D_OK;  //we already have the video memory allocated
    }
    // Attempt to allocate a texture.
    while(NULL == pPrivateData->fpVidMem)
    {
        LONG lScratchDelta;
        DWORD   PackedPP;
        ++trycount;
        pPrivateData->fpVidMem=(FLATPTR)
            ulVidMemAllocate( pContext->ppdev,
                              pTexture->wWidth,
                              pTexture->wHeight,
                              ShiftLookup[pTexture->dwRGBBitCount>>3],
                              &lScratchDelta,
                              &pPrivateData->pvmHeap,
                              &PackedPP,
                              FALSE);
        DBG_D3D((8,"Got fpVidMem=%08lx",pPrivateData->fpVidMem));
        if (NULL != pPrivateData->fpVidMem)
        {   // No problem, there is enough memory. 
            pTexture->m_dwTicks = pTextureCacheManager->tcm_ticks;
            if(!TextureHeapAdd(&pTextureCacheManager->m_heap,pTexture))
            {          
                VidMemFree(pPrivateData->pvmHeap->lpHeap,
                    pPrivateData->fpVidMem);
                pPrivateData->fpVidMem=NULL;
                DBG_D3D((0,"Out of memory"));
                return DDERR_OUTOFMEMORY;
            }
            pPrivateData->dwFlags |= P2_SURFACE_NEEDUPDATE;
            break;
        }
        else
        {
            if (!TextureCacheManagerFreeTextures(
                pTextureCacheManager,0, bytecount))
            {
                DBG_D3D((0,"all Freed no further video memory available"));
                return DDERR_OUTOFVIDEOMEMORY;	//nothing left
            }
            bytecount <<= 1;
        }
    }
    if(trycount > 1)
    {
        DBG_D3D((8, "Allocated texture after %u tries.", trycount));
    }
    TextureCacheManagerIncTotSz(pTextureCacheManager,
        pTexture->m_dwBytes);
    ++pTextureCacheManager->m_stats.dwWorkingSet;
    pTextureCacheManager->m_stats.dwWorkingSetBytes 
        += (pTexture->m_dwBytes);
    ++pTextureCacheManager->m_stats.dwNumVidCreates;
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// void TextureCacheManagerRemove
//
// remove all HW handles and release surface
//
//-----------------------------------------------------------------------------
void TextureCacheManagerRemove(
    PTextureCacheManager pTextureCacheManager,
    PPERMEDIA_D3DTEXTURE pTexture)
{
    PermediaSurfaceData* pPrivateData=pTexture->pTextureSurface;
    if (CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData) && pPrivateData->fpVidMem)
    {
        VidMemFree(pPrivateData->pvmHeap->lpHeap,pPrivateData->fpVidMem);
        pPrivateData->fpVidMem=NULL;
        TextureCacheManagerDecTotSz(pTextureCacheManager,
            pTexture->m_dwBytes);
        --pTextureCacheManager->m_stats.dwWorkingSet;
        pTextureCacheManager->m_stats.dwWorkingSetBytes -= 
            (pTexture->m_dwBytes);
    }
    if (pTexture->m_dwHeapIndex && pTextureCacheManager->m_heap.m_data_p)
        TextureHeapDel(&pTextureCacheManager->m_heap,
        pTexture->m_dwHeapIndex); 
}

//-----------------------------------------------------------------------------
//
// void TextureCacheManagerEvictTextures
//
//-----------------------------------------------------------------------------
void TextureCacheManagerEvictTextures(
    PTextureCacheManager pTextureCacheManager)
{
    while(pTextureCacheManager->m_heap.m_next > 1)
    {
        PPERMEDIA_D3DTEXTURE lpD3DTexI = 
            TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        TextureCacheManagerRemove(pTextureCacheManager,lpD3DTexI);
    }
    pTextureCacheManager->tcm_ticks = 0;
}

//-----------------------------------------------------------------------------
//
// void TextureCacheManagerTimeStamp
//
//-----------------------------------------------------------------------------
void TextureCacheManagerTimeStamp(
    PTextureCacheManager pTextureCacheManager,PPERMEDIA_D3DTEXTURE lpD3DTexI)
{
    TextureHeapUpdate(&pTextureCacheManager->m_heap,
        lpD3DTexI->m_dwHeapIndex, lpD3DTexI->m_dwPriority, 
        pTextureCacheManager->tcm_ticks);
    pTextureCacheManager->tcm_ticks += 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dd.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dd.c
*
* Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define INITGUID
#include "precomp.h"
#include <mmsystem.h>
#include "directx.h"
#include "dd.h"
#include "d3dhw.h"
#include "d3dtext.h"
#include "heap.h"

//-----------------------------------------------------------------------------
//
// use bits to indicate which ROPs you support.
//
// DWORD 0, bit 0 == ROP 0
// DWORD 8, bit 31 == ROP 255
//
//-----------------------------------------------------------------------------

static BYTE ropList[] =
{
    SRCCOPY >> 16,
};

static DWORD rops[DD_ROP_SPACE] = { 0 };



// The FourCC's we support
static DWORD fourCC[] =
{
    FOURCC_YUV422
};

//-----------------------------------------------------------------------------
//
//      setupRops
//
//      build array for supported ROPS
//
//-----------------------------------------------------------------------------

VOID
setupRops( LPBYTE proplist, LPDWORD proptable, int cnt )
{
    INT         i;
    DWORD       idx;
    DWORD       bit;
    DWORD       rop;

    for(i=0; i<cnt; i++)
    {
        rop = proplist[i];
        idx = rop / 32;
        bit = 1L << ((DWORD)(rop % 32));
        proptable[idx] |= bit;
    }

} // setupRops

//-----------------------------------------------------------------------------
//
//  P2DisableAllUnits
//
//  reset permedia rasterizer to known state
//
//-----------------------------------------------------------------------------

VOID
P2DisableAllUnits(PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);

    RESERVEDMAPTR(47);
    SEND_PERMEDIA_DATA(RasterizerMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AreaStippleMode,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ScissorMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ColorDDAMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FogMode,             __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LBReadMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(Window,              __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(StencilMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(DepthMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LBWriteMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBReadMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(DitherMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LogicalOpMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBWriteMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(StatisticMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AlphaBlendMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FilterMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBSourceData,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LBWriteFormat,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureMapFormat,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureDataFormat,   __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(YUVMode,             __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AStart,              PM_BYTE_COLOR(0xFF));
    SEND_PERMEDIA_DATA(TextureBaseAddress,  __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTIndex,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTTransfer,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureAddressMode,  __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AlphaMapUpperBound,  0);
    SEND_PERMEDIA_DATA(AlphaMapLowerBound,  0);
    SEND_PERMEDIA_DATA(Color,  0);

    SEND_PERMEDIA_DATA(FBWriteMode, __PERMEDIA_ENABLE);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);
    SEND_PERMEDIA_DATA(FBSoftwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);

    // We sometimes use the scissor in DDRAW to scissor out unnecessary pixels.
    SEND_PERMEDIA_DATA(ScissorMinXY, 0);
    SEND_PERMEDIA_DATA(ScissorMaxXY, (ppdev->cyMemory << 16) | (ppdev->cxMemory));
    SEND_PERMEDIA_DATA(ScreenSize, (ppdev->cyMemory << 16) | (ppdev->cxMemory));

    SEND_PERMEDIA_DATA(WindowOrigin, 0x0);

    // DirectDraw might not need to set these up
    SEND_PERMEDIA_DATA(dXDom, 0x0);
    SEND_PERMEDIA_DATA(dXSub, 0x0);

    // set max size, no filtering
    SEND_PERMEDIA_DATA(TextureReadMode,
        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
        PM_TEXREADMODE_WIDTH(11) |
        PM_TEXREADMODE_HEIGHT(11) );

    // 16 bit Z, no other buffers
    SEND_PERMEDIA_DATA(LBWriteFormat, __PERMEDIA_DEPTH_WIDTH_16);

    // Ensure an extra LBData message doesn't flow through the core.
    SEND_PERMEDIA_DATA(Window, PM_WINDOW_DISABLELBUPDATE(__PERMEDIA_ENABLE));

    SEND_PERMEDIA_DATA(FBReadPixel, ppdev->bPixShift);

    COMMITDMAPTR();
    FLUSHDMA();

}   // P2DisableAllUnits

//-----------------------------------------------------------------------------
//
// GetDDHALInfo
//
// Takes a pointer to a partially or fully filled in ppdev and a pointer
// to an empty DDHALINFO and fills in the DDHALINFO.
//
//-----------------------------------------------------------------------------

VOID
GetDDHALInfo(PPDev ppdev, DDHALINFO* pHALInfo)
{
    DWORD dwResult;
    BOOL bRet;

    DBG_DD(( 5, "DDraw:GetDDHalInfo"));

    // Setup the HAL driver caps.
    memset( pHALInfo, 0, sizeof(DDHALINFO));
    pHALInfo->dwSize = sizeof(DDHALINFO);

    // Setup the ROPS we do.
    setupRops( ropList, rops, sizeof(ropList)/sizeof(ropList[0]));

    // The most basic DirectDraw functionality
    pHALInfo->ddCaps.dwCaps =   DDCAPS_BLT |
                                DDCAPS_BLTQUEUE |
                                DDCAPS_BLTCOLORFILL |
                                DDCAPS_READSCANLINE;

    pHALInfo->ddCaps.ddsCaps.dwCaps =   DDSCAPS_OFFSCREENPLAIN |
                                        DDSCAPS_PRIMARYSURFACE |
                                        DDSCAPS_FLIP;

    // add caps for D3D
    pHALInfo->ddCaps.dwCaps |=  DDCAPS_3D |
                                DDCAPS_ALPHA |
                                DDCAPS_BLTDEPTHFILL;

    // add surface caps for D3D
    pHALInfo->ddCaps.ddsCaps.dwCaps |=  DDSCAPS_ALPHA |
                                        DDSCAPS_3DDEVICE |
                                        DDSCAPS_ZBUFFER;

    // Permedia can do
    // 1. Stretching/Shrinking
    // 2. YUV->RGB conversion (only non paletted mode)
    // 3. Mirroring in X and Y

    // add Permedia caps to global caps
    pHALInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH |
                               DDCAPS_COLORKEY |
                               DDCAPS_CANBLTSYSMEM;


#if DX7_STEREO
    // check if mode supports stereo
    DD_STEREOMODE DDStereoMode;
    DDStereoMode.dwHeight = ppdev->cyScreen;
    DDStereoMode.dwWidth  = ppdev->cxScreen;
    DDStereoMode.dwBpp    = ppdev->cBitsPerPel;
    DDStereoMode.dwRefreshRate= 0;
    ppdev->bCanDoStereo=bIsStereoMode(ppdev,&DDStereoMode);

    // Stereo caps are set if the driver can do stereo in any mode:
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_STEREO;
    pHALInfo->ddCaps.dwSVCaps = DDSVCAPS_STEREOSEQUENTIAL;
#endif

    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGETEXTURE;

    //declare we can handle textures wider than the primary
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_WIDESURFACES;

    // Special effects caps
    pHALInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTSTRETCHY |
                                DDFXCAPS_BLTSTRETCHX |
                                DDFXCAPS_BLTSTRETCHYN |
                                DDFXCAPS_BLTSTRETCHXN |
                                DDFXCAPS_BLTSHRINKY |
                                DDFXCAPS_BLTSHRINKX |
                                DDFXCAPS_BLTSHRINKYN |
                                DDFXCAPS_BLTSHRINKXN |
                                DDFXCAPS_BLTMIRRORUPDOWN |
                                DDFXCAPS_BLTMIRRORLEFTRIGHT;


    // add AlphaBlt and Filter caps
    pHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTALPHA |
                                 DDFXCAPS_BLTFILTER;

    // colorkey caps, only src color key supported
    pHALInfo->ddCaps.dwCKeyCaps =   DDCKEYCAPS_SRCBLT |
                                    DDCKEYCAPS_SRCBLTCLRSPACE;

    // We can do a texture from sysmem to video mem blt.
    pHALInfo->ddCaps.dwSVBCaps = DDCAPS_BLT;
    pHALInfo->ddCaps.dwSVBCKeyCaps = 0;
    pHALInfo->ddCaps.dwSVBFXCaps = 0;

    // Fill in the sysmem->vidmem rops (only can copy);
    for(int i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSVBRops[i] = rops[i];
    }

    if (ppdev->iBitmapFormat != BMF_8BPP)
    {
        pHALInfo->ddCaps.dwCaps |= DDCAPS_BLTFOURCC;
        pHALInfo->ddCaps.dwCKeyCaps |=  DDCKEYCAPS_SRCBLTCLRSPACEYUV;
    }

    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

    // Z Buffer is only 16 Bits on Permedia
    pHALInfo->ddCaps.dwZBufferBitDepths = DDBD_16;

#if D3D_MIPMAPPING
    // Mip Mapping
    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_MIPMAP;
#endif

    if (DD_P2AGPCAPABLE(ppdev))
    {
        DBG_DD((1, "GetDDHALInfo: P2 AGP board - supports NONLOCALVIDMEM"));

        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM |
                                    DDCAPS2_NONLOCALVIDMEMCAPS;
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM |
                                           DDSCAPS_NONLOCALVIDMEM;
    }
    else
    {
        DBG_DD((1,"GetDDHALInfo: P2 Board is NOT AGP"));
    }

    // Won't do Video-Sys mem Blits.
    pHALInfo->ddCaps.dwVSBCaps = 0;
    pHALInfo->ddCaps.dwVSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwVSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwVSBRops[i] = 0;
    }

    // Won't do Sys-Sys mem Blits
    pHALInfo->ddCaps.dwSSBCaps = 0;
    pHALInfo->ddCaps.dwSSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwSSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSSBRops[i] = 0;
    }

    // bit depths supported for alpha and Z
    pHALInfo->ddCaps.dwAlphaBltConstBitDepths = DDBD_2 |
                                                DDBD_4 |
                                                DDBD_8;
    pHALInfo->ddCaps.dwAlphaBltPixelBitDepths = DDBD_1 |
                                                DDBD_8;
    pHALInfo->ddCaps.dwAlphaBltSurfaceBitDepths = DDBD_1 |
                                                  DDBD_2 |
                                                  DDBD_4 |
                                                  DDBD_8;
    pHALInfo->ddCaps.dwAlphaOverlayConstBitDepths = DDBD_2 |
                                                    DDBD_4 |
                                                    DDBD_8;
    pHALInfo->ddCaps.dwAlphaOverlayPixelBitDepths = DDBD_1 |
                                                    DDBD_8;
    pHALInfo->ddCaps.dwAlphaOverlaySurfaceBitDepths = DDBD_1 |
                                                      DDBD_2 |
                                                      DDBD_4 |
                                                      DDBD_8;

    // ROPS supported
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwRops[i] = rops[i];
    }

    // For DX5 and beyond we support this new informational callback.
    pHALInfo->GetDriverInfo = DdGetDriverInfo;
    pHALInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;

    // now setup D3D callbacks
    D3DHALCreateDriver( ppdev,
                        (LPD3DHAL_GLOBALDRIVERDATA*)
                            &pHALInfo->lpD3DGlobalDriverData,
                        (LPD3DHAL_CALLBACKS*)
                            &pHALInfo->lpD3DHALCallbacks,
                        (LPDDHAL_D3DBUFCALLBACKS*)
                            &pHALInfo->lpD3DBufCallbacks);

    if(pHALInfo->lpD3DGlobalDriverData == NULL)
    {
        // no D3D available - kill caps we set before
        pHALInfo->ddCaps.dwCaps &=
            ~(DDCAPS_3D | DDCAPS_BLTDEPTHFILL);
        pHALInfo->ddCaps.ddsCaps.dwCaps &=
            ~(DDSCAPS_3DDEVICE | DDSCAPS_ZBUFFER);
    }

}  // GetHALInfo

//-----------------------------------------------------------------------------
//
//  Global DirectDraw Callbacks
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//  DdFlip
//
//  This callback is invoked whenever we are about to flip to from
//  one surface to another. lpFlipData->lpSurfCurr is the surface we were at,
//  lpFlipData->lpSurfTarg is the one we are flipping to.
//
//  You should point the hardware registers at the new surface, and
//  also keep track of the surface that was flipped away from, so
//  that if the user tries to lock it, you can be sure that it is done
//  being displayed
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdFlip( LPDDHAL_FLIPDATA lpFlipData)
{
    PPDev ppdev=(PPDev)lpFlipData->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD       dwDDSurfaceOffset;
    HRESULT     ddrval;

    DBG_DD(( 3, "DDraw:Flip"));

    // Switch to DirectDraw context
    DDCONTEXT;

    // is the previous Flip already done?
    // check if the current surface is already displayed
    ddrval = updateFlipStatus(ppdev);
    if( FAILED(ddrval) )
    {
        lpFlipData->ddRVal = ddrval;
        return DDHAL_DRIVER_HANDLED;
    }

    // everything is OK, do the flip.
    // get offset for Permedia ScreenBase register
    dwDDSurfaceOffset=(DWORD)lpFlipData->lpSurfTarg->lpGbl->fpVidMem;


#if DX7_STEREO
    if (lpFlipData->dwFlags & DDFLIP_STEREO)   // will be stereo
    {
        DBG_DD((4,"DDraw:Flip:Stereo"));
        DBG_DD((5,"ScreenBase: %08lx", dwDDSurfaceOffset));

        if (lpFlipData->lpSurfTargLeft!=NULL)
        {
            DWORD dwDDLeftSurfaceOffset;
            dwDDLeftSurfaceOffset=(DWORD)
                lpFlipData->lpSurfTargLeft->lpGbl->fpVidMem;
            LD_PERMEDIA_REG(PREG_SCREENBASERIGHT,dwDDLeftSurfaceOffset>>3);
            DBG_DD((5,"ScreenBaseLeft: %08lx", dwDDLeftSurfaceOffset));
        }

        ULONG ulVControl=READ_PERMEDIA_REG(PREG_VIDEOCONTROL);
        if ((ulVControl&PREG_VC_STEREOENABLE)==0 ||
            !ppdev->bDdStereoMode)
        {
            ppdev->bDdStereoMode=TRUE;
            LD_PERMEDIA_REG(PREG_VIDEOCONTROL, ulVControl
                                             | PREG_VC_STEREOENABLE);
        }
    } else
#endif // DX7_STEREO
    {
        // append flip command to Permedia render pipeline
        // that makes sure that all buffers are flushed before
        // the flip occurs
#if DX7_STEREO
        if (ppdev->bDdStereoMode)
        {
            ppdev->bDdStereoMode=FALSE;
            LD_PERMEDIA_REG(PREG_VIDEOCONTROL,
                READ_PERMEDIA_REG(PREG_VIDEOCONTROL)&
                ~PREG_VC_STEREOENABLE);
        }
#endif
    }

    // adjust base address according to register spec.
    dwDDSurfaceOffset>>=3;

    // add new base address to render pipeline
    RESERVEDMAPTR(1);
    LD_INPUT_FIFO(__Permedia2TagSuspendUntilFrameBlank, dwDDSurfaceOffset);
    COMMITDMAPTR();
    FLUSHDMA();

    // remember new Surface Offset for GetFlipStatus
    ppdev->dwNewDDSurfaceOffset=dwDDSurfaceOffset;

    lpFlipData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} // DdFlip

//-----------------------------------------------------------------------------
//
// DdWaitForVerticalBlank
//
// This callback is invoked to get information about the vertical blank
// status of the display or to wait until the display is at the begin or
// the end of the vertical blank
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdWaitForVerticalBlank(LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    static int bInVBlank = FALSE;
    PPDev ppdev=(PPDev)lpWaitForVerticalBlank->lpDD->dhpdev;

    DBG_DD(( 2, "DDraw:WaitForVerticalBlank"));

    switch(lpWaitForVerticalBlank->dwFlags)
    {

    case DDWAITVB_I_TESTVB:

        // If the monitor is off, we don't always want to report
        // the same status or else an app polling this status
        // might hang

        if( !(READ_PERMEDIA_REG(PREG_VIDEOCONTROL) & PREG_VC_VIDEO_ENABLE))
        {
            lpWaitForVerticalBlank->bIsInVB = bInVBlank;
            bInVBlank = !bInVBlank;
        }
        else
        {
            // Just a request for current VBLANK status.

            lpWaitForVerticalBlank->bIsInVB = IN_VRETRACE(ppdev);
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKBEGIN:

        // we don't care to wait if the monitor is off

        if( READ_PERMEDIA_REG(PREG_VIDEOCONTROL) & PREG_VC_VIDEO_ENABLE)
        {
            // if blockbegin is requested we wait until the vertical retrace
            // is over, and then wait for the display period to end.

            while(IN_VRETRACE(ppdev));
            while(IN_DISPLAY(ppdev));
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKEND:

        // we don't care to wait if the monitor is off

        if( READ_PERMEDIA_REG(PREG_VIDEOCONTROL) & PREG_VC_VIDEO_ENABLE)
        {
            // if blockend is requested we wait for the vblank interval to end.

            if( IN_VRETRACE(ppdev) )
            {
                while( IN_VRETRACE(ppdev) );
            }
            else
            {
                while(IN_DISPLAY(ppdev));
                while(IN_VRETRACE(ppdev));
            }
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_NOTHANDLED;

} // WaitForVerticalBlank

//-----------------------------------------------------------------------------
//
//  Lock
//
//  This call is invoked to lock a DirectDraw Videomemory surface. To make
//  sure there are no pending drawing operations on the surface, flush all
//  drawing operations and wait for a flip if it is still pending.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdLock( LPDDHAL_LOCKDATA lpLockData )
{
    PPDev ppdev=(PPDev)lpLockData->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    HRESULT     ddrval;
    DWORD pSurf;

    DBG_DD(( 2, "DDraw:Lock"));

    //
    // Switch to DirectDraw context
    //
    DDCONTEXT;

    // check to see if any pending physical flip has occurred
    ddrval = updateFlipStatus(ppdev);
    if( FAILED(ddrval) )
    {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // don't allow a lock if a blt is in progress
    //

    if(DRAW_ENGINE_BUSY)
    {
        DBG_DD((2,"DDraw:Lock, DrawEngineBusy"));
        FLUSHDMA();
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }


    // send a flush and wait for outstanding operations
    // before allowing surfaces to be locked.

    SYNC_WITH_PERMEDIA;

    // now check if the user wants to lock a texture surface,
    // which was loaded as patched! In this case we have to to
    // a blit to unpatch before we return it to the user
    // This is not expensive, since we leave it unpatched for
    // the future when the application decides to use it this way
    LPDDRAWI_DDRAWSURFACE_LCL  pLcl=lpLockData->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL  pGbl=pLcl->lpGbl;
    PermediaSurfaceData       *pPrivate=
        (PermediaSurfaceData*)pGbl->dwReserved1;

    //
    //  If the user attempts to lock a managed surface, mark it as dirty
    //  and return.
    //

    if (pLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        DBG_DD(( 3, "DDraw:Lock %08lx %08lx",
            pLcl->lpSurfMore->dwSurfaceHandle, pGbl->fpVidMem));
        if (NULL != pPrivate)
            pPrivate->dwFlags |= P2_SURFACE_NEEDUPDATE;
        lpLockData->lpSurfData = (LPVOID)(pLcl->lpGbl->fpVidMem +
                                          (pLcl->lpGbl->lPitch * lpLockData->rArea.top) +
                                          (lpLockData->rArea.left << DDSurf_GetPixelShift(pLcl)));
        lpLockData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    DD_CHECK_PRIMARY_SURFACE_DATA(pLcl,pPrivate);

    //
    //  We only need to unswizzle a surface if the
    //  PrivateData is in a format we know (pPrivate!=NULL)
    //

    if (pPrivate!=NULL)
    {
        //
        //  if the surface is a texture which was loaded in a swizzled
        //  format, we have to undo the swizzle before succeding the lock.
        //  In this driver, a texture remains unswizzled when a user
        //  attempted to lock it once.
        //

        if (pPrivate->dwFlags & P2_ISPATCHED)
        {
            //
            // The scratchpad must be 32 lines high and should have
            // the same width as our original surface.
            //

            PermediaSurfaceData ScratchData=*pPrivate;
            LONG lScratchDelta;
            VIDEOMEMORY*  pvmHeap;
            ULONG ulScratchOffset=
                ulVidMemAllocate( ppdev,
                                  DDSurf_Width(pLcl),
                                  DDSurf_Height(pLcl),
                                  DDSurf_GetPixelShift(pLcl),
                                  &lScratchDelta,
                                  &pvmHeap,
                                  &ScratchData.ulPackedPP,
                                  FALSE);

            DBG_DD(( 5, "  unswizzle surface, scratchpad at: %08lx",
                           ulScratchOffset));
            if (ulScratchOffset!=0)
            {
                RECTL rSurfRect;
                RECTL rScratchRect;

                rSurfRect.left=0;
                rSurfRect.top=0;
                rSurfRect.right=DDSurf_Width(pLcl);
                rSurfRect.bottom=32;

                rScratchRect=rSurfRect;

                // scratchpad should be non patched
                ScratchData.dwFlags &= ~(P2_ISPATCHED|P2_CANPATCH);

                LONG lSurfOffset;
                DWORD dwSurfBase=(DWORD)pGbl->fpVidMem >>
                    DDSurf_GetPixelShift(pLcl);
                DWORD dwScratchBase=ulScratchOffset >>
                    DDSurf_GetPixelShift(pLcl);
                lScratchDelta >>= DDSurf_GetPixelShift(pLcl);
                LONG lSurfDelta=DDSurf_Pitch(pLcl)>>
                    DDSurf_GetPixelShift(pLcl);

                for (DWORD i=0; i<DDSurf_Height(pLcl); i+=32)
                {
                    lSurfOffset = dwSurfBase-dwScratchBase;
                    // first do a patched to unpatched blt to the scratchpad
                    PermediaPatchedCopyBlt( ppdev,
                                            lScratchDelta,
                                            lSurfDelta,
                                            &ScratchData,
                                            pPrivate,
                                            &rScratchRect,
                                            &rSurfRect,
                                            dwScratchBase,
                                            lSurfOffset);

                    // then do a fast copyblt back to the original
                    // Packed blit ignores the ISPATCHED flag

                    lSurfOffset = dwScratchBase-dwSurfBase;

                    PermediaPackedCopyBlt( ppdev,
                                           lSurfDelta,
                                           lScratchDelta,
                                           pPrivate,
                                           &ScratchData,
                                           &rSurfRect,
                                           &rScratchRect,
                                           dwSurfBase,
                                           lSurfOffset);

                    rSurfRect.top += 32;
                    rSurfRect.bottom += 32;
                }

                pPrivate->dwFlags &= ~P2_ISPATCHED;

                //
                // free scratchpad memory
                //
                VidMemFree( pvmHeap->lpHeap, ulScratchOffset);

                SYNC_WITH_PERMEDIA;
            } else
            {
                lpLockData->ddRVal = DDERR_OUTOFMEMORY;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }


    // Because we correctly set 'fpVidMem' to be the offset into our frame
    // buffer when we created the surface, DirectDraw will automatically take
    // care of adding in the user-mode frame buffer address if we return
    // DDHAL_DRIVER_NOTHANDLED:

    return DDHAL_DRIVER_NOTHANDLED;

} // DdLock

//-----------------------------------------------------------------------------
//
//  DdGetScanLine
//
//  This callback is invoked to get the current scanline of our video display
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetScanLine(LPDDHAL_GETSCANLINEDATA lpGetScanLine)
{
    PPDev ppdev=(PPDev)lpGetScanLine->lpDD->dhpdev;

    DBG_DD(( 2, "DDraw:GetScanLine"));

    //  If a vertical blank is in progress the scan line is
    //  indeterminant. If the scan line is indeterminant we return
    //  the error code DDERR_VERTICALBLANKINPROGRESS.
    //  Otherwise we return the scan line and a success code

    if( IN_VRETRACE(ppdev) )
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
        lpGetScanLine->dwScanLine = 0;
    }
    else
    {
        lpGetScanLine->dwScanLine = CURRENT_VLINE(ppdev);
        lpGetScanLine->ddRVal = DD_OK;
    }
    return DDHAL_DRIVER_HANDLED;

} // DdGetScanLine

//-----------------------------------------------------------------------------
//
//  DdGetBltStatus
//
//  This callback is invoked to get the current blit status or to ask if the
//  user can add the next blit.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetBltStatus(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus )
{
    PPDev ppdev=(PPDev)lpGetBltStatus->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 2, "DDraw:DdGetBltStatus"));

    // CANBLT: can we add a blt?
    // On the Permedia we can always add blits

    if( lpGetBltStatus->dwFlags == DDGBS_CANBLT )
    {
        lpGetBltStatus->ddRVal = DD_OK;
    }
    else
    {
        if( DRAW_ENGINE_BUSY )
        {

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
            if(ppdev->ulLockCount)
            {
                 DBG_DD((MT_LOG_LEVEL, "DdGetBltStatus: re-entry! %d", ppdev->ulLockCount));
            }
            EngAcquireSemaphore(ppdev->hsemLock);
            ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

            // switch to DDraw context if necessary
            DDCONTEXT;

            FLUSHDMA();
            lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
            ppdev->ulLockCount--;
            EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
        }
        else
        {
            lpGetBltStatus->ddRVal = DD_OK;
        }
    }

    return DDHAL_DRIVER_HANDLED;

} // DdGetBltStatus

//-----------------------------------------------------------------------------
//
// DdGetFlipStatus
//
// If the display has went through one refresh cycle since the flip
// occurred we return DD_OK.  If it has not went through one refresh
// cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
// is still busy "drawing" the flipped page. We also return
// DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
// to know if they could flip yet
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetFlipStatus(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus )
{
    PPDev ppdev=(PPDev)lpGetFlipStatus->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 2, "DDraw:GetFlipStatus"));

    // switch to DDraw context if necessary
    DDCONTEXT;

    // we can always flip, since the flip is pipelined
    // but we allow only one flip in advance
    if( lpGetFlipStatus->dwFlags == DDGFS_CANFLIP )
    {
        lpGetFlipStatus->ddRVal = updateFlipStatus(ppdev);

        return DDHAL_DRIVER_HANDLED;
    }

    // don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem

    lpGetFlipStatus->ddRVal = updateFlipStatus(ppdev);

    return DDHAL_DRIVER_HANDLED;

} // DdGetFlipStatus



//-----------------------------------------------------------------------------
//
//  DdMapMemory
//
//  This is a new DDI call specific to Windows NT that is used to map
//  or unmap all the application modifiable portions of the frame buffer
//  into the specified process's address space.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
    PDev*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DBG_DD(( 2, "DDraw:MapMemory"));

    ppdev = (PDev*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            &ShareMemoryInformation,
            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
            &ReturnedDataLength))
        {
            DBG_DD((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;

            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess=(FLATPTR)ShareMemoryInformation.VirtualAddress;

    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            NULL,
            0,
            &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;

    return(DDHAL_DRIVER_HANDLED);
}


//-----------------------------------------------------------------------------
//
// DdSetExclusiveMode
//
// This function is called by DirectDraw when we switch from the GDI surface,
// to DirectDraw exclusive mode, e.g. to run a game in fullcreen mode.
// You only need to implement this function when you are using the
// 'HeapVidMemAllocAligned' function and allocate memory for Device Bitmaps
// and DirectDraw surfaces from the same heap.
//
// We use this call to disable GDI DeviceBitMaps when we are running in
// DirectDraw exclusive mode. Otherwise a DD app gets confused if both GDI and
// DirectDraw allocate memory from the same heap.
//
// See also DdFlipToGDISurface.
//
//-----------------------------------------------------------------------------


DWORD CALLBACK
DdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    PDev*   ppdev=(PDev*)lpSetExclusiveMode->lpDD->dhpdev;

    DBG_DD((6, "DDraw::DdSetExclusiveMode called"));

    // remember setting of exclusive mode in ppdev,
    // so GDI can stop to promote DeviceBitmaps into
    // video memory

    ppdev->bDdExclusiveMode = lpSetExclusiveMode->dwEnterExcl;

    if (ppdev->bDdExclusiveMode)
    {
        // remove all GDI device bitmaps from video memory here
        // and make sure they will not be promoted to videomemory
        // until we leave exclusive mode.

        bDemoteAll(ppdev);
    }

    lpSetExclusiveMode->ddRVal=DD_OK;

    return (DDHAL_DRIVER_HANDLED);
}

//-----------------------------------------------------------------------------
//
// DWORD DdFlipToGDISurface
//
// This function is called by DirectDraw when it flips to the surface on which
// GDI can write to.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    PDev*   ppdev=(PDev*)lpFlipToGDISurface->lpDD->dhpdev;

    DBG_DD((6, "DDraw::DdFlipToGDISurface called"));

    ppdev->dwNewDDSurfaceOffset=0xffffffff;

#if DX7_STEREO
    if (ppdev->bDdStereoMode)
    {
        ppdev->bDdStereoMode=FALSE;
        LD_PERMEDIA_REG(PREG_VIDEOCONTROL,
            READ_PERMEDIA_REG(PREG_VIDEOCONTROL) &
            ~PREG_VC_STEREOENABLE);
    }
#endif

    lpFlipToGDISurface->ddRVal=DD_OK;

    //
    //  we return NOTHANDLED, then the ddraw runtime takes
    //  care that we flip back to the primary...
    //
    return (DDHAL_DRIVER_NOTHANDLED);
}

//-----------------------------------------------------------------------------
//
// DWORD DdFreeDriverMemory
//
// This function called by DirectDraw when it's running low on memory in
// our heap.  You only need to implement this function if you use the
// DirectDraw 'HeapVidMemAllocAligned' function in your driver, and you
// can boot those allocations out of memory to make room for DirectDraw.
//
// We implement this function in the P2 driver because we have DirectDraw
// entirely manage our off-screen heap, and we use HeapVidMemAllocAligned
// to put GDI device-bitmaps in off-screen memory.  DirectDraw applications
// have a higher priority for getting stuff into video memory, though, and
// so this function is used to boot those GDI surfaces out of memory in
// order to make room for DirectDraw.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdFreeDriverMemory(PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory)
{
    PDev*   ppdev;

    DBG_DD((6, "DDraw::DdFreeDriverMemory called"));

    ppdev = (PDev*)lpFreeDriverMemory->lpDD->dhpdev;

    lpFreeDriverMemory->ddRVal = DDERR_OUTOFMEMORY;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_DD((MT_LOG_LEVEL, "DdFreeDriverMemory: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    //
    // If we successfully freed up some memory, set the return value to
    // 'DD_OK'.  DirectDraw will try again to do its allocation, and
    // will call us again if there's still not enough room.  (It will
    // call us until either there's enough room for its alocation to
    // succeed, or until we return something other than DD_OK.)
    //
    if ( bMoveOldestBMPOut(ppdev) )
    {
        lpFreeDriverMemory->ddRVal = DD_OK;
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (DDHAL_DRIVER_HANDLED);
}// DdFreeDriverMemory()

//-----------------------------------------------------------------------------
//
// BOOL DrvGetDirectDrawInfo
//
// Function called by DirectDraw to returns the capabilities of the graphics
// hardware
//
// Parameters:
//
// dhpdev-------Is a handle to the PDEV returned by the driver's DrvEnablePDEV
//              routine.
// pHalInfo-----Points to a DD_HALINFO structure in which the driver should
//              return the hardware capabilities that it supports.
// pdwNumHeaps--Points to the location in which the driver should return the
//              number of VIDEOMEMORY structures pointed to by pvmList.
// pvmList------Points to an array of VIDEOMEMORY structures in which the
//              driver should return information about each video memory chunk
//              that it controls. The driver should ignore this parameter when
//              it is NULL.
// pdwNumFourCC-Points to the location in which the driver should return the
//              number of DWORDs pointed to by pdwFourCC.
// pdwFourCC----Points to an array of DWORDs in which the driver should return
//              information about each FOURCC that it supports. The driver
//              should ignore this parameter when it is NULL.
//
// Return:
//  Returns TRUE if it succeeds; otherwise, it returns FALSE
//
// Note:
//  This function will be called twice before DrvEnableDirectDraw is called.
//
// Comments
//  The driver's DrvGetDirectDrawInfo routine should do the following:
//  1)When pvmList and pdwFourCC are NULL:
//  Reserve off-screen video memory for DirectDraw use. Write the number of
//  driver video memory heaps and supported FOURCCs in pdwNumHeaps and
//  pdwNumFourCC, respectively.
//
//  2)When pvmList and pdwFourCC are not NULL:
//  Write the number of driver video memory heaps and supported FOURCCs in
//  pdwNumHeaps and pdwNumFourCC, respectively.
//  Get ptr to reserved offscreen mem?
//  For each VIDEOMEMORY structure in the list to which pvmList points, fill in
//  the appropriate members to describe a particular chunk of display memory.
//  The list of structures provides DirectDraw with a complete description of
//  the driver's off-screen memory.
//
//  3)Initialize the members of the DD_HALINFO structure with driver-specific
//  information as follows:
//  Initialize the appropriate members of the VIDEOMEMORYINFO structure to
//  describe the general characteristics of the display's memory.
//  Initialize the appropriate members of the DDNTCORECAPS structure to
//  describe the capabilities of the hardware.
//  If the driver implements a DdGetDriverInfo function, set GetDriverInfo to
//  point to it and set dwFlags to DDHALINFO_GETDRIVERINFOSET
//
//-----------------------------------------------------------------------------

BOOL
DrvGetDirectDrawInfo(DHPDEV         dhpdev,
                     DD_HALINFO*    pHalInfo,
                     DWORD*         pdwNumHeaps,
                     VIDEOMEMORY*   pvmList,     // Will be NULL on first call
                     DWORD*         pdwNumFourCC,
                     DWORD*         pdwFourCC)   // Will be NULL on first call
{
    BOOL            bCanFlip;
    BOOL            bDefineAGPHeap = FALSE,bDefineDDrawHeap = FALSE;
    LONGLONG        li;
    VIDEOMEMORY*    pVm;
    DWORD           cHeaps;
    DWORD           dwRegistryValue;

    DBG_DD((3, "DrvGetDirectDrawInfo Called"));

    PDev *ppdev=(PDev*) dhpdev;


    *pdwNumFourCC = 0;
    *pdwNumHeaps = 0;

    //On the first call, setup the chip info

    if(!(pvmList && pdwFourCC)) {

        //
        // Fill in the DDHAL Informational caps
        //
        GetDDHALInfo(ppdev, pHalInfo);

        //
        // Current primary surface attributes:
        //
        pHalInfo->vmiData.pvPrimary                 = ppdev->pjScreen;
        pHalInfo->vmiData.fpPrimary                 = 0;
        pHalInfo->vmiData.dwDisplayWidth            = ppdev->cxScreen;
        pHalInfo->vmiData.dwDisplayHeight           = ppdev->cyScreen;
        pHalInfo->vmiData.lDisplayPitch             = ppdev->lDelta;
        pHalInfo->vmiData.ddpfDisplay.dwSize        = sizeof(DDPIXELFORMAT);
        pHalInfo->vmiData.ddpfDisplay.dwFlags       = DDPF_RGB;
        pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cjPelSize * 8;

        if ( ppdev->iBitmapFormat == BMF_8BPP ) {
            //
            // Tell DDRAW that the surface is 8-bit color indexed
            //
            pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
        }

        //
        // These masks will be zero at 8bpp:
        //
        pHalInfo->vmiData.ddpfDisplay.dwRBitMask    = ppdev->flRed;
        pHalInfo->vmiData.ddpfDisplay.dwGBitMask    = ppdev->flGreen;
        pHalInfo->vmiData.ddpfDisplay.dwBBitMask    = ppdev->flBlue;

        //
        // We have to tell DirectDraw our preferred off-screen alignment
        //
        pHalInfo->vmiData.dwOffscreenAlign = 4;
        pHalInfo->vmiData.dwZBufferAlign = 4;
        pHalInfo->vmiData.dwTextureAlign = 4;

        pHalInfo->ddCaps.dwVidMemTotal =
            (ppdev->lVidMemHeight - ppdev->cyScreen) * ppdev->lDelta;
    }

    cHeaps = 0;

    //
    // Determine the YUV modes for Video playback acceleration. We can do YUV
    // conversions at any depth except 8 bits...
    //
    if (ppdev->iBitmapFormat != BMF_8BPP) {
        *pdwNumFourCC = sizeof( fourCC ) / sizeof( fourCC[0] );
    }

    if(DD_P2AGPCAPABLE(ppdev)) {
        bDefineAGPHeap = TRUE;
        cHeaps++;
    }

    // Do we have sufficient videomemory to create an off-screen heap for
    // DDraw? Test how much video memory is left after we subtract
    // that which is being used for the screen.

    if ( (ppdev->cxScreen < ppdev->lVidMemWidth)
       ||(ppdev->cyScreen < ppdev->lVidMemHeight))
    {
            bDefineDDrawHeap = TRUE;
            cHeaps++;
    }

    ppdev->cHeaps = cHeaps;
    *pdwNumHeaps  = cHeaps;

    // Define the fourCC's that we support
    if (pdwFourCC) {
        memcpy(pdwFourCC, fourCC, sizeof(fourCC));
    }

    // If pvmList is not NULL then we can go ahead and fill out the VIDEOMEMORY
    // structures which define our requested heaps.

    if(pvmList) {

        pVm=pvmList;

        //
        // Snag a pointer to the video-memory list so that we can use it to
        // call back to DirectDraw to allocate video memory:
        //
        ppdev->pvmList = pVm;

        //
        // Create one heap to describe the unused portion of video memory for
        // DirectDraw use
        //
        // Note: here lVidMemWidth is in "pixel" unit. So we should multiply it
        // by cjPelSize to get actually BYTES of video memory
        //
        // fpStart---Points to the starting address of a memory range in the
        // heap.
        // fpEnd-----Points to the ending address of a memory range if the heap
        // is linear. This address is inclusive, that is, it specifies the last
        // valid address in the range. Thus, the number of bytes specified by
        // fpStart and fpEnd is (fpEnd-fpStart+1).
        //
        // Define the heap for DirectDraw
        //
        if ( bDefineDDrawHeap )
        {
            pVm->dwFlags        = VIDMEM_ISLINEAR ;
            pVm->fpStart        = ppdev->cyScreen * ppdev->lDelta;
            pVm->fpEnd          = ppdev->lVidMemHeight * ppdev->lDelta - 1;

            //
            // DWORD align the size, the hardware should guarantee this
            //
            ASSERTDD(((pVm->fpEnd - pVm->fpStart + 1) & 3) == 0,
                    "The off-screen heap size should be DWORD aligned");

            pVm->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            DBG_DD((7, "fpStart %ld fpEnd %ld", pVm->fpStart, pVm->fpEnd));
            DBG_DD((7, "DrvGetDirectDrawInfo Creates 1 heap for DDRAW"));

            pVm++;

        }

        //Define the AGP heap
        if(bDefineAGPHeap) {
            DWORD dwAGPMemBytes;
            BOOL bSuccess;

            // Request 32Mb of AGP Memory, DDRAW will allocate less
            // if this amount is not available
            dwAGPMemBytes = P2_AGP_HEAPSIZE*1024*1024;

            DBG_DD((7, "Initialised AGP Heap for P2"));

            // The start address of the heap,
            // just set to zero as DDRAW handles the allocation
            pVm->fpStart = 0;
            // Fetch the last byte of AGP memory
            pVm->fpEnd = dwAGPMemBytes - 1;

            // drivers can set VIDMEM_ISWC here,
            // then memory will be write combined.
            // but memory on AGP buses is always uncached
            pVm->dwFlags = VIDMEM_ISNONLOCAL | VIDMEM_ISLINEAR | VIDMEM_ISWC;

            // Only use AGP memory for textures and OFFSCREENPLAIN
            pVm->ddsCaps.dwCaps =   DDSCAPS_OVERLAY |
                                    DDSCAPS_FRONTBUFFER |
                                    DDSCAPS_BACKBUFFER |
                                    DDSCAPS_ZBUFFER |
                                    DDSCAPS_3DDEVICE
                                    ;

            pVm->ddsCapsAlt.dwCaps =DDSCAPS_OVERLAY |
                                    DDSCAPS_FRONTBUFFER |
                                    DDSCAPS_BACKBUFFER |
                                    DDSCAPS_ZBUFFER |
                                    DDSCAPS_3DDEVICE
                                    ;
            ++pVm;
        }

    }


    DBG_DD((6, "DrvGetDirectDrawInfo return TRUE"));
    return(TRUE);
}// DrvGetDirectDrawInfo()

//-----------------------------------------------------------------------------
//
//  InitDDHAL
//
//  do the final initialisation of the HAL:
//  setup DDraw specific variables for the ppdev and fill in all callbacks
//  for DirectDraw
//
//  No Chip register setup is done here - it is all handled in the mode
//  change code which this function calls
//
//-----------------------------------------------------------------------------

BOOL
InitDDHAL(PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);

    DBG_DD((1, "DDraw:InitDDHAL*************************************" ));
    DBG_DD((1, "    ScreenStart =%08lx", ppdev->dwScreenStart));
    DBG_DD((1, "    ScreenWidth=%08lx",  ppdev->cxScreen ));
    DBG_DD((1, "    ScreenHeight=%08lx", ppdev->cyScreen));
    DBG_DD((1, "    dwRGBBitCount=%ld", ppdev->ddpfDisplay.dwRGBBitCount ));
    DBG_DD((1, "    RMask:   0x%x", ppdev->ddpfDisplay.dwRBitMask ));
    DBG_DD((1, "    GMask:   0x%x", ppdev->ddpfDisplay.dwGBitMask ));
    DBG_DD((1, "    BMask:   0x%x", ppdev->ddpfDisplay.dwBBitMask ));
    DBG_DD((1, "*****************************************************" ));

    // Fill in the HAL Callback pointers
    memset(&ppdev->DDHALCallbacks, 0, sizeof(DDHAL_DDCALLBACKS));
    ppdev->DDHALCallbacks.dwSize = sizeof(DDHAL_DDCALLBACKS);
    ppdev->DDHALCallbacks.WaitForVerticalBlank = DdWaitForVerticalBlank;
    ppdev->DDHALCallbacks.CanCreateSurface = DdCanCreateSurface;
    ppdev->DDHALCallbacks.GetScanLine = DdGetScanLine;
    ppdev->DDHALCallbacks.MapMemory = DdMapMemory;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->DDHALCallbacks.CreateSurface = MtDdCreateSurface;
#else
//@@END_DDKSPLIT
    ppdev->DDHALCallbacks.CreateSurface = DdCreateSurface;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT

    // Fill in the HAL Callback flags
    ppdev->DDHALCallbacks.dwFlags = DDHAL_CB32_WAITFORVERTICALBLANK |
                                    DDHAL_CB32_MAPMEMORY |
                                    DDHAL_CB32_GETSCANLINE |
                                    DDHAL_CB32_CANCREATESURFACE |
                                    DDHAL_CB32_CREATESURFACE;

    // Fill in the Surface Callback pointers
    memset(&ppdev->DDSurfCallbacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    ppdev->DDSurfCallbacks.dwSize = sizeof(DDHAL_DDSURFACECALLBACKS);
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->DDSurfCallbacks.DestroySurface = MtDdDestroySurface;
    ppdev->DDSurfCallbacks.Flip = MtDdFlip;
    ppdev->DDSurfCallbacks.Lock = MtDdLock;
    ppdev->DDSurfCallbacks.GetBltStatus = DdGetBltStatus;       // Internally protected
    ppdev->DDSurfCallbacks.GetFlipStatus = MtDdGetFlipStatus;
    ppdev->DDSurfCallbacks.Blt = MtDdBlt;
#else
//@@END_DDKSPLIT
    ppdev->DDSurfCallbacks.DestroySurface = DdDestroySurface;
    ppdev->DDSurfCallbacks.Flip = DdFlip;
    ppdev->DDSurfCallbacks.Lock = DdLock;
    ppdev->DDSurfCallbacks.GetBltStatus = DdGetBltStatus;
    ppdev->DDSurfCallbacks.GetFlipStatus = DdGetFlipStatus;
    ppdev->DDSurfCallbacks.Blt = DdBlt;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT

    ppdev->DDSurfCallbacks.dwFlags =    DDHAL_SURFCB32_DESTROYSURFACE |
                                        DDHAL_SURFCB32_FLIP     |
                                        DDHAL_SURFCB32_LOCK     |
                                        DDHAL_SURFCB32_BLT |
                                        DDHAL_SURFCB32_GETBLTSTATUS |
                                        DDHAL_SURFCB32_GETFLIPSTATUS;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->DDSurfCallbacks.SetColorKey = MtDdSetColorKey;
#else
//@@END_DDKSPLIT
    ppdev->DDSurfCallbacks.SetColorKey = DdSetColorKey;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT
    ppdev->DDSurfCallbacks.dwFlags |= DDHAL_SURFCB32_SETCOLORKEY;

    // Fill in the DDHAL Informational caps
    GetDDHALInfo(ppdev, &ppdev->ddhi32);

    return (TRUE);

}// InitDDHAL()

//-----------------------------------------------------------------------------
//
//  bIsStereoMode
//
//  Decide if mode can be displayed as stereo mode. Here we limit stereo
//  modes so that two front and two backbuffers can be created for rendering.
//
//-----------------------------------------------------------------------------

BOOL bIsStereoMode(PDev *ppdev, PDD_STEREOMODE pDDStereoMode)
{
    pDDStereoMode->bSupported = FALSE;

    // we need to check dwBpp for a valid value as PDD_STEREOMODE.dwBpp is a
    // parameter passed on from the user mode API call

    if ((pDDStereoMode->dwWidth >= 320) &&
        (pDDStereoMode->dwHeight >= 240) &&
        (pDDStereoMode->dwBpp >=  8) &&
        (pDDStereoMode->dwBpp <= 32)
       )
    {
        DWORD dwLines=ppdev->FrameBufferLength/
            (pDDStereoMode->dwWidth*pDDStereoMode->dwBpp/8);
        if (dwLines > (pDDStereoMode->dwHeight*4))
        {
            pDDStereoMode->bSupported = TRUE;
        }
    }

    return pDDStereoMode->bSupported;
}

//-----------------------------------------------------------------------------
//
// DdGetDriverInfo
//
// callback for various new HAL features, post DX3.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
{
    PPDev ppdev=(PPDev)lpData->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD dwSize;

    DBG_DD(( 2, "DDraw:GetDriverInfo"));

    // Get a pointer to the chip we are on.


    // Default to 'not supported'
    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
    ppdev = (PDev*) lpData->dhpdev;

    // fill in supported stuff
    if (IsEqualIID(&lpData->guidInfo, &GUID_D3DCallbacks3))
    {
        D3DHAL_CALLBACKS3 D3DCB3;
        DBG_DD((3,"  GUID_D3DCallbacks3"));

        memset(&D3DCB3, 0, sizeof(D3DHAL_CALLBACKS3));
        D3DCB3.dwSize = sizeof(D3DHAL_CALLBACKS3);
        D3DCB3.lpvReserved = NULL;
        D3DCB3.ValidateTextureStageState = D3DValidateTextureStageState;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
        D3DCB3.DrawPrimitives2 = MtD3DDrawPrimitives2;
#else
//@@END_DDKSPLIT
        D3DCB3.DrawPrimitives2 = D3DDrawPrimitives2;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT
        D3DCB3.dwFlags |=   D3DHAL3_CB32_DRAWPRIMITIVES2           |
                            D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
                            0;

        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        dwSize=min(lpData->dwExpectedSize,sizeof(D3DHAL_CALLBACKS3));
        memcpy(lpData->lpvData, &D3DCB3, dwSize);
        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&lpData->guidInfo, &GUID_D3DExtendedCaps))
    {
        D3DNTHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
        DBG_DD((3,"  GUID_D3DExtendedCaps"));

        memset(&D3DExtendedCaps, 0, sizeof(D3DExtendedCaps));
        dwSize=min(lpData->dwExpectedSize, sizeof(D3DExtendedCaps));

        lpData->dwActualSize = dwSize;
        D3DExtendedCaps.dwSize = dwSize;

        // number of (multi)textures we support simultaneusly for DX6
        D3DExtendedCaps.dwFVFCaps = 1;

        D3DExtendedCaps.dwMinTextureWidth  = 1;
        D3DExtendedCaps.dwMinTextureHeight = 1;
        D3DExtendedCaps.dwMaxTextureWidth  = 2048;
        D3DExtendedCaps.dwMaxTextureHeight = 2048;

        D3DExtendedCaps.dwMinStippleWidth = 8;
        D3DExtendedCaps.dwMaxStippleWidth = 8;
        D3DExtendedCaps.dwMinStippleHeight = 8;
        D3DExtendedCaps.dwMaxStippleHeight = 8;

        D3DExtendedCaps.dwTextureOpCaps =
            D3DTEXOPCAPS_DISABLE                   |
            D3DTEXOPCAPS_SELECTARG1                |
            D3DTEXOPCAPS_SELECTARG2                |
            D3DTEXOPCAPS_MODULATE                  |
            D3DTEXOPCAPS_ADD                       |
            D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
            0;

        D3DExtendedCaps.wMaxTextureBlendStages = 1;
        D3DExtendedCaps.wMaxSimultaneousTextures = 1;

        // Full range of the integer (non-fractional) bits of the
        // post-normalized texture indices. If the
        // D3DDEVCAPS_TEXREPEATNOTSCALEDBYSIZE bit is set, the
        // device defers scaling by the texture size until after
        // the texture address mode is applied. If it isn't set,
        // the device scales the texture indices by the texture size
        // (largest level-of-detail) prior to interpolation.
        D3DExtendedCaps.dwMaxTextureRepeat = 2048;

        // In order to support stencil buffers in DX6 we need besides
        // setting these caps and handling the proper renderstates to
        // declare the appropriate z buffer pixel formats here in
        // response to the GUID_ZPixelFormats and implement the
        // Clear2 callback. Also , we need to be able to create the
        // appropriate ddraw surfaces.
#if D3D_STENCIL
        D3DExtendedCaps.dwStencilCaps =  0                      |
                                        D3DSTENCILCAPS_KEEP     |
                                        D3DSTENCILCAPS_ZERO     |
                                        D3DSTENCILCAPS_REPLACE  |
                                        D3DSTENCILCAPS_INCRSAT  |
                                        D3DSTENCILCAPS_DECRSAT  |
                                        D3DSTENCILCAPS_INVERT;
#endif

#if D3DDX7_TL
        // In order to use hw accelerated T&L we must declare
        // how many simultaneously active lights we can handle.
        D3DExtendedCaps.dwMaxActiveLights = 0;
#endif //D3DDX7_TL

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
        // Parameter for point sprites
        D3DExtendedCaps.dvMaxPointSize = 10.0;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

        memcpy(lpData->lpvData, &D3DExtendedCaps, dwSize);
        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&lpData->guidInfo, &GUID_ZPixelFormats))
    {
        DDPIXELFORMAT ddZBufPixelFormat[2];
        DWORD         dwNumZPixelFormats;

        DBG_DD((3,"  GUID_ZPixelFormats"));


        memset(ddZBufPixelFormat, 0, sizeof(ddZBufPixelFormat));

#if D3D_STENCIL
        dwSize = (DWORD)min(lpData->dwExpectedSize, 2*sizeof(DDPIXELFORMAT));
        lpData->dwActualSize = 2*sizeof(DDPIXELFORMAT) + sizeof(DWORD);
#else
        dwSize = (DWORD)min(lpData->dwExpectedSize, 1*sizeof(DDPIXELFORMAT));
        lpData->dwActualSize = 1*sizeof(DDPIXELFORMAT) + sizeof(DWORD);
#endif

        // If we didn't support stencils, we would only fill one 16-bit
        // Z Buffer format since that is all what the Permedia supports.
        // Drivers that implement stencil buffer support (like this one)
        // have to report here all Z Buffer formats supported since they
        // have to support the Clear2 callback (or the D3DDP2OP_CLEAR
        // token)

#if D3D_STENCIL
        dwNumZPixelFormats = 2;
#else
        dwNumZPixelFormats = 1;
#endif

        ddZBufPixelFormat[0].dwSize = sizeof(DDPIXELFORMAT);
        ddZBufPixelFormat[0].dwFlags = DDPF_ZBUFFER;
        ddZBufPixelFormat[0].dwFourCC = 0;
        ddZBufPixelFormat[0].dwZBufferBitDepth = 16;
        ddZBufPixelFormat[0].dwStencilBitDepth = 0;
        ddZBufPixelFormat[0].dwZBitMask = 0xFFFF;
        ddZBufPixelFormat[0].dwStencilBitMask = 0x0000;
        ddZBufPixelFormat[0].dwRGBZBitMask = 0;

#if D3D_STENCIL
        ddZBufPixelFormat[1].dwSize = sizeof(DDPIXELFORMAT);
        ddZBufPixelFormat[1].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
        ddZBufPixelFormat[1].dwFourCC = 0;
        // The sum of the z buffer bit depth AND the stencil depth
        // should be included here
        ddZBufPixelFormat[1].dwZBufferBitDepth = 16;
        ddZBufPixelFormat[1].dwStencilBitDepth = 1;
        ddZBufPixelFormat[1].dwZBitMask = 0x7FFF;
        ddZBufPixelFormat[1].dwStencilBitMask = 0x8000;
        ddZBufPixelFormat[1].dwRGBZBitMask = 0;
#endif

        memcpy(lpData->lpvData, &dwNumZPixelFormats, sizeof(DWORD));
        memcpy((LPVOID)((LPBYTE)(lpData->lpvData) + sizeof(DWORD)),
                        ddZBufPixelFormat, dwSize);

        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo),
                &GUID_D3DParseUnknownCommandCallback))
    {
        DBG_DD((3,"  GUID_D3DParseUnknownCommandCallback"));
        ppdev->pD3DParseUnknownCommand =
            (PFND3DNTPARSEUNKNOWNCOMMAND)(lpData->lpvData);
        lpData->ddRVal = DD_OK;
    }
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_DDMoreCaps))
    {
        DD_MORECAPS DDMoreCaps;

        DBG_DD((3,"  GUID_DDMoreCaps"));

        // here we set all the caps for the new
        // DirectDraw 7 AlphaBlt callback

        memset(&DDMoreCaps, 0, sizeof(DD_MORECAPS));

        DDMoreCaps.dwSize=sizeof(DD_MORECAPS);

        // alpha caps for Vmem->Vmem blts
        // claim to do lots of stuff, we can still fail in callback
        DDMoreCaps.dwAlphaCaps    = DDALPHACAPS_BLTALPHAPIXELS |
                                    DDALPHACAPS_BLTSATURATE |
                                    DDALPHACAPS_BLTPREMULT  |
                                    DDALPHACAPS_BLTNONPREMULT |
                                    DDALPHACAPS_BLTALPHAFILL |
                                    DDALPHACAPS_BLTARGBSCALE1F |
                                    DDALPHACAPS_BLTARGBSCALE2F |
                                    DDALPHACAPS_BLTARGBSCALE4F |
                                    DDALPHACAPS_BLTALPHAANDARGBSCALING;

        DDMoreCaps.dwSVBAlphaCaps = 0;
        // alpha capabilities for System->Vmem blts
        DDMoreCaps.dwVSBAlphaCaps = 0;
        // alpha capabilities for Vmem->System blts
        DDMoreCaps.dwSSBAlphaCaps = 0;
        // alpha capabilities for System->System blts

        // filter caps for Vmem->Vmem blts
        DDMoreCaps.dwFilterCaps   = DDFILTCAPS_BLTQUALITYFILTER |
                                    DDFILTCAPS_BLTCANDISABLEFILTER;

        DDMoreCaps.dwSVBFilterCaps= 0;
        // filter capabilities for System->Vmem blts
        DDMoreCaps.dwVSBFilterCaps= 0;
        // filter capabilities for Vmem->System blts
        DDMoreCaps.dwSSBFilterCaps= 0;
        // filter capabilities for System->System blts

        lpData->dwActualSize = sizeof(DDMoreCaps);
        dwSize=min( sizeof(DDMoreCaps), lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDMoreCaps, dwSize);
        lpData->ddRVal = DD_OK;
    }
#endif
//@@END_DDKSPLIT
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_Miscellaneous2Callbacks) )
    {
        BOOL bRet;
        DWORD dwResult;

        DDHAL_DDMISCELLANEOUS2CALLBACKS MISC2_CB;

        DBG_DD((3,"  GUID_Miscellaneous2Callbacks2"));

        memset(&MISC2_CB, 0, sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS));
        MISC2_CB.dwSize = sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS);

        MISC2_CB.dwFlags  = 0
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
            | DDHAL_MISC2CB32_ALPHABLT
#endif
//@@END_DDKSPLIT
            | DDHAL_MISC2CB32_CREATESURFACEEX
            | DDHAL_MISC2CB32_GETDRIVERSTATE
            | DDHAL_MISC2CB32_DESTROYDDLOCAL;

        MISC2_CB.GetDriverState = D3DGetDriverState;
        MISC2_CB.CreateSurfaceEx = D3DCreateSurfaceEx;
        MISC2_CB.DestroyDDLocal = D3DDestroyDDLocal;

//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
        MISC2_CB.AlphaBlt = DdAlphaBlt;
#endif
//@@END_DDKSPLIT
        lpData->dwActualSize = sizeof(MISC2_CB);
        dwSize = min(sizeof(MISC2_CB),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &MISC2_CB, dwSize);
        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_UpdateNonLocalHeap))
    {
        LPDDHAL_UPDATENONLOCALHEAPDATA pDDNonLocalHeap;

        DBG_DD((3,"  GUID_UpdateNonLocalHeap"));

        pDDNonLocalHeap = (LPDDHAL_UPDATENONLOCALHEAPDATA)lpData->lpvData;

        ppdev->dwGARTLinBase = pDDNonLocalHeap->fpGARTLin;
        ppdev->dwGARTDevBase = pDDNonLocalHeap->fpGARTDev;

        // These values are used to specify the base address of the
        // visible 8Mb window of AGP memory

        ppdev->dwGARTLin = pDDNonLocalHeap->fpGARTLin;
        ppdev->dwGARTDev = pDDNonLocalHeap->fpGARTDev;

        DDCONTEXT;
        SYNC_WITH_PERMEDIA;

        LD_PERMEDIA_REG (PREG_AGPTEXBASEADDRESS,(ULONG)ppdev->dwGARTDev);

        DBG_DD((3,"GartLin: 0x%x, GartDev: 0x%x",
            (ULONG)ppdev->dwGARTLin, ppdev->dwGARTDev));

        lpData->ddRVal = DD_OK;

    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_GetHeapAlignment) )
    {

        LPDDHAL_GETHEAPALIGNMENTDATA lpFData=
            (LPDDHAL_GETHEAPALIGNMENTDATA) lpData->lpvData;

        DBG_DD((3,"  GUID_GetHeapAlignment"));

        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_NTPrivateDriverCaps) )
    {
        DD_NTPRIVATEDRIVERCAPS DDPrivateDriverCaps;

        DBG_DD((3,"  GUID_NTPrivateDriverCaps"));

        memset(&DDPrivateDriverCaps, 0, sizeof(DDPrivateDriverCaps));
        DDPrivateDriverCaps.dwSize=sizeof(DDPrivateDriverCaps);

        // we want the kernel to call us when a primary surface is created
        // so that we can store some private information in the
        // lpGbl->dwReserved1 field
        DDPrivateDriverCaps.dwPrivateCaps=DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION;

        lpData->dwActualSize =sizeof(DDPrivateDriverCaps);

        dwSize = min(sizeof(DDPrivateDriverCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDPrivateDriverCaps, dwSize);
        lpData->ddRVal = DD_OK;
    }
#if DX7_STEREO
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_DDMoreSurfaceCaps) )
    {
        DD_MORESURFACECAPS DDMoreSurfaceCaps;
        DDSCAPSEX   ddsCapsEx, ddsCapsExAlt;
        ULONG ulCopyPointer;

        DBG_DD((3,"  GUID_DDMoreSurfaceCaps"));

        // fill in everything until expectedsize...
        memset(&DDMoreSurfaceCaps, 0, sizeof(DDMoreSurfaceCaps));

        // Caps for heaps 2..n
        memset(&ddsCapsEx, 0, sizeof(ddsCapsEx));
        memset(&ddsCapsExAlt, 0, sizeof(ddsCapsEx));

        DDMoreSurfaceCaps.dwSize=lpData->dwExpectedSize;

        DBG_DD((3,"  stereo support: %ld", ppdev->bCanDoStereo));
        if (ppdev->bCanDoStereo)
        {
            DDMoreSurfaceCaps.ddsCapsMore.dwCaps2 =
                DDSCAPS2_STEREOSURFACELEFT;
        }
        lpData->dwActualSize = lpData->dwExpectedSize;

        dwSize = min(sizeof(DDMoreSurfaceCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDMoreSurfaceCaps, dwSize);

        // now fill in other heaps...
        while (dwSize < lpData->dwExpectedSize)
        {
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsEx,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsExAlt,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
        }

        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_DDStereoMode) ) {
        PDD_STEREOMODE pDDStereoMode;

        // Permedia supports all modes as stereo modes.
        // for test purposes, we restrict them to something
        // larger than 320x240

        //
        // note: this GUID_DDStereoMode is only used on NT to
        // report stereo modes. There is no need to implement
        // it in win9x drivers. Win9x drivers report stereo
        // modes by setting the DDMODEINFO_STEREO bit in the
        // dwFlags member of the DDHALMODEINFO structure.
        // It is also recommended to report DDMODEINFO_MAXREFRESH
        // for stereo modes when running under a runtime >= DX7 to
        // allow applications to select higher refresh rates for
        // stereo modes.
        //

        if (lpData->dwExpectedSize >= sizeof(PDD_STEREOMODE))
        {
            pDDStereoMode = (PDD_STEREOMODE) lpData->lpvData;

            bIsStereoMode( ppdev, pDDStereoMode);

            DBG_DD((3,"  GUID_DDStereoMode(%d,%d,%d,%d=%d)",
                pDDStereoMode->dwWidth,
                pDDStereoMode->dwHeight,
                pDDStereoMode->dwBpp,
                pDDStereoMode->dwRefreshRate,
                pDDStereoMode->bSupported));

            lpData->dwActualSize = sizeof(DD_STEREOMODE);
            lpData->ddRVal = DD_OK;
        }
    }
#endif
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_NonLocalVidMemCaps) )
    {
        DD_NONLOCALVIDMEMCAPS DDNonLocalVidMemCaps;

        DBG_DD((3,"  GUID_DDNonLocalVidMemCaps"));

        memset(&DDNonLocalVidMemCaps, 0, sizeof(DDNonLocalVidMemCaps));
        DDNonLocalVidMemCaps.dwSize=sizeof(DDNonLocalVidMemCaps);

        //fill in all supported nonlocal to videomemory blts
        //
        DDNonLocalVidMemCaps.dwNLVBCaps = DDCAPS_BLT |
                                          DDCAPS_BLTSTRETCH |
                                          DDCAPS_BLTQUEUE |
                                          DDCAPS_COLORKEY |
                                          DDCAPS_ALPHA |
                                          DDCAPS_CANBLTSYSMEM;

        DDNonLocalVidMemCaps.dwNLVBCaps2 = 0;

        DDNonLocalVidMemCaps.dwNLVBCKeyCaps=DDCKEYCAPS_SRCBLT |
                                            DDCKEYCAPS_SRCBLTCLRSPACE;


        DDNonLocalVidMemCaps.dwNLVBFXCaps = DDFXCAPS_BLTALPHA |
                                            DDFXCAPS_BLTFILTER |
                                            DDFXCAPS_BLTSTRETCHY |
                                            DDFXCAPS_BLTSTRETCHX |
                                            DDFXCAPS_BLTSTRETCHYN |
                                            DDFXCAPS_BLTSTRETCHXN |
                                            DDFXCAPS_BLTSHRINKY |
                                            DDFXCAPS_BLTSHRINKX |
                                            DDFXCAPS_BLTSHRINKYN |
                                            DDFXCAPS_BLTSHRINKXN |
                                            DDFXCAPS_BLTMIRRORUPDOWN |
                                            DDFXCAPS_BLTMIRRORLEFTRIGHT;

        if (ppdev->iBitmapFormat != BMF_8BPP)
        {
            DDNonLocalVidMemCaps.dwNLVBCaps |= DDCAPS_BLTFOURCC;
            DDNonLocalVidMemCaps.dwNLVBCKeyCaps|=DDCKEYCAPS_SRCBLTCLRSPACEYUV;
        }

        for(INT i = 0; i < DD_ROP_SPACE; i++ )
            DDNonLocalVidMemCaps.dwNLVBRops[i] = rops[i];

        lpData->dwActualSize =sizeof(DDNonLocalVidMemCaps);

        dwSize = min(sizeof(DDNonLocalVidMemCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDNonLocalVidMemCaps, dwSize);
        lpData->ddRVal = DD_OK;
    } else if (IsEqualIID(&lpData->guidInfo, &GUID_NTCallbacks))
    {
        DD_NTCALLBACKS NtCallbacks;

        memset(&NtCallbacks, 0, sizeof(NtCallbacks));

        dwSize = min(lpData->dwExpectedSize, sizeof(DD_NTCALLBACKS));

        NtCallbacks.dwSize           = dwSize;
        NtCallbacks.dwFlags          =   DDHAL_NTCB32_FREEDRIVERMEMORY
                                       | DDHAL_NTCB32_SETEXCLUSIVEMODE
                                       | DDHAL_NTCB32_FLIPTOGDISURFACE
                                       ;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;      // Internally protected
        NtCallbacks.SetExclusiveMode = MtDdSetExclusiveMode;
        NtCallbacks.FlipToGDISurface = MtDdFlipToGDISurface;
#else
//@@END_DDKSPLIT
        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;
        NtCallbacks.SetExclusiveMode = DdSetExclusiveMode;
        NtCallbacks.FlipToGDISurface = DdFlipToGDISurface;
//@@BEGIN_DDKSPLIT
#endif  MULTITHREADED
//@@END_DDKSPLIT

        memcpy(lpData->lpvData, &NtCallbacks, dwSize);

        lpData->ddRVal = DD_OK;
    }

    // We always handled it.
    return DDHAL_DRIVER_HANDLED;

}   // GetDriverInfo


//-----------------------------------------------------------------------------
//
//  updateFlipStatus
//
//  return DD_OK when last flip has occured.
//
//-----------------------------------------------------------------------------

HRESULT
updateFlipStatus( PPDev ppdev )
{
    PERMEDIA_DEFS(ppdev);
    DBG_DD((6, "DDraw:updateFlipStatus"));

    // we assume that we are already in the DDraw/D3D context.

    // read Permedia register which tells us if there is a flip pending
    if (ppdev->dwNewDDSurfaceOffset!=0xffffffff)
    {
        ULONG ulScreenBase=READ_PERMEDIA_REG(PREG_SCREENBASE);

        if (ulScreenBase!=
            ppdev->dwNewDDSurfaceOffset)
        {

            DBG_DD((7,"  SurfaceOffset %08lx instead of %08lx",
                ulScreenBase,
                ppdev->dwNewDDSurfaceOffset));

            //
            //  make sure all pending data was flushed!
            //
            FLUSHDMA();

            //
            // if we are busy, return
            // otherwise the pipeline is empty and we can
            // fall through and to check if the chip already flipped.
            //
            if (DRAW_ENGINE_BUSY)
                return DDERR_WASSTILLDRAWING;

        }
    }

    DWORD dwVideoControl=READ_PERMEDIA_REG(PREG_VIDEOCONTROL);

    if (dwVideoControl & PREG_VC_SCREENBASEPENDING)
    {
        DBG_DD((7,"  VideoControl still pending (%08lx)",dwVideoControl));
        return DDERR_WASSTILLDRAWING;
    }

    return DD_OK;

} // updateFlipStatus




//@@BEGIN_DDKSPLIT
#if MULTITHREADED

//-----------------------------------------------------------------------------
//
// Multithread support wrappers for Dx callback functions
//
//-----------------------------------------------------------------------------

//DWORD CALLBACK MtDdBlt( LPDDHAL_BLTDATA lpBlt );
WRAPMTDXCALLBACK(DD, DdBlt, LPDDHAL_BLTDATA, lpBlt,
                 lpBlt->lpDD->dhpdev);

//DWORD CALLBACK MtDdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd);
WRAPMTDXCALLBACK(DD, DdCreateSurface, LPDDHAL_CREATESURFACEDATA, pcsd,
                 pcsd->lpDD->dhpdev);

//DWORD CALLBACK MtDdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd);
WRAPMTDXCALLBACK(DD, DdDestroySurface, LPDDHAL_DESTROYSURFACEDATA, psdd,
                 psdd->lpDD->dhpdev);

//DWORD CALLBACK MtDdFlip( LPDDHAL_FLIPDATA lpFlipData);
WRAPMTDXCALLBACK(DD, DdFlip, LPDDHAL_FLIPDATA, lpFlipData,
                 lpFlipData->lpDD->dhpdev);

//DWORD CALLBACK MtDdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface);
WRAPMTDXCALLBACK(DD, DdFlipToGDISurface, PDD_FLIPTOGDISURFACEDATA, lpFlipToGDISurface,
                 lpFlipToGDISurface->lpDD->dhpdev);

//DWORD CALLBACK MtDdGetFlipStatus(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus);
WRAPMTDXCALLBACK(DD, DdGetFlipStatus, LPDDHAL_GETFLIPSTATUSDATA, lpGetFlipStatus,
                 lpGetFlipStatus->lpDD->dhpdev);

//DWORD CALLBACK MtDdLock( LPDDHAL_LOCKDATA lpLockData );
WRAPMTDXCALLBACK(DD, DdLock, LPDDHAL_LOCKDATA, lpLockData,
                 lpLockData->lpDD->dhpdev);

//DWORD CALLBACK MtDdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);
WRAPMTDXCALLBACK(DD, DdSetExclusiveMode, PDD_SETEXCLUSIVEMODEDATA, lpSetExclusiveMode,
                 lpSetExclusiveMode->lpDD->dhpdev);

#endif  MULTITHREADED
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtxman.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.h
*
* Content:  D3D Texture manager definitions and macros.
*
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#ifdef __D3DTEXMAN
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif
#define __D3DTEXMAN

#ifndef __D3DHW
#include "d3dhw.h"
#endif
#ifndef __DCONTEXT
#include "d3dcntxt.h"
#endif

#define parent(k) (k / 2)
#define lchild(k) (k * 2)
#define rchild(k) (k * 2 + 1)

__inline ULONGLONG TextureCost(PPERMEDIA_D3DTEXTURE pTexture)
{
#ifdef _X86_
    ULONGLONG retval = 0;
    _asm
    {
        mov     ebx, pTexture;
        mov     eax, [ebx]PERMEDIA_D3DTEXTURE.m_dwPriority;
        mov     ecx, eax;
        shr     eax, 1;
        mov     DWORD PTR retval + 4, eax;
        shl     ecx, 31;
        mov     eax, [ebx]PERMEDIA_D3DTEXTURE.m_dwTicks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR retval, eax;
    }
    return retval;
#else
    return ((ULONGLONG)pTexture->m_dwPriority << 31) + 
            ((ULONGLONG)(pTexture->m_dwTicks >> 1));
#endif
}

typedef struct _TextureHeap 
{
    DWORD   m_next;
    DWORD   m_size;
    PPERMEDIA_D3DTEXTURE *m_data_p;
} TextureHeap, *PTextureHeap;

void TextureHeapHeapify(PTextureHeap,DWORD);
bool TextureHeapAdd(PTextureHeap,PPERMEDIA_D3DTEXTURE);
PPERMEDIA_D3DTEXTURE TextureHeapExtractMin(PTextureHeap);
PPERMEDIA_D3DTEXTURE TextureHeapExtractMax(PTextureHeap);
void TextureHeapDel(PTextureHeap,DWORD);
void TextureHeapUpdate(PTextureHeap,DWORD,DWORD,DWORD); 

typedef struct _TextureCacheManager 
{    
    TextureHeap m_heap;
    unsigned int tcm_ticks;
    D3DDEVINFO_TEXTUREMANAGER m_stats;
}TextureCacheManager, *PTextureCacheManager;

// Free the LRU texture 
BOOL TextureCacheManagerFreeTextures(PTextureCacheManager,DWORD, DWORD);
    //remove all HW handles and release surface
void TextureCacheManagerRemove(PTextureCacheManager,PPERMEDIA_D3DTEXTURE);  
    
HRESULT TextureCacheManagerAllocNode(PERMEDIA_D3DCONTEXT*,PPERMEDIA_D3DTEXTURE);
HRESULT TextureCacheManagerInitialize(PTextureCacheManager);
    
__inline void TextureCacheManagerRemoveFromHeap(
    PTextureCacheManager pTextureCacheManager,
    PPERMEDIA_D3DTEXTURE lpD3DTexI) 
{ 
    TextureHeapDel(&pTextureCacheManager->m_heap,lpD3DTexI->m_dwHeapIndex); 
}
__inline void TextureCacheManagerUpdatePriority(
    PTextureCacheManager pTextureCacheManager,
    PPERMEDIA_D3DTEXTURE lpD3DTexI) 
{ 
    TextureHeapUpdate(&pTextureCacheManager->m_heap,
        lpD3DTexI->m_dwHeapIndex, 
        lpD3DTexI->m_dwPriority, lpD3DTexI->m_dwTicks); 
}
__inline void TextureCacheManagerIncTotSz(
    PTextureCacheManager pTextureCacheManager,
    DWORD dwSize)
{
    ++pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes += dwSize;
}
__inline void TextureCacheManagerDecTotSz(
    PTextureCacheManager pTextureCacheManager,
    DWORD dwSize)
{
    --pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes -= dwSize;
}
__inline void TextureCacheManagerIncNumSetTexInVid(
    PTextureCacheManager pTextureCacheManager)
{
    ++pTextureCacheManager->m_stats.dwNumUsedTexInVid;
}
__inline void TextureCacheManagerIncNumTexturesSet(
    PTextureCacheManager pTextureCacheManager)
{
    ++pTextureCacheManager->m_stats.dwNumTexturesUsed;
}
__inline void TextureCacheManagerResetStatCounters(
    PTextureCacheManager pTextureCacheManager)
{
    pTextureCacheManager->m_stats.bThrashing = 0;
    pTextureCacheManager->m_stats.dwNumEvicts = 0;
    pTextureCacheManager->m_stats.dwNumVidCreates = 0;
    pTextureCacheManager->m_stats.dwNumUsedTexInVid = 0;
    pTextureCacheManager->m_stats.dwNumTexturesUsed = 0;
}
__inline void TextureCacheManagerGetStats(
    PERMEDIA_D3DCONTEXT *pContext,
    LPD3DDEVINFO_TEXTUREMANAGER stats)
{
    memcpy(stats, &pContext->pTextureManager->m_stats, 
        sizeof(D3DDEVINFO_TEXTUREMANAGER));
}
void TextureCacheManagerEvictTextures(PTextureCacheManager);
void TextureCacheManagerTimeStamp(PTextureCacheManager,PPERMEDIA_D3DTEXTURE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\ddblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddblt.c
*
* Content:    DirectDraw Blt and AlphaBlt callbacks
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"

//
// lookup table to get shift values from Permedia format definition
DWORD ShiftLookup[5] = { 0, 0, 1, 0, 2};

//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
//---------------------------------------------------------------------------
// BOOL Intersect
//
// Function:
//      Check the integration of two input rectangles (RECTL* pRcl1,
//      RECTL* pRcl2) and set the intersection result in (RECTL* pRclResult)
//
// Return:
//      TRUE---If 'prcl1' and 'prcl2' intersect. The intersection will be in
//            'prclResult'
//      FALSE--If they don't intersect. 'prclResult' is undefined.
//
//---------------------------------------------------------------------------

BOOL
Intersect(RECTL*  pRcl1,
          RECT*   pRcl2,
          RECTL*  pRclResult)
{
    pRclResult->left  = max(pRcl1->left,  pRcl2->left);
    pRclResult->right = min(pRcl1->right, pRcl2->right);

    //
    // Check if there is a horizontal intersection
    //
    if ( pRclResult->left < pRclResult->right )
    {
        pRclResult->top    = max(pRcl1->top,    pRcl2->top);
        pRclResult->bottom = min(pRcl1->bottom, pRcl2->bottom);

        //
        // Check if there a vertical intersection
        //
        if (pRclResult->top < pRclResult->bottom)
            return(TRUE);

    }

    //
    // Return FALSE if there is no intersection
    //
    return(FALSE);
}// Intersect()

//-----------------------------------------------------------------------------
//  IsDstRectClipped
//  
//  check if the destination rectangle of a blit is clipped by the given clip  
//  rectangles. The function takes the rectangles as is and there can be cases
//  where a dest. rectangle is not clipped, but do not detect it...
//
//  pDstRect---destination rectangle for blt
//  iClipRects-number of clip regions
//  pClipRects-clipping regions
//
//Return:
//  TRUE---dest rectangle is clipped
//  FALSE--dest rectangle is not clipped
//-----------------------------------------------------------------------------

BOOL 
IsDstRectClipped(RECTL *pDstRect, 
                 INT iClipRects, 
                 RECT *pClipRects)
{
    INT i;
    RECTL rClippedRect;

    for ( i=0; i<iClipRects; i++)
    {
        if (Intersect( pDstRect, &pClipRects[i], &rClippedRect))
        {
            if (pDstRect->left==rClippedRect.left &&
                pDstRect->right==rClippedRect.right &&
                pDstRect->top==rClippedRect.top &&
                pDstRect->bottom==rClippedRect.bottom 
               )
            {
                // dest rect is not clipped!!!
                return FALSE;
            }
        }
    }

    return TRUE;
}
#endif
//@@END_DDKSPLIT

//-----------------------------------------------------------------------------
//
//  DdPermediaBlt
//
//  implements DirectDraw Blt callback  
//
//  lpBlt----structure for passing information to DDHAL Blt
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
DdBlt( LPDDHAL_BLTDATA lpBlt )
{
    PPDev ppdev=(PPDev)lpBlt->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD   dwWindowBase;
    RECTL   rSrc;
    RECTL   rDest;
    DWORD   dwFlags;
    LONG    lPixPitchDest;
    LONG    lPixPitchSrc;
    HRESULT ddrval;
    LPDDRAWI_DDRAWSURFACE_LCL  pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL  pDestLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pSrcGbl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDestGbl;
    PermediaSurfaceData* pPrivateSource;
    PermediaSurfaceData* pPrivateDest;
    
    pDestLcl    = lpBlt->lpDDDestSurface;
    pSrcLcl     = lpBlt->lpDDSrcSurface;
    
    DBG_DD((2,"DDraw: Blt, ppdev: 0x%x",ppdev));
    
    pDestGbl    = pDestLcl->lpGbl;
    pPrivateDest= (PermediaSurfaceData*)pDestGbl->dwReserved1;
    
    DD_CHECK_PRIMARY_SURFACE_DATA(pDestLcl,pPrivateDest);

    DBG_DD((10, "Dest Surface:"));
    DUMPSURFACE(10, pDestLcl, NULL);

    ULONG ulDestPixelShift=DDSurf_GetPixelShift(pDestLcl);

    dwFlags = lpBlt->dwFlags;
   
    // For the future, drivers should ignore the DDBLT_ASYNC
    // flag, because its hardly used by applications and
    // nowadays drivers can queue up lots of blits, so that
    // the applications do not have to wait for it.
    
    // get local copy of src and dest rect    
    rSrc = lpBlt->rSrc;
    rDest = lpBlt->rDest;

    // Switch to DirectDraw context
    DDCONTEXT;
    
    if (DDSurf_BitDepth(pDestLcl)==24)
    {
        return DDHAL_DRIVER_NOTHANDLED;  
    }

    dwWindowBase = (DWORD)((UINT_PTR)(pDestGbl->fpVidMem) >> 
        ulDestPixelShift);

    // get pitch for destination in pixels
    lPixPitchDest = pDestGbl->lPitch >> ulDestPixelShift;

    if (dwFlags & DDBLT_ROP)
    {

        if ((lpBlt->bltFX.dwROP >> 16) != (SRCCOPY >> 16))
        {
            DBG_DD((1,"DDraw:Blt:BLT ROP case not supported!"));
            return DDHAL_DRIVER_NOTHANDLED;
        }

        LONG    srcOffset;
        
        DBG_DD((3,"DDBLT_ROP:  SRCCOPY"));

        if (pSrcLcl != NULL) 
        {
            pSrcGbl = pSrcLcl->lpGbl;
            
            pPrivateSource = (PermediaSurfaceData*)pSrcGbl->dwReserved1;
            
            DD_CHECK_PRIMARY_SURFACE_DATA(pSrcLcl,pPrivateSource);

            DBG_DD((10, "Source Surface:"));
            DUMPSURFACE(10, pSrcLcl, NULL);
        }
        else 
        {
            return DDHAL_DRIVER_NOTHANDLED;
        }

        if (DDSurf_BitDepth(pSrcLcl)==24)
            return DDHAL_DRIVER_NOTHANDLED;  

        // determine src pitch in pixels
        lPixPitchSrc = pSrcGbl->lPitch >> ulDestPixelShift;


        // Operation is System -> Video memory blit, 
        // as a texture download or an image download.
        if ((pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) && 
            (pDestLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        {
            ASSERTDD(!(pDestLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM),
                "unsupported texture download to AGP memory");

            if ((pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                        DDSCAPS2_TEXTUREMANAGE)
                && (NULL != pPrivateDest)
               )
            {   
                // texture download

                DBG_DD((3,"SYSMEM->MANAGED MEM Blit"
                           "(texture to system memory)"));
                
                pPrivateDest->dwFlags |= P2_SURFACE_NEEDUPDATE;
                SysMemToSysMemSurfaceCopy(
                    pSrcGbl->fpVidMem,
                    pSrcGbl->lPitch,
                    DDSurf_BitDepth(pSrcLcl),
                    pDestGbl->fpVidMem,
                    pDestGbl->lPitch,
                    DDSurf_BitDepth(pDestLcl), 
                    &rSrc, 
                    &rDest);

                goto BltDone;
            }
            else
            if (pPrivateDest!=NULL)
            {
                if ( (pDestLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
                    ((rSrc.right-rSrc.left)==(LONG)pSrcGbl->wWidth) &&
                    ((rSrc.bottom-rSrc.top)==(LONG)pSrcGbl->wHeight)
                    )
                {   
                    // 
                    // patched texture download can only be done 
                    // when the texture is downloaded as a whole!
                    //

                    DBG_DD((3,"SYSMEM->VIDMEM Blit (texture to videomemory)"));

                    PermediaPatchedTextureDownload(
                        ppdev, 
                        pPrivateDest, 
                        pSrcGbl->fpVidMem,
                        pSrcGbl->lPitch,
                        &rSrc, 
                        pDestGbl->fpVidMem,
                        pDestGbl->lPitch, 
                        &rDest);
                }
                else
                {
                    // Image download

                    DBG_DD((3,"SYSMEM->VIDMEM Blit (system to videomemory)"));

                    PermediaPackedDownload( 
                        ppdev, 
                        pPrivateDest, 
                        pSrcLcl, 
                        &rSrc, 
                        pDestLcl, 
                        &rDest);
                }                   
                goto BltDone;
            } else
            {
                DBG_DD((0,"DDraw: Blt, privatedest invalid"));
                return DDHAL_DRIVER_NOTHANDLED;
            }
        }

        if (pPrivateSource == NULL ||
            pPrivateDest == NULL)
        {
            DBG_DD((0,"DDraw: Blt, privatesource or dest invalid"));
            return DDHAL_DRIVER_NOTHANDLED;
        }

        BOOL bNonLocalToVideo=FALSE;

        // set base of source
        if ( DDSCAPS_NONLOCALVIDMEM & pSrcLcl->ddsCaps.dwCaps)
        {
            // turn on AGP bus texture source
            srcOffset  = (LONG) DD_AGPSURFACEPHYSICAL(pSrcGbl);
            srcOffset |= 1 << 30;

            bNonLocalToVideo=TRUE;

        } else
        {
            srcOffset = (LONG)((pSrcGbl->fpVidMem) >> 
                pPrivateSource->SurfaceFormat.PixelSize);
        }

        // Operation is YUV->RGB conversion
        if ((pPrivateSource != NULL) && 
            (pPrivateSource->SurfaceFormat.Format == PERMEDIA_YUV422) &&
            (pPrivateSource->SurfaceFormat.FormatExtension 
                    == PERMEDIA_YUV422_EXTENSION))
        {
            DBG_DD((3,"YUV to RGB blt"));
            
            // We are only doing blits from YUV422 to RGB !

            if (pPrivateDest->SurfaceFormat.Format != PERMEDIA_YUV422)
            {
                DBG_DD((4,"Blitting from Source YUV to RGB"));
                
                // YUV to RGB blt
                PermediaYUVtoRGB(   ppdev, 
                                    &lpBlt->bltFX, 
                                    pPrivateDest, 
                                    pPrivateSource, 
                                    &rDest, 
                                    &rSrc, 
                                    dwWindowBase, 
                                    srcOffset);
                
                goto BltDone;
            }
            else
            {
                DBG_DD((0,"Couldn't handle YUV to YUV blt"));

                lpBlt->ddRVal = DD_OK;

                return DDHAL_DRIVER_NOTHANDLED;
            }
        }

        ASSERTDD(DDSurf_BitDepth(pSrcLcl)==DDSurf_BitDepth(pDestLcl),
                 "Blt between surfaces of different"
                 "color depths are not supported");

        BOOL bMirror=(dwFlags & DDBLT_DDFX)==DDBLT_DDFX;
        if (bMirror)
        {
            bMirror=  (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) || 
                      (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT);
        }
        BOOL bStretched=((rSrc.right - rSrc.left) != 
                            (rDest.right - rDest.left) || 
                        (rSrc.bottom - rSrc.top) != 
                            (rDest.bottom - rDest.top));

        // Is it a colorkey blt?
        if (dwFlags & DDBLT_KEYSRCOVERRIDE)
        {
            DBG_DD((3,"DDBLT_KEYSRCOVERRIDE"));

            // If the surface sizes don't match, then we are stretching.
            if (bStretched || bMirror)
            {
                PermediaStretchCopyChromaBlt(   ppdev, 
                                                lpBlt, 
                                                pPrivateDest, 
                                                pPrivateSource, 
                                                &rDest, 
                                                &rSrc, 
                                                dwWindowBase, 
                                                srcOffset);
            }
            else
            {
                PermediaSourceChromaBlt(    ppdev, 
                                            lpBlt, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &rSrc, 
                                            dwWindowBase, 
                                            srcOffset);
            }
            
            goto BltDone;
            
        }
        else
        { 
            // If the surface sizes don't match, then we are stretching.
            // Also the blits from Nonlocal- to Videomemory have to go through
            // the texture unit!
            if ( bStretched || bMirror || bNonLocalToVideo)
            {
                DBG_DD((3,"DDBLT_ROP: STRETCHCOPYBLT OR "
                          "MIRROR OR BOTH OR AGPVIDEO"));

                PermediaStretchCopyBlt( ppdev, 
                                        lpBlt, 
                                        pPrivateDest, 
                                        pPrivateSource, 
                                        &rDest, 
                                        &rSrc, 
                                        dwWindowBase, 
                                        srcOffset);
            }
            else
            {
                DBG_DD((3,"DDBLT_ROP:  COPYBLT %08lx %08lx %08lx",
                    pSrcGbl->fpVidMem,pDestGbl->fpVidMem,ulDestPixelShift));

                // Work out the source offset 
                // (offset in pixels from dst to src)
                srcOffset = (LONG)((pSrcGbl->fpVidMem - pDestGbl->fpVidMem) 
                    >> ulDestPixelShift);
                // For some reason, the user might want 
                // to do a conversion on the data as it is
                // blitted from VRAM->VRAM by turning on Patching. 
                // If Surf1Patch XOR Surf2Patch then
                // do a special blit that isn't packed and does patching.
                if (((pPrivateDest->dwFlags & P2_CANPATCH) ^ 
                     (pPrivateSource->dwFlags & P2_CANPATCH)) 
                       & P2_CANPATCH)
                {
                    DBG_DD((4,"Doing Patch-Conversion!"));

                    PermediaPatchedCopyBlt( ppdev, 
                                            lPixPitchDest, 
                                            lPixPitchSrc, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &rSrc, 
                                            dwWindowBase, 
                                            srcOffset);
                }
                else
                {
                    PermediaPackedCopyBlt( ppdev, 
                                           lPixPitchDest, 
                                           lPixPitchSrc, 
                                           pPrivateDest, 
                                           pPrivateSource, 
                                           &rDest, 
                                           &rSrc, 
                                           dwWindowBase, 
                                           srcOffset);
                }
            }
            goto BltDone;
        }

    }
    else if (pPrivateDest==NULL)
    {
        DBG_DD((0,"Private Surface data invalid!"));
        DUMPSURFACE(0, pDestLcl, NULL);
    } else if (dwFlags & DDBLT_COLORFILL)
    {
        DBG_DD((3,"DDBLT_COLORFILL: Color=0x%x", lpBlt->bltFX.dwFillColor));
        if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                    DDSCAPS2_TEXTUREMANAGE)
        {
            PermediaClearManagedSurface(pPrivateDest->SurfaceFormat.PixelSize,
                  &rDest, 
                  pDestGbl->fpVidMem, 
                  pDestGbl->lPitch,
                  lpBlt->bltFX.dwFillColor);
            pPrivateDest->dwFlags |= P2_SURFACE_NEEDUPDATE;
        }
        else
        {
            PermediaFastClear( ppdev, 
                           pPrivateDest, 
                           &rDest, 
                           dwWindowBase, 
                           lpBlt->bltFX.dwFillColor);
        }
    }
    else if (dwFlags & DDBLT_DEPTHFILL)
    {
        DBG_DD((3,"DDBLT_DEPTHFILL:  Value=0x%x", lpBlt->bltFX.dwFillColor));
        
        // Work out the window base for the LB clear, acount for the depth size
        dwWindowBase = (DWORD)((UINT_PTR)(pDestGbl->fpVidMem) 
            >> __PERMEDIA_16BITPIXEL);
        
        // Call the LB Solid Fill Function.
        PermediaFastLBClear( ppdev, 
                             pPrivateDest, 
                             &rDest, 
                             dwWindowBase, 
                             lpBlt->bltFX.dwFillColor);
    }
    else
    {
        DBG_DD((1,"DDraw:Blt:Blt case not supported %08lx", dwFlags));
        return DDHAL_DRIVER_NOTHANDLED;
    }
    
BltDone:
   
    lpBlt->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdBlt ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dd.h ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dd.h
*
* Content:     definitions and macros for DirectDraw
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/   

#ifndef _DD_H_
#define _DD_H_

extern DWORD ShiftLookup[];

// DirectDraw Macros for determining surface characteristics
#define DDSurf_Width(lpLcl) ( lpLcl->lpGbl->wWidth )
#define DDSurf_Height(lpLcl) ( lpLcl->lpGbl->wHeight )
#define DDSurf_Pitch(lpLcl) (lpLcl->lpGbl->lPitch)
#define DDSurf_Get_dwCaps(lpLcl) (lpLcl->ddsCaps.dwCaps)
#define DDSurf_BitDepth(lpLcl) (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount)
#define DDSurf_AlphaBitDepth(lpLcl) (lpLcl->lpGbl->ddpfSurface.dwAlphaBitDepth)
#define DDSurf_RGBAlphaBitMask(lpLcl) \
            (lpLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask)
#define DDSurf_GetPixelShift(a) (ShiftLookup[(DDSurf_BitDepth(a) >> 3)])

//
// DirectDraw callback functions implemented in this driver
//
DWORD CALLBACK DdCanCreateSurface( LPDDHAL_CANCREATESURFACEDATA pccsd );
DWORD CALLBACK DdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd );
DWORD CALLBACK DdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd );
DWORD CALLBACK DdBlt( LPDDHAL_BLTDATA lpBlt );
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
DWORD CALLBACK DdAlphaBlt( LPDDHAL_BLTDATA lpBlt );
#endif
//@@END_DDKSPLIT
DWORD CALLBACK DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);
DWORD CALLBACK DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);



//
// here are various blitter functions
//
VOID 
PermediaPackedCopyBlt (PPDev, 
                       DWORD, 
                       DWORD, 
                       PermediaSurfaceData*, 
                       PermediaSurfaceData*, 
                       RECTL*, 
                       RECTL*, 
                       DWORD, 
                       LONG);

VOID 
PermediaPatchedCopyBlt(PPDev, 
                       DWORD, 
                       DWORD, 
                       PermediaSurfaceData*, 
                       PermediaSurfaceData*, 
                       RECTL*, 
                       RECTL*, 
                       DWORD, 
                       LONG);

//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
VOID
PermediaSourceAlphaBlt(PPDev ppdev, 
                       LPDDHAL_BLTDATA lpBlt, 
                       PermediaSurfaceData* pDest, 
                       PermediaSurfaceData* pSource, 
                       RECTL *rDest, 
                       RECTL *rSrc, 
                       DWORD windowBase, 
                       DWORD SourceOffset,
                       ULONG ulDestPixelShift);

VOID
PermediaAlphaFill(PPDev ppdev, 
                  LPDDHAL_BLTDATA lpBlt, 
                  PermediaSurfaceData* pDest, 
                  RECTL *rDest, 
                  DWORD dwWindowBase, 
                  ULONG ulDestPixelShift);
#endif
//@@END_DDKSPLIT

// Clear functions
VOID PermediaFastClear(PPDev, PermediaSurfaceData*, 
                       RECTL*, DWORD, DWORD);
VOID PermediaClearManagedSurface(DWORD,RECTL*, 
                  FLATPTR,LONG,DWORD);
VOID PermediaFastLBClear(PPDev, PermediaSurfaceData*, 
                         RECTL*, DWORD, DWORD);

// FX Blits
VOID PermediaStretchCopyBlt(PPDev, LPDDHAL_BLTDATA, PermediaSurfaceData*, 
                            PermediaSurfaceData*, RECTL *, RECTL *, DWORD, 
                            DWORD);
VOID PermediaStretchCopyChromaBlt(PPDev, LPDDHAL_BLTDATA, PermediaSurfaceData*, 
                                  PermediaSurfaceData*, RECTL *, RECTL *,
                                  DWORD, DWORD);
VOID PermediaSourceChromaBlt(PPDev, LPDDHAL_BLTDATA, PermediaSurfaceData*, 
                             PermediaSurfaceData*, RECTL*, RECTL*, 
                             DWORD, DWORD);
VOID PermediaYUVtoRGB(PPDev, DDBLTFX*, PermediaSurfaceData*, 
                      PermediaSurfaceData*, RECTL*, RECTL*, DWORD, DWORD);

// SYSMEM->VIDMEM Blits
VOID PermediaPackedDownload(PPDev, PermediaSurfaceData* pPrivateData, 
                            LPDDRAWI_DDRAWSURFACE_LCL lpSourceSurf, 
                            RECTL* rSrc, 
                            LPDDRAWI_DDRAWSURFACE_LCL lpDestSurf, 
                            RECTL* rDest);

// Texture Downloads
VOID PermediaPatchedTextureDownload(PPDev, PermediaSurfaceData*,FLATPTR,
                                    LONG,RECTL*,FLATPTR,LONG,RECTL*);

// DX Utility functions.
//
HRESULT updateFlipStatus( PPDev ppdev );

// Sysmem->Sysmem Blit
VOID SysMemToSysMemSurfaceCopy(FLATPTR,LONG,DWORD,FLATPTR,
                               LONG,DWORD,RECTL*,RECTL*);

//
//  function to validate RGB format of a DirectDraw surface
//
BOOL ValidRGBAlphaSurfaceformat(DDPIXELFORMAT *pPixFormat, INT *pIndex);
BOOL SetRGBAlphaSurfaceFormat  (DDPIXELFORMAT *pPixFormat, 
                                PERMEDIA_SURFACE *pSurfaceFormat);
//
// Initialise DirectDraw structs
//

BOOL InitDDHAL(PPDev ppdev);

//
//  setup some DDraw data stored in ppdev
//
VOID SetupDDData(PPDev ppdev);
BOOL bIsStereoMode(PPDev ppdev,PDD_STEREOMODE pDDStereoMode);

// Useful macro
#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

// DD Blit helper defines.
#define PIXELS_INTO_RECT_PACKED(rect, PixelPitch, lPixelMask) \
((rect->top * PixelPitch) + \
(rect->left & ~lPixelMask))

#define RECTS_PIXEL_OFFSET(rS,rD,SourcePitch,DestPitch,Mask) \
(PIXELS_INTO_RECT_PACKED(rS, SourcePitch, Mask) - \
 PIXELS_INTO_RECT_PACKED(rD, DestPitch, Mask) )

#define LINEAR_FUDGE(SourcePitch, DestPitch, rectDest) \
((DestPitch - SourcePitch) * (rectDest->top))

//
//  check if privateData for primary surface was properly
//  initialized
//
#define DD_CHECK_PRIMARY_SURFACE_DATA( pLcl, pPrivate) \
    if ((pLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) ||\
        (pLcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER))\
    {\
        if (!CHECK_P2_SURFACEDATA_VALIDITY(pPrivate))\
        {\
            ASSERTDD(FALSE, "primary surface data not initialized");\
            /*SetupPrimarySurfaceData(ppdev, pLcl);*/\
            pPrivate = (PermediaSurfaceData*)pLcl->lpGbl->dwReserved1;\
        }\
    }\



//@@BEGIN_DDKSPLIT
#if MULTITHREADED
//
// Multithread wrapped DirectDraw callback functions implemented in this driver
//
DWORD CALLBACK MtDdBlt(LPDDHAL_BLTDATA lpBlt);
DWORD CALLBACK MtDdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd);
DWORD CALLBACK MtDdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd);
DWORD CALLBACK MtDdFlip(LPDDHAL_FLIPDATA lpFlipData);
DWORD CALLBACK MtDdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface);
DWORD CALLBACK MtDdGetFlipStatus(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD CALLBACK MtDdLock(LPDDHAL_LOCKDATA lpLockData);
DWORD CALLBACK MtDdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);

//
// Multithread wrapped Direct3D callback functions implemented in this driver
//
DWORD CALLBACK MtD3DDrawPrimitives2(LPD3DNTHAL_DRAWPRIMITIVES2DATA);
DWORD CALLBACK MtDdSetColorKey(LPDDHAL_SETCOLORKEYDATA lpSetColorKey);

#endif  MULTITHREADED
//@@END_DDKSPLIT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dddebug.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dddebug.c
*
* Content:     some DDraw and D3D debug output functions
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include <windef.h>
#include <limits.h>
#include <stdio.h>
#include <stdarg.h>

#if (DBG)

//-----------------------------------------------------------------------------
//
//  DecodeBlend
//
//  produce debug output for D3D blend modes
//
//-----------------------------------------------------------------------------

VOID 
DecodeBlend( LONG Level, DWORD i )
{
    switch ((D3DBLEND)i)
    {
    case D3DBLEND_ZERO:
        DISPDBG((Level, "  ZERO"));
        break;
    case D3DBLEND_ONE:
        DISPDBG((Level, "  ONE"));
        break;
    case D3DBLEND_SRCCOLOR:
        DISPDBG((Level, "  SRCCOLOR"));
        break;
    case D3DBLEND_INVSRCCOLOR:
        DISPDBG((Level, "  INVSRCCOLOR"));
        break;
    case D3DBLEND_SRCALPHA:
        DISPDBG((Level, "  SRCALPHA"));
        break;
    case D3DBLEND_INVSRCALPHA:
        DISPDBG((Level, "  INVSRCALPHA"));
        break;
    case D3DBLEND_DESTALPHA:
        DISPDBG((Level, "  DESTALPHA"));
        break;
    case D3DBLEND_INVDESTALPHA:
        DISPDBG((Level, "  INVDESTALPHA"));
        break;
    case D3DBLEND_DESTCOLOR:
        DISPDBG((Level, "  DESTCOLOR"));
        break;
    case D3DBLEND_INVDESTCOLOR:
        DISPDBG((Level, "  INVDESTCOLOR"));
        break;
    case D3DBLEND_SRCALPHASAT:
        DISPDBG((Level, "  SRCALPHASAT"));
        break;
    case D3DBLEND_BOTHSRCALPHA:
        DISPDBG((Level, "  BOTHSRCALPHA"));
        break;
    case D3DBLEND_BOTHINVSRCALPHA:
        DISPDBG((Level, "  BOTHINVSRCALPHA"));
        break;
    }
}  /* DecodeBlend */

// Surface dumping is turned on by setting DDDebugLevel 

LONG DDDebugLevel = 0;

//-----------------------------------------------------------------------------
//
//  DumpSurface
//
//  dump properties of a DirectDraw Surface
//
//-----------------------------------------------------------------------------

VOID 
DumpSurface(LONG Level, 
            LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, 
            LPDDSURFACEDESC lpDDSurfaceDesc)
{
    LPDDRAWI_DDRAWSURFACE_GBL psurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl;
    LPDDPIXELFORMAT pPixFormat;
    DDSCAPS ddsCaps;
    DDSCAPSEX ddsCapsEx;

    memset( &ddsCaps, 0, sizeof(ddsCaps));
    memset( &ddsCapsEx, 0, sizeof(ddsCapsEx));
    
    if (Level <= DDDebugLevel)
    {
        Level = 0;

        DBG_DD((Level,"  Surface Dump:"));
        
        if (lpDDSurfaceDesc != NULL)
        {
            pPixFormat = &lpDDSurfaceDesc->ddpfPixelFormat;
            ddsCaps = lpDDSurfaceDesc->ddsCaps;
            
            DBG_DD((Level,"    Surface Width:                      0x%x", 
                lpDDSurfaceDesc->dwWidth));
            DBG_DD((Level,"    Surface Height:                     0x%x", 
                lpDDSurfaceDesc->dwHeight));
            DBG_DD((Level,"    dwFlags:                            0x%x", 
                lpDDSurfaceDesc->dwFlags));
            
            DBG_DD((Level,"    DestOverlay: dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceLowValue));
            DBG_DD((Level,"    DestOverlay: dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceHighValue));
            DBG_DD((Level,"    DestBlt:     dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKDestBlt.dwColorSpaceLowValue));
            DBG_DD((Level,"    DestBlt:     dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKDestBlt.dwColorSpaceHighValue));
            DBG_DD((Level,"    SrcOverlay:  dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceLowValue));
            DBG_DD((Level,"    SrcOverlay:  dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceHighValue));
            DBG_DD((Level,"    SrcBlt:      dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKSrcBlt.dwColorSpaceLowValue));
            DBG_DD((Level,"    SrcBlt:      dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKSrcBlt.dwColorSpaceHighValue));
            
        }
        else if (lpDDSurface != NULL)
        {
            psurf_gbl = lpDDSurface->lpGbl;
            psurf_lcl = lpDDSurface;
            pPixFormat = &psurf_gbl->ddpfSurface;
            ddsCaps = psurf_lcl->ddsCaps;
            ddsCapsEx= psurf_lcl->lpSurfMore->ddsCapsEx;
            DBG_DD((Level,"    Surface Width:          0x%x", 
                psurf_gbl->wWidth));
            DBG_DD((Level,"    Surface Height:         0x%x", 
                psurf_gbl->wHeight));
            DBG_DD((Level,"    ddsCaps.dwCaps:         0x%x", 
                psurf_lcl->ddsCaps.dwCaps));
            DBG_DD((Level,"    dwFlags:                0x%x", 
                psurf_lcl->dwFlags));
        }
        DBG_DD((Level,"    dwFourCC:               0x%x", 
            pPixFormat->dwFourCC));
        DBG_DD((Level,"    dwRGBBitCount:          0x%x", 
            pPixFormat->dwRGBBitCount));
        DBG_DD((Level,"    dwR/Y BitMask:          0x%x", 
            pPixFormat->dwRBitMask));
        DBG_DD((Level,"    dwG/U BitMask:          0x%x", 
            pPixFormat->dwGBitMask));
        DBG_DD((Level,"    dwB/V BitMask:          0x%x", 
            pPixFormat->dwBBitMask));
        DBG_DD((Level,"    dwRGBAlphaBitMask:      0x%x", 
            pPixFormat->dwRGBAlphaBitMask));
        
        DBG_DD((Level,"  Surface Is:"));

        if (ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        {
            DBG_DD((Level,"   TEXTURE"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            DBG_DD((Level,"   SYSTEMMEMORY"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            DBG_DD((Level,"   VIDEOMEMORY"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            DBG_DD((Level,"   NONLOCALVIDMEM"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        {
            DBG_DD((Level,"   LOCALVIDMEM"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        {
            DBG_DD((Level,"   PRIMARYSURFACE"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
        {
            DBG_DD((Level,"   OFFSCREEN_PLAIN"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER)
        {
            DBG_DD((Level,"   FRONT_BUFFER"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_BACKBUFFER)
        {
            DBG_DD((Level,"   BACK_BUFFER"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_COMPLEX)
        {
            DBG_DD((Level,"   COMPLEX"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_FLIP)
        {
            DBG_DD((Level,"   FLIP"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_MODEX)
        {
            DBG_DD((Level,"   MODEX"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_ALLOCONLOAD)
        {
            DBG_DD((Level,"   ALLOCONLOAD"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
        {
            DBG_DD((Level,"   LIVEVIDEO"));
        }
        if (pPixFormat->dwFlags & DDPF_ZBUFFER)
        {
            DBG_DD((Level,"   Z BUFFER"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            DBG_DD((Level,"   ALPHAPIXELS"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            DBG_DD((Level,"   ALPHA"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHAPREMULT)
        {
            DBG_DD((Level,"   ALPHAPREMULT"));
        }
#if DX7_STEREO
        if (ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
        {
            DBG_DD((Level,"   STEREOSURFACELEFT"));
        }
#endif
    }
}   // DumpSurface 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\ddcpyblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddcpyblt.c
*
* Content:     several copy and clear blits for Permedia 2
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"

//-----------------------------------------------------------------------------
//
// PermediaPackedCopyBlt
//
// Does a packed blit, allowing for different source and destination
// partial products.
//
// ppdev----------- the ppdev
// dwDestPitch----- pitch of destination surface          
// dwSourcePitch--- pitch of source surface
// pDest----------- pointer to private data structure of dest. surface
// pSource--------- pointer to private data structure of source surface
// *rDest---------- dest. rectangle of blit
// *rSrc----------- source rectangle of blit
// dwWindowBase---- offset of dest. window in frame buffer  
// lWindowOffset--- offset of source window in frame buffer
//
//-----------------------------------------------------------------------------

VOID 
PermediaPackedCopyBlt(  PPDev ppdev,                    // ppdev
                        DWORD dwDestPitch,              // pitch of dest 
                        DWORD dwSourcePitch,
                        PermediaSurfaceData* pDest,
                        PermediaSurfaceData* pSource,
                        RECTL   *rDest,
                        RECTL   *rSrc,
                        DWORD   dwWindowBase,   
                        LONG    lWindowOffset
                        )
{
    PERMEDIA_DEFS(ppdev);

    LONG    lOffset;
    LONG    lSourceOffset;
   
    LONG    lPixelSize=pDest->SurfaceFormat.PixelSize;
    LONG    lPixelMask=3>>pDest->SurfaceFormat.PixelShift;
    LONG    lPixelShift=2-pDest->SurfaceFormat.PixelShift;
    
    DBG_DD(( 5, "DDraw:PermediaPackedCopyBlt "
        "From %08lx %08lx %08lx %08lx %08lx %08lx %08lx "
        "To   %08lx %08lx %08lx %08lx %08lx %08lx %08lx",
        dwSourcePitch,pSource,rSrc->bottom,rSrc->left,
        rSrc->right,rSrc->top,lWindowOffset,
        dwDestPitch,pDest,rDest->bottom,rDest->left,
        rDest->right,rDest->top,dwWindowBase));

    ASSERTDD(!(rSrc->top<0) && !(rSrc->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");
    ASSERTDD(!(rDest->top<0) && !(rDest->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");

    lOffset = (((rDest->left & lPixelMask)-(rSrc->left & lPixelMask)) & 7);
    lSourceOffset = lWindowOffset + 
                    RECTS_PIXEL_OFFSET(rSrc, rDest,
                                       dwSourcePitch, dwDestPitch, 
                                       lPixelMask ) + 
                    LINEAR_FUDGE(dwSourcePitch, dwDestPitch, rDest);
    
    RESERVEDMAPTR(14);

    SEND_PERMEDIA_DATA( FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    // set packed with offset
    SEND_PERMEDIA_DATA( FBWindowBase, dwWindowBase);

    SEND_PERMEDIA_DATA( FBReadMode,  
                        PM_FBREADMODE_PARTIAL(pSource->ulPackedPP) |
                        PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_RELATIVEOFFSET(lOffset));

    SEND_PERMEDIA_DATA( FBWriteConfig,   
                        PM_FBREADMODE_PARTIAL(pDest->ulPackedPP) |
                        PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_RELATIVEOFFSET(lOffset));

    SEND_PERMEDIA_DATA( LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA( FBSourceOffset, lSourceOffset);

    // Render the rectangle

    if (lSourceOffset >= 0) {
        // Use left to right and top to bottom
        SEND_PERMEDIA_DATA( StartXDom, 
            INTtoFIXED(rDest->left >> lPixelShift));
        SEND_PERMEDIA_DATA( StartXSub, 
            INTtoFIXED((rDest->right >> lPixelShift) + lPixelMask));
        SEND_PERMEDIA_DATA( PackedDataLimits,    
                            PM_PACKEDDATALIMITS_OFFSET(lOffset)      |
                            PM_PACKEDDATALIMITS_XSTART(rDest->left) |
                            PM_PACKEDDATALIMITS_XEND(rDest->right));
        SEND_PERMEDIA_DATA( StartY, INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA( dY, INTtoFIXED(1));
    }
    else {
        // Use right to left and bottom to top
        SEND_PERMEDIA_DATA( StartXDom, 
            INTtoFIXED(((rDest->right) >> lPixelShift) + lPixelMask));
        SEND_PERMEDIA_DATA( StartXSub, 
            INTtoFIXED(rDest->left >> lPixelShift));
        SEND_PERMEDIA_DATA( PackedDataLimits,    
                            PM_PACKEDDATALIMITS_OFFSET(lOffset)       |
                            PM_PACKEDDATALIMITS_XSTART(rDest->right) |
                            PM_PACKEDDATALIMITS_XEND(rDest->left));
        SEND_PERMEDIA_DATA( StartY, INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA( dY, (DWORD)INTtoFIXED(-1));
    }

    SEND_PERMEDIA_DATA( Count, rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA( Render, __RENDER_TRAPEZOID_PRIMITIVE);
    COMMITDMAPTR();
    FLUSHDMA();

}   //  PermediaPackedCopyBlt 

//-----------------------------------------------------------------------------
//
// PermediaPatchedCopyBlt
//
// Does a patched blit, i.e. blits from source to destination and
// turns on patching. Note that this method cannot use packed blits.
// 
// ppdev----------- the ppdev
// dwDestPitch----- pitch of destination surface          
// dwSourcePitch--- pitch of source surface
// pDest----------- pointer to private data structure of dest. surface
// pSource--------- pointer to private data structure of source surface
// *rDest---------- dest. rectangle of blit
// *rSrc----------- source rectangle of blit
// dwWindowBase---- offset of dest. window in frame buffer  
// lWindowOffset--- offset of source window in frame buffer
//
//-----------------------------------------------------------------------------

VOID 
PermediaPatchedCopyBlt( PPDev ppdev,
                        DWORD dwDestPitch,
                        DWORD dwSourcePitch,
                        PermediaSurfaceData* pDest,
                        PermediaSurfaceData* pSource,
                        RECTL *rDest,
                        RECTL *rSrc,
                        DWORD  dwWindowBase,
                        LONG   lWindowOffset
                        )
{
    PERMEDIA_DEFS(ppdev);

    LONG    lSourceOffset;
    LONG    lPixelSize=pDest->SurfaceFormat.PixelSize;
    LONG    lPixelMask=pDest->SurfaceFormat.PixelMask;
    LONG    lPixelShift=pDest->SurfaceFormat.PixelShift;

    ASSERTDD(!(rSrc->top<0) && !(rSrc->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");
    ASSERTDD(!(rDest->top<0) && !(rDest->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");

    DBG_DD(( 5, "DDraw:PermediaPatchedCopyBlt"));

    lSourceOffset = lWindowOffset + 
                    RECTS_PIXEL_OFFSET(rSrc, rDest,
                        dwSourcePitch, dwDestPitch, lPixelMask) +
                    LINEAR_FUDGE(dwSourcePitch, dwDestPitch, rDest);

    RESERVEDMAPTR(13);

    SEND_PERMEDIA_DATA( FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    // Patching isn't symetric, so we need to reverse the patch code depending
    // on the direction of the patch

    SEND_PERMEDIA_DATA( FBWindowBase, dwWindowBase);

    if (pDest->dwFlags & P2_CANPATCH) 
    {
        pDest->dwFlags |= P2_ISPATCHED;
        SEND_PERMEDIA_DATA( FBReadMode, 
                            pSource->ulPackedPP | 
                            __FB_READ_SOURCE);
        SEND_PERMEDIA_DATA( FBWriteConfig, 
                            pDest->ulPackedPP                 |
                            PM_FBREADMODE_PATCHENABLE(__PERMEDIA_ENABLE) |
                            PM_FBREADMODE_PATCHMODE(__PERMEDIA_SUBPATCH));
    } else 
    {
        pDest->dwFlags &= ~P2_ISPATCHED;
        SEND_PERMEDIA_DATA( FBReadMode, 
                            pSource->ulPackedPP               | 
                            __FB_READ_SOURCE                          |
                            PM_FBREADMODE_PATCHENABLE(__PERMEDIA_ENABLE) |
                            PM_FBREADMODE_PATCHMODE(__PERMEDIA_SUBPATCH) );
        SEND_PERMEDIA_DATA(FBWriteConfig, (pDest->ulPackedPP ));
    }

    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBSourceOffset, lSourceOffset);

    // Render the rectangle

    if (lSourceOffset >= 0) 
    {
        // Use left to right and top to bottom
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    } else 
    {
        // Use right to left and bottom to top
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY, (DWORD)INTtoFIXED(-1));
    }
 
    SEND_PERMEDIA_DATA(Count, rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE);
    COMMITDMAPTR();
    FLUSHDMA();

}   // PermediaPatchedCopyBlt 

//-----------------------------------------------------------------------------
//
// PermediaFastClear
//
// Does a fast clear of a surface. Supports all color depths
// Can clear depth or Frame buffer.
//
// ppdev---------the ppdev        
// pPrivateData--pointer to private data structure of dest. surface
// rDest---------rectangle for colorfill in dest. surface 
// dwWindowBase--offset of dest. surface in frame buffer
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
PermediaFastClear(PPDev ppdev, 
                  PermediaSurfaceData* pPrivateData,
                  RECTL *rDest, 
                  DWORD dwWindowBase, 
                  DWORD dwColor)
{
    PERMEDIA_DEFS(ppdev);

    ULONG   ulRenderBits;
    BOOL    bFastFill=TRUE;
    LONG    lPixelSize=pPrivateData->SurfaceFormat.PixelSize;
    

    DBG_DD(( 5, "DDraw:PermediaFastClear"));

    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData), 
        "Private Surface data not valid in clear");

    ASSERTDD((pPrivateData->dwFlags & P2_PPVALID),
        "PermediaFastClear called with invalid PP codes");

    ulRenderBits = __RENDER_FAST_FILL_ENABLE
                 | __RENDER_TRAPEZOID_PRIMITIVE;

    // Clear depending on depth
    switch (lPixelSize) 
    {
        case __PERMEDIA_4BITPIXEL:
            dwColor &= 0xF;
            dwColor |= dwColor << 4;
            // fall through...
        case __PERMEDIA_8BITPIXEL:
            dwColor &= 0xFF;
            dwColor |= dwColor << 8;
            // fall through
        case __PERMEDIA_16BITPIXEL:
            dwColor &= 0xFFFF;
            dwColor |= (dwColor << 16);
            break;

        case __PERMEDIA_24BITPIXEL:
            dwColor &= 0xFFFFFF;
            dwColor |= ((dwColor & 0xFF) << 24);
            // Can't use SGRAM fast block fills on any color, only on grey.
            if (((dwColor & 0xFF) == ((dwColor & 0xFF00) >> 8)) &&
                    ((dwColor & 0xFF) == ((dwColor & 0xFF0000) >> 16))) {
                bFastFill = TRUE;
            } else {
                bFastFill = FALSE;
            }
            break;

        default:
            break;
    }


    RESERVEDMAPTR(15);
    SEND_PERMEDIA_DATA( dXDom, 0x0);
    SEND_PERMEDIA_DATA( dXSub, 0x0);
    SEND_PERMEDIA_DATA( FBPixelOffset, 0);
    SEND_PERMEDIA_DATA( FBReadPixel, 
                        pPrivateData->SurfaceFormat.FBReadPixel);

    if (bFastFill) 
    {
        SEND_PERMEDIA_DATA(FBBlockColor, dwColor);
    } else 
    {
        ulRenderBits &= ~__RENDER_FAST_FILL_ENABLE;
        SEND_PERMEDIA_DATA(FBWriteData, dwColor);
    }

    SEND_PERMEDIA_DATA(FBReadMode,    
                       PM_FBREADMODE_PARTIAL(pPrivateData->ulPackedPP)|
                       PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE));

    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_CONSTANT_FB_WRITE);
    SEND_PERMEDIA_DATA(FBWindowBase,  dwWindowBase);

    // Render the rectangle

    SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
    SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
    SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
    SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);

    SEND_PERMEDIA_DATA(Render, ulRenderBits);

    // Reset our pixel values.
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    COMMITDMAPTR();
    FLUSHDMA();

}   //PermediaFastClear

//-----------------------------------------------------------------------------
//
// PermediaClearManagedSurface
//
// Does a clear of a managed surface. Supports all color depths
//
// PixelSize-----surface color depth
// rDest---------rectangle for colorfill in dest. surface 
// fpVidMem------pointer to fill
// lPitch--------Surface Pitch
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
PermediaClearManagedSurface(DWORD   PixelSize,
                  RECTL     *rDest, 
                  FLATPTR   fpVidMem, 
                  LONG      lPitch,
                  DWORD     dwColor)
{
    BYTE* pDestStart;
    LONG i;
    DBG_DD(( 5, "DDraw:PermediaClearManagedSurface"));

    LONG lByteWidth = rDest->right - rDest->left;
    LONG lHeight = rDest->bottom - rDest->top;

    // Calculate the start pointer for the dest
    pDestStart   = (BYTE*)(fpVidMem + (rDest->top * lPitch));
    // Clear depending on depth
    switch (PixelSize) 
    {
        case __PERMEDIA_4BITPIXEL:
        {
            DWORD   right=rDest->right,left=rDest->left;
            dwColor &= 0x0F;
            dwColor |= dwColor << 4;
            if (right & 1)
            {
                pDestStart = (BYTE*)(fpVidMem + (rDest->top * lPitch));
                pDestStart += right/2;
                for (i=0;i<lHeight;i++)
                {
                    pDestStart[i*lPitch] = (pDestStart[i*lPitch] & 0xF0) |
                        (BYTE)(dwColor & 0x0F);
                }   
                right--;
            }

            if (left & 1)
            {
                pDestStart = (BYTE*)(fpVidMem + (rDest->top * lPitch));
                pDestStart += left/2;
                for (i=0;i<lHeight;i++)
                {
                    pDestStart[i*lPitch] = (pDestStart[i*lPitch] & 0x0F) |
                        (BYTE)(dwColor << 4);
                }   
                left++;
            }
            pDestStart = (BYTE*)(fpVidMem + (rDest->top * lPitch));
            while (--lHeight >= 0) 
            {
                while (left<right)
                {
                    pDestStart[left/2]=(BYTE)dwColor;
                    left +=2;
                }
                pDestStart += lPitch;
            }
        }
        break;
        case __PERMEDIA_8BITPIXEL:
            pDestStart += rDest->left;
            while (--lHeight >= 0) 
            {
                for (i=0;i<lByteWidth;i++)
                    pDestStart[i]=(BYTE)dwColor;
                pDestStart += lPitch;
            }
            break;
            // fall through
        case __PERMEDIA_16BITPIXEL:
            pDestStart += rDest->left*2;
            while (--lHeight >= 0) 
            {
                LPWORD  lpWord=(LPWORD)pDestStart;
                for (i=0;i<lByteWidth;i++)
                    lpWord[i]=(WORD)dwColor;
                pDestStart += lPitch;
            }
            break;

        case __PERMEDIA_24BITPIXEL:
            dwColor &= 0xFFFFFF;
            dwColor |= ((dwColor & 0xFF) << 24);
        default:
            pDestStart += rDest->left*4;
            while (--lHeight >= 0) 
            {
                LPDWORD lpDWord=(LPDWORD)pDestStart;
                for (i=0;i<lByteWidth;i++)
                    lpDWord[i]=(WORD)dwColor;
                pDestStart += lPitch;
            }
            break;
    }
}
//-----------------------------------------------------------------------------
//
// PermediaFastLBClear
//
// Does a fast clear of the Permedia Z (local) Buffer. The Permedia Z Buffer
// is always 16 bit wide...
//
// ppdev---------the ppdev        
// pPrivateData--pointer to private data structure of dest. surface
// rDest---------rectangle for colorfill in dest. surface 
// dwWindowBase--offset of dest. surface in frame buffer
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
PermediaFastLBClear(PPDev ppdev,
                    PermediaSurfaceData* pPrivateData,
                    RECTL *rDest,
                    DWORD dwWindowBase,
                    DWORD dwColor)
{
    PERMEDIA_DEFS(ppdev);
    
    DBG_DD(( 5, "DDraw:PermediaFastLBClear"));
    
    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData), 
                "Private Surface data not valid in clear");
    ASSERTDD((pPrivateData->dwFlags & P2_PPVALID),
        "PermediaFastClear called with invalid PP codes");
    
    // Clear according to Z-Buffer depth
    dwColor &= 0xFFFF;
    dwColor |= dwColor << 16;
    
    RESERVEDMAPTR(15);
    SEND_PERMEDIA_DATA( dXDom, 0x0);
    SEND_PERMEDIA_DATA( dXSub, 0x0);
    SEND_PERMEDIA_DATA( FBPixelOffset, 0);
    SEND_PERMEDIA_DATA( FBReadPixel, __PERMEDIA_16BITPIXEL);    
    SEND_PERMEDIA_DATA( FBBlockColor, dwColor);
    SEND_PERMEDIA_DATA( FBReadMode,    
                        PM_FBREADMODE_PARTIAL(pPrivateData->ulPackedPP) |
                        PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE));
    SEND_PERMEDIA_DATA( LogicalOpMode, __PERMEDIA_CONSTANT_FB_WRITE);
    SEND_PERMEDIA_DATA( FBWindowBase, dwWindowBase);
    SEND_PERMEDIA_DATA( StartXDom, INTtoFIXED(rDest->left));
    SEND_PERMEDIA_DATA( StartXSub, INTtoFIXED(rDest->right));
    SEND_PERMEDIA_DATA( StartY,    INTtoFIXED(rDest->top));
    SEND_PERMEDIA_DATA( dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA( Count,     rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA( Render,    __RENDER_FAST_FILL_ENABLE
                                  |__RENDER_TRAPEZOID_PRIMITIVE);

    // Reset our pixel values.
    SEND_PERMEDIA_DATA( LogicalOpMode, __PERMEDIA_DISABLE);

    COMMITDMAPTR();
    FLUSHDMA();
    
}   // PermediaFastLBClear 

//-----------------------------------------------------------------------------
//
// SysMemToSysMemSurfaceCopy
//
// Does a copy from System memory to System memory (either from or to an
// AGP surface, or any other system memory surface)
//
//-----------------------------------------------------------------------------

VOID 
SysMemToSysMemSurfaceCopy(FLATPTR     fpSrcVidMem,
                          LONG        lSrcPitch,
                          DWORD       dwSrcBitCount,
                          FLATPTR     fpDstVidMem,
                          LONG        lDstPitch, 
                          DWORD       dwDstBitCount,
                          RECTL*      rSource,
                          RECTL*      rDest)
{
    BYTE* pSourceStart;
    BYTE* pDestStart;
    BYTE  pixSource;
    BYTE* pNewDest;
    BYTE* pNewSource;

    DBG_DD(( 5, "DDraw:SysMemToSysMemSurfaceCopy"));

    LONG lByteWidth = rSource->right - rSource->left;
    LONG lHeight = rSource->bottom - rSource->top;
    if (NULL == fpSrcVidMem || NULL == fpDstVidMem)
    {
        DBG_DD(( 0, "DDraw:SysMemToSysMemSurfaceCopy unexpected 0 fpVidMem"));
        return;
    }
    // Calculate the start pointer for the source and the dest
    pSourceStart = (BYTE*)(fpSrcVidMem + (rSource->top * lSrcPitch));
    pDestStart   = (BYTE*)(fpDstVidMem + (rDest->top * lDstPitch));

    // Be careful if the source is 4 bits deep.
    if(4 == dwSrcBitCount)
    {
        // May have to handle horrible single pixel edges.  Check if we need to
        if (!((1 & (rSource->left ^ rDest->left)) == 1))
        {
            pSourceStart += rSource->left / 2;
            pDestStart += rDest->left / 2;
            lByteWidth /= 2;

            // Do we have to account for the odd pixel at the start?
            if (rSource->left & 0x1) 
            {
                    lByteWidth--;
            }

            // If the end is odd then miss of the last nibble (do it later).
            if (rSource->right & 0x1) 
            {
                    lByteWidth--;
            }

            while (--lHeight >= 0) 
            {
                // Potentially copy the left hand pixel
                if (rSource->left & 0x1) {
                    *pDestStart &= 0x0F;
                    *pDestStart |= (*pSourceStart & 0xF0);

                    pNewDest = pDestStart + 1;
                    pNewSource = pSourceStart + 1;
                } else {
                    pNewDest = pDestStart;
                    pNewSource = pSourceStart;
                }

                // Byte copy the rest of the field
                memcpy(pNewDest, pNewSource, lByteWidth);

                // Potentially copy the right hand pixel
                if (rSource->right & 0x1) {
                    *(pNewDest + lByteWidth) &= 0xF0;
                    *(pNewDest + lByteWidth) |= 
                        (*(pNewSource + lByteWidth) & 0xF);
                }

                pDestStart += lDstPitch;
                pSourceStart += lSrcPitch;
            }

        } else 
        {
            // Do it the hard way - copy single pixels one at a time

            pSourceStart += rSource->left / 2;
            pDestStart += rDest->left / 2;

            while (--lHeight >= 0) 
            {
                BOOL bOddSource = rSource->left & 0x1;
                BOOL bOddDest = rDest->left & 0x1;

                pNewDest = pDestStart;
                pNewSource = pSourceStart;

                for (INT i = 0; i < lByteWidth; i++) 
                {
                    if (bOddSource) {
                        pixSource = (*pNewSource & 0xF0) >> 4;
                        pNewSource++;
                    } else {
                        pixSource = (*pNewSource & 0x0F);
                    }

                    if (bOddDest) {
                        *pNewDest &= 0x0F;
                        *pNewDest |= pixSource << 4;
                        pNewDest++;
                    } else {
                        *pNewDest &= 0xF0;
                        *pNewDest |= pixSource;
                    }

                    bOddSource = !bOddSource;
                    bOddDest = !bOddDest;
                }

                // Step onto the next line
                pDestStart += lDstPitch;
                pSourceStart += lSrcPitch;
            }
        }
    }
    else // The simple 8, 16 or 24 bit copy
    {
        pSourceStart += rSource->left * (dwSrcBitCount >> 3);
        pDestStart += rDest->left * (dwDstBitCount >> 3);
        lByteWidth *= (dwSrcBitCount >> 3);

        while (--lHeight >= 0) 
        {
            memcpy(pDestStart, pSourceStart, lByteWidth);
            pDestStart += lDstPitch;
            pSourceStart += lSrcPitch;
        };
    }

}   // SysMemToSysMemSurfaceCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\ddstrblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddstrblt.c
*
* Content:    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#include "precomp.h"
#include "directx.h"
#include "dd.h"



//--------------------------------------------------------------------------
//
//  ConvertColorKeys
//
//  converts a color key to the Permedia internal format according to 
//  the given Permedia surface format
//
//--------------------------------------------------------------------------

VOID
ConvertColorKeys(PermediaSurfaceData *pSurface,
                 DWORD &dwLowerBound, 
                 DWORD &dwUpperBound)
{
    switch (pSurface->SurfaceFormat.Format)
    {
        case PERMEDIA_444_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_4444_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_4444_32BIT_BGR(dwUpperBound));
            break;
        case PERMEDIA_332_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_332_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_332_32BIT_BGR(dwUpperBound));
            break;
        case PERMEDIA_2321_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_2321_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_2321_32BIT_BGR(dwUpperBound));
            break;
        case PERMEDIA_4BIT_PALETTEINDEX:
        case PERMEDIA_8BIT_PALETTEINDEX:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_PALETTE_32BIT(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_PALETTE_32BIT(dwUpperBound));
            break;
        case PERMEDIA_5551_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_5551_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_5551_32BIT_BGR(dwUpperBound));
            dwLowerBound = dwLowerBound & 0xF8F8F8F8;   
            dwUpperBound = dwUpperBound | 0x07070707;
            break;
        case PERMEDIA_8888_RGB:
            // The permedia 565 mode is an extension, so don't confuse it with 
            // the 8888 mode which has the same number
            if (pSurface->SurfaceFormat.FormatExtension == 
                PERMEDIA_565_RGB_EXTENSION)
            {
                dwLowerBound = CHROMA_LOWER_ALPHA(
                    FORMAT_565_32BIT_BGR(dwLowerBound));
                dwUpperBound = CHROMA_UPPER_ALPHA(
                    FORMAT_565_32BIT_BGR(dwUpperBound));
                dwLowerBound = dwLowerBound & 0xF8F8FcF8; 
                dwUpperBound = dwUpperBound | 0x07070307;
            }
            else
            {
                dwLowerBound = CHROMA_LOWER_ALPHA(
                    FORMAT_8888_32BIT_BGR(dwLowerBound));
                dwUpperBound = CHROMA_UPPER_ALPHA(
                    FORMAT_8888_32BIT_BGR(dwUpperBound));
            }
            break;
        case PERMEDIA_888_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_8888_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_8888_32BIT_BGR(dwUpperBound));
            break;
    }

    // swap blue and red if we have a RGB surface
    if (!pSurface->SurfaceFormat.ColorOrder)
    {
        dwLowerBound = SWAP_BR(dwLowerBound);   
        dwUpperBound = SWAP_BR(dwUpperBound);   
    }
}

//--------------------------------------------------------------------------
//
// PermediaStretchCopyBlt
//
// stretched blt through texture unit. no keying.
// handle mirroring if the stretched image requires it.
//
//--------------------------------------------------------------------------

VOID 
PermediaStretchCopyBlt( PPDev ppdev, 
                        LPDDHAL_BLTDATA lpBlt, 
                        PermediaSurfaceData* pDest, 
                        PermediaSurfaceData* pSource, 
                        RECTL *rDest, 
                        RECTL *rSrc, 
                        DWORD dwWindowBase, 
                        DWORD dwSourceOffset
                        )
{
    LONG lXScale;
    LONG lYScale;
    BOOL bYMirror=FALSE;
    BOOL bXMirror=FALSE;
    LONG lPixelSize=pDest->SurfaceFormat.PixelSize;

    DWORD dwDestWidth = rDest->right - rDest->left;
    DWORD dwDestHeight = rDest->bottom - rDest->top;
    DWORD dwSourceWidth = rSrc->right - rSrc->left;
    DWORD dwSourceHeight = rSrc->bottom - rSrc->top;

    DWORD dwTexSStart, dwTexTStart;
    DWORD dwRenderDirection;

    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 5, "DDraw:PermediaStretchCopyBlt dwWindowBase=%08lx "
        "dwSourceOffset=%08lx", dwWindowBase, dwSourceOffset));

    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");

    lXScale = (dwSourceWidth << 20) / dwDestWidth;
    lYScale = (dwSourceHeight << 20) / dwDestHeight;
    
    // Changes pixel depth to Dest buffer pixel depth if neccessary.
    RESERVEDMAPTR(28);

    SEND_PERMEDIA_DATA( FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    if (lPixelSize != 0)
    {
        // set writeback to dest surface...
        SEND_PERMEDIA_DATA( DitherMode,  
                            (pDest->SurfaceFormat.ColorOrder << 
                                PM_DITHERMODE_COLORORDER) | 
                            (pDest->SurfaceFormat.Format << 
                                PM_DITHERMODE_COLORFORMAT) |
                            (pDest->SurfaceFormat.FormatExtension << 
                                PM_DITHERMODE_COLORFORMATEXTENSION) |
                            (__PERMEDIA_ENABLE << PM_DITHERMODE_ENABLE)); 

    } 

    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);

    // set no read of dest.
    SEND_PERMEDIA_DATA(FBReadMode, pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    SEND_PERMEDIA_DATA(TextureColorMode,  (1 << PM_TEXCOLORMODE_ENABLE) |
                                          (_P2_TEXTURE_COPY << 
                                                PM_TEXCOLORMODE_APPLICATION));

    SEND_PERMEDIA_DATA(TextureReadMode,
                        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE)|
                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE)|
                        PM_TEXREADMODE_WIDTH(11) |
                        PM_TEXREADMODE_HEIGHT(11) );

    // set source bitmap format
    SEND_PERMEDIA_DATA(TextureDataFormat, 
                        (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                        (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                        (pSource->SurfaceFormat.ColorOrder << 
                            PM_TEXDATAFORMAT_COLORORDER));
    SEND_PERMEDIA_DATA(TextureMapFormat, (pSource->ulPackedPP) | 
                                         (pSource->SurfaceFormat.PixelSize << 
                                            PM_TEXMAPFORMAT_TEXELSIZE) );

    // If we are doing special effects, and we are mirroring, 
    // we need to fix up the rectangles and change the sense of 
    // the render operation - we need to be carefull with overlapping
    // rectangles
    if (dwWindowBase != dwSourceOffset)
    {
        dwRenderDirection = 1;
    }
    else
    {
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else if(rSrc->left < rDest->left)
        {
            dwRenderDirection = 0;
        }
        else dwRenderDirection = 1;
    }

    if(NULL != lpBlt && lpBlt->dwFlags & DDBLT_DDFX)
    {
        bYMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN;
        bXMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT;

    } else
    {
        if (dwRenderDirection==0)
        {
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    if (bXMirror)        
    {
        dwTexSStart = rSrc->right - 1;
        lXScale = -lXScale;
    }   
    else
    {
        dwTexSStart = rSrc->left;
    }

    if (bYMirror)        
    {
        dwTexTStart = rSrc->bottom - 1;
        lYScale = -lYScale;
    }
    else
    {
        dwTexTStart = rSrc->top;
    }

    SEND_PERMEDIA_DATA(SStart,      dwTexSStart << 20);
    SEND_PERMEDIA_DATA(TStart,      dwTexTStart << 20);
    SEND_PERMEDIA_DATA(dSdx,        lXScale);
    SEND_PERMEDIA_DATA(dSdyDom,     0);
    SEND_PERMEDIA_DATA(dTdx,        0);
    SEND_PERMEDIA_DATA(dTdyDom,     lYScale);
    
    // Render the rectangle

    if (dwRenderDirection)
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }
    else
    {
        // Render right to left, bottom to top
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY,        (DWORD)INTtoFIXED(-1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }

    SEND_PERMEDIA_DATA(DitherMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    COMMITDMAPTR();
    FLUSHDMA();

}   // PermediaStretchCopyBlt 

//--------------------------------------------------------------------------
//
// PermediaSourceChromaBlt
//
// Does a blit through the texture unit to allow chroma keying.
// Note the unpacking of the colour key to fit into the Permedia format.
//
//--------------------------------------------------------------------------

VOID 
PermediaSourceChromaBlt(    PPDev ppdev, 
                            LPDDHAL_BLTDATA lpBlt, 
                            PermediaSurfaceData* pDest, 
                            PermediaSurfaceData* pSource, 
                            RECTL *rDest, 
                            RECTL *rSrc, 
                            DWORD dwWindowBase, 
                            DWORD dwSourceOffset
                            )
{
    DWORD dwLowerBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
    DWORD dwUpperBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue;
    DWORD dwRenderDirection;
    LONG lPixelSize=pDest->SurfaceFormat.PixelSize;

    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 5, "DDraw:PermediaSourceChromaBlt"));

    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");

    // Changes pixel depth to Frame buffer pixel depth if neccessary.

    ConvertColorKeys( pSource, dwLowerBound, dwUpperBound);

    RESERVEDMAPTR(31);

    SEND_PERMEDIA_DATA(FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    if (lPixelSize != 0)
    {
        
        // set writeback to dest surface...
        SEND_PERMEDIA_DATA( DitherMode,
                            (pDest->SurfaceFormat.ColorOrder << 
                                PM_DITHERMODE_COLORORDER) | 
                            (pDest->SurfaceFormat.Format << 
                                PM_DITHERMODE_COLORFORMAT) |
                            (pDest->SurfaceFormat.FormatExtension << 
                                PM_DITHERMODE_COLORFORMATEXTENSION) |
                            (1 << PM_DITHERMODE_ENABLE)); 
        
    } 

    
    // Reject range
    SEND_PERMEDIA_DATA(YUVMode, PM_YUVMODE_CHROMATEST_FAILWITHIN << 1);
    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);

    // set no read of source.
    // add read src/dest enable
    SEND_PERMEDIA_DATA(FBReadMode,pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    //
    // modulate & ramp??
    SEND_PERMEDIA_DATA(TextureColorMode, (1 << PM_TEXCOLORMODE_ENABLE) |
                                         (_P2_TEXTURE_COPY << 
                                            PM_TEXCOLORMODE_APPLICATION));

    SEND_PERMEDIA_DATA(TextureReadMode, 
                       PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                       PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                       PM_TEXREADMODE_WIDTH(11) |
                       PM_TEXREADMODE_HEIGHT(11) );

    SEND_PERMEDIA_DATA(TextureDataFormat,   
                       (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                       (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                       (pSource->SurfaceFormat.ColorOrder << 
                            PM_TEXDATAFORMAT_COLORORDER));

    SEND_PERMEDIA_DATA( TextureMapFormat, 
                        (pSource->ulPackedPP) | 
                        (pSource->SurfaceFormat.PixelSize << 
                            PM_TEXMAPFORMAT_TEXELSIZE) );


    SEND_PERMEDIA_DATA(ChromaLowerBound, dwLowerBound);
    SEND_PERMEDIA_DATA(ChromaUpperBound, dwUpperBound);
    
    if ((lpBlt->lpDDDestSurface->lpGbl->fpVidMem) != 
        (lpBlt->lpDDSrcSurface->lpGbl->fpVidMem))
    {
        dwRenderDirection = 1;
    }
    else
    {
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else if(rSrc->left < rDest->left)
        {
            dwRenderDirection = 0;
        }
        else dwRenderDirection = 1;
    }

    /*
     * Render the rectangle
     */

    // Left -> right, top->bottom
    if (dwRenderDirection)
    {
        // set offset of source
        SEND_PERMEDIA_DATA(SStart,    rSrc->left<<20);
        SEND_PERMEDIA_DATA(TStart,    rSrc->top<<20);
        SEND_PERMEDIA_DATA(dSdx,      1 << 20);
        SEND_PERMEDIA_DATA(dSdyDom,   0);
        SEND_PERMEDIA_DATA(dTdx,      0);
        SEND_PERMEDIA_DATA(dTdyDom,   1 << 20);

        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }
    else
    // right->left, bottom->top
    {
        // set offset of source
        SEND_PERMEDIA_DATA(SStart,    rSrc->right << 20);
        SEND_PERMEDIA_DATA(TStart,    (rSrc->bottom - 1) << 20);
        SEND_PERMEDIA_DATA(dSdx,      (DWORD)(-1 << 20));
        SEND_PERMEDIA_DATA(dSdyDom,   0);
        SEND_PERMEDIA_DATA(dTdx,      0);
        SEND_PERMEDIA_DATA(dTdyDom,   (DWORD)(-1 << 20));

        // Render right to left, bottom to top
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY,        (DWORD)INTtoFIXED(-1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }


    // Turn off chroma key
    SEND_PERMEDIA_DATA(YUVMode, 0x0);

    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    if (pSource->SurfaceFormat.PixelSize != 0)
    {   
        SEND_PERMEDIA_DATA(DitherMode, 0);
    }

    COMMITDMAPTR();
    FLUSHDMA();

}   // PermediaSourceChromaBlt 

//--------------------------------------------------------------------------
//
// PermediaStretchCopyChromaBlt
//
// Does a blit through the texture unit to allow stretching.  Also
// handle mirroring and chroma keying if the stretched image requires it.
//
//--------------------------------------------------------------------------

VOID 
PermediaStretchCopyChromaBlt(   PPDev ppdev, 
                                LPDDHAL_BLTDATA lpBlt, 
                                PermediaSurfaceData* pDest, 
                                PermediaSurfaceData* pSource, 
                                RECTL *rDest, 
                                RECTL *rSrc, 
                                DWORD dwWindowBase, 
                                DWORD dwSourceOffset
                                )
{
    LONG lXScale;
    LONG lYScale;
    BOOL bYMirror;
    BOOL bXMirror;
    DWORD dwDestWidth = rDest->right - rDest->left;
    DWORD dwDestHeight = rDest->bottom - rDest->top;
    DWORD dwSourceWidth = rSrc->right - rSrc->left;
    DWORD dwSourceHeight = rSrc->bottom - rSrc->top;
    DWORD dwTexSStart, dwTexTStart;
    DWORD dwRenderDirection;
    LONG lPixelSize=pDest->SurfaceFormat.PixelSize;

    DWORD dwLowerBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
    DWORD dwUpperBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue;
    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 5, "DDraw:PermediaStretchCopyChromaBlt"));

    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");

    // Changes pixel depth to Frame buffer pixel depth if neccessary.

    ConvertColorKeys( pSource, dwLowerBound, dwUpperBound);

    RESERVEDMAPTR(31);

    SEND_PERMEDIA_DATA(FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    if (lPixelSize != 0)
    {

        // set writeback to dest surface...
        SEND_PERMEDIA_DATA( DitherMode,  
                            (pDest->SurfaceFormat.ColorOrder << 
                                PM_DITHERMODE_COLORORDER) | 
                            (pDest->SurfaceFormat.Format << 
                                PM_DITHERMODE_COLORFORMAT) |
                            (pDest->SurfaceFormat.FormatExtension << 
                                PM_DITHERMODE_COLORFORMATEXTENSION) |
                            (1 << PM_DITHERMODE_ENABLE)); 

    } 

    // Reject range
    SEND_PERMEDIA_DATA(YUVMode, PM_YUVMODE_CHROMATEST_FAILWITHIN <<1);
    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);

    // set no read of source.
    SEND_PERMEDIA_DATA(FBReadMode, pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    
    SEND_PERMEDIA_DATA( TextureColorMode,
                        (1 << PM_TEXCOLORMODE_ENABLE) |
                        (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION));

    SEND_PERMEDIA_DATA( TextureReadMode, 
                        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                        PM_TEXREADMODE_WIDTH(11) |
                        PM_TEXREADMODE_HEIGHT(11));

    lXScale = (dwSourceWidth << 20) / (dwDestWidth);
    lYScale = (dwSourceHeight << 20) / (dwDestHeight);

    SEND_PERMEDIA_DATA( TextureDataFormat,
                        (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                        (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                        (pSource->SurfaceFormat.ColorOrder << 
                            PM_TEXDATAFORMAT_COLORORDER));

    SEND_PERMEDIA_DATA( TextureMapFormat, 
                        (pSource->ulPackedPP) | 
                        (pSource->SurfaceFormat.PixelSize << 
                            PM_TEXMAPFORMAT_TEXELSIZE) );

    bYMirror = FALSE;
    bXMirror = FALSE;

    if ((lpBlt->lpDDDestSurface->lpGbl->fpVidMem) != 
        (lpBlt->lpDDSrcSurface->lpGbl->fpVidMem))
    {
        dwRenderDirection = 1;
    }
    else
    {
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else if(rSrc->left < rDest->left)
        {
            dwRenderDirection = 0;
        }
        else dwRenderDirection = 1;
    }

    if(lpBlt->dwFlags & DDBLT_DDFX)
    {
        bYMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN;
        bXMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT;

    } else
    {
        if (dwRenderDirection==0)
        {
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    if (bXMirror)        
    {
        dwTexSStart = rSrc->right - 1;
        lXScale = -lXScale;
    }   
    else
    {
        dwTexSStart = rSrc->left;
    }

    if (bYMirror)        
    {
        dwTexTStart = rSrc->bottom - 1;
        lYScale = -lYScale;
    }
    else
    {
        dwTexTStart = rSrc->top;
    }

    SEND_PERMEDIA_DATA(dTdyDom, lYScale);
    SEND_PERMEDIA_DATA(ChromaLowerBound, dwLowerBound);
    SEND_PERMEDIA_DATA(ChromaUpperBound, dwUpperBound);

    // set texture coordinates
    SEND_PERMEDIA_DATA(SStart,      dwTexSStart << 20);
    SEND_PERMEDIA_DATA(TStart,      dwTexTStart << 20);
    SEND_PERMEDIA_DATA(dSdx,        lXScale);
    SEND_PERMEDIA_DATA(dSdyDom,     0);
    SEND_PERMEDIA_DATA(dTdx,        0);

    //
    // Render the rectangle
    //

    if (dwRenderDirection)
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    }
    else
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY,        (DWORD)INTtoFIXED(-1));
    }

    SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                  __RENDER_TEXTURED_PRIMITIVE);


    // Turn off units
    SEND_PERMEDIA_DATA(YUVMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    if (pSource->SurfaceFormat.PixelSize != 0)
    {
        SEND_PERMEDIA_DATA(DitherMode, 0);
    }

    COMMITDMAPTR();
    FLUSHDMA();

} // PermediaStretchCopyChromaBlt 

//--------------------------------------------------------------------------
//
// PermediaYUVtoRGB
//
// Permedia2 YUV to RGB conversion blt
//
//--------------------------------------------------------------------------


VOID 
PermediaYUVtoRGB(   PPDev ppdev, 
                    DDBLTFX* lpBltFX, 
                    PermediaSurfaceData* pDest, 
                    PermediaSurfaceData* pSource, 
                    RECTL *rDest, 
                    RECTL *rSrc, 
                    DWORD dwWindowBase, 
                    DWORD dwSourceOffset)
{
    DWORD lXScale;
    DWORD lYScale;
    DWORD dwDestWidth = rDest->right - rDest->left;
    DWORD dwDestHeight = rDest->bottom - rDest->top;
    DWORD dwSourceWidth = rSrc->right - rSrc->left;
    DWORD dwSourceHeight = rSrc->bottom - rSrc->top;
    PERMEDIA_DEFS(ppdev);
    
    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");
    
    lXScale = (dwSourceWidth << 20) / dwDestWidth;
    lYScale = (dwSourceHeight << 20) / dwDestHeight;
    
    // Changes pixel depth to Frame buffer pixel depth if neccessary.
    
    RESERVEDMAPTR(29);

    SEND_PERMEDIA_DATA(FBReadPixel,ppdev->bPixShift);
    
    if (pDest->SurfaceFormat.PixelSize != __PERMEDIA_8BITPIXEL)
    {
        SEND_PERMEDIA_DATA(DitherMode, 
            (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
            (pDest->SurfaceFormat.Format << PM_DITHERMODE_COLORFORMAT) |
            (pDest->SurfaceFormat.FormatExtension << 
                PM_DITHERMODE_COLORFORMATEXTENSION) |
            (1 << PM_DITHERMODE_ENABLE) |
            (1 << PM_DITHERMODE_DITHERENABLE));
    }
    
    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);
    
    // set no read of source.
    SEND_PERMEDIA_DATA(FBReadMode, pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    
    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    
    SEND_PERMEDIA_DATA( TextureColorMode,
                        (1 << PM_TEXCOLORMODE_ENABLE) |
                        (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION));
    
    SEND_PERMEDIA_DATA( TextureReadMode, 
                        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                        PM_TEXREADMODE_FILTER(__PERMEDIA_ENABLE) |
                        PM_TEXREADMODE_WIDTH(11) |
                        PM_TEXREADMODE_HEIGHT(11) );
    
    SEND_PERMEDIA_DATA( TextureDataFormat, 
                        (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                        (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                        (INV_COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER));
    
    SEND_PERMEDIA_DATA( TextureMapFormat,    
                        (pSource->ulPackedPP) | 
                        (pSource->SurfaceFormat.PixelSize << 
                            PM_TEXMAPFORMAT_TEXELSIZE) );
    
    // Turn on the YUV unit
    SEND_PERMEDIA_DATA(YUVMode, 0x1);
    
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);
    
    // set offset of source
    SEND_PERMEDIA_DATA(SStart,    rSrc->left << 20);
    SEND_PERMEDIA_DATA(TStart,    rSrc->top << 20);
    SEND_PERMEDIA_DATA(dSdx,      lXScale);
    SEND_PERMEDIA_DATA(dSdyDom,   0);
    SEND_PERMEDIA_DATA(dTdx,      0);
    SEND_PERMEDIA_DATA(dTdyDom, lYScale);
    
    
    // Render the rectangle
    //
    SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
    SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
    SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
    SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                  __RENDER_TEXTURED_PRIMITIVE);
    
    if (pSource->SurfaceFormat.PixelSize != __PERMEDIA_8BITPIXEL)
    {
        SEND_PERMEDIA_DATA(DitherMode, 0);
    }
    
    // Turn off units
    SEND_PERMEDIA_DATA(YUVMode, 0x0);
    SEND_PERMEDIA_DATA( TextureAddressMode,
                        (0 << PM_TEXADDRESSMODE_ENABLE));
    SEND_PERMEDIA_DATA( TextureColorMode,    
                        (0 << PM_TEXCOLORMODE_ENABLE));
    COMMITDMAPTR();
    FLUSHDMA();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\ddldblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddldblt.c
*
* Content:     DirectDraw System to Videomemory download routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"

typedef struct tagSHORTDWORD 
{
    BYTE Red;
    BYTE Green;
    BYTE Blue;
} SHORTDWORD, *LPSHORTDWORD;

//-----------------------------------------------------------------------------
//
// PermediaPatchedTextureDownload
//
// Do a texture download to the linear region of memory. Access to textures
// is faster if they are stored as "patched". This function downloads a texture
// from system to videomemory and rearranges the data in the patched format.
//
// ppdev---------the PPDev
// pPrivateDest--DDraw private surface data for the dest. surface
// fpSrcVidMem---linear pointer to source systemmemory surface
// lSrcPitch-----pitch of source surface
// rSrc----------source rectangle
// fpDstVidMem---offset in videomemory of dest surface
// lDstPitch-----pitch of dest. surface
// rDest---------destination rectangle
//
//-----------------------------------------------------------------------------

VOID 
PermediaPatchedTextureDownload (PPDev ppdev, 
                                PermediaSurfaceData* pPrivateDest, 
                                FLATPTR     fpSrcVidMem,
                                LONG        lSrcPitch,
                                RECTL*      rSrc, 
                                FLATPTR     fpDstVidMem,
                                LONG        lDstPitch,
                                RECTL*      rDest)
{
    PERMEDIA_DEFS(ppdev);

    ULONG ulTextureBase = (ULONG)(fpDstVidMem);
    LONG  lWidth = rDest->right - rDest->left;
    LONG  lLines = rDest->bottom - rDest->top;

    DBG_DD((5,"DDraw:PermediaPatchedTextureDownload:, PrivateDest: 0x%x",
                pPrivateDest));

    if (NULL == fpSrcVidMem)
    {
        DBG_DD(( 0, "DDraw:PermediaPatchedTextureDownload"
            " unexpected NULL = fpSrcVidMem"));
        return;
    }
    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateDest),
             "Blt32: Destination Private Data not valid!");

    DBG_DD((6,"  Texture Base: 0x%x DstPitch=0x%x", 
                ulTextureBase, lDstPitch));
    DBG_DD((6,"  Source Base: 0x%x SourcePitch: 0x%x", 
                fpSrcVidMem,lSrcPitch));
    DBG_DD((6,"  rSource->left: 0x%x, rSource->right: 0x%x", 
                rSrc->left,rSrc->right));
    DBG_DD((6,"  rSource->top: 0x%x, rSource->bottom: 0x%x\n", 
                rSrc->top, rSrc->bottom));
    DBG_DD((6,"  rDest->left: 0x%x, rDest->right: 0x%x", 
                rDest->left,rDest->right));
    DBG_DD((6,"  rDest->top: 0x%x, rDest->bottom: 0x%x\n", 
                rDest->top, rDest->bottom));

    //
    //  define some handy variables
    //
    
    LONG lPixelSize=pPrivateDest->SurfaceFormat.PixelSize;

    RESERVEDMAPTR(18);

    SEND_PERMEDIA_DATA( ColorDDAMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA( AlphaBlendMode,      __PERMEDIA_DISABLE);                
    SEND_PERMEDIA_DATA( Window, PM_WINDOW_DISABLELBUPDATE(__PERMEDIA_ENABLE));
    SEND_PERMEDIA_DATA( dXDom, 0x0);
    SEND_PERMEDIA_DATA( dXSub, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pPrivateDest->SurfaceFormat.FBReadPixel);
 
    switch (lPixelSize)
    {
    case __PERMEDIA_4BITPIXEL:
        // There are half as many 8-bit, 4-bit texels
        DBG_DD((6,"  Texture is 4-Bit indexed"));
        lWidth >>= 1;
        SEND_PERMEDIA_DATA(DitherMode, 0);
        break;
    case __PERMEDIA_8BITPIXEL: 
        DBG_DD((6,"  Texture is 8-Bit indexed"));
        SEND_PERMEDIA_DATA(DitherMode, 0);
        break;
    default:
        if (lPixelSize != __PERMEDIA_24BITPIXEL) {
            DBG_DD((6,"  Texture is BGR"));
            ulTextureBase >>= lPixelSize;
        } else {
            DBG_DD((6,"  Texture is 24-Bit BGR"));
            ulTextureBase /= 3;
        }
        // Setup the Dither unit
        SEND_PERMEDIA_DATA(DitherMode,( 
                (INV_COLOR_MODE << PM_DITHERMODE_COLORORDER)|
                (1 << PM_DITHERMODE_ENABLE)                 |
                (pPrivateDest->SurfaceFormat.Format << 
                    PM_DITHERMODE_COLORFORMAT) |
                (pPrivateDest->SurfaceFormat.FormatExtension << 
                    PM_DITHERMODE_COLORFORMATEXTENSION) ));
        break;
    }

    DBG_DD((6,"  Partial Products: 0x%x", pPrivateDest->ulPackedPP));
    DBG_DD((6,"  Texture Width: 0x%x, Downloaded as: 0x%x", 
                (rDest->right - rDest->left),lWidth));
    DBG_DD((6,"  Texture Height: 0x%x", rDest->bottom - rDest->top));
    DBG_DD((6,"  PixelSize: 0x%x", pPrivateDest->SurfaceFormat.PixelSize));
    DBG_DD((6,"  Format: 0x%x", pPrivateDest->SurfaceFormat.Format));
    DBG_DD((6,"  Format Extension: 0x%x", 
                 pPrivateDest->SurfaceFormat.FormatExtension));

    // Downloading a texture, disable texture colour mode.
    SEND_PERMEDIA_DATA(TextureColorMode,    (0 << PM_TEXCOLORMODE_ENABLE));
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);

    //
    //  all textures get by default marked as P2_CANPATCH,
    //  except 4 bit paletted textures
    //
    if (pPrivateDest->dwFlags & P2_CANPATCH) {

        // Mark the texture as being patched.
        pPrivateDest->dwFlags |= P2_ISPATCHED;

        // set up partial product and patch
        SEND_PERMEDIA_DATA(FBReadMode,  
                PM_FBREADMODE_PARTIAL(pPrivateDest->ulPackedPP) |
                PM_FBREADMODE_PATCHENABLE(__PERMEDIA_ENABLE) |
                PM_FBREADMODE_PATCHMODE(__PERMEDIA_SUBPATCH) );

    } else {

        // This texture isn't patched
        pPrivateDest->dwFlags &= ~P2_ISPATCHED;

        // Load up the partial products of the texture, don't use patching
        SEND_PERMEDIA_DATA(FBReadMode, 
                PM_FBREADMODE_PARTIAL(pPrivateDest->ulPackedPP));
    }

    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    SEND_PERMEDIA_DATA(FBWindowBase, ulTextureBase);

    // Use left to right and top to bottom
    if (lWidth == 2048)
    {
        // special case for 2048-wide textures because of the precision
        // of the StartXSub register
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(-1));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(lWidth-1));
    }
    else
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(0));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(lWidth));
    }
    SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(0));
    SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,     (lLines));
    SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE |
                                  __RENDER_SYNC_ON_HOST_DATA);
    COMMITDMAPTR();

    switch (lPixelSize) {

    case __PERMEDIA_4BITPIXEL:
    case __PERMEDIA_8BITPIXEL:
    {
        BYTE* pTextureData = (BYTE*)fpSrcVidMem;

        //
        //  download texture data line by line
        //
        while(lLines-- > 0)
        {
            LONG lWords=lWidth;
            BYTE *pData=pTextureData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pData++);
            }

            COMMITDMAPTR();

            //
            //  force flush only every couple of lines
            //
            if ((lLines & 3)==0)
            {
                FLUSHDMA();
            }

            pTextureData += lSrcPitch;
        }
    }
    break;

    case __PERMEDIA_16BITPIXEL:
    {
        BYTE* pTextureData  = (BYTE*)fpSrcVidMem;

        if (pPrivateDest->SurfaceFormat.RedMask == 0x7c00)
        {
            DBG_DD((6,"  Texture is BGR, 16 bit 5:5:5:1"));

            //
            //  download texture data line by line
            //
            while(lLines-- > 0)
            {
                LONG lWords=lWidth;
                WORD *pData=(WORD*)pTextureData;

                RESERVEDMAWORDS(lWords+1);

                LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                        ((lWords-1) << 16));

                while (lWords--)
                {
                    LD_INPUT_FIFO_DATA(FORMAT_5551_32BIT((DWORD)*pData));
                    pData++;
                }

                COMMITDMAPTR();

                //
                //  force flush only every couple of lines
                //
                if ((lLines & 3)==0)
                {
                    FLUSHDMA();
                }

                pTextureData += lSrcPitch;
            }
        }
        else if(pPrivateDest->SurfaceFormat.RedMask == 0xF00)
        {
            DBG_DD((6,"  Texture is BGR, 16 bit 4:4:4:4"));
            //
            //  download texture data line by line
            //
            while(lLines-- > 0)
            {
                LONG lWords=lWidth;
                WORD *pData=(WORD*)pTextureData;

                RESERVEDMAWORDS(lWords+1);

                LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                    ((lWords-1) << 16));

                while (lWords--)
                {
                    LD_INPUT_FIFO_DATA(FORMAT_4444_32BIT((DWORD)*pData));
                    pData++;
                }

                COMMITDMAPTR();

                //
                //  force flush only every couple of lines
                //
                if ((lLines & 3)==0)
                {
                    FLUSHDMA();
                }

                pTextureData += lSrcPitch;
            }
        }
        else
        {
            DBG_DD((6,"  Texture is BGR, 16 bit 5:6:5"));
            //
            //  download texture data line by line
            //
            while(lLines-- > 0)
            {
                LONG lWords=lWidth;
                WORD *pData=(WORD*)pTextureData;

                RESERVEDMAWORDS(lWords+1);

                LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                    ((lWords-1) << 16));

                while (lWords--)
                {
                    LD_INPUT_FIFO_DATA(FORMAT_565_32BIT((DWORD)*pData));
                    pData++;
                }

                COMMITDMAPTR();

                //
                //  force flush only every couple of lines
                //
                if ((lLines & 3)==0)
                {
                    FLUSHDMA();
                }

                pTextureData += lSrcPitch;
            }
        }
    }
    break;

    case __PERMEDIA_24BITPIXEL:
    case __PERMEDIA_32BITPIXEL:
    {
        BYTE* pTextureData  = (BYTE*)fpSrcVidMem;
        //
        //  download texture data line by line
        //
        while(lLines-- > 0)
        {
            LONG lWords=lWidth;
            ULONG *pData=(ULONG*)pTextureData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pData++);
            }

            COMMITDMAPTR();

            //
            //  force flush only every couple of lines
            //
            if ((lLines & 3)==0)
            {
                FLUSHDMA();
            }

            pTextureData += lSrcPitch;
        }
    }
    break;

    }

    RESERVEDMAPTR(2);
    SEND_PERMEDIA_DATA(DitherMode, 0);
    SEND_PERMEDIA_DATA(WaitForCompletion, 0);
    COMMITDMAPTR();

} // PermediaPatchedTextureDownload 


//-----------------------------------------------------------------------------
//
// PermediaPackedDownload
//
// Function to do a system to video memory blt.
// Uses the packed bit on Permedia to do the packing for us. Needs
// to setup the offset bit for alignment and doesn't need to adjust
// the partial products. The calling function guarantees that the
// source and destination rects have the same size.
// 
//
// ppdev----------the PPDev 
// pPrivateDst----Permedia Surface data for destination
// lpSourceSurf---DDraw LCL for source surface 
// rSrc-----------source rect
// lpDestSurf-----DDraw LCL for destination surface
// rDest----------dest rect
//
//-----------------------------------------------------------------------------

VOID
PermediaPackedDownload(PPDev ppdev, 
                       PermediaSurfaceData* pPrivateDst, 
                       LPDDRAWI_DDRAWSURFACE_LCL lpSourceSurf, 
                       RECTL* rSrc, 
                       LPDDRAWI_DDRAWSURFACE_LCL lpDestSurf, 
                       RECTL* rDst)
{
    PERMEDIA_DEFS(ppdev);

    LONG  lDstOffset;           // dest offset in packed coordinates
    LONG  lSrcOffset;           // source offset in buffer in bytes
    LONG  lDstLeft, lDstRight;  // left and right dst in packed coordiantes
    LONG  lSrcLeft, lSrcRight;  // left and right src in packed coordiantes
    LONG  lPackedWidth;         // packed width to download
    LONG  lPixelMask;           // mask for pixels per packed DWORD
    LONG  lOffset;              // relative offset between src and dest 
    LONG  lPixelShift;          // handy helper var which contains pixel 
                                // shift from packed to surface format
    LONG  lPixelSize;           // just a helper
    LONG  lExtraDword;          // chip needs extra dummy 
                                // DWORD passed at end of line

    DBG_DD((5,"DDraw:PermediaPackedDownload, PrivateDst: 0x%x",
                pPrivateDst));

    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateDst), 
                "Blt: Destination Private Data not valid!");
    ASSERTDD((rSrc->right-rSrc->left)==(rDst->right-rDst->left),
                "PermediaPackedDownload: src and dest rect width not equal");
    ASSERTDD((rSrc->bottom-rSrc->top)==(rDst->bottom-rDst->top),
                "PermediaPackedDownload: src and dest rect height not equal");

    // get a handy variable for pixel shifts, masks and size
    lPixelSize=pPrivateDst->SurfaceFormat.PixelSize;
    lPixelMask=pPrivateDst->SurfaceFormat.PixelMask;
    lPixelShift=pPrivateDst->SurfaceFormat.PixelShift;

    // offset in dst buffer adjusted to packed format
    lDstOffset =(LONG)((UINT_PTR)(lpDestSurf->lpGbl->fpVidMem) >> lPixelShift);

    // calculate offset in source buffer adjusted to packed format
    lSrcOffset = ((rSrc->left & ~lPixelMask) << lPixelShift) + 
                  (rSrc->top * lpSourceSurf->lpGbl->lPitch);

    // Calculate the relative offset within the dword packed dimensions
    lOffset = ((rDst->left & lPixelMask) - 
               (rSrc->left & lPixelMask)) & 0x7;

    // set up the left and right end of the unpacked source data
    lDstLeft  = rDst->left;
    lDstRight = rDst->right;

    // precalc packed width for 32 bit case
    lPackedWidth = lDstRight-lDstLeft;
    lExtraDword=0;

    if (lPixelSize != __PERMEDIA_32BITPIXEL) 
    {
        // we need to check both source and dest
        // if they have different alignments
        LONG lSrcLeft2  = rSrc->left;
        LONG lSrcRight2 = rSrc->right;

        // Set up the relative offset to allow us to download packed word
        // and byte aligned data.
        if (lPixelSize == __PERMEDIA_4BITPIXEL) 
        {
            lDstLeft >>= 3;
            lSrcLeft2 >>= 3;
            lDstRight = (lDstRight + 7) >> 3;
            lSrcRight2 = (lSrcRight2 + 7) >> 3;
        }
        else 
        if (lPixelSize == __PERMEDIA_8BITPIXEL) 
        {
            lDstLeft >>= 2;
            lSrcLeft2 >>= 2;
            lDstRight = (lDstRight + 3) >> 2;
            lSrcRight2 = (lSrcRight2 + 3) >> 2;
        }
        else 
        {
            lDstLeft >>= 1;
            lSrcLeft2 >>= 1;
            lDstRight = (lDstRight + 1) >> 1;
            lSrcRight2 = (lSrcRight2 + 1) >> 1;
        }

        if ((lSrcRight2-lSrcLeft2) < (lDstRight-lDstLeft))
        {
            lExtraDword=1;
            lPackedWidth = lDstRight-lDstLeft;
        } else
        {
            lPackedWidth = lSrcRight2-lSrcLeft2;
        }
    } 

    RESERVEDMAPTR(12);
    SEND_PERMEDIA_DATA(FBReadPixel, pPrivateDst->SurfaceFormat.FBReadPixel);

    // No logical ops in SYS->VIDMEM Blits
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);

    // Load up the partial products of image
    SEND_PERMEDIA_DATA(FBReadMode, (pPrivateDst->ulPackedPP) |
                                   PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)|
                                   PM_FBREADMODE_RELATIVEOFFSET(lOffset) );

    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    SEND_PERMEDIA_DATA(FBWindowBase,  lDstOffset);

    // Use left to right and top to bottom
    SEND_PERMEDIA_DATA(StartXDom,       INTtoFIXED(lDstLeft));
    SEND_PERMEDIA_DATA(StartXSub,       INTtoFIXED(lDstLeft+lPackedWidth));
    SEND_PERMEDIA_DATA(PackedDataLimits,PM_PACKEDDATALIMITS_OFFSET(lOffset) | 
                                        (rDst->left << 16) | 
                                         rDst->right);
    SEND_PERMEDIA_DATA(StartY,          INTtoFIXED(rDst->top));
    SEND_PERMEDIA_DATA(dY,              INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,           (rDst->bottom - rDst->top));
    SEND_PERMEDIA_DATA(Render,          __RENDER_TRAPEZOID_PRIMITIVE | 
                                        __RENDER_SYNC_ON_HOST_DATA);
    COMMITDMAPTR();

    //
    // introduce some more handy pointers and LONGs
    //
    BYTE *pSurfaceData = (BYTE *)lpSourceSurf->lpGbl->fpVidMem + lSrcOffset;
    LONG lPitch =lpSourceSurf->lpGbl->lPitch;
    LONG lHeight=rDst->bottom - rDst->top;

    //
    // pump the whole thing in one huge block 
    // if the pitch and linewidth are the same and no extra treatment
    // for the buffer end is necessary
    //
    if ((lExtraDword==0) &&
        (lPackedWidth*(LONG)sizeof(ULONG))==lPitch)
    {
        vBlockLoadInputFifo( pP2dma, 
                             __Permedia2TagColor, 
                             (ULONG*)pSurfaceData, 
                             lPackedWidth*lHeight);
    } else
    {
        //
        //  lExtraDword is zero or 1, depends if we have to do a special
        //  treatment after this while block
        //
        while (lHeight>lExtraDword)
        {
            LONG lWords=lPackedWidth;
            ULONG *pImage=(ULONG*)pSurfaceData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pImage++);
            }

            COMMITDMAPTR();

            //
            //  force flush only every couple of lines
            //
            if ((lHeight & 3)==0)
            {
                FLUSHDMA();
            }

            pSurfaceData += lPitch;
            lHeight--;
        }

        //
        // treat last line separately, because we could read over the
        // end of buffer here if the source and dest rects are aligned
        // differently. lHeight will only be one here if lExtraDword==1
        //
        if (lHeight==1)
        {
            LONG lWords=lPackedWidth-1;
            ULONG *pImage=(ULONG*)pSurfaceData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pImage++);
            }

            COMMITDMAPTR();

            //
            // send extra dummy DWORD
            //
            RESERVEDMAPTR(1);
            SEND_PERMEDIA_DATA( Color, 0);
            COMMITDMAPTR();

        }

        FLUSHDMA();
    }
} // PermediaPackedDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\ddenable.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddenable.c
*
* Content:    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"


//-----------------------------------------------------------------------------
//
//  SetDdPixelFormat
//
//  fill a DDPIXELFORMAT structure based with the current mode info
//
//-----------------------------------------------------------------------------

VOID 
SetDdPixelFormat(PPDev  ppdev,
                 LPDDPIXELFORMAT pdpf )
{
    pdpf->dwSize = sizeof( DDPIXELFORMAT );
    pdpf->dwFourCC = 0;
    
    pdpf->dwFlags = DDPF_RGB;
    
    pdpf->dwRBitMask = ppdev->flRed;
    pdpf->dwGBitMask = ppdev->flGreen;
    pdpf->dwBBitMask = ppdev->flBlue;
    
    // Calculate some bitdepth dependent stuff
    switch (ppdev->iBitmapFormat)
    {
    case BMF_8BPP:
        pdpf->dwRGBAlphaBitMask = 0;
        pdpf->dwRGBBitCount=8;
        pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
        break;
        
    case BMF_16BPP:
        pdpf->dwRGBBitCount=16;
        switch(ppdev->flRed)
        {
        case 0x7C00:
            pdpf->dwRGBAlphaBitMask = 0x8000L;
            break;
        default:
            pdpf->dwRGBAlphaBitMask = 0x0L;
        }
        break;
    case BMF_24BPP:
        pdpf->dwRGBAlphaBitMask = 0x00000000L;
        pdpf->dwRGBBitCount=24;
        break;
    case BMF_32BPP:
        pdpf->dwRGBAlphaBitMask = 0xff000000L;
        pdpf->dwRGBBitCount=32;
        break;
    default:
        ASSERTDD(FALSE,"trying to build unknown pixelformat");
        break;
            
    }
} // buildPixelFormat 

//-----------------------------------------------------------------------------
//
//  SetupDDData
//
//  Called to fill in DirectDraw specific information in the ppdev.
//
//-----------------------------------------------------------------------------

VOID
SetupDDData(PPDev ppdev)
{

    DBG_DD((7, "SetupDDData"));
    
    SetDdPixelFormat(ppdev, &ppdev->ddpfDisplay);
    

    //
    // Setup the display size information
    // cxMemory = Pixels across for one scanline 
    //      (not necessarily the same as the screen width)
    // cyMemory = Scanline height of the memory
    //
    ppdev->cxMemory = ppdev->cxScreen; 
    ppdev->cyMemory = ppdev->FrameBufferLength / 
                     (ppdev->cxScreen <<  ppdev->bPixShift);

    // reset some DDraw specific vars
    ppdev->bDdStereoMode=FALSE;
    ppdev->dwNewDDSurfaceOffset=0xffffffff;
    
    // Reset the GART copies.
    ppdev->dwGARTLin = 0;
    ppdev->dwGARTDev = 0;

}//  SetupDDData()



//-----------------------------------------------------------------------------
//
// DrvEnableDirectDraw
//
// This function is called by GDI at start of day or after a mode switch
// to enable DirectDraw 
//
//-----------------------------------------------------------------------------

BOOL 
DrvEnableDirectDraw(DHPDEV                  dhpdev,
                    DD_CALLBACKS*           pCallBacks,
                    DD_SURFACECALLBACKS*    pSurfaceCallBacks,
                    DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PPDev ppdev = (PDev*)dhpdev;
    
    DBG_DD((7,"DrvEnableDirectDraw called"));

    ppdev->pDDContext = P2AllocateNewContext(ppdev, 
                                             (PULONG)P2DisableAllUnits, 
                                             0, 
                                             P2CtxtUserFunc);

    if ( ppdev->pDDContext == NULL )
    {
        DBG_DD((0, "DrvEnableDirectDraw: ERROR: "
                    "failed to allocate DDRAW context"));
        
        //
        // Since we have already got the ppdev->pvmList, pointer to video memory
        // heap list, in DrvGetDirectDrawInfo(), we better NULL it out here.
        // The reason is that we can't enable DirectDraw. So the system won't
        // initialize the DDRAW heap manager for us. Then we won't be able to
        // use the video memory heap at all.
        //
        ppdev->pvmList = NULL;

        return(FALSE);
    }

    DBG_DD((7,"  Created DD Register context: 0x%p", ppdev->pDDContext));

    //
    //  setup some DirectDraw/D3D specific data in ppdev
    //

    SetupDDData(ppdev);

    InitDDHAL(ppdev);
    
    //
    // Fill in the function pointers at start of day.  
    // We copy these from the Initialisation done in InitDDHAL32Bit.
    //
    memcpy(pCallBacks, &ppdev->DDHALCallbacks, sizeof(DD_CALLBACKS));
    memcpy(pSurfaceCallBacks, &ppdev->DDSurfCallbacks, 
        sizeof(DD_SURFACECALLBACKS));
    
    return(TRUE);
} // DrvEnableDirectDraw()

//-----------------------------------------------------------------------------
//
//  DrvDisableDirectDraw
//
//  This function is called by GDI at end of day or after a mode switch
//
//-----------------------------------------------------------------------------

VOID 
DrvDisableDirectDraw( DHPDEV dhpdev)
{
    PPDev ppdev;
    
    DBG_DD((0, "DrvDisableDirectDraw(%lx)", dhpdev));
    
    ppdev = (PDev*) dhpdev;

    P2FreeContext (ppdev, ppdev->pDDContext);
    ppdev->pDDContext = NULL;
    ppdev->pvmList = NULL;

    MEMTRACKERDEBUGCHK();

    DBG_DD((3,"  freed Register context: 0x%x", ppdev->pDDContext));
}   /* DrvDisableDirectDraw */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\debug.c ===
/******************************Module*Header***********************************\
*
*                           ****************
*                           *  SAMPLE CODE *
*                           ****************
*
* Module Name: debug.cpp
*
* Content:     Miscellaneous Driver Debug Routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "log.h"

LONG DebugLevel = 0;            // Set to '100' to debug initialization code
                                // (the default is '0')
DWORD DebugPrintFilter = 0;
DWORD DebugFilter = 0;


#define ALLOC_TAG ALLOC_TAG_ED2P
//------------------------------------------------------------------------------
//
//  VOID DebugPrint
//
//  Variable-argument level-sensitive debug print routine.
//
//  If the specified debug level for the print statement is lower or equal
//  to the current debug level, the message will be printed.
//
//  Parameters
//   DebugPrintLevel----Specifies at which debugging level the string should
//                      be printed
//   DebugMessage-------Variable argument ascii c string
//
//------------------------------------------------------------------------------

VOID
DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);

    if ( ((DebugPrintFilter & DebugFilter) && 
          (DebugPrintLevel <= DebugLevel ))    ||
         DebugPrintLevel <= 0                   )     
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

} // DebugPrint()


#if DBG

//------------------------------------------------------------------------------
//
//  VOID vDumpSurfobj
//
//  Dumps using DSPDBG usefull information about the given surface
//
//  Parameters
//   pso------------surface to dump
//
//------------------------------------------------------------------------------

void
vDumpSurfobj(SURFOBJ*   pso)
{
    ULONG   * bits;
    PPDev     ppdev;

    if(pso != NULL)
    {
        ULONG   width;
        ULONG   height;
        ULONG   stride;

        ppdev = (PPDev) pso->dhpdev;

        if(pso->dhsurf == NULL)
        {
            bits = (ULONG *) pso->pvScan0;
            width = pso->sizlBitmap.cx;
            height = pso->sizlBitmap.cy;
            stride = pso->lDelta;

            DISPDBG((0, "GDI managed surface %lx", pso));
        }
        else
        {
            Surf * surf = (Surf *) pso->dhsurf;
        
            if(surf->flags & SF_SM)
            {
                bits = (ULONG *) surf->pvScan0;
                DISPDBG((0, "device managed SM surface %lx", pso));
            }
            else
            {
                bits = (ULONG *) (ppdev->pjScreen + surf->ulByteOffset);
                DISPDBG((0, "device managed VM surface %lx", pso));
            }

            width = surf->cx;
            height = surf->cy;
            stride = surf->lDelta;
        }

        DISPDBG((0, "width %d height %d", width, height ));
        DISPDBG((0, "bits 0x%lx bits[0] 0x%lx stride %ld", bits, bits[0], stride));
    }
}

//------------------------------------------------------------------------------
//
//  VOID vDumpRect
//
//  Dumps the rectangle description using DISPDBG
//
//  Parameters
//   prcl-----------rectangle to dump
//
//------------------------------------------------------------------------------

void
vDumpRect(RECTL * prcl)
{
    if(prcl != NULL)
        DISPDBG((0, "left %d top %d width %d height %d",
                        prcl->left, prcl->top,
                        prcl->right - prcl->left,
                        prcl->bottom - prcl->top));
}

//------------------------------------------------------------------------------
//
//  VOID vDumpSurfobj
//
//  Dumps the point description using DISPDBG
//
//  Parameters
//   point----------point to dump
//
//------------------------------------------------------------------------------

void
vDumpPoint(POINTL * point)
{
    if(point != NULL)
        DISPDBG((0, "left %d top %d", point->x, point->y));
}


//------------------------------------------------------------------------------
//
// DEBUGGING INITIALIZATION CODE
//
// When you're bringing up your display for the first time, you can
// recompile with 'DebugLevel' set to 100.  That will cause absolutely
// all DISPDBG messages to be displayed on the kernel debugger (this
// is known as the "PrintF Approach to Debugging" and is about the only
// viable method for debugging driver initialization code).
//
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// THUNK_LAYER
//
// By Setting THUNK_LAYER equal to 1 you are adding a wrapper call on top of
// all DDI rendering functions.  In this thunk layer of wrapper calls
// several usefull debugging features are enabled.
//
// Surface checks--which can help catch errant rendering routines
// Event logging---which can record rendering evernts to a log file
//
//------------------------------------------------------------------------------

#if THUNK_LAYER

//------------------------------------------------------------------------------
//
// BOOL bSurfaceChecks
//
// By dynamically setting bSurfaceChecks  (via debugger) you can turn
// surface checking on and off.  Surface checking is usefull for catching 
// errant rendering operations overwritting other surfaces other then the
// destination surface.
//
//------------------------------------------------------------------------------

BOOL    bSurfaceChecks = 0;

//------------------------------------------------------------------------------
//
//  ULONG ulCalcSurfaceChecksum
//
//  Calculates a checksum for the given surface
//
//  Parameters
//   psurf----Surf to be used for checksum
//
//  Retuns checksum for given surface as a ULONG
//
//------------------------------------------------------------------------------

ULONG
ulCalcSurfaceChecksum(Surf* psurf)
{
    ULONG     ulChecksum = 0;

    if( psurf->dt == DT_VM )
    {
        //
        // Get the real memory address of this psurf
        //
        ULONG*  ulp = (ULONG*)(psurf->ppdev->pjScreen + psurf->ulByteOffset);

        //
        // Get total bytes allocated in this psurf. Here >> 2 is to make
        // 4 bytes as a unit so that we can use it to do checksum
        //
        ULONG   ulCount = (psurf->lDelta * psurf->cy) >> 2;

        //
        // Sum up the contents of all the bytes we allocated
        //
        while( ulCount-- )
        {
            ulChecksum += *ulp++;
        }
    }
    
    return ulChecksum;
}// vCalcSurfaceChecksum()

//------------------------------------------------------------------------------
//
//  VOID vCalcSurfaceChecksums
//
//  Calculates and stores all surface checksums except for the given destination
//  surface.
//
//  Parameters
//   psoDst---destination SURFOBJ
//   psoSrc---source SURFOBJ
//
//------------------------------------------------------------------------------

VOID
vCalcSurfaceChecksums(SURFOBJ * psoDst, SURFOBJ * psoSrc)
{
    PPDev   ppdev = NULL;
    Surf * pdSrcSurf = NULL;
    Surf * pdDstSurf = NULL;
    
    ASSERTDD(psoDst != NULL, "unexpected psoDst == NULL");

    pdDstSurf = (Surf *) psoDst->dhsurf;

    if(psoSrc != NULL)
        pdSrcSurf = (Surf *) psoSrc->dhsurf;

    if(pdDstSurf != NULL)
        ppdev = (PPDev) psoDst->dhpdev;
    else if(pdSrcSurf != NULL)
        ppdev = (PPDev) psoSrc->dhpdev;

    if(ppdev != NULL)
    {
        Surf * psurf = ppdev->psurfListHead;

        while(psurf != ppdev->psurfListTail)
        {
            if(psurf != pdDstSurf)
                psurf->ulChecksum = vCalcSurfaceChecksum(psurf);

            psurf = psurf->psurfNext;

        }
        
    }
}

//------------------------------------------------------------------------------
//
//  VOID vCheckSurfaceChecksums
//
//  Calculates and compares all surface checksums except for the given
//  destination surface.
//
//  Parameters
//   psoDst---destination SURFOBJ
//   psoSrc---source SURFOBJ
//
//------------------------------------------------------------------------------

VOID
vCheckSurfaceChecksums(SURFOBJ * psoDst, SURFOBJ * psoSrc)
{
    PPDev   ppdev = NULL;
    Surf * pdSrcSurf = NULL;
    Surf * pdDstSurf = NULL;
    
    ASSERTDD(psoDst != NULL, "unexpected psoDst == NULL");

    pdDstSurf = (Surf *) psoDst->dhsurf;

    if(psoSrc != NULL)
        pdSrcSurf = (Surf *) psoSrc->dhsurf;

    if(pdDstSurf != NULL)
        ppdev = (PPDev) psoDst->dhpdev;
    else if(pdSrcSurf != NULL)
        ppdev = (PPDev) psoSrc->dhpdev;

    if(ppdev != NULL)
    {
        Surf * psurf = ppdev->psurfListHead;

        while(psurf != ppdev->psurfListTail)
        {
            if(psurf != pdDstSurf)
            {
                ASSERTDD(psurf->ulChecksum == vCalcSurfaceChecksum(psurf),
                    "unexpected checksum mismatch");
            }

            psurf = psurf->psurfNext;

        }
        
    }
}


//------------------------------------------------------------------------------
// ULONG ulCallDepth
//
// Used for keeping track of how many times the DDI layer has been entered.
// Some punted calls to the GDI engine will cause callbacks into DDI.  This
// call depth information is used when event logging.
//
//------------------------------------------------------------------------------

ULONG   ulCallDepth = 0;

//------------------------------------------------------------------------------
//
// BOOL xDrvBitBlt
//
// Thunk layer wrapper for DrvBitBlt.
//
//------------------------------------------------------------------------------

BOOL
xDrvBitBlt(SURFOBJ*  psoDst,
          SURFOBJ*  psoSrc,
          SURFOBJ*  psoMsk,
          CLIPOBJ*  pco,
          XLATEOBJ* pxlo,
          RECTL*    prclDst,
          POINTL*   pptlSrc,
          POINTL*   pptlMsk,
          BRUSHOBJ* pbo,
          POINTL*   pptlBrush,
          ROP4      rop4)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;


    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                         pptlSrc, pptlMsk,pbo, pptlBrush, rop4);

    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc, pptlMsk,
                pbo, pptlBrush, rop4, llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);

    ulCallDepth--;

    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvCopyBits
//
// Thunk layer wrapper for DrvCopyBits.
//
//------------------------------------------------------------------------------

BOOL
xDrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);
    
    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);

    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc, 
                    llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);
    
    ulCallDepth--;
    
    return bResult;

}

//------------------------------------------------------------------------------
//
// BOOL xDrvTransparentBlt
//
// Thunk layer wrapper for DrvTransparentBlt.
//
//------------------------------------------------------------------------------

BOOL 
xDrvTransparentBlt(
   SURFOBJ *    psoDst,
   SURFOBJ *    psoSrc,
   CLIPOBJ *    pco,
   XLATEOBJ *   pxlo,
   RECTL *      prclDst,
   RECTL *      prclSrc,
   ULONG        iTransColor,
   ULONG        ulReserved)
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);
    
    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvTransparentBlt(psoDst,
                             psoSrc,
                             pco,
                             pxlo,
                             prclDst,
                             prclSrc,
                             iTransColor,
                             ulReserved);

    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, 
                       iTransColor,
                       llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);
    
    ulCallDepth--;
    
    return bResult;

}

//------------------------------------------------------------------------------
//
// BOOL xDrvAlphaBlend
//
// Thunk layer wrapper for DrvAlphaBlend.
//
//------------------------------------------------------------------------------

BOOL
xDrvAlphaBlend(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   RECTL    *prclSrc,
   BLENDOBJ *pBlendObj)
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);
    
    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvAlphaBlend(
        psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, pBlendObj);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogAlphaBlend(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, pBlendObj,
                    llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);
    
    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvGradientFill
//
// Thunk layer wrapper for DrvGradientFill.
//
//------------------------------------------------------------------------------

BOOL
xDrvGradientFill(
   SURFOBJ      *psoDst,
   CLIPOBJ      *pco,
   XLATEOBJ     *pxlo,
   TRIVERTEX    *pVertex,
   ULONG        nVertex,
   PVOID        pMesh,
   ULONG        nMesh,
   RECTL        *prclExtents,
   POINTL       *pptlDitherOrg,
   ULONG        ulMode
   )
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvGradientFill(
            psoDst, pco, pxlo, pVertex, nVertex, 
            pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogGradientFill(psoDst, pco, pxlo, pVertex, nVertex, pMesh, nMesh,
                     prclExtents, pptlDitherOrg, ulMode,
                     llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, NULL);
    
    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvTextOut
//
// Thunk layer wrapper for DrvTextOut.
//
//------------------------------------------------------------------------------

BOOL
xDrvTextOut(SURFOBJ*     pso,
           STROBJ*      pstro,
           FONTOBJ*     pfo,
           CLIPOBJ*     pco,
           RECTL*       prclExtra,
           RECTL*       prclOpaque,
           BRUSHOBJ*    pboFore,
           BRUSHOBJ*    pboOpaque,
           POINTL*      pptlBrush, 
           MIX          mix)
{    
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque,
                           pboFore, pboOpaque, pptlBrush, mix);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque,
                 pboFore, pboOpaque, pptlBrush, mix,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvLineTo
//
// Thunk layer wrapper for DrvLineTo.
//
//------------------------------------------------------------------------------

BOOL
xDrvLineTo(
    SURFOBJ*  pso,
    CLIPOBJ*  pco,
    BRUSHOBJ* pbo,
    LONG      x1,
    LONG      y1,
    LONG      x2,
    LONG      y2,
    RECTL*    prclBounds,
    MIX       mix)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvFillPath
//
// Thunk layer wrapper for DrvFillPath.
//
//------------------------------------------------------------------------------

BOOL
xDrvFillPath(
    SURFOBJ*    pso,
    PATHOBJ*    ppo,
    CLIPOBJ*    pco,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    MIX         mix,
    FLONG       flOptions)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvStrokePath
//
// Thunk layer wrapper for DrvStrokePath.
//
//------------------------------------------------------------------------------

BOOL
xDrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

#endif // THUNK LAYER

//-----------------------------------------------------------------------------
//  
//..Add some functions to aid tracking down memory leaks.
//  Its sole purpose is tracking down leaks, so its not optimized for speed.
//  WARNING: If two instances of same driver are active at the same time,
//  it will track the memory allocations of both.
//
//  To keep it simple, we just allocate an array here where we store memory allocations.
//  There is some simple algorithm to keep track of recently freed entries. Anyway,
//  to free a piece of memory we have to search through the whole table. So better
//  use for debugging memory holes.
//
//-----------------------------------------------------------------------------

#if DBG && TRACKMEMALLOC

typedef struct tagMemTrackInfo {
    PVOID    pMemory;
    LONG     lSize;
    PCHAR    pModule;
    LONG     lLineNo;
    //LONGINT                   save time of allocation?
    BOOL     bStopWhenFreed;
    BOOL     bTemp;
} MemTrackInfo, *PMemTrackInfo;

#define NEWCHUNKSIZE 256

static PMemTrackInfo pTrackPool=NULL;
static LONG lTrackPoolTotalSize=0;
static LONG lTrackPoolSize=0;
static LONG lInstances=0;
static LONG lTotalAllocatedMemory=0;
static LONG lNextFreeEntry=0;

//  glMemTrackerVerboseMode--- set flags according to debug output
//                          0   no output
//                          1   print summary for all allocations in same module/LineNo
//                          2   print all entries

LONG glMemTrackerVerboseMode=1;

//-----------------------------------------------------------------------------
//
//  MemTrackerAddInstance
//
//  Just count number of active instances of the driver
//
//-----------------------------------------------------------------------------

VOID MemTrackerAddInstance()
{
    lInstances++;
}

//-----------------------------------------------------------------------------
//
//  MemTrackerRemInstance
//
//  Just count number of active instances of the driver. Free Tracker memory
//  if last instance is destroyed!!!
//
//-----------------------------------------------------------------------------

VOID MemTrackerRemInstance()
{
    lInstances--;
    if (lInstances==0)
    {
        EngFreeMem(pTrackPool);
        pTrackPool=NULL;
        lTrackPoolTotalSize=0;
        lTrackPoolSize=0;
        lTotalAllocatedMemory=0;
        lNextFreeEntry=0;
    }
}

//-----------------------------------------------------------------------------
//
//  MemTrackerAllocateMem
//
//  Add memory top be tracked to table.
//
//  p--------address of memory chunk
//  lSize----Size of memory chunk
//  pModulo--module name
//  lLineNo--module line number
//  bStopWhenFreed--set a breakpoint if this memory is freed (not yet used)
//
//-----------------------------------------------------------------------------

PVOID MemTrackerAllocateMem(PVOID p, 
                           LONG lSize, 
                           PCHAR pModule, 
                           LONG lLineNo, 
                           BOOL bStopWhenFreed)
{
    // check for first time allocation
    if (p==NULL) return p;

    if (pTrackPool==NULL)
    {
        pTrackPool=(PMemTrackInfo)EngAllocMem( FL_ZERO_MEMORY, 
                                               NEWCHUNKSIZE*sizeof(MemTrackInfo), 
                                               ALLOC_TAG);
        if (pTrackPool==NULL) return p;
        lTrackPoolTotalSize=NEWCHUNKSIZE;
        lTrackPoolSize=2;
        lTotalAllocatedMemory=0;
        lNextFreeEntry=1;

        pTrackPool[0].pMemory= pTrackPool;
        pTrackPool[0].lSize=   NEWCHUNKSIZE*sizeof(MemTrackInfo);
        pTrackPool[0].pModule= __FILE__;
        pTrackPool[0].lLineNo= __LINE__;
        pTrackPool[0].bStopWhenFreed=FALSE;
    }

    if (lTrackPoolSize>=lTrackPoolTotalSize)
    {   // reallocation necessary
        LONG lNewTrackPoolTotalSize=lTrackPoolTotalSize+NEWCHUNKSIZE;
        LONG lNewSize;
        PMemTrackInfo pNewTrackPool=(PMemTrackInfo)
            EngAllocMem( FL_ZERO_MEMORY, lNewSize=lNewTrackPoolTotalSize*sizeof(MemTrackInfo), ALLOC_TAG);
        if (pNewTrackPool==NULL) return p;
        memcpy( pNewTrackPool, pTrackPool, lTrackPoolTotalSize*sizeof(MemTrackInfo));
        EngFreeMem( pTrackPool);
        pTrackPool=pNewTrackPool;
        lTrackPoolTotalSize=lNewTrackPoolTotalSize;

        pTrackPool[0].pMemory= pTrackPool;
        pTrackPool[0].lSize=   lNewSize;
        pTrackPool[0].pModule= __FILE__;
        pTrackPool[0].lLineNo= __LINE__;
        pTrackPool[0].bStopWhenFreed=FALSE;
    }

    LONG lThisEntry=lNextFreeEntry;

    lNextFreeEntry=pTrackPool[lThisEntry].lSize;

    pTrackPool[lThisEntry].pMemory= p;
    pTrackPool[lThisEntry].lSize=   lSize;
    pTrackPool[lThisEntry].pModule= pModule;
    pTrackPool[lThisEntry].lLineNo= lLineNo;
    pTrackPool[lThisEntry].bStopWhenFreed=FALSE;

    if (lNextFreeEntry==0)
    {
        lNextFreeEntry=lTrackPoolSize;
        lTrackPoolSize++;
    }

    lTotalAllocatedMemory += lSize;

    return p;
}

//-----------------------------------------------------------------------------
//
//  MemTrackerFreeMem
//
//  remove a memory chunk from table, because it is freed  
//
//  p-----address of memory to be removed from table
//  
//-----------------------------------------------------------------------------

VOID MemTrackerFreeMem( VOID *p)
{

    for (INT i=1; i<lTrackPoolSize; i++)
    {
        if (pTrackPool[i].pMemory==p)
        {
            lTotalAllocatedMemory -= pTrackPool[i].lSize;

            pTrackPool[i].pMemory=NULL;
            pTrackPool[i].lSize=lNextFreeEntry;
            pTrackPool[i].pModule=NULL;
            pTrackPool[i].lLineNo=0;
            pTrackPool[i].bStopWhenFreed=FALSE;

            lNextFreeEntry = i;

            return;
        }
    }

    DISPDBG(( 0, "freeing some piece of memory which was not allocated in this context"));

}

//-----------------------------------------------------------------------------
// 
//  MemTrackerDebugChk
//
//  print out some debug info about tracked memory
//
//-----------------------------------------------------------------------------

VOID MemTrackerDebugChk()
{
    if (glMemTrackerVerboseMode==0) return;

    DISPDBG(( 0, "MemTracker: %ld total allocated memory (%ld for tracker, total %ld)", 
        lTotalAllocatedMemory, pTrackPool[0].lSize,pTrackPool[0].lSize+lTotalAllocatedMemory));

    LONG lTotalTrackedMemory=0;
    for (INT i=0; i<lTrackPoolSize; i++)
    {
        pTrackPool[i].bTemp=FALSE;
        if (pTrackPool[i].pMemory!=NULL)
        {
            lTotalTrackedMemory += pTrackPool[i].lSize;

            if (glMemTrackerVerboseMode & 2)
            {
                DISPDBG((0, "%5ld:%s, line %5ld: %ld b, %p",
                    i, 
                    pTrackPool[i].lLineNo,
                    pTrackPool[i].pModule, 
                    pTrackPool[i].lSize,
                    pTrackPool[i].pMemory)); 
            }
        }
    }

    DISPDBG(( 0, "  sanity check: %ld bytes allocated", lTotalTrackedMemory));

    if (!(glMemTrackerVerboseMode & 1))
        return;

    for (i=1; i<lTrackPoolSize; i++)
    {
        if ( pTrackPool[i].pMemory!=NULL &&
            !pTrackPool[i].bTemp)
        {
            LONG lAllocations=0;
            LONG lTrackedMemory=0;

            for (INT v=i; v<lTrackPoolSize; v++)
            {
                if (!pTrackPool[v].bTemp &&
                     pTrackPool[v].lLineNo==pTrackPool[i].lLineNo &&
                     pTrackPool[v].pModule==pTrackPool[i].pModule)
                {
                    pTrackPool[v].bTemp=TRUE;
                    lAllocations++;
                    lTrackedMemory+=pTrackPool[v].lSize;
                }
            }

            DISPDBG((0, "  %s, line %5ld: %ld bytes total, %ld allocations",
                    pTrackPool[i].pModule, 
                    pTrackPool[i].lLineNo,
                    lTrackedMemory, 
                    lAllocations
                    ));
        }
    }
}

#endif
////////////////////////////////////////////////////////////////////////////

static DWORD readableRegistersP2[] = {
    __Permedia2TagStartXDom,
    __Permedia2TagdXDom,
    __Permedia2TagStartXSub,
    __Permedia2TagdXSub,
    __Permedia2TagStartY,
    __Permedia2TagdY,               
    __Permedia2TagCount,            
    __Permedia2TagRasterizerMode,   
    __Permedia2TagYLimits,
    __Permedia2TagXLimits,
    __Permedia2TagScissorMode,
    __Permedia2TagScissorMinXY,
    __Permedia2TagScissorMaxXY,
    __Permedia2TagScreenSize,
    __Permedia2TagAreaStippleMode,
    __Permedia2TagWindowOrigin,
    __Permedia2TagAreaStipplePattern0,
    __Permedia2TagAreaStipplePattern1,
    __Permedia2TagAreaStipplePattern2,
    __Permedia2TagAreaStipplePattern3,
    __Permedia2TagAreaStipplePattern4,
    __Permedia2TagAreaStipplePattern5,
    __Permedia2TagAreaStipplePattern6,
    __Permedia2TagAreaStipplePattern7,
    __Permedia2TagTextureAddressMode,
    __Permedia2TagSStart,
    __Permedia2TagdSdx,
    __Permedia2TagdSdyDom,
    __Permedia2TagTStart,
    __Permedia2TagdTdx,
    __Permedia2TagdTdyDom,
    __Permedia2TagQStart,
    __Permedia2TagdQdx,
    __Permedia2TagdQdyDom,
    // texellutindex..transfer are treated seperately
    __Permedia2TagTextureBaseAddress,
    __Permedia2TagTextureMapFormat,
    __Permedia2TagTextureDataFormat,
    __Permedia2TagTexel0,
    __Permedia2TagTextureReadMode,
    __Permedia2TagTexelLUTMode,
    __Permedia2TagTextureColorMode,
    __Permedia2TagFogMode,
    __Permedia2TagFogColor,
    __Permedia2TagFStart,
    __Permedia2TagdFdx,
    __Permedia2TagdFdyDom,
    __Permedia2TagKsStart,
    __Permedia2TagdKsdx,
    __Permedia2TagdKsdyDom,
    __Permedia2TagKdStart,
    __Permedia2TagdKddx,
    __Permedia2TagdKddyDom,
    __Permedia2TagRStart,
    __Permedia2TagdRdx,
    __Permedia2TagdRdyDom,
    __Permedia2TagGStart,
    __Permedia2TagdGdx,
    __Permedia2TagdGdyDom,
    __Permedia2TagBStart,
    __Permedia2TagdBdx,
    __Permedia2TagdBdyDom,
    __Permedia2TagAStart,
    __Permedia2TagColorDDAMode,
    __Permedia2TagConstantColor,
    __Permedia2TagAlphaBlendMode,
    __Permedia2TagDitherMode,
    __Permedia2TagFBSoftwareWriteMask,
    __Permedia2TagLogicalOpMode,
    __Permedia2TagLBReadMode,
    __Permedia2TagLBReadFormat,
    __Permedia2TagLBSourceOffset,
    __Permedia2TagLBWindowBase,
    __Permedia2TagLBWriteMode,
    __Permedia2TagLBWriteFormat,
    __Permedia2TagTextureDownloadOffset,
    __Permedia2TagWindow,
    __Permedia2TagStencilMode,
    __Permedia2TagStencilData,
    __Permedia2TagStencil,
    __Permedia2TagDepthMode,
    __Permedia2TagDepth,
    __Permedia2TagZStartU,
    __Permedia2TagZStartL,
    __Permedia2TagdZdxU,
    __Permedia2TagdZdxL,
    __Permedia2TagdZdyDomU,
    __Permedia2TagdZdyDomL,
    __Permedia2TagFBReadMode,
    __Permedia2TagFBSourceOffset,
    __Permedia2TagFBPixelOffset,
    __Permedia2TagFBWindowBase,
    __Permedia2TagFBWriteMode,
    __Permedia2TagFBHardwareWriteMask,
    __Permedia2TagFBBlockColor,
    __Permedia2TagFBReadPixel,
    __Permedia2TagFilterMode,
    __Permedia2TagStatisticMode,
    __Permedia2TagMinRegion,
    __Permedia2TagMaxRegion,
    __Permedia2TagFBBlockColorU,
    __Permedia2TagFBBlockColorL,
    __Permedia2TagFBSourceBase,
    __Permedia2TagTexelLUT0,
    __Permedia2TagTexelLUT1,
    __Permedia2TagTexelLUT2,
    __Permedia2TagTexelLUT3,
    __Permedia2TagTexelLUT4,
    __Permedia2TagTexelLUT5,
    __Permedia2TagTexelLUT6,
    __Permedia2TagTexelLUT7,
    __Permedia2TagTexelLUT8,
    __Permedia2TagTexelLUT9,
    __Permedia2TagTexelLUT10,
    __Permedia2TagTexelLUT11,
    __Permedia2TagTexelLUT12,
    __Permedia2TagTexelLUT13,
    __Permedia2TagTexelLUT14,
    __Permedia2TagTexelLUT15,

    __Permedia2TagYUVMode,
    __Permedia2TagChromaUpperBound,
    __Permedia2TagChromaLowerBound,
    __Permedia2TagAlphaMapUpperBound,
    __Permedia2TagAlphaMapLowerBound,

    // delta tag values. must be at the end of this array

    // v0/1/2 fixed are not used and for that reason not in the context
    
    __Permedia2TagV0FloatS,
    __Permedia2TagV0FloatT,
    __Permedia2TagV0FloatQ,
    __Permedia2TagV0FloatKs,
    __Permedia2TagV0FloatKd,
    __Permedia2TagV0FloatR,
    __Permedia2TagV0FloatG,
    __Permedia2TagV0FloatB,
    __Permedia2TagV0FloatA,
    __Permedia2TagV0FloatF,
    __Permedia2TagV0FloatX,
    __Permedia2TagV0FloatY,
    __Permedia2TagV0FloatZ,
    
    __Permedia2TagV1FloatS,
    __Permedia2TagV1FloatT,
    __Permedia2TagV1FloatQ,
    __Permedia2TagV1FloatKs,
    __Permedia2TagV1FloatKd,
    __Permedia2TagV1FloatR,
    __Permedia2TagV1FloatG,
    __Permedia2TagV1FloatB,
    __Permedia2TagV1FloatA,
    __Permedia2TagV1FloatF,
    __Permedia2TagV1FloatX,
    __Permedia2TagV1FloatY,
    __Permedia2TagV1FloatZ,
    
    __Permedia2TagV2FloatS,
    __Permedia2TagV2FloatT,
    __Permedia2TagV2FloatQ,
    __Permedia2TagV2FloatKs,
    __Permedia2TagV2FloatKd,
    __Permedia2TagV2FloatR,
    __Permedia2TagV2FloatG,
    __Permedia2TagV2FloatB,
    __Permedia2TagV2FloatA,
    __Permedia2TagV2FloatF,
    __Permedia2TagV2FloatX,
    __Permedia2TagV2FloatY,
    __Permedia2TagV2FloatZ,
    
    __Permedia2TagDeltaMode};

#define N_P2_READABLE_REGISTERS (sizeof(readableRegistersP2)/sizeof(DWORD))

static DWORD P2SaveRegs[N_P2_READABLE_REGISTERS];

static PCHAR szReadableRegistersP2[] = {
    "StartXDom",
    "dXDom",
    "StartXSub",
    "dXSub",
    "StartY",
    "dY",               
    "Count",            
    "RasterizerMode",   
    "YLimits",
    "XLimits",
    "ScissorMode",
    "ScissorMinXY",
    "ScissorMaxXY",
    "ScreenSize",
    "AreaStippleMode",
    "WindowOrigin",
    "AreaStipplePattern0",
    "AreaStipplePattern1",
    "AreaStipplePattern2",
    "AreaStipplePattern3",
    "AreaStipplePattern4",
    "AreaStipplePattern5",
    "AreaStipplePattern6",
    "AreaStipplePattern7",
    "TextureAddressMode",
    "SStart",
    "dSdx",
    "dSdyDom",
    "TStart",
    "dTdx",
    "dTdyDom",
    "QStart",
    "dQdx",
    "dQdyDom",
    
    "TextureBaseAddress",
    "TextureMapFormat",
    "TextureDataFormat",
    "Texel0",
    "TextureReadMode",
    "TexelLUTMode",
    "TextureColorMode",
    "FogMode",
    "FogColor",
    "FStart",
    "dFdx",
    "dFdyDom",
    "KsStart",
    "dKsdx",
    "dKsdyDom",
    "KdStart",
    "dKddx",
    "dKddyDom",
    "RStart",
    "dRdx",
    "dRdyDom",
    "GStart",
    "dGdx",
    "dGdyDom",
    "BStart",
    "dBdx",
    "dBdyDom",
    "AStart",
    "ColorDDAMode",
    "ConstantColor",
    "AlphaBlendMode",
    "DitherMode",
    "FBSoftwareWriteMask",
    "LogicalOpMode",
    "LBReadMode",
    "LBReadFormat",
    "LBSourceOffset",
    "LBWindowBase",
    "LBWriteMode",
    "LBWriteFormat",
    "TextureDownloadOffset",
    "Window",
    "StencilMode",
    "StencilData",
    "Stencil",
    "DepthMode",
    "Depth",
    "ZStartU",
    "ZStartL",
    "dZdxU",
    "dZdxL",
    "dZdyDomU",
    "dZdyDomL",
    "FBReadMode",
    "FBSourceOffset",
    "FBPixelOffset",
    "FBWindowBase",
    "FBWriteMode",
    "FBHardwareWriteMask",
    "FBBlockColor",
    "FBReadPixel",
    "FilterMode",
    "StatisticMode",
    "MinRegion",
    "MaxRegion",
    "FBBlockColorU",
    "FBBlockColorL",
    "FBSourceBase",
    "TexelLUT0",
    "TexelLUT1",
    "TexelLUT2",
    "TexelLUT3",
    "TexelLUT4",
    "TexelLUT5",
    "TexelLUT6",
    "TexelLUT7",
    "TexelLUT8",
    "TexelLUT9",
    "TexelLUT10",
    "TexelLUT11",
    "TexelLUT12",
    "TexelLUT13",
    "TexelLUT14",
    "TexelLUT15",
    "YUVMode",
    "ChromaUpperBound",
    "ChromaLowerBound",
    "AlphaMapUpperBound",
    "AlphaMapLowerBound",

    // delta tag values. must be at the end of this array

    // v0/1/2 fixed are not used and for that reason not in the context
    
    "V0FloatS",
    "V0FloatT",
    "V0FloatQ",
    "V0FloatKs",
    "V0FloatKd",
    "V0FloatR",
    "V0FloatG",
    "V0FloatB",
    "V0FloatA",
    "V0FloatF",
    "V0FloatX",
    "V0FloatY",
    "V0FloatZ",
    
    "V1FloatS",
    "V1FloatT",
    "V1FloatQ",
    "V1FloatKs",
    "V1FloatKd",
    "V1FloatR",
    "V1FloatG",
    "V1FloatB",
    "V1FloatA",
    "V1FloatF",
    "V1FloatX",
    "V1FloatY",
    "V1FloatZ",
    
    "V2FloatS",
    "V2FloatT",
    "V2FloatQ",
    "V2FloatKs",
    "V2FloatKd",
    "V2FloatR",
    "V2FloatG",
    "V2FloatB",
    "V2FloatA",
    "V2FloatF",
    "V2FloatX",
    "V2FloatY",
    "V2FloatZ",
    
    "DeltaMode"
    };


VOID PrintAllP2Registers( ULONG ulDebugLevel, PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);
    INT i;

    SYNC_WITH_PERMEDIA;

    DISPDBG((ulDebugLevel,"dumping P2 register set"));

    for (i=0;i<N_P2_READABLE_REGISTERS;i++)
    {
        DWORD lValue=READ_FIFO_REG(readableRegistersP2[i]); 
        DISPDBG((ulDebugLevel," %-25s, 0x%08lx",szReadableRegistersP2[i],lValue));
    }
}

VOID SaveAllP2Registers( PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);
    INT i;

    SYNC_WITH_PERMEDIA;

    for (i=0;i<N_P2_READABLE_REGISTERS;i++)
    {
        P2SaveRegs[i]=READ_FIFO_REG(readableRegistersP2[i]);        
    }
}

VOID PrintDifferentP2Registers(ULONG ulDebugLevel, PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);
    INT i;

    SYNC_WITH_PERMEDIA;

    DISPDBG((ulDebugLevel,"dumping P2 register set"));

    for (i=0;i<N_P2_READABLE_REGISTERS;i++)
    {
        DWORD dwValue=READ_FIFO_REG(readableRegistersP2[i]);        
        if (P2SaveRegs[i]!=dwValue)
        {
            DISPDBG((ulDebugLevel," %-25s, 0x%08lx was 0x%08lx",
                szReadableRegistersP2[i], dwValue, P2SaveRegs[i]));
        }
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\ddsurf.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddsurf.c
*
*  Content:    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"
#include "heap.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_US2P
// Texture tables defined in the D3D side of the driver (d3d.c)
// TODO: move to dd.h or d3d.h
extern ULONG gD3DNumberOfTextureFormats;
extern DDSURFACEDESC gD3DTextureFormats[];


//---------------------------------------------------------------------------
// BOOL bComparePixelFormat
//
// Function used to compare 2 pixels formats for equality. This is a 
// helper function to bCheckTextureFormat. A return value of TRUE indicates 
// equality
//
//---------------------------------------------------------------------------


BOOL 
bComparePixelFormat(LPDDPIXELFORMAT lpddpf1, LPDDPIXELFORMAT lpddpf2)
{
    if (lpddpf1->dwFlags != lpddpf2->dwFlags)
    {
        return FALSE;
    }

    // same bitcount for non-YUV surfaces?
    if (!(lpddpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)))
    {
        if (lpddpf1->dwRGBBitCount != lpddpf2->dwRGBBitCount )
        {
            return FALSE;
        }
    }

    // same RGB properties?
    if (lpddpf1->dwFlags & DDPF_RGB)
    {
        if ((lpddpf1->dwRBitMask != lpddpf2->dwRBitMask) ||
            (lpddpf1->dwGBitMask != lpddpf2->dwGBitMask) ||
            (lpddpf1->dwBBitMask != lpddpf2->dwBBitMask) ||
            (lpddpf1->dwRGBAlphaBitMask != lpddpf2->dwRGBAlphaBitMask))
        { 
             return FALSE;
        }
    }
    
    // same YUV properties?
    if (lpddpf1->dwFlags & DDPF_YUV)	
    {
        if ((lpddpf1->dwFourCC != lpddpf2->dwFourCC) ||
            (lpddpf1->dwYUVBitCount != lpddpf2->dwYUVBitCount) ||
            (lpddpf1->dwYBitMask != lpddpf2->dwYBitMask) ||
            (lpddpf1->dwUBitMask != lpddpf2->dwUBitMask) ||
            (lpddpf1->dwVBitMask != lpddpf2->dwVBitMask) ||
            (lpddpf1->dwYUVAlphaBitMask != lpddpf2->dwYUVAlphaBitMask))
        {
             return FALSE;
        }
    }
    else if (lpddpf1->dwFlags & DDPF_FOURCC)
    {
        if (lpddpf1->dwFourCC != lpddpf2->dwFourCC)
        {
            return FALSE;
        }
    }

    // If Interleaved Z then check Z bit masks are the same
    if (lpddpf1->dwFlags & DDPF_ZPIXELS)
    {
        if (lpddpf1->dwRGBZBitMask != lpddpf2->dwRGBZBitMask)
        {
            return FALSE;
        }
    }

    return TRUE;
} // bComparePixelFormat

//---------------------------------------------------------------------------
//
// BOOL bCheckTextureFormat
//
// Function used to determine if a texture format is supported. It traverses 
// the deviceTextureFormats list. We use this in DdCanCreateSurface32. A
// return value of TRUE indicates that we do support the requested texture 
// format.
//
//---------------------------------------------------------------------------

BOOL 
bCheckTextureFormat(LPDDPIXELFORMAT lpddpf)
{
    DWORD i;

    // Run the list for a matching format
    for (i=0; i < gD3DNumberOfTextureFormats; i++)
    {
        if (bComparePixelFormat(lpddpf, 
                                &gD3DTextureFormats[i].ddpfPixelFormat))
        {
            return TRUE;
        }   
    }

    return FALSE;
} // bCheckTextureFormat


//-----------------------------------------------------------------------------
//
// DdCanCreateSurface32
//
// This entry point is called after parameter validation but before
// any object creation. You can decide here if it is possible for
// you to create this surface.  For example, if the person is trying
// to create an overlay, and you already have the maximum number of
// overlays created, this is the place to fail the call.
//
// You also need to check if the pixel format specified can be supported.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
DdCanCreateSurface(LPDDHAL_CANCREATESURFACEDATA pccsd)
{    
    PPDev ppdev=(PPDev)pccsd->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    PDD_SURFACEDESC lpDDS=pccsd->lpDDSurfaceDesc;
    
    DBG_DD((2,"DDraw:DdCanCreateSurface"));
    
    if(lpDDS->dwLinearSize == 0)
    {
        // rectangular surface
        // Reject all widths larger than we can create partial products for.
        DUMPSURFACE(10, NULL, lpDDS);
        
        if (lpDDS->dwWidth > (ULONG)(2 << MAX_PARTIAL_PRODUCT_P2)) 
        {
            DBG_DD((1,"DDraw:DdCanCreateSurface: Surface rejected:"));
            DBG_DD((1,"  Width Requested: %ld (max. %ld)", 
                lpDDS->dwWidth,(2 << MAX_PARTIAL_PRODUCT_P2)));

            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
        }
    }
    
    // We only support 16bits & 15bits (for stencils) Z-Buffer on PERMEDIA
    if ((lpDDS->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) &&
        (lpDDS->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        DWORD dwBitDepth;
        
        // verify where the right z buffer bit depth is
        if (DDSD_ZBUFFERBITDEPTH & lpDDS->dwFlags)
            dwBitDepth = lpDDS->dwZBufferBitDepth;
        else
            dwBitDepth = lpDDS->ddpfPixelFormat.dwZBufferBitDepth;
        
        // Notice we have to check for a BitDepth of 16 even if a stencil 
        // buffer is present. dwZBufferBitDepth in this case will be the 
        // sum of the z buffer and the stencil buffer bit depth.
        if (dwBitDepth == 16)
        {
            pccsd->ddRVal = DD_OK;
        }
        else
        {
            DBG_DD((2,"DDraw:DdCanCreateSurface: ERROR: "
                       "Depth buffer not 16Bits! - %d", dwBitDepth));
            
            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            
        }
        return DDHAL_DRIVER_HANDLED;
    }

    // pccsd->bIsDifferentPixelFormat tells us if the pixel format of the
    // surface being created matches that of the primary surface.  It can be
    // true for Z buffer and alpha buffers, so don't just reject it out of
    // hand...
 
    if (pccsd->bIsDifferentPixelFormat)
    {
        DBG_DD((3,"  Pixel Format is different to primary"));

        if(lpDDS->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
        {
            DBG_DD((3, "  FourCC requested (%4.4hs, 0x%08lx)", (LPSTR) 
                        &lpDDS->ddpfPixelFormat.dwFourCC,
                        lpDDS->ddpfPixelFormat.dwFourCC ));

            switch (lpDDS->ddpfPixelFormat.dwFourCC)
            {
            case FOURCC_YUV422:
                DBG_DD((3,"  Surface requested is YUV422"));
                if (ppdev->iBitmapFormat == BMF_8BPP)
                {
                    pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                } else
                {
                    lpDDS->ddpfPixelFormat.dwYUVBitCount = 16;
                    pccsd->ddRVal = DD_OK;
                }
                return DDHAL_DRIVER_HANDLED;

            default:
                DBG_DD((3,"  ERROR: Invalid FOURCC requested, refusing"));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
            }
        }
        else if((lpDDS->ddsCaps.dwCaps & DDSCAPS_TEXTURE))
        {

            if (bCheckTextureFormat(&pccsd->lpDDSurfaceDesc->ddpfPixelFormat))
            {
                // texture surface is in one or our supported texture formats
                DBG_DD((3, "  Texture Surface - OK" ));
                pccsd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }
            else
            {
                // we don't support this kind of texture format
                DBG_DD((3, "  ERROR: Texture Surface - NOT OK" ));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
            }
        } 
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
        else if (ValidRGBAlphaSurfaceformat(
                 &lpDDS->ddpfPixelFormat, 
                 NULL))
        {
            DBG_DD((3, "  RGB alpha Surface - OK" ));

            if (lpDDS->ddpfPixelFormat.dwRGBBitCount!=24)
            {
                pccsd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }

        }
#endif
//@@END_DDKSPLIT
        pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
    }
    
    pccsd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdCanCreateSurface32 

//-----------------------------------------------------------------------------
//
//  DdCreateSurface
//
//  This function is called by DirectDraw if a new surface is created. If the 
//  driver has its own memory manager, here is the place to allocate the 
//  videomemory or to fail the call. Note that we return 
//  DDHAL_DRIVER_NOTHANDLED here to indicate that we do not manage the heap.
//  fpVidMem is set to DDHAL_PLEASEALLOC_BLOCKSIZE, and the DDraw memory
//  manager wll allocate the memory for us.
//  
//  Note that the Permedia chip requires a partial product
//  to be setup for each surface.  They also limit the widths to a multiple
//  of 32 for the Partial Products to work.  The below code adjusts the
//  surfaces to meet this requirement.  Note that if we are using a
//  rectangular allocation scheme, the surface is already OK as the desktop
//  is a good width anyway.  This code also handles YUV 16 Bit colour space
//  compressed format (FOURCC_YUV422) which will always be 16 bits, regardless
//  of the desktop resolution/requested depth.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
DdCreateSurface(PDD_CREATESURFACEDATA lpCreateSurface)
{
    PPDev ppdev=        (PPDev)lpCreateSurface->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD               dwBitDepth;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    BOOL                bYUV = FALSE;
    BOOL                bResize = FALSE;
    DWORD               dwExtraBytes;
    PermediaSurfaceData*pPrivateData = NULL;

    DBG_DD((2, "DdCreateSurface called"));

    //
    // See if any of these surfaces are Z buffers. If they are, ensure that the
    // pitch is a valid LB width. The minimum partial product is 32 words or
    // 32 pixels on Permedia 2
    //
    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:
    //
    ASSERTDD(lpCreateSurface->dwSCnt == 1,
             "DdCreateSurface: Unexpected dwSCnt value not equal to one");

    lpSurfaceLocal = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal = lpSurfaceLocal->lpGbl;    
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    //
    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.
    //
    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    //
    // If the surface has already been allocated, don't reallocate it, just
    // reset it. This will happen if the surface is the primary surface.
    //

    if ( lpSurfaceGlobal->dwReserved1 != 0 )
    {
        pPrivateData = (PermediaSurfaceData*)lpSurfaceGlobal->dwReserved1;
        if ( CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData) )
        {
            DBG_DD((0, "  Already allocated Private Surface data 0x%x",
                     pPrivateData));
            memset(pPrivateData, 0, sizeof(PermediaSurfaceData));
        }
        else
        {
            pPrivateData = NULL;
        }
    }

    //
    // If the data isn't valid allocate it.
    //
    if ( pPrivateData == NULL )
    {
        pPrivateData = (PermediaSurfaceData *)
            ENGALLOCMEM(FL_ZERO_MEMORY, 
                        sizeof(PermediaSurfaceData), 
                        ALLOC_TAG);

        if ( pPrivateData == NULL )
        {
            DBG_DD((0, "DDraw:DdCreateSurface: "
                        "Not enough memory for private surface data!"));
            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
            
            return DDHAL_DRIVER_HANDLED;
        }
    }

    //
    // Store the pointer to the new data
    //
    lpSurfaceGlobal->dwReserved1 = (UINT_PTR)pPrivateData;
    DBG_DD((3,"DDraw:DdCreateSurface privatedata=0x%x lpGbl=0x%x lpLcl=0x%x "
        "dwFlags=%08lx &dwReserved1=0x%x", pPrivateData, lpSurfaceGlobal,
        lpSurfaceLocal, lpSurfaceLocal->dwFlags, 
        &lpSurfaceGlobal->dwReserved1));
    //
    // Set the magic number
    //
    pPrivateData->MagicNo = SURF_MAGIC_NO;
    
    //
    // Store away the important information
    //

    SetupPrivateSurfaceData(ppdev, pPrivateData, lpSurfaceLocal);

    if ( pPrivateData->SurfaceFormat.PixelSize != __PERMEDIA_24BITPIXEL )
    {
        dwBitDepth = (8 << pPrivateData->SurfaceFormat.PixelSize);
    }
    else
    {
        dwBitDepth = 24;
    }

    //
    // If the surface is a Z Buffer, then we always need to check the
    // pitch/partial products, and we need to get the depth from the
    // dwZBufferBitDepth field.
    //
    bYUV = FALSE;
    bResize = FALSE;
    dwExtraBytes = 0;

    //
    // get correct bit depth for Z buffers
    //
    if ( (lpSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
       &&(lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_ZBUFFER) )
    {
        DBG_DD((5,"  Surface is Z Buffer - Adjusting"));
        dwBitDepth = lpSurfaceGlobal->ddpfSurface.dwZBufferBitDepth;
    }

    if ( lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC )
    {
        //
        // The surface is a YUV format surface or we fail 
        //

        switch ( lpSurfaceGlobal->ddpfSurface.dwFourCC )
        {
            case FOURCC_YUV422:
                DBG_DD((3,"  Surface is YUV422 - Adjusting"));
                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 16;
                dwBitDepth = 16;
                bYUV = TRUE;
                break;

            default:
                //
                // We should never get here, as CanCreateSurface will
                // validate the YUV format for us.
                //
                ASSERTDD(0, "Trying to create an invalid YUV surface!");
                break;
        }
    }

    //
    // If the surface is a p2 texture and it is using a LUT, then we need to
    // allocate extra local buffer memory for the LUT entries (only on p2).
    //
    if ( (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
       &&(pPrivateData->SurfaceFormat.Format == PERMEDIA_8BIT_PALETTEINDEX) )
    {
        DBG_DD((7,"  Texture is a P2 8Bit LUT"));
        bResize = TRUE;
        dwExtraBytes = (256 * sizeof(DWORD));
    }

    DBG_DD((5,"  Surface Pitch is: 0x%x",  lpSurfaceGlobal->lPitch));

    //
    // Width is in pixels/texels
    //
    LONG lPitch;
    lPitch = lpSurfaceGlobal->wWidth;

    DBG_DD((4,"  Source Surface is %d texels/depth values across",
               lpSurfaceGlobal->wWidth));

    // align before hand to a DWPORD boundary
    if (pPrivateData->SurfaceFormat.PixelSize == __PERMEDIA_4BITPIXEL)
    {
        lPitch = ((lPitch >> 1) + 31) & ~31;
    }
    else
    {
        lPitch = (lPitch + 31) & ~31;
    }

    ULONG ulPackedPP;
    vCalcPackedPP( lPitch, &lPitch, &ulPackedPP);

    DBG_DD((7,"  Surface is 0x%x bits deep", dwBitDepth));

    if ( pPrivateData->SurfaceFormat.PixelSize != __PERMEDIA_4BITPIXEL )
    {
        //
        // Convert back to BYTES
        //
        if ( dwBitDepth != 24 )
        {
            lPitch <<= ((int)dwBitDepth) >> 4;
        }
        else
        {
            lPitch *= 3;
        }
    }

    pPrivateData->dwFlags |= P2_PPVALID;

    DWORD dwExtraLines = 0;

    if ( !bYUV )
    {
        //
        // PM Textures must be at least 32 high
        //
        if ( lpSurfaceGlobal->wHeight < 32 )
        {
            dwExtraLines = 32 - lpSurfaceGlobal->wHeight;
        }
    }

    lpSurfaceGlobal->dwBlockSizeX = 
        lPitch * (DWORD)(lpSurfaceGlobal->wHeight + dwExtraLines);
    lpSurfaceGlobal->dwBlockSizeY = 1;
    lpSurfaceGlobal->lPitch = lPitch;

    //
    // Store the partial productes in the structure
    //
    pPrivateData->ulPackedPP = ulPackedPP;

    DBG_DD((4, "  New Width of surface in Bytes: %d", lPitch));

    //
    // This flag is set if the surface needs resizing. This is currently only
    // used for the P2 LUT based textures.
    //
    if ( bResize )
    {
        DWORD dwExtraScanlines = 0;
        LONG  lExtraRemaining = (LONG)dwExtraBytes;

        //
        // ExtraScanlines is the count x, which * pitch is what we need to get
        // enough memory to hold the LUT.  This algorithm will ensure that even
        // requests for sizes less than a pitch length will get allocated.
        //
        do
        {
            dwExtraScanlines++;
            lExtraRemaining -= (LONG)lpSurfaceGlobal->lPitch;
        } while ( lExtraRemaining > 0 );

        DBG_DD((4, "Calculated extra Pitch lines = %d", dwExtraScanlines));

        //
        // Stretch the surface a little more in multiples of pitch.
        //
        lpSurfaceGlobal->dwBlockSizeX +=dwExtraScanlines * 
                                        lpSurfaceGlobal->lPitch;
    }// if ( bResize )

    
    //
    // Modify surface descriptions as appropriate and let Direct
    // Draw perform the allocation if the surface was not the primary
    //
    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        lpSurfaceGlobal->fpVidMem = NULL;
    }
    else
    {
        lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
    }
    
    lpSurfaceDesc->lPitch   = lpSurfaceGlobal->lPitch;
    lpSurfaceDesc->dwFlags |= DDSD_PITCH;

    if (lpSurfaceLocal->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        if (lpSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
        {
            lPitch =
            lpSurfaceDesc->lPitch   = 
            lpSurfaceGlobal->lPitch =
                ((lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount*
                lpSurfaceGlobal->wWidth+31)/32)*4;  //make it DWORD aligned
        }

        lpSurfaceGlobal->dwUserMemSize = lPitch * 
                                        (DWORD)(lpSurfaceGlobal->wHeight);
        lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
    }

    lpCreateSurface->ddRVal = DD_OK;

    return DDHAL_DRIVER_NOTHANDLED;

}// DdCreateSurface()

//-----------------------------------------------------------------------------
//
// DdDestroySurface
//
// Frees up the private memory allocated with this surface.  Note that
// we return DDHAL_DRIVER_NOTHANDLED indicating that we didn't actually
// free the surface, since the heap is managed by DDraw.
//
//-----------------------------------------------------------------------------
extern TextureCacheManager P2TextureManager;

DWORD CALLBACK 
DdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd )
{
    PermediaSurfaceData *pPrivateData= 
        (PermediaSurfaceData*)psdd->lpDDSurface->lpGbl->dwReserved1;

    
    DBG_DD((3,"DDraw:DdDestroySurface pPrivateData=0x%x "
        "lpGbl=0x%x lpLcl=0x%x dwFlags=%08lx &dwReserved1=0x%x",
        pPrivateData, psdd->lpDDSurface->lpGbl, psdd->lpDDSurface,
        psdd->lpDDSurface->dwFlags, &psdd->lpDDSurface->lpGbl->dwReserved1));

    if (CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData))
    {
        PPERMEDIA_D3DTEXTURE pTexture=NULL;
        if ((psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle) &&
            (HandleList[psdd->lpDDSurface->dwReserved1].dwSurfaceList) &&
            (psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle <
                PtrToUlong(HandleList[psdd->lpDDSurface->dwReserved1].
                    dwSurfaceList[0])))
            pTexture=HandleList[psdd->lpDDSurface->dwReserved1].dwSurfaceList
                [psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle];

        DBG_DD((3,"psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2=%08lx",
            psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2));
        
        if (psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & 
            DDSCAPS2_TEXTUREMANAGE)
        {
            DBG_D3D((3, "free fpVidMem=%08lx fpVidMem=%08lx",
                pPrivateData->fpVidMem,psdd->lpDDSurface->lpGbl->fpVidMem));
            if ((pPrivateData->fpVidMem) && pTexture)
            {
                ASSERTDD(CHECK_D3DSURFACE_VALIDITY(pTexture),
                    "Invalid pTexture in DdDestroySurface");
                TextureCacheManagerRemove(&P2TextureManager,pTexture);
            }
            if (DDRAWISURF_INVALID & psdd->lpDDSurface->dwFlags)
            {
                // indicate that driver takes care of the lost surface already
                psdd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }
        }
        if (pTexture)
        {
            ENGFREEMEM(pTexture);
            HandleList[psdd->lpDDSurface->dwReserved1].dwSurfaceList
                [psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle]=0;
        }
        pPrivateData->MagicNo = NULL;        
        ENGFREEMEM(pPrivateData);
        psdd->lpDDSurface->lpGbl->dwReserved1 = 0;    
    }
#if DBG
    else
    {
        if (pPrivateData) {
            ASSERTDD(0, "DDraw:DdDestroySurface:ERROR:"
                        "Private Surface data not valid??");
        }
        DBG_DD((0, "DDraw:DdDestroySurface:WARNING:"
                    "No Private data in destroyed surface"));
    }
#endif    
    return DDHAL_DRIVER_NOTHANDLED;

} // DdDestroySurface 

//-----------------------------------------------------------------------------
//
// SetupPrivateSurfaceData
//
// Function to get info about DDRAW surface and store it away in the
// private structure.  Useful for partial products, pixel depths,
// texture setup (patching/formats), etc. 
//
//-----------------------------------------------------------------------------

VOID
SetupPrivateSurfaceData( PPDev ppdev, 
                         PermediaSurfaceData* pPrivateData, 
                         LPDDRAWI_DDRAWSURFACE_LCL pSurface)
{
    DDPIXELFORMAT* pPixFormat = NULL;
    
    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData), 
        "SetupPrivateSurfaceData: Private Surface data pointer invalid!!");
    ASSERTDD(pSurface, "SetupPrivateSurfaceData: Surface pointer invalid");
    
    DBG_DD((5,"DDraw:SetupPrivateSurfaceData"));
    DBG_DD((6,"  Width: %d, Height: %d", 
        pSurface->lpGbl->wWidth, pSurface->lpGbl->wHeight));

    // Surface is the primary surface
    if (pSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        DBG_DD((6,"  Surface is Primary"));
        pPrivateData->dwFlags |= P2_SURFACE_PRIMARY;
        pPixFormat = &ppdev->ddpfDisplay;
    } // Either the surface is a texture or it has a valid pixel format.
    else
    {
        DUMPSURFACE(6, pSurface, NULL);
        pPixFormat = &pSurface->lpGbl->ddpfSurface;
    }
    
    // At surface creation the surface has not been patched.
    pPrivateData->dwFlags &= ~P2_ISPATCHED;
    
    if (pSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        // If the user has chosen the normal mechanism, then patch the surface.
        if (pSurface->ddsCaps.dwCaps & DDSCAPS_ALLOCONLOAD) 
        {
            DBG_DD((6,"  Remembering to patch this surface"));
            pPrivateData->dwFlags |= P2_CANPATCH;
        }
        else
        {
            pPrivateData->dwFlags &= ~P2_CANPATCH;
        }
    }
     
    // Initially assume no Alpha
    pPrivateData->SurfaceFormat.bAlpha = FALSE;

    if (pPixFormat != NULL)
    {
        if (pPixFormat->dwFlags & DDPF_FOURCC)
        {
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            switch( pPixFormat->dwFourCC )
            {
            case FOURCC_YUV422:
                DBG_DD((6,"  Surface is 4:2:2 YUV"));
                pPrivateData->SurfaceFormat.Format = PERMEDIA_YUV422;
                pPrivateData->SurfaceFormat.FormatExtension = 
                    PERMEDIA_YUV422_EXTENSION;
                pPrivateData->SurfaceFormat.PixelSize = __PERMEDIA_16BITPIXEL;
                pPrivateData->SurfaceFormat.FBReadPixel= __PERMEDIA_16BITPIXEL;
                pPrivateData->SurfaceFormat.PixelMask = 1;
                pPrivateData->SurfaceFormat.PixelShift= 1;
                pPrivateData->SurfaceFormat.ColorComponents = 2;
                pPrivateData->SurfaceFormat.logPixelSize = log2(16);
                pPrivateData->SurfaceFormat.ColorOrder = 0;
                break;
            }
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED4)
        {
            DBG_DD((6,"  Surface is 4-Bit Palette"));
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_PALETTE;
            pPrivateData->SurfaceFormat.Format = PERMEDIA_4BIT_PALETTEINDEX;
            pPrivateData->SurfaceFormat.FormatExtension = 0;
            pPrivateData->SurfaceFormat.PixelSize = __PERMEDIA_4BITPIXEL;
            pPrivateData->SurfaceFormat.FBReadPixel= __PERMEDIA_8BITPIXEL;
            pPrivateData->SurfaceFormat.PixelMask = 7;
            pPrivateData->SurfaceFormat.PixelShift= 0;
            pPrivateData->SurfaceFormat.ColorComponents = 3;
            pPrivateData->SurfaceFormat.logPixelSize = log2(4);
            pPrivateData->SurfaceFormat.ColorOrder = 0;
            pPrivateData->dwFlags &= ~P2_CANPATCH;
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED8)
        {
            DBG_DD((6,"  Surface is 8-Bit Palette"));
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_PALETTE;
            pPrivateData->SurfaceFormat.Format = PERMEDIA_8BIT_PALETTEINDEX;
            pPrivateData->SurfaceFormat.FormatExtension = 0;
            pPrivateData->SurfaceFormat.PixelSize = __PERMEDIA_8BITPIXEL;
            pPrivateData->SurfaceFormat.FBReadPixel= __PERMEDIA_8BITPIXEL;
            pPrivateData->SurfaceFormat.PixelMask = 3;
            pPrivateData->SurfaceFormat.PixelShift= 0;
            pPrivateData->SurfaceFormat.ColorComponents = 3;
            pPrivateData->SurfaceFormat.Texture16BitMode = 1;
            pPrivateData->SurfaceFormat.logPixelSize = log2(8);
            pPrivateData->SurfaceFormat.ColorOrder = 0;
        }
        else
        {
            if (SetRGBAlphaSurfaceFormat( pPixFormat, 
                                         &pPrivateData->SurfaceFormat))
            {
                pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            } else
            {
                pPrivateData->dwFlags &= ~P2_SURFACE_FORMAT_VALID;
            }
        }
    }
    else
    {
        ASSERTDD(0, "SetupPrivateSurfaceData:"
                    "Can't get valid surface format pointer");
    }
    

} // SetupPrivateSurfaceData 

//-----------------------------------------------------------------------------
//
// list all valid pixel formats for Permedia 2
// The P2 supports BGR for all formats, so these formats are not
// explicitely listed here, also formats having no alpha channel are permitted
//  
//-----------------------------------------------------------------------------

DDPIXELFORMAT Permedia2PixelFormats[] = {
    // 32 bit RGBa
    {PERMEDIA_8888_RGB,0,0,32,0x000000ff,0x0000ff00,0x00ff0000,0xff000000},     
    // 16 bit 5:6:5, RGB
    {PERMEDIA_565_RGB ,0,0,16,0x0000001f,0x000007e0,0x0000f800,0x00000000},     
    // 16 bit 4:4:4:4RGBa
    {PERMEDIA_444_RGB ,0,0,16,0x0000000f,0x000000f0,0x00000f00,0x0000f000},     
    // 15 bit 5:5:5, RGBa
    {PERMEDIA_5551_RGB,0,0,16,0x0000001f,0x000003e0,0x00007c00,0x00008000},     
    //  8 bit 3:3:2  RGB
    // 332 format is not symmetric. Its listed twice for BGR/RGB case
    {PERMEDIA_332_RGB ,1,0, 8,0x00000007,0x00000038,0x000000c0,0x00000000},     
    {PERMEDIA_332_RGB ,0,0, 8,0x00000003,0x0000001c,0x000000e0,0x00000000},     
//@@BEGIN_DDKSPLIT
//  there are no testcases against the 2321 format, so disable it for now
//  8 bit 2:3:2:1RGBa
//  {PERMEDIA_2321_RGB,0,0, 8,0x00000003,0x0000001c,0x00000060,0x00000080},     
//@@END_DDKSPLIT
    // 24 bit RGB
    {PERMEDIA_888_RGB ,0,0,24,0x000000ff,0x0000ff00,0x00ff0000,0x00000000}      
};
#define N_PERMEDIA2PIXELFORMATS \
    (sizeof(Permedia2PixelFormats)/sizeof(DDPIXELFORMAT))

BOOL
ValidRGBAlphaSurfaceformat( DDPIXELFORMAT *pPixFormat, INT *pIndex)
{
    INT i;

    if (pPixFormat==NULL) 
        return FALSE;

    if (pPixFormat->dwSize < sizeof(DDPIXELFORMAT))
        return FALSE;

    // The Z-Buffer is a special case. Its basically a 16 bit surface
    if (pPixFormat->dwFlags & DDPF_ZBUFFER)
    {
        if (pIndex!=0) *pIndex=1;
        return TRUE;
    }

    if ((pPixFormat->dwFlags & DDPF_RGB)==0)
        return FALSE;

    for ( i=0; i<N_PERMEDIA2PIXELFORMATS; i++)
    {
        // check if the RGB and alpha masks fit.
        // on Permedia we can swap R and B, so allow also BGR formats
        if ((((pPixFormat->dwRBitMask == 
                    Permedia2PixelFormats[i].dwRBitMask) &&
              (pPixFormat->dwBBitMask == 
                    Permedia2PixelFormats[i].dwBBitMask)) ||
             ((pPixFormat->dwRBitMask == 
                    Permedia2PixelFormats[i].dwBBitMask) &&
              (pPixFormat->dwBBitMask == 
                    Permedia2PixelFormats[i].dwRBitMask))) &&
            (pPixFormat->dwGBitMask == 
                    Permedia2PixelFormats[i].dwGBitMask) &&
            ((pPixFormat->dwRGBAlphaBitMask == 
                    Permedia2PixelFormats[i].dwRGBAlphaBitMask) ||
             (pPixFormat->dwRGBAlphaBitMask == 0) ||
             ((pPixFormat->dwFlags&DDPF_ALPHAPIXELS)==0)) &&
              (pPixFormat->dwRGBBitCount==
                    Permedia2PixelFormats[i].dwRGBBitCount)
            )
        {
            if (pIndex!=NULL)
            {
                *pIndex = i;
            }
            return TRUE;
        }
    }
     
    // no pixel format matched...

    return FALSE;

} // ValidRGBAlphaSurfaceformat


//-----------------------------------------------------------------------------
//
//  SetRGBAlphaSurfaceFormat
//
//  Store away pixel format information of a surface in the Permedia native 
//  format
//
//-----------------------------------------------------------------------------

BOOL
SetRGBAlphaSurfaceFormat(DDPIXELFORMAT *pPixFormat, 
                         PERMEDIA_SURFACE *pSurfaceFormat)
{
    INT iFormatIndex;

    if (!ValidRGBAlphaSurfaceformat( pPixFormat, &iFormatIndex))
    {
        DBG_DD((1,"couldn't set SurfaceFormat"));
        return FALSE;        
    }

    DBG_DD((6,"  Surface RGB Data Valid"));

    pSurfaceFormat->RedMask = pPixFormat->dwRBitMask;
    pSurfaceFormat->GreenMask = pPixFormat->dwGBitMask;
    pSurfaceFormat->BlueMask = pPixFormat->dwBBitMask;
    pSurfaceFormat->bPreMult = FALSE;

    if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
    {
        pSurfaceFormat->AlphaMask = pPixFormat->dwRGBAlphaBitMask;
    
        if (pSurfaceFormat->AlphaMask!=0)
        {
            pSurfaceFormat->bAlpha = TRUE;
        } 

        if (pPixFormat->dwFlags & DDPF_ALPHAPREMULT)
        {
            pSurfaceFormat->bPreMult = TRUE;
        }
    }

    pSurfaceFormat->ColorOrder = Permedia2PixelFormats[iFormatIndex].dwFlags;

    // check for the BGR case
    if (pPixFormat->dwRBitMask == 
        Permedia2PixelFormats[iFormatIndex].dwRBitMask)
        pSurfaceFormat->ColorOrder = !pSurfaceFormat->ColorOrder;
            
    switch (pPixFormat->dwRGBBitCount)
    {
    case 24:
        DBG_DD((6,"  Surface is 8:8:8 Packed 24 Bit"));
        pSurfaceFormat->Format = PERMEDIA_888_RGB;
        pSurfaceFormat->FormatExtension = PERMEDIA_888_RGB_EXTENSION;
        pSurfaceFormat->PixelSize = __PERMEDIA_24BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_24BITPIXEL;
        pSurfaceFormat->PixelMask = 0;  // not valid for 24 bit
        pSurfaceFormat->PixelShift= 0;
        pSurfaceFormat->logPixelSize = 0;
        pSurfaceFormat->ColorComponents = 3;
        break;

    case 32:
        DBG_DD((6,"  Surface is 8:8:8:8"));
        pSurfaceFormat->Format = PERMEDIA_8888_RGB;
        pSurfaceFormat->FormatExtension = PERMEDIA_8888_RGB_EXTENSION;
        pSurfaceFormat->PixelSize = __PERMEDIA_32BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_32BITPIXEL;
        pSurfaceFormat->PixelMask = 0;
        pSurfaceFormat->PixelShift= 2;
        pSurfaceFormat->logPixelSize = log2(32);
        pSurfaceFormat->ColorComponents = 3;
        break;

    case 16:
        pSurfaceFormat->logPixelSize = log2(16);
        pSurfaceFormat->PixelSize = __PERMEDIA_16BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_16BITPIXEL;
        pSurfaceFormat->PixelMask = 1;  // not valid for 24 bit
        pSurfaceFormat->PixelShift= 1;
        switch (Permedia2PixelFormats[iFormatIndex].dwSize)
        {
        case PERMEDIA_565_RGB:
            pSurfaceFormat->Texture16BitMode = 0;
            pSurfaceFormat->Format = PERMEDIA_565_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_565_RGB_EXTENSION;
            pSurfaceFormat->ColorComponents = 2;
            DBG_DD((6,"  Surface is 5:6:5"));
            break;

        case PERMEDIA_444_RGB:
            pSurfaceFormat->Format = PERMEDIA_444_RGB;
            pSurfaceFormat->FormatExtension = 0;
            pSurfaceFormat->ColorComponents = 3;
            if (pPixFormat->dwRGBAlphaBitMask != 0)
            {
                DBG_DD((6,"  Surface is 4:4:4:4"));
            } else
            {
                DBG_DD((6,"  Surface is 4:4:4:0"));
            }
            break;

        case PERMEDIA_5551_RGB:
            pSurfaceFormat->Texture16BitMode = 1;
            pSurfaceFormat->Format = PERMEDIA_5551_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_5551_RGB_EXTENSION;
            if (pPixFormat->dwRGBAlphaBitMask != 0)
            {
                DBG_DD((6,"  Surface is 5:5:5:1"));
                pSurfaceFormat->ColorComponents = 3;
            }
            else
            {
                DBG_DD((6,"  Surface is 5:5:5"));
                pSurfaceFormat->ColorComponents = 2;
            }
            break;
        default: 
            ASSERTDD( FALSE, "  16 bit Surface has unknown format");
            break;
        }
        break;

    case 8:
        pSurfaceFormat->PixelSize = __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->PixelMask = 3;
        pSurfaceFormat->PixelShift= 0;
        pSurfaceFormat->logPixelSize = log2(8);
        if (Permedia2PixelFormats[iFormatIndex].dwSize==PERMEDIA_2321_RGB)
        {
            pSurfaceFormat->Format = PERMEDIA_2321_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_2321_RGB_EXTENSION;
            pSurfaceFormat->ColorComponents = 3;
        }
        else if (Permedia2PixelFormats[iFormatIndex].dwSize==PERMEDIA_332_RGB)
        {
            pSurfaceFormat->Format = PERMEDIA_332_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_332_RGB_EXTENSION;
            pSurfaceFormat->ColorComponents = 2;
        } else
        {
            ASSERTDD( FALSE, "  Surface (8bit) has unknown format");
        }
        break;

    case 0:
        DBG_DD((6,"  Surface is palleted"));
        pSurfaceFormat->Format = PERMEDIA_8BIT_PALETTEINDEX;
        pSurfaceFormat->FormatExtension = PERMEDIA_8BIT_PALETTEINDEX_EXTENSION;
        pSurfaceFormat->PixelSize = __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->PixelMask = 3;  // not valid for 24 bit
        pSurfaceFormat->PixelShift= 0;
        pSurfaceFormat->logPixelSize = log2(8);
        pSurfaceFormat->ColorComponents = 0;
        break;

    default:
        ASSERTDD( FALSE, "  Surface has unknown pixelformat");
        return FALSE;
    }

    return TRUE;

}  // SetRGBAlphaSurfaceFormat
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\debug.h ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: debug.h
*
* Debugging support interfaces.    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

extern
VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );


#if DBG

// In order to enable per component debugging, DebugFilter will
// contain the bit pattern that will turn on messages for them.
// Debug messages with a debuglevel of 0 will be printed regardless
// of the filter in effect.The DWORD in which the DebugFilter is
// stored and the patterns of the filter masks will allow up to
// 4 separate components to be tracked, each one with 8 separate
// subcomponents.

// Note: During the transition phase to this new functionality, a 
// filter of 0 will print ALL messages, but will later be switched 
// to print NONE (expect of course , those at level 0)

extern DWORD DebugFilter;
extern DWORD DebugPrintFilter;

#define DEBUG_FILTER_D3D   0x000000FF
#define DEBUG_FILTER_DD    0x0000FF00
#define DEBUG_FILTER_GDI   0x00FF0000

#define MINOR_DEBUG

#define DISPDBG(arg) DebugPrint arg

#define DBG_COMPONENT(arg, component)        \
{       DebugPrintFilter = component;        \
        DebugPrint arg ;                     \
        DebugPrintFilter = 0;                \
}

#define DBG_D3D(arg)        DBG_COMPONENT(arg,DEBUG_FILTER_D3D)
#define DBG_DD(arg)         DBG_COMPONENT(arg,DEBUG_FILTER_DD)
#define DBG_GDI(arg)        DBG_COMPONENT(arg,DEBUG_FILTER_GDI)

#define RIP(x) { DebugPrint(-1000, x); DebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)

extern VOID __cdecl DebugMsg(PCHAR DebugMessage, ...);
extern void DumpSurface(LONG Level, LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, LPDDSURFACEDESC lpDDSurfaceDesc);
extern void DecodeBlend(LONG Level, DWORD i );

#define DUMPSURFACE(a, b, c) DumpSurface(a, b, c); 
#define DECODEBLEND(a, b) DecodeBlend(a, b);

#define PRINTALLP2REGISTER    PrintAllP2Registers  
#define PRINTDIFFP2REGISTER   PrintDifferentP2Registers
#define SAVEALLP2REGISTER     SaveAllP2Registers  

VOID PrintAllP2Registers( ULONG ulDebugLevel, PPDev ppdev);
VOID SaveAllP2Registers( PPDev ppdev);
VOID PrintDifferentP2Registers(ULONG ulDebugLevel, PPDev ppdev);

#if TRACKMEMALLOC
//------------------------------------------------------------------------------
//
//  Memory Tracker
//
//------------------------------------------------------------------------------




VOID MemTrackerAddInstance();
VOID MemTrackerRemInstance();
PVOID MemTrackerAllocateMem(PVOID p, 
                           LONG lSize, 
                           PCHAR pModule, 
                           LONG lLineNo, 
                           BOOL bStopWhenFreed);
VOID MemTrackerFreeMem( VOID *p);
VOID MemTrackerDebugChk();

#define MEMTRACKERADDINSTANCE MemTrackerAddInstance
#define MEMTRACKERREMINSTANCE MemTrackerRemInstance
#define MEMTRACKERALLOCATEMEM MemTrackerAllocateMem
#define MEMTRACKERFREEMEM     MemTrackerFreeMem
#define MEMTRACKERDEBUGCHK    MemTrackerDebugChk

#else

#define MEMTRACKERADDINSTANCE / ## /
#define MEMTRACKERREMINSTANCE / ## /
#define MEMTRACKERALLOCATEMEM / ## /
#define MEMTRACKERFREEMEM     / ## /
#define MEMTRACKERDEBUGCHK    / ## /

#endif

//------------------------------------------------------------------------------
//
// THUNK_LAYER
//
// By Setting THUNK_LAYER equal to 1 you are adding a wrapper call on top of
// all DDI rendering functions.  In this thunk layer of wrapper calls
// several usefull debugging features are enabled.
//
// Surface checks--which can help catch errant rendering routines
// Event logging---which can record rendering evernts to a log file
//
//------------------------------------------------------------------------------


#define THUNK_LAYER 0

#if THUNK_LAYER

BOOL
xDrvBitBlt(SURFOBJ*  psoDst,
          SURFOBJ*  psoSrc,
          SURFOBJ*  psoMsk,
          CLIPOBJ*  pco,
          XLATEOBJ* pxlo,
          RECTL*    prclDst,
          POINTL*   pptlSrc,
          POINTL*   pptlMsk,
          BRUSHOBJ* pbo,
          POINTL*   pptlBrush,
          ROP4      rop4);

BOOL
xDrvCopyBits(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc);

BOOL 
xDrvTransparentBlt(
   SURFOBJ *    psoDst,
   SURFOBJ *    psoSrc,
   CLIPOBJ *    pco,
   XLATEOBJ *   pxlo,
   RECTL *      prclDst,
   RECTL *      prclSrc,
   ULONG        iTransColor,
   ULONG        ulReserved);

BOOL xDrvAlphaBlend(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   RECTL    *prclSrc,
   BLENDOBJ *pBlendObj);

BOOL
xDrvGradientFill(
   SURFOBJ      *psoDst,
   CLIPOBJ      *pco,
   XLATEOBJ     *pxlo,
   TRIVERTEX    *pVertex,
   ULONG        nVertex,
   PVOID        pMesh,
   ULONG        nMesh,
   RECTL        *prclExtents,
   POINTL       *pptlDitherOrg,
   ULONG        ulMode
   );

BOOL
xDrvTextOut(SURFOBJ*     pso,
           STROBJ*      pstro,
           FONTOBJ*     pfo,
           CLIPOBJ*     pco,
           RECTL*       prclExtra,
           RECTL*       prclOpaque,
           BRUSHOBJ*    pboFore,
           BRUSHOBJ*    pboOpaque,
           POINTL*      pptlBrush, 
           MIX          mix);

BOOL
xDrvFillPath(
    SURFOBJ*    pso,
    PATHOBJ*    ppo,
    CLIPOBJ*    pco,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    MIX         mix,
    FLONG       flOptions);

BOOL
xDrvLineTo(
    SURFOBJ*  pso,
    CLIPOBJ*  pco,
    BRUSHOBJ* pbo,
    LONG      x1,
    LONG      y1,
    LONG      x2,
    LONG      y2,
    RECTL*    prclBounds,
    MIX       mix);

BOOL
xDrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix);

#endif

#else

#define DISPDBG(arg)
#define DBG_D3D(arg)
#define DBG_DD(arg)
#define DBG_GDI(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define DUMPSURFACE(a, b, c)
#define DECODEBLEND(a, b)

#define MEMTRACKERADDINSTANCE / ## /
#define MEMTRACKERREMINSTANCE / ## /
#define MEMTRACKERALLOCATEMEM / ## /
#define MEMTRACKERFREEMEM     / ## /
#define MEMTRACKERDEBUGCHK    / ## /

#define PRINTALLP2REGISTER      / ## /  
#define PRINTDIFFP2REGISTER     / ## /
#define SAVEALLP2REGISTER       / ## /

#endif

#define DebugBreak              EngDebugBreak

#define MAKE_BITMAPS_OPAQUE 0

//@@BEGIN_DDKSPLIT
#if GDI_TEST
//
// GDI debug functions
//
void vPuntAfter(ULONG flags, SURFOBJ * psoSrc, SURFOBJ * psoDst);

ULONG vPuntBefore(SURFOBJ * psoSrc, SURFOBJ * psoDst);
#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\download.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: download.c
*
* Contains the upload and download routines.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"

//-----------------------------------------------------------------------------
//
// VOID vDownloadNative(GFNPB* ppb)
//
// Does a download of a native surface for a list of rectangles.
// Note: this download takes the advantage of Permedia 2 packed data read.
//      Because of the permedia 2 hardware limitation, we can only use the
//      packedData download when the logic OP is SRC_COPY or the destination
//      is aligned to the packed data being downloaded. This will typically be
//      when the surface is 32 bpp. Otherwise, we just do the regular download
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------
VOID
vDownloadNative(GFNPB* ppb)
{
    PDev*       ppdev = ppb->ppdev;
    Surf*       psurfDst = ppb->psurfDst;
    SURFOBJ*    pSrcSurface = ppb->psoSrc;

    RECTL*      pRects = ppb->pRects;
    RECTL*      prclDst = ppb->prclDst;
    
    POINTL*     pptlSrc = ppb->pptlSrc;
    
    BOOL        bEnablePacked;
    
    DWORD       dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                             | __RENDER_SYNC_ON_HOST_DATA;
    LONG        lNumRects = ppb->lNumRects;
    LONG        lSrcStride;
    LONG        lXOffset = pptlSrc->x - prclDst->left;
    LONG        lYOffset = pptlSrc->y - prclDst->top;

    ULONG       ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);
    ULONG*      pBuffer;

    //
    // Note: Due to the hardware limitation, we can take the advantage of
    // Permedia 2 PackedData copy only when the logic OP is SRC_COPY, or
    // the destination is aligned to the packed data being downloaded.
    // This will typically be when the surface is 32 bpp.
    //
    if ( (ulLogicOP == K_LOGICOP_COPY)
       ||(pSrcSurface->iBitmapFormat == BMF_32BPP) )
    {
        bEnablePacked = TRUE;
    }
    else
    {
        bEnablePacked = FALSE;
    }

    DBG_GDI((6, "vDownloadNative called, logicop=%d", ulLogicOP));

    DBG_GDI((6, "source SURFOBJ=0x%x", pSrcSurface));
    DBG_GDI((6, "pptlSrc(x, y)(%d, %d) logicop=%d",
             pptlSrc->x, pptlSrc->y, ulLogicOP));
    DBG_GDI((6, "prclDst(left, right, top, bottom)(%d, %d, %d, %d)",
             prclDst->left, prclDst->right, prclDst->top, prclDst->bottom));
    DBG_GDI((6, "lXOffset=%d, lYOffset=%d", lXOffset, lYOffset));

    vCheckGdiContext(ppdev);

    InputBufferReserve(ppdev, 10, &pBuffer);

    //
    // Setup loop invariant state
    //
    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = psurfDst->ulPixOffset;
    pBuffer[4] = __Permedia2TagFBPixelOffset;
    pBuffer[5] = 0;
    pBuffer[6] = __Permedia2TagFBReadPixel;
    pBuffer[7] = ppdev->cPelSize;
    pBuffer[8] =  __Permedia2TagdY;
    pBuffer[9] = INTtoFIXED(1);

    pBuffer += 10;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Loop all the rectangles to render
    //
    while( lNumRects-- )
    {
        ULONG   ulMask = ppdev->dwBppMask;
        DWORD   dwReadMode = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                           | LogicopReadDest[ulLogicOP];
        
        ULONG   ulStartXDom;
        ULONG   ulStartXSub;
        
        LONG    lSrcLeft = lXOffset + pRects->left;
        
        //
        // Calculate the 3 bit 2's compliment shift that is required to align
        // the source pixels with the destination. This relative offset can be
        // used to shift the downloaded data to the 32 bit destination alignment
        // that packing requires. This enables you to read DWORD aligned data
        // on the host despite the data not being aligned correctly for the
        // packing.
        //
        ULONG   ulOffset = ( (pRects->left & ulMask)
                           - (lSrcLeft & ulMask)) & 0x7;
        
        DBG_GDI((6, "ulOffset = 0x%x", ulOffset));
        DBG_GDI((6, "pRects(left, right, top, bottom)(%d, %d, %d, %d)",
                 pRects->left, pRects->right, pRects->top, pRects->bottom));

        if ( (bEnablePacked == FALSE) && (ulOffset == 0) )
        {
            //
            // As long as the source and dest are aligned, then we can still use
            // the packed data copy, even with logic OPs
            //
            DBG_GDI((6, "Turn packed data on when src and dst are aligned"));
            bEnablePacked = TRUE;
        }

        ULONG   ulWidth = pRects->right - pRects->left;
        ULONG   ulHeight = pRects->bottom - pRects->top;
        
        ULONG   ulDstLeft;
        ULONG   ulDstRight;
        ULONG   ulDstWidth;        
        LONG    lSrcRight;
        ULONG   ulSrcWidth;
        ULONG   ulExtra;
        
        if ( bEnablePacked == TRUE )
        {
            ULONG   ulShift = ppdev->bBppShift;
            
            ulDstLeft = pRects->left >> ulShift;
            ulDstRight = (pRects->right + ulMask) >> ulShift;
            ulDstWidth = ulDstRight - ulDstLeft;
        
            lSrcRight = (lSrcLeft + ulWidth + ulMask) >> ulShift;
        
            lSrcLeft >>= ulShift;
        
            ulSrcWidth = (ULONG)(lSrcRight - lSrcLeft);
        
            //
            // We need to convert from pixel coordinates to ULONG coordinates.
            // Also, we need to set the destination width to the greater of the
            // source width or destination width.  If destination width is
            // greater then the source width, we need to remember this so that
            // we can download an additional dummy value without reading past
            // the end of the source data (which could result in an access
            // fault).
            //
            if( ulDstWidth <= ulSrcWidth )
            {
                ulExtra = 0;
                ulWidth = ulSrcWidth;
            }
            else
            {
                ulWidth = ulDstWidth;
                ulExtra = 1;
            }
        
            dwReadMode |= (PM_FBREADMODE_RELATIVEOFFSET(ulOffset)
                         | PM_FBREADMODE_READSOURCE(__PERMEDIA_DISABLE)
                         | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE) );
            ulStartXDom = INTtoFIXED(ulDstLeft);
            ulStartXSub = INTtoFIXED(ulDstLeft + ulWidth);
        }
        else
        {
            dwReadMode |= PM_FBREADMODE_RELATIVEOFFSET(0);

            ulStartXDom = INTtoFIXED(pRects->left);
            ulStartXSub = INTtoFIXED(pRects->right);
        }

        InputBufferReserve(ppdev, 14, &pBuffer);
        
        pBuffer[0] = __Permedia2TagFBReadMode;
        pBuffer[1] = dwReadMode;
        pBuffer[2] = __Permedia2TagStartXDom;
        pBuffer[3] = ulStartXDom;
        pBuffer[4] = __Permedia2TagStartXSub;
        pBuffer[5] = ulStartXSub;

        //
        // Test result shows that it won't hurt if we are doing non-packed
        // download and setting this register. If we move this settings
        // inside the "bEnablePacked == TRUE" case, then we need the extra
        // InputBufferReserve/InputBufferCommit for packed data download
        // which will hurt performance
        //
        pBuffer[6] = __Permedia2TagPackedDataLimits;
        pBuffer[7] = PM_PACKEDDATALIMITS_OFFSET(ulOffset)
                   |(INTtoFIXED(pRects->left)
                   | pRects->right);
        pBuffer[8] = __Permedia2TagStartY;
        pBuffer[9] = INTtoFIXED(pRects->top);
        pBuffer[10] = __Permedia2TagCount;
        pBuffer[11] = ulHeight;
        pBuffer[12] = __Permedia2TagRender;
        pBuffer[13] = dwRenderBits;
        pBuffer += 14;

        InputBufferCommit(ppdev, pBuffer);
        
        if ( bEnablePacked == TRUE )
        {
            ULONG*  pulSrcStart = (ULONG*)(pSrcSurface->pvScan0);
            lSrcStride = pSrcSurface->lDelta >> 2;

            ULONG* pulSrc = (ULONG*)(pulSrcStart
                                     + ((lYOffset + pRects->top) * lSrcStride)
                                     + lSrcLeft);        
            ULONG*  pulData = pulSrc;

            while ( ulHeight-- )
            {
                ULONG   ulTemp = ulSrcWidth;
                ULONG*  pulSrcTemp = pulData;

                InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                pBuffer[0] = __Permedia2TagColor | ((ulWidth - 1) << 16);
                pBuffer +=1;

                while ( ulTemp-- )
                {
                    *pBuffer++ = *pulSrcTemp++;
                }

                if ( ulExtra )
                {
                    *pBuffer++ = 0;
                }

                InputBufferCommit(ppdev, pBuffer);

                pulData += lSrcStride;
            }// while ( ulHeight-- )
        }// PackedEnabled case
        else if ( pSrcSurface->iBitmapFormat == BMF_16BPP )
        {
            USHORT* psSrcStart = (USHORT*)(pSrcSurface->pvScan0);
            lSrcStride = pSrcSurface->lDelta >> 1;

            USHORT* psSrc = (USHORT*)(psSrcStart
                                      + ((lYOffset + pRects->top) * lSrcStride)
                                      + lSrcLeft);
            USHORT*  psData = psSrc;

            while ( ulHeight-- )
            {
                ULONG   ulTemp = ulWidth;
                USHORT* psSrcTemp = psData;

                InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                pBuffer[0] = __Permedia2TagColor | ((ulWidth - 1) << 16);
                pBuffer +=1;

                while ( ulTemp-- )
                {
                    *pBuffer++ = (ULONG)(*psSrcTemp++);
                }

                InputBufferCommit(ppdev, pBuffer);

                psData += lSrcStride;
            }// while ( ulHeight-- )
        }// 16 bpp non-packed case
        else if ( pSrcSurface->iBitmapFormat == BMF_8BPP )
        {
            BYTE*   pcSrcStart = (BYTE*)(pSrcSurface->pvScan0);
            lSrcStride = pSrcSurface->lDelta;

            BYTE* pcSrc = (BYTE*)(pcSrcStart
                                  + ((lYOffset + pRects->top) * lSrcStride)
                                  + lSrcLeft);        
            BYTE*  pcData = pcSrc;

            while ( ulHeight-- )
            {
                ULONG   ulTemp = ulWidth;
                BYTE*   pcSrcTemp = pcData;

                InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                pBuffer[0] = __Permedia2TagColor | ((ulWidth - 1) << 16);
                pBuffer +=1;

                while ( ulTemp-- )
                {
                    *pBuffer++ = (ULONG)(*pcSrcTemp++);
                }

                InputBufferCommit(ppdev, pBuffer);

                pcData += lSrcStride;
            }// while ( ulHeight-- )
        }// 8 bpp non-packed case
        else
        {
            //
            // Since we have a check in DrvBitBlt
            // if(psoSrc->iBitmapFormat == pb.ppdev->iBitmapFormat) before we
            // allow it to call this function, so this ASSERT should never
            // be hit. It will if we implement 24 bpp download late.
            //
            ASSERTDD(0, "we don't handle it for now");
        }

        //
        // Next rectangle
        //
        pRects++;
    }// while( lNumRects-- )
}// vDownloadNative()

//-----------------------------------------------------------------------------
//
// VOID vDowload4Bpp(GFNPB* ppb)
//
// Does a download of a 4bpp surface for a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------

ULONG   gDownload4BppEnabled = 1;

#if 0
VOID
vDownload4Bpp(GFNPB* ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    DWORD   dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_SYNC_ON_HOST_DATA;
    BYTE*   pbSrcStart = (BYTE *) ppb->psoSrc->pvScan0;
    LONG    lSrcStride = ppb->psoSrc->lDelta;
    ULONG   ulOffset = ((pptlSrc->x & 1) -
                        (prclDst->left & ppdev->dwBppMask)) & 0x7;

    if(!gDownload4BppEnabled) return;

    PERMEDIA_DECL_VARS;
    PERMEDIA_DECL_INIT;
    VALIDATE_GDI_CONTEXT;
    
//    P2_CHECK_STATE;

    P2_DEFAULT_FB_DEPTH;

    // setup loop invariant state
    WAIT_INPUT_FIFO(4);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    if(ppdev->cPelSize < 2)
    {
        SEND_PERMEDIA_DATA(FBReadMode, psurfDst->ulPackedPP |
                                      PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE) |
                                      PM_FBREADMODE_RELATIVEOFFSET(ulOffset));
    }
    else
    {
        // Do we even need this at all???
        SEND_PERMEDIA_DATA(FBReadMode, psurfDst->ulPackedPP);
    }

    SEND_PERMEDIA_DATA(FBWindowBase, psurfDst->ulPixOffset);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    DEXE_INPUT_FIFO();

    while(c--) {

        LONG    lSrcLeft = pptlSrc->x + (prcl->left - prclDst->left);
        LONG    lSrcTop = pptlSrc->y + (prcl->top - prclDst->top);

        ASSERTDD(lSrcLeft >= 0, "ugh");
        ASSERTDD(lSrcTop >= 0, "ugh");

        // Render the rectangle

        ULONG left = prcl->left >> ppdev->bBppShift;
        ULONG right = (prcl->right + ppdev->dwBppMask) >> ppdev->bBppShift;
        ULONG width = right - left;
        ULONG count = prcl->bottom - prcl->top; 

        WAIT_INPUT_FIFO((ppdev->cPelSize < 2 ? 6 : 5));
        
        SEND_PERMEDIA_DATA(StartXDom, left << 16);
        SEND_PERMEDIA_DATA(StartXSub, right << 16);
        if(ppdev->cPelSize < 2)
        {
            SEND_PERMEDIA_DATA(PackedDataLimits,
                                    PM_PACKEDDATALIMITS_OFFSET(ulOffset) 
                                  | (prcl->left << 16) | prcl->right);
        }
        SEND_PERMEDIA_DATA(StartY, prcl->top << 16);
        SEND_PERMEDIA_DATA(Count, count);
        SEND_PERMEDIA_DATA(Render, dwRenderBits);

        DEXE_INPUT_FIFO();

        BYTE *  srcScan = (BYTE *)(pbSrcStart + (lSrcTop * lSrcStride))
                    + (lSrcLeft >> 1);
        ULONG*  aulXlate = ppb->pxlo->pulXlate;

        while(count--)
        {
            LONG    remaining = width;
            ULONG*  lp = pPermedia->GetDMAPtr(width+1);
            BYTE*   src = srcScan;

            *lp++ = __Permedia2TagColor | ((width-1) << 16);
            
            switch(ppdev->cPelSize)
            {
            case 0:

                while(remaining-- > 0)
                {
    
                    *lp++ = aulXlate[src[0] & 0x0F] |
                           (aulXlate[(src[0] & 0xF0) >> 4] << 8) |
                           (aulXlate[src[1] & 0xf] << 16) |
                           (aulXlate[(src[1] & 0xf0) >> 4] << 24);

                    src += 2;
                }

                break;

            case 1:
            
                while(remaining >= 8)
                {
                    remaining -= 8;
                    lp[0] = aulXlate[src[0] & 0x0F] | (aulXlate[(src[0] & 0xF0) >> 4] << 16);
                    lp[1] = aulXlate[src[1] & 0x0F] | (aulXlate[(src[1] & 0xF0) >> 4] << 16);
                    lp[2] = aulXlate[src[2] & 0x0F] | (aulXlate[(src[2] & 0xF0) >> 4] << 16);
                    lp[3] = aulXlate[src[3] & 0x0F] | (aulXlate[(src[3] & 0xF0) >> 4] << 16);
                    lp[4] = aulXlate[src[4] & 0x0F] | (aulXlate[(src[4] & 0xF0) >> 4] << 16);
                    lp[5] = aulXlate[src[5] & 0x0F] | (aulXlate[(src[5] & 0xF0) >> 4] << 16);
                    lp[6] = aulXlate[src[6] & 0x0F] | (aulXlate[(src[6] & 0xF0) >> 4] << 16);
                    lp[7] = aulXlate[src[7] & 0x0F] | (aulXlate[(src[7] & 0xF0) >> 4] << 16);
                    lp+=8;
                    src+=8;
                }

                while(remaining-- > 0)
                {
                    *lp++ = aulXlate[src[0] & 0x0F] | (aulXlate[(src[0] & 0xF0) >> 4] << 16);
                    src++;
                }
                
                break;
            
            case 2:
            
                if(lSrcLeft & 1)
                {
                    *lp++ = aulXlate[(src[0] & 0xf0) >> 4];
                    src++;
                    remaining--;
                }

                while(remaining >= 8)
                {
                    remaining -= 8;
                    lp[0] = aulXlate[src[0] & 0x0F];
                    lp[1] = aulXlate[(src[0] & 0xf0) >> 4];
                    lp[2] = aulXlate[src[1] & 0x0F];
                    lp[3] = aulXlate[(src[1] & 0xf0) >> 4];
                    lp[4] = aulXlate[src[2] & 0x0F];
                    lp[5] = aulXlate[(src[2] & 0xf0) >> 4];
                    lp[6] = aulXlate[src[3] & 0x0F];
                    lp[7] = aulXlate[(src[3] & 0xf0) >> 4];

                    src+=4;
                    lp += 8;
                }
                
                while(remaining > 1)
                {
                    remaining -= 2;
                    *lp++ = aulXlate[src[0] & 0x0F];
                    *lp++ = aulXlate[(src[0] & 0xf0) >> 4];

                    src++;
                }

                if(remaining)
                {
                    *lp++ = aulXlate[src[0] & 0xf];
                }
                
                break;
            
            }

            srcScan += lSrcStride;

            pPermedia->DoneDMAPtr();

        }
                
        prcl++;
    }

}// vDownload4Bpp()
#endif

//-----------------------------------------------------------------------------
//
// VOID vDowload4Bpp(GFNPB* ppb)
//
// Does a download of a 4bpp surface for a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------

VOID
vDownload24Bpp(GFNPB* ppb)
{
#if 0
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    DWORD   dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                       | __RENDER_SYNC_ON_HOST_DATA;
    BYTE*   pbSrcStart = (BYTE*)ppb->psoSrc->pvScan0;
    LONG    lSrcStride = ppb->psoSrc->lDelta;
    ULONG   ulOffset = ((pptlSrc->x & ppdev->dwBppMask)
                     - (prclDst->left & ppdev->dwBppMask)) & 0x7;

    PERMEDIA_DECL_VARS;
    PERMEDIA_DECL_INIT;
    VALIDATE_GDI_CONTEXT;
    
    P2_CHECK_STATE;

    P2_DEFAULT_FB_DEPTH;

    // setup loop invariant state
    WAIT_INPUT_FIFO(4);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBReadMode, psurfDst->ulPackedPP |
                                  PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE) |
                                  PM_FBREADMODE_RELATIVEOFFSET(ulOffset));
    SEND_PERMEDIA_DATA(FBWindowBase, psurfDst->ulPixOffset);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    DEXE_INPUT_FIFO();

    while(c--)
    {
        LONG    lSrcLeft = pptlSrc->x + (prcl->left - prclDst->left);
        LONG    lSrcTop = pptlSrc->y + (prcl->top - prclDst->top);

        ASSERTDD(lSrcLeft >= 0, "ugh");
        ASSERTDD(lSrcTop >= 0, "ugh");

        // Render the rectangle

        ULONG left = prcl->left >> ppdev->bBppShift;
        ULONG right = (prcl->right + ppdev->dwBppMask) >> ppdev->bBppShift;
        ULONG width = right - left;
        ULONG count = prcl->bottom - prcl->top; 

        WAIT_INPUT_FIFO(6);
        
        SEND_PERMEDIA_DATA(StartXDom, left << 16);
        SEND_PERMEDIA_DATA(StartXSub, right << 16);
        SEND_PERMEDIA_DATA(PackedDataLimits,
                                PM_PACKEDDATALIMITS_OFFSET(ulOffset) 
                              | (prcl->left << 16) | prcl->right);
        SEND_PERMEDIA_DATA(StartY, prcl->top << 16);
        SEND_PERMEDIA_DATA(Count, count);
        SEND_PERMEDIA_DATA(Render, dwRenderBits);

        DEXE_INPUT_FIFO();

        ULONG * src = (ULONG *) (pbSrcStart + (lSrcTop * lSrcStride)
                    + ((lSrcLeft & ~(ppdev->dwBppMask)) << ppdev->cPelSize));

        #if 0
        BLKLD_INPUT_FIFO_LINES(__Permedia2TagColor, src, width, count, lSrcStride); 
        #else
        while(count--)
        {
            ULONG   i;
            for(i=0; i<width; i++)
            {
                WAIT_INPUT_FIFO(1);
                SEND_PERMEDIA_DATA(Color, 0);
                EXE_INPUT_FIFO();
            }
        }
        #endif
        
        prcl++;
    }
#endif
}// vDownload24Bpp()

//-----------------------------------------------------------------------------
//
// VOID vUploadNative
//
// Does a VM-to-SM copy of a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------
VOID
vUploadNative(GFNPB* ppb)
{
    PDev*       ppdev = ppb->ppdev;
    POINTL*     pptlSrc = ppb->pptlSrc;
    RECTL*      prclDst = ppb->prclDst;
    RECTL*      pRects = ppb->pRects;
    Surf*       psurfSrc = ppb->psurfSrc;
    SURFOBJ*    psoDst = ppb->psoDst;
    
    BYTE*       pbDst;
    BYTE*       pbDstStart = (BYTE*)psoDst->pvScan0;
    BYTE*       pbSrc;
    BYTE*       pbSrcStart = (BYTE*)ppdev->pjScreen + psurfSrc->ulByteOffset;
    
    LONG        lDstStride = psoDst->lDelta;
    LONG        lNumRects = ppb->lNumRects;
    LONG        lSrcStride = psurfSrc->lDelta;

    InputBufferSync(ppdev);
    DBG_GDI((6, "vUploadNative called"));

    while( lNumRects-- )
    {
        LONG    lWidthInBytes = (pRects->right - pRects->left) 
                              << ppdev->cPelSize;
        LONG    lHeight = pRects->bottom - pRects->top;
        LONG    lSrcX = pptlSrc->x + (pRects->left - prclDst->left);
        LONG    lSrcY = pptlSrc->y + (pRects->top - prclDst->top);

        if( (lWidthInBytes != 0) && (lHeight != 0) )
        {
            pbSrc = pbSrcStart + (lSrcX << ppdev->cPelSize); // Offset in Bytes
            pbSrc += (lSrcY * lSrcStride);               // Add vertical offset
            pbDst = pbDstStart + (pRects->left << ppdev->cPelSize);
            pbDst += (pRects->top * lDstStride);

            //
            // Up to this point, "pbSrc" points to the beginning of the bits
            // needs to be copied and "pbDst" points to the position for the
            // receiving bits
            //
            // Now copy it row by row, vertically
            //
            while( lHeight-- )
            {
                LONG    lCount = lWidthInBytes;

                //
                // If the source address is not DWORD aligned,
                // (pbSrc & 0x3 != 0), then we copy these bytes first until
                // it reaches DWORD aligned condition
                //
                // The reason we are doing alignment is unaligned DWORD reads
                // are twice as expensive as aligned reads
                //
                while( (((ULONG_PTR)pbSrc & 0x3)) && (lCount > 0) )
                {
                    *pbDst++ = *pbSrc++;
                    lCount--;
                }

                //
                // Up to this point, the source should be DWORD aligned. So we
                // can start to do uploading at DWORD level till there are less
                // than bytes left
                //
                ULONG* pulSrc = (ULONG*)pbSrc;
                ULONG* pulDst = (ULONG*)pbDst;

                while( lCount >= 4 )
                {
                    *(ULONG UNALIGNED*)pulDst++ = *pulSrc++;
                    lCount -= 4;
                }

                //
                // Now copy the last several left over bytes
                //
                pbSrc = (BYTE*)pulSrc;
                pbDst = (BYTE*)pulDst;

                while( lCount > 0 )
                {
                    *pbDst++ = *pbSrc++;
                    lCount--;
                }

                //
                // Move onto next line
                //
                pbSrc += (lSrcStride - lWidthInBytes);
                pbDst += (lDstStride - lWidthInBytes);
            }// while( lHeight-- )
        }// if( (lWidthInBytes != 0) && (lHeight != 0) )

        pRects++;
    }// while( lNumRects-- )
}// vUploadNative
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\draw.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: draw.c
*
* Contains the DrvFillPath routine. Permedia P2 optimised functions
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"

//-----------------------------------------------------------------------------
//
// void vAlphaBlendDownload(GFNPB * ppb)
//
// Doing an alpha blend on a source surface which is in a pre-multiplied alpha
// 32bpp "BGRA" format; that is, the surface type is BMF_32BPP and the palette
// type is BI_RGB.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psoSrc------Pointer to source SURFOBJ
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  ucAlpha-----Alpha value
//
//-----------------------------------------------------------------------------
VOID
vAlphaBlendDownload(GFNPB * ppb)
{
    PDev*       ppdev = ppb->ppdev;
    Surf*       psurfDst = ppb->psurfDst;
    RECTL*      prcl = ppb->pRects;
    LONG        c = ppb->lNumRects;
    RECTL*      prclDst = ppb->prclDst;
    RECTL*      prclSrc = ppb->prclSrc;
    DWORD       dwRenderDirection;
    UCHAR       ucAlpha = ppb->ucAlpha;
    SURFOBJ*    psoSrc = ppb->psoSrc;
    ULONG*      pBuffer;

    DBG_GDI((6, "vAlphaBlendDownload called"));

    ASSERTDD(ppdev->cPelSize != 0,
        "vAlphaBlend: expect not to be in 8bpp mode");

    ASSERTDD(psoSrc->iBitmapFormat == BMF_32BPP,
        "vAlphaBlend: expect source bitmap format to be 32bpp");

    InputBufferReserve(ppdev, 20, &pBuffer);

    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[2] = __Permedia2TagAlphaBlendMode;
    pBuffer[3] = (1 << PM_ALPHABLENDMODE_BLENDTYPE) | // ramp
                 (1 << PM_ALPHABLENDMODE_COLORORDER) | // RGB
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (81 << PM_ALPHABLENDMODE_OPERATION) | // PreMult
                 (ppdev->ulPermFormat << PM_ALPHABLENDMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_ALPHABLENDMODE_COLORFORMATEXTENSION);
    
    // Reject range
    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] =  psurfDst->ulPixOffset;
   
    // set no read of source.
    pBuffer[6] = __Permedia2TagFBReadMode;
    pBuffer[7] =   0x400 | psurfDst->ulPackedPP;

    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    
    pBuffer[10] = __Permedia2TagTextureColorMode;
    pBuffer[11] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB 
                 (0 << 1) ; // Modulate

    pBuffer[12] = __Permedia2TagTextureDataFormat;
    pBuffer[13] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                 (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                 (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  1;

    pBuffer[16] = __Permedia2TagConstantColor;
    pBuffer[17] = ucAlpha << 24 | ucAlpha << 16 | ucAlpha << 8 | ucAlpha;

    pBuffer[18] = __Permedia2TagTextureReadMode;
    pBuffer[19] = PM_TEXREADMODE_ENABLE(__PERMEDIA_DISABLE);

    pBuffer += 20;
    
    InputBufferCommit(ppdev, pBuffer);
    
    while(c--)
    {
        
        InputBufferReserve(ppdev, 12, &pBuffer);
        
        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  prcl->left << 16;
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] =  prcl->right << 16;
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] =     prcl->top << 16;
        pBuffer[6] = __Permedia2TagdY;
        pBuffer[7] =         1 << 16;
        pBuffer[8] = __Permedia2TagCount;
        pBuffer[9] =      prcl->bottom - prcl->top;
        pBuffer[10] = __Permedia2TagRender;
        pBuffer[11] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE
                    | __RENDER_SYNC_ON_HOST_DATA;

        pBuffer += 12;
        
        InputBufferCommit(ppdev, pBuffer);

        // download data

        {
            LONG    xOffset = prclSrc->left + (prcl->left - prclDst->left);
            LONG    yOffset = prclSrc->top + (prcl->top - prclDst->top);
            ULONG * pulTexel = (ULONG *) psoSrc->pvScan0;
            ULONG   ulWidth = prcl->right - prcl->left;
            ULONG   ulHeight = prcl->bottom - prcl->top;
            LONG    ulPixDelta = psoSrc->lDelta >> 2;
            LONG    ulScanSkip = ulPixDelta - ulWidth;
            ULONG*  pulSentinel;

            ASSERTDD(psoSrc->pvScan0 != NULL, "pvScan0 is null");
            ASSERTDD((psoSrc->lDelta & 3) == 0, "lDelta not multiple of four");
            ASSERTDD(xOffset >= 0, "xOffset is negative");
            ASSERTDD(yOffset >= 0, "yOffset is negative");
            ASSERTDD(ulWidth < MAX_INPUT_BUFFER_RESERVATION,
                        "vAlphaBlendDownload: width is too large");

            pulTexel += xOffset;
            pulTexel += ulPixDelta * yOffset;

            while(ulHeight--)
            {
                 pulSentinel = pulTexel + ulWidth;

                 InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                 *pBuffer++ = __Permedia2TagTexel0 | ((ulWidth - 1) << 16);

                 while(pulTexel < pulSentinel)
                 {
                     ULONG  texel = *pulTexel++;

                     *pBuffer++ =  SWAP_BR(texel);
                 }

                 InputBufferCommit(ppdev, pBuffer);

                 pulTexel += ulScanSkip;
            }
                
        }

        prcl++;

    }

    //
    // Always restore default state
    //
    InputBufferReserve(ppdev, 16, &pBuffer);
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] =  __PERMEDIA_DISABLE;
    pBuffer[12] = __Permedia2TagAlphaBlendMode;
    pBuffer[13] =  __PERMEDIA_DISABLE;
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  __PERMEDIA_DISABLE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

}// vAlphaBlend()

//-----------------------------------------------------------------------------
//
// void vConstantAlphaBlend(GFNPB * ppb)
//
// Using constant blend factor to apply to the entire source surface
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  ucAlpha-----Alpha value
//
//-----------------------------------------------------------------------------
VOID
vConstantAlphaBlend(GFNPB * ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*  psurfSrc = ppb->psurfSrc;
    Surf*  psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    RECTL*  prclSrc = ppb->prclSrc;
    DWORD   dwRenderDirection;
    UCHAR   alpha = ppb->ucAlpha;
    ULONG*  pBuffer;
     

    DBG_GDI((6,"vConstantAlphaBlend called"));

    ASSERTDD(ppdev->cPelSize != 0,
        "vAlphaBlend: expect not to be in 8bpp mode");

    // setup loop invariant state

    InputBufferReserve(ppdev, 26, &pBuffer);
    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[2] = __Permedia2TagAlphaBlendMode;
    pBuffer[3] = ppdev->ulPermFormat << 8 |
                 ppdev->ulPermFormatEx << 16 |
                 ( 1 << 0 ) | // enable blending
                 ( 1 << 13) | // color order: BGR=0, RGB=1
                 ( 1 << 14) | // BlendType: RGB=0, Ramp=1
                 (84 << 1);   // Operation: Blend=84, PreMult=81
        

    
    // Reject range
    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] =  psurfDst->ulPixOffset;
    
    // set no read of source.
    pBuffer[6] = __Permedia2TagFBReadMode;
    pBuffer[7] =  0x400   // read destination enable
               | psurfDst->ulPackedPP;
    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    
    // set base of source
    pBuffer[10] = __Permedia2TagTextureBaseAddress;
    pBuffer[11] =  psurfSrc->ulPixOffset;
    pBuffer[12] = __Permedia2TagTextureAddressMode;
    pBuffer[13] = (1 << PM_TEXADDRESSMODE_ENABLE);
    
    pBuffer[14] = __Permedia2TagTextureColorMode;
    pBuffer[15] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (0 << 1);  // Modulate
    
    pBuffer[16] = __Permedia2TagTextureReadMode;
    pBuffer[17] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                 PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                 PM_TEXREADMODE_WIDTH(11) |
                 PM_TEXREADMODE_HEIGHT(11);
    
    pBuffer[18] = __Permedia2TagTextureDataFormat;
    pBuffer[19] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                 (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                 (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER) |
                 (1 << 4); // no alpha
    
    pBuffer[20] = __Permedia2TagTextureMapFormat;
    pBuffer[21] = (psurfSrc->ulPackedPP) | 
                 (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);


    pBuffer[22] = __Permedia2TagColorDDAMode;
    pBuffer[23] =  1;
    pBuffer[24] = __Permedia2TagConstantColor;
    pBuffer[25] =  alpha << 24 | 0xffffff ;

    pBuffer += 26;

    InputBufferCommit(ppdev, pBuffer);

    while(c--)
    {
        
        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        
        rSrc.left = prclSrc->left + (rDest.left - prclDst->left);
        rSrc.top = prclSrc->top + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }
        
//@@BEGIN_DDKSPLIT
        // TODO: remove some of the magic values
//@@END_DDKSPLIT
        if (psurfSrc->ulPixOffset != psurfDst->ulPixOffset)
        {
            dwRenderDirection = 1;
        }
        else
        {
            if(rSrc.top < rDest.top)
            {
                dwRenderDirection = 0;
            }
            else if(rSrc.top > rDest.top)
            {
                dwRenderDirection = 1;
            }
            else if(rSrc.left < rDest.left)
            {
                dwRenderDirection = 0;
            }
            else dwRenderDirection = 1;
        }
        
        InputBufferReserve(ppdev, 24, &pBuffer);
        
        // Left -> right, top->bottom
        if (dwRenderDirection)
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.left << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     rSrc.top << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       1 << 20;
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    1 << 20;
        
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.left << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.right << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     rDest.top << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         1 << 16;
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }
        else
        // right->left, bottom->top
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.right << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     (rSrc.bottom - 1) << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       (DWORD)(-1 << 20);
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    (DWORD)(-1 << 20);
        
            // Render right to left, bottom to top
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.right << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.left << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     (rDest.bottom - 1) << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         (DWORD)(-1 << 16);
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }

        pBuffer += 24;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;

    }

    InputBufferReserve(ppdev, 20, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] =  __PERMEDIA_DISABLE;
    pBuffer[12] = __Permedia2TagAlphaBlendMode;
    pBuffer[13] =  __PERMEDIA_DISABLE;
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  __PERMEDIA_DISABLE;
    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] =  __PERMEDIA_DISABLE;
    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] =  __PERMEDIA_DISABLE;

    pBuffer += 20;

    InputBufferCommit(ppdev, pBuffer);

}// vConstantAlphaBlend()

//-----------------------------------------------------------------------------
//
// void vAlphaBlend(GFNPB * ppb)
//
// Doing an alpha blend on a source surface which is in a pre-multiplied alpha
// 32bpp "BGRA" format; that is, the surface type is BMF_32BPP and the palette
// type is BI_RGB.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  ucAlpha-----Alpha value
//
//-----------------------------------------------------------------------------
VOID
vAlphaBlend(GFNPB * ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfSrc = ppb->psurfSrc;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    RECTL*  prclSrc = ppb->prclSrc;
    DWORD   dwRenderDirection;
    UCHAR   ucAlpha = ppb->ucAlpha;
    ULONG*      pBuffer;

    DBG_GDI((6, "vAlphaBlend called"));
    
    DBG_GDI((7,"vAlphaBlend"));

    ASSERTDD(ppdev->cPelSize != 0,
        "vAlphaBlend: expect not to be in 8bpp mode");

    InputBufferReserve(ppdev, 26, &pBuffer);

    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[2] = __Permedia2TagAlphaBlendMode;
    pBuffer[3] = (1 << PM_ALPHABLENDMODE_BLENDTYPE) | // ramp
                 (1 << PM_ALPHABLENDMODE_COLORORDER) | // RGB
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (81 << PM_ALPHABLENDMODE_OPERATION) | // PreMult
                 (ppdev->ulPermFormat << PM_ALPHABLENDMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_ALPHABLENDMODE_COLORFORMATEXTENSION);
    
    // Reject range
    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] =  psurfDst->ulPixOffset;
    
    // set no read of source.
    pBuffer[6] = __Permedia2TagFBReadMode;
    pBuffer[7] =   0x400 | psurfDst->ulPackedPP;
    
    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    
    // set base of source
    pBuffer[10] = __Permedia2TagTextureBaseAddress;
    pBuffer[11] =  psurfSrc->ulPixOffset;
    
    pBuffer[12] = __Permedia2TagTextureAddressMode;
    pBuffer[13] = (1 << PM_TEXADDRESSMODE_ENABLE);
    
    pBuffer[14] = __Permedia2TagTextureColorMode;
    pBuffer[15] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (0 << 1);  // Modulate
    
    pBuffer[16] = __Permedia2TagTextureReadMode;
    pBuffer[17] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                  PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                  PM_TEXREADMODE_WIDTH(11) |
                  PM_TEXREADMODE_HEIGHT(11);
    
    pBuffer[18] = __Permedia2TagTextureDataFormat;
    pBuffer[19] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                  (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                  (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[20] = __Permedia2TagTextureMapFormat;
    pBuffer[21] = (psurfSrc->ulPackedPP) | 
                  (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);
    
    pBuffer[22] = __Permedia2TagColorDDAMode;
    pBuffer[23] =  1;

    pBuffer[24] = __Permedia2TagConstantColor;
    pBuffer[25] = ucAlpha << 24 | ucAlpha << 16 | ucAlpha << 8 | ucAlpha;

    pBuffer += 26;

    InputBufferCommit(ppdev, pBuffer);
    
    while(c--)
    {
        
        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        
        rSrc.left = prclSrc->left + (rDest.left - prclDst->left);
        rSrc.top = prclSrc->top + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }
        
//@@BEGIN_DDKSPLIT
        // TODO: use continuation to save permedia writes

        // TODO: remove some of the magic values
//@@END_DDKSPLIT
        if (psurfSrc->ulPixOffset != psurfDst->ulPixOffset)
        {
            dwRenderDirection = 1;
        }
        else
        {
            if(rSrc.top < rDest.top)
            {
                dwRenderDirection = 0;
            }
            else if(rSrc.top > rDest.top)
            {
                dwRenderDirection = 1;
            }
            else if(rSrc.left < rDest.left)
            {
                dwRenderDirection = 0;
            }
            else dwRenderDirection = 1;
        }
        
        /*
         * Render the rectangle
         */
        
        InputBufferReserve(ppdev, 24, &pBuffer);
        
        // Left -> right, top->bottom
        if (dwRenderDirection)
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.left << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     rSrc.top << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       1 << 20;
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    1 << 20;
        
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.left << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.right << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     rDest.top << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         1 << 16;
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }
        else
        // right->left, bottom->top
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.right << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     (rSrc.bottom - 1) << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       (DWORD)(-1 << 20);
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    (DWORD)(-1 << 20);
        
            // Render right to left, bottom to top
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.right << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.left << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     (rDest.bottom - 1) << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         (DWORD)(-1 << 16);
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }
        
        pBuffer += 24;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;

    }

    //
    // Always restore default state
    //
    InputBufferReserve(ppdev, 16, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] =  __PERMEDIA_DISABLE;
    pBuffer[12] = __Permedia2TagAlphaBlendMode;
    pBuffer[13] =  __PERMEDIA_DISABLE;
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  __PERMEDIA_DISABLE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

}// vAlphaBlend()

//-----------------------------------------------------------------------------
//
// VOID vCopyBlt(GFNPB* ppb)
//
// Does a screen-to-screen copy blt of a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------

VOID
vCopyBlt(GFNPB* ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*  psurfSrc = ppb->psurfSrc;
    Surf*  psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    DWORD   renderBits = __RENDER_TRAPEZOID_PRIMITIVE;
    DWORD   offset;
    LONG    sourceOffset;
    DWORD   windowBase;
    LONG    windowOffset;
    ULONG   DestPitch = psurfDst->ulPixDelta;
    ULONG   SourcePitch = psurfSrc->ulPixDelta;
    BOOL    bEnablePacked = TRUE;
    ULONG   ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);

    DBG_GDI((6, "vCopyBlt called"));

    windowBase = psurfDst->ulPixOffset;
    windowOffset = (LONG) (psurfSrc->ulPixOffset - psurfDst->ulPixOffset);

    
    // BUGFIX: Permedia hardware bug
    // We can not enable if we have an overlapping blt with not vertical shift
    // and a horizontal shift less or equal to ppdev->dwBppMask
    if (psurfSrc == psurfDst && prclDst->top == pptlSrc->y)
    {
        LONG    xShift = prclDst->left - pptlSrc->x;

        if(xShift >= 0 && xShift <= (LONG) ppdev->dwBppMask)
            bEnablePacked = FALSE;
    }

    // BUGFIX: Permedia hardware bug???
    // We have intermittent failures of the copy operation
    // when going from the screen to offscreen where the first
    // four bytes (when in 8bpp) of every row are not copied.
    // For now, I'm disabling until we can talk with the permedia folks.
    bEnablePacked = FALSE;

    // setup loop invariant state
    ULONG*  pBuffer;

    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = windowBase;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    while(c--) {

        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;

        rSrc.left = pptlSrc->x + (rDest.left - prclDst->left);
        rSrc.top = pptlSrc->y + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }

        if(bEnablePacked)
        {
            offset = (((rDest.left & ppdev->dwBppMask) 
                        - (rSrc.left & ppdev->dwBppMask)) & 7);
            sourceOffset = windowOffset 
              + ((rSrc.top * SourcePitch) + (rSrc.left & ~(ppdev->dwBppMask)))
              - ((rDest.top * DestPitch) + (rDest.left & ~(ppdev->dwBppMask)))
              + ((DestPitch - SourcePitch) * rDest.top);
       }
        else
        {
            offset = 0;
            sourceOffset = windowOffset + ((rSrc.top * SourcePitch) + rSrc.left)
                                       - ((rDest.top * DestPitch) + rDest.left)
                                      + ((DestPitch - SourcePitch) * rDest.top);
        }
        
//        P2_DEFAULT_FB_DEPTH;

        ULONG readMode = PM_FBREADMODE_PARTIAL(psurfSrc->ulPackedPP) |
                         PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)   |
                         PM_FBREADMODE_RELATIVEOFFSET(offset) |
                         LogicopReadDest[ulLogicOP];

        ULONG writeConfig = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP) |
                          PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)   |
                          PM_FBREADMODE_RELATIVEOFFSET(offset) |
                          LogicopReadDest[ulLogicOP];
                           

        if(bEnablePacked)
        {
            readMode |= PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE);
            writeConfig |= PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE);
        }
    
        // Render the rectangle

        ULONG startXDom;
        ULONG startXSub;
        ULONG packedDataLimits;
        ULONG startY;
        ULONG dy;
    
        if (sourceOffset >= 0) {
            // Use left to right and top to bottom

            if(bEnablePacked)
            {
                startXDom = (rDest.left >> ppdev->bBppShift) << 16;
                startXSub = ((rDest.right >> ppdev->bBppShift) 
                          + ppdev->dwBppMask) << 16;
            
                packedDataLimits = PM_PACKEDDATALIMITS_OFFSET(offset)     |
                                   PM_PACKEDDATALIMITS_XSTART(rDest.left) |
                                   PM_PACKEDDATALIMITS_XEND(rDest.right);
            }
            else
            {
                startXDom = rDest.left  << 16;
                startXSub = rDest.right << 16;
            }

            startY =  rDest.top << 16;
            dy = 1 << 16;
        }
        else
        {
            // Use right to left and bottom to top

            if(bEnablePacked)
            {
                startXDom = (((rDest.right) >> ppdev->bBppShift) 
                          + ppdev->dwBppMask) << 16; 
                startXSub = (rDest.left >> ppdev->bBppShift) << 16;
                packedDataLimits = PM_PACKEDDATALIMITS_OFFSET(offset) |
                                   PM_PACKEDDATALIMITS_XSTART(rDest.right) |
                                   PM_PACKEDDATALIMITS_XEND(rDest.left);
            }
            else
            {
                startXDom =  rDest.right << 16; 
                startXSub = rDest.left << 16;
            }
            
            startY = (rDest.bottom - 1) << 16;
            dy = (DWORD)((-1) << 16);
        }
    
        ULONG count = rDest.bottom - rDest.top; 
        
        InputBufferReserve(ppdev, 18, &pBuffer);

        pBuffer[0] = __Permedia2TagFBSourceOffset;
        pBuffer[1] =  sourceOffset;
        pBuffer[2] = __Permedia2TagFBReadMode;
        pBuffer[3] =  readMode;
        pBuffer[4] = __Permedia2TagFBWriteConfig;
        pBuffer[5] =  writeConfig;
        pBuffer[6] = __Permedia2TagStartXDom;
        pBuffer[7] =  startXDom;
        pBuffer[8] = __Permedia2TagStartXSub;
        pBuffer[9] =  startXSub;
        
#if 0        
        if(bEnablePacked)
        {
            pBuffer[0] = __Permedia2TagPackedDataLimits;
            pBuffer[1] =  packedDataLimits;
        }
#endif
        pBuffer[10] = __Permedia2TagStartY;
        pBuffer[11] =  startY;
        pBuffer[12] = __Permedia2TagdY;
        pBuffer[13] =  dy;
        pBuffer[14] = __Permedia2TagCount;
        pBuffer[15] =  count;
        pBuffer[16] = __Permedia2TagRender;
        pBuffer[17] =  renderBits;

        pBuffer += 18;

        InputBufferCommit(ppdev, pBuffer);


        prcl++;
    }

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] = INTtoFIXED(1);

    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);

}// vCopyBlt()

//-----------------------------------------------------------------------------
//
// VOID vCopyBltNative(GFNPB* ppb)
//
// Does a screen-to-screen copy blt of a list of rectangles.
//
// Note: The difference between this function and vCopyBlt() is that this
// function will be called only when the source and dest has the same pitch
// size. The reason is that we are using the Permedia2 packed data feature to
// do a 32 bits copy. Unfortunately when the source and dest has the different
// pitch, the hardware has some problems to implement it right. So in
// vCopyBlt(), we have to disable PackedData copy which slows down a lot
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------
VOID
vCopyBltNative(GFNPB* ppb)
{
    PDev*   ppdev = ppb->ppdev;
    
    Surf*   psurfDst = ppb->psurfDst;
    Surf*   psurfSrc = ppb->psurfSrc;
    
    RECTL*  prcl = ppb->pRects;
    RECTL*  prclDst = ppb->prclDst;
    
    POINTL* pptlSrc = ppb->pptlSrc;
    
    LONG    lNumRects = ppb->lNumRects;
    LONG    lSourceOffset;
    LONG    lWindowOffset;
    
    DWORD   dwOffset;
    ULONG   ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);
    ULONG   ulPitch = psurfDst->ulPixDelta;

    DBG_GDI((6, "vCopyBltNative called, ulPitch=%d", ulPitch));

    lWindowOffset = (LONG)(psurfSrc->ulPixOffset - psurfDst->ulPixOffset);

    //
    // Setup loop invariant state
    //
    ULONG*  pBuffer;

    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = psurfDst->ulPixOffset;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    while( lNumRects-- )
    {
        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        rSrc.left = pptlSrc->x + (rDest.left - prclDst->left);
        rSrc.top = pptlSrc->y + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if ( rSrc.top < 0 )
        {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }

        if ( rSrc.left < 0 )
        {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }

        dwOffset = (((rDest.left & ppdev->dwBppMask)
                 - (rSrc.left & ppdev->dwBppMask)) & 7);
        lSourceOffset = lWindowOffset
                      + ( (rSrc.top - rDest.top) * ulPitch )
                      + ( rSrc.left & ~(ppdev->dwBppMask) )
                      - ( rDest.left & ~(ppdev->dwBppMask) );

        //
        // Render the rectangle
        //
        ULONG ulStartXDom;
        ULONG ulStartXSub;
        ULONG ulPackedDataLimits;
        ULONG ulStartY;
        ULONG ulDY;

        DBG_GDI((6, "lSourceOffset=%d", lSourceOffset));

        if ( lSourceOffset >= 0 )
        {
            //
            // Use left to right and top to bottom
            //
            ulStartXDom = (rDest.left >> ppdev->bBppShift) << 16;
            ulStartXSub = ((rDest.right >> ppdev->bBppShift)
                        + ppdev->dwBppMask) << 16;

            ulPackedDataLimits = PM_PACKEDDATALIMITS_OFFSET(dwOffset)
                               | (rDest.left << 16)
                               | (rDest.right);

            ulStartY =  rDest.top << 16;
            ulDY = 1 << 16;
        }// if ( lSourceOffset >= 0 )
        else
        {
            //
            // Use right to left and bottom to top
            //
            ulStartXDom = (((rDest.right) >> ppdev->bBppShift)
                        + ppdev->dwBppMask) << 16;
            ulStartXSub = (rDest.left >> ppdev->bBppShift) << 16;
            ulPackedDataLimits = PM_PACKEDDATALIMITS_OFFSET(dwOffset)
                               | (rDest.right << 16)
                               | (rDest.left);

            ulStartY = (rDest.bottom - 1) << 16;
            ulDY = (DWORD)((-1) << 16);
        }// if ( lSourceOffset < 0 )

        InputBufferReserve(ppdev, 18, &pBuffer);

        pBuffer[0] = __Permedia2TagFBSourceOffset;
        pBuffer[1] = lSourceOffset;
        pBuffer[2] = __Permedia2TagFBReadMode;
        pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfSrc->ulPackedPP)
                   | PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)
                   | PM_FBREADMODE_RELATIVEOFFSET(dwOffset)
                   | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)
                   | LogicopReadDest[ulLogicOP];
        pBuffer[4] = __Permedia2TagPackedDataLimits;
        pBuffer[5] = ulPackedDataLimits;
        pBuffer[6] = __Permedia2TagStartXDom;
        pBuffer[7] = ulStartXDom;
        pBuffer[8] = __Permedia2TagStartXSub;
        pBuffer[9] = ulStartXSub;
        pBuffer[10] = __Permedia2TagStartY;
        pBuffer[11] = ulStartY;
        pBuffer[12] = __Permedia2TagdY;
        pBuffer[13] = ulDY;
        pBuffer[14] = __Permedia2TagCount;
        pBuffer[15] = rDest.bottom - rDest.top;
        pBuffer[16] = __Permedia2TagRender;
        pBuffer[17] = __RENDER_TRAPEZOID_PRIMITIVE;

        pBuffer += 18;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;
    }// while( lNumRects-- )

    //
    // Restore dY register value
    //
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] = INTtoFIXED(1);

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);
}// vCopyBltNative()

//-----------------------------------------------------------------------------
//
// VOID vRop2Blt
//
// Does a screen-to-screen blt of a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//  usRop4------Rop4
//
//-----------------------------------------------------------------------------

VOID
vRop2Blt(GFNPB * ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfSrc = ppb->psurfSrc;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    ULONG   ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);
    ULONG*  pBuffer;
    
//    PERMEDIA_DECL_VARS;
//    PERMEDIA_DECL_INIT;


    ASSERTDD(psurfSrc != psurfDst, "vRop2Blt: unexpected psurfSrc == psurfDst");

    InputBufferReserve(ppdev, 32, &pBuffer);
    
    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  psurfDst->ulPixOffset;
    
    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] =  P2_ENABLED_LOGICALOP(ulLogicOP);
    
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    
    pBuffer[6] = __Permedia2TagFBWriteConfig;
    pBuffer[7] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    
    pBuffer[8] = __Permedia2TagDitherMode;
    pBuffer[9] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[10] = __Permedia2TagTextureAddressMode;
    pBuffer[11] = (1 << PM_TEXADDRESSMODE_ENABLE);
    
    pBuffer[12] = __Permedia2TagTextureColorMode;
    pBuffer[13] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (3 << 1);  // Copy
    
    pBuffer[14] = __Permedia2TagTextureReadMode;
    pBuffer[15] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                 PM_TEXREADMODE_WIDTH(11) |
                 PM_TEXREADMODE_HEIGHT(11);
    
    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                 (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                 (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] = (psurfSrc->ulPackedPP) | 
                 (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);
    pBuffer[20] = __Permedia2TagSStart;
    pBuffer[21] =  0;
    pBuffer[22] = __Permedia2TagTStart;
    pBuffer[23] =  0;
    
    pBuffer[24] = __Permedia2TagdSdx;
    pBuffer[25] =       1 << 20;
    pBuffer[26] = __Permedia2TagdSdyDom;
    pBuffer[27] =    0;
    pBuffer[28] = __Permedia2TagdTdx;
    pBuffer[29] =       0;
    pBuffer[30] = __Permedia2TagdTdyDom;
    pBuffer[31] =    1 << 20;

    pBuffer += 32;

    InputBufferCommit(ppdev, pBuffer);
    
    while(c--) {

        // Render the rectangle

        ULONG ulSrcOffset = psurfSrc->ulPixOffset
                          + pptlSrc->x + (prcl->left - prclDst->left)
                          + (pptlSrc->y + (prcl->top - prclDst->top))
                            * psurfSrc->ulPixDelta;

        InputBufferReserve(ppdev, 12, &pBuffer);

        pBuffer[0] = __Permedia2TagTextureBaseAddress;
        pBuffer[1] =  ulSrcOffset;
        pBuffer[2] = __Permedia2TagStartXDom;
        pBuffer[3] =  prcl->left  << 16;
        pBuffer[4] = __Permedia2TagStartXSub;
        pBuffer[5] =  prcl->right << 16;
        pBuffer[6] = __Permedia2TagStartY;
        pBuffer[7] =  prcl->top << 16;
        pBuffer[8] = __Permedia2TagCount;
        pBuffer[9] =  prcl->bottom - prcl->top;
        pBuffer[10] = __Permedia2TagRender;
        pBuffer[11] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE;

        pBuffer += 12;
        
        InputBufferCommit(ppdev, pBuffer);
        
        prcl++;
    }

    // Restore default state
    InputBufferReserve(ppdev, 8, &pBuffer);
    
    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagTextureAddressMode;
    pBuffer[3] =  __PERMEDIA_DISABLE;
    pBuffer[4] = __Permedia2TagTextureColorMode;
    pBuffer[5] =  __PERMEDIA_DISABLE;
    pBuffer[6] = __Permedia2TagTextureReadMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;

    pBuffer += 8;

    InputBufferCommit(ppdev, pBuffer);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\directx.h ===
/******************************Module*Header**********************************\
*
*                           ***********************
*                           * DIRECTX SAMPLE CODE *
*                           ***********************
*
* Module Name: directx.h
*
* Content:     useful constants and definitions for DirectDraw and Direct3d
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __directx__
#define __directx__

//
//  switch to DirectDraw context if necessary.
//  must be used in any DDraw blt function

#define DDCONTEXT  if (ppdev->permediaInfo->pCurrentCtxt != (ppdev->pDDContext)) \
                   {     P2SwitchContext(ppdev, ppdev->pDDContext); }


//
// fourcc codes supported in the driver for blts
#define FOURCC_YUV422     0x32595559    

//  
//  constants for surface privatedata structure
#define P2_CANPATCH                1
#define P2_PPVALID                 2
#define P2_CKVALID                 4
#define P2_SURFACE_FORMAT_VALID    8
#define P2_SURFACE_PRIMARY        16
#define P2_EMULATED_16BITZ        32
#define P2_ISPATCHED              64
#define P2_SURFACE_FORMAT_PALETTE 256
#define P2_SURFACE_NEEDUPDATE   0x00000200  //indicating managed 
                                            //surface content is obsolete

//
//  this magic no. tells us if the surface has already been initialized
#define SURF_MAGIC_NO 0xd3d10110
#define CHECK_P2_SURFACEDATA_VALIDITY(ptr)    \
    ( ((ptr) != NULL) && ((ptr)->MagicNo == SURF_MAGIC_NO) )

// Permedia specific settings for surfaces.
// A pointer to this structure is stored in 
// each surface (in lpGbl->dwReserved1)
typedef struct _permedia_surface_type {
    int PixelSize;              // 
    int PixelShift;
    int PixelMask;
    int FBReadPixel;
    int logPixelSize;
    
    int Format;                 // format description according to 
                                // Permedia 2 manual
    int FormatExtension;        // format extension...
    int ColorComponents;
    int ColorOrder;             // BGR=0, RGB=1
    int Texture16BitMode;

    DWORD RedMask;              // masks of surface, copied from DDPIXELFORMAT
    DWORD GreenMask;
    DWORD BlueMask;
    DWORD AlphaMask;

    BOOL bAlpha;                // surface contains alpha pixels
    BOOL bPreMult;              // surface contains premultiplied alpha !!
} PERMEDIA_SURFACE;

//
//  complete private structure of a surface
typedef struct tagPermediaSurfaceData
{
    DWORD                       MagicNo;    // Magic number to ensure 
                                            // structure is valid
    DWORD                       dwFlags;    // Private flags

    ULONG                       ulPackedPP; // PP values for surface pitch
    
    PERMEDIA_SURFACE            SurfaceFormat;            
    FLATPTR                     fpVidMem;   // store the real vidmem 
                                            // for managed textures
    VIDEOMEMORY*                pvmHeap;    // heap pointer for the managed 
                                            // video texture
    DWORD                       dwPaletteHandle;    
                                            //for video memory surface use
} PermediaSurfaceData;

//
// these constants are used in the PERMEDIA_SURFACE structure,
// Format and FormatExtension
#define PERMEDIA_4BIT_PALETTEINDEX 15
#define PERMEDIA_4BIT_PALETTEINDEX_EXTENSION 0
#define PERMEDIA_8BIT_PALETTEINDEX 14
#define PERMEDIA_8BIT_PALETTEINDEX_EXTENSION 0
#define PERMEDIA_332_RGB 5
#define PERMEDIA_332_RGB_EXTENSION 0
#define PERMEDIA_2321_RGB 9
#define PERMEDIA_2321_RGB_EXTENSION 0
#define PERMEDIA_5551_RGB 1
#define PERMEDIA_5551_RGB_EXTENSION 0
#define PERMEDIA_565_RGB 0
#define PERMEDIA_565_RGB_EXTENSION 1
#define PERMEDIA_8888_RGB 0
#define PERMEDIA_8888_RGB_EXTENSION 0
#define PERMEDIA_888_RGB 4
#define PERMEDIA_888_RGB_EXTENSION 1
#define PERMEDIA_444_RGB 2
#define PERMEDIA_444_RGB_EXTENSION 0
#define PERMEDIA_YUV422 3
#define PERMEDIA_YUV422_EXTENSION 1
#define PERMEDIA_YUV411 2
#define PERMEDIA_YUV411_EXTENSION 1


// 
// Color formating helper defines
// they convert an RGB value in a certain format to a RGB 32 bit value
#define FORMAT_565_32BIT(val) \
( (((val & 0xF800) >> 8) << 16) |\
 (((val & 0x7E0) >> 3) << 8) |\
 ((val & 0x1F) << 3) )

#define FORMAT_565_32BIT_BGR(val)   \
    ( ((val & 0xF800) >> 8) |           \
      (((val & 0x7E0) >> 3) << 8) |     \
      ((val & 0x1F) << 19) )

#define FORMAT_5551_32BIT(val)      \
( (((val & 0x8000) >> 8) << 24) |\
 (((val & 0x7C00) >> 7) << 16) |\
 (((val & 0x3E0) >> 2) << 8) | ((val & 0x1F) << 3) )

#define FORMAT_5551_32BIT_BGR(val)  \
( (((val & 0x8000) >> 8) << 24) |       \
  ((val & 0x7C00) >> 7) |               \
  (((val & 0x3E0) >> 2) << 8) |         \
  ((val & 0x1F) << 19) )

#define FORMAT_4444_32BIT(val)          \
( ((val & 0xF000) << 16) |\
 (((val & 0xF00) >> 4) << 16) |\
 ((val & 0xF0) << 8) | ((val & 0xF) << 4) )

#define FORMAT_4444_32BIT_BGR(val)  \
( ((val & 0xF000) << 16) |              \
  ((val & 0xF00) >> 4) |                \
  ((val & 0xF0) << 8) |                 \
  ((val & 0xF) << 20) )

#define FORMAT_332_32BIT(val)           \
( ((val & 0xE0) << 16) |\
 (((val & 0x1C) << 3) << 8) |\
 ((val & 0x3) << 6) ) 

#define FORMAT_332_32BIT_BGR(val)   \
( (val & 0xE0) |                        \
  (((val & 0x1C) << 3) << 8) |          \
  ((val & 0x3) << 22) )

#define FORMAT_2321_32BIT(val)          \
( ((val & 0x80) << 24) | ((val & 0x60) << 17) |\
 (((val & 0x1C) << 3) << 8) | ((val & 0x3) << 6) ) 

#define FORMAT_2321_32BIT_BGR(val)      \
( ((val & 0x80) << 24) |                \
  ((val & 0x60) << 1) |                 \
  (((val & 0x1C) << 3) << 8) |          \
  ((val & 0x3) << 22) )

#define FORMAT_8888_32BIT_BGR(val)  \
( (val & 0xFF00FF00) | ( ((val & 0xFF0000) >> 16) | ((val & 0xFF) << 16) ) )

#define FORMAT_888_32BIT_BGR(val)   \
( (val & 0xFF00FF00) | ( ((val & 0xFF0000) >> 16) | ((val & 0xFF) << 16) ) )

#define CHROMA_UPPER_ALPHA(val) \
    (val | 0xFF000000)

#define CHROMA_LOWER_ALPHA(val) \
    (val & 0x00FFFFFF)

#define CHROMA_332_UPPER(val) \
    (val | 0x001F1F3F)

#define FORMAT_PALETTE_32BIT(val) \
    ( (val & 0xFF) | ((val & 0xFF) << 8) | ((val & 0xFF) << 16))


//
// Direct Draw related functions
//

VOID 
SetupPrivateSurfaceData(PPDev ppdev, 
                        PermediaSurfaceData* pPrivateData, 
                        LPDDRAWI_DDRAWSURFACE_LCL pSurface);


//-----------------------------------------------------------------------------
//                             AGP related declarations
//-----------------------------------------------------------------------------

//@@BEGIN_DDKSPLIT
//  TODO: implement 32MB AGP heap
//
//@@END_DDKSPLIT

#define P2_AGP_HEAPSIZE     8
#define DD_AGPSURFBASEOFFSET(psurf) \
        (psurf->fpHeapOffset - psurf->lpVidMemHeap->fpStart)

#define DD_AGPSURFACEPHYSICAL(psurf) \
        (ppdev->dwGARTDevBase + DD_AGPSURFBASEOFFSET(psurf))

#define DD_P2AGPCAPABLE(ppdev) \
        (ppdev->dwChipConfig & PM_CHIPCONFIG_AGPCAPABLE)


//@@BEGIN_DDKSPLIT
#if MULTITHREADED
//-----------------------------------------------------------------------------
//
// WRAPMTDXCALLBACK
//
// Generate multithread protected wrapper for Dx callbacks
//
//-----------------------------------------------------------------------------

#define WRAPMTDXCALLBACK(component, name, type, ptr, ppdevaccess)           \
    DWORD CALLBACK                                                          \
    Mt##name( type ptr )                                                    \
    {                                                                       \
        PPDev       ppdev = (PPDev)ppdevaccess;                             \
        DWORD       dwRet;                                                  \
                                                                            \
        if(ppdev->ulLockCount)                                              \
        {                                                                   \
             DBG_##component((MT_LOG_LEVEL,                                 \
                     "Mt" #name ": re-entry! %d", ppdev->ulLockCount));     \
        }                                                                   \
        EngAcquireSemaphore(ppdev->hsemLock);                               \
        ppdev->ulLockCount++;                                               \
                                                                            \
        dwRet = name(ptr);                                                  \
                                                                            \
        ppdev->ulLockCount--;                                               \
        EngReleaseSemaphore(ppdev->hsemLock);                               \
                                                                            \
        return dwRet;                                                       \
    }

#endif  MULTITHREADED
//@@END_DDKSPLIT


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\driver.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* Contains definitions and typedefs common to all driver
* components.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __DRIVER__H__
#define __DRIVER__H__

typedef struct _PDev PDev;          // Handy forward declaration
typedef struct _Surf Surf;          // Handy forward declaration
typedef struct _GFNPB GFNPB;        // Handy forward declaration

typedef VOID (GFN)(GFNPB*);
typedef BOOL (GFNLINE)(PDev*, LONG, LONG, LONG, LONG);
typedef BOOL (GFNINIS)(PDev*, ULONG, DWORD, RECTL*);
typedef VOID (GFNRSTS)(PDev*);

typedef struct _P2DMA P2DMA;
typedef struct tagP2CtxtRec *P2CtxtPtr;
typedef struct _hw_data *HwDataPtr;

// Four byte tag used for tracking memory allocations on a per source
// file basis. (characters are in reverse order). Note if you add any
// new files which call ENGALLOCMEM remember to update this list. This also
// applies if you want to make the allocation tagging more granular than
// file level.

#define ALLOC_TAG_3D2P '3d2p'  // Allocations from d3d.c
#define ALLOC_TAG_6D2P '6d2p'  // Allocations from d3ddx6.c 
#define ALLOC_TAG_SD2P 'sd2p'  // Allocations from d3dstate.c
#define ALLOC_TAG_TD2P 'td2p'  // Allocations from d3dtxman.c
#define ALLOC_TAG_US2P 'us2p'  // Allocations from ddsurf.c
#define ALLOC_TAG_ED2P 'ed2p'  // Allocations from debug.c
#define ALLOC_TAG_NE2P 'ne2p'  // Allocations from enable.c
#define ALLOC_TAG_IF2P 'if2p'  // Allocations from fillpath.c
#define ALLOC_TAG_EH2P 'eh2p'  // Alloactions from heap.c
#define ALLOC_TAG_WH2P 'wh2p'  // Allocations from hwinit.c
#define ALLOC_TAG_XC2P 'xc2p'  // Allocations from p2ctxt.c
#define ALLOC_TAG_AP2P 'ap2p'  // Allocations from palette.c
#define ALLOC_TAG_EP2P 'ep2p'  // Allocations from permedia.c
#define ALLOC_TAG_XT2P 'xt2p'  // Allocations from textout.c


//
// Miscellaneous shared stuff
//
#define DLL_NAME                L"perm2dll" // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "PERM2DLL: "// All debug output is prefixed
                                            // by this string

#define DRIVER_EXTRA_SIZE       0   // Size of the DriverExtra information in
                                    // the DEVMODE structure
#define TMP_BUFFER_SIZE        8192 // Size in bytes of 'pvTmpBuffer'.
                                    // Has to be at least enough to store an
                                    // entire scan line (i.e., 6400 for
                                    // 1600x1200x32).

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


#define INPUT_BUFFER_SIZE (1024 * 64)   // Size in bytes

//@@BEGIN_DDKSPLIT

#define MULTITHREADED   0
#define MT_LOG_LEVEL    6

#if MULTITHREADED && DBG
#define ASSERTLOCK(xppdev, func)                                    \
    {                                                               \
        EngAcquireSemaphore((xppdev)->hsemLock);                      \
        if ((xppdev)->ulLockCount < 1)                                  \
        {                                                           \
            DebugPrint(-1000, __FILE__ ":%d:" #func ": bad lock count", __LINE__); \
            EngDebugBreak();                                        \
        }                                                           \
        EngReleaseSemaphore((xppdev)->hsemLock);                      \
    }                                                       
#else
#define ASSERTLOCK(xppdev, func)
#endif
//@@END_DDKSPLIT

//
// Status flags
//
typedef enum
{
    // STAT_* indicates that the resource actually exists
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
    STAT_DEV_BITMAPS        = 0x0004,   // Device Bitmaps are allowed

    // ENABLE_* indicates whether resource is currently available
    ENABLE_BRUSH_CACHE      = 0x0020,   // Brush cache disabled
    ENABLE_DEV_BITMAPS      = 0x0040,   // Device Bitmaps disabled

} /*STATUS*/;
typedef int Status;

//
// The Physical Device data structure
//
typedef struct  _PDev
{
    BYTE*       pjScreen;           // Points to base screen address
    ULONG       iBitmapFormat;      // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                    //   (our current colour depth)
    CAPS        flCaps;             // Capabilities flags
    Status      flStatus;           // Status flags
    BOOL        bEnabled;           // In graphics mode (not full-screen)

    HANDLE      hDriver;            // Handle to \Device\Screen
    HDEV        hdevEng;            // Engine's handle to PDev
    HSURF       hsurfScreen;        // Engine's handle to screen surface
    Surf*       pdsurfScreen;       // Our private DSURF for the screen
    Surf*       pdsurfOffScreen;    // Our private DSURF for the back buffer

    LONG        cxScreen;           // Visible screen width
    LONG        cyScreen;           // Visible screen height
    LONG        cxMemory;           // Width of Video RAM
    LONG        cyMemory;           // Height of Video RAM
    ULONG       ulMode;             // Mode the mini-port driver is in.
    LONG        lDelta;             // Distance from one scan to the next.

    FLONG       flHooks;            // What we're hooking from GDI

    LONG        cjPelSize;          // 4/2/1 for 32/16/8 bpp
    LONG        cPelSize;           // 2/1/0 for 32/16/8 bpp
    DWORD       bPixShift;          // 2/1/0 for 32/16/8 bpp
    DWORD       bBppShift;          // 0/1/2 for 32/16/8 bpp
    DWORD       dwBppMask;          // 0/1/3 for 32/16/8 bpp

    ULONG       ulWhite;            // 0xff if 8bpp, 0xffff if 16bpp,
                                    // 0xffffffff if 32bpp
    ULONG*      pulCtrlBase[2];     // Mapped control registers for this PDEV
                                    // 2 entries to support Dual-TX
    ULONG*      pulDenseCtrlBase;   // Dense mapping for direct draw
    ULONG*      pulRamdacBase;      // Mapped control registers for the RAMDAC
    VOID*       pvTmpBuffer;        // General purpose temporary buffer,
                                    // TMP_BUFFER_SIZE bytes in size
                                    // (Remember to synchronize if you use this
                                    // for device bitmaps or async pointers)
    LONG        lVidMemHeight;      // Height of Video RAM available to
                                    // DirectDraw heap (cyScreen <= cyHeap
                                    // <= cyMemory), including primary surface
    LONG        lVidMemWidth;       // Width, in pixel, of Video RAM available
                                    // to DDraw heap, including primary surface
    LONG        cBitsPerPel;        // Bits per pel (8, 15, 16, 24 or 32)
    UCHAR*      pjIoBase;           // Mapped IO port base for this PDEV
    
    ULONG       ulPermFormat;       // permedia format type of primary
    ULONG       ulPermFormatEx;     // permedia extended format bit of primary
    
    DWORD       dwAccelLevel;       // Acceleration level setting
    POINTL      ptlOrigin;          // Origin of desktop in multi-mon dev space

    //
    // Palette stuff:
    //
    PALETTEENTRY* pPal;             // The palette if palette managed
    HPALETTE    hpalDefault;        // GDI handle to the default palette.
    FLONG       flRed;              // Red mask for 16/32bpp bitfields
    FLONG       flGreen;            // Green mask for 16/32bpp bitfields
    FLONG       flBlue;             // Blue mask for 16/32bpp bitfields

    //
    // Heap stuff for DDRAW managed off-screen memory
    //
    VIDEOMEMORY* pvmList;           // Points to the video-memory heap list
                                    //   as supplied by DirectDraw, needed
                                    //   for heap allocations
    ULONG       cHeaps;             // Count of video-memory heaps
    ULONG       iHeapUniq;          // Incremented every time room is freed
                                    //   in the off-screen heap

    Surf*       psurfListHead;      // Dbl Linked list of discardable bitmaps,
    Surf*       psurfListTail;      //   in order of oldest to newest

    //
    // Pointer stuff
    //

    LONG        xPointerHot;        // xHot of current hardware pointer
    LONG        yPointerHot;        // yHot of current hardware pointer

    ULONG       ulHwGraphicsCursorModeRegister_45;
                                    // Default value for index 45
    PtrFlags    flPointer;          // Pointer state flags
    VOID*       pvPointerData;      // Points to ajPointerData[0]
    BYTE        ajPointerData[POINTER_DATA_SIZE];
                                    // Private work area for downloaded
                                    //   miniport pointer code

    BOOL        bPointerInitialized;// Flag to indicate if HW pointer has been
                                    // initizlized
    
    // Brush stuff:
    
    BOOL        bRealizeTransparent;// Hint to DrvRealizeBrush for whether
                                    // the brush should be realized as
                                    // transparent or not
    LONG        cPatterns;          // Count of bitmap patterns created
    LONG        lNextCachedBrush;   // Index for next brush to be allocated
    LONG        cBrushCache;        // Total number of brushes cached
    BrushEntry  abeMono;            // Keeps track of area stipple brush
    BrushEntry  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    HBITMAP     ahbmPat[HS_DDI_MAX];// Engine handles to standard patterns

    ULONG       ulBrushPackedPP;    // Stride of brush as partial products
    VIDEOMEMORY*pvmBrushHeap;       // Heap from which brush cached was alloced
    ULONG       ulBrushVidMem;      // Poitner to start of brush cache
    
    // Hardware pointer cache stuff:

    HWPointerCache  HWPtrCache;     // The cache data structure itself
    LONG        HWPtrLastCursor;    // The index of the last cursor that we drew
    LONG        HWPtrPos_X;         // The last X position of the cursor
    LONG        HWPtrPos_Y;         // The last Y position of the cursor

    HwDataPtr   permediaInfo;       // info about the interface to permedia2

    LONG        FrameBufferLength;  // Length of framebuffer in bytes

    // rendering routines

    GFN*        pgfnAlphaBlend;
    GFN*        pgfnConstantAlphaBlend;
    GFN*        pgfnCopyBlt;
    GFN*        pgfnCopyBltWithRop;
    GFN*        pgfnGradientFillTri;
    GFN*        pgfnGradientFillRect;
    GFN*        pgfnMonoOffset;
    GFN*        pgfnMonoPatFill;
    GFN*        pgfnPatFill;
    GFN*        pgfnPatRealize;
    GFN*        pgfnSolidFill;
    GFN*        pgfnSolidFillWithRop;
    GFN*        pgfnSourceFillRect;
    GFN*        pgfnTransparentBlt;
    GFN*        pgfnXferImage;
    GFN*        pgfnInvert;


    // support for DrvStroke
    // TODO: remove use of this implicit parameter passing
    Surf*       psurf;     //  this is an implicit parameter passed to various
                           //  calls ... this needs to be removed.

    // Direct draw stuff

    P2CtxtPtr   pDDContext;            // DDRAW context

    // Virtual address of start of screen
    UINT_PTR    dwScreenStart;

    // DDraw/D3D DMA shared memory block
    P2DMA      *pP2dma;

    // Current pixel format of display
    DDPIXELFORMAT   ddpfDisplay;

    // Some P2 specific information
    DWORD       dwChipConfig;           // image of P2 chip configuration        
                                        // some virtual addresses of the P2 
                                        // registers
    ULONG      *pCtrlBase;              //  
    ULONG      *pCoreBase;              //
    ULONG      *pGPFifo;                //

    // DirectDraw callbacks
    DDHAL_DDCALLBACKS           DDHALCallbacks;
    DDHAL_DDSURFACECALLBACKS    DDSurfCallbacks;

    DWORD dwNewDDSurfaceOffset;

    BOOL        bDdExclusiveMode;       // TRUE if DDraw is in ExclusiveMode
    BOOL        bDdStereoMode;          // TRUE if flip has switched us 
                                        // to stereo mode
    BOOL        bCanDoStereo;           // This mode can do stereo

    // These have to live here, as we could be running on 2 different cards
    // on two different displays...!
    UINT_PTR pD3DDriverData32;
    UINT_PTR pD3DHALCallbacks32;
    
    // Linear allocator defines
    UINT_PTR       dwGARTLin;       // Linear address of Base of AGP Memory
    UINT_PTR       dwGARTDev;       // High Linear address of Base of AGP Memory
    UINT_PTR       dwGARTLinBase;   // The Linear base address passed into
                                    // UpdateNonLocalVidMem 
    UINT_PTR       dwGARTDevBase;   // The High Linear base address passed into
                                    // UpdateNonLocalVidMem

    // HAL info structure.
    DDHALINFO   ddhi32;

    PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand;

    // New Input FIFO cached information

    PULONG          pulInFifoPtr;
    PULONG          pulInFifoStart;
    PULONG          pulInFifoEnd;
    
    ULONG*          dmaBufferVirtualAddress;
    LARGE_INTEGER   dmaBufferPhysicalAddress;
    ULONG           dmaCurrentBufferOffset;
    ULONG           dmaActiveBufferOffset;

    ULONG*          pulInputDmaCount;
    ULONG*          pulInputDmaAddress;
    ULONG*          pulFifo;
    ULONG*          pulOutputFifoCount;
    ULONG*          pulInputFifoCount;

    BOOL            bGdiContext;

    BOOL            bNeedSync;
    BOOL            bForceSwap;

#if DBG
    ULONG           ulReserved;
#endif

    //
    // On NT4.0 The psoScreen is the locked screen Surf we EngLockSurface
    // on to in DrvEnableSurface which we EngUnlockSurface in
    // DrvDisableSurface. On NT5.0 this should be NULL.
    //
    SURFOBJ     *psoScreen;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    HSEMAPHORE      hsemLock;
    ULONG           ulLockCount;
#endif
//@@END_DDKSPLIT

} PDev, *PPDev;


/*****************************************************************************\
*                                                                             *
* NT 5.0  -> NT 4.0 single binary support:                                    *
*                                                                             *
\*****************************************************************************/

// Are we running on NT40 system

extern BOOL g_bOnNT40;

// Function to load thunks for new NT5.0 functionality. Called in
// DrvEnableDriver and implemented in thunks.c

extern BOOL bEnableThunks();
 

#endif // __DRIVER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\escape.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: escape.c
 *
 * Contains private escape calls for driver.
 *
 *
 *
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *****************************************************************************/
#include "precomp.h"

#include "log.h"                                   
                                   
#define ESCAPE_OPEN_LOG     1024
#define ESCAPE_CLOSE_LOG    1025

ULONG APIENTRY DrvEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
   )
{
    PPDev   ppdev = (PPDev) pso->dhpdev;
    ULONG   ulResult;

    switch(iEsc)
    {

    case ESCAPE_OPEN_LOG:
        ulResult = ulLogOpen(L"\\??\\E:\\puntinfo.txt", 1024 * 1024 * 32);
        if(!ulResult)
        {
            DBG_GDI((0, "DrvEscape: failed to open log file")); 
        }
        else
        {
            DBG_GDI((0, "DrvEscape: opened log file"));
        }

        break;

    case ESCAPE_CLOSE_LOG:
        ulResult = ulLogClose();
        if(!ulResult)
        {
            DBG_GDI((0, "DrvEscape: failed to close log file"));
        }
        else
        {
            DBG_GDI((0, "DrvEscape: close log file"));
        }

        break;

    default:
        DBG_GDI((3, "DrvEscape: unknown escape %d", iEsc));
        ulResult = 0;
    }

    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\fastfill.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: fastfill.c
 *
 * Draws fast solid-coloured, unclipped, non-complex rectangles.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"

//-----------------------------------------------------------------------------
//
// BOOL bFillPolygon()
//
// Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
// having only two edges that are monotonic increasing in 'y'. That is,
// the polygon cannot have more than one disconnected segment on any given
// scan. Note that the edges of the polygon can self-intersect, so hourglass
// shapes are permissible. This restriction permits this routine to run two
// simultaneous DDAs(Digital Differential Analyzer), and no sorting of the
// edges is required.
//
// Note that NT's fill convention is different from that of Win 3.1 or 4.0.
// With the additional complication of fractional end-points, our convention
// is the same as in 'X-Windows'.
//
// This routine handles patterns only when the Permedia2 area stipple can be
// used.  The reason for this is that once the stipple initialization is
// done, pattern fills appear to the programmer exactly the same as solid
// fills (with the slight difference of an extra bit in the render command).
//
// We break each polygon down to a sequenze of screen aligned trapeziods, which
// the Permedia2 can handle.
//
// Optimisation list follows ....
//
// This routine is in no way the ultimate convex polygon drawing routine
// Some obvious things that would make it faster:
//
//    1) Write it in Assembler
//
//    2) Make the non-complex polygon detection faster.  If I could have
//       modified memory before the start of after the end of the buffer,
//       I could have simplified the detection code.  But since I expect
//       this buffer to come from GDI, I can't do that.  Another thing
//       would be to have GDI give a flag on calls that are guaranteed
//       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
//       the buffer would still have to be scanned to find the top-most
//       point.
//
//    3) Implement support for a single sub-path that spans multiple
//       path data records, so that we don't have to copy all the points
//       to a single buffer like we do in 'fillpath.c'.
//
//    4) Use 'ebp' and/or 'esp' as a general register in the inner loops
//       of the Asm loops, and also Pentium-optimize the code.  It's safe
//       to use 'esp' on NT because it's guaranteed that no interrupts
//       will be taken in our thread context, and nobody else looks at the
//       stack pointer from our context.
//
//    5) When we get to a part of the polygon where both vertices are of 
//       equal height, the algorithm essentially starts the polygon again.
//       Using the Permedia2 Continue message could speed things up in certain
//       cases.
//       
// Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
//
// Note: the point data (POINTFX) GDI passed to us in 28.4 format. Permedia 2
//       hardware uses 12.15 format. So most of the time, we need to do a
//       x = (x + 15) >> 4 to bring it back to normal interger format and then
//       convert it to 12.15 format when we set the register value
//
// Parameters:
//  ppdev-------Pointer to PDev
//  pSurfDst----Destination surface
//  lEdges------Number of edges, includes close figure edge
//  pptfxFirst--Pointer to the first point in the data buffer. There are total
//              "lEdges" points
//  iSolidColor-Solid color fill
//  ulRop4------ROP4
//  pco---------Clip Object. 
//  prb---------Realized brush
//  pptlBrush---Pattern alignment    
//
//-----------------------------------------------------------------------------
BOOL
bFillPolygon(PDev*      ppdev,
             Surf*      pSurfDst,
             LONG       lEdges,
             POINTFIX*  pptfxFirst,
             ULONG      ulSolidColor,
             ULONG      ulRop4,
             CLIPOBJ*   pco,
             RBrush*    prb,
             POINTL*    pptlBrush)
{
    POINTFIX*   pptfxLast;      // Points to the last point in the polygon
                                // array
    POINTFIX*   pptfxTop;       // Points to the top-most point in the polygon
    POINTFIX*   pptfxScan;      // Current edge pointer for finding pptfxTop
    POINTFIX*   aPtrFixTop[2];  // DDA terms and stuff
    POINTFIX*   aPtrFixNext[2]; // DDA terms and stuff
    
    BOOL        bRC = FALSE;    // Return code for this function
    BOOL        bSingleColor;   // Only one color pass
    BOOL        bTrivialClip;   // Trivial Clip or not
    
    ClipEnum*   pClipRegion = (ClipEnum*)(ppdev->pvTmpBuffer);
                                // Buffer for storing clipping region
    DWORD       dwAsMode[2];    // The area stipple mode and the color for that
                                // pass
    DWORD       dwColorMode;    // Current color mode
    DWORD       dwColorReg;     // Current color register mode
    DWORD       dwLogicMode;    // Current logic op mode
    DWORD       dwReadMode;     // Current register read mode
    DWORD       dwRenderBits;   // Current render bits
    
    LONG        lCount;         // Number of scan lines to render
    LONG        alDX[2];         // 
    LONG        alDY[2];
    LONG        lNumOfPass;     // Number of passes required to render
    LONG        lScanEdges;     // Number of edges scanned to find pptfxTop
                                // (doesn't include the closefigure edge)
    
    LONG        alDxDy[2];
    
    RECTL*      pClipList;      // List of clip rects
    
    ULONG       ulBgColor;      // Background color
    ULONG       ulBgLogicOp = ulRop3ToLogicop(ulRop4 >> 8);
    ULONG       ulBrushColor = ulSolidColor;
                                // Current fill color
    ULONG       ulColor[2];     // On multiple color passes we need to know how
                                // to set up
    ULONG       ulFgColor;      // Foreground color
    ULONG       ulFgLogicOp = ulRop3ToLogicop(ulRop4 & 0xFF);
    ULONG       ulOrX;          // We do logic OR for all values to eliminate
    ULONG       ulOrY;          // complex polygons

    GFNPB       pb;             // Functional block for lower level function

    ULONG*      pBuffer;

    PERMEDIA_DECL;
    

    pb.ppdev = ppdev;

    DBG_GDI((6, "bFillPolygon called, rop4 = %x, fg ulFgLogicOp =%d, bg = %d",
             ulRop4, ulFgLogicOp, ulBgLogicOp));
    ASSERTDD(lEdges > 1, "Polygon with less than 2 edges");

    //
    // See if the polygon is 'non-complex'
    // Assume for now that the first point in path is the top-most
    //
    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;
    pptfxLast = pptfxFirst + lEdges - 1;
    
    //
    // Initialize our logic OR op counters
    //
    ulOrX = pptfxScan->x;
    ulOrY = pptfxScan->y;

    //
    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'lScanEdges' will be the number of edges remaining, including
    // the current one, but not counting close figure
    //
    lScanEdges = lEdges - 1;

    //
    // First phase: Velidate input point data to see if we can handle it or not
    //
    // Check if the 2nd edge point is lower than current edge point
    //
    // Note: the (0,0) is at the up-left corner in this coordinate system
    // So the bigger the Y value, the lower the point
    //
    if ( (pptfxScan + 1)->y > pptfxScan->y )
    {
        //
        // The edge goes down, that is, the 2nd point is lower than the 1st
        // point. Collect all downs: that is, collect all the X and Y until
        // the edge goes up
        //
        do
        {
            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;

            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y >= pptfxScan->y );

        //
        // From this point, the edge goes up, that is, the next point is higher
        // than current point
        // Collect all ups: Collect all the X and Y until the edge goes down
        //
        do
        {
            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFillingCheck;
            }
        } while ( (pptfxScan + 1)->y <= pptfxScan->y );

        //
        // Reset pptfxTop to the current point which is at top again compare
        // with the next point
        // Collect all downs:
        //
        pptfxTop = pptfxScan;

        do
        {
            //
            // If the next edge point is lower than the 1st point, stop
            //
            if ( (pptfxScan + 1)->y > pptfxFirst->y )
            {
                break;
            }

            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;

            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y >= pptfxScan->y );

        //
        // If we fallen here, it means we are given down-up-down polygon.
        // We can't handle it and return FALSE to let GDI do it.
        //
        DBG_GDI((7, "Reject: can't fill down-up-down polygon"));

        goto ReturnBack;
    }// if ( (pptfxScan + 1)->y>pptfxScan->y ), 2nd point is lower than 1st one
    else
    {
        //
        // The edge goes up, that is, the 2nd point is higher than the 1st
        // point. Collect all ups: that is, collect all the X and Y until
        // the edge goes down.
        // Note: we keeps changing the value of "pptfxTop" so that after
        // this "while" loop, "pptfxTop" points to the TOPEST point
        //
        do
        {
            ulOrY |= (++pptfxTop)->y;    // We increment this now because we
            ulOrX |= pptfxTop->x;        //  want it to point to the very last
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxTop + 1)->y <= pptfxTop->y );

        //
        // Form this point, the edge goes down, that is, the next point is
        // lower than current point. Collect all downs: that is, collect all
        // the X and Y until the edge goes up
        // Note: here we keep changing "pptfxScan" so that after this loop,
        // "pptfxScan" points to the current scan line, which also is the
        // lowest point
        //
        pptfxScan = pptfxTop;
        
        do
        {
            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y >= pptfxScan->y );

        //
        // Up to this point, the edge is about to go up again.
        // Collect all ups:
        //
        do
        {
            //
            // If the edge going down again, just qute because we can't
            // fill up-down-up polygon
            // 
            if ( (pptfxScan + 1)->y < pptfxFirst->y )
            {
                break;
            }

            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y <= pptfxScan->y );

        //
        // If we fallen here, it means we are given up-down-up polygon.
        // We can't handle it and return FALSE to let GDI do it.
        //
        DBG_GDI((7, "Reject: Can't fill up-down-up polygon"));
        
        goto ReturnBack;
    }// if (pptfxScan + 1)->y<=pptfxScan->y), 2nd point is higher than 1st one
    
    //
    // Phase 2: Now we have validated the input point and think we can fill it
    //
SetUpForFillingCheck:
    
    //
    // We check to see if the end of the current edge is higher than the top
    // edge we've found so far. If yes, then let pptfxTop point to the end of
    // current edge which is the highest.
    // 
    //
    if ( pptfxScan->y < pptfxTop->y )
    {
        pptfxTop = pptfxScan;
    }

SetUpForFilling:
    
    //
    // Can only use block fills for trivial clip so work it out here
    //
    bTrivialClip = (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL);

    if ( (ulOrY & 0xffffc00f) || (ulOrX & 0xffff8000) )
    {
        ULONG   ulNeg;
        ULONG   ulPosX;
        ULONG   ulPosY;

        //
        // Fractional Y must be done as spans
        //
        if ( ulOrY & 0xf )
        {
            bRC = bFillSpans(ppdev, pSurfDst, lEdges, pptfxFirst,
                             pptfxTop, pptfxLast,
                             ulSolidColor, ulRop4, pco, prb, pptlBrush);
            goto ReturnBack;
        }

        //
        // Run through all the vertices and check that none of them
        // have a negative component less than -256.
        //
        ulNeg = 0;
        ulPosX = 0;
        ulPosY = 0;

        for ( pptfxScan = pptfxFirst; pptfxScan <= pptfxLast; ++pptfxScan )
        {
            if ( pptfxScan->x < 0 )
            {
                ulNeg |= -pptfxScan->x;
            }
            else
            {
                ulPosX |= pptfxScan->x;
            }

            if ( pptfxScan->y < 0 )
            {
                ulNeg |= -pptfxScan->y;
            }
            else
            {
                ulPosY |= pptfxScan->y;
            }
        }

        //
        // We don't want to handle any polygon with a negative vertex
        // at <= -256 in either coordinate.
        //
        if ( ulNeg & 0xfffff000 )
        {
            DBG_GDI((1, "Coords out of range for fast fill"));
            goto ReturnBack;
        }

        if ( (ulPosX > 2047) || (ulPosY > 1023) )
        {
            DBG_GDI((1, "Coords out of range for Permedia2 fast fill"));
            goto ReturnBack;
        }
    }// if ( (ulOrY & 0xffffc00f) || (ulOrX & 0xffff8000) )

    //
    // Now we are ready to fill
    //

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  pSurfDst->ulPixOffset;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "bFillPolygon: Polygon is renderable. Go ahead and render"));

    if ( ulFgLogicOp == K_LOGICOP_COPY )
    {
        dwColorMode = __PERMEDIA_DISABLE;
        dwLogicMode = __PERMEDIA_CONSTANT_FB_WRITE;
        dwReadMode  = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                  | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

        //
        // Check to see if it is a non-solid fill brush fill
        //
        if ( (ulBrushColor == 0xffffffff)
           ||(!bTrivialClip) )
        {
            //
            // Non-solid brush, not too much we can do
            //
            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
            dwColorReg   = __Permedia2TagFBWriteData;
        }// Non-solid brush
        else
        {
            //
            // For solid brush, We can use fast fills, so load the fb block
            // color register.
            //
            dwColorReg = __Permedia2TagFBBlockColor;
            dwRenderBits = __RENDER_FAST_FILL_ENABLE
                       | __RENDER_TRAPEZOID_PRIMITIVE;

            //
            // Setup color data based on current color mode we are in
            //
            if ( ppdev->cPelSize == 1 )
            {
                //
                // We are in 16 bit packed mode. So the color data must be
                // repeated in both halves of the FBBlockColor register
                //
                ASSERTDD((ulSolidColor & 0xFFFF0000) == 0,
                         "bFillPolygon: upper bits are not zero");
                ulSolidColor |= (ulSolidColor << 16);
            }
            else if ( ppdev->cPelSize == 0 )
            {
                //
                // We are in 8 bit packed mode. So the color data must be
                // repeated in all 4 bytes of the FBBlockColor register
                //
                ASSERTDD((ulSolidColor & 0xFFFFFF00) == 0,
                         "bFillPolygon: upper bits are not zero");
                ulSolidColor |= ulSolidColor << 8;
                ulSolidColor |= ulSolidColor << 16;
            }

            //
            // Ensure that the last access was a write before loading
            // BlockColor
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = __Permedia2TagFBBlockColor;
            pBuffer[1] =  ulSolidColor;
            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);

        }// Solid brush case
    }// LOGICOP_COPY
    else
    {
        dwColorReg = __Permedia2TagConstantColor;
        dwColorMode = __COLOR_DDA_FLAT_SHADE;
        dwLogicMode = P2_ENABLED_LOGICALOP(ulFgLogicOp);
        dwReadMode = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                   | LogicopReadDest[ulFgLogicOp];
        dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
    }// Non-COPY LogicOP

    //
    // Determine how many passes we need to draw all the clip rects
    //
    if ( bTrivialClip )
    {
        //
        // Just draw, no clipping to perform.
        //
        pClipList = NULL;                       // Indicate no clip list
        lNumOfPass = 1;
    }
    else
    {
        if ( pco->iDComplexity == DC_RECT )
        {
            //
            // For DC_RECT, we can do it in one pass
            //
            lNumOfPass = 1;
            pClipList = &pco->rclBounds;
        }
        else
        {
            //
            // It may be slow to render the entire polygon for each clip rect,
            // especially if the object is very complex. An arbitary limit of
            // up to CLIP_LIMIT regions will be rendered by this function.
            // Return false if more than CLIP_LIMIT regions.
            //
            lNumOfPass = CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY,
                                      CLIP_LIMIT);
            if ( lNumOfPass == -1 )
            {
                goto ReturnBack; // More than CLIP_LIMIT.
            }

            //
            // Put the regions into our clip buffer
            //
            if ( (CLIPOBJ_bEnum(pco, sizeof(ClipEnum), (ULONG*)pClipRegion))
               ||(pClipRegion->c != lNumOfPass) )
            {
                DBG_GDI((7, "CLIPOBJ_bEnum inconsistency. %d = %d",
                         pClipRegion->c, lNumOfPass));
            }

            pClipList = &(pClipRegion->arcl[0]);
        }// Non-DC_RECT case

        //
        // For non-trivial clipping, we can use SCISSOR to implement it
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] =  SCREEN_SCISSOR_DEFAULT  | USER_SCISSOR_ENABLE;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }// Non-trivial clipping

    bSingleColor = TRUE;
    if ( ulBrushColor != 0xFFFFFFFF )
    {
        //
        // Solid brush case, just set the color register as the color
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = dwColorReg;
        pBuffer[1] = ulSolidColor;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }// Solid brush case
    else
    {
        //
        // For non-solid brush, we need to realize brush first
        //
        BrushEntry* pbe;

        //
        // Turn on the area stipple.
        //
        dwRenderBits |= __RENDER_AREA_STIPPLE_ENABLE;

        //
        // If anything has changed with the brush we must re-realize it. If the
        // brush has been kicked out of the area stipple unit we must fully
        // realize it. If only the alignment has changed we can simply update
        // the alignment for the stipple.
        //
        pbe = prb->pbe;
        
        pb.prbrush = prb;
        pb.pptlBrush = pptlBrush;
        
        if ( (pbe == NULL) || (pbe->prbVerify != prb) )
        {
            DBG_GDI((7, "full brush realize"));
            vPatRealize(&pb);
        }
        else if ( (prb->ptlBrushOrg.x != pptlBrush->x)
                ||(prb->ptlBrushOrg.y != pptlBrush->y) )
        {
            DBG_GDI((7, "changing brush offset"));
            vMonoOffset(&pb);
        }

        ulFgColor = prb->ulForeColor;
        ulBgColor = prb->ulBackColor;

        if (  (ulBgLogicOp == K_LOGICOP_NOOP)
            ||((ulFgLogicOp == K_LOGICOP_XOR) && (ulBgColor == 0)) )
        {
            //
            // Either we have a transparent bitmap or it can be assumed to be
            // transparent (XOR with bg=0) 
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulFgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] =  prb->areaStippleMode;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }// Transparent bitmap
        else if ( (ulFgLogicOp == K_LOGICOP_XOR) && (ulFgColor == 0) )
        {
            //
            // We have a transparent foreground! (XOR with fg=0) 
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulBgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] = prb->areaStippleMode  | AREA_STIPPLE_INVERT_PAT;
            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }// Transparent foreground
        else
        {
            //
            // Not using a transparent pattern
            //
            bSingleColor = FALSE;
            ulColor[0] = ulFgColor;
            ulColor[1] = ulBgColor;
            dwAsMode[0] = prb->areaStippleMode;
            dwAsMode[1] = dwAsMode[0] | AREA_STIPPLE_INVERT_PAT;

            //
            // Double the number of passes, one for fg one for bg
            //
            lNumOfPass <<= 1;
        }// No transparent
    }// if ( ulBrushColor == 0xFFFFFFFF ), non-solid brush

    InputBufferReserve(ppdev, 6, &pBuffer);

    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] =  dwColorMode;
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] =  dwReadMode;
    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] =  dwLogicMode;

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "Rendering Polygon in %d passes. with %s",
             lNumOfPass, bSingleColor ? "Single Color" : "Two Color"));

    lNumOfPass--;
    
    while ( 1 )
    {
        //
        // Per pass initialization
        //
        if ( bSingleColor )
        {
            //
            // Need to set up clip rect each pass
            //
            if ( pClipList )
            {
                InputBufferReserve(ppdev, 4, &pBuffer);

                pBuffer[0] = __Permedia2TagScissorMinXY;
                pBuffer[1] = ((pClipList->left)<< SCISSOR_XOFFSET)
                           | ((pClipList->top)<< SCISSOR_YOFFSET);
                pBuffer[2] = __Permedia2TagScissorMaxXY;
                pBuffer[3] = ((pClipList->right)<< SCISSOR_XOFFSET)
                           | ((pClipList->bottom)<< SCISSOR_YOFFSET);

                pBuffer += 4;

                InputBufferCommit(ppdev, pBuffer);
                pClipList++;
            }
        }// Single color
        else
        {
            //
            // Need to set up clip rect every other pass and change color and
            // inversion mode every pass
            //
            if ( (pClipList) && (lNumOfPass & 1) )
            {
                InputBufferReserve(ppdev, 4, &pBuffer);

                pBuffer[0] = __Permedia2TagScissorMinXY;
                pBuffer[1] = ((pClipList->left)<< SCISSOR_XOFFSET)
                           | ((pClipList->top)<< SCISSOR_YOFFSET);
                pBuffer[2] = __Permedia2TagScissorMaxXY;
                pBuffer[3] = ((pClipList->right)<< SCISSOR_XOFFSET)
                           | ((pClipList->bottom)<< SCISSOR_YOFFSET);
                
                pBuffer += 4;

                InputBufferCommit(ppdev, pBuffer);

                pClipList++;
            }

            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulColor[lNumOfPass & 1];
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] =  dwAsMode[lNumOfPass & 1];

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }// Non-single color mode

        //
        // Initialize left and right points (current) to top point.
        //
        aPtrFixNext[LEFT]  = pptfxTop;
        aPtrFixNext[RIGHT] = pptfxTop;

        while ( 1 )
        {
            //
            // aPtrFixNext[] is always the valid point to draw from
            //
            do
            {
                aPtrFixTop[LEFT] = aPtrFixNext[LEFT];
                aPtrFixNext[LEFT] = aPtrFixTop[LEFT] - 1;

                if ( aPtrFixNext[LEFT] < pptfxFirst )
                {
                    aPtrFixNext[LEFT] = pptfxLast;
                }

                //
                // Special case of flat based polygon, need to break now as
                // polygon is finished
                //
                if ( aPtrFixNext[LEFT] == aPtrFixNext[RIGHT] )
                {
                    goto FinishedPolygon;
                }

                DBG_GDI((7, "LEFT: aPtrFixTop %x aPtrFixNext %x",
                         aPtrFixTop[LEFT], aPtrFixNext[LEFT]));
                DBG_GDI((7, "FIRST %x LAST %x",
                         pptfxFirst, pptfxLast));
                DBG_GDI((7, "X %x Y %x Next: X %x Y %x",
                         aPtrFixTop[LEFT]->x, aPtrFixTop[LEFT]->y,
                         aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y));
            } while ( aPtrFixTop[LEFT]->y == aPtrFixNext[LEFT]->y );

            do
            {
                aPtrFixTop[RIGHT] = aPtrFixNext[RIGHT];
                aPtrFixNext[RIGHT] = aPtrFixTop[RIGHT] + 1;     

                if ( aPtrFixNext[RIGHT] > pptfxLast )
                {
                    aPtrFixNext[RIGHT] = pptfxFirst;
                }

                DBG_GDI((7, "RIGHT: aPtrFixTop %x aPtrFixNext %x FIRST %x",
                         aPtrFixTop[RIGHT], aPtrFixNext[RIGHT], pptfxFirst));
                DBG_GDI((7, " LAST %x X %x Y %x Next: X %x Y %x",
                         pptfxLast, aPtrFixTop[RIGHT]->x, aPtrFixTop[RIGHT]->y,
                         aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));
            } while ( aPtrFixTop[RIGHT]->y == aPtrFixNext[RIGHT]->y );

            //
            // Start up new rectangle. Whenever we get to this code, both
            // points should have equal y values, and need to be restarted.
            // Note: To get correct results, we need to add on nearly one to
            // each X coordinate.
            //
            DBG_GDI((7, "New: Top: x: %x y: %x x: %x y: %x",
                     aPtrFixTop[LEFT]->x, aPtrFixTop[LEFT]->y,
                     aPtrFixTop[RIGHT]->x, aPtrFixTop[RIGHT]->y));
            DBG_GDI((7, " Next: x: %x y: %x x: %x y: %x",
                     aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y,
                     aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));

            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  FIXtoFIXED(aPtrFixTop[LEFT]->x) + NEARLY_ONE;
            pBuffer[2] = __Permedia2TagStartXSub;
            pBuffer[3] =  FIXtoFIXED(aPtrFixTop[RIGHT]->x)+ NEARLY_ONE;
            pBuffer[4] = __Permedia2TagStartY;
            pBuffer[5] =  FIXtoFIXED(aPtrFixTop[RIGHT]->y);

            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);

            //
            // We have 2 15.4 coordinates. We need to divide them and change
            // them into a 15.16 coordinate. We know the y coordinate is not
            // fractional, so we do not loose precision by shifting right by 4
            //
            alDX[LEFT] = (aPtrFixNext[LEFT]->x - aPtrFixTop[LEFT]->x) << 12;
            alDY[LEFT] = (aPtrFixNext[LEFT]->y - aPtrFixTop[LEFT]->y) >> 4;

            //
            // Need to ensure we round delta down. divide rounds towards zero
            //
            if ( alDX[LEFT] < 0 )
            {
                alDX[LEFT] -= alDY[LEFT] - 1;
            }

            alDxDy[LEFT] = alDX[LEFT] / alDY[LEFT];

            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagdXDom;
            pBuffer[1] =  alDxDy[LEFT];

            alDX[RIGHT] = (aPtrFixNext[RIGHT]->x - aPtrFixTop[RIGHT]->x) << 12;
            alDY[RIGHT] = (aPtrFixNext[RIGHT]->y - aPtrFixTop[RIGHT]->y) >> 4;

            //
            // Need to ensure we round delta down. divide rounds towards zero
            //
            if ( alDX[RIGHT] < 0 )
            {
                alDX[RIGHT] -= alDY[RIGHT] - 1;
            }

            alDxDy[RIGHT] = alDX[RIGHT] / alDY[RIGHT];
            pBuffer[2] = __Permedia2TagdXSub;
            pBuffer[3] =  alDxDy[RIGHT];

            //
            // Work out number of scanlines to render
            //
            if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
            {
                lCount = alDY[LEFT];
            }
            else
            {
                lCount = alDY[RIGHT];
            }

            pBuffer[4] = __Permedia2TagCount;
            pBuffer[5] =  lCount;
            pBuffer[6] = __Permedia2TagRender;
            pBuffer[7] =  dwRenderBits;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            //
            // With lots of luck, top trapezoid should be drawn now!
            // Repeatedly draw more trapezoids until points are equal
            // If y values are equal, then we can start again from
            // scratch. 
            //
            while ( (aPtrFixNext[LEFT] != aPtrFixNext[RIGHT])
                  &&(aPtrFixNext[LEFT]->y != aPtrFixNext[RIGHT]->y) )
            {
                //
                // Some continues are required for next rectangle
                //
                if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
                {
                    //
                    // We have reached aPtrFixNext[LEFT]. aPtrFixNext[RIGHT]
                    // is still ok
                    //
                    do
                    {
                        aPtrFixTop[LEFT] = aPtrFixNext[LEFT];
                        aPtrFixNext[LEFT] = aPtrFixTop[LEFT] - 1;   

                        if ( aPtrFixNext[LEFT] < pptfxFirst )
                        {
                            aPtrFixNext[LEFT] = pptfxLast;
                        }
                    }  while ( aPtrFixTop[LEFT]->y == aPtrFixNext[LEFT]->y );

                    //
                    // We have a new aPtrFixNext[LEFT] now.
                    //
                    DBG_GDI((7, "Dom: Top: x: %x y: %x",
                             aPtrFixTop[LEFT]->x, aPtrFixTop[LEFT]->y));
                    DBG_GDI((7, "Next: x: %x y: %x x: %x y: %x",
                             aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y,
                             aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));

                    alDX[LEFT] = (aPtrFixNext[LEFT]->x
                               - aPtrFixTop[LEFT]->x) << 12;
                    alDY[LEFT] = (aPtrFixNext[LEFT]->y
                               - aPtrFixTop[LEFT]->y) >> 4;

                    //
                    // Need to ensure we round delta down. Divide rounds
                    // towards zero
                    //
                    if ( alDX[LEFT] < 0 )
                    {
                        alDX[LEFT] -= alDY[LEFT] - 1;
                    }

                    alDxDy[LEFT] = alDX[LEFT] / alDY[LEFT];

                    if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
                    {
                        lCount = alDY[LEFT];
                    }
                    else
                    {
                        lCount = (abs(aPtrFixNext[RIGHT]->y
                                      - aPtrFixTop[LEFT]->y)) >> 4;
                    }

                    InputBufferReserve(ppdev, 6, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXDom;
                    pBuffer[1] =  FIXtoFIXED(aPtrFixTop[LEFT]->x) + NEARLY_ONE;
                    pBuffer[2] = __Permedia2TagdXDom;
                    pBuffer[3] =  alDxDy[LEFT];
                    pBuffer[4] = __Permedia2TagContinueNewDom;
                    pBuffer[5] =  lCount;

                    pBuffer += 6;

                    InputBufferCommit(ppdev, pBuffer);

                }// if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
                else
                {
                    //
                    // We have reached aPtrFixNext[RIGHT]. aPtrFixNext[LEFT]
                    // is still ok
                    //
                    do
                    {
                        aPtrFixTop[RIGHT] = aPtrFixNext[RIGHT];
                        aPtrFixNext[RIGHT] = aPtrFixTop[RIGHT] + 1;     

                        if ( aPtrFixNext[RIGHT] > pptfxLast )
                        {
                            aPtrFixNext[RIGHT] = pptfxFirst;
                        }
                    } while ( aPtrFixTop[RIGHT]->y == aPtrFixNext[RIGHT]->y );

                    //
                    // We have a new aPtrFixNext[RIGHT] now.
                    //
                    DBG_GDI((7, "Sub: Top: x: %x y: %x",
                             aPtrFixTop[RIGHT]->x, aPtrFixTop[RIGHT]->y));
                    DBG_GDI((7, "Next: x: %x y: %x x: %x y: %x",
                             aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y,
                             aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));

                    alDX[RIGHT] = (aPtrFixNext[RIGHT]->x
                                - aPtrFixTop[RIGHT]->x) << 12;
                    alDY[RIGHT] = (aPtrFixNext[RIGHT]->y
                                - aPtrFixTop[RIGHT]->y) >> 4;

                    //
                    // Need to ensure we round delta down. divide rounds
                    // towards zero
                    //
                    if ( alDX[RIGHT] < 0 )
                    {
                        alDX[RIGHT] -= alDY[RIGHT] - 1;
                    }
                    alDxDy[RIGHT] = alDX[RIGHT] / alDY[RIGHT];

                    if ( aPtrFixNext[RIGHT]->y < aPtrFixNext[LEFT]->y )
                    {
                        lCount = alDY[RIGHT];
                    }
                    else
                    {
                        lCount = (abs(aPtrFixNext[LEFT]->y
                                      - aPtrFixTop[RIGHT]->y)) >> 4;
                    }
                    InputBufferReserve(ppdev, 6, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXSub;
                    pBuffer[1] =  FIXtoFIXED(aPtrFixTop[RIGHT]->x) + NEARLY_ONE;
                    pBuffer[2] = __Permedia2TagdXSub;
                    pBuffer[3] =  alDxDy[RIGHT];
                    pBuffer[4] = __Permedia2TagContinueNewSub;
                    pBuffer[5] =  lCount;

                    pBuffer += 6;

                    InputBufferCommit(ppdev, pBuffer);
                }// if !( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
            }// Loop through next trapezoids

            //
            // Repeatedly draw more trapezoids until points are equal
            // If y values are equal, then we can start again from
            // scratch. 
            //
            if ( aPtrFixNext[LEFT] == aPtrFixNext[RIGHT] )
            {
                break;
            }
        }// loop through all the trapezoids

FinishedPolygon:

        if ( !lNumOfPass-- )
        {
            break;
        }
    }// Loop through all the polygons

    if ( pClipList )
    {
        //
        // Reset scissor mode to its default state.
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] =  SCREEN_SCISSOR_DEFAULT;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

    DBG_GDI((6, "bFillPolygon: returning TRUE"));

    bRC = TRUE;

ReturnBack:

    InputBufferReserve(ppdev, 12, &pBuffer);

    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] =  __PERMEDIA_DISABLE;
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  INTtoFIXED(1);
    pBuffer[4] = __Permedia2TagContinue;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagContinueNewDom;
    pBuffer[7] =  0;
    pBuffer[8] = __Permedia2TagdXDom;
    pBuffer[9] =   0;
    pBuffer[10] = __Permedia2TagdXSub;
    pBuffer[11] =   0;

    pBuffer += 12;

    InputBufferCommit(ppdev, pBuffer);

    return bRC;
}// bFillPolygon()

//-----------------------------------------------------------------------------
//
// BOOL bFillSpan()
//
// This is the code to break the polygon into spans.
//
// Parameters:
//  ppdev-------Pointer to PDev
//  pSurfDst----Destination surface
//  lEdges------Number of edges, includes close figure edge
//  pptfxFirst--Pointer to the first point in the data buffer. There are total
//              "lEdges" points
//  pptfxTop----Pointer to the toppest point in the polygon array.
//  pptfxLast---Pointer to the last point in the polygon array.
//  iSolidColor-Solid color fill
//  ulRop4------ROP4
//  pco---------Clip Object. 
//  prb---------Realized brush
//  pptlBrush---Pattern alignment    
//
//-----------------------------------------------------------------------------
BOOL
bFillSpans(PDev*      ppdev,
           Surf*      pSurfDst,
           LONG       lEdges,
           POINTFIX*  pptfxFirst,
           POINTFIX*  pptfxTop,
           POINTFIX*  pptfxLast,
           ULONG      ulSolidColor,
           ULONG      ulRop4,
           CLIPOBJ*   pco,
           RBrush*    prb,
           POINTL*    pptlBrush)
{
    GFNPB       pb;             // Parameter block
    
    POINTFIX*   pptfxOld;       // Start point in current edge
    
    EDGEDATA    aEd[2];         // Left and right edge
    EDGEDATA    aEdTmp[2];      // DDA terms and stuff
    EDGEDATA*   pEdgeData;
    
    BOOL        bTrivialClip;   // Trivial Clip or not
    
    DWORD       dwAsMode[2];    // The area stipple mode and the color for that
                                // pass
    DWORD       dwColorMode;    // Current color mode
    DWORD       dwColorReg;     // Current color register mode
    DWORD       dwContinueMsg = 0;
                                // Current "Continue" register settings
    DWORD       dwLogicMode;    // Current logic op mode
    DWORD       dwRenderBits;   // Current render bits
    DWORD       dwReadMode;     // Current register read mode
    

    LONG        lCurrentSpan;   // Current Span
    LONG        lDX;            // Edge delta in FIX units in x direction
    LONG        lDY;            // Edge delta in FIX units in y direction
    LONG        lNumColors;     // Number of colors
    LONG        lNumOfPass;     // Number of passes required to render
    LONG        lNumScan;       // Number of scans in current trapezoid
    LONG        lQuotient;      // Quotient
    LONG        lRemainder;     // Remainder
    LONG        lStartY;        // y-position of start point in current edge
    LONG        lTempNumScan;   // Temporary variable for number of spans
    LONG        lTmpLeftX;      // Temporary variable
    LONG        lTmpRightX;     // Temporary variable
    
    ULONG       ulBgColor;      // Background color
    ULONG       ulBgLogicOp = ulRop3ToLogicop(ulRop4 >> 8);
    ULONG       ulBrushColor = ulSolidColor;
    ULONG       ulColor[2];     // On multiple color passes we need to know how
                                // to set up
    ULONG       ulFgColor;      // Foreground color
    ULONG       ulFgLogicOp = ulRop3ToLogicop(ulRop4 & 0xFF);
    ULONG*      pBuffer;

    PERMEDIA_DECL;
    
    bTrivialClip = (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL);

    pb.ppdev = ppdev;

    //
    // This span code cannot handle a clip list yet!
    //
    if ( !bTrivialClip )
    {
        return FALSE;
    }

    DBG_GDI((7, "Starting Spans Code"));

    //
    // Setup window base first
    //
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  pSurfDst->ulPixOffset;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Some Initialization. First trapezoid starts from the topest point
    // which is pointed by "pptfxTop".
    // Here we convert it from 28.4 to normal interger
    //
    lCurrentSpan = (pptfxTop->y + 15) >> 4;

    //
    // Make sure we initialize the DDAs appropriately:
    //
    aEd[LEFT].lNumOfScanToGo  = 0;  // Number of scans to go for this left edge
    aEd[RIGHT].lNumOfScanToGo = 0;  // Number of scans to go for this right edge

    //
    // For now, guess as to which is the left and which is the right edge
    //
    aEd[LEFT].lPtfxDelta  = -(LONG)sizeof(POINTFIX); // Delta (in bytes) from
    aEd[RIGHT].lPtfxDelta = sizeof(POINTFIX);        // pptfx to next point

    aEd[LEFT].pptfx  = pptfxTop;                // Points to start of
    aEd[RIGHT].pptfx = pptfxTop;                // current edge

    DBG_GDI((7, "bFillPolygon: Polygon is renderable. Go render"));

    if ( ulFgLogicOp == K_LOGICOP_COPY )
    {
        dwColorMode = __PERMEDIA_DISABLE;
        dwLogicMode = __PERMEDIA_CONSTANT_FB_WRITE;
        dwReadMode  = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                    | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

        //
        // If block fills not available or using the area stipple for mono
        // pattern, then use constant color.
        //
        if ( ulBrushColor == 0xffffffff )
        {
            dwColorReg   = __Permedia2TagFBWriteData;
            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
        } // Non-solid brush
        else
        {
            //
            // We can use fast fills, so load the fb block color register.
            //
            dwColorReg = __Permedia2TagFBBlockColor;
            dwRenderBits = __RENDER_FAST_FILL_ENABLE
                         | __RENDER_TRAPEZOID_PRIMITIVE;

            //
            // Replicate colour for block fill colour.
            //
            if ( ppdev->cPelSize < 2 )
            {
                ulSolidColor |= ulSolidColor << 16;
                if ( ppdev->cPelSize == 0 )
                {
                    ulSolidColor |= ulSolidColor << 8;
                }
            }

            //
            // Ensure that the last access was a write before loading
            // BlockColor
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = __Permedia2TagFBBlockColor;
            pBuffer[1] =  ulSolidColor;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);
        }// Solid brush 
    }// K_LOGICOP_COPY
    else
    {
        dwColorMode = __COLOR_DDA_FLAT_SHADE;
        dwLogicMode = P2_ENABLED_LOGICALOP(ulFgLogicOp);
        dwReadMode = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                   | LogicopReadDest[ulFgLogicOp];
        dwColorReg = __Permedia2TagConstantColor;
        dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
    }// NON_COPY

    //
    // To get correct results, we need to add on nearly one to each X
    // coordinate. 
    //
    if ( ulBrushColor != 0xFFFFFFFF )
    {
        //
        // This is a solid brush
        //
        lNumColors = 1;

        if ( dwColorMode == __PERMEDIA_DISABLE )
        {
            //
            // This is from LOGICOP_COPY mode according to the dwColorMode we
            // set above
            //
            // Note: ColorDDAMode is DISABLED at initialisation time so
            // there is no need to re-load it here.
            //
            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagFBReadMode;
            pBuffer[1] =  dwReadMode;
            pBuffer[2] = __Permedia2TagLogicalOpMode;
            pBuffer[3] =  dwLogicMode;
            pBuffer[4] = dwColorReg;
            pBuffer[5] = ulSolidColor;

            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);
        }// Disable color DDA, LOGIC_COPY
        else
        {
            //
            // This is from NON-COPY logicop mode according to the dwColorMode
            // we set above
            //
            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagColorDDAMode;
            pBuffer[1] =  dwColorMode;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] =  dwReadMode;
            pBuffer[4] = __Permedia2TagLogicalOpMode;
            pBuffer[5] =  dwLogicMode;
            pBuffer[6] = dwColorReg;
            pBuffer[7] = ulSolidColor;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);    

        }// Enable colorDDA, NON-COPY mode
    }// Solid brush case
    else
    {
        //
        // For non-solid brush case, we need to realize brush
        //
        BrushEntry* pbe;

        //
        // Turn on the area stipple.
        //
        dwRenderBits |= __RENDER_AREA_STIPPLE_ENABLE;

        //
        // If anything has changed with the brush we must re-realize it. If
        // the brush has been kicked out of the area stipple unit we must
        // fully realize it. If only the alignment has changed we can
        // simply update the alignment for the stipple.
        //
        DBG_GDI((7, "Brush found"));
        ASSERTDD(prb != NULL,
                 "Caller should pass in prb for non-solid brush");
        pbe = prb->pbe;

        pb.prbrush = prb;
        pb.pptlBrush = pptlBrush;

        if ( (pbe == NULL) || (pbe->prbVerify != prb) )
        {
            DBG_GDI((7, "full brush realize"));
            vPatRealize(&pb);
        }
        else if ( (prb->ptlBrushOrg.x != pptlBrush->x)
                ||(prb->ptlBrushOrg.y != pptlBrush->y) )
        {
            DBG_GDI((7, "changing brush offset"));
            vMonoOffset(&pb);
        }

        ulFgColor = prb->ulForeColor;
        ulBgColor = prb->ulBackColor;

        if ( dwColorMode == __PERMEDIA_DISABLE )
        {
            //
            // ColorDDAMode is DISABLED at initialisation time so there is
            // no need to re-load it here.
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = __Permedia2TagFBReadMode;
            pBuffer[1] =  dwReadMode;
            pBuffer[2] = __Permedia2TagLogicalOpMode;
            pBuffer[3] =  dwLogicMode;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
        else
        {
            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagColorDDAMode;
            pBuffer[1] =  dwColorMode;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] =  dwReadMode;
            pBuffer[4] = __Permedia2TagLogicalOpMode;
            pBuffer[5] =  dwLogicMode;

            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);
        }

        if ( (ulBgLogicOp == K_LOGICOP_NOOP)
           ||((ulFgLogicOp == K_LOGICOP_XOR) && (ulBgColor == 0)) )
        {
            //
            // Either we have a transparent bitmap or it can be assumed to
            // be transparent (XOR with bg=0) 
            //
            DBG_GDI((7, "transparant bg"));

            lNumColors = 1;

            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulFgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] =  prb->areaStippleMode;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
        else if ( (ulFgLogicOp == K_LOGICOP_XOR) && (ulFgColor == 0) )
        {
            //
            // We have a transparent foreground! (XOR with fg=0)
            //
            DBG_GDI((7, "transparant fg"));
            lNumColors = 1;
            
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulBgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] = prb->areaStippleMode |AREA_STIPPLE_INVERT_PAT;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
        else
        {
            //
            // Not using a transparent pattern
            //
            DBG_GDI((7, "2 color"));
            lNumColors = 2;
            ulColor[0] = ulFgColor;
            ulColor[1] = ulBgColor;
            dwAsMode[0] = prb->areaStippleMode;
            dwAsMode[1] = dwAsMode[0] | AREA_STIPPLE_INVERT_PAT;
        }
    }// Non-solid brush case

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagCount;
    pBuffer[1] =  0;     

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    //
    // dxDom, dXSub and dY are initialised to 0, 0, and 1, so we don't need 
    // to re-load them here.
    //
    DBG_GDI((7, "Rendering Polygon. %d Colors", lNumColors));

NewTrapezoid:

    DBG_GDI((7, "New Trapezoid"));

    //
    // DDA initialization
    // Here we start with LEFT(1) edge and then RIGHT(0) edge
    //
    for ( int iEdge = 1; iEdge >= 0; --iEdge )
    {
        pEdgeData = &aEd[iEdge];
        if ( pEdgeData->lNumOfScanToGo == 0 )
        {
            //
            // No more scan lines left to go. Need a new DDA
            // loop until we have some scan lines to go
            //
            do
            {
                lEdges--;
                if ( lEdges < 0 )
                {
                    //
                    //  This is the only return point for this
                    // "BreakIntoSpans", that is, we return TRUE when there
                    // is no more edge left. We are done.
                    //
                    DBG_GDI((7, "bFillPolygon: returning TRUE"));
                    
                    return TRUE;
                }// if no more edge left

                //
                // Find the next left edge, accounting for wrapping. Before
                // that, save the old edge in "pptfxOld"
                //
                pptfxOld = pEdgeData->pptfx;

                //
                // Get next point
                //
                pEdgeData->pptfx = (POINTFIX*)((BYTE*)pEdgeData->pptfx
                                               + pEdgeData->lPtfxDelta);

                //
                // Checking the end point cases
                //
                if ( pEdgeData->pptfx < pptfxFirst )
                {
                    pEdgeData->pptfx = pptfxLast;
                }
                else if ( pEdgeData->pptfx > pptfxLast )
                {
                    pEdgeData->pptfx = pptfxFirst;
                }

                //
                // Have to find the edge that spans lCurrentSpan.
                // Note: we need to convert it to normal interger first
                //
                pEdgeData->lNumOfScanToGo = ((pEdgeData->pptfx->y + 15) >> 4)
                                          - lCurrentSpan;

                //
                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one
                //
            } while ( pEdgeData->lNumOfScanToGo <= 0 );

            //
            // 'pEdgeData->pptfx' now points to the end point of the edge
            //  spanning the scan 'lCurrentSpan'.
            // Calculate dx(lDX) and dy(lDY)
            //
            lDY = pEdgeData->pptfx->y - pptfxOld->y;
            lDX = pEdgeData->pptfx->x - pptfxOld->x;

            ASSERTDD(lDY > 0, "Should be going down only");

            //
            // Compute the DDA increment terms
            //
            if ( lDX < 0 )
            {
                //
                // X is moving from right to left because it is negative
                //
                lDX = -lDX;
                if ( lDX < lDY )                            // Can't be '<='
                {
                    pEdgeData->lXAdvance = -1;
                    pEdgeData->lErrorUp = lDY - lDX;
                }
                else
                {
                    QUOTIENT_REMAINDER(lDX, lDY, lQuotient, lRemainder);

                    pEdgeData->lXAdvance = -lQuotient;      // - lDX / lDY
                    pEdgeData->lErrorUp = lRemainder;       // lDX % lDY

                    if ( pEdgeData->lErrorUp > 0 )
                    {
                        pEdgeData->lXAdvance--;
                        pEdgeData->lErrorUp = lDY - pEdgeData->lErrorUp;
                    }
                }
            }// lDX is negative
            else
            {
                //
                // X is moving from left to right
                //
                if ( lDX < lDY )                            // Can't be '<='
                {
                    pEdgeData->lXAdvance = 0;
                    pEdgeData->lErrorUp = lDX;
                }
                else
                {
                    QUOTIENT_REMAINDER(lDX, lDY, lQuotient, lRemainder);

                    pEdgeData->lXAdvance = lQuotient;       // lDX / lDY
                    pEdgeData->lErrorUp = lRemainder;       // lDX % lDY
                }
            } // lDX is positive

            pEdgeData->lErrorDown = lDY; // DDA limit

            //
            // Error is initially zero (add lDY -1 for the ceiling, but
            // subtract off lDY so that we can check the sign instead of
            // comparing to lDY)
            //
            pEdgeData->lError     = -1;

            //
            // Current edge X starting point
            //
            pEdgeData->lCurrentXPos = pptfxOld->x;

            //
            // Current edge Y starting point
            //
            lStartY = pptfxOld->y;

            //
            // Check if the floating part of the Y coordinate is 0
            // Note: lStartY is still in 28.4 format
            //
            if ( (lStartY & 15) != 0 )
            {
                //
                // Advance to the next integer y coordinate
                // Note: here "pEdgeData->x += pEdgeData->lXAdvance" only
                // increase its fraction part
                //
                for ( int i = 16 - (lStartY & 15); i != 0; --i )
                {
                    pEdgeData->lCurrentXPos += pEdgeData->lXAdvance;
                    pEdgeData->lError += pEdgeData->lErrorUp;

                    if ( pEdgeData->lError >= 0 )
                    {
                        pEdgeData->lError -= pEdgeData->lErrorDown;
                        pEdgeData->lCurrentXPos++;
                    }
                }
            }// Handle fraction part of the coordinate

            if ( (pEdgeData->lCurrentXPos & 15) != 0 )
            {
                //
                // We'll want the ceiling in just a bit...
                //
                pEdgeData->lError -= pEdgeData->lErrorDown
                                   * (16 - (pEdgeData->lCurrentXPos & 15));
                pEdgeData->lCurrentXPos += 15;
            }

            //
            // Chop off those fractional bits, convert to regular format
            //
            pEdgeData->lCurrentXPos = pEdgeData->lCurrentXPos >> 4;
            pEdgeData->lError >>= 4;

            //
            // Convert to Permedia2 format positions and deltas
            // Note: all the data in pEdgeData, aEd are in Permedia2 format now
            //
            pEdgeData->lCurrentXPos = INTtoFIXED(pEdgeData->lCurrentXPos)
                                    + NEARLY_ONE;
            pEdgeData->lXAdvance = INTtoFIXED(pEdgeData->lXAdvance);
        }// If there is no more scan line left
    }// Looping throught the LEFT and RIGHT edges

    //
    // Number of scans in this trap
    // Note: here aEd[LEFT].lNumOfScanToGo and aEd[RIGHT].lNumOfScanToGo are
    // already in normal interger mode since we have done:
    // pEdgeData->lNumOfScanToGo = ((pEdgeData->pptfx->y + 15) >> 4)
    //                           - lCurrentSpan; above
    //
    lNumScan = min(aEd[LEFT].lNumOfScanToGo, aEd[RIGHT].lNumOfScanToGo);
    aEd[LEFT].lNumOfScanToGo  -= lNumScan;
    aEd[RIGHT].lNumOfScanToGo -= lNumScan;
    lCurrentSpan  += lNumScan;        // Top scan in next trap

    //
    // If the left and right edges are vertical, simply output as a rectangle
    //
    DBG_GDI((7, "Generate spans"));

    lNumOfPass = 0;
    while ( ++lNumOfPass <= lNumColors )
    {
        DBG_GDI((7, "Pass %d lNumColors %d", lNumOfPass, lNumColors));

        if ( lNumColors == 2 )
        {
            //
            // Two colours, so we need to save and restore aEd values
            // and set the color and stipple mode.
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            if ( lNumOfPass == 1 )
            {
                //
                // Pass 1, set color reg as foreground color
                //
                aEdTmp[LEFT]  = aEd[LEFT];
                aEdTmp[RIGHT] = aEd[RIGHT];
                lTempNumScan = lNumScan;

                pBuffer[0] = dwColorReg;
                pBuffer[1] = ulColor[0];
                pBuffer[2] = __Permedia2TagAreaStippleMode;
                pBuffer[3] =  dwAsMode[0];

                DBG_GDI((7, "Pass 1, Stipple set"));
            }
            else
            {
                //
                // Pass 2, set color reg as background color
                //
                aEd[LEFT]  = aEdTmp[LEFT];
                aEd[RIGHT] = aEdTmp[RIGHT];
                lNumScan = lTempNumScan;

                pBuffer[0] = dwColorReg;
                pBuffer[1] = ulColor[1];
                pBuffer[2] = __Permedia2TagAreaStippleMode;
                pBuffer[3] =  dwAsMode[1];

                DBG_GDI((7, "Pass 2, Stipple set, New trap started"));
            }

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }// if (nColor == 2)

        InputBufferReserve(ppdev, 8, &pBuffer);

        //
        // Reset render position to the top of the trapezoid.
        // Note: here aEd[RIGHT].x etc. are alreadu in 12.15 mode since
        // we have done
        // "pEdgeData->x  = INTtoFIXED(pEdgeData->x);" and
        // "pEdgeData->lXAdvance = INTtoFIXED(pEdgeData->lXAdvance);" above
        //
        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  aEd[RIGHT].lCurrentXPos;
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] =  aEd[LEFT].lCurrentXPos;
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] =  INTtoFIXED(lCurrentSpan - lNumScan);
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  dwRenderBits;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        dwContinueMsg = __Permedia2TagContinue;

        if ( ((aEd[LEFT].lErrorUp | aEd[RIGHT].lErrorUp) == 0)
           &&((aEd[LEFT].lXAdvance| aEd[RIGHT].lXAdvance) == 0)
           &&(lNumScan > 1) )
        {
            //
            // Vertical-edge special case
            //
            DBG_GDI((7, "Vertical Edge Special Case"));

            //
            // Tell the hardware that we have "lNumScan" scan lines
            // to fill
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = dwContinueMsg;
            pBuffer[1] = lNumScan;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);
            continue;
        }

        while ( TRUE )
        {
            //
            // Run the DDAs
            //
            DBG_GDI((7, "Doing a span 0x%x to 0x%x, 0x%x scans left.Continue%s",
                     aEd[LEFT].lCurrentXPos, aEd[RIGHT].lCurrentXPos, lNumScan,
                     (dwContinueMsg == __Permedia2TagContinueNewDom) ? "NewDom":
                     ((dwContinueMsg == __Permedia2TagContinue)? "":"NewSub")));

            //
            // Tell the hardware that we have "1" scan lines to fill
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = dwContinueMsg;
            pBuffer[1] = 1;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);

            //
            // We have finished this trapezoid. Go get the next one
            //
            // Advance the right wall
            //
            lTmpRightX = aEd[RIGHT].lCurrentXPos;
            aEd[RIGHT].lCurrentXPos += aEd[RIGHT].lXAdvance;
            aEd[RIGHT].lError += aEd[RIGHT].lErrorUp;

            if ( aEd[RIGHT].lError >= 0 )
            {
                aEd[RIGHT].lError -= aEd[RIGHT].lErrorDown;
                aEd[RIGHT].lCurrentXPos += INTtoFIXED(1);
            }

            //
            // Advance the left wall
            //
            lTmpLeftX = aEd[LEFT].lCurrentXPos;
            aEd[LEFT].lCurrentXPos += aEd[LEFT].lXAdvance;
            aEd[LEFT].lError += aEd[LEFT].lErrorUp;

            if ( aEd[LEFT].lError >= 0 )
            {
                aEd[LEFT].lError -= aEd[LEFT].lErrorDown;
                aEd[LEFT].lCurrentXPos += INTtoFIXED(1);
            }

            if ( --lNumScan == 0 )
            {
                break;
            }

            //
            // Setup the X registers if we have changed either end.
            //
            if ( lTmpRightX != aEd[RIGHT].lCurrentXPos )
            {
                if ( lTmpLeftX != aEd[LEFT].lCurrentXPos )
                {
                    InputBufferReserve(ppdev, 6, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXSub;
                    pBuffer[1] =  aEd[LEFT].lCurrentXPos;
                    pBuffer[2] = __Permedia2TagContinueNewSub;
                    pBuffer[3] =  0;
                    pBuffer[4] = __Permedia2TagStartXDom;
                    pBuffer[5] =  aEd[RIGHT].lCurrentXPos;

                    pBuffer += 6;

                    InputBufferCommit(ppdev, pBuffer);
                }
                else
                {
                    InputBufferReserve(ppdev, 2, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXDom;
                    pBuffer[1] =  aEd[RIGHT].lCurrentXPos;

                    pBuffer += 2;

                    InputBufferCommit(ppdev, pBuffer);
                }

                dwContinueMsg = __Permedia2TagContinueNewDom;             
            }
            else if ( lTmpLeftX != aEd[LEFT].lCurrentXPos )
            {
                InputBufferReserve(ppdev, 2, &pBuffer);

                pBuffer[0] = __Permedia2TagStartXSub;
                pBuffer[1] =  aEd[LEFT].lCurrentXPos;

                pBuffer += 2;

                InputBufferCommit(ppdev, pBuffer);
                dwContinueMsg = __Permedia2TagContinueNewSub;
            }
        }// while ( TRUE )
    }// while ( ++lNumOfPass <= lNumColors )

    DBG_GDI((7, "Generate spans done"));
    goto NewTrapezoid;
}// bFillSpans()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\enable.c ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/
#include "precomp.h"
#include "directx.h"

#include "gdi.h"
#include "text.h"
#include "heap.h"  
#include "dd.h"
#define ALLOC_TAG ALLOC_TAG_NE2P  
PVOID    pCounterBlock;  // some macros need this

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

//----------------------------Public*Structure---------------------------------
//
// GDIINFO ggdiDefault
//
// This contains the default GDIINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//-----------------------------------------------------------------------------
GDIINFO ggdiDefault =
{
    0x5000,                 // Major OS Ver 5, Minor Ver 0, Driver Ver 0
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)
    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)
    TC_RA_ABLE,             // flTextCaps
    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)
    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)
    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long
    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize
    256,                    // ulNumPalReg
    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.
    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },
    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};// GDIINFO ggdiDefault

//-----------------------------Public*Structure--------------------------------
//
// DEVINFO gdevinfoDefault
//
// This contains the default DEVINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//-----------------------------------------------------------------------------
DEVINFO gdevinfoDefault =
{
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_DIRECTDRAW       |
     GCAPS_GRAY16           |       // we handle anti-aliased text
     GCAPS_COLOR_DITHER),
                                    // flGraphicsFlags
    SYSTM_LOGFONT,                  // lfDefaultFont
    HELVE_LOGFONT,                  // lfAnsiVarFont
    COURI_LOGFONT,                  // lfAnsiFixFont
    0,                              // cFonts
    BMF_8BPP,                       // iDitherFormat
    8,                              // cxDither
    8,                              // cyDither
    0,                              // hpalDefault (filled in later)
    GCAPS2_SYNCTIMER |
    GCAPS2_SYNCFLUSH
}; // DEVINFO gdevinfoDefault

//-----------------------------Public*Structure--------------------------------
//
// DFVFN gadrvfn[]
//
// Build the driver function table gadrvfn with function index/address
// pairs.  This table tells GDI which DDI calls we support, and their
// location (GDI does an indirect call through this table to call us).
//
// Why haven't we implemented DrvSaveScreenBits?  To save code.
//
// When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
// the-fly by creating a temporary device-format-bitmap, and explicitly
// calling DrvCopyBits to save/restore the bits.  Since we already hook
// DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
// the bits anyway (which would have been the main reason for implementing
// DrvSaveScreenBits).  So we may as well save some working set.
//
//-----------------------------------------------------------------------------
DRVFN gadrvfnOne[] =
{
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode            },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV          },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap    },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap    },
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface         },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont           },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw     },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV           },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver         },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface        },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw      },
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface         },
    {   INDEX_DrvEscape,                (PFN) DrvEscape                },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo     },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes              },
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer           },
    {   INDEX_DrvNotify,                (PFN) DrvNotify                },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush          },
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV             },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette            },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape       },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt            },
    {   INDEX_DrvSynchronizeSurface,    (PFN) DrvSynchronizeSurface    },
#if THUNK_LAYER
    {   INDEX_DrvAlphaBlend,            (PFN) xDrvAlphaBlend           },
    {   INDEX_DrvBitBlt,                (PFN) xDrvBitBlt               },
    {   INDEX_DrvCopyBits,              (PFN) xDrvCopyBits             },
    {   INDEX_DrvFillPath,              (PFN) xDrvFillPath             },
    {   INDEX_DrvGradientFill,          (PFN) xDrvGradientFill         },
    {   INDEX_DrvLineTo,                (PFN) xDrvLineTo               },
    {   INDEX_DrvStrokePath,            (PFN) xDrvStrokePath           },
    {   INDEX_DrvTextOut,               (PFN) xDrvTextOut              },
    {   INDEX_DrvTransparentBlt,        (PFN) xDrvTransparentBlt       },
#else
    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend            },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits              },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath              },
    {   INDEX_DrvGradientFill,          (PFN) DrvGradientFill          },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath            },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut               },
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt        },
#endif                                        
    {   INDEX_DrvResetDevice,           (PFN) DrvResetDevice           },
};// DRVFN gadrvfnOne[]

// Number of driver callbacks for after NT5.
#define NON_NT5_FUNCTIONS   1


//
// Driver Function array we use when running on NT40. Notice the INDEX_Drv
// calls which we have commneted out implying we dont support these
// calls on NT4.0

DRVFN gadrvfnOne40[] =
{
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode            },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV          },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap    },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap    },
//    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface         },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw     },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV           },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver         },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface        },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw      },
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface         },
    {   INDEX_DrvEscape,                (PFN) DrvEscape                },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo     },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes              },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer           },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush          },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette            },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape       },
//    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp },
//    {   INDEX_DrvNotify,                (PFN) DrvNotify                },
//    {   INDEX_DrvSynchronizeSurface,    (PFN) DrvSynchronizeSurface    },
#if THUNK_LAYER
    {   INDEX_DrvBitBlt,                (PFN) xDrvBitBlt                },
    {   INDEX_DrvCopyBits,              (PFN) xDrvCopyBits              },
    {   INDEX_DrvTextOut,               (PFN) xDrvTextOut               },
//    {   INDEX_DrvAlphaBlend,            (PFN) xDrvAlphaBlend            },
//    {   INDEX_DrvGradientFill,          (PFN) xDrvGradientFill          },
//    {   INDEX_DrvTransparentBlt,        (PFN) xDrvTransparentBlt        },
    {   INDEX_DrvLineTo,                (PFN) xDrvLineTo                },
    {   INDEX_DrvFillPath,              (PFN) xDrvFillPath              },
    {   INDEX_DrvStrokePath,            (PFN) xDrvStrokePath            },
#else
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits              },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut               },
//    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend            },
//    {   INDEX_DrvGradientFill,          (PFN) DrvGradientFill          },
//    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt        },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo                },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath              },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath            },
#endif                                        
};// DRVFN gadrvfnOne40[]

ULONG gcdrvfnOne = sizeof(gadrvfnOne) / sizeof(DRVFN);

//
// Special setup for NT4.0 runtime behaviour
//
ULONG gcdrvfnOne40 = sizeof(gadrvfnOne40) / sizeof(DRVFN);
//
// We initialize this to TRUE and set it to FALSE in 
// DrvEnablePDEV when on NT5.0. We do this using the iEngineVersion passed on
// to us in that call.
//
BOOL g_bOnNT40 = TRUE;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
HSEMAPHORE gLock = NULL;
ULONG gLockCount = 0;
#endif
//@@END_DDKSPLIT

//
// Local prototypes
//
BOOL    bAssertModeHardware(PDev* ppdev, BOOL bEnable);
BOOL    bEnableHardware(PDev* ppdev);
BOOL    bInitializeModeFields(PDev* ppdev, GDIINFO* pgdi,
                              DEVINFO* pdi, DEVMODEW* pdm);
DWORD   getAvailableModes(HANDLE hDriver,
                          PVIDEO_MODE_INFORMATION* modeInformation,
                          DWORD* cbModeSize);
VOID    vDisableHardware(PDev* ppdev);

#define SETUP_LOG_LEVEL  2

//-------------------------------Public*Routine--------------------------------
//
// BOOL DrvEnableDriver
//
// DrvEnableDriver is the initial driver entry point exported by the driver
// DLL. It fills a DRVENABLEDATA structure with the driver version number and
// calling addresses of functions supported by the driver
//
// Parameters:
//  iEngineVersion--Identifies the version of GDI that is currently running.
//  cj--------------Specifies the size in bytes of the DRVENABLEDATA structure.
//                  If the structure is larger than expected, extra members
//                  should be left unmodified. 
//  pded------------Points to a DRVENABLEDATA structure. GDI zero-initializes
//                  cj bytes before the call. The driver fills in its own data.
//
// Return Value
//  The return value is TRUE if the specified driver is enabled. Otherwise, it
//  is FALSE, and an error code is logged.
//
//-----------------------------------------------------------------------------
BOOL
DrvEnableDriver(ULONG          iEngineVersion,
                ULONG          cj,
                DRVENABLEDATA* pded)
{
    ULONG   gcdrvfn;
    DRVFN*  gadrvfn;
    ULONG   DriverVersion;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableDriver: iEngineVersion = 0x%lx\n",
            iEngineVersion, cj, pded));

    // Set up g_bOnNT40 based on the value in iEngineVersion
    if(iEngineVersion >= DDI_DRIVER_VERSION_NT5)
        g_bOnNT40 = FALSE;

    if(g_bOnNT40 == FALSE)
    {
        // Since this driver is backwards compatible,
        // report highest driver version this was built
        // against that the Engine will also recognize.
    
        // Ordered list of supported DDI versions
        ULONG SupportedVersions[] = {
            DDI_DRIVER_VERSION_NT5,
            DDI_DRIVER_VERSION_NT5_01,
        };
        LONG i = sizeof(SupportedVersions)/sizeof(SupportedVersions[0]);

        // Look for highest version also supported by engine
        while (--i >= 0)
        {
            if (SupportedVersions[i] <= iEngineVersion) break;
        }

        // Fail if there isn't common support
        if (i < 0) return FALSE;

        DriverVersion = SupportedVersions[i];

        gadrvfn = gadrvfnOne;
        gcdrvfn = gcdrvfnOne;
        if (iEngineVersion < DDI_DRIVER_VERSION_NT5_01)
        {
            // Trim new DDI hooks since NT5.0
            gcdrvfn -= NON_NT5_FUNCTIONS;
        }

        if(!bEnableThunks())
        {
            ASSERTDD(0,"DrvEnableDriver: bEnableThunks Failed\n");
            return FALSE;
        }
    }
    else
    {
        DriverVersion = DDI_DRIVER_VERSION_NT4;
        gadrvfn = gadrvfnOne40;
        gcdrvfn = gcdrvfnOne40;
    }

    //
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.
    // Fill in as much as we can.
    //
    if ( cj >= (sizeof(ULONG) * 3) )
    {
        pded->pdrvfn = gadrvfn;
    }

    //
    // Tell GDI what are the functions this driver can do
    //
    if ( cj >= (sizeof(ULONG) * 2) )
    {
        pded->c = gcdrvfn;
    }

    //
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.
    //
    if ( cj >= sizeof(ULONG) )
    {
        DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableDriver: iDriverVersion = 0x%lx",
                DriverVersion));
        pded->iDriverVersion = DriverVersion;
    }

    //
    //  add instance to memory tracker if enabled
    //
    MEMTRACKERADDINSTANCE();    

    return(TRUE);
}// DrvEnableDriver()

//-------------------------------Public*Routine--------------------------------
//
// VOID DrvDisableDriver
//
// This function is used by GDI to notify a driver that it no longer requires
// the driver and is ready to unload it.
//
// Comments
//  The driver should free all allocated resources and return the device to the
//  state it was in before the driver loaded.
//
//  DrvDisableDriver is required for graphics drivers.
//
//-----------------------------------------------------------------------------
VOID
DrvDisableDriver(VOID)
{
    //
    // Do nothing
    //

    //
    //  except cleanup memory tracker, if enabled.
    //  also show memory usage
    //
    MEMTRACKERDEBUGCHK();
    MEMTRACKERREMINSTANCE();
   
    return;
}// DrvDisableDriver()

//-------------------------------Public*Routine--------------------------------
//
// DHPDEV DrvEnablePDEV
//
// This function returns a description of the physical device's characteristics
// to GDI. 
//
// It initializes a bunch of fields for GDI, based on the mode we've been asked
// to do.  This is the first thing called after DrvEnableDriver, when GDI wants
// to get some information about the driver.
//
// Parameters
//
//  pdm-------------Points to a DEVMODEW structure that contains driver data. 
//
//  pwszLogAddress--Will always be null and can be ignored
//
//  cPat------------No longer used by GDI and can be ignored 
//
//  phsurfPatterns--No longer used by GDI and can be ignored 
//
//  cjCaps----------Specifies the size of the buffer pointed to by pdevcaps.
//                  The driver must not access memory beyond the end of the
//                  buffer. 
//
//  pdevcaps--------Points to a GDIINFO structure that will be used to describe
//                  device capabilities. GDI zero-initializes this structure
//                  calling DrvEnablePDEV. 
//
//  cjDevInfo-------Specifies the number of bytes in the DEVINFO structure
//                  pointed to by pdi. The driver should modify no more than
//                  this number of bytes in the DEVINFO. 
//
//  pdi-------------Points to the DEVINFO structure, which describes the driver
//                  and the physical device. The driver should only alter the
//                  members it understands. GDI fills this structure with zeros
//                  before a call to DrvEnablePDEV.
//
//  hdev------------Is a GDI-supplied handle to the display driver device that
//                  is being enabled.  The device is in the process of being
//                  created and thus can not be used for Eng calls thus making
//                  this paramter practially useless.  The one exception to this
//                  rule is the use of hdev for calls to EngGetDriverName.  No
//                  other Eng calls are gaurenteed to work.
//
//  pwszDeviceName--Device driver file name stored as a zero terminated ASCII
//                  string
//
//  hDriver---------Identifies the kernel-mode driver that supports the device.
//                  We will use this to make EngDeviceIoControl calls to our
//                  corresponding mini-port driver.
//
//  Returns upon success a handle to the driver-defined device instance
//  information upon success.  Otherwise it returns NULL.
//
//-----------------------------------------------------------------------------
DHPDEV
DrvEnablePDEV(DEVMODEW*   pdm,
              PWSTR       pwszLogAddr,
              ULONG       cPat,
              HSURF*      phsurfPatterns,
              ULONG       cjCaps,
              ULONG*      pdevcaps,
              ULONG       cjDevInfo,
              DEVINFO*    pdi,
              HDEV        hdev,
              PWSTR       pwszDeviceName,
              HANDLE      hDriver)
{
    PDev*   ppdev = NULL;
    GDIINFO gdiinfo;
    DEVINFO devinfo;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnablePDEV(...)"));

    //
    // Invalidate input parameters
    // Note: here we use "<" to check the size of the structure is to ensure
    // that the driver can be used in the future version of NT, in which case
    // that the structure size might go larger

    //
    // GDIINFO and DEVINFO are larger on NT50. On NT40 they are smaller.
    // To make NT50 built driver binary work on NT40, we use temporary copies of
    // GDIINFO and DEVINFO and only copy what cjCaps and cjDevInfo indicate
    // into these structures.

    RtlZeroMemory(&gdiinfo, sizeof(GDIINFO));
    RtlCopyMemory(&gdiinfo, pdevcaps, __min(cjCaps, sizeof(GDIINFO)));
    
    RtlZeroMemory(&devinfo, sizeof(DEVINFO));
    RtlCopyMemory(&devinfo, pdi, __min(cjDevInfo, sizeof(DEVINFO)));

    //
    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:
    //
    ppdev = (PDev*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(PDev), ALLOC_TAG);
    if ( ppdev == NULL )
    {
        DBG_GDI((0, "DrvEnablePDEV: failed memory allocation"));
        goto errExit;
    }

    ppdev->hDriver = hDriver;

    //
    // Initialize status field.
    //    
    ppdev->flStatus = ENABLE_BRUSH_CACHE; 

    // NT50 -> NT40 compat:
    // We dont do Device Bitamps on NT40.
    //
    if(!g_bOnNT40)
        ppdev->flStatus |= STAT_DEV_BITMAPS;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->hsemLock = EngCreateSemaphore();

    if(ppdev->hsemLock == NULL)
    {
        DBG_GDI((0, "DrvEnablePDEV: failed to create semaphore"));
        goto errExit;
    }
#endif
//@@END_DDKSPLIT
    
    //
    // We haven't initialized the pointer yet
    //
    ppdev->bPointerInitialized = FALSE;

    //
    // Get the current screen mode information. Set up device caps and devinfo
    //
    if ( !bInitializeModeFields(ppdev, &gdiinfo, &devinfo, pdm) )
    {
        goto errExit;
    }

    RtlCopyMemory(pdevcaps, &gdiinfo, cjCaps);
    RtlCopyMemory(pdi, &devinfo, cjDevInfo);

    //
    // Initialize palette information.
    //
    if ( !bInitializePalette(ppdev, pdi) )
    {
        goto errExit;
    }

    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnablePDEV(...) returning %lx", ppdev));
    
    return((DHPDEV)ppdev);

errExit:
    
    if( ppdev != NULL )
    {
        DrvDisablePDEV((DHPDEV)ppdev);
    }

    DBG_GDI((0, "Failed DrvEnablePDEV"));

    return(0);
}// DrvEnablePDEV()

//-------------------------------Public*Routine--------------------------------
//
// DrvDisablePDEV
//
// This function is used by GDI to notify a driver that the specified PDEV is
// no longer needed
//
// Parameters
//  dhpdev------Pointer to the PDEV that describes the physical device to be
//              disabled. This value is the handle returned by DrvEnablePDEV.
//
// Comments
//  If the physical device has an enabled surface, GDI calls DrvDisablePDEV
//  after calling DrvDisableSurface. The driver should free any memory and
//  resources used by the PDEV.
//
// DrvDisablePDEV is required for graphics drivers.
//
// Note: In an error, we may call this before DrvEnablePDEV is done.
//
//-----------------------------------------------------------------------------
VOID
DrvDisablePDEV(DHPDEV  dhpdev)
{
    PDev*   ppdev = (PDev*)dhpdev;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvDisablePDEV(%lx)",  ppdev));

    vUninitializePalette(ppdev);
    

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if( ppdev->hsemLock != NULL)
    {
        EngDeleteSemaphore(ppdev->hsemLock);
        ppdev->hsemLock = NULL;
    }
#endif
//@@END_DDKSPLIT

    
    ENGFREEMEM(ppdev);
}// DrvDisablePDEV()

//-------------------------------Public*Routine--------------------------------
//
// DrvResetPDEV
//
// This function is used by GDI to allow a driver to pass state information
// from one driver instance to the next.
//
// Parameters
//  dhpdevOld---Pointer to the PDEV that describes the physical device to be
//              disabled. This value is the handle returned by DrvEnablePDEV.
//  dhpdevNew---Pointer to the PDEV that describes the physical device to be
//              enabled. This value is the handle returned by DrvEnablePDEV.
//
//  
// Return Value
//  TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL
DrvResetPDEV(DHPDEV  dhpdevOld,
             DHPDEV  dhpdevNew)
{
    PDev*   ppdevOld = (PDev*)dhpdevOld;
    PDev*   ppdevNew = (PDev*)dhpdevNew;
    BOOL    bResult = TRUE;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvResetPDEV(%lx,%lx)",  ppdevOld, ppdevNew));

    // pass state information here:

    // sometimes the new ppdev has already some DeviceBitmaps assigned...
    if (ppdevOld->bDdExclusiveMode)
    {
        bResult = bDemoteAll(ppdevNew);
    }

    // pass information if DirectDraw is in exclusive mode
    // to next active PDEV
    
    if(bResult)
    {
        ppdevNew->bDdExclusiveMode=ppdevOld->bDdExclusiveMode;
    }


    return bResult;

}// DrvResetPDEV()

//-------------------------------Public*Routine--------------------------------
//
// VOID DrvCompletePDEV
//
// This function stores the GDI handle (hdev) of the physical device in dhpdev.
// The driver should retain this handle for use when calling GDI services.
//
// Parameters
//  dhpdev------Identifies the physical device by its handle, which was
//              returned to GDI when it called DrvEnablePDEV. 
//  hdev--------Identifies the physical device that has been installed. This is
//              the GDI handle for the physical device being created. The
//              driver should use this handle when calling GDI functions.
//
// Comments
//  DrvCompletePDEV is called by GDI when its installation of the physical
//  device is complete. It also provides the driver with a handle to the PDEV
//  to be used when requesting GDI services for the device. This function is
//  required for graphics drivers; when GDI calls DrvCompletePDEV, it cannot
//  fail.
//
//-----------------------------------------------------------------------------
VOID
DrvCompletePDEV(DHPDEV dhpdev,
                HDEV   hdev)
{
    PDev*       ppdev = (PDev*)dhpdev;
    
    DBG_GDI((SETUP_LOG_LEVEL, "DrvCompletePDEV(%lx, %lx)", dhpdev, hdev));

    ppdev->hdevEng = hdev;

    if(!g_bOnNT40)
    {
        //
        // Retrieve acceleration level before the surface is enabled.
        //
        EngQueryDeviceAttribute(hdev,
                                QDA_ACCELERATION_LEVEL,
                                NULL,
                                0,
                                (PVOID)&ppdev->dwAccelLevel,
                                sizeof(ppdev->dwAccelLevel));
    }
    DBG_GDI((6, "acceleration level %d", ppdev->dwAccelLevel));
}// DrvCompletePDEV()

//-------------------------------Public*Routine--------------------------------
//
// HSURF DrvEnableSurface
//
// This function sets up a surface to be drawn on and associates it with a
// given PDEV and initializes the hardware.  This is called after DrvEnablePDEV
// and performs the final device initialization.
//
// Parameters
//  dhpdev------Identifies a handle to a PDEV. This value is the return value
//              of DrvEnablePDEV. The PDEV describes the physical device for
//              which a surface is to be created. 
//
// Return Value
//  The return value is a handle that identifies the newly created surface.
//  Otherwise, it is zero, and an error code is logged.
//
// Comments
//  Depending on the device and circumstances, the driver can do any of the
//  following to enable the surface: 
//
//  If the driver manages its own surface, the driver can call
//  EngCreateDeviceSurface to get a handle for the surface.
//  GDI can manage the surface completely if the device has a surface that
//  resembles a standard-format bitmap. The driver can obtain a bitmap handle
//  for the surface by calling EngCreateBitmap with a pointer to the buffer for
//  the bitmap. 
//  GDI can collect the graphics directly onto a GDI bitmap. The driver should
//  call EngCreateBitmap, allowing GDI to allocate memory for the bitmap. This
//  function is generally used only by printer devices. 
//  Any existing GDI bitmap handle is a valid surface handle.
//
//  Before defining and returning a surface, a graphics driver must associate
//  the surface with the physical device using EngAssociateSurface. This GDI
//  function allows the driver to specify which graphics output routines are
//  supported for standard-format bitmaps. A call to this function can only be
//  made when no surface exists for the given physical device.
//
//-----------------------------------------------------------------------------
HSURF
DrvEnableSurface(DHPDEV dhpdev)
{
    PDev*       ppdev;
    HSURF       hsurf;
    SIZEL       sizl;
    Surf*       psurf;
    VOID*       pvTmpBuffer;
    BYTE*       pjScreen;
    LONG        lDelta;
    FLONG       flHooks;
    ULONG       DIBHooks;
    
    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableSurface(%lx)", dhpdev));

    ppdev = (PDev*)dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvEnableSurface: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    if ( !bEnableHardware(ppdev) )
    {
        goto errExit;
    }

    //
    // Initializes the off-screen heap
    //
    if ( !bEnableOffscreenHeap(ppdev) )
    {
        goto errExit;
    }

    //
    // The DSURF for the screen is special.
    //
    // It is custom built here as opposed to being allocated via the
    // heap management calls.
    //
    // NOTE: The video memory for  the screen is reserved up front starting
    //    at zero and thus we do not need to allocate this memory from the
    //    video memory heap.
    //
    // NOTE: The DSURF will not be among the list of all of the other DSURFs
    //    which are allocated dynamically.
    //
    // NIT: remove the dynamic allocation of the DSURF.  Instead, just
    //       declare pdsurfScreen as a DSURF instead of a DSURF*.
    //

    psurf = (Surf*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(Surf), ALLOC_TAG);
    if ( psurf == NULL )
    {
        DBG_GDI((0, "DrvEnableSurface: failed pdsurf memory allocation"));
        goto errExit;
    }

    ppdev->pdsurfScreen = psurf;

    psurf->flags       = SF_VM;
    psurf->ppdev       = ppdev;
    psurf->ulByteOffset= 0;
    psurf->ulPixOffset = 0;
    psurf->lDelta      = ppdev->lDelta;
    psurf->ulPixDelta  = ppdev->lDelta >> ppdev->cPelSize;
    vCalcPackedPP(ppdev->lDelta >> ppdev->cPelSize, NULL, &psurf->ulPackedPP);

    //
    // Create screen SURFOBJ.
    //

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    //
    // On NT4.0 we create a GDI managed bitmap as the primay surface. But
    // on NT5.0 we create a device managed primary.
    //
    // On NT4.0 we still use our driver's accleration capabilities by
    // doing a trick with EngLockSurface on the GDI managed primary.
    //

    if(g_bOnNT40)
    {
        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        (ppdev->lDelta > 0) ? BMF_TOPDOWN : 0,
                                        (PVOID)(ppdev->pjScreen));
    }
    else
    {
        hsurf = (HSURF)EngCreateDeviceSurface((DHSURF)psurf, sizl,
                                              ppdev->iBitmapFormat);
    }
 
    if ( hsurf == 0 )
    {
        DBG_GDI((0, "DrvEnableSurface: failed EngCreateDeviceBitmap"));
        goto errExit;
    }

    //
    // On NT5.0 we call EngModifSurface to expose our device surface to
    // GDI. We cant do this on NT4.0 hence we call EngAssociateSurface.
    //
     
    if(g_bOnNT40)
    {
        //
        // We have to associate the surface we just created with our physical
        // device so that GDI can get information related to the PDEV when
        // it's drawing to the surface (such as, for example, the length of 
        // styles on the device when simulating styled lines).
        //

        //
        // On NT4.0 we dont want to be called to Synchronize Access
        //
        SURFOBJ *psoScreen;
        LONG myflHooks = ppdev->flHooks;
        myflHooks &= ~HOOK_SYNCHRONIZE;

        if (!EngAssociateSurface(hsurf, ppdev->hdevEng, myflHooks))
        {
            DBG_GDI((0, "DrvEnableSurface: failed EngAssociateSurface"));
            goto errExit; 
        }

        //
        // Jam in the value of dhsurf into screen SURFOBJ. We do this to
        // make sure the driver acclerates Drv calls we hook and not
        // punt them back to GDI as the SURFOBJ's dhsurf = 0. 
        //
        ppdev->psoScreen = EngLockSurface(hsurf);
        if(ppdev->psoScreen == 0)
        {
            DBG_GDI((0, "DrvEnableSurface: failed EngLockSurface"));
            goto errExit; 
        }

        ppdev->psoScreen->dhsurf = (DHSURF)psurf;

    }
    else
    {
        //
        // Tell GDI about the screen surface.  This will enable GDI to render
        // directly to the screen.
        //

        if ( !EngModifySurface(hsurf,
                               ppdev->hdevEng,
                               ppdev->flHooks,
                               MS_NOTSYSTEMMEMORY,
                               (DHSURF)psurf,
                               ppdev->pjScreen,
                               ppdev->lDelta,
                               NULL))
        {
            DBG_GDI((0, "DrvEnableSurface: failed EngModifySurface"));
            goto errExit;
        }
    }

    if(MAKE_BITMAPS_OPAQUE)
    {
        SURFOBJ*    surfobj = EngLockSurface(hsurf);

        ASSERTDD(surfobj->iType == STYPE_BITMAP,
                    "expected STYPE_BITMAP");

        surfobj->iType = STYPE_DEVBITMAP;

        EngUnlockSurface(surfobj);
    }


    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    //
    // Allocate some pageable memory for temp space.  This will save
    // us from having to allocate and free the temp space inside high
    // frequency calls.
    //
    pvTmpBuffer = ENGALLOCMEM(0, TMP_BUFFER_SIZE, ALLOC_TAG);

    if ( pvTmpBuffer == NULL )
    {
        DBG_GDI((0, "DrvEnableSurface: failed TmpBuffer allocation"));
        goto errExit;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    //
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...
    //

    if ( !bInitializeHW(ppdev) )
    {
        goto errExit;
    }

    //
    // On NT5.0 bEnablePointer call is made in DrvNotify. On NT4.0 we wont
    // get called with DrvNotify and hence we have to call bInitializePointer
    // now.
    //

    if(g_bOnNT40)
    { 
        if ( !bEnablePointer(ppdev) )
        {
            goto errExit;
        }
    }

    if ( !bEnablePalette(ppdev) )
    {
        goto errExit;
    }

    if (!bEnableText(ppdev))
    {
        goto errExit;
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    DBG_GDI((7, "DrvEnableSurface: done with hsurf=%x", hsurf));
    DBG_GDI((6, "DrvEnableSurface: done with dhpdev = %lx", dhpdev));
    
    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableSurface(..) return hsurf = %lx", hsurf));
    
    return(hsurf);

errExit:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    DrvDisableSurface((DHPDEV) ppdev);

    DBG_GDI((0, "DrvEnableSurface: failed"));

    
    return(0);
}// DrvEnableSurface()

//-------------------------------Public*Routine--------------------------------
//
// VOID DrvDisableSurface
//
// This function is used by GDI to notify a driver that the surface created
// by DrvEnableSurface for the current device is no longer needed
//
// Parameters
//  dhpdev------Handle to the PDEV that describes the physical device whose
//              surface is to be released. 
//
// Comments
//  The driver should free any memory and resources used by the surface
//  associated with the PDEV as soon as the physical device is disabled.
//
//  If the driver has been disabled by a call to DrvAssertMode, the driver
//  cannot access the hardware during DrvDisablePDEV because another active
//  PDEV might be in use. Any necessary hardware changes should have been
//  performed during the call to DrvAssertMode. A driver should keep track of
//  whether or not it has been disabled by DrvAssertMode so that it can perform
//  proper cleanup operations in DrvDisablePDEV.
//
//  If the physical device has an enabled surface, GDI calls DrvDisableSurface
//  before calling DrvDisablePDEV.
//
//  DrvDisableSurface is required for graphics drivers
//
// Note: In an error case, we may call this before DrvEnableSurface is
//       completely done.
//
//-----------------------------------------------------------------------------
VOID
DrvDisableSurface(DHPDEV dhpdev)
{
    PDev*   ppdev = (PDev*)dhpdev;
    Surf*   psurf = ppdev->pdsurfScreen;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvDisableSurface(%lx)", ppdev));

    //
    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.
    //
    vDisableText(ppdev);
    vDisableHW(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    ENGFREEMEM(ppdev->pvTmpBuffer);

    if(g_bOnNT40)
        EngUnlockSurface(ppdev->psoScreen);

    EngDeleteSurface(ppdev->hsurfScreen);
    ppdev->hsurfScreen = NULL;

    ENGFREEMEM(psurf);
}// DrvDisableSurface()

//-------------------------------Public*Routine--------------------------------
//
// BOOL DrvAssertMode
//
// This function sets the mode of the specified physical device to either the
// mode specified when the PDEV was initialized or to the default mode of the
// hardware.
//
// Parameters
//
//  dhpdev------Identifies the PDEV describing the hardware mode that should be
//              set.
//  bEnable-----Specifies the mode to which the hardware is to be set. If this
//              parameter is TRUE, then the hardware is set to the original
//              mode specified by the initialized PDEV. Otherwise, the hardware
//              is set to its default mode so the video miniport driver can
//              assume control. 
//
// Comments
//  GDI calls DrvAssertMode when it is required to switch among multiple
//  desktops on a single display surface. To switch from one PDEV to another,
//  GDI calls DrvAssertMode with the bEnable parameter set to FALSE for one
//  PDEV, and TRUE for the other. To revert to the original PDEV, DrvAssertMode
//  is called with bEnable set to FALSE, followed by another call to
//  DrvAssertMode, with bEnable set to TRUE and dhpdev set to the original PDEV
//
//  If the physical device is palette-managed, GDI should call DrvSetPalette to
//  reset the device's palette. The driver does not then need to keep track of
//  the current pointer state because the Window Manager selects the correct
//  pointer shape and moves it to the current position. The Console Manager
//  ensures that desktops are properly redrawn.
//
//  DrvAssertMode is required for display drivers
//
//-----------------------------------------------------------------------------
BOOL
DrvAssertMode(DHPDEV  dhpdev,
              BOOL    bEnable)
{
    PDev*   ppdev = (PDev*)dhpdev;
    BOOL    bRet = FALSE;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvAssertMode(%lx, %lx)", dhpdev, bEnable));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvAssertMode: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    if ( !bEnable )
    {
        //
        // bEnable == FALSE. The hardware is set to its default mode so the
        // video miniport driver can assume control.
        //
        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);
        vAssertModeText(ppdev, FALSE);

        if ( bAssertModeOffscreenHeap(ppdev, FALSE) )
        {
            vAssertModeHW(ppdev, FALSE);

            if ( bAssertModeHardware(ppdev, FALSE) )
            {
                ppdev->bEnabled = FALSE;
                bRet = TRUE;

                goto done;
            }

            //
            // We failed to switch to full-screen.  So undo everything:
            //
            vAssertModeHW(ppdev, TRUE);
        }                                           //   return code with TRUE

        bEnablePointer(ppdev);
        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);
    }// if ( !bEnable )
    else
    {
        //
        // bEnable == TRUE means the hardware is set to the original mode
        // specified by the initialized PDEV
        //
        // Switch back to graphics mode
        //
        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:
        //
        // NOTE: We defer the enabling of the brush and pointer cache
        //       to DrvNotify.  The direct draw heap is not valid
        //       at this point.
        //
        if ( bAssertModeHardware(ppdev, TRUE) )
        {
            vAssertModeHW(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            bRet = TRUE;
        }
    }// bEnable == TRUE

done:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    return(bRet);

}// DrvAssertMode()

//-------------------------------Public*Routine--------------------------------
//
// ULONG DrvGetModes
//
// This function lists the modes supported by the device.
//
// Parameters:
//
//  hDriver-----Specifies the handle to the kernel driver for which the modes
//              must be enumerated. This is the handle that is passed in the
//              hDriver parameter of the DrvEnablePDEV function. 
//  cjSize------Specifies the size, in bytes, of the buffer pointed to by pdm.
//  pdm---------Points to the buffer in which DEVMODEW structures will be
//              written. 
//
// Return Value
//  The return value is the count of bytes written to the buffer, or, if pdm is
//  null, the number of bytes required to hold all mode data. If an error
//  occurs, the return value is zero, and an error code is logged
//
//-----------------------------------------------------------------------------
ULONG
DrvGetModes(HANDLE      hDriver,
            ULONG       cjSize,
            DEVMODEW*   pdm)
{
    DWORD                   cModes;
    DWORD                   cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // How many MODEs the caller wants us to fill
    //
    DWORD                   cOutputModes = cjSize
                                    / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD                   cbModeSize;

    DBG_GDI((7, "DrvGetModes"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION*)&pVideoModeInformation,
                               &cbModeSize);
    if ( cModes == 0 )
    {
        DBG_GDI((0, "DrvGetModes: failed to get mode information"));
        return(0);
    }

    if ( pdm == NULL )
    {
        //
        // GDI only wants to know the number of bytes required to hold all
        // mode data at this moment
        //
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //
        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if ( pVideoTemp->Length != 0 )
            {
                //
                // If the caller's buffer is filled up, we should quit now
                //
                if ( cOutputModes == 0 )
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //
                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion = DM_SPECVERSION;
                pdm->dmDriverVersion = DM_SPECVERSION;

                //
                // We currently do not support Extra information in the driver
                //
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes
                                        * pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;
                pdm->dmPanningWidth     = pdm->dmPelsWidth;
                pdm->dmPanningHeight    = pdm->dmPelsHeight;

                pdm->dmFields           = DM_BITSPERPEL
                                        | DM_PELSWIDTH
                                        | DM_PELSHEIGHT
                                        | DM_DISPLAYFREQUENCY
                                        | DM_DISPLAYFLAGS;
                //
                // Go to the next DEVMODE entry in the buffer.
                //
                cOutputModes--;

                pdm = (LPDEVMODEW)(((UINT_PTR)pdm) + sizeof(DEVMODEW)
                                                   + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
            }// if ( pVideoTemp->Length != 0 )

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                         (((PUCHAR)pVideoTemp) + cbModeSize);
        } while (--cModes);
    }// pbm != NULL

    ENGFREEMEM(pVideoModeInformation);

    return(cbOutputSize);
}// DrvGetModes()

//-----------------------------------------------------------------------------
//
// BOOL bAssertModeHardware
//
// Sets the appropriate hardware state for graphics mode or full-screen.
//
//-----------------------------------------------------------------------------
BOOL
bAssertModeHardware(PDev* ppdev, BOOL  bEnable)
{
    DWORD                   dLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    
    PERMEDIA_DECL;

    DBG_GDI((6, "bAssertModeHardware: bEnable = %d", bEnable));

    if ( bEnable )
    {
        //
        // Call the miniport via an IOCTL to set the graphics mode.
        //
        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_SET_CURRENT_MODE,
                                &ppdev->ulMode,  // input buffer
                                sizeof(DWORD),
                                NULL,
                                0,
                                &dLength) )
        {
            DBG_GDI((0, "bAssertModeHardware: failed VIDEO_SET_CURRENT_MODE"));
            goto errExit;
        }

        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_CURRENT_MODE,
                                NULL,
                                0,
                                &VideoModeInfo,
                                sizeof(VideoModeInfo),
                                &dLength) )
        {
            DBG_GDI((0,"bAssertModeHardware: failed VIDEO_QUERY_CURRENT_MODE"));
            goto errExit;
        }

        //
        // The following variables are determined only after the initial
        // modeset
        // Note: here lVidMemWidth and lVidMemHeight are in "pixel" unit, not
        // bytes
        //
        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;        
        ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->lVidMemWidth = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->lVidMemHeight = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->lDelta = VideoModeInfo.ScreenStride;
        ppdev->flCaps = VideoModeInfo.DriverSpecificAttributeFlags;
        
        DBG_GDI((7, "bAssertModeHardware: Got flCaps 0x%x", ppdev->flCaps));

        DBG_GDI((7, "bAssertModeHardware: using %s pointer",
                 (ppdev->flCaps & CAPS_SW_POINTER) ?
                 "GDI Software Cursor":
                 (ppdev->flCaps & CAPS_TVP4020_POINTER) ?
                 "TI TVP4020" :
                 (ppdev->flCaps & CAPS_P2RD_POINTER) ?
                 "3Dlabs P2RD" : "unknown"));
    }
    else
    {
        //
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:
        //
        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_RESET_DEVICE,
                                NULL,
                                0,
                                NULL,
                                0,
                                &ulReturn) )
        {
            DBG_GDI((0, "bAssertModeHardware: failed reset IOCTL"));
            goto errExit;
        }
    }

    return(TRUE);

errExit:
    DBG_GDI((0, "bAssertModeHardware: failed"));

    return(FALSE);
}// bAssertModeHardware()

//-----------------------------------------------------------------------------
//
// BOOL bEnableHardware
//
// Puts the hardware in the requested mode and initializes it.
//
// Note: This function Should be called before any access is done to the
// hardware from the display driver
//
//-----------------------------------------------------------------------------
BOOL
bEnableHardware(PDev* ppdev)
{
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    DWORD                       dLength;    
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[3];
    
    DBG_GDI((7, "bEnableHardware"));

    //
    // Map control registers into virtual memory:
    //
    VideoMemory.RequestedVirtualAddress = NULL;

    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                            &VideoMemory,               // input buffer
                            sizeof(VIDEO_MEMORY),
                            &VideoAccessRange[0],       // output buffer
                            sizeof (VideoAccessRange),
                            &dLength) )
    {
        DBG_GDI((0,"bEnableHardware: query failed"));
        goto errExit;
    }

    ppdev->pulCtrlBase[0] = (ULONG*)VideoAccessRange[0].VirtualAddress;
    ppdev->pulCtrlBase[1] = (ULONG*)VideoAccessRange[1].VirtualAddress;
    ppdev->pulDenseCtrlBase = (ULONG*)VideoAccessRange[2].VirtualAddress;
        
    ppdev->pulInputDmaCount = ppdev->pulCtrlBase[0] + (PREG_INDMACOUNT>>2);
    ppdev->pulInputDmaAddress = ppdev->pulCtrlBase[0] + (PREG_INDMAADDRESS>>2);
    ppdev->pulFifo = ppdev->pulCtrlBase[0] + (PREG_FIFOINTERFACE>>2);
    ppdev->pulOutputFifoCount = ppdev->pulCtrlBase[0] + (PREG_OUTFIFOWORDS>>2);
    ppdev->pulInputFifoCount = ppdev->pulCtrlBase[0] + (PREG_INFIFOSPACE>>2);
    
    DBG_GDI((7, "bEnableHardware: mapped control registers[0] at 0x%x",
            ppdev->pulCtrlBase[0]));
    DBG_GDI((7, "                 mapped registers[1] at 0x%x",
            ppdev->pulCtrlBase[1]));
    DBG_GDI((7, "                 mapped dense control registers at 0x%x",
            ppdev->pulDenseCtrlBase));

    //
    // Get the linear memory address range.
    //
    VideoMemory.RequestedVirtualAddress = NULL;

    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                            &VideoMemory,      // input buffer
                            sizeof(VIDEO_MEMORY),
                            &VideoMemoryInfo,  // output buffer
                            sizeof(VideoMemoryInfo),
                            &dLength) )
    {
        DBG_GDI((0, "bEnableHardware: error mapping buffer address"));
        goto errExit;
    }

    DBG_GDI((7, "bEnableHardware: frameBufferBase addr = %lx",
              VideoMemoryInfo.FrameBufferBase));
    DBG_GDI((7, "                 frameBufferLength = %l",
              VideoMemoryInfo.FrameBufferLength));
    DBG_GDI((7, "                 videoRamBase addr = %lx",
              VideoMemoryInfo.VideoRamBase));
    DBG_GDI((7, "                 videoRamLength = %l",
              VideoMemoryInfo.VideoRamLength));

    //
    // Record the Frame Buffer Linear Address.
    //
    ppdev->pjScreen = (BYTE*)VideoMemoryInfo.FrameBufferBase;
    ppdev->FrameBufferLength = VideoMemoryInfo.FrameBufferLength;

    //
    // Set hardware states, like ppdev->lVidMemWidth, lVidMemHeight, cxMemory,
    // cyMemory etc
    //
    if ( !bAssertModeHardware(ppdev, TRUE) )
    {
        goto errExit;
    }

    DBG_GDI((7, "bEnableHardware: width = %li height = %li",
             ppdev->cxMemory, ppdev->cyMemory));

    DBG_GDI((7, "bEnableHardware: stride = %li flCaps = 0x%lx",
             ppdev->lDelta, ppdev->flCaps));
    
    return (TRUE);

errExit:

    DBG_GDI((0, "bEnableHardware: failed"));

    return (FALSE);
}// bEnableHardware()

//-----------------------------------------------------------------------------
//
// VOID vDisableHardware
//
// Undoes anything done in bEnableHardware.
//
// Note: In an error case, we may call this before bEnableHardware is
//       completely done.
//
//-----------------------------------------------------------------------------
VOID
vDisableHardware(PDev* ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[3];

    DBG_GDI((6, "vDisableHardware"));

    if (ppdev->pjScreen) 
    {
        VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;
        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                                &VideoMemory[0],
                                sizeof(VIDEO_MEMORY),
                                NULL,
                                0,
                                &ReturnedDataLength))
        {
            DBG_GDI((0, "vDisableHardware: failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->pulCtrlBase[0];
    VideoMemory[1].RequestedVirtualAddress = ppdev->pulCtrlBase[1];
    VideoMemory[2].RequestedVirtualAddress = ppdev->pulDenseCtrlBase;

    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                            &VideoMemory[0],
                            sizeof(VideoMemory),
                            NULL,
                            0,
                            &ReturnedDataLength) )
    {
        DBG_GDI((0, "vDisableHardware: failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }
}// vDisableHardware()

//-----------------------------------------------------------------------------
//
// ULONG ulLog2(ULONG ulVal)
//
// Returns the log base 2 of the given value.  The ulVal must be a power of
// two otherwise the return value is undefined.  If ulVal is zero the return
// value is undefined.
//
//-----------------------------------------------------------------------------
ULONG
ulLog2(ULONG ulVal)
{
    ULONG   ulLog2 = 0;
    ULONG   ulTemp = ulVal >> 1;

    while( ulTemp )
    {
        ulTemp >>= 1;
        ulLog2++;
    }

    ASSERTDD(ulVal == (1UL << ulLog2), "ulLog2: bad value given");

    return ulLog2;
}// ulLog2()

//-----------------------------------------------------------------------------
//
// BOOL bInitializeModeFields
//
// Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
// devinfo based on the requested mode.
//
//-----------------------------------------------------------------------------
BOOL
bInitializeModeFields(PDev*     ppdev,
                      GDIINFO*  pgdi,
                      DEVINFO*  pdi,
                      DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    VIDEO_MODE_INFORMATION  vmi;
    ULONG                   cbModeSize;
    BOOL                    bSelectDefault; // Used for NT4.0 compat only


    DBG_GDI((6, "bInitializeModeFields"));

    //
    // Call the miniport to get mode information, result will be in
    // "pVideoBuffer"
    //
    // Note: the lower level function allocates memory for us in "pVideoBuffer"
    // so we should take care of this later
    //
    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if ( cModes == 0 )
    {
        goto errExit;
    }

    //
    // Now see if the requested mode has a match in that table.
    //
    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if(g_bOnNT40)
    {
        if ( (pdm->dmPelsWidth        == 0)
           &&(pdm->dmPelsHeight       == 0)
           &&(pdm->dmBitsPerPel       == 0)
           &&(pdm->dmDisplayFrequency == 0) )
        {
            DBG_GDI((2, "bInitializeModeFields: default mode requested"));
            bSelectDefault = TRUE;
        }
        else
        {
            DBG_GDI((2, "bInitializeModeFields: Request width = %li height = %li",
                 pdm->dmPelsWidth, pdm->dmPelsHeight));
            DBG_GDI((2, "                               bpp = %li frequency = %li",
                 pdm->dmBitsPerPel, pdm->dmDisplayFrequency));

            bSelectDefault = FALSE;
        }
    }
    else
    {
        //
        // On NT5.0 we should never get an old sytle default mode request. 
        //
        ASSERTDD(pdm->dmPelsWidth        != 0 &&
                 pdm->dmPelsHeight       != 0 &&
                 pdm->dmBitsPerPel       != 0 &&
                 pdm->dmDisplayFrequency != 0,
                 "bInitializeModeFields: old style default mode request");
    }

    while ( cModes-- )
    {
        if ( pVideoTemp->Length != 0 )
        {
            DBG_GDI((7, "bInitializeModeFields: check width = %li height = %li",
                     pVideoTemp->VisScreenWidth,
                     pVideoTemp->VisScreenHeight));
            DBG_GDI((7, "                             bpp = %li freq = %li",
                     pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes,
                     pVideoTemp->Frequency));
            //
            // Handle old style default mode case only on NT4.0
            //
            if(g_bOnNT40 && bSelectDefault)
            {
                pVideoModeSelected = pVideoTemp;
                DBG_GDI((7, "bInitializeModeFields: found a mode match(default)"));
                break;
            }

            if ( (pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth)
              && (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight)
              && (pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes
                                                     == pdm->dmBitsPerPel)
              && (pVideoTemp->Frequency == pdm->dmDisplayFrequency) )
            {
                pVideoModeSelected = pVideoTemp;
                DBG_GDI((7, "bInitializeModeFields: found a mode match!"));
                break;
            }
        }//  if the video mode info structure buffer is not empty

        //
        // Move on to next video mode structure
        //
        pVideoTemp = (PVIDEO_MODE_INFORMATION)(((PUCHAR)pVideoTemp)
                                               + cbModeSize);
    }// while ( cModes-- )

    //
    // If no mode has been found, return an error
    //
    if ( pVideoModeSelected == NULL )
    {
        DBG_GDI((0, "bInitializeModeFields: couldn't find a mode match!"));
        ENGFREEMEM(pVideoBuffer);
        
        goto errExit;
    }

    //
    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.
    //
    vmi = *pVideoModeSelected;
    ENGFREEMEM(pVideoBuffer);

    //
    // Set up screen information from the mini-port:
    //
    ppdev->ulMode           = vmi.ModeIndex;
    ppdev->cxScreen         = vmi.VisScreenWidth;
    ppdev->cyScreen         = vmi.VisScreenHeight;
    ppdev->cBitsPerPel      = vmi.BitsPerPlane;

    DBG_GDI((7, "bInitializeModeFields: screenStride = %li", vmi.ScreenStride));

    ppdev->flHooks          = HOOK_SYNCHRONIZE
                            | HOOK_FILLPATH
                            | HOOK_STROKEPATH
                            | HOOK_LINETO                            
                            | HOOK_TEXTOUT
                            | HOOK_BITBLT
                            | HOOK_COPYBITS;

    if(!g_bOnNT40)
        ppdev->flHooks |=  HOOK_TRANSPARENTBLT |
                           HOOK_ALPHABLEND     |
                           HOOK_STRETCHBLT     |
                           HOOK_GRADIENTFILL;
    //
    // Fill in the GDIINFO data structure with the default 8bpp values:
    //
    *pgdi = ggdiDefault;

    //
    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:
    //
    pgdi->ulHorzSize        = vmi.XMillimeter;
    pgdi->ulVertSize        = vmi.YMillimeter;
    pgdi->ulHorzRes         = vmi.VisScreenWidth;
    pgdi->ulVertRes         = vmi.VisScreenHeight;
    pgdi->ulPanningHorzRes  = vmi.VisScreenWidth;
    pgdi->ulPanningVertRes  = vmi.VisScreenHeight;

    pgdi->cBitsPixel        = vmi.BitsPerPlane;
    pgdi->cPlanes           = vmi.NumberOfPlanes;
    pgdi->ulVRefresh        = vmi.Frequency;

    pgdi->ulDACRed          = vmi.NumberRedBits;
    pgdi->ulDACGreen        = vmi.NumberGreenBits;
    pgdi->ulDACBlue         = vmi.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    //
    // Fill in the devinfo structure with the default 8bpp values:
    //
    *pdi = gdevinfoDefault;

    //
    // Bytes per pel 4/2/1 for 32/16/8 bpp
    //

    ppdev->cjPelSize        = vmi.BitsPerPlane >> 3;

    //
    // Bytes per pel log 2  
    //

    ppdev->cPelSize         = ulLog2(ppdev->cjPelSize);
    
    //
    // = 2,1,0 for 32,16,8 depth.  Shifts needed to calculate bytes/pixel
    //
    ppdev->bPixShift = (BYTE) ppdev->cPelSize;

    //
    // = 0,1,2 for 32/16/8.
    //
    ppdev->bBppShift = 2 - ppdev->bPixShift;
    
    //
    // = 3,1,0 for 8,16,32 bpp
    //
    ppdev->dwBppMask = 3 >> ppdev->bPixShift;
    
    
    switch ( vmi.BitsPerPlane )
    {
        case 8:
            ppdev->iBitmapFormat   = BMF_8BPP;

            ASSERTDD(vmi.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN,
                     "bInitializeModeFields: unexpected non-palette 8bpp mode");
                
            ppdev->ulWhite         = 0xff;
            
            ppdev->ulPermFormat = PERMEDIA_8BIT_PALETTEINDEX;
            ppdev->ulPermFormatEx = PERMEDIA_8BIT_PALETTEINDEX_EXTENSION;

            if(g_bOnNT40)
                pdi->flGraphicsCaps &= ~GCAPS_COLOR_DITHER;

            // No AntiAliased text support in 8bpp mode. 
            pdi->flGraphicsCaps &= ~GCAPS_GRAY16;
            break;

        case 16:            
            ppdev->iBitmapFormat   = BMF_16BPP;
            ppdev->flRed           = vmi.RedMask;
            ppdev->flGreen         = vmi.GreenMask;
            ppdev->flBlue          = vmi.BlueMask;

            pgdi->ulNumColors      = (ULONG)-1;
            pgdi->ulNumPalReg      = 0;
            pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

            pdi->iDitherFormat     = BMF_16BPP;
            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

            // support gamma ramp changes
            pdi->flGraphicsCaps2  |= GCAPS2_CHANGEGAMMARAMP;

            ppdev->ulWhite         = vmi.RedMask
                                   | vmi.GreenMask
                                   | vmi.BlueMask;

            ppdev->ulPermFormat = PERMEDIA_565_RGB;
            ppdev->ulPermFormatEx = PERMEDIA_565_RGB_EXTENSION;

            break;

        case 32:            
            ppdev->iBitmapFormat   = BMF_32BPP;

            ppdev->flRed           = vmi.RedMask;
            ppdev->flGreen         = vmi.GreenMask;
            ppdev->flBlue          = vmi.BlueMask;            

            pgdi->ulNumColors      = (ULONG)-1;
            pgdi->ulNumPalReg      = 0;
            pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

            pdi->iDitherFormat     = BMF_32BPP;
            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

            //
            // Support gamma ramp changes
            //
            pdi->flGraphicsCaps2  |= GCAPS2_CHANGEGAMMARAMP;
            
            ppdev->ulWhite         = vmi.RedMask
                                   | vmi.GreenMask
                                   | vmi.BlueMask;
            
            ppdev->ulPermFormat = PERMEDIA_888_RGB;
            ppdev->ulPermFormatEx = PERMEDIA_888_RGB_EXTENSION;

            break;

        default:
            ASSERTDD(0, "bInitializeModeFields: bit depth not supported");
            goto errExit;
    }// switch on clor depth


    return(TRUE);

errExit:
    
    DBG_GDI((0, "bInitializeModeFields: failed"));

    return(FALSE);
}// bInitializeModeFields()

//-----------------------------------------------------------------------------
//
// DWORD getAvailableModes
//
// Calls the miniport to get the list of modes supported by the kernel driver.
// Prunes the list to only those modes supported by this driver.
//
// Returns the number of entries supported and returned in the
// modeInformation array.  If the return value is non-zero, then
// modeInformation was set to point to a valid mode information array. It is
// the responsibility of the caller to free this array when it is no longer
// needed.
//
//-----------------------------------------------------------------------------
DWORD
getAvailableModes(HANDLE                    hDriver,
                  PVIDEO_MODE_INFORMATION*  modeInformation,
                  DWORD*                    cbModeSize)
{
    ULONG                    ulTemp;
    VIDEO_NUM_MODES          modes;
    PVIDEO_MODE_INFORMATION  pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //
    if ( EngDeviceIoControl(hDriver,
                            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                            NULL,
                            0,
                            &modes,
                            sizeof(VIDEO_NUM_MODES),
                            &ulTemp) )
    {
        DBG_GDI((0, "getAvailableModes: failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //
    *modeInformation = (VIDEO_MODE_INFORMATION*)ENGALLOCMEM(FL_ZERO_MEMORY,
                                modes.NumModes  * modes.ModeInformationLength,
                                ALLOC_TAG);

    if ( *modeInformation == (PVIDEO_MODE_INFORMATION)NULL )
    {
        DBG_GDI((0, "getAvailableModes: fFailed memory allocation"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //
    if ( EngDeviceIoControl(hDriver,
                            IOCTL_VIDEO_QUERY_AVAIL_MODES,
                            NULL,
                            0,
                            *modeInformation,
                            modes.NumModes * modes.ModeInformationLength,
                            &ulTemp) )
    {
        DBG_GDI((0, "getAvailableModes: failed VIDEO_QUERY_AVAIL_MODES"));

        ENGFREEMEM(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION)NULL;

        return (0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // A non-supported mode is invalidated by setting the length to 0.
    //
    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16 or 32 bits per pel.
    //
    while ( ulTemp-- )
    {
        if ( (pVideoTemp->NumberOfPlanes != 1 )
           ||!(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS)
           ||(  (pVideoTemp->BitsPerPlane != 8)              
              &&(pVideoTemp->BitsPerPlane != 16)
              &&(pVideoTemp->BitsPerPlane != 32))
           || (pVideoTemp->VisScreenWidth > 2000)
           || (pVideoTemp->VisScreenHeight > 2000) )
        {
            DBG_GDI((2, "getAvailableModes: rejecting miniport mode"));
            DBG_GDI((2, "                   width = %li height = %li",
                     pVideoTemp->VisScreenWidth,
                     pVideoTemp->VisScreenHeight));
            DBG_GDI((2, "                   bpp = %li freq = %li",
                     pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes,
                     pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
                     (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return (modes.NumModes);
}// getAvailableModes()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvNotify
//
//-----------------------------------------------------------------------------
VOID
DrvNotify(SURFOBJ*  pso,
          ULONG     iType,
          PVOID     pvData)
{
    PPDev   ppdev = (PPDev) pso->dhpdev;

    switch( iType )
    {   
        case DN_DEVICE_ORIGIN:
        {
            ppdev->ptlOrigin = *((POINTL*) pvData);
            
            DBG_GDI((6,"DrvNotify: origin at %ld, %ld",
                    ppdev->ptlOrigin.x, ppdev->ptlOrigin.y));
        }
            break;

        case DN_DRAWING_BEGIN:
        {
            bEnablePointer(ppdev);
            bEnableBrushCache(ppdev);
        }
            break;
    
        default:
            // do nothing
            break;
    }
}// DrvNotify()


//-----------------------------Public*Routine----------------------------------
//
// ULONG DrvResetDevice
//
// This function is used by GDI to request that the specified device be
// reset to an operational state.  Safe steps should be taken to keep
// data loss at a minimum.  It may be called anytime between DrvEnablePDEV
// and DrvDisablePDEV.
//
// Parameters
//  dhpdev------Identifies a handle to a PDEV. This value is the return value
//              of DrvEnablePDEV. The PDEV describes the physical device for
//              which a reset is requested. 
//
// Upon successful reset of the device DRD_SUCCESS should be returned.
// Otherwise return DRD_ERROR.
//
//-----------------------------------------------------------------------------

ULONG
DrvResetDevice(
    DHPDEV dhpdev,
    PVOID Reserved
    )
{
    DBG_GDI((0, "DrvResetDevice called."));

    // TODO: Place code to reset device here.

    return DRD_ERROR;
}// DrvResetDevice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\heap.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.c
*
* This module contains the routines for an off-screen video heap manager.
* It is used primarily for allocating space for device-format-bitmaps in
* off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"
#include "log.h"
#include "heap.h"
#define ALLOC_TAG ALLOC_TAG_EH2P
//-----------------------------------------------------------------------------
//
// void vRemoveSurfFromList(Surf* psurf)
//
// Removes the surface from the surface list
//
//-----------------------------------------------------------------------------
VOID
vRemoveSurfFromList(PPDev ppdev, Surf* psurf)
{
    DBG_GDI((3, "vRemoveSurfFromList removing psruf=0x%x", psurf));

//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vRemoveSurfFromList);
//@@END_DDKSPLIT
    
    if ( psurf != NULL && psurf->flags & SF_LIST)
    {
        Surf* pHead = ppdev->psurfListHead;
        Surf* pTail = ppdev->psurfListTail;

        if ( psurf == pHead )
        {
            DBG_GDI((3, "vRemoveSurfFromList removing 1st one"));

            //
            // Remove the first one in the list
            //
            Surf* pNextSurf = psurf->psurfNext;

            if ( pNextSurf != NULL )
            {
                pNextSurf->psurfPrev = NULL;
                ppdev->psurfListHead = pNextSurf;

                DBG_GDI((3, "Move head to 0x%x", ppdev->psurfListHead));
            }
            else
            {
                //
                // This is the only psurf in our list. Let head and tail all
                // point to NULL after removal
                //
                DBG_GDI((3, "vRemoveSurfFromList: the only one in list"));
                ppdev->psurfListHead = NULL;
                ppdev->psurfListTail = NULL;
            }
        }// The psurf happens to be the first one in the list
        else if ( psurf == pTail )
        {
            DBG_GDI((3, "vRemoveSurfFromList removing last one"));

            //
            // Remove the last one in the list
            //
            ppdev->psurfListTail = psurf->psurfPrev;
            ppdev->psurfListTail->psurfNext = NULL;
        }// The psurf happens to be the last one in the list
        else
        {
            //
            // Normal case, the psurf is in the middle of a list
            //
            Surf*   psurfPrev = psurf->psurfPrev;
            Surf*   psurfNext = psurf->psurfNext;

            DBG_GDI((3, "vRemoveSurfFromList removing middle one"));
            psurfPrev->psurfNext = psurfNext;
            psurfNext->psurfPrev = psurfPrev;
        }

        psurf->psurfNext = NULL;
        psurf->psurfPrev = NULL;
        psurf->flags &= ~SF_LIST;

    }// if ( psurf != NULL )
}// vRemoveSurfFromList()

//-----------------------------------------------------------------------------
//
// void vAddSurfToList(PPDev ppdev, Surf* psurf)
//
// Adds the surface to the surface list
//
// Note: We always add the surface to the end of the list.
//
//-----------------------------------------------------------------------------
VOID
vAddSurfToList(PPDev ppdev, Surf* psurf)
{
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vAddSurfToList);
//@@END_DDKSPLIT
    
    if ( ppdev->psurfListHead == NULL )
    {
        DBG_GDI((3, "vAddSurfToList add psurf=0x%x as 1st one", psurf));

        //
        // First time add a pdsurf to the surface list
        //
        ppdev->psurfListHead = psurf;
        ppdev->psurfListTail = psurf;
        psurf->psurfPrev = NULL;
        psurf->psurfNext = NULL;
        DBG_GDI((6, "vAddSurfToList set pHead as 0x%x", ppdev->psurfListHead));
    }
    else
    {
        Surf* pTail = ppdev->psurfListTail;

        DBG_GDI((3, "vAddSurfToList add psurf=0x%x as the tail", psurf));

        //
        // Add this psurf to the end
        //
        pTail->psurfNext = psurf;
        psurf->psurfPrev = pTail;
        ppdev->psurfListTail = psurf;

        DBG_GDI((6, "vAddSurfToList done: psurf->psurfPrev=0x%x",
                 psurf->psurfPrev));
    }

    psurf->flags |= SF_LIST;

}// vAddSurfToList()

//-----------------------------------------------------------------------------
//
// void vShiftSurfToListEnd(PPDev ppdev, Surf* psurf)
//
// Shifts the surface from its current position in the surface list to the
// end of surface list
//
//-----------------------------------------------------------------------------
VOID
vShiftSurfToListEnd(PPDev ppdev, Surf* psurf)
{
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vShiftSurfToListEnd);
//@@END_DDKSPLIT
    
    Surf* pTail = ppdev->psurfListTail;
    
    DBG_GDI((6, "vShiftSurfToListEnd psurf=0x%x, pTail=0x%x", psurf, pTail));

    //
    // We don't need to shift a NULL psurf or the psurf is already at the end
    // of our surface list
    //
    if ( (psurf != NULL) && (psurf != pTail) )
    {
        Surf* pHead = ppdev->psurfListHead;

        DBG_GDI((6, "vShiftSurfToListEnd pHead=0x%x, pTail=0x%x",
                 pHead, pTail));
        if ( psurf == pHead )
        {
            //
            // The surf is the first one in our list.
            // So, first we shift the head and let it points to the next one
            // in the list
            //
            ppdev->psurfListHead = psurf->psurfNext;
            ppdev->psurfListHead->psurfPrev = NULL;

            //
            // Let the tail point to this psurf
            //
            pTail->psurfNext = psurf;
            psurf->psurfPrev = pTail;
            psurf->psurfNext = NULL;
            ppdev->psurfListTail = psurf;

            DBG_GDI((6,"1st shifted. New pHead=0x%x", ppdev->psurfListHead));
        }// psurf is the 1st one in the list
        else
        {
            //
            // The surface is in the middle of the surface list
            //
            Surf* psurfPrev = psurf->psurfPrev;
            Surf* psurfNext = psurf->psurfNext;

            DBG_GDI((6, "vShiftSurfToListEnd psurfPrev=0x%x, psurfNext=0x%x",
                    psurfPrev, psurfNext));
            psurfPrev->psurfNext = psurfNext;
            psurfNext->psurfPrev = psurfPrev;

            //
            // Add this psurf to the end
            //
            pTail->psurfNext = psurf;
            psurf->psurfPrev = pTail;
            psurf->psurfNext = NULL;
            ppdev->psurfListTail = psurf;
        }// Normal position
    }// psurf is NULL or already at the end
}// vShiftSurfToListEnd()

//-----------------------------------------------------------------------------
//
// void vSurfUsed
//
// Informs the heap manager that the surface has been accessed.
//
// Surface access patterns are the only hint that the heap manager receives
// about the usage pattern of surfaces.  From this limited  information, the
// heap manager must decide what surfaces to throw out of video memory when
// the amount of available video memory reaches zero.
//
// For now, we will implement a LRU algorithm by placing any accessed
// surfaces at the tail of the surface list.
//
//-----------------------------------------------------------------------------
VOID
vSurfUsed(PPDev ppdev, Surf* psurf)
{

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "vSurfUsed: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    if( psurf->flags & SF_LIST )
    {
        // shift any surface that we have allocated to the end of the
        // list
        vShiftSurfToListEnd(ppdev, psurf);
    }
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    
}// vSurfUsed()

//-----------------------------------------------------------------------------
//
// This function copies the bits from off-screen memory to the DIB
//
// Parameters
//  ppdev-----------PPDEV
//  pvSrc-----------Source pointer in the off-screen bitmap
//  lBytesToUpLoad--Number of bytes to upload
//  pvDst-----------Destination pointer in the DIB
//
//-----------------------------------------------------------------------------
VOID
vUpload(PPDev   ppdev,
        void*   pvSrc,
        LONG    lBytesToUpLoad,
        void*   pvDst)
{
    LONG        lBytesAvailable;    
    DWORD       srcData;    
    BYTE*       pBitmapByte;
    USHORT*     pBitmapShort;
    ULONG*      pBitmapLong;
    LONG        lNumOfPixel;

    PERMEDIA_DECL;

    DBG_GDI((7, "vUploadRect called"));    
    DBG_GDI((3, "%ld bytes need to be uploaded at %x\n",
             lBytesToUpLoad, pvSrc));

//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vUpload);
#if MULTITHREADED && DBG
    ppdev->pP2dma->ppdev = ppdev;
#endif
//@@END_DDKSPLIT

#if !defined(DMA_NOTWORKING)
    if(ppdev->bGdiContext)
    {
        InputBufferSync(ppdev);
    }
    else
    {
        vSyncWithPermedia(ppdev->pP2dma);
    }
    memcpy(pvDst, pvSrc, lBytesToUpLoad);
#else
    
    P2_DEFAULT_FB_DEPTH;

    //
    // Set up the relevant units correctly
    // ColorDDAMode is DISABLED at initialisation time so there is no need
    // to re-load it here.
    //
    WAIT_INPUT_FIFO(3);
    SEND_TAG_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_TAG_DATA(FBWriteMode, __PERMEDIA_DISABLE); // In "read" mode
    SEND_TAG_DATA(FBReadMode, (permediaInfo->FBReadMode
                                        |__FB_READ_DESTINATION
                                        |__FB_COLOR));

    //
    // Enable filter mode so we can get Sync and color messages on the output
    // FIFO
    //
    data.Word = 0;
    data.FilterMode.Synchronization = __PERMEDIA_FILTER_TAG;
    data.FilterMode.Color           = __PERMEDIA_FILTER_DATA;
    SEND_TAG_DATA(FilterMode, data.Word);
    DEXE_INPUT_FIFO();    

    DBG_GDI((7, "pvDst = %x", pvDst));

    switch ( ppdev->cPelSize )
    {
        case 0:
            //
            // Initialise current pointer
            //
            pBitmapByte = (BYTE*)pvDst;            
            lNumOfPixel = lPixelsToUpLoad;

            //
            // Loop to read in all the "lNumOfPixel" bytes
            //
            while ( lNumOfPixel > 0 )
            {
                //
                // Get number of bytes available in the FIFO
                //
                WAIT_OUTPUT_FIFO_NOT_EMPTY(lBytesAvailable);

                //
                // Decrease the total number of bytes we need to read
                //
                lNumOfPixel -= lBytesAvailable;

                //
                // We don't want to over read. Reset "lBytesAvailable" if we
                // have more available in the FIFO than we required
                //
                if ( lNumOfPixel < 0 )
                {
                    lBytesAvailable += lNumOfPixel;
                }

                //
                // Read in "lBytesAvailable" bytes
                //
                while ( --lBytesAvailable >= 0 )
                {
                    READ_OUTPUT_FIFO(srcData);
                    *pBitmapByte++ = (BYTE)srcData;
                }
            }// while ( lNumOfPixel > 0 )                    

            break;

        case 1:               
            //
            // Initialise current pointer
            //
            pBitmapShort = (USHORT*)pvDst;

            lNumOfPixel = lPixelsToUpLoad;
            while ( lNumOfPixel > 0 )
            {
                WAIT_OUTPUT_FIFO_NOT_EMPTY(lBytesAvailable);
                lNumOfPixel -= lBytesAvailable;
                if ( lNumOfPixel < 0 )
                {
                    lBytesAvailable += lNumOfPixel;
                }

                while ( --lBytesAvailable >= 0 )
                {
                    READ_OUTPUT_FIFO(srcData);
                    *pBitmapShort++ = (USHORT)srcData;
                }
            }                    

            break;

        case 2:
            //
            // True color mode, use DWORD as reading UNIT, here pBitmapLong
            // points to the destination address, that is, the BMP data address
            // in main memory
            //            
            pBitmapLong = (ULONG*)pvDst;

            lNumOfPixel = lPixelsToUpLoad;

            //
            // Loop until we upload all the pixels
            //
            while ( lNumOfPixel > 0 )
            {
                //
                // Wait until we have something to read
                //
                WAIT_OUTPUT_FIFO_NOT_EMPTY(lBytesAvailable);

                //
                // Check here to guarntee that we don't read more than we
                // asked for
                //
                lNumOfPixel -= lBytesAvailable;
                if ( lNumOfPixel < 0 )
                {
                    lBytesAvailable += lNumOfPixel;
                }

                //
                // Read all these available BYTES, READ_OUTPUT_FIFO, in FIFO
                // to main memory
                //
                while ( --lBytesAvailable >= 0 )
//                while ( lBytesAvailable > 0 )
                {
                    READ_OUTPUT_FIFO(*pBitmapLong);                    
                    ++pBitmapLong;
//                    lBytesAvailable -= 4;
                }
            }

            break;
    }// switch ( ppdev->cPelSize )        

    //
    // Don't bother with a WAIT_INPUT_FIFO, as we know FIFO is empty.
    // We need to reset the chip back to its standard state. This
    // means: enable FB writes and set the filter mode back to allow
    // only syncs through.
    //
    WAIT_INPUT_FIFO(2);
    SEND_TAG_DATA(FBWriteMode, permediaInfo->FBWriteMode);
    SEND_TAG_DATA(FilterMode, 0);
    EXE_INPUT_FIFO();

    DBG_GDI((7, "vUploadRectNative: done"));
#endif
}// vUpload()

//---------------------------------------------------------------------------
//
// ULONG ulVidMemAllocate
//
// This function allocates "lWidth" by "lHeight" bytes of video memory
//
// Parameters:
//  ppdev----------PPDEV
//  lWidth---------Width of the memory to allocate
//  lHeight--------Height of the memory to allocate
//  lPelSize-------Pixel Size of memory chunk
//  plDelta--------lDelta of this memory chunk
//  ppvmHeap-------Pointer to a video memory heap, local or non-local etc.
//  pulPackedPP----Packed products
//  bDiscardable---TRUE if the surface can be discarded if needed
//
//--------------------------------------------------------------------------
ULONG
ulVidMemAllocate(PDev*           ppdev,
                 LONG            lWidth,
                 LONG            lHeight,
                 LONG            lPelSize,
                 LONG*           plDelta,
                 VIDEOMEMORY**   ppvmHeap,
                 ULONG*          pulPackedPP,
                 BOOL            bDiscardable )
{
    ULONG               iHeap;
    VIDEOMEMORY*        pvmHeap;
    ULONG               ulByteOffset;
    LONG                lDelta;
    LONG                lNewDelta;
    ULONG               packedPP;
    SURFACEALIGNMENT    alignment;  // DDRAW heap management allignment stru

    //
    // Dont allocate any video memory on NT40, just let GDI do all the
    // allocating.
    //
    if(g_bOnNT40)
        return 0;

    memset(&alignment, 0, sizeof(alignment));

    //
    // Calculate lDelta and partical products based on lWidth
    // The permedia has surface width restrictions that must be met
    //
    vCalcPackedPP(lWidth, &lDelta, &packedPP);
    lDelta <<= lPelSize;

    //
    // Set alignment requirements
    //   - must start at an pixel address
    //   - pitch needs to be lDelta
    //

    alignment.Linear.dwStartAlignment = ppdev->cjPelSize;
    alignment.Linear.dwPitchAlignment = lDelta;

    //
    // Indicate that this allocation can be discarded if a DDraw/D3D
    // app really needs the memory
    //

    if( bDiscardable )
    {
        alignment.Linear.dwFlags = SURFACEALIGN_DISCARDABLE;
    }

    //
    // Loop through all the heaps to find available memory
    // Note: This ppdev->cHeap info was set in DrvGetDirectDrawInfo
    // when the driver is initialized
    //
    for ( iHeap = 0; iHeap < ppdev->cHeaps; iHeap++ )
    {
        pvmHeap = &ppdev->pvmList[iHeap];

        //
        // Since we are using DDRAW run time heap management code. It is
        // possible that the heap hasn't been initialized. For example, if
        // we fail in DrvEnableDirectDraw(), then the system won't initialize
        // the heap for us
        //
        if ( pvmHeap == NULL )
        {
            DBG_GDI((1, "Video memory hasn't been initialzied"));
            return 0;
        }

        //
        // AGP memory could be potentially used for device-bitmaps, with
        // two very large caveats:
        //
        // 1. No kernel-mode view is made for the AGP memory (would take
        //    up too many PTEs and too much virtual address space).
        //    No user-mode view is made either unless a DirectDraw
        //    application happens to be running.  Consequently, neither
        //    GDI nor the driver can use the CPU to directly access the
        //    bits.  (It can be done through the accelerator, however.)
        //
        // 2. AGP heaps never shrink their committed allocations.  The
        //    only time AGP memory gets de-committed is when the entire
        //    heap is empty.  And don't forget that committed AGP memory
        //    is non-pageable.  Consequently, if you were to enable a
        //    50 MB AGP heap for DirectDraw, and were sharing that heap
        //    for device bitmap allocations, after running a D3D game
        //    the system would never be able to free that 50 MB of non-
        //    pageable memory until every single device bitmap was deleted!
        //    Just watch your Winstone scores plummet if someone plays
        //    a D3D game first.
        //
        if ( !(pvmHeap->dwFlags & VIDMEM_ISNONLOCAL) )
        {
            //
            // Ask DDRAW heap management to allocate memory for us
            //
            ulByteOffset = (ULONG)HeapVidMemAllocAligned(pvmHeap,
                                                         lDelta,
                                                         lHeight,
                                                         &alignment,
                                                         &lNewDelta);
            
            DBG_GDI((3, "allocate %d bytes----got memory offset %ld real %x",
                     lWidth * ppdev->cjPelSize * lHeight,
                     ulByteOffset, (VOID*)(ppdev->pjScreen + ulByteOffset)));

            if ( ulByteOffset != 0 )
            {
                ASSERTDD(lDelta == lNewDelta,
                         "ulVidMemAllocate: deltas don't match");

                *ppvmHeap    = pvmHeap;
                *plDelta     = lDelta;
                *pulPackedPP = packedPP;

                //
                // We are done
                //
                return (ulByteOffset);
            }// if ( pdsurf != NULL )
        }// if (!(pvmHeap->dwFlags & VIDMEM_ISNONLOCAL))
    }// loop through all the heaps to see if we can find available memory

    return 0;
}// ulVidMemAllocate()

//---------------------------------------------------------------------------
//
// VOID vDeleteSurf(DSURF* pdsurf)
//
// This routine frees a DSURF structure and the video or system memory inside
// this DSURF
//
//----------------------------------------------------------------------------
VOID
vDeleteSurf(Surf* psurf)
{
    DBG_GDI((6, "vDeleteSurf called with pdsurf =0x%x", psurf));

    //
    // Validate input parameters
    //
    if ( psurf == NULL )
    {
        DBG_GDI((3, "vDeleteSurf do nothing because pdsurf is NULL\n"));
        return;
    }

    //
    // Note: we don't need to call EngDeleteSurface(psurf->hsurf) to delete
    // the HBITMAP we created in DrvCreateDeviceBitmap() or DrvDeriveSurface()
    // because GDI will take care of this when it call DrvDeleteDeviceBitmap
    //

    if ( psurf->flags & SF_ALLOCATED )
    {
        if( psurf->flags & SF_SM )
        {
            ENGFREEMEM(psurf->pvScan0);
        }
        else
        {
            ASSERTDD(psurf->flags & SF_VM, "expected video memeory surface");

            //
            // Update the uniqueness to show that space has been freed, so
            // that we may decide to see if some DIBs can be moved back into
            // off-screen memory:
            //
            psurf->ppdev->iHeapUniq++;
        
            //
            // Free the video memory by specifing which heap and the pointer
            // to the chunk of video memory
            //
            DBG_GDI((3, "Free offset %ld from video mem\n", psurf->ulByteOffset));
            VidMemFree(psurf->pvmHeap->lpHeap, (FLATPTR)psurf->ulByteOffset);
        }// It is video memory
    }

    //
    // Free the GDI wrap around video memory
    //
    ENGFREEMEM(psurf);

    return;
}// vDeleteSurf()

//--------------------------------------------------------------------------
//
// pCreateSurf(PDEV* ppdev, LONG lWidth, LONG lHeight)
// This routine returns allocates a chunk of video memory and returns a DSURF*
//
// Parameters:
//  ppdev-------PDEV*
//  lWidth------Width of the bitmap to be allocated
//  lHeight-----Height of the bitmap to be allocated
//
//--------------------------------------------------------------------------
Surf*
pCreateSurf(PDev*   ppdev,
             LONG    lWidth,
             LONG    lHeight)
{
    ULONG         ulByteOffset;
    Surf*         psurf;
    LONG          lDelta;
    ULONG         ulPackedPP;
    VIDEOMEMORY*  pvmHeap;

    //
    // First, try to get video memory
    //
    ulByteOffset = ulVidMemAllocate(ppdev, 
                                    lWidth, lHeight, ppdev->cPelSize,
                                    &lDelta, &pvmHeap, &ulPackedPP, TRUE);

    if ( ulByteOffset != 0 )
    {
        //
        // Use system memory to allocate a wrap (DSURF) so that gdi
        // can track all the info later
        //
        psurf = (Surf*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(Surf),
                                     ALLOC_TAG);
        if ( psurf != NULL )
        {
            DBG_GDI((3, "pdsurf is %x\n", psurf));

            //
            // Fill up the DSURF structure and our job is done
            //
            psurf->flags         = SF_VM | SF_ALLOCATED;
            psurf->ppdev         = ppdev;
            psurf->cx            = lWidth;
            psurf->cy            = lHeight;
            psurf->ulByteOffset  = ulByteOffset;
            psurf->pvmHeap       = pvmHeap;
            psurf->lDelta        = lDelta;
            psurf->ulPackedPP    = ulPackedPP;
            psurf->ulPixOffset   = (ULONG)(ulByteOffset >> ppdev->cPelSize);
            psurf->ulPixDelta    = lDelta >> ppdev->cPelSize;
            psurf->psurfNext     = NULL;
            psurf->psurfPrev     = NULL;
            
            //
            // We are done
            //
            return(psurf);
        }// if ( pdsurf != NULL )

        //
        // Something weird happened that we can't get memory from
        // the system. We should free the video memory before quit
        //
        VidMemFree(pvmHeap->lpHeap, (FLATPTR)ulByteOffset);
    }// if ( ulByteOffset != 0 )

    return (NULL);
}// pCreateSurf()

//---------------------------------------------------------------------------
//
// BOOL bMoveOldestBMPOut
//
// This routine moves the oldest DFB in the video memory to the system memory
// and store it as a DIB
//
//---------------------------------------------------------------------------
BOOL
bMoveOldestBMPOut(PDev* ppdev)
{
    BOOL bResult = FALSE;

    if(ppdev->psurfListHead != NULL)
        bResult = bDemote(ppdev->psurfListHead);

    return bResult;

}// bMoveOldestBMPOut()

//--------------------------Public*Routine-------------------------------------
//
// HBITMAP DrvCreateDeviceBitmap
//
// Function called by GDI to create a device-format-bitmap (DFB).  We will
// always try to allocate the bitmap in off-screen; if we can't, we simply
// fail the call and GDI will create and manage the bitmap itself.
//
// Note: We do not have to zero the bitmap bits.  GDI will automatically
//       call us via DrvBitBlt to zero the bits (which is a security
//       consideration).
//
// Parameters:
// dhpdev---Identifies the PDEV that describes the physical device that an
//          application has designated as the primary target for a bitmap. The
//          format of the bitmap must be compatible with this physical device. 
// sizl-----Specifies the height and width of the desired bitmap, in pixels. 
// iFormat--Specifies the bitmap format, which indicates the required number of
//          bits of color information per pixel. This value can be one of the
//          following: Value         Meaning 
//                     BMF_1BPP    Monochrome. 
//                     BMF_4BPP   4 bits per pixel. 
//                     BMF_8BPP   8 bits per pixel. 
//                     BMF_16BPP 16 bits per pixel. 
//                     BMF_24BPP 24 bits per pixel. 
//                     BMF_32BPP 32 bits per pixel. 
//                     BMF_4RLE   4 bits per pixel; run length encoded. 
//                     BMF_8RLE   8 bits per pixel; run length encoded. 
//
// Return Value:
//   The return value is a handle that identifies the created bitmap if the
//   function is successful. If the driver chooses to let GDI create and manage
//   the bitmap, the return value is zero. If an error occurs, the return value
//   is 0xFFFFFFFF, and GDI logs an error code.
//
//------------------------------------------------------------------------------
HBITMAP
DrvCreateDeviceBitmap(DHPDEV  dhpdev,
                      SIZEL   sizl,
                      ULONG   iFormat)
{
    PDev*   ppdev = (PDev*)dhpdev;
    Surf*   psurf;
    HBITMAP hbmDevice = NULL;
    BYTE*   pjSurface;    

    PERMEDIA_DECL;

    DBG_GDI((6, "DrvCreateDeviceBitmap()called"));

    //
    // First check If we're in full-screen mode ( ppdev->bEnabled = FALSE )
    // If yes, we hardly have any off-screen memory in which to allocate a DFB.
    // LATER: We could still allocate an OH node and put the bitmap on the DIB
    // DFB list for later promotion.
    // Also check that off-screen DFBs are configured ( STAT_DEV_BITMAPS). This
    // flag is turned off in bCheckHighResolutionCapability() (enable.c) when
    // the resolution is too high for the accelerator
    //
//    if ( !ppdev->bEnabled || !(ppdev->flStatus & STAT_DEV_BITMAPS) )
    if ( !ppdev->bEnabled )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap(): return 0, full screen mode"));
        
        return (0);
    }

    //
    // Second check If we're in DirectDraw exclusive mode 
    //
    if ( ppdev->bDdExclusiveMode )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap(): return 0, DirectDraw exclusive mode"));
        
        return (0);
    }

    //
    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.
    //
    if ( iFormat != ppdev->iBitmapFormat )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap(): can't create bmp of format %d size(%d,%d)",
                 iFormat, sizl.cx, sizl.cy));
        DBG_GDI((2, "only bitmaps of format %d supported!",
                 ppdev->iBitmapFormat));

        return (0);
    }

    //
    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:
    //
    // Note if you're tempted to extend this philosophy to surfaces
    // larger than 8x8: in NT5, software cursors will use device-bitmaps
    // when possible, which is a big win when they're in video-memory
    // because we avoid the horrendous reads from video memory whenever
    // the cursor has to be redrawn.  But the problem is that these
    // are small!  (Typically 16x16 to 32x32.)
    //
    if ( (sizl.cx <= 8) && (sizl.cy <= 8) )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap rtn 0 because BMP size is small"));
        return (0);
    }
    else if ( ((sizl.cx >= 2048) || (sizl.cy >= 1024)) )
    {
        //
        // On Permedia don't create anything bigger than we can rasterize
        // because the rasteriser cannot handle coordinates higher than these
        //        
        DBG_GDI((2, "DrvCreateDeviceBitmap rtn 0 for BMP too large %d %d",
                 sizl.cx, sizl.cy));
        return (0);
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvCreateDeviceBitmap: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    //
    // Allocate a chunk of video memory for storing this bitmap
    //
    do
    {
        psurf = pCreateSurf(ppdev, sizl.cx, sizl.cy);

        if ( psurf != NULL )
        {
            //
            // Create a GDI wrap of a device managed bitmap
            //
            hbmDevice = EngCreateDeviceBitmap((DHSURF)psurf, sizl, iFormat);
            if ( hbmDevice != NULL )
            {
                //
                // Since we're running on a card that can map all of off-screen
                // video-memory, give a pointer to the bits to GDI so that
                // it can draw directly on the bits when it wants to.
                //
                // Note that this requires that we hook DrvSynchronize and
                // set HOOK_SYNCHRONIZE.
                //
                pjSurface = psurf->ulByteOffset + ppdev->pjScreen;                                

                DBG_GDI((3, "width=%ld pel=%ld, pjSurface=%x",
                         sizl.cy, ppdev->cjPelSize, pjSurface));

                ULONG   flags = MS_NOTSYSTEMMEMORY;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
                flags |= MS_SHAREDACCESS;
#endif
//@@END_DDKSPLIT

                if ( EngModifySurface((HSURF)hbmDevice,
                                      ppdev->hdevEng,
                                      ppdev->flHooks,
                                      flags,
                                      (DHSURF)psurf,
                                      pjSurface,
                                      psurf->lDelta,
                                      NULL))
                {
                    psurf->hsurf = (HSURF)hbmDevice;

                    vAddSurfToList(ppdev, psurf);
                    
                    DBG_GDI((6, "DrvCteDeviceBmp succeed, hsurf=%x, dsurf=%x",
                             hbmDevice, psurf));

                    vLogSurfCreated(psurf);

                    break;

                }// if ( EngAssociateSurface() )

                DBG_GDI((0, "DrvCreateDeviceBitmap,EngModifySurface failed"));
                //
                // Since associate surface failed, we should delete the surface
                //
                EngDeleteSurface((HSURF)hbmDevice);
                hbmDevice = NULL;

            }// if ( hbmDevice != NULL )

            //
            // Failed in CreateDeviceBitmap, we should free all the memory
            //
            vDeleteSurf(psurf);

            DBG_GDI((0, "DrvCreateDeviceBitmap,EngCreateDeviceBitmap failed"));
            break;

        }// if ( pdsurf != NULL )
    } while (bMoveOldestBMPOut(ppdev));

#if DBG
    if(hbmDevice == NULL)
    {
        DBG_GDI((1, "DrvCreateDeviceBitmap failed, no memory"));
    }
#endif

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (hbmDevice);

}// DrvCreateDeviceBitmap()

//--------------------------Public*Routine-------------------------------------
//
// VOID DrvDeleteDeviceBitmap()
//
// This function deletes a device bitmap created by DrvCreateDeviceBitmap
//
// Parameters
//  dhsurf------Identifies the bitmap to be deleted. This handle identifies the
//              bitmap created by DrvCreateDeviceBitmap. 
//
// Comments
//  A display driver must implement DrvDeleteDeviceBitmap if it supplies
//  DrvCreateDeviceBitmap.
//
//  GDI will never pass this function a DHSURF which is the same as the
//  screen (Surf*)
//
//-----------------------------------------------------------------------------
VOID
DrvDeleteDeviceBitmap(DHSURF dhsurf)
{
    Surf*  psurf;
    PDev*  ppdev;
    Surf*  pCurrent;        
    
    psurf = (Surf*)dhsurf;
    ppdev = psurf->ppdev;

    DBG_GDI((6, "DrvDeleteDeviceBitamp(%lx)", psurf));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvDeleteDeviceBitmap: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vRemoveSurfFromList(ppdev, psurf);
    vLogSurfDeleted(psurf);
    
    vDeleteSurf(psurf);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

}// DrvDeleteDeviceBitmap()

//-----------------------------------------------------------------------------
//
// VOID vBlankScreen(PDev*   ppdev)
//
// This function balnk the screen by setting the memory contents to zero
//
//-----------------------------------------------------------------------------
VOID
vBlankScreen(PDev*   ppdev)
{
    //
    // Synchronize the hardware first
    //
    if( ppdev->bGdiContext )
    {
        InputBufferSync(ppdev);
    }
    else
    {
#if MULTITHREADED && DBG
        ppdev->pP2dma->ppdev = ppdev;
#endif
        vSyncWithPermedia(ppdev->pP2dma);
    }

    //
    // Set the video memory contents, screen portion, to zero
    //
    memset(ppdev->pjScreen, 0x0,
           ppdev->cyScreen * ppdev->lDelta);
}// vBlankScreen()

//-----------------------------------------------------------------------------
//
// BOOL bAssertModeOffscreenHeap
//
// This function is called whenever we switch in or out of full-screen
// mode.  We have to convert all the off-screen bitmaps to DIBs when
// we switch to full-screen (because we may be asked to draw on them even
// when in full-screen, and the mode switch would probably nuke the video
// memory contents anyway).
//
//-----------------------------------------------------------------------------
BOOL
bAssertModeOffscreenHeap(PDev*   ppdev,
                         BOOL    bEnable)
{
    BOOL    bResult = TRUE;

    if ( !bEnable )
    {
        bResult = bDemoteAll(ppdev);
    
        //
        // We need to clean the screen. bAssertModeOffscreenHeap() is called
        // when DrvAssertMode(FALSE), which means we either switch to a full
        // screen DOS window or this PDEV will be deleted.
        //
        if ( bResult )
        {
            vBlankScreen(ppdev);
        }
    }

    return bResult;
}// bAssertModeOffscreenHeap()

//-----------------------------------------------------------------------------
//
// VOID vDisableOffscreenHeap
//
// Frees any resources allocated by the off-screen heap.
//
//-----------------------------------------------------------------------------
VOID
vDisableOffscreenHeap(PDev* ppdev)
{
#if 0
    ASSERTDD(ppdev->psurfListHead == NULL,
             "vDisableOffscreenHeap: expected surface list to be empty");

    ASSERTDD(ppdev->psurfListTail == NULL,
             "vDisableOffscreenHeap: expected surface list to be empty");
#endif

}// vDisableOffscreenHeap()

//-----------------------------------------------------------------------------
//
// BOOL bEnableOffscreenHeap
//
// Off-screen heap initialization
//
//-----------------------------------------------------------------------------
BOOL
bEnableOffscreenHeap(PDev* ppdev)
{
    DBG_GDI((6, "bEnableOffscreenHeap called"));

    ppdev->psurfListHead = NULL;
    ppdev->psurfListTail = NULL;
    
    return TRUE;
}// bEnableOffscreenHeap()

//-----------------------------------------------------------------------------
//
// BOOL bDownLoad
//
// Download a GDI owned bmp (GOB) to the video memory if we have room on the
// video off-screen heap
//
// Returns: FALSE if there wasn't room, TRUE if successfully downloaded.
//
//-----------------------------------------------------------------------------
#if defined(AFTER_BETA3)
BOOL
bDownLoad(PDev*   ppdev,
          Surf*   psurf)
{
    ULONG         ulByteOffset;
    LONG          lDelta;
    ULONG         ulPackedPP;
    VIDEOMEMORY*  pvmHeap;

    DBG_GDI((6, "bDownLoad called with psurf 0x%x", psurf));

    ASSERTDD(psurf->flags & SF_SM,
             "Can't move a bitmap off-screen when it's already off-screen");

    if ( !(psurf->flags & SF_ALLOCATED) )
    {
        return (FALSE);
    }
    //
    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:
    //
    if ( !ppdev->bEnabled )
    {
        return(FALSE);
    }
    //
    // If we're in DirectDraw exclusive mode, we can't move anything to 
    // off-screen memory:
    //
    if ( ppdev->bDdExclusiveMode )
    {
        return(FALSE);
    }
    //
    // Allocate video memory first
    //
    ulByteOffset = ulVidMemAllocate(ppdev, psurf->cx, psurf->cy, ppdev->cPelSize,
                                    &lDelta, &pvmHeap, &ulPackedPP, TRUE);

    if ( ulByteOffset == 0 )
    {
        //
        // No more free video memory, we have to return
        //
        DBG_GDI((1, "No more free video memory"));
        return(FALSE);
    }

    ULONG   flags = MS_NOTSYSTEMMEMORY;   // It's video-memory

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    flags |= MS_SHAREDACCESS;
#endif
//@@END_DDKSPLIT

    if ( !EngModifySurface(psurf->hsurf,
                           ppdev->hdevEng,
                           ppdev->flHooks,                                     
                           flags,
                           (DHSURF)psurf,
                           ulByteOffset + ppdev->pjScreen,
                           lDelta,
                           NULL))
    {
        //
        // Failed in EngModifySurface, we should free the video memory we got
        //
        VidMemFree(psurf->pvmHeap->lpHeap, (FLATPTR)ulByteOffset);
        return(FALSE);
    }

    //
    // Download BMP from system memory to video memory
    //
    memcpy((void*)(ppdev->pjScreen + psurf->ulByteOffset),
           psurf->pvScan0, lDelta * psurf->cy);

    //
    // Free the system memory
    //
    ENGFREEMEM(psurf->pvScan0);

    //
    // Change the attributes for this PDSURF data structures
    //
    psurf->flags  &= ~SF_SM;
    psurf->flags  |= SF_VM;
    psurf->ulByteOffset = ulByteOffset;
    psurf->pvmHeap  = pvmHeap;
    psurf->lDelta   = lDelta;
    psurf->ulPackedPP = ulPackedPP;
    psurf->ulPixOffset = (ULONG)(ulByteOffset >> ppdev->cPelSize);
    psurf->ulPixDelta = lDelta >> ppdev->cPelSize;
    psurf->psurfNext = NULL;
    psurf->psurfPrev = NULL;

    vAddSurfToList(ppdev, psurf);
    
    return (TRUE);
}// bDownLoad()
#endif

//--------------------------Public Routine-------------------------------------
//
// HBITMAP DrvDeriveSurface
//
// This function derives and creates a GDI surface from the specified
// DirectDraw surface.
//
// Parameters
//  pDirectDraw-----Points to a DD_DIRECTDRAW_GLOBAL structure that describes
//                  the DirectDraw object. 
//  pSurface--------Points to a DD_SURFACE_LOCAL structure that describes the
//                  DirectDraw surface around which to wrap a GDI surface.
//
// Return Value
//  DrvDeriveSurface returns a handle to the created GDI surface upon success.
//  It returns NULL if the call fails or if the driver cannot accelerate GDI
//  drawing to the specified DirectDraw surface.
//
// Comments
//  DrvDeriveSurface allows the driver to create a GDI surface around a
//  DirectDraw video memory or AGP surface object in order to allow accelerated
//  GDI drawing to the surface. If the driver does not hook this call, all GDI
//  drawing to DirectDraw surfaces is done in software using the DIB engine.
//
//  GDI calls DrvDeriveSurface with RGB surfaces only.
//
//  The driver should call DrvCreateDeviceBitmap to create a GDI surface of the
//  same size and format as that of the DirectDraw surface. Space for the
//  actual pixels need not be allocated since it already exists.
//
//-----------------------------------------------------------------------------
HBITMAP
DrvDeriveSurface(DD_DIRECTDRAW_GLOBAL*  pDirectDraw,
                 DD_SURFACE_LOCAL*      pSurface)
{
    PDev*               ppdev;
    Surf*               psurf;
    HBITMAP             hbmDevice;
    DD_SURFACE_GLOBAL*  pSurfaceGlobal;
    SIZEL               sizl;

    DBG_GDI((6, "DrvDeriveSurface: with pDirectDraw 0x%x, pSurface 0x%x",
             pDirectDraw, pSurface));

    ppdev = (PDev*)pDirectDraw->dhpdev;

    pSurfaceGlobal = pSurface->lpGbl;

    //
    // GDI should never call us for a non-RGB surface, but let's assert just
    // to make sure they're doing their job properly.
    //
    ASSERTDD(!(pSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC),
             "GDI called us with a non-RGB surface!");


    // The GDI driver does not accelerate surfaces in AGP memory,
    // thus we fail the call

    if (pSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        DBG_GDI((6, "DrvDeriveSurface return NULL, surface in AGP memory"));
        return 0;
    }

    // The GDI driver does not accelerate managed surface,
    // thus we fail the call
    if (pSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        DBG_GDI((6, "DrvDeriveSurface return NULL, surface is managed"));
        return 0;
    }

    //
    // The rest of our driver expects GDI calls to come in with the same
    // format as the primary surface.  So we'd better not wrap a device
    // bitmap around an RGB format that the rest of our driver doesn't
    // understand.  Also, we must check to see that it is not a surface
    // whose pitch does not match the primary surface.
    //
    // NOTE: Most surfaces created by this driver are allocated as 2D surfaces
    // whose lPitch's are equal to the screen pitch.  However, overlay surfaces
    // are allocated such that there lPitch's are usually different then the
    // screen pitch.  The hardware can not accelerate drawing operations to
    // these surfaces and thus we fail to derive these surfaces.
    //

    if ( (pSurfaceGlobal->ddpfSurface.dwRGBBitCount
          == (DWORD)ppdev->cjPelSize * 8) )
    {
        psurf = (Surf*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(Surf), ALLOC_TAG);
        if ( psurf != NULL )
        {
            sizl.cx = pSurfaceGlobal->wWidth;
            sizl.cy = pSurfaceGlobal->wHeight;

            hbmDevice = EngCreateDeviceBitmap((DHSURF)psurf,
                                              sizl,
                                              ppdev->iBitmapFormat);
            if ( hbmDevice != NULL )
            {
                VOID*   pvScan0;
                if (pSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                {
                    // this actually is in user memory, so don't add offset
                    pvScan0 = (VOID *)pSurfaceGlobal->fpVidMem; 
                }
                else
                {
                    pvScan0 = ppdev->pjScreen + pSurfaceGlobal->fpVidMem;
                }
                //
                // Note that HOOK_SYNCHRONIZE must always be hooked when we
                // give GDI a pointer to the bitmap bits. We don't need to
                // do it here since HOOK_SYNCHRONIZE is always set in our
                // pdev->flHooks
                //

                ULONG   flags = MS_NOTSYSTEMMEMORY;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
                flags |= MS_SHAREDACCESS;
#endif
//@@END_DDKSPLIT

                if ( EngModifySurface((HSURF)hbmDevice,
                                      ppdev->hdevEng,
                                      ppdev->flHooks,
                                      flags,
                                      (DHSURF)psurf,
                                      pvScan0,
                                      pSurfaceGlobal->lPitch,
                                      NULL) )
                {
                    ULONG   ulPackedPP;
                    LONG    lDelta;

                    psurf->hsurf       = (HSURF)hbmDevice;
                    psurf->flags       = SF_DIRECTDRAW | SF_VM;
                    psurf->ppdev       = ppdev;
                    psurf->cx          = pSurfaceGlobal->wWidth;
                    psurf->cy          = pSurfaceGlobal->wHeight;
                    psurf->ulByteOffset= (ULONG)(pSurfaceGlobal->fpVidMem);
                    psurf->pvmHeap     = pSurfaceGlobal->lpVidMemHeap;
                    psurf->psurfNext   = NULL;
                    psurf->psurfPrev   = NULL;
                    psurf->lDelta      = pSurfaceGlobal->lPitch;

                    vCalcPackedPP(psurf->cx, &lDelta, &ulPackedPP);

                    psurf->ulPackedPP  = ulPackedPP;
                    psurf->ulPixOffset = (ULONG)(psurf->ulByteOffset
                                                  >> ppdev->cPelSize);
                    psurf->ulPixDelta  = psurf->lDelta
                                                  >> ppdev->cPelSize;

                    DBG_GDI((6, "DrvDeriveSurface return succeed"));

                    vLogSurfCreated(psurf);

                    if(MAKE_BITMAPS_OPAQUE)
                    {
                        SURFOBJ*    surfobj = EngLockSurface((HSURF) hbmDevice);

                        ASSERTDD(surfobj->iType == STYPE_BITMAP,
                                    "expected STYPE_BITMAP");

                        surfobj->iType = STYPE_DEVBITMAP;

                        EngUnlockSurface(surfobj);
                    }

                    return(hbmDevice);
                }// EngModifySurface succeed

                DBG_GDI((0, "DrvDeriveSurface: EngModifySurface failed"));
                EngDeleteSurface((HSURF)hbmDevice);
            }

            DBG_GDI((0, "DrvDeriveSurface: EngAllocMem failed"));
            ENGFREEMEM(psurf);
        }// if ( pdsurf != NULL ) 
    }// Check surface format

    DBG_GDI((6, "DrvDeriveSurface return NULL"));
    DBG_GDI((6,"pSurfaceGlobal->ddpfSurface.dwRGBBitCount = %d, lPitch =%ld",
            pSurfaceGlobal->ddpfSurface.dwRGBBitCount,pSurfaceGlobal->lPitch));
    DBG_GDI((6, "ppdev->cjPelSize * 8 = %d, lDelta =%d",
             ppdev->cjPelSize * 8, ppdev->lDelta));
      
    return(0);
}// DrvDeriveSurface()

//-----------------------------------------------------------------------------
//
// VOID vDemote
//
// Attempt to move the given surface from VM to SM 
//
//-----------------------------------------------------------------------------
BOOL
bDemote(Surf * psurf)
{
    LONG    lDelta;
    VOID*   pvScan0;
    BOOL    bResult = FALSE;
    
    ASSERTDD( psurf->flags & SF_VM, "source to be VM");
    ASSERTDD( psurf->flags & SF_ALLOCATED, "source must have been allocated");

    //
    // Make the system-memory scans quadword aligned:
    //

    lDelta = (psurf->lDelta + 7) & ~7;

    DBG_GDI((7, "Allocate %ld bytes in Eng, lDelta=%ld\n",
            lDelta * psurf->cy, lDelta));
    
    //
    // Allocate system memory to hold the bitmap
    // Note: there's no point in zero-initializing this memory:
    //
    pvScan0 = ENGALLOCMEM(0, lDelta * psurf->cy, ALLOC_TAG);

    if ( pvScan0 != NULL )
    {
        //
        // The following 'EngModifySurface' call tells GDI to
        // modify the surface to point to system-memory for
        // the bits, and changes what Drv calls we want to
        // hook for the surface.
        //
        // By specifying the surface address, GDI will convert the
        // surface to an STYPE_BITMAP surface (if necessary) and
        // point the bits to the memory we just allocated.  The
        // next time we see it in a DrvBitBlt call, the 'dhsurf'
        // field will still point to our 'pdsurf' structure.
        //
        // Note that we hook only CopyBits and BitBlt when we
        // convert the device-bitmap to a system-memory surface.
        // This is so that we don't have to worry about getting
        // DrvTextOut, DrvLineTo, etc. calls on bitmaps that
        // we've converted to system-memory -- GDI will just
        // automatically do the drawing for us.
        //
        // However, we are still interested in seeing DrvCopyBits
        // and DrvBitBlt calls involving this surface, because
        // in those calls we take the opportunity to see if it's
        // worth putting the device-bitmap back into video memory
        // (if some room has been freed up).
        //
        if ( EngModifySurface(psurf->hsurf,
                              psurf->ppdev->hdevEng,
                              HOOK_COPYBITS | HOOK_BITBLT,
                              0,                    // It's system-memory
                              (DHSURF)psurf,
                              pvScan0,
                              lDelta,
                              NULL))
        {
            //
            // First, copy the bits from off-screen memory to the DIB
            //
            DBG_GDI((3, "Free %d bytes, offset %ld real %x",
                    lDelta * psurf->cy, psurf->ulByteOffset,
                    (VOID*)(psurf->ppdev->pjScreen + psurf->ulByteOffset)));

            vUpload(psurf->ppdev, (void*)(psurf->ppdev->pjScreen + psurf->ulByteOffset),
                    lDelta * psurf->cy, pvScan0);

            DBG_GDI((6, "bMoveOldest() free vidmem %ld",
                     psurf->ulByteOffset));

            //
            // Now free the off-screen memory:
            //
            VidMemFree(psurf->pvmHeap->lpHeap,
                       (FLATPTR)psurf->ulByteOffset);

            vRemoveSurfFromList(psurf->ppdev, psurf);

            //
            // Setup the pdsurf properly because it is a DIB now
            //
            psurf->flags &= ~SF_VM;
            psurf->flags |= SF_SM;
            psurf->pvScan0 = pvScan0;

            vLogSurfMovedToSM(psurf);

            bResult = TRUE;

        }// EngModifySurface()
        else
        {

            //
            // Somehow, EngModifySurface() failed. Free the memory
            //
            ENGFREEMEM(pvScan0);
            ASSERTDD(0, "bMoveOldest() EngModifySurface failed\n");
        }

    }// if ( pvScan0 != NULL )

    return bResult;

}

//-----------------------------------------------------------------------------
//
// VOID vPromote
//
// Attempt to move the given surface from SM to VM 
//
//-----------------------------------------------------------------------------
VOID
vPromote(Surf * psurf)
{
    ASSERTDD( psurf->flags & SF_VM, "source to be VM");
    ASSERTDD( psurf->flags & SF_ALLOCATED, "source must have been allocated");
    ASSERTDD(!psurf->ppdev->bDdExclusiveMode, 
        "cannot promote when DirectDraw is in exclusive mode");
    

    // nothing for now
}

//-----------------------------------------------------------------------------
//
// BOOL bDemoteAll
//
// Attempts to move all surfaces to SM
//
//-----------------------------------------------------------------------------
BOOL
bDemoteAll(PPDev ppdev)
{
    BOOL    bRet;
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    while (ppdev->psurfListHead != NULL)
        if(!bDemote(ppdev->psurfListHead))
            break;

    bRet = (ppdev->psurfListHead == NULL);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\hw.h ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: hw.h
*
* All the hardware defines and typedefs.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#ifndef _HW_H_
#define _HW_H_

#include "p2def.h"

//
// Texture memory allocation macros and structures are in 3DPrivTx.h
//
//
// Definition of handle to a memory region
//
typedef  LONG HMEMREGION;
typedef  LONG HMEMCACHE;
typedef enum
{
    RESIDENCY_NOTLOADED,
    RESIDENCY_PERMANENT,
    RESIDENCY_TRANSIENT,
    RESIDENCY_HOST
} MEM_MGR_RESIDENCY;

//
// Extern declarations
//
extern DWORD    LogicopReadDest[];      // Indicates which logic ops need dest
                                        // read turned on
extern DWORD    ConfigReadDest[];
extern UCHAR    LBWidthBits[];

//
// Definition of counter data area for performance counters (PERFCTR)
//
extern PVOID    pCounterBlock;

//
// Values for flags in HwDataRec
//
typedef enum
{
    GLICAP_NT_CONFORMANT_LINES    = 0x00000001, // draw NT conformant lines
    GLICAP_HW_WRITE_MASK          = 0x00000002, // hardware planemasking
};

typedef int PERMEDIA2_CAPS;

//
// SCISSOR stuff
//
#define SCREEN_SCISSOR_DEFAULT  (0 << 1)
#define SCISSOR_MAX 2047            // Maximum scissor size in P2

//
// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the miniport drivers permedia.h
//
typedef struct _Hw_Device_Info
{
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    LONG  LocalbufferWidth;
    ULONG ActualDacId;
} Hw_Device_Info;


typedef struct tagP2CtxtRec *P2CtxtPtr;

typedef struct _hw_data
{
    DWORD       renderBits;         // Saved render bits set by setup routines
    DWORD       FBWriteMode;        // Software copy of FBWriteMode register
    DWORD       RasterizerMode;     // Software copy of the rasterizer mode
    DWORD       FBPacking;          // Software copy of FBModeSel
    DWORD       FBBlockColor;       // Software copy of FBBlockColor (P1 only)
    DWORD       TextureAddressMode; // Software copy of TextureAddressMode
                                    // (P2 only)
    DWORD       TextureReadMode;    // Software copy of TextureReadMode
                                    // (P2 only)

    ULONG       currentCSbuffer;    // Color space buffer being displayed
    PERMEDIA2_CAPS  flags;          // Various flags

    P2CtxtPtr   pGDICtxt;           // id of the display driver's context for
                                    // this board
    LONG        PixelOffset;        // Last DFB pixel offset

    ULONG       PerfScaleShift;

    PVOID       ContextTable;       // Array of extant contexts
    P2CtxtPtr   pCurrentCtxt;       // id of this board's current context

    union
    {
        UCHAR       _clutBuffer[MAX_CLUT_SIZE];
        VIDEO_CLUT  gammaLUT;       // Saved gamma LUT contents
    };

    //
    // PCI configuration id information
    //
    Hw_Device_Info deviceInfo;
} HwDataRec, *HwDataPtr;


#define TRANSLATE_ADDR_ULONG(a) (a)     //TODO: should be removed in pointer.c

//
// If we have a sparsely mapped framebuffer then we use the xx_REGISTER_ULONG()
// macros, otherwise we just access the framebuffer.
//
#define READ_SCREEN_ULONG(a)\
    ((ppdev->flCaps & CAPS_SPARSE_SPACE) ?\
      (READ_REGISTER_ULONG(a)) : *((ULONG volatile *)(a)))

#define WRITE_SCREEN_ULONG(a,d)\
    ((ppdev->flCaps & CAPS_SPARSE_SPACE) ?\
      (WRITE_REGISTER_ULONG(a,d)) : (*((ULONG volatile *)(a)) = (d)))

//
// Generic macros to access Permedia 2 FIFO and non-FIFO control registers.
// We do nothing sophisticated for the Alpha. We just MEMORY_BARRIER
// everything.
//

#define LD_PERMEDIA_REG(x,y) \
{   \
    WRITE_REGISTER_ULONG(&(ppdev->pCtrlBase[x/sizeof(ULONG)]),y); \
    MEMORY_BARRIER();\
}
    
#define READ_PERMEDIA_REG(x) \
    READ_REGISTER_ULONG(&(ppdev->pCtrlBase[x/sizeof(ULONG)]))

#define READ_PERMEDIA_FIFO_REG(uiTag, d) \
    ((d) = READ_REGISTER_ULONG(&(ppdev->pCoreBase[uiTag*2])))

#define READ_FIFO_REG(uiTag)\
    READ_REGISTER_ULONG(&ppdev->pCoreBase[uiTag*2])

//
// Local variables for all functions that access PERMEDIA 2. Generally we
// use PERMEDIA_DECL. Sometimes we have to split it up if ppdev isn't
// passed into the routine.
//
#define PERMEDIA_DECL_VARS \
    HwDataPtr permediaInfo;

#define PERMEDIA_DECL_INIT \
    permediaInfo = (HwDataPtr)(ppdev->permediaInfo);

#define PERMEDIA_DECL \
    PERMEDIA_DECL_VARS; \
    PERMEDIA_DECL_INIT

// TODO: move to debug???
#if DBG
    VOID vCheckDefaultState(P2DMA * pP2dma);

    #define P2_CHECK_STATE vCheckDefaultState(ppdev->pP2dma)
#else
    #define P2_CHECK_STATE
#endif

//
// Pointer interrupts not enabled so just provide stub definitions
//
#define SYNCHRONOUS_WRITE_ULONG(var, value)
#define SYNCHRONOUS_WRITE_INDIRECT_ULONG(pvar, value)
#define GET_INTR_CMD_BLOCK_MUTEX
#define RELEASE_INTR_CMD_BLOCK_MUTEX

//
// FIFO functions
//
#define MAX_P2_FIFO_ENTRIES         256


#define P2_DEFAULT_FB_DEPTH  P2_SET_FB_DEPTH(ppdev->cPelSize)
#define P2DEPTH8             0
#define P2DEPTH16            1
#define P2DEPTH32            2

//
// External interface to the context switching code. The caller can allocate and
// free a context or ask for a switch to a new context. vSwitchContext
// should not be called except through the given macro. The macro assumes
// that ppdev has been defined.
//
typedef enum
{
    P2CtxtReadWrite,
    P2CtxtWriteOnly,
    P2CtxtUserFunc
} P2CtxtType;

P2CtxtPtr P2AllocateNewContext(PPDev ppdev, 
                          DWORD *pReglist, 
                          LONG lEntries, 
                          P2CtxtType dwCtxtType=P2CtxtReadWrite
                          );

VOID P2FreeContext  (PPDev, P2CtxtPtr);
VOID P2SwitchContext(PPDev, P2CtxtPtr);

//
// Macro used by display driver to validate its context
//
#define VALIDATE_GDI_CONTEXT                                                 \
    P2_VALIDATE_CONTEXT(permediaInfo->pGDICtxt)

//
// Useful macros not defined in standard Permedia 2 header files. Generally, for
// speed we don't want to use the bitfield structures so we define the bit
// shifts to get at the various fields.
//
#define INTtoFIXED(i)   ((i) << 16)         // int to 16.16 fixed format
#define FIXEDtoINT(i)   ((i) >> 16)         // 16.16 fixed format to int
#define INTofFIXED(i)   ((i) & 0xffff0000)  // int part of 16.16
#define FRACTofFIXED(i) ((i) & 0xffff)      // fractional part of 16.16

#define FIXtoFIXED(i)   ((i) << 12)         // 12.4 to 16.16
#define FIXtoINT(i)     ((i) >> 4)          // 28.4 to 28

#define __PERMEDIA_CONSTANT_FB_WRITE   (1 << (4+1))
#define __COLOR_DDA_FLAT_SHADE      (__PERMEDIA_ENABLE | \
                                        (__PERMEDIA_FLAT_SHADE_MODE << 1))
#define __COLOR_DDA_GOURAUD_SHADE   (__PERMEDIA_ENABLE | \
                                        (__PERMEDIA_GOURAUD_SHADE_MODE << 1))

#define INVERT_BITMASK_BITS         (1 << 1)
#define BYTESWAP_BITMASK            (3 << 7)
#define FORCE_BACKGROUND_COLOR      (1 << 6)    // Permedia only

//
// Bits in the Render command
//
#define __RENDER_INCREASE_Y             (1 << 22)
#define __RENDER_INCREASE_X             (1 << 21)
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_REUSE_BIT_MASK         (1 << 17)
#define __RENDER_TEXTURE_ENABLE         (1 << 13)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_RECTANGLE_PRIMITIVE    (__PERMEDIA_RECTANGLE_PRIMITIVE << 6)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__PERMEDIA_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__PERMEDIA_LINE_PRIMITIVE << 6)
#define __RENDER_POINT_PRIMITIVE        (__PERMEDIA_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)

//
// Bits in the ScissorMode register
//
#define USER_SCISSOR_ENABLE             (1 << 0)
#define SCREEN_SCISSOR_ENABLE           (1 << 1)
#define SCISSOR_XOFFSET                 0
#define SCISSOR_YOFFSET                 16

//
// Bits in the FBReadMode register
//
#define __FB_READ_SOURCE                (1 << 9)
#define __FB_READ_DESTINATION           (1 << 10)
#define __FB_COLOR                      (1 << 15)
#define __FB_WINDOW_ORIGIN              (1 << 16)
#define __FB_PACKED_DATA                (1 << 19)

//
// Extra bits in PERMEDIA FBReadMode
//
#define __FB_RELATIVE_OFFSET            20

//
// P2 also provides a version of Relative Offset in the PackedDataLimits
// register
//
#define __PDL_RELATIVE_OFFSET           29

//
// Bits in the LBReadMode register
//
#define __LB_READ_SOURCE                (1 << 9)
#define __LB_READ_DESTINATION           (1 << 10)
#define __LB_STENCIL                    (1 << 16)
#define __LB_DEPTH                      (1 << 17)
#define __LB_WINDOW_ORIGIN              (1 << 18)
#define __LB_READMODE_PATCH             (1 << 19)
#define __LB_SCAN_INTERVAL_2            (1 << 20)

//
// Bits in the DepthMode register
//
#define __DEPTH_ENABLE                  1
#define __DEPTH_WRITE_ENABLE            (1<<1)
#define __DEPTH_REGISTER_SOURCE         (2<<2)
#define __DEPTH_MSG_SOURCE              (3<<2)
#define __DEPTH_ALWAYS                  (7<<4)

//
// Bits in the LBReadFormat/LBWriteFormat registers
//
#define __LB_FORMAT_DEPTH32             2

//
// Macros to load indexed tags more efficiently than using __HwDMATag struct
//
#define P2_TAG_MAJOR(x)              ((x) & 0xff0)
#define P2_TAG_MINOR(x)              ((x) & 0x00f)

#define P2_TAG_MAJOR_INDEXED(x)                                          \
    ((__PERMEDIA_TAG_MODE_INDEXED << (5+4+1+4)) | P2_TAG_MAJOR(x))
#define P2_TAG_MINOR_INDEX(x)                                            \
    (1 << (P2_TAG_MINOR(x) + 16))

//
// Macro to take a permedia2 logical op and return the enabled LogcialOpMode bits
//
#define P2_ENABLED_LOGICALOP(op)     (((op) << 1) | __PERMEDIA_ENABLE)

#define RECTORIGIN_YX(y,x)              (((y) << 16) | ((x) & 0xFFFF))

//
// Area stipple shifts and bit defines
//
#define AREA_STIPPLE_XSEL(x)            ((x) << 1)
#define AREA_STIPPLE_YSEL(y)            ((y) << 4)
#define AREA_STIPPLE_XOFF(x)            ((x) << 7)
#define AREA_STIPPLE_YOFF(y)            ((y) << 12)
#define AREA_STIPPLE_INVERT_PAT         (1 << 17)
#define AREA_STIPPLE_MIRROR_X           (1 << 18)
#define AREA_STIPPLE_MIRROR_Y           (1 << 19)

//
// We always use 8x8 monochrome brushes.
//
#define AREA_STIPPLE_8x8_ENABLE                                             \
    (__PERMEDIA_ENABLE |                                                    \
    AREA_STIPPLE_XSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN) |            \
    AREA_STIPPLE_YSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN))

//
// RasteriserMode values
//
#define BIAS_NONE                  (__PERMEDIA_START_BIAS_ZERO << 4)
#define BIAS_HALF                  (__PERMEDIA_START_BIAS_HALF << 4)
#define BIAS_NEARLY_HALF           (__PERMEDIA_START_BIAS_ALMOST_HALF << 4)

#define FRADJ_NONE                 (__PERMEDIA_FRACTION_ADJUST_NONE << 2)
#define FRADJ_ZERO                 (__PERMEDIA_FRACTION_ADJUST_TRUNC << 2)
#define FRADJ_HALF                 (__PERMEDIA_FRACTION_ADJUST_HALF << 2)
#define FRADJ_NEARLY_HALF          (__PERMEDIA_FRACTION_ADJUST_ALMOST_HALF << 2)


//
// Some constants
//
#define ONE                         0x00010000
#define MINUS_ONE                   0xFFFF0000
#define PLUS_ONE                    ONE
#define NEARLY_ONE                  0x0000FFFF
#define HALF                        0x00008000
#define NEARLY_HALF                 0x00007FFF

//
// Max length of GIQ conformant lines that Permedia2 can draw
// Permedia has only 15 bits of fraction so reduce the lengths.
//
#define MAX_LENGTH_CONFORMANT_NONINTEGER_LINES  (16/2)
#define MAX_LENGTH_CONFORMANT_INTEGER_LINES     (194/2)

//
// We need to byte swap monochrome bitmaps. On 486 we can do this with
// fast assembler.
//
#if defined(_X86_)
//
// This only works on a 486 so the driver won't run on a 386.
//
#define LSWAP_BYTES(dst, pSrc)                                              \
{                                                                           \
    __asm mov eax, pSrc                                                     \
    __asm mov eax, [eax]                                                    \
    __asm bswap eax                                                         \
    __asm mov dst, eax                                                      \
}
#else
#define LSWAP_BYTES(dst, pSrc)                                              \
{                                                                           \
    ULONG   _src = *(ULONG *)pSrc;                                           \
    dst = ((_src) >> 24) |                                                   \
          ((_src) << 24) |                                                   \
          (((_src) >> 8) & 0x0000ff00) |                                     \
          (((_src) << 8) & 0x00ff0000);                                      \
}

#endif

// macro to swap the Red and Blue component of a 32 bit dword
//

#define SWAP_BR(a) ((a & 0xff00ff00l) | \
                   ((a&0xff0000l)>> 16) | \
                   ((a & 0xff) << 16))

//
// min. and max. values for Permedia PP register
#define MAX_PARTIAL_PRODUCT_P2          10
#define MIN_PARTIAL_PRODUCT_P2          5

//
// Permedia2 DMA definitions
//
#include "mini.h"
// structure definitions passed in by the application for mapping and
// unmapping DMA buffers.
//

//
// Registry variable names
//
#define REG_USE_SOFTWARE_WRITEMASK      L"UseSoftwareWriteMask"

//
// Function declarations
//
VOID  vDoMonoBitsDownload(PPDev, BYTE*, LONG, LONG, LONG, LONG);
BOOL bInitializeHW(PPDev);
VOID vDisableHW(PPDev);
VOID vAssertModeHW(PPDev, BOOL);
VOID vP2ChangeFBDepth(PPDev, ULONG);

//
// Calculate the packed partial products
//
VOID    vCalcPackedPP(LONG width, LONG * outPitch, ULONG * outPackedPP);

VOID        vSetNewGammaValue(PPDev ppdev, ULONG ulgvFIX16_16);
BOOL        bInstallGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut);

//
// The following structures and macros define the memory map for the Permedia2
// control registers. We don't use this memory map to access Permedia2 registers
// since on Alpha machines we want to precompute the addresses. So we do
// a TRANSLATE_ADDR_ULONG on all the addresses here and save them into a
// P2RegAddrRec. We use that to obtain the addresses for the different
// registers.
//
typedef struct
{
    ULONG   reg;
    ULONG   pad;
} RAMDAC_REG;

//
// Macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The
// id is irrelevant as long as it's different from every other id used in the
// same struct. It's a pity pad##__LINE__ doesn't work.
//
//#define PAD(id, n)              UCHAR   pad##id[n]


//
// Interrupt status bits
//
typedef enum
{
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
} INTERRUPT_CONTROL;

extern DWORD    LogicopReadDest[];  // Indicates which logic ops need dest read
                                    // turned on

#define INTtoFIXED(i)               ((i) << 16)    // int to 16.16 fixed format
#define FIXEDtoINT(i)               ((i) >> 16)    // 16.16 fixed format to int

#define __PERMEDIA_CONSTANT_FB_WRITE                                        \
    (1 << (4+1))
#define __COLOR_DDA_FLAT_SHADE                                              \
    (__PERMEDIA_ENABLE | (__PERMEDIA_FLAT_SHADE_MODE << 1))
#define __COLOR_DDA_GOURAUD_SHADE                                           \
    (__PERMEDIA_ENABLE | (__PERMEDIA_GOURAUD_SHADE_MODE << 1))

#define INVERT_BITMASK_BITS    (1 << 1)

//
// Bits in the Render command
//
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__PERMEDIA_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__PERMEDIA_LINE_PRIMITIVE << 6)
#define __RENDER_POINT_PRIMITIVE        (__PERMEDIA_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)
#define __RENDER_TEXTURED_PRIMITIVE     (1 << 13)

//
// Bits in the ScissorMode register
//
#define USER_SCISSOR_ENABLE             (1 << 0)
#define SCREEN_SCISSOR_ENABLE           (1 << 1)
#define SCISSOR_XOFFSET                 0
#define SCISSOR_YOFFSET                 16

//
// Bits in the FBReadMode register
//
#define __FB_READ_SOURCE                (1 << 9)
#define __FB_READ_DESTINATION           (1 << 10)
#define __FB_COLOR                      (1 << 15)
#define __FB_WINDOW_ORIGIN              (1 << 16)
#define __FB_USE_PACKED                 (1 << 19)

//
// Bits in the LBReadMode register
//
#define __LB_READ_SOURCE                (1 << 9)
#define __LB_READ_DESTINATION           (1 << 10)
#define __LB_STENCIL                    (1 << 16)
#define __LB_DEPTH                      (1 << 17)
#define __LB_WINDOW_ORIGIN              (1 << 18)

//
// Area stipple shifts and bit defines
//
#define AREA_STIPPLE_XSEL(x)            ((x) << 1)
#define AREA_STIPPLE_YSEL(y)            ((y) << 4)
#define AREA_STIPPLE_XOFF(x)            ((x) << 7)
#define AREA_STIPPLE_YOFF(y)            ((y) << 12)
#define AREA_STIPPLE_INVERT_PAT         (1 << 17)
#define AREA_STIPPLE_MIRROR_X           (1 << 18)
#define AREA_STIPPLE_MIRROR_Y           (1 << 19)

// we always use 8x8 monochrome brushes.
#define AREA_STIPPLE_8x8_ENABLE \
        (__PERMEDIA_ENABLE | \
         AREA_STIPPLE_XSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN) | \
         AREA_STIPPLE_YSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN))

#define DEFAULTWRITEMASK 0xffffffffl


// *******************************************************************
// Permedia Bit Field Macros

// FBReadMode 
#define PM_FBREADMODE_PARTIAL(a)           ((a) << 0)
#define PM_FBREADMODE_READSOURCE(a)        ((a) << 9)
#define PM_FBREADMODE_READDEST(a)          ((a) << 10)
#define PM_FBREADMODE_PATCHENABLE(a)       ((a) << 18)
#define PM_FBREADMODE_PACKEDDATA(a)        ((a) << 19)
#define PM_FBREADMODE_RELATIVEOFFSET(a)    ((a) << 20)
#define PM_FBREADMODE_PATCHMODE(a)         ((a) << 25)

// Texture read mode
#define PM_TEXREADMODE_ENABLE(a)         ((a) << 0)
#define PM_TEXREADMODE_WIDTH(a)          ((a) << 9)
#define PM_TEXREADMODE_HEIGHT(a)         ((a) << 13)
#define PM_TEXREADMODE_FILTER(a)         ((a) << 17)

// PackedDataLimits
#define PM_PACKEDDATALIMITS_OFFSET(a)    ((a) << 29)
#define PM_PACKEDDATALIMITS_XSTART(a)    ((a) << 16)
#define PM_PACKEDDATALIMITS_XEND(a)      ((a) << 0)

// Window Register
#define PM_WINDOW_LBUPDATESOURCE(a)      ((a) << 4)
#define PM_WINDOW_DISABLELBUPDATE(a)     ((a) << 18)

// Colors
#define PM_BYTE_COLOR(a) ((a) << 15)

// Config register
#define PM_CHIPCONFIG_AGPCAPABLE (1 << 9)


static __inline int log2(int s)
{
    int d = 1, iter = -1;
    do {
         d *= 2;
         iter++;
    } while (d <= s);
    return iter;
}

VOID
P2DisableAllUnits(PPDev ppdev);

#if DBG && TRACKMEMALLOC
#define ENGALLOCMEM( opt, size, tag)\
    MEMTRACKERALLOCATEMEM( EngAllocMem( opt, size, tag), size, __FILE__, __LINE__, FALSE)
#define ENGFREEMEM( obj)\
    { MEMTRACKERFREEMEM(obj); EngFreeMem( obj);}
#else
#define ENGALLOCMEM( opt, size, tag)\
    EngAllocMem( opt, size, tag)
#define ENGFREEMEM( obj)\
    EngFreeMem( obj)
#endif
    

#endif  // _HW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\hwmisc.c ===
/******************************Module*Header***********************************\
* Module Name: hwmisc.c
*
* Hardware specific support routines and structures.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "tvp4020.h"


// table to determine which logicops need read dest turned on in FBReadMode
DWORD   LogicopReadDest[] = {
    0,                                                  /* 00 */
    __FB_READ_DESTINATION,                              /* 01 */
    __FB_READ_DESTINATION,                              /* 02 */
    0,                                                  /* 03 */
    __FB_READ_DESTINATION,                              /* 04 */
    __FB_READ_DESTINATION,                              /* 05 */
    __FB_READ_DESTINATION,                              /* 06 */
    __FB_READ_DESTINATION,                              /* 07 */
    __FB_READ_DESTINATION,                              /* 08 */
    __FB_READ_DESTINATION,                              /* 09 */
    __FB_READ_DESTINATION,                              /* 10 */
    __FB_READ_DESTINATION,                              /* 11 */
    0,                                                  /* 12 */
    __FB_READ_DESTINATION,                              /* 13 */
    __FB_READ_DESTINATION,                              /* 14 */
    0,                                                  /* 15 */
};


// table to determine which logicops need read dest turned on in Config
DWORD   ConfigReadDest[] = {
    0,                                                  /* 00 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 01 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 02 */
    0,                                                  /* 03 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 04 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 05 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 06 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 07 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 08 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 09 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 10 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 11 */
    0,                                                  /* 12 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 13 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 14 */
    0,                                                  /* 15 */
};

//
// Partial products array for width multiples of 32:
// Use GET_PPCODE macro to access this
//

const PPCODE aPartialProducts[] =
{
        0,              (0 << 6) | (0 << 3) | 0,
        32,             (0 << 6) | (0 << 3) | 1,
        64,             (0 << 6) | (1 << 3) | 1,
        96,             (1 << 6) | (1 << 3) | 1,
        128,    (1 << 6) | (1 << 3) | 2,
        160,    (1 << 6) | (2 << 3) | 2,
        192,    (2 << 6) | (2 << 3) | 2,
        224,    (1 << 6) | (2 << 3) | 3,
        256,    (2 << 6) | (2 << 3) | 3,
        288,    (1 << 6) | (3 << 3) | 3,

        320,    (2 << 6) | (3 << 3) | 3,
        384,    (3 << 6) | (3 << 3) | 3, // 352 = 384
        384,    (3 << 6) | (3 << 3) | 3,
        416,    (1 << 6) | (3 << 3) | 4,
        448,    (2 << 6) | (3 << 3) | 4,
        512,    (3 << 6) | (3 << 3) | 4, // 480 = 512
        512,    (3 << 6) | (3 << 3) | 4,
        544,    (1 << 6) | (4 << 3) | 4,
        576,    (2 << 6) | (4 << 3) | 4,
        640,    (3 << 6) | (4 << 3) | 4, // 608 = 640

        640,    (3 << 6) | (4 << 3) | 4,
        768,    (4 << 6) | (4 << 3) | 4, // 672 = 768
        768,    (4 << 6) | (4 << 3) | 4, // 704 = 768
        768,    (4 << 6) | (4 << 3) | 4, // 736 = 768
        768,    (4 << 6) | (4 << 3) | 4,
        800,    (1 << 6) | (4 << 3) | 5,
        832,    (2 << 6) | (4 << 3) | 5,
        896,    (3 << 6) | (4 << 3) | 5, // 864 = 896
        896,    (3 << 6) | (4 << 3) | 5,
        1024,   (4 << 6) | (4 << 3) | 5, // 928 = 1024

        1024,   (4 << 6) | (4 << 3) | 5, // 960 = 1024
        1024,   (4 << 6) | (4 << 3) | 5, // 992 = 1024
        1024,   (4 << 6) | (4 << 3) | 5,
        1056,   (1 << 6) | (5 << 3) | 5,
        1088,   (2 << 6) | (5 << 3) | 5,
        1152,   (3 << 6) | (5 << 3) | 5, // 1120 = 1152
        1152,   (3 << 6) | (5 << 3) | 5,
        1280,   (4 << 6) | (5 << 3) | 5, // 1184 = 1280
        1280,   (4 << 6) | (5 << 3) | 5, // 1216 = 1280
        1280,   (4 << 6) | (5 << 3) | 5, // 1248 = 1280

        1280,   (4 << 6) | (5 << 3) | 5,
        1536,   (5 << 6) | (5 << 3) | 5, // 1312 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1344 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1376 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1408 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1440 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1472 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1504 = 1536
        1536,   (5 << 6) | (5 << 3) | 5,
        2048,   (5 << 6) | (5 << 3) | 6, // 1568 = 2048

        2048,   (5 << 6) | (5 << 3) | 6, // 1600 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1632 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1664 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1696 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1728 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1760 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1792 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1824 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1856 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1888 = 2048

        2048,   (5 << 6) | (5 << 3) | 6, // 1920 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1952 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1984 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 2016 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 2048 = 2048
};

//------------------------------------------------------------------------------
// VOID vCheckDefaultState
//
// Checks that the default state of the hardware is set.
//
//------------------------------------------------------------------------------

VOID vCheckDefaultState(PPDev * ppdev)
{
#if 0
    // Make sure we sync before checking
    vInputBufferSync(ppdev);

    ASSERTDD(READ_FIFO_REG(__Permedia2TagdY) == INTtoFIXED(1),
        "vCheckDefaultState: dY is not 1.0");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagTextureAddressMode) 
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: TextureAddressMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagTextureColorMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: TextureColorMode is not disabled");

//    ASSERTDD(P2_READ_FIFO_REG(__Permedia2TagTextureReadMode)
//                == __PERMEDIA_DISABLE,
//        "vCheckDefaultState: TextureReadMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagAlphaBlendMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: AlphaBlendMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagColorDDAMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: ColorDDAMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagDitherMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: DitherMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagYUVMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: YUVMode is not disabled");
#endif
}

//-----------------------------------------------------------------------------
//
// VOID vCalcPackedPP
//
// Function:
//   Calculate the packed partial products for the given width.
//   If outPitch is not NULL, then return the pitch in pixels
//   for the passed back packed partial product.
//
//-----------------------------------------------------------------------------
VOID
vCalcPackedPP(LONG      width,
              LONG*     outPitch,
              ULONG*    outPackedPP)
{
    LONG    pitch =  (width + 31) & ~31;
    LONG    pp[4];
    LONG    ppn;
    LONG    j;

    do
    {
        ppn = pp[0] = pp[1] = pp[2] = pp[3] = 0;
        if ( pitch >= MAX_PARTIAL_PRODUCT_P2 )
        {
            ppn = pitch >> (MAX_PARTIAL_PRODUCT_P2);
            for ( j = 0; j < ppn; j++ )
            {
                pp[j] = 1 + MAX_PARTIAL_PRODUCT_P2 - MIN_PARTIAL_PRODUCT_P2;
            }
        }
        for ( j = MIN_PARTIAL_PRODUCT_P2 ; j < MAX_PARTIAL_PRODUCT_P2 ; j++ )
        {
            if ( pitch & (1 << j) )
            {
                if ( ppn < 4 )
                    pp[ppn] = j + 1 - MIN_PARTIAL_PRODUCT_P2;
                ppn++;
            }
        }
        pitch += 32;            // Add 32 to the pitch just in case we have
                                // too many pps.
    } while ( ppn > 3 );        // We have to loop until we get a pitch
                                // with < 4 pps

    pitch -= 32;                // Pitch is now the correct number of words


    if (outPitch != NULL)
    {
        *outPitch = pitch;
    }
    else
    {
        // if outPitch is null, then caller expects calculated pitch to be
        // the same as the width
        ASSERTDD(pitch == width, "vCalcPackedPP: pitch does not equal width");
    }

    *outPackedPP = pp[0] | (pp[1] << 3) | (pp[2] << 6);
}// vCalcPackedPP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\fillpath.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: fillpath.c
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved. 
\*****************************************************************************/
// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles

#include "precomp.h"
#include "log.h"
#include "gdi.h"
#include "clip.h"
#define ALLOC_TAG ALLOC_TAG_IF2P
//-----------------------------Public*Routine----------------------------------
//
// DrvFillPath
//
// This function fills the specified path with the specified brush and ROP.
// This function detects single convex polygons, and will call to separate
// faster convex polygon code for those cases.  This routine also detects
// polygons that are really rectangles, and handles those separately as well.
//
// Parameters
//  pso---------Points to a SURFOBJ structure that defines the surface on which
//              to draw. 
//  ppo---------Points to a PATHOBJ structure that defines the path to be filled
//              The PATHOBJ_Xxx service routines are provided to enumerate the
//              lines, Bezier curves, and other data that make up the path. 
//  pco---------Points to a CLIPOBJ structure. The CLIPOBJ_Xxx service routines
//              are provided to enumerate the clip region as a set of rectangles. 
//  pbo---------Points to a BRUSHOBJ structure that defines the pattern and
//              colors to fill with. 
//  pptlBrushOrg-Points to a POINTL structure that defines the brush origin,
//              which is used to align the brush pattern on the device. 
//  mix---------Defines the foreground and background raster operations to use
//              for the brush. 
//  flOptions---Specifies either FP_WINDINGMODE, indicating that a winding mode
//              fill should be performed, or FP_ALTERNATEMODE, indicating that
//              an alternating mode fill should be performed. All other flags
//              should be ignored. 
//
// Return Value
//  The return value is TRUE if the driver is able to fill the path. If the
//  path or clipping is too complex to be handled by the driver and should be
//  handled by GDI, the return value is FALSE, and an error code is not logged.
//  If the driver encounters an unexpected error, such as not being able to
//  realize the brush, the return value is DDI_ERROR, and an error code is
//  logged.
//
// Comments
//  GDI can call DrvFillPath to fill a path on a device-managed surface. When
//  deciding whether to call this function, GDI compares the fill requirements
//  with the following flags in the flGraphicsCaps member of the DEVINFO
//  structure: GCAPS_BEZIERS, GCAPS_ALTERNATEFILL, and GCAPS_WINDINGFILL.
//
//  The mix mode defines how the incoming pattern should be mixed with the data
//  already on the device surface. The MIX data type consists of two ROP2 values
//  packed into a single ULONG. The low-order byte defines the foreground raster
//  operation; the next byte defines the background raster operation.
//
//  Multiple polygons in a path cannot be treated as being disjoint; The fill
//  must consider all the points in the path.  That is, if the path contains
//  multiple polygons, you cannot simply draw one polygon after the other
//  (unless they don't overlap).
//
//  This function is an optional entry point for the driver. but is recommended
//  for good performance. To get GDI to call this function, not only do you
//  have to HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
//  GCAPS_WINDINGFILL.
//
//-----------------------------------------------------------------------------
BOOL
DrvFillPath(SURFOBJ*    pso,
            PATHOBJ*    ppo,
            CLIPOBJ*    pco,
            BRUSHOBJ*   pbo,
            POINTL*     pptlBrush,
            MIX         mix,
            FLONG       flOptions)
{
    GFNPB   pb;
    BYTE    jClipping;      // Clipping type
    EDGE*   pCurrentEdge;
    EDGE    AETHead;        // Dummy head/tail node & sentinel for Active Edge
                            // Table
    EDGE*   pAETHead;       // Pointer to AETHead
    EDGE    GETHead;        // Dummy head/tail node & sentinel for Global Edge
                            // Table
    EDGE*   pGETHead;       // Pointer to GETHead
    EDGE*   pFreeEdges = NULL; // Pointer to memory free for use to store edges
    ULONG   ulNumRects;     // # of rectangles to draw currently in rectangle
                            // list
    RECTL*  prclRects;      // Pointer to start of rectangle draw list
    INT     iCurrentY;      // Scan line for which we're currently scanning out
                            // the fill

    BOOL        bMore;
    PATHDATA    pd;
    RECTL       ClipRect;
    PDev*       ppdev;

    BOOL        bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL        bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG       flFirstRecord;
    POINTFIX*   pPtFxTmp;
    ULONG       ulPtFxTmp;
    POINTFIX    aptfxBuf[NUM_BUFFER_POINTS];
    ULONG       ulRop4;

    DBG_GDI((6, "DrvFillPath called"));

    pb.psurfDst = (Surf*)pso->dhsurf;

    pb.pco = pco;
    ppdev = pb.psurfDst->ppdev;
    pb.ppdev = ppdev;
    pb.ulRop4 = gaMix[mix & 0xFF] | (gaMix[mix >> 8] << 8);
    ulRop4 = pb.ulRop4;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvBitBlt: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(ppdev);

    //
    // There's nothing to do if there are only one or two points
    //
    if ( ppo->cCurves <= 2 )
    {
        goto ReturnTrue;
    }

    //
    // Pass the surface off to GDI if it's a device bitmap that we've uploaded
    // to the system memory.
    //    
    if ( pb.psurfDst->flags == SF_SM )
    {
        DBG_GDI((1, "dest surface is in system memory. Punt it back"));

//@@BEGIN_DDKSPLIT
        #if MULTITHREADED
            pb.ppdev->ulLockCount--;
            EngReleaseSemaphore(pb.ppdev->hsemLock);
        #endif
//@@END_DDKSPLIT
        
        return ( EngFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions));
    }

    //
    // Set up the clipping
    //
    if ( pco == (CLIPOBJ*)NULL )
    {
        //
        // No CLIPOBJ provided, so we don't have to worry about clipping
        //
        jClipping = DC_TRIVIAL;
    }
    else
    {
        //
        // Use the CLIPOBJ-provided clipping
        //
        jClipping = pco->iDComplexity;
    }
    
    //
    // Now we are sure the surface we are going to draw is in the video memory
    //
    // Set default fill as solid fill
    //
    pb.pgfn = vSolidFillWithRop;
    pb.solidColor = 0;    //Assume we don't need a pattern
    pb.prbrush = NULL;

    //
    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this
    //
    PATHOBJ_vEnumStart(ppo);
    bMore = PATHOBJ_bEnum(ppo, &pd);

    //
    // First we need to check if we need a pattern or not
    //
    if ( (((ulRop4 & 0xff00) >> 8) != (ulRop4 & 0x00ff))
      || ((((ulRop4 >> 4) ^ (ulRop4)) & 0xf0f) != 0) )
    {
        pb.solidColor = pbo->iSolidColor;

        //
        // Check to see if it is a non-solid brush (-1)
        //
        if ( pbo->iSolidColor == -1 )
        {
            //
            // Get the driver's realized brush
            //
            pb.prbrush = (RBrush*)pbo->pvRbrush;

            //
            // If it hasn't been realized, do it
            // Note: GDI will call DrvRealizeBrsuh to fullfill this task. So the
            // driver should have this function ready
            //
            if ( pb.prbrush == NULL )
            {
                DBG_GDI((7, "Realizing brush"));

                pb.prbrush = (RBrush*)BRUSHOBJ_pvGetRbrush(pbo);
                if ( pb.prbrush == NULL )
                {
                    //
                    // If we can't realize it, nothing we can do
                    //

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
                    pb.ppdev->ulLockCount--;
                    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

                    return(FALSE);
                }
                DBG_GDI((7, "Brsuh realizing done"));
            }// Realize brush

            pb.pptlBrush = pptlBrush;

            //
            // Check if brush pattern is 1 BPP or not
            // Note: This is set in DrvRealizeBrush
            //
            if ( pb.prbrush->fl & RBRUSH_2COLOR )
            {
                //
                // 1 BPP pattern. Do a Mono fill
                //
                pb.pgfn = vMonoPatFill;
            }
            else
            {
                //
                // Pattern is more than 1 BPP. Do color pattern fill
                //
                pb.pgfn = vPatFill;
                DBG_GDI((7, "Skip Fast Fill Color Pattern"));

                //
                // P2 can not handle fast filled patterns
                //
                goto SkipFastFill;
            }
        }// Handle non-solid brush
    }// Blackness check

    //
    // For solid brush, we can use FastFill
    //
    if ( bMore )
    {
        //
        // FastFill only knows how to take a single contiguous buffer
        // of points.  Unfortunately, GDI sometimes hands us paths
        // that are split over multiple path data records.  Convex
        // figures such as Ellipses, Pies and RoundRects are almost
        // always given in multiple records.  Since probably 90% of
        // multiple record paths could still be done by FastFill, for
        // those cases we simply copy the points into a contiguous
        // buffer...
        //
        // First make sure that the entire path would fit in the
        // temporary buffer, and make sure the path isn't comprised
        // of more than one subpath:
        //
        if ( (ppo->cCurves >= NUM_BUFFER_POINTS)
           ||(pd.flags & PD_ENDSUBPATH) )
        {
            goto SkipFastFill;
        }

        pPtFxTmp = &aptfxBuf[0];

        //
        // Copy one vertex over to pPtFxTmp from pd(path data)
        //
        RtlCopyMemory(pPtFxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

        //
        // Move the memory pointer over to next structure
        //
        pPtFxTmp     += pd.count;
        ulPtFxTmp     = pd.count;
        flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

        //
        // Loop to get all the vertex info. After the loop, all the vertex info
        // will be in array aptfxBuf[]
        //
        do
        {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            RtlCopyMemory(pPtFxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
            ulPtFxTmp += pd.count;
            pPtFxTmp += pd.count;
        } while ( !(pd.flags & PD_ENDSUBPATH) );

        //
        // Fake up the path data record
        //
        pd.pptfx  = &aptfxBuf[0];
        pd.count  = ulPtFxTmp;
        pd.flags |= flFirstRecord;

        //
        // If there's more than one subpath, we can't call FastFill
        //
        DBG_GDI((7, "More than one subpath!"));
        if ( bMore )
        {
            goto SkipFastFill;
        }
    }// if ( bMore )

    //
    // Fast polygon fill
    //
    if ( bFillPolygon(ppdev, (Surf*)pso->dhsurf, pd.count,
                      pd.pptfx, pb.solidColor,
                      ulRop4,
                      pco, pb.prbrush, pptlBrush) )
    {
        DBG_GDI((7, "Fast Fill Succeeded"));
        InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
        #if MULTITHREADED
            pb.ppdev->ulLockCount--;
            EngReleaseSemaphore(pb.ppdev->hsemLock);
        #endif
//@@END_DDKSPLIT

        return (TRUE);
    }

SkipFastFill:
    DBG_GDI((7, "Fast Fill Skipped"));
    if ( jClipping != DC_TRIVIAL )
    {
        if ( jClipping != DC_RECT )
        {
            DBG_GDI((7, "Complex Clipping"));

            //
            // There is complex clipping; let GDI fill the path
            //
            goto ReturnFalse;
        }

        //
        // Clip to the clip rectangle
        //
        ClipRect = pco->rclBounds;
    }
    else
    {
        //
        // So the y-clipping code doesn't do any clipping
        // We don't blow the values out when we scale up to GIQ
        //
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    //
    // Set up working storage in the temporary buffer, storage for list of
    // rectangles to draw
    // Note: ppdev->pvTmpBuffer is allocated in DrvEnableSurface() in enable.c
    // The purpose of using ppdev->pvTmpBuffer is to save us from having to
    // allocate and free the temp space inside high frequency calls. It was
    // allocated for TMP_BUFFER_SIZE bytes and will be freed in
    // DrvDeleteSurface()
    //
    prclRects = (RECTL*)ppdev->pvTmpBuffer;

    if ( !bMore )
    {
        RECTL*  pTmpRect;
        INT     cPoints = pd.count;

        //
        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges
        //
        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same.
        //
        // ??? we have already done the memcpy for the pd data. shall we use it
        //
        if ( ( cPoints == 4 )
           ||( ( cPoints == 5 )
             &&(pd.pptfx[0].x == pd.pptfx[4].x)
             &&(pd.pptfx[0].y == pd.pptfx[4].y) ) )
        {
            //
            // Get storage space for this temp rectangle
            //
            pTmpRect = prclRects;

            //
            // We have to start somewhere to assume that most
            // applications specify the top left point first
            // We want to check that the first two points are
            // either vertically or horizontally aligned.  If
            // they are then we check that the last point [3]
            // is either horizontally or  vertically  aligned,
            // and finally that the 3rd point [2] is  aligned
            // with both the first point and the  last  point
            //
            pTmpRect->top   = pd.pptfx[0].y - 1 & FIX_MASK;
            pTmpRect->left  = pd.pptfx[0].x - 1 & FIX_MASK;
            pTmpRect->right = pd.pptfx[1].x - 1 & FIX_MASK;

            //
            // Check if the first two points are vertically alligned
            //
            if ( pTmpRect->left ^ pTmpRect->right )
            {
                //
                // The first two points are not vertically alligned
                // Let's see if these two points are horizontal alligned
                //
                if ( pTmpRect->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK) )
                {
                    //
                    // The first two points are not horizontally alligned
                    // So it is not a rectangle
                    //
                    goto not_rectangle;
                }

                //
                // Up to now, the first two points are horizontally alligned,
                // but not vertically alligned. We need to check if the first
                // point vertically alligned with the 4th point
                //
                if ( pTmpRect->left ^ (pd.pptfx[3].x - 1 & FIX_MASK) )
                {
                    //
                    // The first point is not vertically alligned with the 4th
                    // point either. So this is not a rectangle
                    //
                    goto not_rectangle;
                }

                //
                // Check if the 2nd point and the 3rd point are vertically aligned
                //
                if ( pTmpRect->right ^ (pd.pptfx[2].x - 1 & FIX_MASK) )
                {
                    //
                    // The 2nd point and the 3rd point are not vertically aligned
                    // So this is not a rectangle
                    //
                    goto not_rectangle;
                }

                //
                // Check to see if the 3rd and 4th points are horizontally
                // alligned. If not, then it is not a rectangle
                //
                pTmpRect->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
                if ( pTmpRect->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }
            }// Check if the first two points are vertically alligned
            else
            {
                //
                // The first two points are vertically alligned. Now we need to
                // check if the 1st point and the 4th point are horizontally
                // aligned. If not, then this is not a rectangle
                //
                if ( pTmpRect->top ^ (pd.pptfx[3].y - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }

                //
                // Check if the 2nd point and the 3rd point are horizontally
                // aligned. If not, then this is not a rectangle
                //
                pTmpRect->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
                if ( pTmpRect->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }

                //
                // Check if the 3rd point and the 4th point are vertically
                // aligned. If not, then this is not a rectangle
                //
                pTmpRect->right = pd.pptfx[2].x - 1 & FIX_MASK;
                if ( pTmpRect->right ^ (pd.pptfx[3].x - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }
            }

            //
            // We have a rectangle now. Do some adjustment here first
            // If the left is greater than the right then
            // swap them so the blt code won't have problem
            //
            if ( pTmpRect->left > pTmpRect->right )
            {
                FIX temp;

                temp = pTmpRect->left;
                pTmpRect->left = pTmpRect->right;
                pTmpRect->right = temp;
            }
            else
            {
                //
                // If left == right there's nothing to draw
                //
                if ( pTmpRect->left == pTmpRect->right )
                {
                    DBG_GDI((7, "Nothing to draw"));
                    goto ReturnTrue;
                }
            }// Adjust right and left edge

            //
            // Shift the values to get pixel coordinates
            //
            pTmpRect->left  = (pTmpRect->left  >> FIX_SHIFT) + 1;
            pTmpRect->right = (pTmpRect->right >> FIX_SHIFT) + 1;

            //
            // Adjust the top and bottom coordiantes if necessary
            //
            if ( pTmpRect->top > pTmpRect->bottom )
            {
                FIX temp;

                temp = pTmpRect->top;
                pTmpRect->top = pTmpRect->bottom;
                pTmpRect->bottom = temp;
            }
            else
            {
                if ( pTmpRect->top == pTmpRect->bottom )
                {
                    DBG_GDI((7, "Nothing to draw"));
                    goto ReturnTrue;
                }
            }

            //
            // Shift the values to get pixel coordinates
            //
            pTmpRect->top    = (pTmpRect->top    >> FIX_SHIFT) + 1;
            pTmpRect->bottom = (pTmpRect->bottom >> FIX_SHIFT) + 1;

            //
            // Finally, check for clipping
            //
            if ( jClipping == DC_RECT )
            {
                //
                // Clip to the clip rectangle
                //
                if ( !bIntersect(pTmpRect, &ClipRect, pTmpRect) )
                {
                    //
                    // Totally clipped, nothing to do
                    //
                    DBG_GDI((7, "Nothing to draw"));
                    goto ReturnTrue;
                }
            }

            //
            // If we get here then the polygon is a rectangle,
            // set count to 1 and goto bottom to draw it
            //
            ulNumRects = 1;
            goto draw_remaining_rectangles;
        }// Check to see if it is a rectangle

not_rectangle:
        ;
    }// if ( !bMore )

    //
    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure????
    //
    if ( ppo->cCurves > MAX_EDGES )
    {
        //
        // Try to allocate enough memory
        //
        pFreeEdges = (EDGE*)ENGALLOCMEM(0, (ppo->cCurves * sizeof(EDGE)),
                                        ALLOC_TAG);
        if ( pFreeEdges == NULL )
        {
            DBG_GDI((1, "Can't allocate memory for %d edges", ppo->cCurves));

            //
            // Too many edges; let GDI fill the path
            //
            goto ReturnFalse;
        }
        else
        {
            //
            // Set a flag to indicate that we have allocate the memory so that
            // we can free it later
            //
            bMemAlloced = TRUE;
        }
    }// if ( ppo->cCurves > MAX_EDGES )
    else
    {
        //
        // If the total number of edges doesn't exceed the MAX_EDGES, then just
        // use our handy temporary buffer (it's big enough)
        //
        pFreeEdges = (EDGE*)((BYTE*)ppdev->pvTmpBuffer + RECT_BYTES);
    }

    //
    // Initialize an empty list of rectangles to fill
    //
    ulNumRects = 0;

    //
    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    //
    pGETHead = &GETHead;
    if ( !bConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect) )
    {
        DBG_GDI((7, "Outside Range"));
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    //
    // Create an empty AET with the head node also a tail sentinel
    //
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;       // Mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;         // This is greater than any valid X value, so
                                    // searches will always terminate

    //
    // Top scan of polygon is the top of the first edge we come to
    //
    iCurrentY = ((EDGE*)GETHead.pNext)->Y;

    //
    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    //
    while ( 1 )
    {
        //
        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        //
        if ( AETHead.pNext != pAETHead )
        {
            vAdvanceAETEdges(pAETHead);
        }

        //
        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        //
        if ( AETHead.pNext == pAETHead )
        {
            if ( GETHead.pNext == pGETHead )
            {
                //
                // Done if there are no edges in either the AET or the GET
                //
                break;
            }

            //
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            //
            iCurrentY = ((EDGE*)GETHead.pNext)->Y;
        }
        else
        {
            //
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            //
            if ( ((EDGE*)AETHead.pNext)->pNext != pAETHead )
            {
                vXSortAETEdges(pAETHead);
            }
        }

        //
        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        //
        if ( ((EDGE*)GETHead.pNext)->Y == iCurrentY )
        {
            vMoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        //
        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        //
        pCurrentEdge = (EDGE*)AETHead.pNext;   // point to the first edge
        do
        {
            INT iLeftEdge;

            //
            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            //
            iLeftEdge = pCurrentEdge->X;

            //
            // Find the matching right edge according to the current fill rule
            //
            if ( (flOptions & FP_WINDINGMODE) != 0 )
            {

                INT iWindingCount;

                //
                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                //
                iWindingCount = pCurrentEdge->iWindingDirection;
                do
                {
                    pCurrentEdge = (EDGE*)pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while ( iWindingCount != 0 );
            }
            else
            {
                //
                // Odd-even fill; the next edge is the matching right edge
                //
                pCurrentEdge = (EDGE*)pCurrentEdge->pNext;
            }

            //
            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            //
            if ( iLeftEdge < pCurrentEdge->X )
            {
                //
                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                //
                if ( ulNumRects >= MAX_PATH_RECTS )
                {
                    //
                    // No more room; draw the rectangles in the list and reset
                    // it to empty
                    //
                    pb.lNumRects = ulNumRects;
                    pb.pRects = prclRects;

                    pb.pgfn(&pb);

                    //
                    // Reset the list to empty
                    //
                    ulNumRects = 0;
                }

                //
                // Add the rectangle representing the current edge pair
                //
                if ( jClipping == DC_RECT )
                {
                    //
                    // Clipped
                    // Clip to left
                    //
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);

                    //
                    // Clip to right
                    //
                    prclRects[ulNumRects].right =
                                        min(pCurrentEdge->X, ClipRect.right);

                    //
                    // Draw only if not fully clipped
                    //
                    if ( prclRects[ulNumRects].left
                       < prclRects[ulNumRects].right )
                    {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY + 1;
                        ulNumRects++;
                    }
                }
                else
                {
                    //
                    // Unclipped
                    //
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY + 1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ( (pCurrentEdge = (EDGE*)pCurrentEdge->pNext) != pAETHead );

        iCurrentY++;                        // next scan
    }// Loop through all the scans in the polygon

    //
    // Draw the remaining rectangles, if there are any
    //
draw_remaining_rectangles:

    if ( ulNumRects > 0 )
    {
        pb.lNumRects = ulNumRects;
        pb.pRects = prclRects;
        
        pb.pgfn(&pb);
    }

ReturnTrue:
    DBG_GDI((7, "Drawn"));
    bRetVal = TRUE;                         // done successfully

ReturnFalse:
    //
    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.
    //
    if ( bMemAlloced )
    {
        //
        // We did allocate memory, so release it
        //
        ENGFREEMEM(pFreeEdges);
    }

    DBG_GDI((6, "Returning %s", bRetVal ? "True" : "False"));

    InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (bRetVal);
}// DrvFillPath()

//-----------------------------------------------------------------------------
//
// void vAdvanceAETEdges(EDGE* pAETHead)
//
// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
//
//-----------------------------------------------------------------------------
VOID
vAdvanceAETEdges(EDGE* pAETHead)
{
    EDGE*   pLastEdge;
    EDGE*   pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = (EDGE*)pLastEdge->pNext;
    do
    {
        //
        // Count down this edge's remaining scans
        //
        if ( --pCurrentEdge->iScansLeft == 0 )
        {
            //
            // We've done all scans for this edge; drop this edge from the AET
            //
            pLastEdge->pNext = pCurrentEdge->pNext;
        }
        else
        {
            //
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            //
            pCurrentEdge->X += pCurrentEdge->iXWhole;

            //
            // Advance the error term and see if we got one extra pixel this
            // time
            //
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;

            if ( pCurrentEdge->iErrorTerm >= 0 )
            {
                //
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                //
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = (EDGE *)pLastEdge->pNext) != pAETHead);
}// vAdvanceAETEdges()

//-----------------------------------------------------------------------------
//
// VOID vXSortAETEdges(EDGE* pAETHead)
//
// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
//
//-----------------------------------------------------------------------------
VOID
vXSortAETEdges(EDGE *pAETHead)
{
    BOOL    bEdgesSwapped;
    EDGE*   pLastEdge;
    EDGE*   pCurrentEdge;
    EDGE*   pNextEdge;

    do
    {
        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = (EDGE *)pLastEdge->pNext;
        pNextEdge = (EDGE *)pCurrentEdge->pNext;

        do
        {
            if ( pNextEdge->X < pCurrentEdge->X )
            {
                //
                // Next edge is to the left of the current edge; swap them
                //
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;

                //
                // Continue sorting before the edge we just swapped; it might
                // move farther yet
                //
                pCurrentEdge = pNextEdge;
            }
            
            pLastEdge = pCurrentEdge;
            pCurrentEdge = (EDGE *)pLastEdge->pNext;
        } while ( (pNextEdge = (EDGE*)pCurrentEdge->pNext) != pAETHead );
    } while ( bEdgesSwapped );
}// vXSortAETEdges()

//-----------------------------------------------------------------------------
//
// VOID vMoveNewEdges(EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY)
//
// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
//
//-----------------------------------------------------------------------------
VOID
vMoveNewEdges(EDGE* pGETHead,
              EDGE* pAETHead,
              INT   iCurrentY)
{
    EDGE*   pCurrentEdge = pAETHead;
    EDGE*   pGETNext = (EDGE*)pGETHead->pNext;

    do
    {
        //
        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        //
        while ( pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X )
        {
            pCurrentEdge = (EDGE*)pCurrentEdge->pNext;
        }

        //
        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        //
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = (EDGE*)pGETHead->pNext;
    } while (pGETNext->Y == iCurrentY);
}// vMoveNewEdges()

//-----------------------------------------------------------------------------
//
// BOOL (EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY)
//
// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.
//
//-----------------------------------------------------------------------------
BOOL
bConstructGET(EDGE*     pGETHead,
              EDGE*     pFreeEdges,
              PATHOBJ*  ppo,
              PATHDATA* pd,
              BOOL      bMore,
              RECTL*    pClipRect)
{
    POINTFIX pfxPathStart;    // point that started the current subpath
    POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              // starts the current edge

    //
    // Create an empty GET with the head node also a tail sentinel
    //
    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                // Searches will always terminate

    //
    // Note: PATHOBJ_vEnumStart is implicitly  performed by engine
    // already and first path is enumerated by the caller 
    // so here we don't need to call it again.
    //
next_subpath:

    //
    // Make sure the PATHDATA is not empty (is this necessary)???
    //
    if ( pd->count != 0 )
    {
        //
        // If first point starts a subpath, remember it as such
        // and go on to the next point, so we can get an edge
        //
        if ( pd->flags & PD_BEGINSUBPATH )
        {
            //
            // The first point starts the subpath; Remember it
            //
            pfxPathStart    = *pd->pptfx; // the subpath starts here
            pfxPathPrevious = *pd->pptfx; // this point starts the next edge
            pd->pptfx++;                  // advance to the next point
            pd->count--;                  // count off this point
        }

        //
        // Add edges in PATHDATA to GET, in Y-X sorted order
        //
        while ( pd->count-- )
        {
            if ( (pFreeEdges =
                  pAddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                pd->pptfx, pClipRect)) == NULL )
            {
                goto ReturnFalse;
            }

            pfxPathPrevious = *pd->pptfx; // current point becomes previous
            pd->pptfx++;                  // advance to the next point
        }// Loop through all the points

        //
        // If last point ends the subpath, insert the edge that
        // connects to first point  (is this built in already?)
        //
        if ( pd->flags & PD_ENDSUBPATH )
        {
            if ( (pFreeEdges = pAddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                            &pfxPathStart, pClipRect)) == NULL )
            {
                goto ReturnFalse;
            }
        }
    }// if ( pd->count != 0 )

    //
    // The initial loop conditions preclude a do, while or for
    //
    if ( bMore )
    {
        bMore = PATHOBJ_bEnum(ppo, pd);
        goto next_subpath;
    }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}// bConstructGET()

//-----------------------------------------------------------------------------
//
// EDGE* pAddEdgeToGET(EDGE* pGETHead, EDGE* pFreeEdge, POINTFIX* ppfxEdgeStart,
//                     POINTFIX* ppfxEdgeEnd, RECTL* pClipRect)
//
// Adds the edge described by the two passed-in points to the Global Edge
// Table (GET), if the edge spans at least one pixel vertically.
//
//-----------------------------------------------------------------------------
EDGE*
pAddEdgeToGET(EDGE*     pGETHead,
              EDGE*     pFreeEdge,
              POINTFIX* ppfxEdgeStart,
              POINTFIX* ppfxEdgeEnd,
              RECTL*    pClipRect)
{
    int iYStart;
    int iYEnd;
    int iXStart;
    int iXEnd;
    int iYHeight;
    int iXWidth;
    int yJump;
    int yTop;

    //
    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    //
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;

    if ( iYHeight == 0 )
    {
        //
        // Zero height; ignore this edge
        //
        return(pFreeEdge);
    }
    else if ( iYHeight > 0 )
    {
        //
        // Top-to-bottom
        //
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;

        pFreeEdge->iWindingDirection = 1;
    }
    else
    {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        
        pFreeEdge->iWindingDirection = -1;
    }

    if ( iYHeight & 0x80000000 )
    {
        //
        // Too large; outside 2**27 GDI range
        //
        return(NULL);
    }

    //
    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    //
    iXWidth = iXEnd - iXStart;
    if ( iXWidth >= 0 )
    {
        //
        // Left to right, so we change X as soon as we move at all
        //
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    }
    else
    {
        //
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        //
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if ( iXWidth & 0x80000000 )
    {
        //
        // Too large; outside 2**27 GDI range
        //
        return(NULL);
    }

    if ( iXWidth >= iYHeight )
    {
        //
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        //
        pFreeEdge->iXWhole = iXWidth / iYHeight;

        //
        // Add sign back into base run length if going right to left
        //
        if ( pFreeEdge->iXDirection == -1 )
        {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }

        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    }
    else
    {
        //
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        //
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }

    pFreeEdge->iErrorAdjustDown = iYHeight;

    //
    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping
    //
    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    //
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);

    //
    // Initial scan line on which to fill edge
    //
    pFreeEdge->Y = yTop >> 4;

    //
    // Calculate # of scans to actually fill, accounting for clipping
    //
    if ( (pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
         - pFreeEdge->Y) <= 0 )
    {
        //
        // No pixels at all are spanned, so we can ignore this edge
        //
        return(pFreeEdge);
    }

    //
    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed
    //
    if ( iYStart != yTop )
    {
        //
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        //
        yJump = yTop - iYStart;

        //
        // Advance x the minimum amount for the number of scans traversed
        //
        iXStart += pFreeEdge->iXWhole * yJump;

        vAdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }

    //
    // Turn the calculations into pixel rather than GIQ calculations
    //
    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    //
    // LATER adjust only if needed (if prestepped above)?
    //
    if ( pFreeEdge->iXDirection == 1 )
    {
        //
        // Left to right
        //
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown
                               * (((iXStart + 15) & ~0x0F) - iXStart);
    }
    else
    {
        //
        // Right to left
        //
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown
                               * ((iXStart - 1) & 0x0F);
    }

    //
    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    //
    pFreeEdge->iErrorTerm >>= 4;

    //
    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    //
    while (  (pFreeEdge->Y > ((EDGE*)pGETHead->pNext)->Y)
           ||( (pFreeEdge->Y == ((EDGE*)pGETHead->pNext)->Y)
             &&(pFreeEdge->X > ((EDGE*)pGETHead->pNext)->X) ) )
    {
        pGETHead = (EDGE*)pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    //
    // Point to the next edge storage location for next time
    //
    return(++pFreeEdge);
}// pAddEdgeToGET()

//-----------------------------------------------------------------------------
//
// void vAdjustErrorTerm(int *pErrorTerm, int iErrorAdjustUp,
//                       int iErrorAdjustDown, int yJump, int *pXStart,
//                       int iXDirection)
// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.
//
//-----------------------------------------------------------------------------
void
vAdjustErrorTerm(int*   pErrorTerm,
                 int    iErrorAdjustUp,
                 int    iErrorAdjustDown,
                 int    yJump,
                 int*   pXStart,
                 int    iXDirection)

{
#if defined(_X86_) || defined(i386)
    //
    // Adjust the error term up by the number of y coordinates we'll skip
    // *pErrorTerm += iErrorAdjustUp * yJump;
    //
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    //
    // See if the error term turned over even once while skipping
    //
    _asm    js  short NoErrorTurnover

    //
    // # of times we'll turn over the error term and step an extra x
    // coordinate while skipping
    // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
    //
    _asm    div iErrorAdjustDown
    _asm    inc eax

    //
    // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
    // the error term ends up ultimately
    //
    // Advance x appropriately for the # of times the error term
    // turned over
    // if (iXDirection == 1)
    // {
    //     *pXStart += NumAdjustDowns;
    // }
    // else
    // {
    //     *pXStart -= NumAdjustDowns;
    // }
    //
    _asm    mov ecx,pXStart
    _asm    cmp iXDirection,1
    _asm    jz  short GoingRight
    _asm    neg eax
GoingRight:
    _asm    add [ecx],eax

    // Adjust the error term down to its proper post-skip value
    // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    _asm    sub edx,iErrorAdjustDown
    _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
NoErrorTurnover:
    _asm    mov [ebx],eax

#else
    //
    // LONGLONGS are 64 bit integers (We hope!) as the multiply could
    // overflow 32 bit integers. If 64 bit ints are unsupported, the
    // LONGLONG will end up as a double. Hopefully there will be no
    // noticable difference in accuracy.
    LONGLONG NumAdjustDowns;
    LONGLONG tmpError = *pErrorTerm;

    //
    // Adjust the error term up by the number of y coordinates we'll skip
    //
    tmpError += (LONGLONG)iErrorAdjustUp * (LONGLONG)yJump;

    //
    // See if the error term turned over even once while skipping
    //
    if ( tmpError >= 0 )
    {
        //
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        //
        NumAdjustDowns = (tmpError / (LONGLONG)iErrorAdjustDown) + 1;

        //
        // Advance x appropriately for the # of times the error term
        // turned over
        //
        if ( iXDirection == 1 )
        {
            *pXStart += (LONG)NumAdjustDowns;
        }
        else
        {
            *pXStart -= (LONG) NumAdjustDowns;
        }

        //
        // Adjust the error term down to its proper post-skip value
        //
        tmpError -= (LONGLONG)iErrorAdjustDown * NumAdjustDowns;
    }
    *pErrorTerm = (LONG)tmpError;

#endif  // X86
}// vAdjustErrorTerm()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\gdi.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: gdi.h
*
* Contains all the gdi related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __GDI__H__
#define __GDI__H__

typedef struct _PDev PDev;

#define CLIP_LIMIT              50  // We'll take 800 bytes of stack space

typedef struct _ClipEnum
{
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];       // Space for enumerating complex clipping
} ClipEnum;                         /* ce, pce */

//
// Text stuff. Specifies foreground and background colours for faking a 1bpp
// XLATEOBJ
//
typedef struct _XlateColors
{       
    ULONG   iBackColor;
    ULONG   iForeColor;
} XlateColors;

#define SF_VM           0x01        // kept in video memory
#define SF_SM           0x02        // kept in system memory
#define SF_AGP          0x04        // kept in AGP memory
#define SF_LIST         0x08        // in surface list
#define SF_ALLOCATED    0x10        // surface memory allocated by us
#define SF_DIRECTDRAW   0x20        // wrapper of a Direct Draw surface

typedef ULONG SurfFlags;

typedef struct _Surf
{
    SurfFlags       flags;          // Type (video memory or system memory)

    PDev*           ppdev;          // Need this for deleting the bitmap

    struct _Surf*   psurfNext;
    struct _Surf*   psurfPrev;
    
    ULONG           cBlt;           // Counts down the number of blts necessary
                                    // at the current uniqueness before we'll
                                    // consider putting the DIB back into
                                    // off-screen memory
    ULONG           iUniq;          // Tells us whether there have been any
                                    // heap 'free's since the last time we
                                    // looked at
    LONG            cx;             // Bitmap width in pixels
    LONG            cy;             // Bitmap height in pixels
    union
    {
        ULONG       ulByteOffset;   // Offset from start of video memory if
                                    // DT_VM
        VOID*       pvScan0;        // pointer to system memory if DT_SM
    };
    LONG            lDelta;         // Stride in bytes for this bitmap
    VIDEOMEMORY*    pvmHeap;        // DirectDraw heap this was allocated from
    HSURF           hsurf;          // Handle to associated GDI surface (if any)
                                    // this DIB

    // New fields to support linear heap allocation of surface
    // Only valid if dt == DT_VM
    ULONG           ulPackedPP;     // padcked partial products needed by
                                    // Permedia hardware for given surface
                                    // lDelta
    ULONG           ulPixOffset;    // Pixel Offset from start of video memory
    ULONG           ulPixDelta;     // stride in pixels

    ULONG           ulChecksum;

} Surf;                             // dsurf, pdsurf

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill
#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

//
// Maximum number of rects we'll fill per call to the fill code
//
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

#define RIGHT 0
#define LEFT  1
#define NEARLY_ONE              0x0000FFFF

//
// Describe a single non-horizontal edge of a path to fill.
//
typedef struct _EDGE
{
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

typedef struct _EDGEDATA
{
    LONG      lCurrentXPos;     // Current x position
    LONG      lXAdvance;        // Number of pixels to advance x on each scan
    LONG      lError;           // Current DDA error
    LONG      lErrorUp;         // DDA error increment on each scan
    LONG      lErrorDown;       // DDA error adjustment
    POINTFIX* pptfx;            // Points to start of current edge
    LONG      lPtfxDelta;       // Delta (in bytes) from pptfx to next point
    LONG      lNumOfScanToGo;   // Number of scans to go for this edge
} EDGEDATA;                     // Ed, pEd

//
//
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

//
// Rendering constant definition
//
#define __RENDER_TEXTURE_ENABLE             (1 << 13)

#define __FX_TEXREADMODE_SWRAP_REPEAT       (1 << 1)
#define __FX_TEXREADMODE_TWRAP_REPEAT       (1 << 3)
#define __FX_TEXREADMODE_8HIGH              (3 << 13)
#define __FX_TEXREADMODE_8WIDE              (3 << 9)
#define __FX_TEXREADMODE_2048HIGH           (11 << 13)
#define __FX_TEXREADMODE_2048WIDE           (11 << 9)

#define __FX_TEXTUREREADMODE_PACKED_DATA    (1 << 24)

#define __FX_8x8REPEAT_TEXTUREREADMODE      ( __PERMEDIA_ENABLE               \
                                            | __FX_TEXREADMODE_TWRAP_REPEAT   \
                                            | __FX_TEXREADMODE_SWRAP_REPEAT   \
                                            | __FX_TEXREADMODE_8HIGH          \
                                            | __FX_TEXREADMODE_8WIDE)

#define __FX_TEXTUREDATAFORMAT_32BIT_RGBA   0x00
#define __FX_TEXTUREDATAFORMAT_32BIT        0x10
#define __FX_TEXTUREDATAFORMAT_8BIT         0xe
#define __FX_TEXTUREDATAFORMAT_16BIT        0x11
#define __FX_TEXTUREDATAFORMAT_4BIT         0xf

#define __P2_TEXTURE_DATAFORMAT_FLIP        (1 << 9)

#define __FX_TEXLUTMODE_DIRECT_ENTRY        (1 << 1)
#define __FX_TEXLUTMODE_4PIXELS_PER_ENTRY   (2 << 10)   //log2
#define __FX_TEXLUTMODE_2PIXELS_PER_ENTRY   (1 << 10)   //log2
#define __FX_TEXLUTMODE_1PIXEL_PER_ENTRY    0           //log2

#define STRETCH_MAX_EXTENT 32767

//
//-----------------------Function***Prototypes--------------------------------
//
// Low-level blt function prototypes
//
//----------------------------------------------------------------------------
typedef struct _GFNPB
{
    VOID (*pgfn)(struct _GFNPB *); // pointer to graphics function

    PDev *      ppdev;      // driver ppdev
    
    Surf *      psurfDst;   // destination surface
    RECTL *     prclDst;    // original unclipped destination rectangle
    
    Surf *      psurfSrc;   // source surface
    RECTL *     prclSrc;    // original unclipped source rectangle
    POINTL *    pptlSrc;    // original unclipped source point
                            // NOTE: pdsurfSrc must be null if
                            // there is no source.  If there is
                            // a source either (pptlSrc must be
                            // valid) or (pptlSrc is NULL and prclSrc
                            // is valid).
    
    RECTL *     pRects;     // rectangle list
    LONG        lNumRects;  // number of rectangles in list
    ULONG       colorKey;   // colorKey for transparent operations
    ULONG       solidColor; // solid color used in fills
    RBrush *    prbrush;    // pointer to brush
    POINTL *    pptlBrush;  // brush origin
    CLIPOBJ *   pco;        // clipping object
    XLATEOBJ *  pxlo;       // color translatoin object
    POINTL *    pptlMask;   // original uncliped mask origin
    ULONG       ulRop4;     // original rop4
    UCHAR       ucAlpha;    // alpha value for constant blends
    TRIVERTEX * ptvrt;      // verticies used for gradient fills
    ULONG       ulNumTvrt;  // number of verticies
    PVOID       pvMesh;     // connectivity for gradient fills
    ULONG       ulNumMesh;  // number of connectivity elements
    ULONG       ulMode;     // drawing mode
    SURFOBJ *   psoSrc;     // GDI managed surface source
    SURFOBJ *   psoDst;     // GDI managed surface destination
} GFNPB;

long flt_to_fix_1_30(float f);

BOOL    bConstructGET(EDGE*     pGETHead,
                      EDGE*     pFreeEdges,
                      PATHOBJ*  ppo,
                      PATHDATA* pd,
                      BOOL      bMore,
                      RECTL*    pClipRect);

EDGE*   pAddEdgeToGET(EDGE*     pGETHead,
                      EDGE*     pFreeEdge,
                      POINTFIX* ppfxEdgeStart,
                      POINTFIX* ppfxEdgeEnd,
                      RECTL*    pClipRect);

void    vAdjustErrorTerm(INT*   pErrorTerm,
                         INT    iErrorAdjustUp,
                         INT    iErrorAdjustDown,
                         INT    yJump,
                         INT*   pXStart,
                         INT    iXDirection);

VOID    vAdvanceAETEdges(EDGE* pAETHead);

VOID    vMoveNewEdges(EDGE* pGETHead,
                      EDGE* pAETHead,
                      INT   iCurrentY);

VOID    vXSortAETEdges(EDGE* pAETHead);

//
// Prototypes for lower level rendering functions
//
BOOL    bFillPolygon(PDev*      ppdev,
                     Surf*      pSurfDst,
                     LONG       lEdges,
                     POINTFIX*  pptfxFirst,
                     ULONG      ulSolidColor,
                     ULONG      ulRop4,
                     CLIPOBJ*   pco,
                     RBrush*    prb,
                     POINTL*    pptlBrush);

BOOL    bFillSpans(PDev*      ppdev,
                   Surf*      pSurfDst,
                   LONG       lEdges,
                   POINTFIX*  pptfxFirst,
                   POINTFIX*  pptfxTop,
                   POINTFIX*  pptfxLast,
                   ULONG      ulSolidColor,
                   ULONG      ulRop4,
                   CLIPOBJ*   pco,
                   RBrush*    prb,
                   POINTL*    pptlBrush);

BOOL    bInitializeStrips(PDev*     ppdev,
                          ULONG     iSolidColor,
                          DWORD     logicop,
                          RECTL*    prclClip);

void    vAlphaBlend(GFNPB * ppb);
void    vAlphaBlendDownload(GFNPB * ppb);
void    vConstantAlphaBlend(GFNPB * ppb);
void    vConstantAlphaBlendDownload(GFNPB * ppb);
void    vCopyBlt(GFNPB * ppb);
void    vCopyBltNative(GFNPB * ppb);
void    vGradientFillRect(GFNPB * ppb);
void    vGradientFillTri(GFNPB * ppb);
void    vImageDownload(GFNPB * ppb);
void    vInvert(GFNPB * ppb);
void    vMonoDownload(GFNPB * ppb);
void    vMonoOffset(GFNPB * ppb);
void    vMonoPatFill(GFNPB * ppb);
void    vPatFill(GFNPB * ppb);
void    vPatternFillRects(GFNPB * ppb);
void    vPatRealize(GFNPB * ppb);
void    vResetStrips(PDev* ppdev);
void    vRop2Blt(GFNPB * ppb);
void    vSolidFill(GFNPB * ppb);
void    vSolidFillWithRop(GFNPB * ppb);
void    vTransparentBlt(GFNPB * ppb);

//
// Text stuff
//
BOOL    bEnableText(PDev* ppdev);
VOID    vDisableText(PDev* ppdev);
VOID    vAssertModeText(PDev* ppdev, BOOL bEnable);

//
// Palette stuff
//
BOOL    bEnablePalette(PDev* ppdev);
BOOL    bInitializePalette(PDev* ppdev, DEVINFO* pdi);
VOID    vDisablePalette(PDev* ppdev);
VOID    vUninitializePalette(PDev* ppdev);

//
// Upload and download functions
//
VOID    vDownloadNative(GFNPB* ppb);
VOID    vUploadNative(GFNPB* ppb);

//
// StretchBlt stuff
//
DWORD   dwGetPixelSize(ULONG    ulBitmapFormat,
                       DWORD*   pdwFormatBits,
                       DWORD*   pdwFormatExtention);

BOOL    bStretchInit(SURFOBJ*    psoDst,
                     SURFOBJ*    psoSrc);

VOID    vStretchBlt(SURFOBJ*    psoDst,
                    SURFOBJ*    psoSrc,
                    RECTL*      rDest,
                    RECTL*      rSrc,
                    RECTL*      prclClip);

VOID    vStretchReset(PDev* ppdev);

//
// Work in progress
//

VOID    vCheckGdiContext(PPDev ppdev);
VOID    vOldStyleDMA(PPDev ppdev);
VOID    vNewStyleDMA(PPDev ppdev);

// Input buffer access methods

//
// InputBufferStart/InputBufferContinue/InputBufferCommit
//
//     This method is used when the caller does not know
//     the upper limit of the amount of space that needs to be reserved
//     or needs to reserve space that exceeds that maximum allowed to
//     be reserved MAX_FIFO_RESERVATION.
//
//     InputBufferStart() is used to get a pointer to the first available entry in
//     the input fifo, a pointer to the end of the reservation and
//     a pointer to the end of the usable area of the buffer.
//
//     InputBufferContinue() is called to extend the current reservation.
//
//     InputBufferCommit() is called when the caller is done using the reserved space.
//
//     Please see textout.c for an example usage of these methods.
//
// InputBufferReserve/InputBufferCommit
//
//     This method is used when the caller needs to make only one
//     reservation of some small known quantity.
//
//     InputBufferReserve() is called to establish the reservation.
//
//     InputBufferCommit() is called when the caller is done using the reserved space.
//
//     Please see textout.c for the usage of InputBufferReserve/InputBufferCommit. 
//
// A caller is free to use these access methods at any time.  Once either
// InputBufferStart or InputBufferReserve is called, the caller must pair the
// call with either a InputBufferFinish or a InputBufferCommit before making
// another reservation.
//
// A caller is free to use either of these methods at any time.
//
// Before calling any of the CPermedia class access methods, the caller
// must call InputBufferFlush (see below).  Because of this, a caller must
// call InputBufferFlush or InputBufferExecute before returning to GDI.
//
// When the caller is done and wishes to initial the transmission of what
// has been placed in the input fifo, the caller can call InputBufferExecute
// (see below).
// 
// InputBufferFlush
//
//      InputBufferFlush is a neccessary evil only as long as these macros are not
//      part of the official input buffer access schemes.  Flush is really
//      the means we sync up our copy of the input buffer state to the
//      CPermedia class.  If these methods were instead part of the fundamental
//      input fifo mechanism, then we could do away with the need for Flush.
//
// InputBufferExecute
//
//      Flush is a neccessary evil only as long as these macros are not
//      part of the official input buffer access schemes.  If and when these
//      new access schemes are made part of the official input fifo buffer
//      mechanism, then it can be replaced by that mechanism's input fifo
//      execute method.
//
//
// InputBufferMakeSpace
//
//      This is a private call and no one should find need to call it directly.
//
//
// Other Notes:
//
// We will play with making the access routines inline functions instead
// of macros taking a look at the code generated.  If acceptable,
// these macros may turn into function calls in the non-Debug build.
//
// The InputBufferStart/InputBufferContinue mechansism keeps state on the stack
// to avoid the dereferences to ppdev freeing up a register in cases where ppdev
// references are not needed in the inner loop that contains InputBufferContinue.
//

// MAX_IN_FIFO_RESERVATION should be bumped up considerably when we add an
// emulation buffer for the non-DMA case

#define MAX_INPUT_BUFFER_RESERVATION (INPUT_BUFFER_SIZE>>3) // in longs

#if DBG
extern
void InputBufferStart(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd);

extern
void InputBufferContinue(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd);

extern
void InputBufferReserve(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer);

extern
void InputBufferCommit(
    PPDev   ppdev,
    PULONG  pulBuffer);

#else
#define InputBufferStart(ppdev, ulLongs, ppulBuffer, ppulBufferEnd, ppulReservationEnd) \
{ \
    *(ppulBuffer) = ppdev->pulInFifoPtr; \
    *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs; \
    *(ppulBufferEnd) = ppdev->pulInFifoEnd; \
    if(*(ppulReservationEnd) > *(ppulBufferEnd)) \
    { \
        InputBufferSwap(ppdev); \
        *(ppulBuffer) = ppdev->pulInFifoPtr; \
        *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs; \
        *(ppulBufferEnd) = ppdev->pulInFifoEnd; \
    } \
}

#define InputBufferContinue(ppdev, ulLongs, ppulBuffer, ppulBufferEnd, ppulReservationEnd) \
{ \
    *(ppulReservationEnd) = *(ppulBuffer) + ulLongs; \
    if(*(ppulReservationEnd) > *(ppulBufferEnd)) \
    { \
        ppdev->pulInFifoPtr = *(ppulBuffer); \
        InputBufferSwap(ppdev); \
        *(ppulBuffer) = ppdev->pulInFifoPtr; \
        *(ppulReservationEnd) = *(ppulBuffer) + ulLongs; \
        *(ppulBufferEnd) = ppdev->pulInFifoEnd; \
    } \
}

#define InputBufferReserve(ppdev, ulLongs, ppulBuffer) \
{ \
    if(ppdev->pulInFifoPtr + ulLongs > ppdev->pulInFifoEnd) \
    { \
        InputBufferSwap(ppdev); \
    } \
    *(ppulBuffer) = ppdev->pulInFifoPtr; \
}

#define InputBufferCommit(ppdev, pulBuffer) ppdev->pulInFifoPtr = pulBuffer

#endif

void FASTCALL InputBufferFlush(PPDev ppdev);
void FASTCALL InputBufferSwap(PPDev ppdev);

void InputBufferSync(PPDev ppdev);

extern BOOL bGdiContext;

#endif // __GDI__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\heap.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.h
*
* This module contains all the definitions for heap related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __HEAP__H__
#define __HEAP__H__

//
// This function is called whenever we switch in or out of full-screen mode
//
BOOL    bAssertModeOffscreenHeap(PDev*, BOOL);

//
// Off-screen heap initialization
//
BOOL    bEnableOffscreenHeap(PDev*);

//
// Move the oldest memory block out of video memory
//
BOOL    bMoveOldestBMPOut(PDev* ppdev);

//
// Create a DSURF* in video memory
//
Surf*   pCreateSurf(PDev* ppdev, LONG lWidth, LONG lHeight);

//
// Video memory allocation
//
ULONG   ulVidMemAllocate(PDev* ppdev, LONG lWidth, LONG lHeight, LONG lPelSize, LONG* plDelta,
                         VIDEOMEMORY** ppvmHeap, ULONG* pulPackedPP, BOOL bDiscardable);

//
// Blank the screen
//
VOID    vBlankScreen(PDev*   ppdev);

//
// Adds the surface to the surface list
//
VOID    vAddSurfToList(PPDev ppdev, Surf* psurf);


//
// Frees any resources allocated by the off-screen heap
//
VOID    vDisableOffscreenHeap(PDev*);

//
// Removes the surface from the surface list
//
VOID    vRemoveSurfFromList(PPDev ppdev, Surf* psurf);

//
// Shifts the surface from its current position in the surface list to the
// end of surface list
//
VOID    vShiftSurfToListEnd(PPDev ppdev, Surf* psurf);

//
// Informs the heap manager that the surface has been accessed
//
VOID    vSurfUsed(PPDev ppdev, Surf* psurf);

//
// Free a DSURF structure
//
void    vDeleteSurf(Surf* psurf);

//
// Moves the surface from VM to SM
//

BOOL    bDemote(Surf* psurf);

//
// Attempts to move the surface from SM to VM
//

void    vPromote(Surf* psurf);

//
// Move all surfaces to SM
//

BOOL    bDemoteAll(PPDev ppdev);

#endif // __HEAP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\hwinit.c ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: hwinit.c
*
* This module contains the functions that enable and disable the hardware
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/

#include "precomp.h"
#include "gdi.h"
#include "p2ctxt.h"
#include "tvp4020.h"
#include "p2rd.h"
#define ALLOC_TAG ALLOC_TAG_WH2P
//-----------------------------------------------------------------------------
//
//  vInitCoreRegisters
//
//  set all core Permedia registers to a known state
//
//-----------------------------------------------------------------------------

VOID
vInitCoreRegisters(PPDev ppdev)
{
    PERMEDIA_DECL;
    PERMEDIA_DEFS(ppdev);

    // tracks FBWindowBase for off-screen bitmaps
    permediaInfo->PixelOffset = 0; 
    permediaInfo->TextureAddressMode = __PERMEDIA_ENABLE;
    permediaInfo->TextureReadMode = __PERMEDIA_DISABLE;
                                    /*__FX_TEXREADMODE_2048HIGH |
                                    __FX_TEXREADMODE_2048WIDE |
                                    __FX_TEXREADMODE_TWRAP_REPEAT | 
                                    __FX_TEXREADMODE_SWRAP_REPEAT |
                                    __PERMEDIA_ENABLE;*/
    RESERVEDMAPTR( 41);
    SEND_PERMEDIA_DATA(DeltaMode, 0);
    SEND_PERMEDIA_DATA(ColorDDAMode, 0);
    SEND_PERMEDIA_DATA(ScissorMode, 0);
    SEND_PERMEDIA_DATA(TextureColorMode, 0);
    SEND_PERMEDIA_DATA(FogMode, 0);
    SEND_PERMEDIA_DATA(Window, 0);
    SEND_PERMEDIA_DATA(StencilMode, 0);
    SEND_PERMEDIA_DATA(DepthMode, 0);
    SEND_PERMEDIA_DATA(AlphaBlendMode, 0);
    SEND_PERMEDIA_DATA(DitherMode, 0);
    SEND_PERMEDIA_DATA(LBReadMode, 0);
    SEND_PERMEDIA_DATA(LBWriteMode, 0);
    SEND_PERMEDIA_DATA(RasterizerMode, 0);
    SEND_PERMEDIA_DATA(WindowOrigin, 0);
    SEND_PERMEDIA_DATA(StatisticMode, 0);
    SEND_PERMEDIA_DATA(FBSoftwareWriteMask, -1);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, -1);
    SEND_PERMEDIA_DATA(FilterMode, 0);
    SEND_PERMEDIA_DATA(FBWindowBase, 0);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);
    SEND_PERMEDIA_DATA(FBReadMode, 0);
    SEND_PERMEDIA_DATA(dXDom, 0);
    SEND_PERMEDIA_DATA(dXSub, 0);
    SEND_PERMEDIA_DATA(dY, INTtoFIXED(1));
    SEND_PERMEDIA_DATA(TextureAddressMode, 0);
    SEND_PERMEDIA_DATA(TextureReadMode, 0);
    SEND_PERMEDIA_DATA(TexelLUTMode, 0);
    SEND_PERMEDIA_DATA(Texel0, 0);
    SEND_PERMEDIA_DATA(YUVMode, 0);
    SEND_PERMEDIA_DATA(FBReadPixel, __PERMEDIA_32BITPIXEL);      // 32 bit pixels
    SEND_PERMEDIA_DATA(SStart, 0);
    SEND_PERMEDIA_DATA(dSdx, 1 << 20);
    SEND_PERMEDIA_DATA(dSdyDom, 0);
    SEND_PERMEDIA_DATA(TStart, 0);
    SEND_PERMEDIA_DATA(dTdx, 0);
    SEND_PERMEDIA_DATA(dTdyDom, 0);
    SEND_PERMEDIA_DATA(TextureDataFormat, __FX_TEXTUREDATAFORMAT_32BIT_RGBA | 
                                          __P2_TEXTURE_DATAFORMAT_FLIP);
    SEND_PERMEDIA_DATA(TextureColorMode, 
                    (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION) 
                    | __PERMEDIA_ENABLE); // ignored by texture glyph rendering
    SEND_PERMEDIA_DATA(TextureAddressMode, permediaInfo->TextureAddressMode);
    SEND_PERMEDIA_DATA(TextureReadMode, permediaInfo->TextureReadMode);
    COMMITDMAPTR();
    FLUSHDMA();
}

//-----------------------------------------------------------------------------
//
//  bInitializeHW
//
//  Called to load the initial values into the chip. We assume the hardware
//  has been mapped. All the relevant stuff should be hanging off ppdev. We
//  also sort out all the hardware capabilities etc.
//
//-----------------------------------------------------------------------------

BOOL
bInitializeHW(PPDev ppdev)
{
    HwDataPtr permediaInfo;
    Surf*     psurf;
    LONG      i, j;
    ULONG     width;
    ULONG     ulValue;
    BOOL      bExists;
    ULONG     ulLength;
    ULONG     dmaBufferSize;
    PERMEDIA_DEFS(ppdev);

    DBG_GDI((7, "bInitializeHW: fbsize: 0x%x", ppdev->FrameBufferLength));

    // allocate and initialize ppdev->permediaInfo. We store hardware specific
    // stuff in this structure.
    //
    permediaInfo = (HwDataPtr)
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(HwDataRec), ALLOC_TAG); 
    if ( permediaInfo == NULL )
    {
        DBG_GDI((0, "cannot allocate memory for permediaInfo struct"));
        return (FALSE);
    }
    
    ppdev->permediaInfo = permediaInfo;
    permediaInfo->pGDICtxt = NULL;
    permediaInfo->pCurrentCtxt = NULL;

    // retrieve the PCI configuration information and local buffer size
    ulLength = sizeof(Hw_Device_Info);
    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_QUERY_DEVICE_INFO,
                            NULL,
                            0,
                            (PVOID)&(permediaInfo->deviceInfo),
                            ulLength,
                            &ulLength) )
    {
        DBG_GDI((1, "QUERY_DEVICE_INFO failed."));
        return (FALSE);
    }

    ulLength = sizeof(PINTERRUPT_CONTROL_BLOCK);
    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF,
                            NULL,
                            0,
                            (PVOID)&pP2dma,
                            ulLength,
                            &ulLength) )
    {
        DBG_GDI((1, "MAP_INTERRUPT_CMD_BUF failed."));
        return FALSE;
    }

    //
    // On NT4.0 the above IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF will fail and
    // pP2dma will be NULL. Hence we allocate it via ENGALLOCMEM.
    //
    if(g_bOnNT40)
    {
        ASSERTDD(pP2dma == 0, "bInitializeHW: pP2dma != 0");
        pP2dma = (P2DMA*) ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(_P2DMA), ALLOC_TAG);
    }

    // Even if IOCtrl call succeeded, 
    // the allocation can still fail.
    if (pP2dma==NULL)
    {
        DBG_GDI((0,"allocation of memory for P2DMA from miniport failed"));
        return FALSE;
    }

    // store away shared memory area for later use in ppdev
    ppdev->pP2dma=pP2dma;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED && DBG
    pP2dma->ppdev = ppdev;
#endif
//@@END_DDKSPLIT

    DBG_GDI((7, "deviceInfo: VendorId: 0x%x, DevId %d, DeltaId 0x%x,"
                "RevId %d, SubId %d, SubVId %d, lbuf len 0x%x, lbuf width %d",
             permediaInfo->deviceInfo.VendorId,
             permediaInfo->deviceInfo.DeviceId,
             permediaInfo->deviceInfo.DeltaRevId,
             permediaInfo->deviceInfo.RevisionId,
             permediaInfo->deviceInfo.SubsystemId,
             permediaInfo->deviceInfo.SubsystemVendorId,
             permediaInfo->deviceInfo.LocalbufferLength,
             permediaInfo->deviceInfo.LocalbufferWidth));

    // collect flags as we initialize so zero it here
    permediaInfo->flags = 0;

    // set up default pointers to our low level rendering functions
    //
    ppdev->pgfnAlphaBlend           = vAlphaBlend;
    ppdev->pgfnConstantAlphaBlend   = vConstantAlphaBlend;
    ppdev->pgfnCopyBlt              = vCopyBlt;
    ppdev->pgfnGradientFillRect     = vGradientFillRect;
    ppdev->pgfnPatFill              = vPatFill;
    ppdev->pgfnMonoPatFill          = vMonoPatFill;
    ppdev->pgfnMonoOffset           = vMonoOffset;
    ppdev->pgfnPatRealize           = vPatRealize;
    ppdev->pgfnSolidFill            = vSolidFill;
    ppdev->pgfnSolidFillWithRop     = vSolidFillWithRop;
    ppdev->pgfnTransparentBlt       = vTransparentBlt;
    ppdev->pgfnInvert               = vInvert;

    ppdev->pulRamdacBase = (ULONG*) ppdev->pulCtrlBase[0] 
                         + P2_EXTERNALVIDEO / sizeof(ULONG);

    // safe pointers to Permedia 2 registers for later use
    //
    ppdev->pCtrlBase   = ((ULONG *)ppdev->pulCtrlBase[0])+CTRLBASE/sizeof(ULONG);
    ppdev->pGPFifo     = ((ULONG *)ppdev->pulCtrlBase[0])+GPFIFO/sizeof(ULONG);
    ppdev->pCoreBase   = ((ULONG *)ppdev->pulCtrlBase[0])+COREBASE/sizeof(ULONG);

    DBG_GDI((5, "Initialize: pCtrlBase=0x%p", ppdev->pCtrlBase));
    DBG_GDI((5, "Initialize: pGPFifo=0x%p", ppdev->pGPFifo));
    DBG_GDI((5, "Initialize: pCoreBase=0x%p", ppdev->pCoreBase));

    if (!bInitializeP2DMA( pP2dma,
                           ppdev->hDriver,
                           (ULONG *)ppdev->pulCtrlBase[0],
                           ppdev->dwAccelLevel,
                           TRUE
                         ))
    {
        DBG_GDI((0, "P2DMA initialization failed."));
        return FALSE;
    }

    // keep a copy of Permedia 2 ChipConfig, so we know
    // if we are running on a AGP card or not
    ppdev->dwChipConfig = P2_READ_CTRL_REG(PREG_CHIPCONFIG);

    //
    // If we have a gamma ramp saved in the registry then use that. Otherwise,
    // initialize the LUT with a gamma of 1.0
    //
    if ( !bRegistryRetrieveGammaLUT(ppdev, &permediaInfo->gammaLUT) ||
         !bInstallGammaLUT(ppdev, &permediaInfo->gammaLUT) )
    {
        vSetNewGammaValue(ppdev, 0x10000);
    }

    //
    // fill in the permediaInfo capability flags and block fill size.
    //
    permediaInfo->flags |= GLICAP_NT_CONFORMANT_LINES;

    //
    // reset all core registers
    //
    vInitCoreRegisters(ppdev);

    //
    // now initialize the non-zero core registers
    //
    RESERVEDMAPTR(20);    // reserve a reasonable amount until the all is setup

    // Rasterizer Mode
    // Fraction and Bias are used by the line drawing code. MirrorBitMask
    // is set as all the bits we download are interpreted from bit 31 to bit 0

    permediaInfo->RasterizerMode = __PERMEDIA_START_BIAS_ZERO << 4 |
                                   __PERMEDIA_FRACTION_ADJUST_ALMOST_HALF << 2 |
                                   __PERMEDIA_ENABLE << 0 | // mirror bit mask
                                   __PERMEDIA_ENABLE << 18; // limits enabled

    SEND_PERMEDIA_DATA(RasterizerMode, permediaInfo->RasterizerMode);

//@@BEGIN_DDKSPLIT
    // TODO: we should not enable limit checking
//@@END_DDKSPLIT
    SEND_PERMEDIA_DATA(YLimits, 2047 << 16);
    SEND_PERMEDIA_DATA(XLimits, 2047 << 16);
    
    // Disable screen scissor
    SEND_PERMEDIA_DATA(ScissorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ScreenSize, ppdev->cyScreen << 16 | ppdev->cxScreen);

    ULONG ulPackedPP;

    DBG_GDI((7, "assuming screen stride is %d pixels\n", ppdev->cxMemory));
    vCalcPackedPP( ppdev->cxMemory, NULL, &ulPackedPP);

    // initialize FBReadMode for our default stride
    SEND_PERMEDIA_DATA(FBReadMode, ulPackedPP);

    // FB Write Mode
    permediaInfo->FBWriteMode = 1 | ((32/*permediaInfo->fastFillBlockSz*/ >> 4) << 1);

    SEND_PERMEDIA_DATA(FBWriteMode, permediaInfo->FBWriteMode);
    DBG_GDI((7, "setting FBWriteMode to 0x%x", (DWORD)permediaInfo->FBWriteMode));

    SEND_PERMEDIA_DATA(FBReadPixel, ppdev->cPelSize);

    //
    // do a probe to see if we support hardware writemasks. use the bottom
    // 8 bits only so the same code works for all depths. We also query a
    // registry variable which, if set, forces the use of software masking.
    //
    bExists = bRegistryQueryUlong(  ppdev,
                                    REG_USE_SOFTWARE_WRITEMASK,
                                    &ulValue);

    if ( !bExists || (ulValue == 0) )
    {
        // this code works as everything is little endian. i.e. the byte we
        // test is always at the lowest address regardless of the pixel depth.
        //
        WRITE_SCREEN_ULONG(ppdev->pjScreen, 0);   // quickest way to clear a pixel!!

        SEND_PERMEDIA_DATA(LogicalOpMode,       __PERMEDIA_CONSTANT_FB_WRITE);
        SEND_PERMEDIA_DATA(FBWriteData,         0xff);
        SEND_PERMEDIA_DATA(StartXDom,           0);
        SEND_PERMEDIA_DATA(StartY,              0);
        SEND_PERMEDIA_DATA(FBHardwareWriteMask, 0xa5);
        SEND_PERMEDIA_DATA(Render,              __RENDER_POINT_PRIMITIVE);
        COMMITDMAPTR();

        SYNC_WITH_PERMEDIA;

        ulValue = READ_SCREEN_ULONG(ppdev->pjScreen);
        if ( (ulValue & 0xff) == 0xa5 )
            permediaInfo->flags |= GLICAP_HW_WRITE_MASK;

        RESERVEDMAPTR(3);
    }

    DBG_GDI((7, "mode registers initialized"));

    SEND_PERMEDIA_DATA(FBHardwareWriteMask, -1);
    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    COMMITDMAPTR();
    FLUSHDMA();
  
    // Initialize out InFifo cached information

    dmaBufferSize = INPUT_BUFFER_SIZE;

#if defined(_X86_) || defined(_IA64_)
    if(!g_bOnNT40 && !pP2dma->bDMAEmulation)
    {
        AllocateDMABuffer(ppdev->hDriver, 
                          (LONG *) &dmaBufferSize,
                          &ppdev->dmaBufferVirtualAddress,
                          &ppdev->dmaBufferPhysicalAddress);

        if(ppdev->dmaBufferVirtualAddress != NULL
           && dmaBufferSize < INPUT_BUFFER_SIZE)
        {
            FreeDMABuffer(ppdev->hDriver, ppdev->dmaBufferVirtualAddress);
            ppdev->dmaBufferVirtualAddress = NULL;
        }
    }
    else
    {
        ppdev->dmaBufferVirtualAddress = NULL;
    }
#else
    ppdev->dmaBufferVirtualAddress = NULL;
#endif

    if(ppdev->dmaBufferVirtualAddress != NULL)
    {
        ppdev->pulInFifoStart = ppdev->dmaBufferVirtualAddress;
        ppdev->pulInFifoEnd = ppdev->dmaBufferVirtualAddress 
                            + (INPUT_BUFFER_SIZE>>3);
        ppdev->dmaCurrentBufferOffset = 0;
    }
    else
    {
        ppdev->pulInFifoStart = (ULONG*) ENGALLOCMEM(0, INPUT_BUFFER_SIZE>>1, ALLOC_TAG);

        if(ppdev->pulInFifoStart == NULL)
        {
            DBG_GDI((0, "bInitializeHW: unable to allocate scratch buffer"));
            pP2dma->bEnabled = FALSE;
            goto errExit;
        }
        
        ppdev->pulInFifoEnd = ppdev->pulInFifoStart + (INPUT_BUFFER_SIZE>>3);
    }

    ppdev->pulInFifoPtr = ppdev->pulInFifoStart;

#if DBG
    ppdev->ulReserved = 0;
#endif
    
    //
    // We are done setting up the GDI context state.
    //

    //
    // Allocate a hardware context for this PDEV saving the current context.
    //
    DBG_GDI((7, "allocating new context"));
    permediaInfo->pGDICtxt = P2AllocateNewContext(ppdev,
                                                    NULL,
                                                    0,
                                                    P2CtxtWriteOnly
                                                    );            

    if ( permediaInfo->pGDICtxt == NULL )
    {
        DBG_GDI((1, "failed to allocate Permedia context for display driver/GDI"));
        pP2dma->bEnabled = FALSE;
        return (FALSE);
    }

    DBG_GDI((7, "got context id 0x%x for GDI context", permediaInfo->pGDICtxt));
    P2SwitchContext(ppdev, permediaInfo->pGDICtxt);

    return (TRUE);

errExit:
    return FALSE;

}// bInitializeHW()

//-----------------------------------------------------------------------------
//
//  vDisableHW
//
//  do whatever needs to be done to disable the hardware and free resources
//  allocated in bInitializeHW
//
//-----------------------------------------------------------------------------

VOID
vDisableHW(PPDev ppdev)
{
    Surf*  psurf;
    PERMEDIA_DECL;

    if ( !permediaInfo )
    {
        return;
    }

    if(ppdev->dmaBufferVirtualAddress != NULL)
        FreeDMABuffer( ppdev->hDriver, ppdev->dmaBufferVirtualAddress);
    else if(ppdev->pulInFifoStart) // No DMA case..we allocated via ENGALLOCMEM
        ENGFREEMEM(ppdev->pulInFifoStart);

    //
    // Free up any contexts we allocated
    //
    if ( permediaInfo->pGDICtxt != NULL )
    {
        P2FreeContext(ppdev, permediaInfo->pGDICtxt);
        permediaInfo->pGDICtxt = NULL;
    }

    if ( permediaInfo->ContextTable )
    {
        ENGFREEMEM(permediaInfo->ContextTable);
    }
    permediaInfo->ContextTable=NULL;

    vFree(ppdev->pP2dma);
    ppdev->pP2dma = NULL;

    ENGFREEMEM(permediaInfo);

}// vDisableHW()

//-----------------------------------------------------------------------------
//
// VOID vAssertModeHW
//
// We're about to switch to/from full screen mode so do whatever we need to
// to save context etc.
//
//-----------------------------------------------------------------------------

VOID
vAssertModeHW(PPDev ppdev, BOOL bEnable)
{
    PERMEDIA_DECL;

    if (!permediaInfo)
        return;

    if (!bEnable)
    {
        
        if(ppdev->permediaInfo->pCurrentCtxt != NULL)
            P2SwitchContext(ppdev, NULL);
    
        //
        // Disable DMA
        //

        ASSERTDD(ppdev->pP2dma->bEnabled,
                 "vAssertModeHW: expected dma to be enabled");

        vSyncWithPermedia(ppdev->pP2dma);
        ppdev->pP2dma->bEnabled = FALSE;
    }
    else
    {
        //
        // Enable DMA
        //
        if (!bInitializeP2DMA( ppdev->pP2dma,
                               ppdev->hDriver,
                               (ULONG *)ppdev->pulCtrlBase[0],
                               ppdev->dwAccelLevel,
                               FALSE
                             ))
        {
            RIP("vAssertModeHW: Cannot restore DMA");
        }

        ASSERTDD(ppdev->permediaInfo->pCurrentCtxt == NULL,
                 "vAssertModeHW: expected no active context");

        //
        // Restore the current gamma LUT.
        //
        bInstallGammaLUT(ppdev, &permediaInfo->gammaLUT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\log.h ===
/******************************Module*Header*******************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: log.h
 *
 *
 * Copyright (c) 1992-1999 Microsoft Corporation.   All rights reserved.
 **************************************************************************/
#ifndef __LOG__
#define __LOG__

//extern char *  gLog;           // pointer to mapped log file
//extern char *  gLogPos;        // current position in log file
//extern char *  gLogSentinel;   // end of log file

ULONG ulLogOpen(LPWSTR pwsz, ULONG ulSize);
ULONG ulLogClose(void);

void
vLogPunt(void);

void
vLogBitBlt(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMsk,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    POINTL*   pptlMsk,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4,
    LONGLONG  llElapsedTicks,
    ULONG     ulCallDepth);

void
vLogCopyBits(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    LONGLONG  llElapsedTicks,
    ULONG     ulCallDepth);

void
vLogTransparentBlt(
    SURFOBJ *    psoDst,
    SURFOBJ *    psoSrc,
    CLIPOBJ *    pco,
    XLATEOBJ *   pxlo,
    RECTL *      prclDst,
    RECTL *      prclSrc,
    ULONG        iTransColor,
    LONGLONG    llElapsedTicks,
    ULONG       ulCallDepth);

void
vLogAlphaBlend(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    RECTL    *prclSrc,
    BLENDOBJ *pBlendObj,
    LONGLONG  llElapsedTicks,
    ULONG     ulCallDepth);

void
vLogGradientFill(
    SURFOBJ      *psoDst,
    CLIPOBJ      *pco,
    XLATEOBJ     *pxlo,
    TRIVERTEX    *pVertex,
    ULONG        nVertex,
    PVOID        pMesh,
    ULONG        nMesh,
    RECTL        *prclExtents,
    POINTL       *pptlDitherOrg,
    ULONG        ulMode,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);
void
vLogTextOut(
    SURFOBJ*     pso,
    STROBJ*      pstro,
    FONTOBJ*     pfo,
    CLIPOBJ*     pco,
    RECTL*       prclExtra,
    RECTL*       prclOpaque,
    BRUSHOBJ*    pboFore,
    BRUSHOBJ*    pboOpaque,
    POINTL*      pptlBrush, 
    MIX          mix,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogLineTo(
    SURFOBJ*     pso,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    LONG         x1,
    LONG         y1,
    LONG         x2,
    LONG         y2,
    RECTL*       prclBounds,
    MIX          mix,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogFillPath(
    SURFOBJ*     pso,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    MIX          mix,
    FLONG        flOptions,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogStrokePath(
    SURFOBJ*     pso,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    XFORMOBJ*    pxo,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    LINEATTRS*   pla,
    MIX          mix,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogSurfMovedToVM(
    Surf*        psurf);

void
vLogSurfMovedToSM(
    Surf*        psurf);

void
vLogSurfCreated(
    Surf*        psurf);

void
vLogSurfDeleted(
    Surf*        psurf);

#endif // __LOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\log.c ===
/******************************Module*Header*******************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: log.c
 *
 *
 * Copyright (c) 1992-1999 Microsoft Corporation.   All rights reserved.
 **************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "log.h"

// Logging support
#define MAX_LOG_FILE_NAME_SIZE  80

#define LF_PUNTED               0x1
#define LF_DSTVM                0x2
#define LF_SRCVM                0x4
#define LF_CALLDEPTHMASK        0xf0

#define LE_NULL                 0
#define LE_BITBLT               1
#define LE_COPYBITS             2
#define LE_SURFCREATED          3
#define LE_SURFMOVEDTOSM        4
#define LE_SURFMOVEDTOVM        5
#define LE_LOGOPENED            6
#define LE_LOGCLOSED            7
#define LE_ALPHABLEND           8
#define LE_TRANSPARENTBLT       9
#define LE_TEXTOUT              10
#define LE_FILLPATH             11
#define LE_STROKEPATH           12
#define LE_LINETO               13
#define LE_SURFDELETED          14
#define LE_GRADIENTFILL         15

typedef struct LogEntry
{
    USHORT      elapsedTime;
    BYTE        flags;
    BYTE        event;
    ULONG_PTR   src;            // format or pdsurf
    ULONG_PTR   dst;            // format or pdsurf
    USHORT      rop4;
} LogEntry;

LogEntry *  gLog = NULL;    // pointer to mapped log file
ULONG_PTR   giFile = NULL;
LogEntry *  gLogPos;        // current position in log file
LogEntry *  gLogSentinel;   // end of log file
wchar_t     gLogFileName[MAX_LOG_FILE_NAME_SIZE+1];
BOOL        gPunted = FALSE;

ULONG ulLogOpen(LPWSTR pwsz, ULONG ulSize)
{

    ULONG   ulResult = 0;

    // Make sure the log the log will be big enough to store atleast the log
    // open and the log close events
    
    if(gLog == NULL && ulSize >= (sizeof(LogEntry) * 2))
    {
        if(wcslen(pwsz) <= MAX_LOG_FILE_NAME_SIZE)
        {
            wcscpy(gLogFileName, pwsz);
            
            gLog = (LogEntry *) EngMapFile(gLogFileName, ulSize, &giFile);
            if (gLog != NULL)
            {
                // NOTE: we subtract one to save room for the close event
                gLogSentinel = gLog + ((ulSize / sizeof(LogEntry)) - 1);
                memset(gLog, 0, ulSize);
                gLogPos = gLog;
                
                gLogPos->event = LE_LOGOPENED;
                {
                    LONGLONG    frequency;
                    EngQueryPerformanceFrequency(&frequency);
                    if(frequency < 0xFFFFFFFF)
                        gLogPos->dst = (ULONG) (frequency & 0xFFFFFFFF);
                }
                gLogPos++;

                ulResult = TRUE;
            }
        }
    }

    return ulResult;
}

ULONG ulLogClose(void)
{
    ULONG   ulResult = 0;

    if(gLog != NULL)
    {
        // there is always room for the closed event
        gLogPos->event = LE_LOGCLOSED;

        ulResult = (ULONG) EngUnmapFile((ULONG_PTR) giFile);
    }
    
    gLog = NULL;

    return ulResult;
}

void vLogPunt(void)
{
    if(gLog != NULL)
        gLogPos->flags |= LF_PUNTED;
}

void
vLogBitBlt(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMsk,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    POINTL*   pptlMsk,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4,
    LONGLONG  elapsedTime,
    ULONG     ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }
        
        gLogPos->rop4 = (USHORT) rop4;
        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_BITBLT;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;
    }
}

void
vLogCopyBits(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    LONGLONG  elapsedTime,
    ULONG     ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_COPYBITS;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogTransparentBlt(
    SURFOBJ *    psoDst,
    SURFOBJ *    psoSrc,
    CLIPOBJ *    pco,
    XLATEOBJ *   pxlo,
    RECTL *      prclDst,
    RECTL *      prclSrc,
    ULONG        iTransColor,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_TRANSPARENTBLT;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogAlphaBlend(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    RECTL    *prclSrc,
    BLENDOBJ *pBlendObj,
    LONGLONG  elapsedTime,
    ULONG     ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG_PTR) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_ALPHABLEND;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogGradientFill(
    SURFOBJ      *psoDst,
    CLIPOBJ      *pco,
    XLATEOBJ     *pxlo,
    TRIVERTEX    *pVertex,
    ULONG        nVertex,
    PVOID        pMesh,
    ULONG        nMesh,
    RECTL        *prclExtents,
    POINTL       *pptlDitherOrg,
    ULONG        ulMode,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_GRADIENTFILL;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogTextOut(
    SURFOBJ*     psoDst,
    STROBJ*      pstro,
    FONTOBJ*     pfo,
    CLIPOBJ*     pco,
    RECTL*       prclExtra,
    RECTL*       prclOpaque,
    BRUSHOBJ*    pboFore,
    BRUSHOBJ*    pboOpaque,
    POINTL*      pptlBrush, 
    MIX          mix,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_TEXTOUT;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogLineTo(
    SURFOBJ*     psoDst,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    LONG         x1,
    LONG         y1,
    LONG         x2,
    LONG         y2,
    RECTL*       prclBounds,
    MIX          mix,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM )
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_LINETO;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogFillPath(
    SURFOBJ*     psoDst,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    MIX          mix,
    FLONG        flOptions,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM )
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_FILLPATH;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogStrokePath(
    SURFOBJ*     psoDst,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    XFORMOBJ*    pxo,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    LINEATTRS*   pla,
    MIX          mix,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM )
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_STROKEPATH;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogSurfMovedToVM(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFMOVEDTOVM;
        gLogPos++;

    }
}

void
vLogSurfMovedToSM(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFMOVEDTOSM;
        gLogPos++;

    }
}

void
vLogSurfCreated(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFCREATED;
        gLogPos++;

    }
}

void
vLogSurfDeleted(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFDELETED;
        gLogPos++;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\lines.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: lines.c
 *
 * Contains the code for drawing short fractional endpoint lines and
 * longer lines with strips.
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}
#define ABS(a)              ((a) < 0 ? -(a) : (a))

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V 
                                       //                   | FL_FLIP_D
};

BOOL bIntegerLine(PDev*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDev*, POINTFIX*, POINTFIX*);

//------------------------------------------------------------------------------
//
// BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
//             prclClip, apfn[], flStart)
// 
// Computes the DDA for the line and gets ready to draw it.  Puts the
// pixel data into an array of strips, and calls a strip routine to
// do the actual drawing.
// 
// Doing Lines Right
// -----------------
// 
// In NT, all lines are given to the device driver in fractional
// coordinates, in a 28.4 fixed point format.  The lower 4 bits are
// fractional for sub-pixel positioning.
// 
// Note that you CANNOT! just round the coordinates to integers
// and pass the results to your favorite integer Bresenham routine!!
// (Unless, of course, you have such a high resolution device that
// nobody will notice -- not likely for a display device.)  The
// fractions give a more accurate rendering of the line -- this is
// important for things like our Bezier curves, which would have 'kinks'
// if the points in its polyline approximation were rounded to integers.
// 
// Unfortunately, for fractional lines there is more setup work to do
// a DDA than for integer lines.  However, the main loop is exactly
// the same (and can be done entirely with 32 bit math).
// 
// If You've Got Hardware That Does Bresenham
// ------------------------------------------
// 
// A lot of hardware limits DDA error terms to 'n' bits.  With fractional
// coordinates, 4 bits are given to the fractional part, letting
// you draw in hardware only those lines that lie entirely in a 2^(n-4)
// by 2^(n-4) pixel space.
// 
// And you still have to correctly draw those lines with coordinates
// outside that space!  Remember that the screen is only a viewport
// onto a 28.4 by 28.4 space -- if any part of the line is visible
// you MUST render it precisely, regardless of where the end points lie.
// So even if you do it in software, somewhere you'll have to have a
// 32 bit DDA routine.
// 
// Our Implementation
// ------------------
// 
// We employ a run length slice algorithm: our DDA calculates the
// number of pixels that are in each row (or 'strip') of pixels.
// 
// We've separated the running of the DDA and the drawing of pixels:
// we run the DDA for several iterations and store the results in
// a 'strip' buffer (which are the lengths of consecutive pixel rows of
// the line), then we crank up a 'strip drawer' that will draw all the
// strips in the buffer.
// 
// We also employ a 'half-flip' to reduce the number of strip
// iterations we need to do in the DDA and strip drawing loops: when a
// (normalized) line's slope is more than 1/2, we do a final flip
// about the line y = (1/2)x.  So now, instead of each strip being
// consecutive horizontal or vertical pixel rows, each strip is composed
// of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
// (128, 128) would generate only one strip.
// 
// We also always draw only left-to-right.
// 
// Style lines may have arbitrary style patterns.  We specially
// optimize the default patterns (and call them 'masked' styles).
// 
// The DDA Derivation
// ------------------
// 
// Here is how I like to think of the DDA calculation.
// 
// We employ Knuth's "diamond rule": rendering a one-pixel-wide line
// can be thought of as dragging a one-pixel-wide by one-pixel-high
// diamond along the true line.  Pixel centers lie on the integer
// coordinates, and so we light any pixel whose center gets covered
// by the "drag" region (John D. Hobby, Journal of the Association
// for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
// 
// We must define which pixel gets lit when the true line falls
// exactly half-way between two pixels.  In this case, we follow
// the rule: when two pels are equidistant, the upper or left pel
// is illuminated, unless the slope is exactly one, in which case
// the upper or right pel is illuminated.  (So we make the edges
// of the diamond exclusive, except for the top and left vertices,
// which are inclusive, unless we have slope one.)
// 
// This metric decides what pixels should be on any line BEFORE it is
// flipped around for our calculation.  Having a consistent metric
// this way will let our lines blend nicely with our curves.  The
// metric also dictates that we will never have one pixel turned on
// directly above another that's turned on.  We will also never have
// a gap; i.e., there will be exactly one pixel turned on for each
// column between the start and end points.  All that remains to be
// done is to decide how many pixels should be turned on for each row.
// 
// So lines we draw will consist of varying numbers of pixels on
// successive rows, for example:
// 
//       ******
//             *****
//                  ******
//                        *****
// 
// We'll call each set of pixels on a row a "strip".
// 
// (Please remember that our coordinate space has the origin as the
// upper left pixel on the screen; postive y is down and positive x
// is right.)
// 
// Device coordinates are specified as fixed point 28.4 numbers,
// where the first 28 bits are the integer coordinate, and the last
// 4 bits are the fraction.  So coordinates may be thought of as
// having the form (x, y) = (M/F, N/F) where F is the constant scaling
// factor F = 2^4 = 16, and M and N are 32 bit integers.
// 
// Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
// left-to-right and whose slope is in the first octant, and let
// dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
// 
// Since the slope of the line is less than 1, the edges of the
// drag region are created by the top and bottom vertices of the
// diamond.  At any given pixel row y of the line, we light those
// pixels whose centers are between the left and right edges.
// 
// Let mL(n) denote the line representing the left edge of the drag
// region.  On pixel row j, the column of the first pixel to be
// lit is
// 
//       iL(j) = ceiling( mL(j * F) / F)
// 
// Since the line's slope is less than one:
// 
//       iL(j) = ceiling( mL([j + 1/2] F) / F )
// 
// Recall the formula for our line:
// 
//       n(m) = (dN / dM) (m - M0) + N0
// 
//       m(n) = (dM / dN) (n - N0) + M0
// 
// Since the line's slope is less than one, the line representing
// the left edge of the drag region is the original line offset
// by 1/2 pixel in the y direction:
// 
//       mL(n) = (dM / dN) (n - F/2 - N0) + M0
// 
// From this we can figure out the column of the first pixel that
// will be lit on row j, being careful of rounding (if the left
// edge lands exactly on an integer point, the pixel at that
// point is not lit because of our rounding convention):
// 
//       iL(j) = floor( mL(j F) / F ) + 1
// 
//             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
// 
//             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
// 
//                      F dM j - [ dM (N0 + F/2) - dN M0 ]
//             = floor( ---------------------------------- ) + 1
//                                   F dN
// 
//                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
//             = floor( ------------------------------------ ) + 1       (1)
//                                     dN
// 
//             = floor( (dM j + alpha) / dN ) + 1
// 
// where
// 
//       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
// 
// We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
// pixels in row j.  Because we are always calculating iL(j) for
// integer quantities of j, we note that the only fractional term
// is constant, and so we can 'throw away' the fractional bits of
// alpha:
// 
//       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
// 
// so
// 
//       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
// 
// for integers j.
// 
// Note if iR(j) is the line's rightmost pixel on row j, that
// iR(j) = iL(j + 1) - 1.
// 
// Similarly, rewriting equation (1) as a function of column i,
// we can determine, given column i, on which pixel row j is the line
// lit:
// 
//                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
//       j(i) = ceiling( ------------------------------------ ) - 1
//                                       dM
// 
// Floors are easier to compute, so we can rewrite this:
// 
//                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
//       j(i) = floor( ----------------------------------------------- ) - 1
//                                       dM
// 
//                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
//            = floor( ---------------------------------------------------- )
//                                       dM
// 
//                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
//            = floor( ---------------------------------------- )
//                                       dM
// 
// We can once again wave our hands and throw away the fractional bits
// of the remainder term:
// 
//       j(i) = floor( (dN i + gamma) / dM )                             (4)
// 
// where
// 
//       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
// 
// We now note that
// 
//       beta = -gamma - 1 = ~gamma                                      (6)
// 
// To draw the pixels of the line, we could evaluate (3) on every scan
// line to determine where the strip starts.  Of course, we don't want
// to do that because that would involve a multiply and divide for every
// scan.  So we do everything incrementally.
// 
// We would like to easily compute c , the number of pixels on scan j:
//                                  j
// 
//    c  = iL(j + 1) - iL(j)
//     j
// 
//       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
// 
// This may be rewritten as
// 
//    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
//     j          j+1    j+1                j    j
// 
// where i , i    are integers and r  < dN, r    < dN.
//        j   j+1                   j        j+1
// 
// Rewriting (7) again:
// 
//    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
//     j          j    j                          j    j
// 
// 
//       = floor((r  + dM) / dN) - floor(r  / dN)
//                 j                      j
// 
// This may be rewritten as
// 
//    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
//     j                j                      j
// 
// where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
// 
// r  is the remainder (or "error") term in the DDA loop: r  / dN
//  j                                                      j
// is the exact fraction of a pixel at which the strip ends.  To go
// on to the next scan and compute c    we need to know r   .
//                                  j+1                  j+1
// 
// So in the main loop of the DDA:
// 
//    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
//     j                j                  j+1     j
// 
// and we know r  < dN, r    < dN, and dR < dN.
//              j        j+1
// 
// We have derived the DDA only for lines in the first octant; to
// handle other octants we do the common trick of flipping the line
// to the first octant by first making the line left-to-right by
// exchanging the end-points, then flipping about the lines y = 0 and
// y = x, as necessary.  We must record the transformation so we can
// undo them later.
// 
// We must also be careful of how the flips affect our rounding.  If
// to get the line to the first octant we flipped about x = 0, we now
// have to be careful to round a y value of 1/2 up instead of down as
// we would for a line originally in the first octant (recall that
// "In the case where two pels are equidistant, the upper or left
// pel is illuminated...").
// 
// To account for this rounding when running the DDA, we shift the line
// (or not) in the y direction by the smallest amount possible.  That
// takes care of rounding for the DDA, but we still have to be careful
// about the rounding when determining the first and last pixels to be
// lit in the line.
// 
// Determining The First And Last Pixels In The Line
// -------------------------------------------------
// 
// Fractional coordinates also make it harder to determine which pixels
// will be the first and last ones in the line.  We've already taken
// the fractional coordinates into account in calculating the DDA, but
// the DDA cannot tell us which are the end pixels because it is quite
// happy to calculate pixels on the line from minus infinity to positive
// infinity.
// 
// The diamond rule determines the start and end pixels.  (Recall that
// the sides are exclusive except for the left and top vertices.)
// This convention can be thought of in another way: there are diamonds
// around the pixels, and wherever the true line crosses a diamond,
// that pel is illuminated.
// 
// Consider a line where we've done the flips to the first octant, and the
// floor of the start coordinates is the origin:
// 
//        +-----------------------> +x
//        |
//        | 0                     1
//        |     0123456789abcdef
//        |
//        |   0 00000000?1111111
//        |   1 00000000 1111111
//        |   2 0000000   111111
//        |   3 000000     11111
//        |   4 00000    ** 1111
//        |   5 0000       ****1
//        |   6 000           1***
//        |   7 00             1  ****
//        |   8 ?                     ***
//        |   9 22             3         ****
//        |   a 222           33             ***
//        |   b 2222         333                ****
//        |   c 22222       3333                    **
//        |   d 222222     33333
//        |   e 2222222   333333
//        |   f 22222222 3333333
//        |
//        | 2                     3
//        v
//        +y
// 
// If the start of the line lands on the diamond around pixel 0 (shown by
// the '0' region here), pixel 0 is the first pel in the line.  The same
// is true for the other pels.
// 
// A little more work has to be done if the line starts in the
// 'nether-land' between the diamonds (as illustrated by the '*' line):
// the first pel lit is the first diamond crossed by the line (pixel 1 in
// our example).  This calculation is determined by the DDA or slope of
// the line.
// 
// If the line starts exactly half way between two adjacent pixels
// (denoted here by the '?' spots), the first pixel is determined by our
// round-down convention (and is dependent on the flips done to
// normalize the line).
// 
// Last Pel Exclusive
// ------------------
// 
// To eliminate repeatedly lit pels between continuous connected lines,
// we employ a last-pel exclusive convention: if the line ends exactly on
// the diamond around a pel, that pel is not lit.  (This eliminates the
// checks we had in the old code to see if we were re-lighting pels.)
// 
// The Half Flip
// -------------
// 
// To make our run length algorithm more efficient, we employ a "half
// flip".  If after normalizing to the first octant, the slope is more
// than 1/2, we subtract the y coordinate from the x coordinate.  This
// has the effect of reflecting the coordinates through the line of slope
// 1/2.  Note that the diagonal gets mapped into the x-axis after a half
// flip.
// 
// How Many Bits Do We Need, Anyway?
// ---------------------------------
// 
// Note that if the line is visible on your screen, you must light up
// exactly the correct pixels, no matter where in the 28.4 x 28.4 device
// space the end points of the line lie (meaning you must handle 32 bit
// DDAs, you can certainly have optimized cases for lesser DDAs).
// 
// We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
// calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
// are in the first octant, so dM >= dN.  Then we know that gamma can
// be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
// valid lines will have dM and dN values at most 31 bits (unsigned)
// of significance.  So gamma requires 33 bits of significance (we store
// this as a 64 bit number for convenience).
// 
// When running through the DDA loop, r  + dR can have a value in the
//                                     j
// range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
//             j
// 
// Testing Lines
// -------------
// 
// To be NT compliant, a display driver must exactly adhere to GIQ,
// which means that for any given line, the driver must light exactly
// the same pels as does GDI.  This can be tested using the Guiman tool
// provided elsewhere in the DDK, and 'ZTest', which draws random lines
// on the screen and to a bitmap, and compares the results.
// 
// If You've Got Line Hardware
// ---------------------------
// 
// If your hardware already adheres to GIQ, you're all set.  Otherwise
// you'll want to look at the S3 sample code and read the following:
// 
// 1) You'll want to special case integer-only lines, since they require
//    less processing time and are more common (CAD programs will probably
//    only ever give integer lines).  GDI does not provide a flag saying
//    that all lines in a path are integer lines; consequently, you will
//    have to explicitly check every line.
// 
// 2) You are required to correctly draw any line in the 28.4 device
//    space that intersects the viewport.  If you have less than 32 bits
//    of significance in the hardware for the Bresenham terms, extremely
//    long lines would overflow the hardware.  For such (rare) cases, you
//    can fall back to strip-drawing code, of which there is a C version in
//    the S3's lines.cxx (or if your display is a frame buffer, fall back
//    to the engine).
// 
// 3) If you can explicitly set the Bresenham terms in your hardware, you
//    can draw non-integer lines using the hardware.  If your hardware has
//    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
//    pels long (4 bits are required for the fractional part, and one bit is
//    used as a sign bit).  Note that integer lines don't require the 4
//    fractional bits, so if you special case them as in 1), you can do
//    integer lines that are up to 2^(n - 1) pels long.  See the S3's
//    fastline.asm for an example.
// 
//------------------------------------------------------------------------------
BOOL
bLines(PDev*      ppdev,
       POINTFIX*  pptfxFirst,  // Start of first line
       POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
       RUN*       prun,        // Pointer to runs if doing complex clipping
       ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                               // in prun
       LINESTATE* pls,         // Colour and style info
       RECTL*     prclClip,    // Pointer to clip rectangle if doing simple
                               // clipping
       PFNSTRIP   apfn[],      // Array of strip functions
       FLONG      flStart)     // Flags for each line

{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx - 1; // Last point in path record
    STYLEPOS  spThis;                             // Style pos for this line

    LONG xmask  = 0xffff800f;
    LONG ymask  = 0xffffc00f;
    LONG xmask1 = 0xffff8000;
    LONG ymask1 = 0xffffc000;
    PERMEDIA_DECL;

    do
    {
        //
        // Start the DDA calculations
        //
        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        //
        // Check for non-complex-clipped, non-styled integer endpoint lines
        // Essentially, we allow rendering of any line which 'looks' like an
        // unclipped solid line. Initialization of hardware will cause the
        // correct results to appear
        //
        if ((fl & (FL_COMPLEX_CLIP | FL_STYLED))  == 0 )
        {
            LONG orx = (LONG) (M0 | dM);
            LONG ory = (LONG) (N0 | dN);

            if (orx < 0)
            {
                // At least one point was negative. Compute using abs points.
                orx = ABS((LONG)M0) | ABS((LONG)dM);
            }
            if (ory < 0)
            {
                // At least one point was negative. Compute using abs points.
                ory = ABS((LONG)N0) | ABS((LONG)dN);
            }

            DBG_GDI((7, "Lines: Trying Fast Integer %x %x %x %x", 
                     M0, N0, dM, dN));

            // Call fast integer line routines it integer coordinates
            if (((orx & xmask) == 0) && ((ory & ymask) == 0))
            {
                if (bFastIntegerLine(ppdev, M0, N0, dM, dN))
                {

                    if ((fl & FL_READ))
                    {
                        // If we have a logical op which requires reading from
                        // the frame buffer, we cannot guarantee 
                        // ContinueNewLine's behaviour when overwriting pixels.
                        // Also, avoid ContinueNewLine on an MX.
                        pptfxFirst = pptfxBuf;
                        pptfxBuf++;
                        continue;
                    }
                    else
                    {
                        // This is an optimization to use continue new line
                        // to draw any subequent integer lines. The loop is
                        // essentially the same as the outer loop, however, we
                        // dont need to check for a lot of things that we already
                        // know. We need to be able to fall out to the standard
                        // outer loop if we cant handle a line though.

                        while (TRUE)
                        {
                            // Have we reached the end of the list of points.
                            if (pptfxBuf == pptfxBufEnd)
                                return(TRUE);

                            pptfxFirst = pptfxBuf;
                            pptfxBuf++;

                            M0 = dM;
                            N0 = dN;
                            dM = (LONG) pptfxBuf->x;
                            dN = (LONG) pptfxBuf->y;

                            // We know M0 and N0 satisfy our criteria for a
                            // continue new line. Therefore, we just have to
                            // check the new coordinates
                            orx = (LONG) dM;
                            ory = (LONG) dN;

                            if (orx < 0)
                            {
                                // At least one point was negative.
                                // Recompute or using abs.
                                orx = ABS((LONG)dM);
                            }
                            if (ory < 0)
                            {
                                // At least one point was negative.
                                // Recompute or using abs.
                                ory = ABS((LONG)dN);
                            }

                            // We need to call the routine to continue
                            // the line now.  If the line is not a fast integer
                            // line, then we need to break out and try non
                            // integer lines. In this case, or will still be 
                            // valid, because we know M0, N0 are integer coords
                            // that Permedia2 can handle.
                            DBG_GDI((7, "Lines: Trying %x %x %x %x",
                                     M0, N0, dM, dN));
                            if (((orx & xmask) != 0) ||
                                ((ory & ymask) != 0) ||
                                (!bFastIntegerContinueLine(
                                                          ppdev, M0, N0, dM, dN)))
                                // Either we cant draw the line or the strip
                                //  drawer failed.
                                break;
                        }
                    }
                }
            }

            // Call fast non integer line routines.
            if (((orx & xmask1) == 0) && ((ory & ymask1) == 0))
            {
                if (bFastLine(ppdev, M0, N0, dM, dN))
                {
                    // This line done, do next line.
                    pptfxFirst = pptfxBuf;
                    pptfxBuf++;
                    continue;
                }
            }
        }

        DBG_GDI((7, "Lines: Slow Lines %x %x %x %x", M0, N0, dM, dN));

        if ((LONG) M0 > (LONG) dM)
        {
            // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

        // Compute the delta dx.  The DDI says we can never have a valid delta
        // with a magnitude more than 2^31 - 1, but GDI never actually checks
        // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
            // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;
        if ((LONG) dN < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

        // We now have a line running left-to-right, top-to-bottom from (M0, N0)
        // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
                // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
                // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        //
        // Convert M0 and N0 from 28.4 format to normal interger
        //
        x = LFLOOR((LONG)M0);
        y = LFLOOR((LONG)N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

        // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = Int32x32To64(dM, N0 + FBITS/2) - Int32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

        //
        // Figure out which pixels are at the ends of the line.
        //

        // The toughest part of GIQ is determining the start and end pels.
        //
        // Our approach here is to calculate x0 and x1 (the inclusive start
        // and end columns of the line respectively, relative to our normalized
        // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
        // start point is easily calculated by plugging x0 into our line equation
        // (which takes care of whether y = 1/2 rounds up or down in value)
        // getting y0, and then undoing the normalizing flips to get back
        // into device space.
        //
        // We look at the fractional parts of the coordinates of the start and
        // end points, and call them (M0, N0) and (M1, N1) respectively, where
        // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
        // to determine x0:
        //
        //   +-----------------------> +x
        //   |
        //   | 0                     1
        //   |     0123456789abcdef
        //   |
        //   |   0 ........?xxxxxxx
        //   |   1 ..........xxxxxx
        //   |   2 ...........xxxxx
        //   |   3 ............xxxx
        //   |   4 .............xxx
        //   |   5 ..............xx
        //   |   6 ...............x
        //   |   7 ................
        //   |   8 ................
        //   |   9 ......**........
        //   |   a ........****...x
        //   |   b ............****
        //   |   c .............xxx****
        //   |   d ............xxxx    ****
        //   |   e ...........xxxxx        ****
        //   |   f ..........xxxxxx
        //   |
        //   | 2                     3
        //   v
        //
        //   +y
        //
        // This grid accounts for the appropriate rounding of GIQ and last-pel
        // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
        // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // For the end point, if (M1, N1) lands on an 'x', x1 =
        // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
        // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // Lines of exactly slope one require a special case for both the start
        // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
        // the line has gone exactly through (8, 0) -- which may be considered
        // to be part of 'x' because of rounding!  So slopes of exactly slope
        // one going through (8, 0) must also be considered as belonging in 'x'.
        //
        // For lines that go left-to-right, we have the following grid:
        //
        //   +-----------------------> +x
        //   |
        //   | 0                     1
        //   |     0123456789abcdef
        //   |
        //   |   0 xxxxxxxx?.......
        //   |   1 xxxxxxx.........
        //   |   2 xxxxxx..........
        //   |   3 xxxxx...........
        //   |   4 xxxx............
        //   |   5 xxx.............
        //   |   6 xx..............
        //   |   7 x...............
        //   |   8 x...............
        //   |   9 x.....**........
        //   |   a xx......****....
        //   |   b xxx.........****
        //   |   c xxxx............****
        //   |   d xxxxx...........    ****
        //   |   e xxxxxx..........        ****
        //   |   f xxxxxxx.........
        //   |
        //   | 2                     3
        //   v
        //
        //   +y
        //
        // This grid accounts for the appropriate rounding of GIQ and last-pel
        // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
        // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // For the end point, if (M1, N1) lands on an 'x', x1 =
        // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
        // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // Lines of exactly slope one must be handled similarly to the right-to-
        // left case.

        {

            // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            //
            // Store normal integer in x1, not 28.4 format
            //
            x1 = LFLOOR(M0 + dM);

            if (fl & FL_FLIP_H)
            {
                // Line runs right-to-left:  <----

                // Compute x1:

                if (N1 == 0)
                {
                    if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                    {
                        x1++;
                    }
                }
                else if (ABS((LONG) (N1 - FBITS/2)) + M1 > FBITS)
                {
                    x1++;
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    == (FL_FLIP_SLOPE_ONE))
                {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                    if ((N1 > 0) && (M1 == N1 + 8))
                        x1++;

                    if ((N0 > 0) && (M0 == N0 + 8))
                    {
                        x0      = 2;
                        ulDelta = dN;
                        goto right_to_left_compute_y0;
                    }
                }

                // Compute x0:

                x0      = 1;
                ulDelta = 0;
                if (N0 == 0)
                {
                    if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }
                }
                else if (ABS((LONG) (N0 - FBITS/2)) + M0 > FBITS)
                {
                    x0      = 2;
                    ulDelta = dN;
                }

                // Compute y0:

                right_to_left_compute_y0:

                y0 = 0;
                ll = llGamma + (LONGLONG) ulDelta;

                if (ll >= (LONGLONG) (2 * dM - dN))
                    y0 = 2;
                else if (ll >= (LONGLONG) (dM - dN))
                    y0 = 1;
            }
            else
            {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                x1--;

                if (M1 > 0)
                {
                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                            x1++;
                    }
                    else if (ABS((LONG) (N1 - FBITS/2)) <= (LONG) M1)
                    {
                        x1++;
                    }
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                    if ((M1 > 0) && (N1 == M1 + 8))
                        x1--;

                    if ((M0 > 0) && (N0 == M0 + 8))
                    {
                        x0 = 0;
                        goto left_to_right_compute_y0;
                    }
                }

                // Compute x0:

                x0 = 0;
                if (M0 > 0)
                {
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                            x0 = 1;
                    }
                    else if (ABS((LONG) (N0 - FBITS/2)) <= (LONG) M0)
                    {
                        x0 = 1;
                    }
                }

                // Compute y0:

                left_to_right_compute_y0:

                y0 = 0;
                if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                {
                    y0 = 1;
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

        //
        // Complex clipping.                                                     *
        //

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

            Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
                // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
                // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

            // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

            // No overflow since large integer math is used.  Both values
            // will be positive:

            dl = Int32x32To64(x0, dN) + llGamma;

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

        //
        // Simple rectangular clipping.
        //

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

            // Note that y0 and y1 are actually the lower and upper bounds,
            // respectively, of the y coordinates of the line (the line may
            // have actually shrunk due to first/last pel clipping).
            //
            // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

            // Normalize to the same point we've normalized for the DDA
            // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
                Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

            // We have to know the correct y1, which we haven't bothered to
            // calculate up until now.  This multiply and divide is quite
            // expensive; we could replace it with code similar to that which
            // we used for computing y0.
            //
            // The reason why we need the actual value, and not an upper
            // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
            // careful when calculating x(y) that y0 <= y <= y1, otherwise
            // we can overflow on the divide (which, needless to say, is very
            // bad).

            dl = Int32x32To64(x1, dN) + llGamma;

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = Int32x32To64(y1, dM) + llBeta;

                x1 = UInt64Div32To32(dl, dN);
            }

            // At this point, we've taken care of calculating the intercepts
            // with the right and bottom edges.  Now we work on the left and
            // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = Int32x32To64(x0, dN) + llGamma;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = Int32x32To64(y0, dM) + llBeta;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

        //
        // Done clipping.  Unflip if necessary.
        //

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

        // Style calculations.

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_ARBITRARYSTYLED, "Oops");

                // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                    // The modulus of a negative number is not well-defined
                    // in C -- if it's negative we'll adjust it so that it's
                    // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

                // Since we always draw the line left-to-right, but styling is
                // always done in the direction of the original line, we have
                // to figure out where we are in the style array for the left
                // edge of this line.

                if (fl & FL_FLIP_H)
                {
                    // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                    // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                         "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED) &&
            !(fl & FL_DONT_DO_HALF_FLIP))
        {
            // Do a half flip!  Remember that we may doing this on the
            // same line multiple times for complex clipping (meaning the
            // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

        // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

        // Now calculate the DDA variables needed to figure out how many pixels
        // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
            ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = Int32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

            //
            // Run the DDA!                                                          *
            //
            while (TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }
    } while (pptfxBuf <= pptfxBufEnd);

    return(TRUE);
}// bLines()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\lines.h ===
/******************************Module*Header**********************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __LINES__
#define __LINES__

typedef struct _PDev PDev;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)
#define MIN_INTEGER_BOUND  (-512)

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00000100L     // .... ...1 .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_MASKSTYLED           0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED | FL_MASKSTYLED)
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000C00L
#define FL_STYLE_SHIFT          10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Logical operation which requires a read (for hardware)
#define FL_READ                 0x00008000L     // 1... .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + FBITS/2 - ((flRoundDown) > 0)) >> 4)
#define FBITS                 16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (FBITS - 1))

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;              // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawing prototype:

typedef VOID (FNSTRIP)(PDev*, STRIP*, LINESTATE*);
typedef FNSTRIP * PFNSTRIP;

// Strip drawing routines
FNSTRIP vSolidHorizontalLine;
FNSTRIP vSolidVerticalLine;
FNSTRIP vSolidDiagonalHorizontalLine;
FNSTRIP vSolidDiagonalVerticalLine;
FNSTRIP vStyledHorizontalLine;
FNSTRIP vStyledVerticalLine;

// Line drawering routines
GFNLINE bFastIntegerLine;
GFNLINE bFastIntegerContinueLine;
GFNLINE bFastLine;

// External calls:

BOOL bLines(PDev*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);

#endif // __LINES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\math64.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: math64.h
*
* Additional support for 64 bit math.
*
* Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#ifndef __MATH64__
#define __MATH64__

//------------------------------------------------------------------------------
//
// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
// 
//  Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//       two 32-bit LONGs to produce a 64-bit LONGLONG result.
// 
//  UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//       a 32-bit ULONG to produce a 32-bit ULONG result.
// 
//  UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//       a 32-bit ULONG to produce a 32-bit ULONG result.
// 
//------------------------------------------------------------------------------

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))


//------------------------------------------------------------------------------
// Type conversion functions
//------------------------------------------------------------------------------
static __inline void myFtoi(int *result, float f)
{
#if defined(_X86_)
    __asm {
        fld f
        mov   eax,result
        fistp dword ptr [eax]
    }
#else
    *result = (int)f;
#endif
}

static __inline void myFtoui(unsigned long *result, float f)
{
    *result = (unsigned long)f;
}


#endif  // __MATH64__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\lineto.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: lineto.c
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "rops.h"
#include "log.h"

//-----------------------------------------------------------------------------
// BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
//
// DrvLineTo() is an optimised, integer co-ordinate, API call that doesn't
// support styling. The integer-line code in Strips.c is called to do the 
// hard work.
//
//
//-----------------------------------------------------------------------------

BOOL
DrvLineTo(
    SURFOBJ*  pso,
    CLIPOBJ*  pco,
    BRUSHOBJ* pbo,
    LONG      x1,
    LONG      y1,
    LONG      x2,
    LONG      y2,
    RECTL*    prclBounds,
    MIX       mix)
{
    PDev*     ppdev;
    Surf*     psurf;
    BOOL      bResetHW;
    DWORD     logicOp;
    RECTL*    prclClip = (RECTL*)NULL;
    BOOL      retVal;
    ULONG     iSolidColor = pbo->iSolidColor;
    BOOL      bResult;

    //
    // PUnt call to engine if not in video memory
    //
    psurf = (Surf*)pso->dhsurf;
    
    if (psurf->flags & SF_SM)
    {
        goto puntIt;
    }

    if (pco != NULL)
    {
        if( pco->iDComplexity == DC_COMPLEX)
        {
            // hardware does not support complex clipping
            goto puntIt;
        }
        else if(pco->iDComplexity == DC_RECT)
        {
            prclClip = &(pco->rclBounds);
        }
    }

    ppdev = (PDev*) pso->dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvLineTo: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(ppdev);

    ppdev->psurf = psurf;

    // Get the logic op.
    logicOp = ulRop3ToLogicop(gaMix[mix & 0xff]);

    // Need to set up Permedia2 modes and colors appropriately for the line.
    bResetHW = bInitializeStrips(ppdev, iSolidColor, logicOp, prclClip);

    // bFastIntegerLine expects co-ords in 28.4 format
    bResult = bFastIntegerLine (ppdev, x1 << 4, y1 << 4, x2 << 4, y2 << 4);

    // If we have to restore the state then... do it.
    if (bResetHW)
        vResetStrips(ppdev);

    InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    if(bResult)
        return TRUE;
    
    // we failed to draw above, fall through thus punting to engine

puntIt:
//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG   flags = vPuntBefore(NULL, pso);
#endif
//@@END_DDKSPLIT

    bResult = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, NULL, pso);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;
    
}// DrvLineTo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\mini.c ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: mini.c
*
*  Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

//-----------------------------------------------------------------------------
//
//  AllocateDMABuffer
//
//  Allocate physical continous memory for DMA operation. This function returns
//  a pointer to a previously allocated DMA buffer if there is still an unfreed
//  allocation left. That way the reallocation of continous memory can be 
//  avoided when a new ppdev is created on lets say a mode switch, since 
//  allocation of continous memory cannot be guaranteed. The memory is only
//  physically freed after all allocations have called a FreeDMABuffer.
//
//  Calls to AllocateDMABuffer and FreeDMABuffer should be paired, otherwise
//  the usage count logic in the miniport driver gets confused!
//
//  The VideoPort currently restricts the size of a DMA buffer to 256kb.
//
//  hDriver-------videoport driver handle
//  plSize--------pointer to LONG size of requested DMA buffer. Returns size
//                of allocated DMA buffer 
//                (return value can be smaller than requested size)
//  ppVirtAddr----returns virtual address of requested DMA buffer.
//  pPhysAddr-----returns physical address of DMA buffer as seen from graphics
//                device.   
//
//  return        TRUE, allocation successful
//                FALSE, allocation failed
//
//-----------------------------------------------------------------------------

BOOL 
AllocateDMABuffer( HANDLE hDriver, 
                   PLONG  plSize, 
                   PULONG *ppVirtAddr, 
                   LARGE_INTEGER *pPhysAddr)
{

    LINE_DMA_BUFFER ldb;
    ldb.size = *plSize;          
    ldb.virtAddr = 0;

    ldb.cacheEnabled = TRUE;            

    *ppVirtAddr=0;      
    pPhysAddr->HighPart=
    pPhysAddr->LowPart=0;

    ULONG ulLength = sizeof(LINE_DMA_BUFFER);

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER,
                            (PVOID)&ldb,
                            ulLength,
                            (PVOID)&ldb,
                            ulLength,
                            &ulLength))
    {
        return(FALSE);
    }

    *ppVirtAddr=(PULONG)ldb.virtAddr;

    if (ldb.virtAddr!=NULL)
    {
        *pPhysAddr=ldb.physAddr;
        *plSize=ldb.size;          

        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//
//  FreeDMABuffer
//
//  free continous buffer previously allocated by AllocateDMABuffer.
//
//-----------------------------------------------------------------------------

BOOL 
FreeDMABuffer( HANDLE hDriver, 
               PVOID pVirtAddr)
{
    LINE_DMA_BUFFER ldb;
    ldb.size = 0;
    ldb.virtAddr = pVirtAddr;

    ULONG ulLength = sizeof(LINE_DMA_BUFFER);

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER,
                            (PVOID)&ldb,
                            ulLength,
                            NULL,
                            0,
                            &ulLength))
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
//  AllocateEmulatedDMABuffer
//
//  Allocate memory for emulated DMA operation.
//
//  hDriver-------videoport driver handle
//  ulSize--------ULONG size of requested DMA buffer
//  ulTag---------ULONG tag to mark allocation
//
//  return        NULL, allocation failed
//                otherwise, virtual address of emulated DMA buffer
//
//-----------------------------------------------------------------------------

PULONG 
AllocateEmulatedDMABuffer(
    HANDLE hDriver, 
    ULONG  ulSize,
    ULONG  ulTag
    )
{
    EMULATED_DMA_BUFFER edb;

    edb.virtAddr = NULL;
    edb.size = ulSize;
    edb.tag = ulTag;

    ULONG ulLength = sizeof(edb);

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_EMULATED_DMA_BUFFER,
                            (PVOID)&edb,
                            ulLength,
                            (PVOID)&edb,
                            ulLength,
                            &ulLength))
    {
        return (NULL);
    }

    return (PULONG)(edb.virtAddr);
}

//-----------------------------------------------------------------------------
//
//  FreeEmulatedDMABuffer
//
//  free buffer previously allocated by AllocateEmulatedDMABuffer.
//
//-----------------------------------------------------------------------------

BOOL 
FreeEmulatedDMABuffer(
    HANDLE hDriver, 
    PVOID pVirtAddr
    )
{
    EMULATED_DMA_BUFFER edb;

    edb.virtAddr = pVirtAddr;

    ULONG ulLength = sizeof(edb);

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_EMULATED_DMA_BUFFER,
                            (PVOID)&edb,
                            ulLength,
                            NULL,
                            0,
                            &ulLength))
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
//  StallExecution
//
//  calls VideoPortStallExecution in the miniport for defined delay when
//  polling Permedia registers. VideoPortStallexecution does not yield
//  to another process and should only be used in rare cases.
//
//  hDriver--------handle to videoport
//  ulMicroSeconds-number of microseconds to stall CPU execution
//
//-----------------------------------------------------------------------------

VOID
StallExecution( HANDLE hDriver, ULONG ulMicroSeconds)
{
    ULONG Length = 0;
    EngDeviceIoControl(hDriver,
                         IOCTL_VIDEO_STALL_EXECUTION,
                         &ulMicroSeconds,
                         sizeof(ULONG),
                         NULL,
                         0,
                         &Length);
}


//-----------------------------------------------------------------------------
//
//  GetPInterlockedExchange
//
//  We need to call the same InterlockedExchange function from the display 
//  driver and the miniport to make sure they work properly. The miniport
//  will give us a pointer to the function which we will call directly...
//  On Alpha and Risc machines, InterlockedExchange compiles as inline and
//  we don't need to call in the kernel.
//
//  note: the InterlockedExchange function exported from ntoskrnl has calling
//  convention __fastcall.
//
//-----------------------------------------------------------------------------

#if defined(_X86_)
PVOID
GetPInterlockedExchange( HANDLE hDriver)
{
    ULONG Length = 0;
    PVOID pWorkPtr=NULL;

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE,
                            NULL,
                            0,
                            &pWorkPtr,
                            sizeof(pWorkPtr),
                            &Length))
    {
        return NULL;
    }

    return pWorkPtr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\mini.h ===
/******************************Module*Header**********************************\
*
*                           *****************
*                           *  SAMPLE CODE  *
*                           *****************
*
* Module Name: mini.h
*
* Content:     structures and constants for communication with minidriver
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef _MINI_H_
#define _MINI_H_

//-----------------------------------------------------------------------------
//
//   structures used in IOCTL calls to miniport
//
//-----------------------------------------------------------------------------

typedef struct tagLINE_DMA_BUFFER {           //
    LARGE_INTEGER       physAddr;           // physical address of DMA buffer
    PVOID               virtAddr;           // mapped virtual address
    ULONG               size;               // size in bytes
    BOOLEAN             cacheEnabled;       // Whether buffer is cached 
} LINE_DMA_BUFFER, *PLINE_DMA_BUFFER;

typedef struct tagEMULATED_DMA_BUFFER {     //
    PVOID               virtAddr;           // virtual address
    ULONG               size;               // size in bytes
    ULONG               tag;                // allocation tag
} EMULATED_DMA_BUFFER, *PEMULATED_DMA_BUFFER;

//-----------------------------------------------------------------------------
//
//   shared structures used display driver and miniport
//
//-----------------------------------------------------------------------------

#define P2_ICB_MAGICNUMBER 0xbadabe01

typedef struct tagINTERRUPT_CONTROL_BLOCK {

    ULONG           ulMagicNo;

    volatile ULONG  ulControl;
    volatile ULONG  ulIRQCounter;

    LARGE_INTEGER   liDMAPhysAddr;        // physical start address of DMA buffer
    ULONG          *pDMABufferStart;      // virtual buffer start  
    ULONG          *pDMABufferEnd;        // virtual buffer end  
    volatile ULONG *pDMAActualBufferEnd;  // virtual actual buffer end
    volatile ULONG *pDMAWriteEnd;         // end for next write operation
    volatile ULONG *pDMAPrevStart;        // previous start address of a DMA
    volatile ULONG *pDMANextStart;        // next start address of a DMA
    volatile ULONG *pDMAWritePos;         // current write pointer

    // these flags lock the miniport interrupts and the display driver access
    // to these data structures. Use InterlockedExchange to lock to make
    // sure it works on multiprocessing environments
    volatile ULONG ulICBLock;               // this lock is set by the display driver

    volatile ULONG ulVSIRQCounter;          // VS IRQ Counter (if enabled)

    volatile ULONG ulLastErrorFlags;        // miniport saves value of last Error Interrupt
    volatile ULONG ulErrorCounter;          // counter for number of errors

    // the following variables are only used in the display driver



}INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;

//-----------------------------------------------------------------------------
//
// interrupt status bits set by minidriver IRQ service routine
//
//-----------------------------------------------------------------------------

enum {
    DMA_IRQ_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_IRQ_AVAILABLE  = 0x02, // can use VBLANK interrupts
};

//-----------------------------------------------------------------------------
//
//   IOCTL codes for minidriver calls
//
//-----------------------------------------------------------------------------

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_STALL_EXECUTION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_LUT_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDB, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_LUT_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDC, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_SAME_VIDEO_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDD, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_EMULATED_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDE, METHOD_BUFFERED, FILE_ANY_ACCESS)

//-----------------------------------------------------------------------------
//
//   functions provided by minidriver
//
//-----------------------------------------------------------------------------

BOOL 
AllocateDMABuffer( HANDLE hDriver, 
                   PLONG  plSize, 
                   PULONG *ppVirtAddr, 
                   LARGE_INTEGER *pPhysAddr);

BOOL 
FreeDMABuffer( HANDLE hDriver, PVOID pVirtAddr);

PULONG 
AllocateEmulatedDMABuffer(
    HANDLE hDriver, 
    ULONG  ulSize,
    ULONG  ulTag
    );
BOOL 
FreeEmulatedDMABuffer(
    HANDLE hDriver, 
    PVOID pVirtAddr
    );

VOID
StallExecution( HANDLE hDriver, ULONG ulMicroSeconds);
#if defined(_X86_)
PVOID
GetPInterlockedExchange( HANDLE hDriver);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\p2def.h ===
/******************************Module*Header**********************************\
*
*
* Module Name: p2def.h
*
* Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef _P2DEF_H
#define _P2DEF_H

// Texture operations
#define _P2_TEXTURE_MODULATE         0
#define _P2_TEXTURE_DECAL            1
#define _P2_TEXTURE_SPECULAR         4
#define _P2_TEXTURE_COPY             3

#define _P2_TEXTURE_CLAMP            0
#define _P2_TEXTURE_MIRROR           2
#define _P2_TEXTURE_REPEAT           1

/*-----------------------------------------------------*/
/* Permedia Register Fields */
/* --------------------- */

/* Common */
#define __PERMEDIA_ENABLE                         1
#define __PERMEDIA_DISABLE                        0

// From FBReadMode
#define __PERMEDIA_PATCH          0
#define __PERMEDIA_SUBPATCH       1
#define __PERMEDIA_SUBPATCHPACK   2

#define __PERMEDIA_8BITPIXEL      0
#define __PERMEDIA_16BITPIXEL     1
#define __PERMEDIA_32BITPIXEL     2
#define __PERMEDIA_4BITPIXEL      3
#define __PERMEDIA_24BITPIXEL     4

/* Host In */
#define __PERMEDIA_TAG_MODE_HOLD      0
#define __PERMEDIA_TAG_MODE_INCREMENT 1
#define __PERMEDIA_TAG_MODE_INDEXED   2
#define __PERMEDIA_TAG_MODE_RESERVED  3

/* Host out (Filter) options. */

#define __PERMEDIA_FILTER_TAG           0x1
#define __PERMEDIA_FILTER_DATA          0x2
#define __PERMEDIA_FILTER_TAG_AND_DATA  0x3

#define __PERMEDIA_STATS_COMPARE_INSIDE_REGION    0
#define __PERMEDIA_STATS_COMPARE_OUTSIDE_REGION   1
#define __PERMEDIA_STATS_EXCLUDE_PASSIVE_STEPS    0
#define __PERMEDIA_STATS_INCLUDE_PASSIVE_STEPS    1
#define __PERMEDIA_STATS_EXCLUDE_ACTIVE_STEPS     0
#define __PERMEDIA_STATS_INCLUDE_ACTIVE_STEPS     1
#define __PERMEDIA_STATS_TYPE_PICKING             0
#define __PERMEDIA_STATS_TYPE_EXTENT              1

/* Rasterization */

#define __PERMEDIA_LINE_PRIMITIVE                  0
#define __PERMEDIA_TRAPEZOID_PRIMITIVE             1
#define __PERMEDIA_POINT_PRIMITIVE                 2
#define __PERMEDIA_RECTANGLE_PRIMITIVE             3

#define __PERMEDIA_FLAT_SHADE_MODE                 0
#define __PERMEDIA_GOURAUD_SHADE_MODE              1

#define __PERMEDIA_FRACTION_ADJUST_NONE         0
#define __PERMEDIA_FRACTION_ADJUST_TRUNC        1
#define __PERMEDIA_FRACTION_ADJUST_HALF         2
#define __PERMEDIA_FRACTION_ADJUST_ALMOST_HALF  3

#define __PERMEDIA_START_BIAS_ZERO              0
#define __PERMEDIA_START_BIAS_HALF              1
#define __PERMEDIA_START_BIAS_ALMOST_HALF       2

/* Scissor */

/* Stipple */

#define __PERMEDIA_RESET_STIPPLE_COUNTERS         0
#define __PERMEDIA_LOAD_STIPPLE_COUNTERS          1
/* specifies pattern size as number of address bits less 1 */
#define __PERMEDIA_AREA_STIPPLE_2_PIXEL_PATTERN   0
#define __PERMEDIA_AREA_STIPPLE_4_PIXEL_PATTERN   1
#define __PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN   2
#define __PERMEDIA_AREA_STIPPLE_16_PIXEL_PATTERN  3
#define __PERMEDIA_AREA_STIPPLE_32_PIXEL_PATTERN  4

/* Chroma Test Mode */
#define __PERMEDIA_CHROMA_FBSOURCE      0
#define __PERMEDIA_CHROMA_FBDATA        1
#define __PERMEDIA_CHROMA_INPUT_COLOR   2
#define __PERMEDIA_CHROMA_OUTPUT_COLOR  3
#define __PERMEDIA_CHROMA_INCLUDE       0
#define __PERMEDIA_CHROMA_EXCLUDE       1

/* Texture Filter Mode */
#define __PERMEDIA_TEXTUREFILTER_ALPHAMAPSENSE_INCLUDE    0
#define __PERMEDIA_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE    1

/* Local buffer read */

#define __PERMEDIA_PPCODE0  0
#define __PERMEDIA_PPCODE1  1
#define __PERMEDIA_PPCODE2  2
#define __PERMEDIA_PPCODE3  3
#define __PERMEDIA_PPCODE4  4
#define __PERMEDIA_PPCODE5  5
#define __PERMEDIA_PPCODE6  6
#define __PERMEDIA_PPCODE7  7

#define __PERMEDIA_LBDEFAULT      0
#define __PERMEDIA_LBSTENCIL      1
#define __PERMEDIA_LBDEPTH        2

#define __PERMEDIA_FBDEFAULT       0
#define __PERMEDIA_FBCOLOR         1

#define __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN       0
#define __PERMEDIA_BOTTOM_LEFT_WINDOW_ORIGIN    1

#define __PERMEDIA_DEPTH_WIDTH_16      0
#define __PERMEDIA_DEPTH_WIDTH_24      1
#define __PERMEDIA_DEPTH_WIDTH_32      2

#define __PERMEDIA_STENCIL_WIDTH_0     0
#define __PERMEDIA_STENCIL_WIDTH_4     1
#define __PERMEDIA_STENCIL_WIDTH_8     2

#define __PERMEDIA_STENCIL_POSITION_16    0
#define __PERMEDIA_STENCIL_POSITION_20    1 
#define __PERMEDIA_FRAMECOUNT_POSITION_24    2
#define __PERMEDIA_FRAMECOUNT_POSITION_28    3
#define __PERMEDIA_FRAMECOUNT_POSITION_32    4
#define __PERMEDIA_FRAMECOUNT_POSITION_36    5
#define __PERMEDIA_FRAMECOUNT_POSITION_40    6

#define __PERMEDIA_GID_WIDTH_0        0
#define __PERMEDIA_GID_WIDTH_4        1
#define __PERMEDIA_GID_POSITION_16    0
#define __PERMEDIA_GID_POSITION_20    1
#define __PERMEDIA_GID_POSITION_24    2
#define __PERMEDIA_GID_POSITION_28    3
#define __PERMEDIA_GID_POSITION_32    4
#define __PERMEDIA_GID_POSITION_36    5
#define __PERMEDIA_GID_POSITION_40    6
#define __PERMEDIA_GID_POSITION_44    7
#define __PERMEDIA_GID_POSITION_48    8

/* FBReadMode */
#define __PERMEDIA_FBREAD_FBDEFAULT             0
#define __PERMEDIA_FBREAD_FBCOLOR               1
#define __PERMEDIA_FBREAD_ORIGINTOPLEFT         0
#define __PERMEDIA_FBREAD_ORIGINBOTTOMLEFT      1
#define __PERMEDIA_FBREAD_FBSOURCE_CONSTANT     0
#define __PERMEDIA_FBREAD_FBSOURCE_INDEX        1
#define __PERMEDIA_FBREAD_FBSOURCE_COORDINATE   2


/* Pixel ownership */
#define __PERMEDIA_GID_COMPARE_ALWAYS       0
#define __PERMEDIA_GID_COMPARE_NEVER        1
#define __PERMEDIA_GID_COMPARE_EQUAL        2
#define __PERMEDIA_GID_COMPARE_NOT_EQUAL    3
#define __PERMEDIA_GID_LBUPDATE_LBDATA      0
#define __PERMEDIA_GID_LBUPDATE_REGISTER    1

/* Stencil Test */

#define __PERMEDIA_STENCIL_BUFFER_WIDTH_4            0
#define __PERMEDIA_STENCIL_BUFFER_WIDTH_8            1
#define __PERMEDIA_STENCIL_BUFFER_WIDTH_1            2

#define __PERMEDIA_STENCIL_SOURCE_TEST_LOGIC        0
#define __PERMEDIA_STENCIL_SOURCE_STENCIL_MSG       1
#define __PERMEDIA_STENCIL_SOURCE_SOURCE_STENCIL    2
#define __PERMEDIA_STENCIL_SOURCE_LBSOURCEDATA_MSG  3

#define __PERMEDIA_STENCIL_COMPARE_MODE_NEVER               0
#define __PERMEDIA_STENCIL_COMPARE_MODE_LESS                1
#define __PERMEDIA_STENCIL_COMPARE_MODE_EQUAL               2
#define __PERMEDIA_STENCIL_COMPARE_MODE_LESS_OR_EQUAL       3
#define __PERMEDIA_STENCIL_COMPARE_MODE_GREATER             4
#define __PERMEDIA_STENCIL_COMPARE_MODE_NOT_EQUAL           5
#define __PERMEDIA_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL    6
#define __PERMEDIA_STENCIL_COMPARE_MODE_ALWAYS              7

#define __PERMEDIA_STENCIL_METHOD_KEEP          0
#define __PERMEDIA_STENCIL_METHOD_ZERO          1
#define __PERMEDIA_STENCIL_METHOD_REPLACE       2
#define __PERMEDIA_STENCIL_METHOD_INCR          3
#define __PERMEDIA_STENCIL_METHOD_DECR          4
#define __PERMEDIA_STENCIL_METHOD_INVERT        5


/* Depth Test */

#define __PERMEDIA_DEPTH_SOURCE_DDA                 0
#define __PERMEDIA_DEPTH_SOURCE_SOURCE_DEPTH        1
#define __PERMEDIA_DEPTH_SOURCE_DEPTH_MSG           2
#define __PERMEDIA_DEPTH_SOURCE_LBSOURCEDATA_MSG    3

#define __PERMEDIA_DEPTH_COMPARE_MODE_NEVER             0
#define __PERMEDIA_DEPTH_COMPARE_MODE_LESS              1
#define __PERMEDIA_DEPTH_COMPARE_MODE_EQUAL             2
#define __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL     3
#define __PERMEDIA_DEPTH_COMPARE_MODE_GREATER           4
#define __PERMEDIA_DEPTH_COMPARE_MODE_NOT_EQUAL         5
#define __PERMEDIA_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL  6
#define __PERMEDIA_DEPTH_COMPARE_MODE_ALWAYS            7

/* Local buffer write */

#define __PERMEDIA_WRITEMODE_NORMAL         0
#define __PERMEDIA_WRITEMODE_DOWRITE        1
#define __PERMEDIA_WRITEMODE_CANCELWRITE    2

#define __PERMEDIA_UPLOADDATA_NONE          0
#define __PERMEDIA_UPLOADDATA_LBDEPTH       1
#define __PERMEDIA_UPLOADDATA_LBSTENCIL     2

/* Texture / Fog  */

#define __PERMEDIA_TEXTURE_FILTER_NEAREST     0
#define __PERMEDIA_TEXTURE_FILTER_LINEAR2     1
#define __PERMEDIA_TEXTURE_FILTER_TRILINEAR4  2
#define __PERMEDIA_TEXTURE_FILTER_LINEAR4     3
#define __PERMEDIA_TEXTURE_FILTER_TRILINEAR8  4

/* Texture AddressMode */
#define __PERMEDIA_TEXADDRESS_WRAP_CLAMP        0
#define __PERMEDIA_TEXADDRESS_WRAP_REPEAT       1
#define __PERMEDIA_TEXADDRESS_WRAP_MIRROR       2
#define __PERMEDIA_TEXADDRESS_OPERATION_2D      0
#define __PERMEDIA_TEXADDRESS_OPERATION_3D      1
#define __PERMEDIA_TEXADDRESS_TEXMAP_1D         0
#define __PERMEDIA_TEXADDRESS_TEXMAP_2D         1

/* Texture ReadMode */
#define __PERMEDIA_TEXTUREREAD_FILTER_NEAREST           0
#define __PERMEDIA_TEXTUREREAD_FILTER_LINEAR            1
#define __PERMEDIA_TEXTUREREAD_FILTER_NEARMIPNEAREST    2
#define __PERMEDIA_TEXTUREREAD_FILTER_NEARMIPLINEAR     3
#define __PERMEDIA_TEXTUREREAD_FILTER_LINEARMIPNEAREST  4
#define __PERMEDIA_TEXTUREREAD_FILTER_LINEARMIPLINEAR   5
#define __PERMEDIA_TEXTUREREAD_WRAP_CLAMP               0
#define __PERMEDIA_TEXTUREREAD_WRAP_REPEAT              1
#define __PERMEDIA_TEXTUREREAD_WRAP_MIRROR              2
#define __PERMEDIA_TEXTUREREAD_TEXMAP_1D                0
#define __PERMEDIA_TEXTUREREAD_TEXMAP_2D                1
#define __PERMEDIA_TEXTUREREAD_FBSOURCE_NONE            0
#define __PERMEDIA_TEXTUREREAD_FBSOURCE_INDEX           1
#define __PERMEDIA_TEXTUREREAD_FBSOURCE_COORDINATE      2

/* Texture Format */
#define __PERMEDIA_TEXTUREFORMAT_LITTLE_ENDIAN              0
#define __PERMEDIA_TEXTUREFORMAT_BIG_ENDIAN                 1
#define __PERMEDIA_TEXTUREFORMAT_COMPONENTS_RGB             2
#define __PERMEDIA_TEXTUREFORMAT_COMPONENTS_RGBA            3
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_TEXEL               0
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_COLOR               1
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_BITMASK             2
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_ONECOMP_LUMA        0
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_ONECOMP_ALPHA       1
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_ONECOMP_INTESITY    2


/* Texture Color Mode */
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_ALPHA       0
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_LUMA        1
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_LUMA_ALPHA  2
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_INTENSITY   3
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_RGB         4
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_RGBA        5

#define __PERMEDIA_TEXCOLORMODE_APPLICATION_MODULATE 0
#define __PERMEDIA_TEXCOLORMODE_APPLICATION_DECAL    1
#define __PERMEDIA_TEXCOLORMODE_APPLICATION_BLEND    2
#define __PERMEDIA_TEXCOLORMODE_APPLICATION_COPY     3

/* Frame buffer read */
#define __PERMEDIA_FBDATA    0
#define __PERMEDIA_FBCOLOR  1


// Config - combined mode register for P2
#define __PERMEDIA_CONFIG_FBREAD_SRC     0x00000001
#define __PERMEDIA_CONFIG_FBREAD_DST     0x00000002
#define __PERMEDIA_CONFIG_PACKED_DATA    0x00000004
#define __PERMEDIA_CONFIG_FBWRITE        0x00000008
#define __PERMEDIA_CONFIG_COLOR_DDA  0x00000010
#define __PERMEDIA_CONFIG_LOGICOP(x)    (0x00000020 | ((x & 0xF) << 6))

/* Antialias */

#define __PERMEDIA_COLOR_MODE_RGBA                  0
#define __PERMEDIA_COLOR_MODE_CI                    1


/* Alpha Blend */

#define __PERMEDIA_BLEND_FUNC_ZERO                      0
#define __PERMEDIA_BLEND_FUNC_ONE                       1
#define __PERMEDIA_BLEND_FUNC_SRC_ALPHA                 4
#define __PERMEDIA_BLEND_FUNC_ONE_MINUS_SRC_ALPHA       5

#define __PERMEDIA_BLENDOP_ONE_AND_ONE                  0x11
#define __PERMEDIA_BLENDOP_SRCALPHA_AND_INVSRCALPHA     0x54
#define __PERMEDIA_BLENDOP_ONE_AND_INVSRCALPHA          0x51
#define __PERMEDIA_BLENDOP_ONE_AND_ZERO                 0x01

/* Dither */

#define __PERMEDIA_COLOR_FORMAT_RGBA_8888            0
#define __PERMEDIA_COLOR_FORMAT_RGBA_5555            1
#define __PERMEDIA_COLOR_FORMAT_RGBA_4444            2
#define __PERMEDIA_COLOR_FORMAT_RGBA_4444_FRONT      3
#define __PERMEDIA_COLOR_FORMAT_RGBA_4444_BACK       4
#define __PERMEDIA_COLOR_FORMAT_RGB_332_FRONT        5
#define __PERMEDIA_COLOR_FORMAT_RGB_332_BACK         6
#define __PERMEDIA_COLOR_FORMAT_RGB_121_FRONT        7
#define __PERMEDIA_COLOR_FORMAT_RGB_121_BACK         8

#define __PERMEDIA_COLOR_FORMAT_CI_8                14
#define __PERMEDIA_COLOR_FORMAT_CI_4                15

#define __PERMEDIA_COLOR_ORDER_BGR                   0
#define __PERMEDIA_COLOR_ORDER_RGB                   1

/* Logical Ops/Write mask */

#define K_LOGICOP_CLEAR                   0
#define K_LOGICOP_AND                     1
#define K_LOGICOP_AND_REVERSE             2
#define K_LOGICOP_COPY                    3
#define K_LOGICOP_AND_INVERTED            4
#define K_LOGICOP_NOOP                    5
#define K_LOGICOP_XOR                     6
#define K_LOGICOP_OR                      7
#define K_LOGICOP_NOR                     8
#define K_LOGICOP_EQUIV                   9
#define K_LOGICOP_INVERT                 10
#define K_LOGICOP_OR_REVERSE             11
#define K_LOGICOP_COPY_INVERT            12
#define K_LOGICOP_OR_INVERT              13
#define K_LOGICOP_NAND                   14
#define K_LOGICOP_SET                    15

#define __PERMEDIA_ALL_WRITEMASKS_SET             0xFFFFFFFF

/* FB Write */

#define __PERMEDIA_BLOCK_WIDTH_8    0
#define __PERMEDIA_BLOCK_WIDTH_16   1
#define __PERMEDIA_BLOCK_WIDTH_32   2

/*-----------------------------------------------------*/
#define __PERMEDIA_3D_CONTEXT  1
#define __PERMEDIA_2D_CONTEXT  2

#define __PERMEDIA_ALPHA_FUNC_SCALE         255.0

#define __PERMEDIA_MIN_SUB_SCAN_LINES       4
#define __PERMEDIA_MAX_SUB_SCAN_LINES       8
/* converts diameter into number of subscanlines in radius */
#define __PERMEDIA_FASTEST_SMOOTH_POINT_RADIUS (__PERMEDIA_MIN_SUB_SCAN_LINES >> 1)
#define __PERMEDIA_NICEST_SMOOTH_POINT_RADIUS  (__PERMEDIA_MAX_SUB_SCAN_LINES >> 1)

#define __PERMEDIA_POINT_TABLE_LONGS  4

#define __PERMEDIA_MAX_PPC_ENTRIES  3

#define __PERMEDIA_PPCODE0_SHIFT  0
#define __PERMEDIA_PPCODE1_SHIFT  5
#define __PERMEDIA_PPCODE2_SHIFT  6
#define __PERMEDIA_PPCODE3_SHIFT  7
#define __PERMEDIA_PPCODE4_SHIFT  8
#define __PERMEDIA_PPCODE5_SHIFT  9
#define __PERMEDIA_PPCODE6_SHIFT  10
#define __PERMEDIA_PPCODE7_SHIFT  11



// Tags
// group 0
#define __Permedia2TagStartXDom                  0
#define __Permedia2TagdXDom                      0x1
#define __Permedia2TagStartXSub                  0x2
#define __Permedia2TagdXSub                      0x3
#define __Permedia2TagStartY                     0x4
#define __Permedia2TagdY                         0x5
#define __Permedia2TagCount                      0x6
#define __Permedia2TagRender                     0x7
#define __Permedia2TagContinueNewLine            0x8
#define __Permedia2TagContinueNewDom             0x9
#define __Permedia2TagContinueNewSub             0xa
#define __Permedia2TagContinue                   0xb
#define __Permedia2TagBitMaskPattern             0xd

// group 1
#define __Permedia2TagRasterizerMode             0x14
#define __Permedia2TagYLimits                    0x15
#define __Permedia2TagWaitForCompletion          0x17
#define __Permedia2TagXLimits                    0x19
#define __Permedia2TagRectangleOrigin            0x1a
#define __Permedia2TagRectangleSize              0x1b

//group 2
#define __Permedia2TagPackedDataLimits           0x2a

//group 3
#define __Permedia2TagScissorMode                0x30
#define __Permedia2TagScissorMinXY               0x31
#define __Permedia2TagScissorMaxXY               0x32
#define __Permedia2TagScreenSize                 0x33
#define __Permedia2TagAreaStippleMode            0x34
#define __Permedia2TagWindowOrigin               0x39

// group 4
#define __Permedia2TagAreaStipplePattern0        0x40
#define __Permedia2TagAreaStipplePattern1        0x41
#define __Permedia2TagAreaStipplePattern2        0x42
#define __Permedia2TagAreaStipplePattern3        0x43
#define __Permedia2TagAreaStipplePattern4        0x44
#define __Permedia2TagAreaStipplePattern5        0x45
#define __Permedia2TagAreaStipplePattern6        0x46
#define __Permedia2TagAreaStipplePattern7        0x47

// group 7
#define __Permedia2TagTextureAddressMode         0x70
#define __Permedia2TagSStart                     0x71
#define __Permedia2TagdSdx                       0x72
#define __Permedia2TagdSdyDom                    0x73
#define __Permedia2TagTStart                     0x74
#define __Permedia2TagdTdx                       0x75
#define __Permedia2TagdTdyDom                    0x76
#define __Permedia2TagQStart                     0x77
#define __Permedia2TagdQdx                       0x78
#define __Permedia2TagdQdyDom                    0x79

// group 9
#define __Permedia2TagTexelLUTIndex              0x98
#define __Permedia2TagTexelLUTData               0x99
#define __Permedia2TagTexelLUTAddress            0x9a
#define __Permedia2TagTexelLUTTransfer           0x9b

// group b
#define __Permedia2TagTextureBaseAddress         0xb0
#define __Permedia2TagTextureMapFormat           0xb1
#define __Permedia2TagTextureDataFormat          0xb2

// group c
#define __Permedia2TagTexel0                     0xc0
#define __Permedia2TagTextureReadMode            0xce
#define __Permedia2TagTexelLUTMode               0xcf

// group d
#define __Permedia2TagTextureColorMode           0xd0
#define __Permedia2TagFogMode                    0xd2
#define __Permedia2TagFogColor                   0xd3
#define __Permedia2TagFStart                     0xd4
#define __Permedia2TagdFdx                       0xd5
#define __Permedia2TagdFdyDom                    0xd6
#define __Permedia2TagKsStart                    0xd9
#define __Permedia2TagdKsdx                      0xda
#define __Permedia2TagdKsdyDom                   0xdb
#define __Permedia2TagKdStart                    0xdc
#define __Permedia2TagdKddx                      0xdd
#define __Permedia2TagdKddyDom                   0xde

// group f
#define __Permedia2TagRStart                     0xf0
#define __Permedia2TagdRdx                       0xf1
#define __Permedia2TagdRdyDom                    0xf2
#define __Permedia2TagGStart                     0xf3
#define __Permedia2TagdGdx                       0xf4
#define __Permedia2TagdGdyDom                    0xf5
#define __Permedia2TagBStart                     0xf6
#define __Permedia2TagdBdx                       0xf7
#define __Permedia2TagdBdyDom                    0xf8
#define __Permedia2TagAStart                     0xf9
#define __Permedia2TagColorDDAMode               0xfc
#define __Permedia2TagConstantColor              0xfd
#define __Permedia2TagColor                      0xfe

// group 0x10
#define __Permedia2TagAlphaBlendMode             0x102
#define __Permedia2TagDitherMode                 0x103
#define __Permedia2TagFBSoftwareWriteMask        0x104
#define __Permedia2TagLogicalOpMode              0x105
// undocumented reg:
#define __Permedia2TagFBWriteData                0x106

// group 0x11
#define __Permedia2TagLBReadMode                 0x110
#define __Permedia2TagLBReadFormat               0x111
#define __Permedia2TagLBSourceOffset             0x112
#define __Permedia2TagLBData                     0x113
#define __Permedia2TagLBStencil                  0x115
#define __Permedia2TagLBDepth                    0x116
#define __Permedia2TagLBWindowBase               0x117
#define __Permedia2TagLBWriteMode                0x118
#define __Permedia2TagLBWriteFormat              0x119
#define __Permedia2TagTextureData                0x11d
#define __Permedia2TagTextureDownloadOffset      0x11e

//group 0x13
#define __Permedia2TagWindow                     0x130
#define __Permedia2TagStencilMode                0x131
#define __Permedia2TagStencilData                0x132
#define __Permedia2TagStencil                    0x133
#define __Permedia2TagDepthMode                  0x134
#define __Permedia2TagDepth                      0x135
#define __Permedia2TagZStartU                    0x136
#define __Permedia2TagZStartL                    0x137
#define __Permedia2TagdZdxU                      0x138
#define __Permedia2TagdZdxL                      0x139
#define __Permedia2TagdZdyDomU                   0x13a
#define __Permedia2TagdZdyDomL                   0x13b

// group 0x15
#define __Permedia2TagFBReadMode                 0x150
#define __Permedia2TagFBSourceOffset             0x151
#define __Permedia2TagFBPixelOffset              0x152
#define __Permedia2TagFBColor                    0x153
#define __Permedia2TagFBData                     0x154
#define __Permedia2TagFBSourceData               0x155
#define __Permedia2TagFBWindowBase               0x156
#define __Permedia2TagFBWriteMode                0x157
#define __Permedia2TagFBHardwareWriteMask        0x158
#define __Permedia2TagFBBlockColor               0x159
#define __Permedia2TagFBReadPixel                0x15a
// undocumented register, but used (see packed blt)
#define __Permedia2TagFBWriteConfig              0x15d

// group 0x18
#define __Permedia2TagFilterMode                 0x180
#define __Permedia2TagStatisticMode              0x181
#define __Permedia2TagMinRegion                  0x182
#define __Permedia2TagMaxRegion                  0x183
#define __Permedia2TagResetPickResult            0x184
#define __Permedia2TagMinHitRegion               0x185
#define __Permedia2TagMaxHitRegion               0x186
#define __Permedia2TagPickResult                 0x187
#define __Permedia2TagSync                       0x188
#define __Permedia2TagFBBlockColorU              0x18d
#define __Permedia2TagFBBlockColorL              0x18e
#define __Permedia2TagSuspendUntilFrameBlank     0x18f

// group 0x1b
#define __Permedia2TagFBSourceBase               0x1b0
#define __Permedia2TagFBSourceDelta              0x1b1
#define __Permedia2TagConfig                     0x1b2

// group 0x1d
#define __Permedia2TagTexelLUT0                  0x1d0
#define __Permedia2TagTexelLUT1                  0x1d1
#define __Permedia2TagTexelLUT2                  0x1d2
#define __Permedia2TagTexelLUT3                  0x1d3
#define __Permedia2TagTexelLUT4                  0x1d4
#define __Permedia2TagTexelLUT5                  0x1d5
#define __Permedia2TagTexelLUT6                  0x1d6
#define __Permedia2TagTexelLUT7                  0x1d7
#define __Permedia2TagTexelLUT8                  0x1d8
#define __Permedia2TagTexelLUT9                  0x1d9
#define __Permedia2TagTexelLUT10                 0x1da
#define __Permedia2TagTexelLUT11                 0x1db
#define __Permedia2TagTexelLUT12                 0x1dc
#define __Permedia2TagTexelLUT13                 0x1dd
#define __Permedia2TagTexelLUT14                 0x1de
#define __Permedia2TagTexelLUT15                 0x1df

// group 0x1e
#define __Permedia2TagYUVMode                    0x1e0
#define __Permedia2TagChromaUpperBound           0x1e1
#define __Permedia2TagChromaLowerBound           0x1e2
#define __Permedia2TagAlphaMapUpperBound         0x1e3
#define __Permedia2TagAlphaMapLowerBound         0x1e4
#define __Permedia2TagTextureID                  0x1ee
#define __Permedia2TagTexelLUTID                 0x1ef

// group 0x20..
#define __Permedia2TagV0FixedS                   0x200
#define __Permedia2TagV0FixedT                   0x201
#define __Permedia2TagV0FixedQ                   0x202
#define __Permedia2TagV0FixedKs                  0x203
#define __Permedia2TagV0FixedKd                  0x204
#define __Permedia2TagV0FixedR                   0x205
#define __Permedia2TagV0FixedG                   0x206
#define __Permedia2TagV0FixedB                   0x207
#define __Permedia2TagV0FixedA                   0x208
#define __Permedia2TagV0FixedF                   0x209
#define __Permedia2TagV0FixedX                   0x20a
#define __Permedia2TagV0FixedY                   0x20b
#define __Permedia2TagV0FixedZ                   0x20c
#define __Permedia2TagV0FixedW                   0x20d
#define __Permedia2TagV1FixedS                   0x210
#define __Permedia2TagV1FixedT                   0x211
#define __Permedia2TagV1FixedQ                   0x212
#define __Permedia2TagV1FixedKs                  0x213
#define __Permedia2TagV1FixedKd                  0x214
#define __Permedia2TagV1FixedR                   0x215
#define __Permedia2TagV1FixedG                   0x216
#define __Permedia2TagV1FixedB                   0x217
#define __Permedia2TagV1FixedA                   0x218
#define __Permedia2TagV1FixedF                   0x219
#define __Permedia2TagV1FixedX                   0x21a
#define __Permedia2TagV1FixedY                   0x21b
#define __Permedia2TagV1FixedZ                   0x21c
#define __Permedia2TagV1FixedW                   0x21d
#define __Permedia2TagV2FixedS                   0x220
#define __Permedia2TagV2FixedT                   0x221
#define __Permedia2TagV2FixedQ                   0x222
#define __Permedia2TagV2FixedKs                  0x223
#define __Permedia2TagV2FixedKd                  0x224
#define __Permedia2TagV2FixedR                   0x225
#define __Permedia2TagV2FixedG                   0x226
#define __Permedia2TagV2FixedB                   0x227
#define __Permedia2TagV2FixedA                   0x228
#define __Permedia2TagV2FixedF                   0x229
#define __Permedia2TagV2FixedX                   0x22a
#define __Permedia2TagV2FixedY                   0x22b
#define __Permedia2TagV2FixedZ                   0x22c
#define __Permedia2TagV2FixedW                   0x22d
#define __Permedia2TagV0FloatS                   0x230
#define __Permedia2TagV0FloatT                   0x231
#define __Permedia2TagV0FloatQ                   0x232
#define __Permedia2TagV0FloatKs                  0x233
#define __Permedia2TagV0FloatKd                  0x234
#define __Permedia2TagV0FloatR                   0x235
#define __Permedia2TagV0FloatG                   0x236
#define __Permedia2TagV0FloatB                   0x237
#define __Permedia2TagV0FloatA                   0x238
#define __Permedia2TagV0FloatF                   0x239
#define __Permedia2TagV0FloatX                   0x23a
#define __Permedia2TagV0FloatY                   0x23b
#define __Permedia2TagV0FloatZ                   0x23c
#define __Permedia2TagV0FloatW                   0x23d
#define __Permedia2TagV1FloatS                   0x240
#define __Permedia2TagV1FloatT                   0x241
#define __Permedia2TagV1FloatQ                   0x242
#define __Permedia2TagV1FloatKs                  0x243
#define __Permedia2TagV1FloatKd                  0x244
#define __Permedia2TagV1FloatR                   0x245
#define __Permedia2TagV1FloatG                   0x246
#define __Permedia2TagV1FloatB                   0x247
#define __Permedia2TagV1FloatA                   0x248
#define __Permedia2TagV1FloatF                   0x249
#define __Permedia2TagV1FloatX                   0x24a
#define __Permedia2TagV1FloatY                   0x24b
#define __Permedia2TagV1FloatZ                   0x24c
#define __Permedia2TagV1FloatW                   0x24d
#define __Permedia2TagV2FloatS                   0x250
#define __Permedia2TagV2FloatT                   0x251
#define __Permedia2TagV2FloatQ                   0x252
#define __Permedia2TagV2FloatKs                  0x253
#define __Permedia2TagV2FloatKd                  0x254
#define __Permedia2TagV2FloatR                   0x255
#define __Permedia2TagV2FloatG                   0x256
#define __Permedia2TagV2FloatB                   0x257
#define __Permedia2TagV2FloatA                   0x258
#define __Permedia2TagV2FloatF                   0x259
#define __Permedia2TagV2FloatX                   0x25a
#define __Permedia2TagV2FloatY                   0x25b
#define __Permedia2TagV2FloatZ                   0x25c
#define __Permedia2TagV2FloatW                   0x25d
#define __Permedia2TagDeltaMode                  0x260
#define __Permedia2TagDrawTriangle               0x261
#define __Permedia2TagRepeatTriangle             0x262
#define __Permedia2TagDrawLine01                 0x263
#define __Permedia2TagDrawLine10                 0x264
#define __Permedia2TagRepeatLine                 0x265
// special define???
// #define __Permedia2TagBroadcastMask              0x26f
// #define __MaximumPermediaTagValue  __Permedia2TagBroadcastMask

#define __Permedia2TagAreaStipplePattern(i)     (0x040+(i))

typedef long __Permedia2Tag ;

/*-----------------------------------------------------*/
#define __PERMEDIA_MAX_YSAMPLES 8  

#define __PERMEDIA_SAMPLES 4

#if __PERMEDIA_SAMPLES == 8

#define __PERMEDIA_SUBSAMPLES  64
#define __PERMEDIA_XSUBSAMPLES 8
#define __PERMEDIA_YSUBSAMPLES 8
#define __PERMEDIA_COLOR_SCALE 4

#define __PERMEDIA_SAMPLENORM  0.015625
#define __PERMEDIA_SPANNORM    0.125

#define __PERMEDIA_XSUBPIXSCALE 8
#define __PERMEDIA_XSUBPIXBITS  3
#define __PERMEDIA_XSUBPIXSHIFT 3
#define __PERMEDIA_XSUBPIXMASK  7
#define __PERMEDIA_XFRACSHIFT   0

#define __PERMEDIA_YSUBPIXSCALE __PERMEDIA_XSUBPIXSCALE
#define __PERMEDIA_YSUBPIXBITS  __PERMEDIA_XSUBPIXBITS
#define __PERMEDIA_YSUBPIXSHIFT __PERMEDIA_XSUBPIXSHIFT
#define __PERMEDIA_YSUBPIXMASK  __PERMEDIA_XSUBPIXMASK

#elif __PERMEDIA_SAMPLES == 4

#define __PERMEDIA_SUBSAMPLES  16
#define __PERMEDIA_XSUBSAMPLES 4
#define __PERMEDIA_YSUBSAMPLES 4
#define __PERMEDIA_COLOR_SCALE 16

#define __PERMEDIA_SAMPLENORM   0.0625 
#define __PERMEDIA_SPANNORM     0.25  

#define __PERMEDIA_XSUBPIXSCALE 8
#define __PERMEDIA_XSUBPIXBITS  3 
#define __PERMEDIA_XSUBPIXSHIFT 3 
#define __PERMEDIA_XSUBPIXMASK  7 
#define __PERMEDIA_XFRACSHIFT   1

#define __PERMEDIA_YSUBPIXSCALE 4
#define __PERMEDIA_YSUBPIXBITS  2  
#define __PERMEDIA_YSUBPIXSHIFT 2  
#define __PERMEDIA_YSUBPIXMASK  3 

#elif __PERMEDIA_SAMPLES == 2

"NOT SUPPORTED YET"

#else  /* __PERMEDIA_SAMPLES == 1 Alias Case */

#define __PERMEDIA_SUBSAMPLES  1
#define __PERMEDIA_XSUBSAMPLES 1
#define __PERMEDIA_YSUBSAMPLES 1
#define __PERMEDIA_COLOR_SCALE 255

#define __PERMEDIA_SAMPLENORM   1
#define __PERMEDIA_SPANNORM     1

#define __PERMEDIA_XSUBPIXSCALE 8
#define __PERMEDIA_XSUBPIXBITS  3
#define __PERMEDIA_XSUBPIXSHIFT 3
#define __PERMEDIA_XSUBPIXMASK  7
 
#define __PERMEDIA_XFRACSHIFT   3

#define __PERMEDIA_YSUBPIXSCALE 1
#define __PERMEDIA_YSUBPIXBITS  0
#define __PERMEDIA_YSUBPIXSHIFT 0
#define __PERMEDIA_YSUBPIXMASK  ~0
#endif

/*-----------------------------------------------------*/
#define __PERMEDIA_POS_Z_FIXED_PT_SCALE  2147483647.0    /* 2**31 - 1*/
#define __PERMEDIA_NEG_Z_FIXED_PT_SCALE  1073741824.0    /* 2**30 */

#define __PERMEDIA_POS_Z_FIXED_PT_SCALE_RECIP  (1.0/2147483647.0)   
#define __PERMEDIA_NEG_Z_FIXED_PT_SCALE_RECIP  (1.0/1073741824.0)

#define RGB_MODE         1
#define COLOR_MODE       1 /* 0=BGR, 1=RGB */
#define DITHER_XOFFSET   0
#define DITHER_YOFFSET   0
#define DITHER_ENABLE    __PERMEDIA_ENABLE
#define MS_BIT_MASK             0x80000000l

// Shifts to enable units
// DepthMode
#define __PERMEDIA_DEPTHMODE_ENABLE 0
#define __PERMEDIA_DEPTHMODE_WRITEMASK 1
#define __PERMEDIA_DEPTHMODE_SOURCEDEPTH 2
#define __PERMEDIA_DEPTHMODE_COMPARISON 4

/* sync_mode definitions for the SuspendUntilFramBlank tag */

#define EXT_VIDEO_WAITFOR_FB     0
#define EXT_VIDEO_IMMEDIATE      1
#define VTG_FRAMEROW_WAITFOR_FB  2
#define VTG_FRAMEROW_IMMEDIATE   3

typedef struct PartialProductCode
{
    ULONG   cxDelta;
    ULONG   ulPartialProducts;
}
PPCODE;

extern const PPCODE aPartialProducts[];

#define GET_PPCODE(cxTextureWidth, cxTextureDelta, pp) \
{ \
    int i = (cxTextureWidth + 31) / 32; \
    cxTextureDelta  = aPartialProducts[i].cxDelta; \
    pp              = aPartialProducts[i].ulPartialProducts; \
}

// Color component order
#define INV_COLOR_MODE   0 /* 0=RGB, 1=BGR */


#endif /* _P2DEF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\p2ctxt.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name: p2ctxt.h
*
* Content:    
* Context switching for P2. Used to create and swap contexts in and out.
* The GDI, DDraw and D3D part each have another context.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __p2ctxt__
#define __p2ctxt__

// each time round allocate this many entries
#define CTXT_CHUNK  8

typedef VOID(*PCtxtUserFunc)(PPDev);

// each context consists of a set of tags and the corresponding data. so after
// ntags we have 2*ntags*sizeof(DWORD) bytes of memory.
typedef struct tagP2CtxtData {
    DWORD   dwTag;
    DWORD   dwData;
} P2CtxtData;

typedef struct tagP2CtxtRec {
    BOOL        bInitialized;
    P2CtxtType  dwCtxtType;
    LONG        lNumOfTags;
    ULONG       ulTexelLUTEntries;      // number of registers to save for the Texel LUT context
    ULONG       *pTexelLUTCtxt;         // Texel LUT context array
    PCtxtUserFunc P2UserFunc;
    P2CtxtData   pData[1];
    // more follows in memory
} P2CtxtRec;

typedef struct tagP2CtxtTableRec {
    ULONG      lSize;       // in bytes of the table
    ULONG      lEntries;
    P2CtxtPtr  pEntry[CTXT_CHUNK];
    // more to be allocated in memory if needed
} P2CtxtTableRec, *P2CtxtTablePtr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\p2ctxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name:  p2ctxt.c
*
* Content:      Context switching for Permedia 2. Used to create and swap 
*               contexts in and out.
*               The GDI, DDraw and D3D part each have another context.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "p2ctxt.h"
#include "gdi.h"
#define ALLOC_TAG ALLOC_TAG_XC2P
static DWORD readableRegistersP2[] = {
    __Permedia2TagStartXDom,
    __Permedia2TagdXDom,
    __Permedia2TagStartXSub,
    __Permedia2TagdXSub,
    __Permedia2TagStartY,
    __Permedia2TagdY,               
    __Permedia2TagCount,            
    __Permedia2TagRasterizerMode,   
    __Permedia2TagYLimits,
    __Permedia2TagXLimits,
    __Permedia2TagScissorMode,
    __Permedia2TagScissorMinXY,
    __Permedia2TagScissorMaxXY,
    __Permedia2TagScreenSize,
    __Permedia2TagAreaStippleMode,
    __Permedia2TagWindowOrigin,
    __Permedia2TagAreaStipplePattern0,
    __Permedia2TagAreaStipplePattern1,
    __Permedia2TagAreaStipplePattern2,
    __Permedia2TagAreaStipplePattern3,
    __Permedia2TagAreaStipplePattern4,
    __Permedia2TagAreaStipplePattern5,
    __Permedia2TagAreaStipplePattern6,
    __Permedia2TagAreaStipplePattern7,
    __Permedia2TagTextureAddressMode,
    __Permedia2TagSStart,
    __Permedia2TagdSdx,
    __Permedia2TagdSdyDom,
    __Permedia2TagTStart,
    __Permedia2TagdTdx,
    __Permedia2TagdTdyDom,
    __Permedia2TagQStart,
    __Permedia2TagdQdx,
    __Permedia2TagdQdyDom,
    // texellutindex..transfer are treated seperately
    __Permedia2TagTextureBaseAddress,
    __Permedia2TagTextureMapFormat,
    __Permedia2TagTextureDataFormat,
    __Permedia2TagTexel0,
    __Permedia2TagTextureReadMode,
    __Permedia2TagTexelLUTMode,
    __Permedia2TagTextureColorMode,
    __Permedia2TagFogMode,
    __Permedia2TagFogColor,
    __Permedia2TagFStart,
    __Permedia2TagdFdx,
    __Permedia2TagdFdyDom,
    __Permedia2TagKsStart,
    __Permedia2TagdKsdx,
    __Permedia2TagdKsdyDom,
    __Permedia2TagKdStart,
    __Permedia2TagdKddx,
    __Permedia2TagdKddyDom,
    __Permedia2TagRStart,
    __Permedia2TagdRdx,
    __Permedia2TagdRdyDom,
    __Permedia2TagGStart,
    __Permedia2TagdGdx,
    __Permedia2TagdGdyDom,
    __Permedia2TagBStart,
    __Permedia2TagdBdx,
    __Permedia2TagdBdyDom,
    __Permedia2TagAStart,
    __Permedia2TagColorDDAMode,
    __Permedia2TagConstantColor,
    __Permedia2TagAlphaBlendMode,
    __Permedia2TagDitherMode,
    __Permedia2TagFBSoftwareWriteMask,
    __Permedia2TagLogicalOpMode,
    __Permedia2TagLBReadMode,
    __Permedia2TagLBReadFormat,
    __Permedia2TagLBSourceOffset,
    __Permedia2TagLBWindowBase,
    __Permedia2TagLBWriteMode,
    __Permedia2TagLBWriteFormat,
    __Permedia2TagTextureDownloadOffset,
    __Permedia2TagWindow,
    __Permedia2TagStencilMode,
    __Permedia2TagStencilData,
    __Permedia2TagStencil,
    __Permedia2TagDepthMode,
    __Permedia2TagDepth,
    __Permedia2TagZStartU,
    __Permedia2TagZStartL,
    __Permedia2TagdZdxU,
    __Permedia2TagdZdxL,
    __Permedia2TagdZdyDomU,
    __Permedia2TagdZdyDomL,
    __Permedia2TagFBReadMode,
    __Permedia2TagFBSourceOffset,
    __Permedia2TagFBPixelOffset,
    __Permedia2TagFBWindowBase,
    __Permedia2TagFBWriteMode,
    __Permedia2TagFBHardwareWriteMask,
    __Permedia2TagFBBlockColor,
    __Permedia2TagFBReadPixel,
    __Permedia2TagFilterMode,
    __Permedia2TagStatisticMode,
    __Permedia2TagMinRegion,
    __Permedia2TagMaxRegion,
    __Permedia2TagFBBlockColorU,
    __Permedia2TagFBBlockColorL,
    __Permedia2TagFBSourceBase,
    __Permedia2TagTexelLUT0,
    __Permedia2TagTexelLUT1,
    __Permedia2TagTexelLUT2,
    __Permedia2TagTexelLUT3,
    __Permedia2TagTexelLUT4,
    __Permedia2TagTexelLUT5,
    __Permedia2TagTexelLUT6,
    __Permedia2TagTexelLUT7,
    __Permedia2TagTexelLUT8,
    __Permedia2TagTexelLUT9,
    __Permedia2TagTexelLUT10,
    __Permedia2TagTexelLUT11,
    __Permedia2TagTexelLUT12,
    __Permedia2TagTexelLUT13,
    __Permedia2TagTexelLUT14,
    __Permedia2TagTexelLUT15,

    __Permedia2TagYUVMode,
    __Permedia2TagChromaUpperBound,
    __Permedia2TagChromaLowerBound,
    __Permedia2TagAlphaMapUpperBound,
    __Permedia2TagAlphaMapLowerBound,

    // delta tag values. must be at the end of this array

    // v0/1/2 fixed are not used and for that reason not in the context
    
    __Permedia2TagV0FloatS,
    __Permedia2TagV0FloatT,
    __Permedia2TagV0FloatQ,
    __Permedia2TagV0FloatKs,
    __Permedia2TagV0FloatKd,
    __Permedia2TagV0FloatR,
    __Permedia2TagV0FloatG,
    __Permedia2TagV0FloatB,
    __Permedia2TagV0FloatA,
    __Permedia2TagV0FloatF,
    __Permedia2TagV0FloatX,
    __Permedia2TagV0FloatY,
    __Permedia2TagV0FloatZ,
    
    __Permedia2TagV1FloatS,
    __Permedia2TagV1FloatT,
    __Permedia2TagV1FloatQ,
    __Permedia2TagV1FloatKs,
    __Permedia2TagV1FloatKd,
    __Permedia2TagV1FloatR,
    __Permedia2TagV1FloatG,
    __Permedia2TagV1FloatB,
    __Permedia2TagV1FloatA,
    __Permedia2TagV1FloatF,
    __Permedia2TagV1FloatX,
    __Permedia2TagV1FloatY,
    __Permedia2TagV1FloatZ,
    
    __Permedia2TagV2FloatS,
    __Permedia2TagV2FloatT,
    __Permedia2TagV2FloatQ,
    __Permedia2TagV2FloatKs,
    __Permedia2TagV2FloatKd,
    __Permedia2TagV2FloatR,
    __Permedia2TagV2FloatG,
    __Permedia2TagV2FloatB,
    __Permedia2TagV2FloatA,
    __Permedia2TagV2FloatF,
    __Permedia2TagV2FloatX,
    __Permedia2TagV2FloatY,
    __Permedia2TagV2FloatZ,
    
    __Permedia2TagDeltaMode

};

#define N_READABLE_TAGSP2 (sizeof(readableRegistersP2) / sizeof(readableRegistersP2[0]))

//-----------------------------------------------------------------------------
//
// P2AllocateNewContext:
//
// allocate a new context. If all registers are to be saved in the context then
// pTag is passed as null. 
// ppdev--------ppdev
// pTag---------user can supply list of registers to save and restore on 
//              context switch. NULL defaults to all registers.
//              Holds pointer to user function if dwCtxtType==P2CtxtUserFunc
// lTags--------number of tags in user supplied register list
// dwCtxtType---P2CtxtReadWrite (default) 
//                  on a context switch, all Permedia 2 registers are 
//                  saved and restored.
//              P2CtxtWriteOnly
//                  registers of context will be saved once at the first
//                  context switch. After that they will always be restored
//                  to the state ate the very beginning. This method avoids
//                  readback of registers when switching away from context.
//              P2CtxtUserFunc
//                  User can supply a user function to set context to a known
//                  state, to avoid readback when switching away from context.
//
//-----------------------------------------------------------------------------

P2CtxtPtr
P2AllocateNewContext(PPDev   ppdev,
                     DWORD  *pTag,
                     LONG    lTags,
                     P2CtxtType dwCtxtType
                     )
{
    P2CtxtTablePtr pCtxtTable, pNewCtxtTable;
    P2CtxtPtr      pEntry;
    P2CtxtData    *pData;
    LONG           lEntries;
    LONG           lExtraSize;
    LONG           lSize;
    LONG           lCtxtId;
    PERMEDIA_DECL;
    PERMEDIA_DEFS(ppdev);

    // first time round allocate the context table of pointers. We will
    // grow this table as required.
    //
    if (permediaInfo->ContextTable == NULL)
    {
        DISPDBG((7, "creating context table"));
        lSize = sizeof(P2CtxtTableRec);
        pCtxtTable = (P2CtxtTableRec *)
            ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(P2CtxtTableRec), ALLOC_TAG);

        if (pCtxtTable == NULL)
        {
            DISPDBG((0, "failed to allocate Permedia2 context table. out of memory"));
            return(NULL);
        }
        pCtxtTable->lEntries = CTXT_CHUNK;
        pCtxtTable->lSize = lSize;
        permediaInfo->ContextTable = pCtxtTable;
        permediaInfo->pCurrentCtxt  = NULL;
    }
    
    // find an empty entry in the table
    // I suppose if we have hundreds of contexts this could be a bit slow but then
    // allocating the context isn't time critical, swapping in and out is.
    //

    pCtxtTable = (P2CtxtTablePtr) permediaInfo->ContextTable;
    lEntries = pCtxtTable->lEntries;
    
    for (lCtxtId = 0; lCtxtId < lEntries; ++lCtxtId)
        if(pCtxtTable->pEntry[lCtxtId] == NULL)
            break;

    // if we found no free entries try to grow the table
    if (lCtxtId == lEntries) {
        DISPDBG((1, "context table full so enlarging"));
        lSize = pCtxtTable->lSize + (CTXT_CHUNK * sizeof(P2CtxtPtr));
        pNewCtxtTable = 
            (P2CtxtTablePtr) ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(BYTE)*lSize, ALLOC_TAG);

        if (pNewCtxtTable == NULL) {
            DISPDBG((0, "failed to increase Permedia 2 context table. out of memory"));
            return(NULL);
        }

        // copy the old table to the new one
        RtlCopyMemory(pNewCtxtTable, pCtxtTable, pCtxtTable->lSize);
        pNewCtxtTable->lSize = lSize;
        pNewCtxtTable->lEntries = lEntries + CTXT_CHUNK;
        permediaInfo->ContextTable = (PVOID)pNewCtxtTable;
        
        // first of the newly allocated entries is next free one
        lCtxtId = lEntries;
        
        // free the old context table and reassign some variables
        
        ENGFREEMEM(pCtxtTable);

        pCtxtTable = pNewCtxtTable;
        lEntries = pCtxtTable->lEntries;
    }
    
    // if pTag is passed as null then we are to add all readable registers to the
    // context.
    lExtraSize = 0;
    if (dwCtxtType != P2CtxtUserFunc)
    {
        if (pTag == 0)
        {
            DISPDBG((7, "adding all readable registers to the context"));
            DISPDBG((7, "Using PERMEDIA 2 register set for other context switch"));
            pTag = readableRegistersP2;
            lTags = N_READABLE_TAGSP2;
        }
    } else
    {
        lTags = 1;
    }
    
    // now allocate space for the new entry. We are given the number of tags to save
    // when context switching. Allocate twice this much memory as we have to hold the
    // data values as well.

    DISPDBG((7, "Allocating space for context. lTags = %d", lTags));

    lSize = sizeof(P2CtxtRec) + (lTags-1) * sizeof(P2CtxtData);

    pEntry = (P2CtxtPtr) 
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(BYTE)*(lSize+lExtraSize), ALLOC_TAG);

    if (pEntry == NULL) {
        DISPDBG((0, "out of memory trying to allocate space for new context"));
        return(NULL);
    }

    DISPDBG((7, "Got pEntry 0x%x", pEntry));

    pCtxtTable->pEntry[lCtxtId] = pEntry;

    // allocate enough space for the Texel LUT: 256 entries
    pEntry->dwCtxtType=dwCtxtType;
    pEntry->bInitialized=FALSE;
    pEntry->pTexelLUTCtxt = (PULONG)
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(ULONG)*256, ALLOC_TAG);
    if (pEntry->pTexelLUTCtxt!=0)
    {
        pEntry->ulTexelLUTEntries = 256;
    } else
    {
        pEntry->ulTexelLUTEntries = 0;
    }

    pEntry->lNumOfTags = lTags;
    pEntry->P2UserFunc = NULL;
    pData = pEntry->pData;
   
    if (dwCtxtType != P2CtxtUserFunc)
    {
        // we must initialize the new context to something reasonable. We choose to
        // initialize to the current state of the chip. We can't leave it uninitialized
        // since the first thing the caller will do when he wants to draw is validate
        // the new context which will load junk into the chip. At some point we
        // should define a reasonable starting context which would mean we wouldn't
        // have to do this readback.
    
        // copy the tags and read the data back from the chip. We don't sync since we are
        // only initialising the context to something reasonable. i.e. we don't care if
        // the FIFO is still draining while we do this.

        DISPDBG((7, "Reading current chip context back"));
        while (--lTags >= 0) {
            pData->dwTag = *pTag++;
            READ_PERMEDIA_FIFO_REG(pData->dwTag, pData->dwData);
            ++pData;
        }
    
        // save the texel LUT
        if(pEntry->ulTexelLUTEntries && 
           pEntry->pTexelLUTCtxt!=NULL)
        {
            ULONG *pul;
            INT   i=0;

            lEntries = pEntry->ulTexelLUTEntries;
            pul = pEntry->pTexelLUTCtxt;

            //special mechanism: reset readback index to 0
            READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTIndex, i); 

            for(i = 0; i < lEntries; ++i, ++pul)
            {
                READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTData, *pul);
            }
        }
        
    } else
    {
        pEntry->P2UserFunc = (PCtxtUserFunc) pTag;
    }

    DISPDBG((1, "Allocated context %lx", pEntry));

    return(pEntry);
}   // P2AllocateNewContext


//-----------------------------------------------------------------------------
//
//  P2FreeContext:
//
//  free a previously allocated context.
//
//-----------------------------------------------------------------------------

VOID
P2FreeContext(  PPDev       ppdev,
                P2CtxtPtr   pEntry)
{
    PERMEDIA_DECL;
    P2CtxtTablePtr pCtxtTable;
    ULONG          lCtxtId;
    
    pCtxtTable = (P2CtxtTablePtr) permediaInfo->ContextTable;

    for (lCtxtId = 0; lCtxtId < pCtxtTable->lEntries; ++lCtxtId)
        if(pCtxtTable->pEntry[lCtxtId] == pEntry)
            break;

    ASSERTDD(lCtxtId != pCtxtTable->lEntries, "P2FreeContext: context not found");
    
    // free LUT Table
    if(pEntry->pTexelLUTCtxt)
    {
        ENGFREEMEM( pEntry->pTexelLUTCtxt);
    }
    
    ENGFREEMEM( pEntry);

    pCtxtTable->pEntry[lCtxtId] = NULL;

    // if this was the current context, mark the current context as invalid so we
    // force a reload next time.

    if (permediaInfo->pCurrentCtxt == pEntry)
    {
        permediaInfo->pCurrentCtxt = NULL;
    }

    DISPDBG((1, "Released context %lx", pEntry));
}

//-----------------------------------------------------------------------------
//
//  VOID P2SwitchContext:
//
//  load a new context into the hardware. We assume that this call is
//  protected by a test that the given context is not the current one - 
//  hence the assertion. 
//  The code would work but the driver should never try to load an already 
//  loaded context so we trap it as an error.
//
//-----------------------------------------------------------------------------

VOID
P2SwitchContext(
                    PPDev        ppdev,
                    P2CtxtPtr    pEntry)
{
    P2CtxtTablePtr  pCtxtTable;
    P2CtxtData     *pData;
    P2CtxtPtr       pOldCtxt;
    LONG            lTags;
    LONG            i;
    ULONG          *pul;
    LONG            lEntries;
    PERMEDIA_DECL;
    PERMEDIA_DEFS(ppdev);
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    EngAcquireSemaphore(ppdev->hsemLock);
    ASSERTDD(ppdev->ulLockCount, "P2SwitchContext: ulLockCount = 0\n Context could change as caller is NOT protected!");
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    pCtxtTable = (P2CtxtTablePtr)permediaInfo->ContextTable;
    ASSERTDD(pCtxtTable, "Can't perform context switch: no contexts have been created!");
    
    pOldCtxt = permediaInfo->pCurrentCtxt;
    
    DISPDBG((3, "swapping from context %d to context %d", pOldCtxt, pEntry));
    
    if(pOldCtxt == permediaInfo->pGDICtxt)
    {
        DISPDBG((6, "Switching from GDI context"));

        ASSERTDD(ppdev->bNeedSync || 
                (ppdev->pulInFifoPtr == ppdev->pulInFifoStart),
                "P2SwitchContext: bNeedSync flag is wrong");

        InputBufferSync(ppdev);

        ppdev->bGdiContext = FALSE;
        ppdev->pP2dma->bEnabled = TRUE;

    }

    // for each register in the old context, read it back
    if (pOldCtxt != NULL) {

        //
        // P2CtxtWriteOnly will only be readback once after context initialization
        //
        if ((pOldCtxt->dwCtxtType==P2CtxtReadWrite) ||
            (pOldCtxt->dwCtxtType==P2CtxtWriteOnly && !pOldCtxt->bInitialized)
           )
        {
            // sync with the chip before reading back the current state. The flag
            // is used to control context manipulation on lockup recovery.

            SYNC_WITH_PERMEDIA;

            pData = pOldCtxt->pData;
            lTags = pOldCtxt->lNumOfTags;
            while (--lTags >= 0) {
                READ_PERMEDIA_FIFO_REG(pData->dwTag, pData->dwData);
                ++pData;
            }
        
            // save the texel LUT
            if(pOldCtxt->ulTexelLUTEntries &&
               pOldCtxt->pTexelLUTCtxt!=NULL)
            {
                lEntries = pOldCtxt->ulTexelLUTEntries;
                pul = pOldCtxt->pTexelLUTCtxt;

                //special mechanism: reset readback index to 0
                READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTIndex, i); 
            
                for(i = 0; i < lEntries; ++i, ++pul)
                {
                    READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTData, *pul);
                }
            }

            pOldCtxt->bInitialized=TRUE;
        }
    }
    
    // load the new context. We allow -1 to be passed so that we can force a
    // save of the current context and force the current context to be
    // undefined.
    //
    if (pEntry != NULL)
    {

        if (pEntry->dwCtxtType==P2CtxtUserFunc)
        {
            ASSERTDD(pEntry->P2UserFunc!=NULL,"supplied user function not initialized");
            (*pEntry->P2UserFunc)(ppdev);
        } else
        if (pEntry->dwCtxtType==P2CtxtWriteOnly ||
            pEntry->dwCtxtType==P2CtxtReadWrite)
        {
            lTags = pEntry->lNumOfTags;
            pData = pEntry->pData;
        
            while (lTags > 0) {
                lEntries = MAX_P2_FIFO_ENTRIES;
                lTags -= lEntries;
                if (lTags < 0)
                    lEntries += lTags;
                RESERVEDMAPTR(lEntries);
                while (--lEntries >= 0) {
                    LD_INPUT_FIFO(pData->dwTag, pData->dwData);
                    DISPDBG((20, "loading tag 0x%x, data 0x%x", pData->dwTag, pData->dwData));
                    ++pData;
                }
                COMMITDMAPTR();
            }
        
            // restore the texel LUT
            if(pEntry->ulTexelLUTEntries &&
               pEntry->pTexelLUTCtxt!=NULL )
            {
                lEntries = pEntry->ulTexelLUTEntries;
                pul = pEntry->pTexelLUTCtxt;
            
                RESERVEDMAPTR(lEntries+1);
                LD_INPUT_FIFO(__Permedia2TagTexelLUTIndex, 0);
            
                for(i = 0; i < lEntries; ++i, ++pul)
                {
                    LD_INPUT_FIFO(__Permedia2TagTexelLUTData, *pul);
                }
                COMMITDMAPTR();   
                FLUSHDMA();
            }

        } else
        {
            ASSERTDD( FALSE, "undefined state for entry in context table");
        }
    }

    if(pEntry == permediaInfo->pGDICtxt)
    {
        DISPDBG((6, "Switching to GDI context"));

        // 
        //  we have to do a full sync here, because GDI and DDraw
        //  share the same DMA buffer. To make sure nothing will be 
        //  overridden, we do a complete sync
        //
        SYNC_WITH_PERMEDIA;

        //
        // Turn off permedia interrupt handler
        //

        WRITE_CTRL_REG( PREG_INTENABLE, 0);

        ppdev->bGdiContext = TRUE;
        ppdev->pP2dma->bEnabled = FALSE;
    
        // invalidate the mono brush cache entry
        // stipple unit was restored to default values

        ppdev->abeMono.prbVerify = NULL;

    }
    
    DISPDBG((6, "context %lx now current", pEntry));
    permediaInfo->pCurrentCtxt = pEntry;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\p2rd.h ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: p2rd.h
 *
 * This module contains constants for the P2 internal Ramdac
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
//
// 3Dlabs P2RD RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _p2rd_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;
} P2RDRAMDAC, *pP2RDRAMDAC;

//
// structure containing the mapped addresses for each of the P2RD registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _p2rd_data
{
    //
    // Register addresses
    //
    ULONG_PTR   RDPaletteWriteAddress;
    ULONG_PTR   RDPaletteData;
    ULONG_PTR   RDPixelMask;
    ULONG_PTR   RDPaletteAddressRead;
    ULONG_PTR   RDIndexLow;
    ULONG_PTR   RDIndexHigh;
    ULONG_PTR   RDIndexedData;
    ULONG_PTR   RDIndexControl;

    //
    // RAMDAC state info
    //
    ULONG       cursorModeOff;      // cursor disabled
    ULONG       cursorModeCurrent;  // disabled 32/64 mode cursor 
    ULONG       cursorControl;      // x & y zoom, etc.
    ULONG       cursorSize;         // see P2RD_CURSOR_SIZE_*
    ULONG       x, y;
} P2RDData, *pP2RDData;

//
// Macro declared by any function wishing to use the P2ST internal RAMDAC .
// MUST be declared after PERMEDIA_DECL.
//
#define P2RD_DECL_VARS pP2RDData pP2RDinfo
#define P2RD_DECL_INIT pP2RDinfo = (pP2RDData)ppdev->pvPointerData

#define P2RD_DECL \
            P2RD_DECL_VARS; \
            P2RD_DECL_INIT

//
// use the following macros as the address to pass to the
// WRITE_P2RDREG_ULONG function
//
//  Palette Access
#define P2RD_PAL_WR_ADDR            (pP2RDinfo->RDPaletteWriteAddress)
#define P2RD_PAL_RD_ADDR            (pP2RDinfo->RDPaletteAddressRead)
#define P2RD_PAL_DATA               (pP2RDinfo->RDPaletteData)

// Pixel mask
#define P2RD_PIXEL_MASK             (pP2RDinfo->RDPixelMask)

// Access to the indexed registers
#define P2RD_INDEX_ADDR_LO          (pP2RDinfo->RDIndexLow)
#define P2RD_INDEX_ADDR_HI          (pP2RDinfo->RDIndexHigh)
#define P2RD_INDEX_DATA             (pP2RDinfo->RDIndexedData)
#define P2RD_INDEX_CONTROL          (pP2RDinfo->RDIndexControl)


// Bit field definitions for the direct access registers
#define P2RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// Indexed register definitions accessed via P2RD_LOAD_INDEX_REG() and
// P2RD_READ_INDEX_REG()
#define P2RD_MISC_CONTROL               0x0000
#define P2RD_SYNC_CONTROL               0x0001
#define P2RD_DAC_CONTROL                0x0002
#define P2RD_PIXEL_SIZE                 0x0003
#define P2RD_COLOR_FORMAT               0x0004
#define P2RD_CURSOR_MODE                0x0005
#define P2RD_CURSOR_CONTROL             0x0006
#define P2RD_CURSOR_X_LOW               0x0007
#define P2RD_CURSOR_X_HIGH              0x0008
#define P2RD_CURSOR_Y_LOW               0x0009
#define P2RD_CURSOR_Y_HIGH              0x000a
#define P2RD_CURSOR_HOTSPOT_X           0x000b
#define P2RD_CURSOR_HOTSPOT_Y           0x000c
#define P2RD_OVERLAY_KEY                0x000d
#define P2RD_PAN                        0x000e
#define P2RD_SENSE                      0x000f
#define P2RD_CHECK_CONTROL              0x0018
#define P2RD_CHECK_PIXEL_RED            0x0019
#define P2RD_CHECK_PIXEL_GREEN          0x001a
#define P2RD_CHECK_PIXEL_BLUE           0x001b
#define P2RD_CHECK_LUT_RED              0x001c
#define P2RD_CHECK_LUT_GREEN            0x001d
#define P2RD_CHECK_LUT_BLUE             0x001e
#define P2RD_DCLK_SETUP_1               0x01f0
#define P2RD_DCLK_SETUP_2               0x01f1
#define P2RD_MCLK_SETUP_1               0x01f2
#define P2RD_MCLK_SETUP_2               0x01f3
#define P2RD_DCLK_CONTROL               0x0200
#define P2RD_DCLK0_PRE_SCALE            0x0201
#define P2RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P2RD_DCLK0_POST_SCALE           0x0203
#define P2RD_DCLK1_PRE_SCALE            0x0204
#define P2RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P2RD_DCLK1_POST_SCALE           0x0206
#define P2RD_DCLK2_PRE_SCALE            0x0207
#define P2RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P2RD_DCLK2_POST_SCALE           0x0209
#define P2RD_DCLK3_PRE_SCALE            0x020a
#define P2RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P2RD_DCLK3_POST_SCALE           0x020c
#define P2RD_MCLK_CONTROL               0x020d
#define P2RD_MCLK_PRE_SCALE             0x020e
#define P2RD_MCLK_FEEDBACK_SCALE        0x020f
#define P2RD_MCLK_POST_SCALE            0x0210
#define P2RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P2RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P2RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P2RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00

#define P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P2RD_PIXEL_SIZE_8BPP            0x00
#define P2RD_PIXEL_SIZE_16BPP           0x01
#define P2RD_PIXEL_SIZE_24_BPP          0x04
#define P2RD_PIXEL_SIZE_32BPP           0x02

#define P2RD_COLOR_FORMAT_CI8           0x0e
#define P2RD_COLOR_FORMAT_8BPP          0x05
#define P2RD_COLOR_FORMAT_15BPP         0x01
#define P2RD_COLOR_FORMAT_16BPP         0x10
#define P2RD_COLOR_FORMAT_32BPP         0x00
#define P2RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P2RD_CURSOR_MODE_REVERSE        0x40
#define P2RD_CURSOR_MODE_WINDOWS        0x00
#define P2RD_CURSOR_MODE_X              0x10
#define P2RD_CURSOR_MODE_3COLOR         0x20
#define P2RD_CURSOR_MODE_15COLOR        0x30
#define P2RD_CURSOR_MODE_64x64          0x00
#define P2RD_CURSOR_MODE_P0_32x32x2     0x02
#define P2RD_CURSOR_MODE_P1_32x32x2     0x04
#define P2RD_CURSOR_MODE_P2_32x32x2     0x06
#define P2RD_CURSOR_MODE_P3_32x32x2     0x08
#define P2RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P2RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P2RD_CURSOR_MODE_ENABLED        0x01

#define P2RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P2RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P2RD_CURSOR_CONTROL_DOUBLE_X        0x01

#define P2RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_DCLK_CONTROL_ENABLED   0x01

#define P2RD_MCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_MCLK_CONTROL_ENABLED   0x01

#define P2RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}

#define P2RD_SYNC_WITH_PERMEDIA

//
// generic read/write routines for P2RD registers
//

#define WRITE_P2RDREG_ULONG(r, d) \
{ \
    WRITE_REGISTER_ULONG((PULONG)(r), d); \
    MEMORY_BARRIER(); \
}

#define READ_P2RDREG_ULONG(r)    READ_REGISTER_ULONG((PULONG)(r))

//
// Macro to load a given data value into an internal P2RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P2RD_INDEX_REG(index) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
}

#define P2RD_LOAD_DATA(data) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

#define P2RD_LOAD_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

#define P2RD_READ_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    data = READ_P2RDREG_ULONG(P2RD_INDEX_DATA) & 0xff;   \
}

#define P2RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_LO, (ULONG)(index));  \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA,    (ULONG)(data));   \
}

//
// Macros to load a given RGB triple into the P2RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P2RD_PALETTE_START and multiple P2RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P2RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P2RD_PALETTE_START_WR(index) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_WR_ADDR,     (ULONG)(index));    \
}

#define P2RD_PALETTE_START_RD(index) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_RD_ADDR,     (ULONG)(index));    \
}

#define P2RD_LOAD_PALETTE(red, green, blue) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(red));      \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(green));    \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(blue));     \
}

#define P2RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_WR_ADDR, (ULONG)(index));    \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(red));      \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(green));    \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(blue));     \
}

//
// Macro to read back a given RGB triple from the P2RD palette. Use after
// a call to P2RD_PALETTE_START_RD
//
#define P2RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_P2RDREG_ULONG(P2RD_PAL_DATA) & 0xff);        \
    green = (UCHAR)(READ_P2RDREG_ULONG(P2RD_PAL_DATA) & 0xff);        \
    blue  = (UCHAR)(READ_P2RDREG_ULONG(P2RD_PAL_DATA) & 0xff);        \
}

//
// Macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P2RD_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PIXEL_MASK,  (ULONG)(mask)); \
}

#define P2RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = READ_P2RDREG_ULONG(P2RD_PIXEL_MASK) & 0xff; \
}

//
// Windows format byte-packed cursor data: each byte represents 4 consecutive
// pixels
//
#define P2RD_CURSOR_2_COLOR_BLACK           0x00
#define P2RD_CURSOR_2_COLOR_WHITE           0x55
#define P2RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P2RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF
#define P2RD_CURSOR_3_COLOR_TRANSPARENT     0x00
#define P2RD_CURSOR_15_COLOR_TRANSPARENT    0x00

//
// Macros to load values into the cursor array usage is
// P2RD_CURSOR_ARRAR_START() followed by n iterations of P2RD_LOAD_CURSOR_ARRAY()
// or P2RD_READ_CURSOR_ARRAY()
//
#define P2RD_CURSOR_ARRAY_START(offset) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_LO,(ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) & 0xff));\
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) >> 8));    \
}

#define P2RD_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA, (ULONG)(data)); \
}

#define P2RD_READ_CURSOR_ARRAY(data) \
{ \
    data = READ_P2RDREG_ULONG(P2RD_INDEX_DATA) & 0xff; \
}

// macro to move the cursor
//
#define P2RD_MOVE_CURSOR(x, y) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI, (ULONG)0);              \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P2RD_CURSOR_HOTSPOT(x, y) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
    
// cursor sizes
#define P2RD_CURSOR_SIZE_64_MONO    0
#define P2RD_CURSOR_SIZE_32_MONO    1
#define P2RD_CURSOR_SIZE_64_3COLOR  0 
#define P2RD_CURSOR_SIZE_32_3COLOR  1
#define P2RD_CURSOR_SIZE_32_15COLOR 5

#define P2RD_CURSOR_SEL(cursorSize, cursorIndex) (((cursorSize + cursorIndex) & 7) << 1)

//
// exported functions from pointer.c. Anything which is P2RD specific goes
// in this file as well as real pointer stuff.
//
extern BOOL  bP2RDCheckCSBuffering(PPDev);
extern BOOL  bP2RDSwapCSBuffers(PPDev, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\palette.c ===
/******************************Module*Header***********************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/

#include "precomp.h"
#include <math.h>
#define ALLOC_TAG ALLOC_TAG_AP2P
// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};



//-----------------------------------------------------------------------------
// BOOL bInitializePalette
//
// Initializes default palette for PDEV.
//
//-----------------------------------------------------------------------------
BOOL
bInitializePalette(PDev*    ppdev,
                   DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    ULONG           ulMask;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    DBG_GDI((7, "bInitializePalette"));

    if ( ppdev->iBitmapFormat == BMF_8BPP )
    {
        //
        // Allocate our palette:
        //

        ppal = (PALETTEENTRY*)ENGALLOCMEM(FL_ZERO_MEMORY,
                                          sizeof(PALETTEENTRY) * 256,
                                          ALLOC_TAG);

        if (ppal == NULL)
        {
            goto ReturnFalse;
        }

        ppdev->pPal = ppal;

        //
        // Generate 256 (8*8*4) RGB combinations to fill the palette
        //

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;
        
        for ( ulLoop = 256; ulLoop != 0; --ulLoop )
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        //
        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.
        //
        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            //
            // First 10
            //
            ppal[ulLoop]       = gapalBase[ulLoop];

            //
            // Last 10
            //
            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        //
        // Create handle for palette.
        //
        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*)ppal, 0, 0, 0);
    }
    else
    {              
        DBG_GDI((7, "creating True Color palette, masks rgb = 0x%x, 0x%x,0x%x",
                 ppdev->flRed, ppdev->flGreen, ppdev->flBlue));

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if ( hpal == 0 )
    {
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:
    DBG_GDI((0, "Failed bInitializePalette"));
    return(FALSE);

}// bInitializePalette()

//-----------------------------------------------------------------------------
// VOID vUninitializePalette
//
// Frees resources allocated by bInitializePalette.
//
// Note: In an error case, this may be called before bInitializePalette.
//
//-----------------------------------------------------------------------------

VOID vUninitializePalette(PDev* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        ENGFREEMEM(ppdev->pPal);
}

//-----------------------------------------------------------------------------
// BOOL bEnablePalette
//
// Initialize the hardware's 8bpp palette registers.
//
//-----------------------------------------------------------------------------

BOOL bEnablePalette(PDev* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       ulMask;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

//@@BEGIN_DDKSPLIT
#pragma prefast(suppress: 203, "pScreenClut points to sufficient ajClutSpace (PREfast bug 611168)")
//@@END_DDKSPLIT
        RtlCopyMemory(pScreenClut->LookupTable, ppdev->pPal,
                      sizeof(ULONG) * 256);

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DBG_GDI((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DBG_GDI((1, "Passed bEnablePalette"));

    return(TRUE);
}

//-----------------------------------------------------------------------------
// BOOL DrvSetPalette
//
// DDI entry point for manipulating the palette.
//
//-----------------------------------------------------------------------------

BOOL DrvSetPalette(
    DHPDEV  dhpdev,
    PALOBJ* ppalo,
    FLONG   fl,
    ULONG   iStart,
    ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDev*           ppdev;
    ULONG           ulMask;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDev*) dhpdev;

    DBG_GDI((3, "DrvSetPalette called"));

    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;    
    if (ulMask != 0)
    {
        DBG_GDI((1, "DrvSetPalette: trying to set true color palette"));
        return FALSE;
    }

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DBG_GDI((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

    while(cColors--)
        pScreenClutData[cColors].Unused = 0;

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         (PVOID)pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DBG_GDI((0, "DrvSetPalette failed DeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

//-----------------------------------------------------------------------------
// BOOL bInstallGammaLUT
//
// Load a given gamma LUT into the RAMDAC and also save it in the registry.
//
//-----------------------------------------------------------------------------

BOOL
bInstallGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut)
{
    ULONG ulReturnedDataLength;
    BOOL bRet;
    PERMEDIA_DECL;

    // only do this for 16 or 32 bpp.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == P2DEPTH8))
        return FALSE;

    if (pScreenClut->NumEntries == 0)
    {
        DBG_GDI((1, "bInstallGammaLUT: Empty LUT"));
        return TRUE;
    }

    // Set palette registers.

    bRet = !EngDeviceIoControl(
                        ppdev->hDriver,
                        IOCTL_VIDEO_SET_COLOR_REGISTERS,
                        pScreenClut,
                        MAX_CLUT_SIZE,
                        NULL,
                        0,
                        &ulReturnedDataLength);
    // if we succeeded save the ramp in the registry and locally
    if (bRet)
        bRegistrySaveGammaLUT(ppdev, pScreenClut);

    return(bRet);
}        

//-----------------------------------------------------------------------------
// VOID vSetNewGammaValue
//
// Loads up a true color palette with the specified gamma correction factor.
// This is straightforward for 24 bit true color. For 15 and 16 bpp we rely
// on the miniport having enabled the palette for sparse lookup. i.e. each
// 5 or 6 bit component is shifted left to create an 8 bit component before
// the lookup.
//
// Note: the display driver shouldn't really do anything with floats or
// doubles. I restrict their use to this function which is why the gamma
// value is presented as a 16.16 fixed point number. And this function must
// be called only from within an OPELGL escape. On NT 4 FP regs are saved
// and restored for OGL escapes only.
//
//-----------------------------------------------------------------------------

VOID
vSetNewGammaValue(PPDev ppdev, ULONG ulgv)
{
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       i;
    UCHAR       gc;
    double      gv;
    double      dcol;
    PERMEDIA_DECL;

    // gamma can't be zero or we blow up
    if (ulgv == 0)
    {
        DBG_GDI((1, "can't use gamma value of zero"));
        return;
    }

    // only do this for 16 or 32 bpp.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == P2DEPTH8))
        return;

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = 256;
    pScreenClut->FirstEntry = 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    //
    // special case gamma of 1.0 so we can load the LUT at startup without
    // needing any floating point calculations.
    //
    if (ulgv == 0x10000)
    {
        for (i = 0; i < 256; ++i)
        {
            pScreenClutData[i].Red    = (UCHAR)i;
            pScreenClutData[i].Green  = (UCHAR)i;
            pScreenClutData[i].Blue   = (UCHAR)i;
            pScreenClutData[i].Unused = 0;
        }
    }
    else
    {
        // pre-work out 1/gamma
        gv = (double)(ulgv >> 16) + (double)(ulgv & 0xffff) / 65536.0;
        gv = 1.0 / gv;

        for (i = 0; i < 256; ++i)
        {
            dcol = (double)i;
            gc = (UCHAR)(255.0 * pow((dcol/255.0), gv));

            pScreenClutData[i].Red    = gc;
            pScreenClutData[i].Green  = gc;
            pScreenClutData[i].Blue   = gc;
            pScreenClutData[i].Unused = 0;
        }
    }

    if (bInstallGammaLUT(ppdev, pScreenClut))
        RtlCopyMemory(&permediaInfo->gammaLUT, pScreenClut, MAX_CLUT_SIZE);
}

//-----------------------------------------------------------------------------
// BOOL DrvIcmSetDeviceGammaRamp
//
//@@BEGIN_DDKSPLIT
// TODO: provide description.
//@@END_DDKSPLIT
//
//-----------------------------------------------------------------------------

BOOL DrvIcmSetDeviceGammaRamp(
   DHPDEV dhpdev,
   ULONG iFormat,
   LPVOID lpRamp
   )
{
    PPDev           ppdev = (PPDev) dhpdev;
    GAMMARAMP *     pramp = (GAMMARAMP *) lpRamp;
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    ULONG           i;
    ULONG           ulReturnedDataLength;
    BOOL            bRet;
    PERMEDIA_DECL;

    DBG_GDI((3, "DrvIcmSetDeviceGammaRamp called"));

    if(iFormat != IGRF_RGB_256WORDS)
        return FALSE;


    // only do this for 16 or 32 bpp. Not 15/16 for RGB640.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == P2DEPTH8)) 
        return FALSE;

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = 256;
    pScreenClut->FirstEntry = 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));
   
    for (i = 0; i < 256; ++i)
    {
        pScreenClutData[i].Red    = (UCHAR)(pramp->Red[i] >> 8);
        pScreenClutData[i].Green  = (UCHAR)(pramp->Green[i] >> 8);
        pScreenClutData[i].Blue   = (UCHAR)(pramp->Blue[i] >> 8);
        pScreenClutData[i].Unused = 0;
   }
     
    bRet = !EngDeviceIoControl(
                        ppdev->hDriver,
                        IOCTL_VIDEO_SET_COLOR_REGISTERS,
                        pScreenClut,
                        MAX_CLUT_SIZE,
                        NULL,
                        0,
                        &ulReturnedDataLength);

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\p2regs.h ===
/******************************Module*Header**********************************\
*
*
* Module Name: p2regs.h
*
* Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef P2REG_H
#define P2REG_H

#if (defined(_MSDOS)/* mr || defined(__cplusplus)*/)
typedef unsigned long unsigned32;
typedef signed long   signed32;
#else
typedef unsigned int unsigned32;
typedef signed int   signed32;
#endif

typedef unsigned short unsigned16;
typedef signed short   signed16;

typedef unsigned char unsigned8;
typedef signed char   signed8;

typedef long __Permedia2SignedIntegerFmat;
typedef unsigned32 __Permedia2UnsignedIntegerFmat;

/*
** Generic signed 16 + signed 16 format
*/

#if BIG_ENDIAN == 1 
typedef struct {
  signed32 hi:             16;
  signed32 lo:             16;
} __Permedia2S16S16Fmat;
#else
typedef struct {
  signed32 lo:             16;
  signed32 hi:             16;
} __Permedia2S16S16Fmat;
#endif 

/*
** Delta Registers
*/

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      13;
  unsigned32 ColorOrder:                1;
  unsigned32 BackfaceCull:              1;
  unsigned32 FillDirection:             1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 ClampEnable:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 DiamondExit:               1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DepthEnable:               1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 DepthFormat:               2;
  unsigned32 TargetChip:                2;
} __Permedia2DeltaModeFmat;
#else
typedef struct {
  unsigned32 TargetChip:                2;
  unsigned32 DepthFormat:               2;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 DepthEnable:               1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiamondExit:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 ClampEnable:               1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 FillDirection:             1;
  unsigned32 BackfaceCull:              1;
  unsigned32 ColorOrder:                1;
  unsigned32 pad:                      13;
} __Permedia2DeltaModeFmat;
#endif

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad2:                     11;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad1:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad0:                      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 CoverageEnable:            1;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 UsePointTable:             1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 AntialiasEnable:           1;
  unsigned32 PrimitiveType:             2;
  unsigned32 reserved:                  2;
  unsigned32 FastFillEnable:            1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 AreaStippleEnable:         1;
} __Permedia2DeltaDrawFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:         1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 FastFillEnable:            1;
  unsigned32 reserved:                  2;
  unsigned32 PrimitiveType:             2;
  unsigned32 AntialiasEnable:           1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 UsePointTable:             1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 CoverageEnable:            1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 pad0:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad1:                      1;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad2:                     11;
} __Permedia2DeltaDrawFmat;
#endif

#ifdef BIG_ENDIAN
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 pad:                     8;
    unsigned32 Val:                    24; /* 2.22s */
  } K;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.30us */
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.31us */
  } Z;
} __Permedia2DeltaFixedFmat;
#else 
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 Val:                    24; /* 2.22s */
    unsigned32 pad:                     8;
  } K;
  struct {
    unsigned32 Val:                    31; /* 1.30us */
    unsigned32 pad:                     1;
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 Val:                    31; /* 1.31us */
    unsigned32 pad:                     1;
  } Z;
} __Permedia2DeltaFixedFmat;
#endif

#define N_P2_DELTA_BROADCAST_MASK_BITS 4 

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      32 - N_P2_DELTA_BROADCAST_MASK_BITS;
  unsigned32 Mask:	               N_P2_DELTA_BROADCAST_MASK_BITS ;
} __Permedia2DeltaBroadcastMaskFmat;
#else
typedef struct {
  unsigned32 Mask:                     N_P2_DELTA_BROADCAST_MASK_BITS ;
  unsigned32 pad:                      32 - N_P2_DELTA_BROADCAST_MASK_BITS ;
} __Permedia2DeltaBroadcastMaskFmat;
#endif

/*
** Permedia 2 Host In Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Mask:         16;
  unsigned32 Mode:          2;
  unsigned32 pad0:          5;
  unsigned32 MajorGroup:    5;
  unsigned32 Offset:        4;
} __Permedia2DMADataFmat;
#else
typedef struct {
  unsigned32 Offset:        4;
  unsigned32 MajorGroup:    5;
  unsigned32 pad0:          5;
  unsigned32 Mode:          2;
  unsigned32 Mask:         16;
} __Permedia2DMADataFmat;
#endif

/*
**  Permedia 2 Rasterizer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __Permedia2StartXDomFmat,
  __Permedia2dXDomFmat,
  __Permedia2StartXSubFmat,
  __Permedia2dXSubFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __Permedia2StartXDomFmat,
  __Permedia2dXDomFmat,
  __Permedia2StartXSubFmat,
  __Permedia2dXSubFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __Permedia2StartYFmat,
  __Permedia2dYFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __Permedia2StartYFmat,
  __Permedia2dYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         20;
  unsigned32 Val:          12;
} __Permedia2CountFmat,
  __Permedia2ContinueNewLineFmat,
  __Permedia2ContinueNewDomFmat,
  __Permedia2ContinueNewSubFmat,
  __Permedia2ContinueFmat;
#else
typedef struct {
  unsigned32 Val:          12;
  unsigned32 pad0:         20;
} __Permedia2CountFmat,
  __Permedia2ContinueNewLineFmat,
  __Permedia2ContinueNewDomFmat,
  __Permedia2ContinueNewSubFmat,
  __Permedia2ContinueFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad5:                     9;
  unsigned32 IncreaseY:                1;
  unsigned32 IncreaseX:                1;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 pad4:                     2;
  unsigned32 ReuseBitMask:             1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 pad3:                     1;
  unsigned32 FogEnable:                1;
  unsigned32 TextureEnable:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 pad2:                     3;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad1:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad0:                     2;
  unsigned32 AreaStippleEnable:        1;
} __Permedia2RenderFmat,
  __Permedia2PrepareToRenderFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:        1;
  unsigned32 pad0:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad1:                     2;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad2:                     3;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 TextureEnable:            1;
  unsigned32 FogEnable:                1;
  unsigned32 pad3:                     1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 ReuseBitMask:             1;
  unsigned32 pad4:                     2;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 IncreaseX:                1;
  unsigned32 IncreaseY:                1;
  unsigned32 pad5:                     9;
} __Permedia2RenderFmat,
  __Permedia2PrepareToRenderFmat;
#endif 

typedef __Permedia2UnsignedIntegerFmat __Permedia2BitMaskPatternFmat;

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad1:                12;
  unsigned32 BitMaskRelative:      1;
  unsigned32 LimitsEnable:         1;
  unsigned32 pad0:                 1;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 BitMaskOffset:        5;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BiasCoordinates:      2;
  unsigned32 FractionAdjust:       2;
  unsigned32 InvertBitMask:        1;
  unsigned32 MirrorBitMask:        1;
} __Permedia2RasterizerModeFmat;
#else
typedef struct {
  unsigned32 MirrorBitMask:        1;
  unsigned32 InvertBitMask:        1;
  unsigned32 FractionAdjust:       2;
  unsigned32 BiasCoordinates:      2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskOffset:        5;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 pad0:                 1;
  unsigned32 LimitsEnable:         1;
  unsigned32 BitMaskRelative:      1;
  unsigned32 pad1:                12;
} __Permedia2RasterizerModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Max:             12;
  unsigned32 pad0:           4;
  signed32 Min:             12;
} __Permedia2YLimitsFmat, __Permedia2XLimitsFmat;
#else
typedef struct {
  signed32 Min:             12;
  unsigned32 pad0:           4;
  signed32 Max:             12;
  unsigned32 pad1:           4;
} __Permedia2YLimitsFmat, __Permedia2XLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2StepFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2StepFmat;
#endif

typedef __Permedia2StepFmat __Permedia2ActiveStepXFmat;
typedef __Permedia2StepFmat __Permedia2ActiveStepYDomEdgeFmat;
typedef __Permedia2StepFmat __Permedia2PassiveStepXFmat;
typedef __Permedia2StepFmat __Permedia2PassiveStepYDomEdgeFmat;
typedef __Permedia2StepFmat __Permedia2FastBlockFillFmat;
typedef __Permedia2StepFmat __Permedia2RectangleOriginFmat;
typedef __Permedia2StepFmat __Permedia2RectangleSizeFmat;
typedef __Permedia2StepFmat __Permedia2FBSourceDeltaFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __Permedia2UnsignedStepFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __Permedia2UnsignedStepFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 XRight:         12;
  unsigned32 pad0:          4;
  signed32 XLeft:          12;
} __Permedia2FastBlockLimitsFmat;
#else
typedef struct {
  signed32 XLeft:          12;
  unsigned32 pad0:          4;
  signed32 XRight:         12;
  unsigned32 pad1:          4;
} __Permedia2FastBlockLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          27;
  unsigned32 Sign:           1;
  unsigned32 Magnitude:      4;
} __Permedia2SubPixelCorrectionFmat;
#else
typedef struct {
  unsigned32 Magnitude:      4;
  unsigned32 Sign:           1;
  unsigned32 pad0:          27;
} __Permedia2SubPixelCorrectionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 RelativeOffset:  3;
  unsigned32 pad1:          1;
  signed32 XStart:         12;
  unsigned32 pad0:          4;
  signed32 XEnd:           12;
} __Permedia2PackedDataLimitsFmat;
#else
typedef struct {
  signed32 XEnd:           12;
  unsigned32 pad0:          4;
  signed32 XStart:         12;
  unsigned32 pad1:          1;
  signed32 RelativeOffset:  3;
} __Permedia2PackedDataLimitsFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2SpanMaskFmat;

/*
**  Permedia 2 Scissor and Stipple Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                30;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 UserScissorEnable:    1;
} __Permedia2ScissorModeFmat;
#else
typedef struct {
  unsigned32 UserScissorEnable:    1;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 pad0:                30;
} __Permedia2ScissorModeFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                 11;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 MirrorY:               1;
  unsigned32 MirrorX:               1;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 pad2:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 XOffset:               3;
  unsigned32 pad0:                  6;
  unsigned32 UnitEnable:            1;
} __Permedia2AreaStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 pad0:                  6;
  unsigned32 XOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad2:                  2;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 MirrorX:               1;
  unsigned32 MirrorY:               1;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 pad3:                 11;
} __Permedia2AreaStippleModeFmat;
#endif

typedef __Permedia2StepFmat __Permedia2ScreenRegionFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2ScissorMinXYFmat, __Permedia2ScissorMaxXYFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2ScissorMinXYFmat, __Permedia2ScissorMaxXYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2WindowOriginFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2WindowOriginFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __Permedia2ScreenSizeFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __Permedia2ScreenSizeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         24;
  unsigned32 Pattern:       8;
} __Permedia2AreaStipplePatternFmat;
#else
typedef struct {
  unsigned32 Pattern:       8;
  unsigned32 pad0:         24;
} __Permedia2AreaStipplePatternFmat;
#endif

/*
**  Permedia 2 Color DDA Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __Permedia2CStartFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __Permedia2CStartFmat;
#endif

typedef __Permedia2CStartFmat __Permedia2RStartFmat;
typedef __Permedia2CStartFmat __Permedia2GStartFmat;
typedef __Permedia2CStartFmat __Permedia2BStartFmat;
typedef __Permedia2CStartFmat __Permedia2AStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __Permedia2dCdxFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __Permedia2dCdxFmat;
#endif

typedef __Permedia2dCdxFmat __Permedia2dRdxFmat;
typedef __Permedia2dCdxFmat __Permedia2dGdxFmat;
typedef __Permedia2dCdxFmat __Permedia2dBdxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __Permedia2dCdyDomFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __Permedia2dCdyDomFmat;
#endif

typedef __Permedia2dCdyDomFmat __Permedia2dRdyDomFmat;
typedef __Permedia2dCdyDomFmat __Permedia2dGdyDomFmat;
typedef __Permedia2dCdyDomFmat __Permedia2dBdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:            8;
  unsigned32 Blue:             8;
  unsigned32 Green:            8;
  unsigned32 Red:              8;
} __Permedia2ColorFmat;
#else
typedef struct {
  unsigned32 Red:              8;
  unsigned32 Green:            8;
  unsigned32 Blue:             8;
  unsigned32 Alpha:            8;
} __Permedia2ColorFmat;
#endif

typedef __Permedia2ColorFmat __Permedia2ConstantColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 AlphaInteger:     5;
  unsigned32 AlphaFraction:    3;
  unsigned32 BlueInteger:      5;
  unsigned32 BlueFraction:     3;
  unsigned32 GreenInteger:     5;
  unsigned32 GreenFraction:    3;
  unsigned32 RedInteger:       5;
  unsigned32 RedFraction:      3;
} __Permedia2FractionalColorFmat;
#else
typedef struct {
  unsigned32 RedFraction:      3;
  unsigned32 RedInteger:       5;
  unsigned32 GreenFraction:    3;
  unsigned32 GreenInteger:     5;
  unsigned32 BlueFraction:     3;
  unsigned32 BlueInteger:      5;
  unsigned32 AlphaFraction:    3;
  unsigned32 AlphaInteger:     5;
} __Permedia2FractionalColorFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             30;
  unsigned32 ShadeMode:         1;
  unsigned32 UnitEnable:        1;
} __Permedia2ColorDDAModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 ShadeMode:         1;
  unsigned32 pad0:             30;
} __Permedia2ColorDDAModeFmat;
#endif

/*
**  Permedia 2 Texture Application, Fog and 
**       Alpha Blend Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          8;  
  signed32 Integer:         2;
  unsigned32 Fraction:     19;
  unsigned32 pad0:          3;           
} __Permedia2FogFmat;
#else
typedef struct {
  unsigned32 pad0:          3;           
  unsigned32 Fraction:     19;
  signed32 Integer:         2;
  unsigned32 pad1:          8;  
} __Permedia2FogFmat;
#endif

typedef __Permedia2FogFmat __Permedia2FStartFmat;
typedef __Permedia2FogFmat __Permedia2dFdxFmat;
typedef __Permedia2FogFmat __Permedia2dFdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:            29;
  unsigned32 FogTest:          1;
  unsigned32 pad0:             1;
  unsigned32 FogEnable:        1;
} __Permedia2FogModeFmat;
#else
typedef struct {
  unsigned32 FogEnable:        1;
  unsigned32 pad0:             1;
  unsigned32 FogTest:          1;
  unsigned32 pad1:            29;
} __Permedia2FogModeFmat;
#endif

typedef __Permedia2ColorFmat __Permedia2FogColorFmat;
typedef __Permedia2ColorFmat __Permedia2TexelFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            25;
  unsigned32 KsDDA:            1;
  unsigned32 KdDDA:            1;
  unsigned32 TextureType:      1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureEnable:    1;
} __Permedia2TextureColorModeFmat;
#else
typedef struct {
  unsigned32 TextureEnable:    1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureType:      1;
  unsigned32 KdDDA:            1;
  unsigned32 KsDDA:            1;
  unsigned32 pad0:            25;
} __Permedia2TextureColorModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                13;
  unsigned32 AlphaConversion:      1;
  unsigned32 ColorConversion:      1;
  unsigned32 ColorFormatExtension: 1;
  unsigned32 pad1:                 1;
  unsigned32 BlendType:            1;
  unsigned32 ColorOrder:           1;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorFormat:          4;
  unsigned32 DestinationBlend:	   3;
  unsigned32 SourceBlend:		   4;
  unsigned32 AlphaBlendEnable:     1;
} __Permedia2AlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 AlphaBlendEnable:     1;
  unsigned32 SourceBlend:          4;
  unsigned32 DestinationBlend:	   3;
  unsigned32 ColorFormat:          4;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorOrder:           1;
  unsigned32 BlendType:            1;
  unsigned32 pad1:                 1;
  unsigned32 ColorFormatExtension: 1; 
  unsigned32 ColorConversion:      1;
  unsigned32 AlphaConversion:      1;
  unsigned32 pad2:                13;
} __Permedia2AlphaBlendModeFmat;
#endif

/*
**  Permedia 2 Texture Address Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:         12;
  unsigned32 Fraction:      18;
  unsigned32 pad1:           2;
} __Permedia2STFmat;
#else
typedef struct {
  unsigned32 pad1:           2;
  unsigned32 Fraction:      18;
  signed32 Integer:         12;
} __Permedia2STFmat;
#endif

typedef __Permedia2STFmat __Permedia2SStartFmat;
typedef __Permedia2STFmat __Permedia2TStartFmat;
typedef __Permedia2STFmat __Permedia2dSdxFmat;
typedef __Permedia2STFmat __Permedia2dTdxFmat;
typedef __Permedia2STFmat __Permedia2dSdyDomFmat;
typedef __Permedia2STFmat __Permedia2dTdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:          2;
  unsigned32 Fraction:      27;
  unsigned32 pad0:           3;
} __Permedia2QFmat;
#else
typedef struct {
  unsigned32 pad0:           3;
  unsigned32 Fraction:      27;
  signed32 Integer:          2;
} __Permedia2QFmat;
#endif

typedef __Permedia2QFmat __Permedia2QStartFmat;
typedef __Permedia2QFmat __Permedia2dQdxFmat;
typedef __Permedia2QFmat __Permedia2dQdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TLoMagnitude:    12;
  unsigned32 SSign:            1;
  unsigned32 SMagnitude:      19;
} __Permedia2TextureAddressFmat0;
#else
typedef struct {
  unsigned32 SMagnitude:      19;
  unsigned32 SSign:            1;
  unsigned32 TLoMagnitude:    12;
} __Permedia2TextureAddressFmat0;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            24;
  unsigned32 TSign:            1;
  unsigned32 THiMagnitude:     7;
} __Permedia2TextureAddressFmat1;
#else
typedef struct {
  unsigned32 THiMagnitude:     7;
  unsigned32 TSign:            1;
  unsigned32 pad0:            24;
} __Permedia2TextureAddressFmat1;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                    28;
  unsigned32 DeltaFormat:              1;
  unsigned32 Fast:                     1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Enable:                   1;
} __Permedia2TextureAddrModeFmat;
#else
typedef struct {
  unsigned32 Enable:                   1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Fast:                     1;
  unsigned32 DeltaFormat:              1;
  unsigned32 pad0:                    28;
} __Permedia2TextureAddrModeFmat;
#endif

/*
**  Permedia 2 Texture Read Registers
*/

typedef struct {
#if BIG_ENDIAN == 1
    unsigned32 TCoeff :      8;
    unsigned32 Pad1 :        7;
    unsigned32 SwapT :       1;
    unsigned32 SCoeff :      8;
    unsigned32 Pad0 :        7;
    unsigned32 SwapS :       1;
#else
    unsigned32 SwapS :       1;
    unsigned32 Pad0 :        7;
    unsigned32 SCoeff :      8;
    unsigned32 SwapT :       1;
    unsigned32 Pad1 :        7;
    unsigned32 TCoeff :      8;
#endif
} __Permedia2TextureReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                7;
  unsigned32 PackedData:          1;
  unsigned32 pad1:                6;
  unsigned32 FilterMode:          1;
  unsigned32 Height:              4;
  unsigned32 Width:               4;
  unsigned32 pad0:                4;
  unsigned32 TWrapMode:           2;
  unsigned32 SWrapMode:           2;
  unsigned32 Enable:              1;
} __Permedia2TextureReadModeFmat;
#else
typedef struct {
  unsigned32 Enable:              1;
  unsigned32 SWrapMode:           2;
  unsigned32 TWrapMode:           2;
  unsigned32 pad0:                4;
  unsigned32 Width:               4;
  unsigned32 Height:              4;
  unsigned32 FilterMode:          1;
  unsigned32 pad1:                6;
  unsigned32 PackedData:          1;
  unsigned32 pad2:                7;
} __Permedia2TextureReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:             10;
  unsigned32 TexelSize:         3;
  unsigned32 pad1:              1;
  unsigned32 SubPatchMode:      1;
  unsigned32 WindowOrigin:      1;
  unsigned32 pad0:              7;
  unsigned32 PackedPP:          9;
} __Permedia2TextureMapFormatFmat;
#else
typedef struct {
  unsigned32 PackedPP:          9;
  unsigned32 pad0:              7;
  unsigned32 WindowOrigin:      1;
  unsigned32 SubPatchMode:      1;
  unsigned32 pad1:              1;
  unsigned32 TexelSize:         3;
  unsigned32 pad2:             10;
} __Permedia2TextureMapFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   22;
  unsigned32 SpanFormat:              1;
  unsigned32 AlphaMap:                2;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 ColorOrder:              1;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 TextureFormat:           4;
} __Permedia2TextureDataFormatFmat;
#else
typedef struct {
  unsigned32 TextureFormat:           4;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 ColorOrder:              1;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 AlphaMap:                2;
  unsigned32 SpanFormat:              1;
  unsigned32 pad0:                   22;
} __Permedia2TextureDataFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __Permedia2TexelLUTAddressFmat, __Permedia2TexelLUTID;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __Permedia2TexelLUTAddressFmat, __Permedia2TexelLUTID;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              1;
  unsigned32 Access:            1;
  unsigned32 pad1:              6;
  unsigned32 Addr:             24;
} __Permedia2TextureBaseAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad1:              6;
  unsigned32 Access:            1;
  unsigned32 pad0:              1;
} __Permedia2TextureBaseAddressFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2RawDataFmat[2];

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:             8;
  unsigned32 V:                 8;
  unsigned32 U:                 8;
  unsigned32 Y:                 8;
} __Permedia2TexelYUVFmat;
#else
typedef struct {
  unsigned32 Y:                 8;
  unsigned32 U:                 8;
  unsigned32 V:                 8;
  unsigned32 Alpha:             8;
} __Permedia2TexelYUVFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           20;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 LUTOffset:       8;
  unsigned32 DirectIndex:     1;
  unsigned32 Enable:          1;
} __Permedia2TexelLUTModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 DirectIndex:     1;
  unsigned32 LUTOffset:       8;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 pad0:           20;
} __Permedia2TexelLUTModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TCoeff:            8;
  unsigned32 pad1:              7;
  unsigned32 SwapT:             1;
  unsigned32 SCoeff:            8;
  unsigned32 pad0:              7;
  unsigned32 SwapS:             1;
} __Permedia2Interp0Fmat;
#else
typedef struct {
  unsigned32 SwapS:             1;
  unsigned32 pad0:              7;
  unsigned32 SCoeff:            8;
  unsigned32 SwapT:             1;
  unsigned32 pad1:              7;
  unsigned32 TCoeff:            8;
} __Permedia2Interp0Fmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             24;
  unsigned32 Offset:            8;
} __Permedia2TexelLUTIndexFmat;
#else
typedef struct {
  unsigned32 Offset:            8;
  unsigned32 pad0:             24;
} __Permedia2TexelLUTIndexFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             15;
  unsigned32 Count:             9;
  unsigned32 Index:             8;
} __Permedia2TexelLUTTransferFmat;
#else
typedef struct {
  unsigned32 Index:             8;
  unsigned32 Count:             9;
  unsigned32 pad0:             15;
} __Permedia2TexelLUTTransferFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Valid:             1;
  unsigned32 pad0:              7;
  unsigned32 Address:          24;
} __Permedia2TextureIDFmat;
#else
typedef struct {
  unsigned32 Address:          24;
  unsigned32 pad0:              7;
  unsigned32 Valid:             1;
} __Permedia2TextureIDFmat;
#endif

typedef __Permedia2ColorFmat __Permedia2AlphaMapUpperBoundFmat;
typedef __Permedia2ColorFmat __Permedia2AlphaMapLowerBoundFmat;

/*
**  Permedia 2 YUV-REG Registers
*/

typedef __Permedia2ColorFmat __Permedia2ChromaUpperBoundFmat;
typedef __Permedia2ColorFmat __Permedia2ChromaLowerBoundFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           26;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 RejectTexel:     1;
  unsigned32 TestData:        1;
  unsigned32 TestMode:        2;
  unsigned32 Enable:          1;
} __Permedia2YUVModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 TestMode:        2;
  unsigned32 TestData:        1;
  unsigned32 RejectTexel:     1;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 pad0:           26;
} __Permedia2YUVModeFmat;
#endif

/*
**  Permedia 2 Localbuffer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           15;
  unsigned32 Stencil:         1;
  unsigned32 Depth:          16;
} __Permedia2LBDataFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 Stencil:         1;
  unsigned32 pad0:           15;
} __Permedia2LBDataFmat;
#endif

typedef __Permedia2LBDataFmat __Permedia2LBWriteDataFmat;
typedef __Permedia2LBDataFmat __Permedia2LBSourceDataFmat;
typedef __Permedia2LBDataFmat __Permedia2LBCancelWriteFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           28;
  unsigned32 StencilWidth:    2;
  unsigned32 DepthWidth:      2;
} __Permedia2LBFormatFmat;
#else
typedef struct {
  unsigned32 DepthWidth:      2;
  unsigned32 StencilWidth:    2;
  unsigned32 pad0:           28;
} __Permedia2LBFormatFmat;
#endif

typedef __Permedia2LBFormatFmat __Permedia2LBReadFormatFmat;
typedef __Permedia2LBFormatFmat __Permedia2LBWriteFormatFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 12;
  unsigned32 PatchMode:             1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              2;
  unsigned32 pad0:                  5;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PackedPP:              9;
} __Permedia2LBReadModeFmat;
#else
typedef struct {
  unsigned32 PackedPP:              9;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 pad0:                  5;
  unsigned32 DataType:              2;
  unsigned32 WindowOrigin:          1;
  unsigned32 PatchMode:             1;
  unsigned32 pad1:                 12;
} __Permedia2LBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           12;
  unsigned32 PatchMode:       1;
  unsigned32 WindowOrigin:    1;
  unsigned32 pad0:            9;
  unsigned32 PackedPP:        9;
} __Permedia2LBWriteConfigFmat;
#else
typedef struct {
  unsigned32 PackedPP:        9;
  unsigned32 pad0:            9;
  unsigned32 WindowOrigin:    1;
  unsigned32 PatchMode:       1;
  unsigned32 pad1:           12;
} __Permedia2LBWriteConfigFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2LBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 WriteEnable:     1;
} __Permedia2LBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:     1;
  unsigned32 pad0:           31;
} __Permedia2LBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            8;
  unsigned32 Addr:           24;
} __Permedia2LBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:           24;
  unsigned32 pad0:            8;
} __Permedia2LBAddressFmat;
#endif

typedef __Permedia2LBAddressFmat __Permedia2LBWindowBaseFmat;
typedef __Permedia2LBAddressFmat __Permedia2LBSourceOffsetFmat;
typedef __Permedia2LBAddressFmat __Permedia2LBWriteBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 Stencil:         1;
} __Permedia2LBStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:         1;
  unsigned32 pad0:           31;
} __Permedia2LBStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           16;
  unsigned32 Depth:          16;
} __Permedia2LBDepthFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 pad0:           16;
} __Permedia2LBDepthFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              31;
  unsigned32 Data:               1;
} __Permedia2StencilFmat;
#else
typedef struct {
  unsigned32 Data:               1;
  unsigned32 pad0:              31;
} __Permedia2StencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              16;
  unsigned32 Data:              16;
} __Permedia2DepthFmat;
#else
typedef struct {
  unsigned32 Data:              16;
  unsigned32 pad0:              16;
} __Permedia2DepthFmat;
#endif

/*
**  Permedia 2 Depth and Stencil Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad1:                 13;
  unsigned32 LBUpdateSource:        1;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 pad0:                  3;
} __Permedia2WindowFmat;
#else
typedef struct {
  unsigned32 pad0:                  3;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 LBUpdateSource:        1;
  unsigned32 pad1:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad2:                 13;
} __Permedia2WindowFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 15;
  unsigned32 WriteMask:             1;
  unsigned32 pad1:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad0:                  7;
  unsigned32 ReferenceValue:        1;
} __Permedia2StencilDataFmat;
#else
typedef struct {
  unsigned32 ReferenceValue:        1;
  unsigned32 pad0:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad1:                  7;
  unsigned32 WriteMask:             1;
  unsigned32 pad2:                 15;
} __Permedia2StencilDataFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                17;
  unsigned32 StencilSource:        2;
  unsigned32 CompareFunction:      3;
  unsigned32 SFail:                3;
  unsigned32 DPFail:               3;
  unsigned32 DPPass:               3;
  unsigned32 UnitEnable:           1;
} __Permedia2StencilModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:           1;
  unsigned32 DPPass:               3;
  unsigned32 DPFail:               3;
  unsigned32 SFail:                3;
  unsigned32 CompareFunction:      3;
  unsigned32 StencilSource:        2;
  unsigned32 pad0:                17;
} __Permedia2StencilModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              25;
  unsigned32 CompareMode:        3;
  unsigned32 NewDepthSource:     2;
  unsigned32 WriteMask:          1;
  unsigned32 UnitEnable:         1;
} __Permedia2DepthModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:         1;
  unsigned32 WriteMask:          1;
  unsigned32 NewDepthSource:     2;
  unsigned32 CompareMode:        3;
  unsigned32 pad0:              25;
} __Permedia2DepthModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              15;
  signed32 Z:                   17;
} __Permedia2ZUFmat;
#else
typedef struct {
  signed32 Z:                   17;
  unsigned32 pad0:              15;
} __Permedia2ZUFmat;
#endif

typedef __Permedia2ZUFmat __Permedia2ZStartUFmat;
typedef __Permedia2ZUFmat __Permedia2dZdxUFmat;
typedef __Permedia2ZUFmat __Permedia2dZdyDomUFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Z:                 11;
  unsigned32 pad0:              21;
} __Permedia2ZLFmat;
#else
typedef struct {
  unsigned32 pad0:              21;
  unsigned32 Z:                 11;
} __Permedia2ZLFmat;
#endif

typedef __Permedia2ZLFmat __Permedia2ZStartLFmat;
typedef __Permedia2ZLFmat __Permedia2dZdxLFmat;
typedef __Permedia2ZLFmat __Permedia2dZdyDomLFmat;

/*
**  Permedia 2 Framebuffer Registers
*/

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __Permedia2FBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __Permedia2FBAddressFmat;
#endif

typedef __Permedia2FBAddressFmat __Permedia2FBBaseAddressFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBPixelOffsetFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBSourceOffsetFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBWindowBaseFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBWriteBaseFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBSourceBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 TexelInhibit:           1;
  unsigned32 WindowOrigin:           1;
  unsigned32 DataType:               1;
  unsigned32 pad0:                   4;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 PackedPP:               9;
} __Permedia2FBReadModeFmat;
#else
typedef struct {
  unsigned32 PackedPP:               9;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 pad0:                   4;
  unsigned32 DataType:               1;
  unsigned32 WindowOrigin:           1;
  unsigned32 TexelInhibit:           1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __Permedia2FBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct { 
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 pad1:                   1;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad0:                   7;
  unsigned32 PackedPP:               9;
} __Permedia2FBWriteConfigFmat;
#else
typedef struct { 
  unsigned32 PackedPP:               9;
  unsigned32 pad0:                   7;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad1:                   1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __Permedia2FBWriteConfigFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             29;
  unsigned32 PixelSize:         3;
} __Permedia2FBPixelFmat;
#else
typedef struct {
  unsigned32 PixelSize:         3;
  unsigned32 pad1:             29;
} __Permedia2FBPixelFmat;
#endif

typedef __Permedia2FBPixelFmat __Permedia2FBReadPixelFmat;
typedef __Permedia2FBPixelFmat __Permedia2FBWritePixelFmat;

typedef __Permedia2UnsignedIntegerFmat __Permedia2FBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             28;
  unsigned32 UpLoadData:        1;
  unsigned32 pad0:              2;
  unsigned32 UnitEnable:        1;
} __Permedia2FBWriteModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 pad0:              2;
  unsigned32 UpLoadData:        1;
  unsigned32 pad1:             28;
} __Permedia2FBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             28;
  signed32 RelativeOffset:      3;
  unsigned32 DataPacking:       1;
} __Permedia2FBPackedDataModeFmat;
#else
typedef struct {
  unsigned32 DataPacking:       1;
  signed32 RelativeOffset:      3;
  unsigned32 pad0:             28;
} __Permedia2FBPackedDataModeFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2FBFmat;

typedef __Permedia2FBFmat __Permedia2FBColorFmat;
typedef __Permedia2FBFmat __Permedia2FBDataFmat;
typedef __Permedia2FBFmat __Permedia2FBSourceDataFmat;

typedef __Permedia2UnsignedIntegerFmat __Permedia2FBHardwareWriteMaskFmat;
typedef __Permedia2UnsignedIntegerFmat __Permedia2FBBlockColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 10;
  unsigned32 Offset:               22;
} __Permedia2TextureDownloadOffsetFmat;
#else
typedef struct {
  unsigned32 Offset:               22;
  unsigned32 pad0:                 10;
} __Permedia2TextureDownloadOffsetFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                         22;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 LogicOpEnable:               1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModeReadSource:        1;
} __Permedia2ConfigFmat;
#else
typedef struct {
  unsigned32 FBReadModeReadSource:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 LogicOpEnable:               1;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 pad:                         22;
} __Permedia2ConfigFmat;
#endif

/*
**  Permedia 2 Dither Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad0:                  2;
  unsigned32 ForceAlpha:            2;
  unsigned32 DitherMethod:          1;
  unsigned32 ColorOrder:            1;
  unsigned32 YOffset:               2;
  unsigned32 XOffset:               2;
  unsigned32 ColorFormat:           4;
  unsigned32 DitherEnable:          1;
  unsigned32 UnitEnable:            1;
} __Permedia2DitherModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 DitherEnable:          1;
  unsigned32 ColorFormat:           4;
  unsigned32 XOffset:               2;
  unsigned32 YOffset:               2;
  unsigned32 ColorOrder:            1;
  unsigned32 DitherMethod:          1;
  unsigned32 ForceAlpha:            2;
  unsigned32 pad0:                  2;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad1:                 15;
} __Permedia2DitherModeFmat;
#endif

/*
**  Permedia 2 Logic Ops and WriteMask Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   26;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 LogicalOp:               4;
  unsigned32 LogicalOpEnable:         1;
} __Permedia2LogicalOpModeFmat;
#else
typedef struct {
  unsigned32 LogicalOpEnable:         1;
  unsigned32 LogicalOp:               4;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 pad0:                   26;
} __Permedia2LogicalOpModeFmat;
#endif

typedef __Permedia2FBFmat __Permedia2FBWriteDataFmat;
typedef __Permedia2FBFmat __Permedia2FBSoftwareWriteMaskFmat;

/*
**  Permedia 2 Host Out Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                16;
  unsigned32 Remainder:            2;
  unsigned32 Statistics:           2;
  unsigned32 Synchronization:      2;
  unsigned32 Color:                2;
  unsigned32 Stencil:              2;
  unsigned32 Depth:                2;
  unsigned32 Passive:              2;
  unsigned32 Active:               2;
} __Permedia2FilterModeFmat;
#else
typedef struct {
  unsigned32 Active:               2;
  unsigned32 Passive:              2;
  unsigned32 Depth:                2;
  unsigned32 Stencil:              2;
  unsigned32 Color:                2;
  unsigned32 Synchronization:      2;
  unsigned32 Statistics:           2;
  unsigned32 Remainder:            2;
  unsigned32 pad0:                16;
} __Permedia2FilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                26;
  unsigned32 Spans:                1;
  unsigned32 CompareFunction:      1;
  unsigned32 PassiveSteps:         1;
  unsigned32 ActiveSteps:          1;
  unsigned32 StatType:             1;
  unsigned32 Enable:               1;
} __Permedia2StatisticModeFmat;
#else
typedef struct {
  unsigned32 Enable:               1;
  unsigned32 StatType:             1;
  unsigned32 ActiveSteps:          1;
  unsigned32 PassiveSteps:         1;
  unsigned32 CompareFunction:      1;
  unsigned32 Spans:                1;
  unsigned32 pad0:                26;
} __Permedia2StatisticModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 InterruptEnable:      1;
  unsigned32 pad0:                31;
} __Permedia2SyncFmat;
#else
typedef struct {
  unsigned32 pad0:                31;
  unsigned32 InterruptEnable:      1;
} __Permedia2SyncFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2MinRegionFmat,
  __Permedia2MaxRegionFmat,
  __Permedia2MinHitRegionFmat,
  __Permedia2MaxHitRegionFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2MinRegionFmat,
  __Permedia2MaxRegionFmat,
  __Permedia2MinHitRegionFmat,
  __Permedia2MaxHitRegionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 30;
  unsigned32 BusyFlag:              1;
  unsigned32 PickFlag:              1;
} __Permedia2PickResultFmat;
#else
typedef struct {
  unsigned32 PickFlag:              1;
  unsigned32 BusyFlag:              1;
  unsigned32 pad0:                 30;
} __Permedia2PickResultFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 12;
  unsigned32 screenbase:           20;
} __Permedia2SuspendUntilFrameBlankFmat;
#else
typedef struct {
  unsigned32 screenbase:           20;
  unsigned32 pad0:                 12;
} __Permedia2SuspendUntilFrameBlankFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2ResetPickResultFmat;

#if BIG_ENDIAN == 1
typedef struct {
    unsigned32 pad:                31;
    unsigned32 value:               1;
} __Permedia2PCITextureCacheFmat;
#else
typedef struct {
    unsigned32 value:               1;
    unsigned32 pad:                31;
} __Permedia2PCITextureCacheFmat;
#endif

typedef __Permedia2PCITextureCacheFmat __Permedia2PCIReadTextureCacheFmat;
typedef __Permedia2PCITextureCacheFmat __Permedia2PCIWriteTextureCacheFmat;

#endif /* P2REG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\pmdef.h ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: pmdef.h
*
* Content:     bitfield definitions for Permedia2 registers
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifndef __pmdef__
#define __pmdef__

// Texture unit bit fields
// Texture color mode
#define PM_TEXCOLORMODE_ENABLE 0
#define PM_TEXCOLORMODE_APPLICATION 1
#define PM_TEXCOLORMODE_TEXTURETYPE 4

// Texture address mode
#define PM_TEXADDRESSMODE_ENABLE 0
#define PM_TEXADDRESSMODE_PERSPECTIVE 1
#define PM_TEXADDRESSMODE_FAST 2

// Texture map format
#define PM_TEXMAPFORMAT_PP0 0
#define PM_TEXMAPFORMAT_PP1 3
#define PM_TEXMAPFORMAT_PP2 6
#define PM_TEXMAPFORMAT_TEXELSIZE 19

// Texture data format
#define PM_TEXDATAFORMAT_ALPHAMAP_EXCLUDE 2
#define PM_TEXDATAFORMAT_ALPHAMAP_INCLUDE 1
#define PM_TEXDATAFORMAT_ALPHAMAP_DISABLE 0

#define PM_TEXDATAFORMAT_FORMAT 0
#define PM_TEXDATAFORMAT_NOALPHAPIXELS 4
#define PM_TEXDATAFORMAT_FORMATEXTENSION 6
#define PM_TEXDATAFORMAT_COLORORDER 5

// Dither unit bit fields
#define PM_DITHERMODE_ENABLE 0
#define PM_DITHERMODE_DITHERENABLE 1
#define PM_DITHERMODE_COLORFORMAT 2
#define PM_DITHERMODE_XOFFSET 6
#define PM_DITHERMODE_YOFFSET 8
#define PM_DITHERMODE_COLORORDER 10
#define PM_DITHERMODE_DITHERMETHOD 11
#define PM_DITHERMODE_FORCEALPHA 12
#define PM_DITHERMODE_COLORFORMATEXTENSION 16

// Alpha Blend unit bit fields
#define PM_ALPHABLENDMODE_ENABLE 0
#define PM_ALPHABLENDMODE_OPERATION 1
#define PM_ALPHABLENDMODE_COLORFORMAT 8
#define PM_ALPHABLENDMODE_COLORORDER 13
#define PM_ALPHABLENDMODE_BLENDTYPE 14
#define PM_ALPHABLENDMODE_COLORFORMATEXTENSION 16

// Window register
#define PM_WINDOW_LBUPDATESOURCE_LBSOURCEDATA 0
#define PM_WINDOW_LBUPDATESOURCE_REGISTERS 1

// Texture unit YUV mode
#define PM_YUVMODE_CHROMATEST_DISABLE       0
#define PM_YUVMODE_CHROMATEST_PASSWITHIN    1
#define PM_YUVMODE_CHROMATEST_FAILWITHIN    2
#define PM_YUVMODE_TESTDATA_INPUT   0
#define PM_YUVMODE_TESTDATA_OUTPUT  1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\patnfill.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: patnfill.c
*
* Contains all the pattern fill routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"

//-----------------------------Note--------------------------------------------
//
// A Note on brushes
//
// Out cached brushes are 64x64.  Here is the reason.  The minimum brush
// size that we can use as a pattern is 32.
//
// Now, we need to be able to offset the pattern when rendering in x and y
// by as much as 7 pixels in either direction.  The P2
// hardware does not have a simple x/Y pattern offset mechanism.  Instead
// we are forced to offset the origin by offsetting the base address of the
// pattern.  This requires that we store in memory a pattern that is 
// 39 pixels wide.  However, the stride still needs to be acceptable to the
// texture address generation hardware.  The next valid stride is 64.
//
// That's why we have 64x64 pattern brushes in our cache.
//
// Note also that we over do it when caching duplicating the brush to fill
// up the entire 64x64 even though we only use 39x39.  We might change
// this in the near future.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// VOID vMonoOffset(GFNPB* ppb)
//
// Update the offset to be used in the area stipple unit. We do this for a
// mono brush which is realized in the hardware but whose alignment has simply
// changed. This avoids a full scale realization.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  prbrush-----Pointer to the RBrush structure
//  pptlBrush---Pointer to pointer brush structure
//
//-----------------------------------------------------------------------------
VOID
vMonoOffset(GFNPB* ppb)
{
    PPDev   ppdev = ppb->ppdev;
    
    DWORD   dwMode;
    POINTL* pptlBrush = ppb->pptlBrush;
    RBrush* prb = ppb->prbrush;

    PERMEDIA_DECL;

    DBG_GDI((6, "vMonoOffset started"));

    //
    // Construct the AreaStippleMode value. It contains the pattern size,
    // the offset for the brush origin and the enable bit. Remember the
    // offset so we can later check if it changes and update the hardware.
    // Remember the mode so we can do a mirrored stipple easily.
    //
    prb->ptlBrushOrg.x = pptlBrush->x;
    prb->ptlBrushOrg.y = pptlBrush->y;
    
    dwMode = __PERMEDIA_ENABLE
           | AREA_STIPPLE_XSEL(__PERMEDIA_AREA_STIPPLE_32_PIXEL_PATTERN)
           | AREA_STIPPLE_YSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN)
           | AREA_STIPPLE_MIRROR_X
           | AREA_STIPPLE_XOFF(8 - (prb->ptlBrushOrg.x & 7))
           | AREA_STIPPLE_YOFF(8 - (prb->ptlBrushOrg.y & 7));

    prb->areaStippleMode = dwMode;

    DBG_GDI((7, "setting new area stipple offset to %d, %d",
             8 - (prb->ptlBrushOrg.x & 7), 8 - (prb->ptlBrushOrg.y & 7)));

    ULONG* pBuffer;

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagAreaStippleMode;
    pBuffer[1] = dwMode;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

}// vMonoOffset()

//-----------------------------------------------------------------------------
//
// VOID vPatRealize(GFNPB* ppb)
//
// This routine transfers an 8x8 pattern to off-screen display memory, and
// duplicates it to make a 32x32 cached realization which is then used by
// vPatFill.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  prbrush-----Pointer to the RBrush structure
//
//-----------------------------------------------------------------------------
VOID
vPatRealize(GFNPB* ppb)
{
    PDev*       ppdev = ppb->ppdev;
    RBrush*     prb = ppb->prbrush; // Points to brush realization structure
    BrushEntry* pbe = prb->pbe;
    
    BYTE*       pcSrc;
    LONG        lNextCachedBrush;
    LONG        lTemp;
    LONG        lPelSize;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;

//    VALIDATE_GDI_CONTEXT;

    DBG_GDI((6, "vPatRealize started"));

    if ( (pbe == NULL) || (pbe->prbVerify != prb) )
    {
        //
        // Mono brushes are realized into the area stipple unit. For this we
        // have a set of special BRUSHENTRYs, one for each board.
        //
        if ( prb->fl & RBRUSH_2COLOR )
        {
            //
            // 1 BPP patten
            //
            DBG_GDI((7, "loading mono brush into cache"));
            pbe = &ppdev->abeMono;
            pbe->prbVerify = prb;
            prb->pbe = pbe;
        }
        else
        {
            //
            // We have to allocate a new off-screen cache brush entry for
            // the brush
            //
            lNextCachedBrush = ppdev->lNextCachedBrush; // Get the next index
            pbe = &ppdev->abe[lNextCachedBrush];        // Get the brush entry

            //
            // Check if this index is out of the total brush stamps cached
            // If yes, rotate to the 1st one
            //
            lNextCachedBrush++;
            if ( lNextCachedBrush >= ppdev->cBrushCache )
            {
                lNextCachedBrush = 0;
            }

            //
            // Reset the next brush to be allocated
            //
            ppdev->lNextCachedBrush = lNextCachedBrush;

            //
            // Update our links:
            //
            pbe->prbVerify = prb;
            prb->pbe = pbe;
            DBG_GDI((7, "new cache entry allocated for color brush"));
        }// Get cached brush entry depends on its color depth
    }// If the brush is not cached

    //
    // We're going to load mono patterns into the area stipple and set the
    // start offset to the brush origin. WARNING: we assume that we are
    // running little endian. I believe this is always true for NT.
    //
    if ( prb->fl & RBRUSH_2COLOR )
    {
        //
        // 1 BPP patten
        //
        DWORD*  pdwSrc = &prb->aulPattern[0];

        //
        // This function loads the stipple offset into the hardware. We also
        // call this function on its own if the brush is realized but its
        // offset changes. In that case we don't have to go through a complete
        // realize again.
        //
        ppb->prbrush = prb;

        (*ppdev->pgfnMonoOffset)(ppb);
        
        DBG_GDI((7, "area stipple pattern:"));
        
        InputBufferReserve(ppdev, 16, &pBuffer);

        for ( lTemp = 0; lTemp < 8; ++lTemp, ++pdwSrc )
        {
            pBuffer[0] = __Permedia2TagAreaStipplePattern0 + lTemp;
            pBuffer[1] = *pdwSrc;
            pBuffer += 2;
        }

        InputBufferCommit(ppdev, pBuffer);
        
        DBG_GDI((7, "area stipple downloaded. vPatRealize done"));

        return;
    }// 1 BPP case

    lPelSize = ppdev->cPelSize;
    pcSrc = (BYTE*)&prb->aulPattern[0];        // Copy from brush buffer


    InputBufferReserve(ppdev, 12 + 65, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  pbe->ulPixelOffset;
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] =  PM_FBREADMODE_PARTIAL(ppdev->ulBrushPackedPP);
    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] =   __PERMEDIA_DISABLE;

    pBuffer[6] = __Permedia2TagRectangleOrigin;
    pBuffer[7] = 0;
    pBuffer[8] = __Permedia2TagRectangleSize;
    pBuffer[9] = (8 << 16) | 8;
	pBuffer[10] = __Permedia2TagRender;
    pBuffer[11] = __RENDER_RECTANGLE_PRIMITIVE
                | __RENDER_SYNC_ON_HOST_DATA
                | __RENDER_INCREASE_Y
                | __RENDER_INCREASE_X;

	pBuffer += 12;

    *pBuffer++ = (63 << 16) | __Permedia2TagColor;
    
    switch( lPelSize )
    {
        case 0:
            for ( lTemp = 0; lTemp < 64; ++lTemp )
            {
                *pBuffer++ =  pcSrc[lTemp];
            }
            break;

        case 1:    
            for ( lTemp = 0; lTemp < 64; ++lTemp )
            {
                *pBuffer++ =  ((USHORT *) pcSrc)[lTemp];
            }
            break;

        case 2:
            for ( lTemp = 0; lTemp < 64; ++lTemp )
            {
                *pBuffer++ =  ((ULONG *) pcSrc)[lTemp];
            }
            break;
    }

    InputBufferCommit(ppdev, pBuffer);


    // 
    // 012   We now have an 8x8 colour-expanded copy of
    //  the pattern sitting in off-screen memory,
    // 5       represented here by square '0'.
    //        
    //         We're now going to expand the pattern to
    //         64x64 by repeatedly copying larger rectangles
    //         in the indicated order, and doing a 'rolling'
    //         blt to copy vertically.
    //        
    // 

    InputBufferReserve(ppdev, 36, &pBuffer);

    pBuffer[0] = __Permedia2TagFBReadMode;
    pBuffer[1] = PM_FBREADMODE_PARTIAL(ppdev->ulBrushPackedPP)
               | __FB_READ_SOURCE;
    pBuffer[2] = __Permedia2TagStartXDom;
    pBuffer[3] =  INTtoFIXED(8);
    pBuffer[4] = __Permedia2TagStartXSub;
    pBuffer[5] =  INTtoFIXED(16);
    pBuffer[6] = __Permedia2TagFBSourceOffset;
    pBuffer[7] =  -8;
    pBuffer[8] = __Permedia2TagRender;
    pBuffer[9] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer[10] = __Permedia2TagStartXDom;
    pBuffer[11] =  INTtoFIXED(16);
    pBuffer[12] = __Permedia2TagStartXSub;
    pBuffer[13] =  INTtoFIXED(32);
    pBuffer[14] = __Permedia2TagFBSourceOffset;
    pBuffer[15] =  -16;
    pBuffer[16] = __Permedia2TagRender;
    pBuffer[17] =  __RENDER_TRAPEZOID_PRIMITIVE;
    
    pBuffer[18] = __Permedia2TagStartXDom;
    pBuffer[19] =  INTtoFIXED(32);
    pBuffer[20] = __Permedia2TagStartXSub;
    pBuffer[21] =  INTtoFIXED(64);
    pBuffer[22] = __Permedia2TagFBSourceOffset;
    pBuffer[23] =  -32;
    pBuffer[24] = __Permedia2TagRender;
    pBuffer[25] =  __RENDER_TRAPEZOID_PRIMITIVE;
    
    //
    // Now rolling copy downward.
    //
    pBuffer[26] = __Permedia2TagStartXDom;
    pBuffer[27] =  INTtoFIXED(0);
    pBuffer[28] = __Permedia2TagStartY;
    pBuffer[29] =  INTtoFIXED(8);
    pBuffer[30] = __Permedia2TagFBSourceOffset;
    pBuffer[31] =  -(CACHED_BRUSH_WIDTH << 3);
    pBuffer[32] = __Permedia2TagCount;
    pBuffer[33] =  CACHED_BRUSH_HEIGHT - 8;
    pBuffer[34] = __Permedia2TagRender;
    pBuffer[35] =  __RENDER_TRAPEZOID_PRIMITIVE;

	pBuffer += 36;

	InputBufferCommit(ppdev, pBuffer);

}// vPatRealize()

//-----------------------------------------------------------------------------
//
// VOID vMonoPatFill(GFNPB* ppb)
//
// Fill a series of rectangles with a monochrome pattern previously loaded
// into the area stipple unit. If bTransparent is false we must do each
// rectangle twice, inverting the stipple pattern in the second go.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  ucFgRop3----Foreground Logic OP for the fill
//  ucBgRop3----Background Logic OP for the fill
//  prbrush-----Pointer to the RBrush structure
//  pptlBrush---Structure for brush origin
//  
//-----------------------------------------------------------------------------
VOID
vMonoPatFill(GFNPB* ppb)
{
    PPDev           ppdev = ppb->ppdev;
    Surf*           psurf = ppb->psurfDst;

    RBrush*         prb = ppb->prbrush;
    POINTL*         pptlBrush = ppb->pptlBrush;
    BrushEntry*     pbe = prb->pbe;             // Brush entry
    RECTL*          pRect = ppb->pRects;        // List of rectangles to be
                                                // filled in relative
                                                // coordinates
    ULONG*      pBuffer;
    
    DWORD           dwColorMode;
    DWORD           dwColorReg;
    DWORD           dwLogicMode;
    DWORD           dwReadMode;
    LONG            lNumPass;
    LONG            lNumRects;                  // Can't be zero
//    ULONG           ulBgLogicOp = ulRop3ToLogicop(ppb->ucBgRop3);
    ULONG           ulBgLogicOp = ulRop3ToLogicop(ppb->ulRop4 >> 8);
                                                // Not used (unless the brush
                                                // has a mask, in which case it
                                                // is the background mix mode)
//    ULONG           ulFgLogicOp = ulRop3ToLogicop(ppb->ucFgRop3);
    ULONG           ulFgLogicOp = ulRop3ToLogicop(ppb->ulRop4 & 0xFF);
                                                // Hardware mix mode
                                                // (foreground mix mode if
                                                // the brush has a mask)
    ULONG           ulBgColor = prb->ulBackColor;
    ULONG           ulFgColor = prb->ulForeColor;
    ULONG           ulCurrentFillColor;
    ULONG           ulCurrentLogicOp;

    PERMEDIA_DECL;
    
    DBG_GDI((6, "vMonoPatFill called: %d rects. ulRop4 = %x",
             ppb->lNumRects, ppb->ulRop4));
//    DBG_GDI((6, "ulFgLogicOp = 0x%x, ulBgLogicOp = 0x%x",
//             ulFgLogicOp, ulBgLogicOp));

    DBG_GDI((6, "ulFgColor 0x%x, ulBgColor 0x%x", ulFgColor, ulBgColor));

    //
    // If anything has changed with the brush we must re-realize it. If the
    // brush has been kicked out of the area stipple unit we must fully realize
    // it. If only the alignment has changed we can simply update the alignment
    // for the stipple.
    //
    if ( (pbe == NULL) || (pbe->prbVerify != prb) )
    {
        DBG_GDI((7, "full brush realize"));
        (*ppdev->pgfnPatRealize)(ppb);
    }
    else if ( (prb->ptlBrushOrg.x != pptlBrush->x)
            ||(prb->ptlBrushOrg.y != pptlBrush->y) )
    {
        DBG_GDI((7, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppb);
    }

    //
    // We get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.
    //
    if ( ((ulFgLogicOp == K_LOGICOP_AND) && (ulFgColor == ppdev->ulWhite))
       ||((ulFgLogicOp == K_LOGICOP_XOR) && (ulFgColor == 0)) )
    {
        DBG_GDI((7, "Set FgLogicOp to NOOP"));
        ulFgLogicOp = K_LOGICOP_NOOP;        
    }

    //
    // Same for background
    //
    if ( ((ulBgLogicOp == K_LOGICOP_AND) && (ulBgColor == ppdev->ulWhite))
       ||((ulBgLogicOp == K_LOGICOP_XOR) && (ulBgColor == 0)) )
    {
        DBG_GDI((7, "Set BgLogicOp to NOOP"));
        ulBgLogicOp = K_LOGICOP_NOOP;
    }

    //
    // Try to do the background as a solid fill. lNumPass starts at 1 rather
    // than 2 because we want to do all comparisons with zero. This is faster.
    // We also do a trick with its value to avoid an extra WAIT_FIFO on the
    // first pass.
    //
    if ( (ulBgLogicOp == K_LOGICOP_COPY)
       &&(ulFgLogicOp == K_LOGICOP_COPY) )
    {
        DBG_GDI((7, "FgLogicOp and BgLogicOp are COPY"));

        //
        // For PatCopy case, we can use solid fill to fill the background first
        // Note: we do not need to set FBWindowBase, it will be set by
        // the solid fill
        //
        ppb->solidColor = ulBgColor;
        (*ppdev->pgfnSolidFill)(ppb);

        //
        // We've done the background so we only want to go round the stipple
        // loop once. So set the lNumPass counter up for only one loop and set
        // the ulCurrentLogicOp and color to the foreground values.
        //
        lNumPass           = 0;
        ulCurrentFillColor = ulFgColor;
        ulCurrentLogicOp   = ulFgLogicOp;

        //
        // Do this here in case the solid fill changed the packing.
        //

// brh not needed
//        P2_DEFAULT_FB_DEPTH;
    }
    else
    {
        //
        // For non-PATCOPY cases, we have to do 2 passes. Fill the background
        // first and then fill the foreground
        //
        lNumPass           = 1;
        ulCurrentFillColor = ulBgColor;
        ulCurrentLogicOp   = ulBgLogicOp;

        //
        // Note: In this case, dxDom, dXSub and dY are initialised to 0, 0,
        // and 1, so we don't need to re-load them here. But we need to set
        // WindowBase here
        //

        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagFBWindowBase;
        pBuffer[1] =   psurf->ulPixOffset;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }// if-else for LOGICOP_COPY case

    //
    // Do 2 passes loop or single loop depends on "lNumPass"
    //
    while ( TRUE )
    {
        if ( ulCurrentLogicOp != K_LOGICOP_NOOP )
        {
            dwReadMode  = psurf->ulPackedPP;

            if ( ulCurrentLogicOp == K_LOGICOP_COPY )
            {
                DBG_GDI((7, "Current logicOP is COPY"));
                dwColorReg  = __Permedia2TagFBWriteData;
                dwColorMode = __PERMEDIA_DISABLE;
                dwLogicMode = __PERMEDIA_CONSTANT_FB_WRITE;
            }
            else
            {
                DBG_GDI((7, "Current logicOP is NOT-COPY"));
                dwColorReg  = __Permedia2TagConstantColor;
                dwColorMode = __COLOR_DDA_FLAT_SHADE;
                dwLogicMode = P2_ENABLED_LOGICALOP(ulCurrentLogicOp);
                dwReadMode |= LogicopReadDest[ulCurrentLogicOp];
            }

            //
            // On the bg fill pass, we have to invert the sense of the
            // download bits. On the first pass, lNumPass == 1; on the second
            // pass, lNumPass == 0, so we get our WAIT_FIFO sums correct!!
            //
            InputBufferReserve(ppdev, 10, &pBuffer);

            if ( lNumPass > 0 )
            {
                pBuffer[0] = __Permedia2TagAreaStippleMode;
                pBuffer[1] = (prb->areaStippleMode
                           | AREA_STIPPLE_INVERT_PAT);
                pBuffer += 2;

            }

            pBuffer[0] = __Permedia2TagColorDDAMode;
            pBuffer[1] =   dwColorMode;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] =     dwReadMode;
            pBuffer[4] = __Permedia2TagLogicalOpMode;
            pBuffer[5] =  dwLogicMode;

            pBuffer[6] = dwColorReg,
            pBuffer[7] = ulCurrentFillColor;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            //
            // Fill rects one by one
            //
            lNumRects = ppb->lNumRects;

            while ( TRUE )
            {
                DBG_GDI((7, "mono pattern fill to rect (%d,%d) to (%d,%d)",
                        pRect->left,
                        pRect->top,
                        pRect->right,
                        pRect->bottom));

                InputBufferReserve(ppdev, 12, &pBuffer);

                //
                // Render the rectangle
                //
                pBuffer[0] = __Permedia2TagStartXDom;
                pBuffer[1] =  pRect->left << 16;
                pBuffer[2] = __Permedia2TagStartXSub;
                pBuffer[3] =  pRect->right << 16;
                pBuffer[4] = __Permedia2TagStartY;
                pBuffer[5] =  pRect->top << 16;
                pBuffer[6] = __Permedia2TagdY;
                pBuffer[7] =  1 << 16;
                pBuffer[8] = __Permedia2TagCount;
                pBuffer[9] =  pRect->bottom - pRect->top;

                pBuffer[10] = __Permedia2TagRender;
                pBuffer[11] = __RENDER_TRAPEZOID_PRIMITIVE
                           |__RENDER_AREA_STIPPLE_ENABLE;

                pBuffer += 12;

                InputBufferCommit(ppdev, pBuffer);

                if ( --lNumRects == 0 )
                {
                    break;
                }

                pRect++;
            }// loop through all the rectangles

            //
            // Reset our pixel values.
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] =  __PERMEDIA_DISABLE;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);

            //
            // We must reset the area stipple mode for the foreground pass. if
            // there's no foreground pass we must reset it anyway.
            //
            if ( lNumPass > 0 )
            {
                InputBufferReserve(ppdev, 2, &pBuffer);

                pBuffer[0] = __Permedia2TagAreaStippleMode;
                pBuffer[1] =  prb->areaStippleMode;

                pBuffer += 2;

                InputBufferCommit(ppdev, pBuffer);
            }
        }// if ( ulCurrentLogicOp != K_LOGICOP_NOOP )

        if ( --lNumPass < 0 )
        {
            break;
        }

        //
        // We need to the 2nd pass. So reset the rectangle info, color mode
        // and logicop status
        //
        pRect              = ppb->pRects;
        ulCurrentFillColor = ulFgColor;
        ulCurrentLogicOp   = ulFgLogicOp;
    }// Loop through all the passes

    if ( dwColorMode != __PERMEDIA_DISABLE )
    {
        InputBufferReserve(ppdev, 2, &pBuffer);

        //
        // Restore ColorDDAMode
        //
        pBuffer[0] = __Permedia2TagColorDDAMode;
        pBuffer[1] =  __PERMEDIA_DISABLE;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

    DBG_GDI((6, "vMonoPatFill returning"));

}// vMonoPatFill()

//-----------------------------------------------------------------------------
//
// VOID vPatFill(GFNPB* ppb)
//
// Function to fill a set of rectangles with a given pattern. Colored patterns
// only. Monochrome patterns are handled in a different routine. This routine
// only handles patterns which were not rotated in memory and which have been
// replicated in X to cope with different alignments.
//
// Parameter block arguments
//
//  ppdev-------Valid
//  lNumRects---Number of rects pointed to by pRects
//  pRects------Of destination rectangles to be filled
//  ucFgRop3----Valid Pattern fill rop3 code (source invariant)
//  pptlBrush---Origin of brush
//  pdsurfDst---Destination surface
//  prbrush-----ponter to RBRUSH
//
//-----------------------------------------------------------------------------
VOID
vPatFill(GFNPB* ppb)
{
    PPDev       ppdev = ppb->ppdev;
    LONG        lNumRects = ppb->lNumRects;
    RECTL*      prcl = ppb->pRects;
    POINTL*     pptlBrush = ppb->pptlBrush;
    Surf*       psurf = ppb->psurfDst;
    RBrush*     prbrush = ppb->prbrush;
    
    BrushEntry* pbe = prbrush->pbe;
    DWORD       dwRenderBits;    
    ULONG       ulBrushX;
    ULONG       ulBrushY;
    ULONG       ulBrushOffset;
//    ULONG       ulLogicOP = ulRop3ToLogicop(ppb->ucFgRop3);
    ULONG       ulLogicOP = ulRop3ToLogicop(ppb->ulRop4 & 0xFF);
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;

    ASSERTDD(lNumRects > 0, "vPatFill: unexpected rectangle lNumRects <= 0");

    if ( (pbe == NULL) || (pbe->prbVerify != ppb->prbrush) )
    {
        vPatRealize(ppb);
        
        pbe = prbrush->pbe;
        ASSERTDD(pbe != NULL, "vPatFill: unexpected null pattern brush entry");
    }

    dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                 | __RENDER_TEXTURED_PRIMITIVE;
    
    InputBufferReserve(ppdev, 34, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =   psurf->ulPixOffset;
    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] =  P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    pBuffer[6] = __Permedia2TagFBWriteConfig; 
    pBuffer[7] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    pBuffer[8] = __Permedia2TagFBSourceOffset;
    pBuffer[9] =  0;

    //
    // Setup the texture unit with the pattern
    //    
    pBuffer[10] = __Permedia2TagDitherMode;
    pBuffer[11] = (COLOR_MODE << PM_DITHERMODE_COLORORDER)
               | (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT)
               | (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION)
               | (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[12] = __Permedia2TagTextureAddressMode;
    pBuffer[13] = (1 << PM_TEXADDRESSMODE_ENABLE);
    pBuffer[14] = __Permedia2TagTextureColorMode;
    pBuffer[15] = (1 << PM_TEXCOLORMODE_ENABLE)
               | (0 << 4)       // RGB
               | (3 << 1);     // Copy

    
    pBuffer[16] = __Permedia2TagTextureReadMode;
    pBuffer[17] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE)
               | PM_TEXREADMODE_WIDTH(CACHED_BRUSH_WIDTH_LOG2 - 1)
               | PM_TEXREADMODE_HEIGHT(CACHED_BRUSH_HEIGHT_LOG2 - 1)
               | (1 << 1)       // repeat S 
               | (1 << 3);      // repeat T
    
    pBuffer[18] = __Permedia2TagTextureDataFormat;
    pBuffer[19] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT)
               | (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION)
               | (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[20] = __Permedia2TagTextureMapFormat;
    pBuffer[21] = (ppdev->ulBrushPackedPP)
               | (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);

//@@BEGIN_DDKSPLIT
    // TODO: use SStart and TStart to avoid having to offset the pattern using
    //       ulBrushOffset.  This will also allow us to save some space in the
    //       pattern cache (we have to make it 7 pixels wider and taller due to
    //       our need to set different origins).
//@@END_DDKSPLIT
    pBuffer[22] = __Permedia2TagSStart;
    pBuffer[23] =  0;
    pBuffer[24] = __Permedia2TagTStart;
    pBuffer[25] =  0;
    pBuffer[26] = __Permedia2TagdSdx;
    pBuffer[27] =       1 << 20;
    pBuffer[28] = __Permedia2TagdSdyDom;
    pBuffer[29] =    0;
    pBuffer[30] = __Permedia2TagdTdx;
    pBuffer[31] =       0;
    pBuffer[32] = __Permedia2TagdTdyDom;
    pBuffer[33] =    1 << 20;

    pBuffer += 34;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Render rectangles
    //
    do
    {
        //
        // Caclulate brush offset taking into account the brush origin
        // NOTE: that the texture unit places the origin of the texture
        //       at the upper left of the destination rectangle
        //
        ulBrushX = (prcl->left - ppb->pptlBrush->x) & 7;
        ulBrushY = (prcl->top - ppb->pptlBrush->y) & 7;
        ulBrushOffset = pbe->ulPixelOffset 
                      + ulBrushX
                      + (ulBrushY * CACHED_BRUSH_WIDTH);

        InputBufferReserve(ppdev, 12, &pBuffer);

        pBuffer[0] = __Permedia2TagTextureBaseAddress;
        pBuffer[1] =  ulBrushOffset;
        pBuffer[2] = __Permedia2TagStartXDom;
        pBuffer[3] =  INTtoFIXED(prcl->left);
        pBuffer[4] = __Permedia2TagStartXSub;
        pBuffer[5] =  INTtoFIXED(prcl->right);
        pBuffer[6] = __Permedia2TagStartY;
        pBuffer[7] =  INTtoFIXED(prcl->top);
        pBuffer[8] = __Permedia2TagCount;
        pBuffer[9] =  (prcl->bottom - prcl->top);
        pBuffer[10] = __Permedia2TagRender;
        pBuffer[11] =  dwRenderBits;

        pBuffer += 12;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;    

    } while (--lNumRects != 0);

    //
    // Restore defaults
    //
    InputBufferReserve(ppdev, 8, &pBuffer);

    pBuffer[0] = __Permedia2TagTextureAddressMode;
    pBuffer[1] = (0 << PM_TEXADDRESSMODE_ENABLE);
    pBuffer[2] = __Permedia2TagTextureColorMode;
    pBuffer[3] =  (0 << PM_TEXCOLORMODE_ENABLE);
    pBuffer[4] = __Permedia2TagDitherMode;
    pBuffer[5] =  (0 << PM_DITHERMODE_ENABLE);
    pBuffer[6] = __Permedia2TagTextureReadMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;

    pBuffer += 8;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((6, "vPatternFillRects done"));
}// vPatFill
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\permedia.c ===
/******************************Module*Header*********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: Permedia.c
*
* Content:     This module implements basic access to the Permedia chip and
*              DMA transport. It shows also how to implement synchronization
*              between a display driver and the miniport interrupt by using
*              a shared buffer.
*
*              
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#define ALLOC_TAG ALLOC_TAG_EP2P
//----------------------------------------------------------------------------
// 
//  here some notes to the transport of data to the Permedia Fifo
//  via standard CPU writes or DMA:
//
//  The Permedia 2 chip allows to download data via three methods:
//      1. program registers by writing once to a specific address
//      2. writing an address and a data tag to a special area on the chip
//      3. writing an address and a data tag to a DMA buffer, then
//          download via DMA
//
//  The third method is preferred, because the CPU writes fastest to memory
//  and the DMA does not stall the CPU. Also many commands can be queued 
//  in a buffer while the graphic processor continues to render 
//  independently. Methods one and two need to read the space in the Input
//  Fifo before data can be written to the Fifo. The disconnect mode of the 
//  chip should not be used, because it can stall the CPU in PCI Disconnect/Retry
//  cycles, where the CPU is not even able to acknoledge an interrupt.
//  On the other hand writing to a DMA buffer introduces a latency compared
//  to write directly to the chip registers. The more data is queued in the
//  DMA buffer, the higher will be the latency. 
//
//  Methods one and two force the CPU to access the chip, which costs more 
//  PCI/AGP bus bandwidth than a DMA burst. Also sequential writes using
//  method one are less efficient, because only accesses to consecutive
//  addresses can be combined to a burst. 
//  The special FIFO area on the chip which is used for method two is 2kb
//  wide and can be written by using a memory copy. These copies can be 
//  combined to bursts by the PCI-Bridge. On processors implementing writeback
//  caches also normal writes to this area are combined to bursts. 
//  (in this driver the "Fifo" memory area on the 
//  chip is not marked as write combined, because writes to the Fifo
//  need to preserve the order). Also the data 
//  format which is written to the chip is exactly the same as in the DMA case. 
//  For that reason a very simple fallback mechanism can be implemented in case
//  the DMA doesn't work on the target system. This could be due to low memory,
//  problems in sharing interrupts, incompatible PCI devices etc.  
//
//  here is a typical piece of code sending some data to the chip:
//  
//  RESERVEDMAPTR(2);     //  wait until two entries are left in Fifo
//  LD_INPUT_FIFO(__Permedia2TagFogMode,0);    // write data        
//  LD_INPUT_FIFO(__Permedia2TagScissorMode,0);
//  COMMITDMAPTR();       //  commit write pointer for next DMA flush
//  FLUSHDMA();           //  do the actual flush (optional)
//
//  Here is a brief description of the DMA memory model:
//
//  There is one huge DMA buffer. It is organized as a ring and is typically
//  between 32kb and 256kb big. There are three main pointers  and one helper
//  handling the DMA operation. They reside in the shared memory section
//  (nonpaged) of the interrupt handler and the display driver.      
//
//
//            pulDMAPrevStart;        // start address of previous DMA
//            pulDMANextStart;        // start address of next DMA
//            pulDMAWritePos;         // address of current write pointer
//
//            pulDMAWriteEnd;         // helper address for reserve function
//
//  In the idle case all three pointers have the same value. In the above sample
//  the write pointer is incremented by two and the execute command would start
//  a 2 command long DMA and setting NextStart to the current value of WritePos and
//  PrevStart to the previous NextStart. Since there can only be one DMA active
//  at a time, a check is necessary if subsequent DMAs have finished before 
//  starting a new one. As long as there are no unfinished DMAs pending, the
//  current implementation does not use interrupts to save CPU time.
//  In the case there is still a DMA pending, a mechanism for flushing the buffer
//  is necessary without stalling the CPU. Interrupts are enabled in this case to 
//  ensure the buffer flush. The interrupt handler in the miniport can also access
//  the current pointer positions in the shared memory area. Updates to these
//  pointers have to be done carefully and synchronization between the interrupt 
//  thread and the display driver thread is necessary for some operations.
//  On multiprocessor systems, special care has to be taken to handle cases where
//  both CPUs access the shared memory area at the same time.
//
//  The access to the shared memory area is secured by calls to
//  InterlockedExchange on a variable in this area. Pointer updates like
//  the "CommitDMAPtr", which are only done one at a time by one thread
//  need not to be secured (as long as they are atomic)
//  Since the call to InterlockedExchange in the kernel
//  is also very expensive, different versions of the FlushDMA function are 
//  provided for single processor and multiprocessor environments.
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//  here are some hints of how to vary parameters of the CPermedia class:
//
//      the DMA buffer size can be changed between
//      8kb and 256kb by setting:
//
//      #define DMA_BUFFERSIZE   0x40000 // set size between 8kb and 256kb
//
//      The 256kb allocation limit is set by VideoPortGetCommonBuffer.
//      Also the Permedia2 can only transfer 256 kb in one piece.
//      On the Alpha processor we have a limit of 8kb, because some alpha 
//      machines cannot handle DMAs which pass a 8kb page limit.
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//  on x86 machines we need to call InterlockedExchange in ntoskrnl, but 
//  the display driver is only allowed to import EngXXX functions. So the 
//  VideoPort maps the function for us and we call it directly. On other 
//  platforms InterlockedExchange is implemented as inline. (in fact we 
//  are calling VideoPortInterlockedExchange)
//
#if defined(_X86_)
#define InterlockedExchange(a,b) (*pP2dma->pInterlockedExchange)(a, b)
#endif


//----------------------------------------------------------------------------
//
//  vFree()
//
//  frees allocated DMA buffer, instance count to DMA buffer will be 
//  decremented by one. if usage counts gets down to zero, 
//  the DMA buffer(s) will be freed.
//
//----------------------------------------------------------------------------

VOID vFree(P2DMA *pP2dma)
{
    ULONG   MagicNum;

    pP2dma->uiInstances--;
    if (pP2dma->uiInstances==0)
    {
        ASSERTDD(pP2dma->bEnabled == FALSE,
                 "vFree: Trying to free enabled DMA");

        if (pP2dma->pSharedDMABuffer != NULL)
        {
            FreeDMABuffer(pP2dma->hDriver, pP2dma->pSharedDMABuffer);
        }

        if (pP2dma->pEmulatedDMABuffer != NULL)
        {
            FreeEmulatedDMABuffer(pP2dma->hDriver, pP2dma->pEmulatedDMABuffer);
        }

        // Back to zeroed state retaining magic number
        MagicNum = pP2dma->ICB.ulMagicNo;
        RtlZeroMemory(pP2dma, sizeof(P2DMA));
        pP2dma->ICB.ulMagicNo = MagicNum;
    }
}

//----------------------------------------------------------------------------
//
//  bInitializeP2DMA
//
//  Initialize chip registers for use with display driver and decide if we
//  will use DMA. DMA will only be used if:
//      - the acceleration level is zero (full acc.)
//      - the miniport can map at least 8kb of DMA memory for us
//      - we get the receipt from the IRQ handler after starting a DMA
//      - x86 only: if we get the pointer to the InterlockedExchange function
//          in the videoport
//
//  TODO: parameters
//
//----------------------------------------------------------------------------

BOOL bInitializeP2DMA(P2DMA *pP2dma,
                      HANDLE hDriver, 
                      ULONG *pChipBase, 
                      DWORD dwAccelLevel,
                      BOOL NewReference
                     )
{
    ASSERTDD(pP2dma->bEnabled == FALSE,
                "bInitializeP2DMA: DMA already enabled");

    if (NewReference)
    {
        // increment usage count
        // we rely here on the fact that the videport initializes the shared
        // memory section to zero at start of day

        pP2dma->uiInstances++;

        if (pP2dma->uiInstances == 1)
        {
            ASSERTDD(pP2dma->pSharedDMABuffer == NULL,
                     "Shared DMA Buffer already allocated");
            ASSERTDD(pP2dma->pEmulatedDMABuffer == NULL,
                     "Emulated DMA Buffer already allocated");
        }
    }
    else
    {
        ASSERTDD(pP2dma->uiInstances != 0, "bInitializeP2DMA: DMA hasn't been initialized");
    }

    // save pointers to Permedia 2 registers for later use
    //
    pP2dma->pCtrlBase   = pChipBase+CTRLBASE/sizeof(ULONG);
    pP2dma->pGPFifo     = pChipBase+GPFIFO/sizeof(ULONG);

    DISPDBG((5, "Initialize: pCtrlBase=0x%p\n", pP2dma->pCtrlBase));
    DISPDBG((5, "Initialize: pGPFifo=0x%p\n", pP2dma->pGPFifo));

    BOOL bUseDMA=FALSE;

    // read number of processors we are running on:
    // If we are on a multiprocessing environment we have to take special care
    // about the synchronization of the interrupt 
    // service routine and the display driver
    
    ULONG ulNumberOfProcessors = 1; // Init to 1 by default.
    if(!g_bOnNT40)
        EngQuerySystemAttribute(EngNumberOfProcessors,
            (ULONG *)&ulNumberOfProcessors);
    DISPDBG((1,"running on %ld processor machine", 
        ulNumberOfProcessors));

    //
    // Allow DMA initialization only at full acceleration level (0) on NT5.0
    // and when the magic number of the miniport is the same as ours
    // Otherwise the miniport could use a different version of data structures
    // where the synchronization would probably fail. The magic no. is the 
    // first entry in the shared memory data structure.
    //
    if ( dwAccelLevel==0 && 
        (pP2dma->ICB.ulMagicNo==P2_ICB_MAGICNUMBER) &&
        !g_bOnNT40)
    {
        bUseDMA=TRUE;
    }

    pP2dma->hDriver=hDriver;

    //
    // On x86 machines the InterlockedExchange routine is implemented different
    // in the single- and multiprocessor versions of the kernel. So we have to
    // make sure we call the same function as the interrupt service routine in 
    // the miniport.
    // The miniport returns us a pointer to his InterlockedExchange function, 
    // which is implemented as __fastcall. Otherwise the lock could also be 
    // implemented using an x86 assembler xchg instruction, which is 
    // multiprocessor safe.
    //
    // On the Alpha architecture the compiler generates inline code for 
    // InterlockedExchange and the pointer to this function is not needed.
    //
#if defined(_X86_)
    // get pointer to InterlockedExchange in kernel
    pP2dma->pInterlockedExchange=
        (PInterlockedExchange) GetPInterlockedExchange(hDriver);
    if (pP2dma->pInterlockedExchange==NULL)
    {
        bUseDMA=FALSE;
    }
#endif

    // set DMA control status to default
    //
    WRITE_CTRL_REG(PREG_DMACONTROL,0);

    //  disable all interrupts
    //
    WRITE_CTRL_REG(PREG_INTENABLE, 0);

    // We turn the register on by default, so no entries written to the Fifo can
    // be lost. But the code checks the number of available entries anyway,
    // because when the CPU ends up in a PCI Disconnect-Retry cycle because of an
    // Fifo overflow, it would not even allow an interrupt to come through.
    WRITE_CTRL_REG(PREG_FIFODISCON, DISCONNECT_INPUT_FIFO_ENABLE);

    pP2dma->bDMAEmulation=FALSE;

    pP2dma->lDMABufferSize=0;

    pP2dma->ICB.pDMAActualBufferEnd = 
    pP2dma->ICB.pDMAWriteEnd =
    pP2dma->ICB.pDMAPrevStart=
    pP2dma->ICB.pDMANextStart=
    pP2dma->ICB.pDMAWritePos = NULL;
    pP2dma->ICB.pDMABufferEnd = 
    pP2dma->ICB.pDMABufferStart=NULL;

    //
    //  the following code first tries to allocate a reasonably sized DMA 
    //  buffer, does some initialization and fires off a DMA transfer to see 
    //  if the systems responds as expected. If the system doesn't, it falls 
    //  back to DMA emulation.
    //
    if (bUseDMA) 
    {
        //
        // preset flush and Check function pointers first
        //

//@@BEGIN_DDKSPLIT
#if !MULTITHREADED
//@@END_DDKSPLIT
        if (ulNumberOfProcessors==1)
        {
            pP2dma->pgfnFlushDMA= vFlushDMA;
            pP2dma->pgfnCheckEOB= vCheckForEOB;
        } else
//@@BEGIN_DDKSPLIT
#endif !MULTITHREADED
//@@END_DDKSPLIT
        {   
            pP2dma->pgfnFlushDMA= vFlushDMAMP;
            pP2dma->pgfnCheckEOB= vCheckForEOBMP;
        }

        // Allocate the DMA buffer shared with videoport
        // if we haven't previously allocated one.
        if (pP2dma->pSharedDMABuffer == NULL)
        {
            // allocate a buffer between 8kb and 256kb
            pP2dma->lSharedDMABufferSize = DMACMDSIZE;

            //
            //  allocate the DMA buffer in the videoport
            //
            if (AllocateDMABuffer(  pP2dma->hDriver, 
                                    &pP2dma->lSharedDMABufferSize, 
                                    &pP2dma->pSharedDMABuffer,
                                    &pP2dma->ICB.liDMAPhysAddr))
            {
                // for now we limit DMA Buffer size on alpha to 8kb, because
                // of hardware problems on some Miata machines
#if defined(_ALPHA_)
                ASSERTDD(pP2dma->lSharedDMABufferSize<=0x2000,
                         "DMA Buffer too big for alpha, fix constants!");
#endif
                if (pP2dma->lSharedDMABufferSize < DMACMDMINSIZE)
                {
                    DISPDBG((0,"allocated %ld bytes for DMA, not enough! No DMA!", 
                             pP2dma->lSharedDMABufferSize));

                    FreeDMABuffer(  pP2dma->hDriver, 
                                    pP2dma->pSharedDMABuffer);

                    pP2dma->pSharedDMABuffer = NULL;
                }
            }
            else
            {
                DISPDBG((0,"couldn't allocate memory for DMA"));
                pP2dma->pSharedDMABuffer = NULL;
            }
        }

        // Make sure we have a shared DMA buffer
        if (pP2dma->pSharedDMABuffer == NULL)
        {
            bUseDMA=FALSE;
        }
        else
        {
            // we always do "ULONG" arithmetics in the DMA routines
            pP2dma->lDMABufferSize=pP2dma->lSharedDMABufferSize/sizeof(ULONG);

            pP2dma->ICB.ulControl=0;

            pP2dma->ICB.pDMABufferStart = pP2dma->pSharedDMABuffer;
            pP2dma->ICB.pDMAActualBufferEnd = 
            pP2dma->ICB.pDMABufferEnd = 
                pP2dma->ICB.pDMABufferStart+
                pP2dma->lDMABufferSize;

            pP2dma->ICB.pDMAWriteEnd =
                pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=
            pP2dma->ICB.pDMANextStart=
            pP2dma->ICB.pDMAWritePos =
                pP2dma->ICB.pDMABufferStart;


            // check if we get an interrupt...
            // clear the flags before we check for a DMA
            WRITE_CTRL_REG( PREG_ERRORFLAGS, 0xffffffffl);

            //
            // clear DMA, VSync and Error interrupt flags
            //
            WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_DMA|
                                           PREG_INTFLAGS_VS|
                                           PREG_INTFLAGS_ERROR);
            //
            //  enable DMA interrupts
            //
            WRITE_CTRL_REG( PREG_INTENABLE, PREG_INTFLAGS_DMA);

            BOOL bIRQsOk=FALSE;
            DWORD dwTimeOut=5;

            // send a small sequence and see if we get a response 
            // by the interrupt handler
            //
            pP2dma->bEnabled = TRUE;

            PULONG pTmp=ReserveDMAPtr(pP2dma,10);
            LD_INPUT_FIFO(__Permedia2TagDeltaMode, 0);
            LD_INPUT_FIFO(__Permedia2TagColorDDAMode, 0);
            LD_INPUT_FIFO(__Permedia2TagScissorMode, 0);
            LD_INPUT_FIFO(__Permedia2TagTextureColorMode, 0);
            LD_INPUT_FIFO(__Permedia2TagFogMode, 0);
            CommitDMAPtr(pP2dma,pTmp);
            vFlushDMAMP(pP2dma);

            pP2dma->bEnabled = FALSE;

            //
            //  The videoport IRQ service routine marks ulControl
            //  on a DMA Interrupt
            //
            while (!(pP2dma->ICB.ulControl & DMA_INTERRUPT_AVAILABLE))
            {
                // wait for some Vsyncs here, then continue
                // 
                if (READ_CTRL_REG( PREG_INTFLAGS) & PREG_INTFLAGS_VS)
                {
                    WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_VS);

                    if (--dwTimeOut==0) 
                        break;
                }
            } 

            // interrupt service is ok if the IRQ handler marked the flag
            //
            bIRQsOk=pP2dma->ICB.ulControl & DMA_INTERRUPT_AVAILABLE;

            if (!bIRQsOk)
            {
                // disable IRQs and go back to emulation...
                // 
                WRITE_CTRL_REG( PREG_INTENABLE, 0);
                bUseDMA=FALSE;

                pP2dma->lDMABufferSize=0;

                pP2dma->ICB.pDMAActualBufferEnd = 
                pP2dma->ICB.pDMAWriteEnd =
                pP2dma->ICB.pDMAPrevStart=
                pP2dma->ICB.pDMANextStart=
                pP2dma->ICB.pDMAWritePos = NULL;
                pP2dma->ICB.pDMABufferEnd = 
                pP2dma->ICB.pDMABufferStart=NULL;

                DISPDBG((0,"no interrupts available...no DMA available"));
            }
            else
            {
                // VS IRQs can be turned off for now.
                // but enable DMA and Error interrupts
                pP2dma->ulIntFlags=PREG_INTFLAGS_DMA|PREG_INTFLAGS_ERROR;
                WRITE_CTRL_REG(PREG_INTENABLE, pP2dma->ulIntFlags);
                WRITE_CTRL_REG(PREG_INTFLAGS, PREG_INTFLAGS_ERROR);

                DISPDBG((2,"allocated %ld bytes for DMA, interrupts ok", 
                    pP2dma->lDMABufferSize*4));
            }

        }

    }

    if (!bUseDMA)
    {
        // DMA didn't work, then try to allocate memory for DMA emulation
        pP2dma->pgfnFlushDMA= vFlushDMAEmulation;
        pP2dma->pgfnCheckEOB= vCheckForEOBEmulation;

        if (pP2dma->pEmulatedDMABuffer == NULL)
        {
            pP2dma->lEmulatedDMABufferSize=DMACMDMINSIZE;

            pP2dma->pEmulatedDMABuffer=
                AllocateEmulatedDMABuffer( pP2dma->hDriver,
                                           pP2dma->lEmulatedDMABufferSize,
                                           ALLOC_TAG);

            if (pP2dma->pEmulatedDMABuffer == NULL)
            {
                DISPDBG((0,"failed to run in DMA emulation mode"));
                return FALSE;
            }
        }

        DISPDBG((0,"running in DMA emulation mode"));

        pP2dma->bDMAEmulation=TRUE;

        pP2dma->lDMABufferSize = pP2dma->lEmulatedDMABufferSize/sizeof(ULONG);

        pP2dma->ICB.pDMABufferStart = pP2dma->pEmulatedDMABuffer;
        pP2dma->ICB.pDMAActualBufferEnd = 
        pP2dma->ICB.pDMABufferEnd = 
            pP2dma->ICB.pDMABufferStart+
            pP2dma->lDMABufferSize;

        pP2dma->ICB.pDMAWriteEnd = 
            pP2dma->ICB.pDMABufferEnd;
        pP2dma->ICB.pDMAPrevStart=
        pP2dma->ICB.pDMANextStart=
        pP2dma->ICB.pDMAWritePos = 
            pP2dma->ICB.pDMABufferStart;

    }

    pP2dma->bEnabled = TRUE;
    
    return TRUE;
}



//----------------------------------------------------------------------------
//
//  vSyncWithPermedia
//
//  Send a sync tag through the Permedia and make sure all pending reads and 
//  writes are flushed from the graphics pipeline. 
//
//  MUST be called before accessing the Frame Buffer directly
//
//----------------------------------------------------------------------------

VOID vSyncWithPermedia(P2DMA *pP2dma)
{ 
    PULONG pTmp;        // pointer for pTmp in macros

    ASSERTDD(pP2dma->bEnabled, "vSyncWithPermedia: not enabled");

    pTmp=ReserveDMAPtr(pP2dma,6);

    // let the filter tag walk through the whole core
    // by setting the filter mode to passthrough
    //
    LD_INPUT_FIFO(__Permedia2TagFilterMode, 0x400);
    LD_INPUT_FIFO(__Permedia2TagSync, 0L); 
    LD_INPUT_FIFO(__Permedia2TagFilterMode, 0x0); 

    CommitDMAPtr(pP2dma,pTmp);

    (pP2dma->pgfnFlushDMA)(pP2dma);

    vWaitDMAComplete(pP2dma);

    ULONG   ulSync; 

    //
    // now wait until the sync tag has walked through the
    // graphic core and shows up at the output
    //
    do { 
        if (lWaitOutputFifoReady(pP2dma)==0) break; 
        ulSync=READ_CTRL_REG(PREG_FIFOINTERFACE);
    } while (ulSync != __Permedia2TagSync); 

}


//----------------------------------------------------------------------------
//
//  vWaitDMAComplete
//
//  Flush the DMA Buffer and wait until all data is at least sent to the chip.
//  Does not wait until the graphics pipeline is idle.
//
//----------------------------------------------------------------------------

VOID vWaitDMAComplete(P2DMA *pP2dma)
{
    while ( READ_CTRL_REG(PREG_INDMACOUNT)!=0 || 
            pP2dma->ICB.pDMAWritePos!=pP2dma->ICB.pDMANextStart || 
            pP2dma->ICB.pDMAPrevStart!=pP2dma->ICB.pDMANextStart)
    {

        if (READ_CTRL_REG(PREG_INDMACOUNT)!=0) 
        {
            // stall for 1 us
            // we shouldn't access the P2 chip here too often, because
            // reading from the DMA register too often would stall an
            // ongoing DMA transfer. So we better wait for a microsecond.
            // Also we eat up less PCI bus bandwidth by polling only every
            // 1 microsecond.
            // 
            StallExecution( pP2dma->hDriver, 1);
        }
        (pP2dma->pgfnFlushDMA)(pP2dma);
    }

}


//----------------------------------------------------------------------------
//
//  vBlockLoadInputFifo
//
//  pP2dma-----shared 
//  uiTag------register tag to write the data to
//  pImage-----pointer to data
//  lWords-----number of pixels to transfer
//
//  download a block of data with lWords pixels
//  to register uiTag from buffer at pImage. The size of the source pixels
//  are DWORDS.
//
//----------------------------------------------------------------------------


VOID vBlockLoadInputFifo( P2DMA *pP2dma, ULONG uiTag, ULONG *pImage, LONG lWords)
{
    ASSERTDD(pP2dma->bEnabled, "vBlockLoadInputFifo: not enabled");
    
    while (lWords>0)
    {
        PULONG pTmp=ReserveDMAPtr(pP2dma,MAXINPUTFIFOLENGTH);
        LONG lBufferEntries=GetFreeEntries(pP2dma)-1;

        if (lWords < lBufferEntries)
        {
            lBufferEntries = lWords;
        }

        *pTmp++ = uiTag | ((lBufferEntries-1) << 16);

        lWords -= lBufferEntries;

        while (lBufferEntries--)
        {
            *pTmp++=*pImage++;
        }

        CommitDMAPtr(pP2dma,pTmp);
        (pP2dma->pgfnFlushDMA)(pP2dma);
    }
}


//----------------------------------------------------------------------------
//
//  lWaitOutputFifoReady
//
//  return---number of words ready in output fifo
//
//  Wait until some data appears at the output Fifo of the P2. Flush DMA 
//  if necessary. 
//
//----------------------------------------------------------------------------

LONG lWaitOutputFifoReady(P2DMA *pP2dma)
{
    ULONG    x=1000000L;    // equals a timeout of 1s
    ULONG   uiResult;
    while ((uiResult=READ_CTRL_REG(PREG_OUTFIFOWORDS)) == 0)
    {
        if (x-- == 0) 
        {
            // we will end up here if nothing shows up at the output
            // Usually a download operation did not provide the right
            // amount of data if we end up here
            ASSERTDD( FALSE, "chip output fifo timed out");

            break;
        }

        // Make sure we do not read from the control register too often
        // when waiting. Permanent reading from the chip can stall DMA
        // downloads
        if (READ_CTRL_REG(PREG_INDMACOUNT)!=0)
            StallExecution( pP2dma->hDriver, 1);  // stall 1us if DMA still busy
        else
            (pP2dma->pgfnFlushDMA)(pP2dma);  // make sure buffer is flushed

    }
    return uiResult;
}


//----------------------------------------------------------------------------
//
//  vFlushDMA
//
//      single processor version of FlushDMA
//
//  vFlushDMAMP
//
//      multiprocessor version of FlushDMA
//
//  vFlushDMAEmulation
//
//      buffer flush using DMA emulation, where the normal DMA doesn't work
//
//  This routine really kicks off DMAs and handles synchronization with the
//  miniport interrupt service routine.
//
//  several scenarios can happen:
//      1.) DMA is inactive, then just kick off the data currently in the 
//          buffer
//          a) WritePos > NextStart, kick off DMA
//          a) otherwise we wrap around, just flush to buffer end
//
//      2.) DMA still active, make sure interrupts are started and let
//          the interrupt handler 
//
//  The synchronization between this routine and the miniport is essential
//  for our DMA model to work on Multiprocessor machines. The display driver
//  is single threaded, but the miniport interrupt handler can be called 
//  any time and be processed by another CPU. For that reason we loop with 
//  InterlockedExchange until we get the lock. The interrupt handler behaves 
//  a bit different. Since we don't want an interrupt being stalled, it just
//  falls through doing nothing when it cannot get the lock, since then the
//  DMA start will be handled by the display driver anyway. 
//
//  For the single processor case InterlockedExchange needs not to be called.
//  A simple assignment instead of the lock is enough.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  VOID vFlushDMAMP()
//
//  multiprocessor safe version of FlushDMA. Its basically the same as the single
//  processor version, but we are calling here the expensive InterlockedExchange
//  functions to lock the shared memory section    
//
//----------------------------------------------------------------------------

VOID vFlushDMAMP(P2DMA *pP2dma)
{
    ASSERTDD(pP2dma->bEnabled, "vFlushDMAMP: not enabled");
    
    ASSERTDD(!pP2dma->bDMAEmulation, "FlushDMA called with DMA mode disabled");
    ASSERTDD(pP2dma->ICB.pDMAWritePos<=
        pP2dma->ICB.pDMABufferEnd,"Index exceeds buffer limit");
    ASSERTDD(pP2dma->ICB.pDMANextStart<=
        pP2dma->ICB.pDMABufferEnd,"NextStart exceeds buffer limit!");

    // lock the access to the shared memory section first
    while (InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,TRUE))
        ;
 
    // check if DMA channel is still busy, count is zero if not
    if (READ_CTRL_REG(PREG_INDMACOUNT)==0)
    {
        // this code is called frequently. To help the processors branch
        // prediction the most common case should be reached 
        // without a cond. jump

        if (pP2dma->ICB.pDMAWritePos>pP2dma->ICB.pDMANextStart)
        {
            // This is the most common case for DMA start
            // set Permedia 2 DMA unit to fire the DMA
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                           (pP2dma->ICB.liDMAPhysAddr.LowPart+
                            (pP2dma->ICB.pDMANextStart-
                             pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAWritePos-
                            pP2dma->ICB.pDMANextStart));

            // in this case we always continue to fill to buffer end,
            // iterate the other pointers
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMAWritePos;

            // free the shared memory lock
            InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

            return;

        } else if (pP2dma->ICB.pDMAWritePos<pP2dma->ICB.pDMANextStart)       
        {
            // wraparound case: the write pointer already wrapped around 
            // to the beginning and we finish up to the end of the buffer.
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                           (pP2dma->ICB.liDMAPhysAddr.LowPart+
                           (pP2dma->ICB.pDMANextStart-
                            pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAActualBufferEnd-
                            pP2dma->ICB.pDMANextStart));

            // reset buffer size back to full length for next round
            pP2dma->ICB.pDMAActualBufferEnd=pP2dma->ICB.pDMABufferEnd;
            
            // in this case we don't want the write pointer 
            // to catch up to last start...
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMANextStart-1;

            // iterate last and next start pointer:
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;

            // free the shared memory lock
            InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

            return;

        } else     // nothing to do
        {
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
        }

        // free the shared memory lock
        InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

        return;

    } else
    {
        // the index pointer has been passed to IRQ service routine, nothing more to do..
        // 

        // unlock shared section, 
        InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

        // now we are filling the DMA buffer faster than the hardware
        // can follow up and we want to make sure that the DMA channel
        // keeps being busy and start the interrupt handler
       
        WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_DMA);
        WRITE_CTRL_REG( PREG_INTENABLE, pP2dma->ulIntFlags );

        return;
    } 
}


//----------------------------------------------------------------------------
//
//  VOID vFlushDMA()
//
//  single processor version of FlushDMA.
//
//----------------------------------------------------------------------------

VOID vFlushDMA(P2DMA *pP2dma)
{
    ASSERTDD(pP2dma->bEnabled, "vFlushDMA: not enabled");
    ASSERTDD(!pP2dma->bDMAEmulation, "FlushDMA called with DMA mode disabled");
    ASSERTDD(pP2dma->ICB.pDMAWritePos<=
        pP2dma->ICB.pDMABufferEnd,"Index exceeds buffer limit");
    ASSERTDD(pP2dma->ICB.pDMANextStart<=
        pP2dma->ICB.pDMABufferEnd,"NextStart exceeds buffer limit!");

    // lock the access to the shared memory section first
    pP2dma->ICB.ulICBLock=TRUE;
 
    // check if DMA channel is still busy, count is zero if not
    if (READ_CTRL_REG(PREG_INDMACOUNT)==0)
    {
        // this code is called frequently. To help the processors branch
        // prediction the most common case should be reached 
        // without a cond. jump

        if (pP2dma->ICB.pDMAWritePos>pP2dma->ICB.pDMANextStart)
        {
            // This is the most common case for DMA start
            // set Permedia 2 DMA unit to fire the DMA
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                            (pP2dma->ICB.liDMAPhysAddr.LowPart+
                             (pP2dma->ICB.pDMANextStart-
                              pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAWritePos-
                            pP2dma->ICB.pDMANextStart));

            // in this case we always continue to fill to buffer end,
            // iterate the other pointers
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMAWritePos;

            // free the shared memory lock
            pP2dma->ICB.ulICBLock=FALSE;

            return;

        } else if (pP2dma->ICB.pDMAWritePos<pP2dma->ICB.pDMANextStart)       
        {
            // wraparound case: the write pointer already wrapped around 
            // to the beginning and we finish up to the end of the buffer.
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                           (pP2dma->ICB.liDMAPhysAddr.LowPart+
                           (pP2dma->ICB.pDMANextStart-
                            pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAActualBufferEnd-
                            pP2dma->ICB.pDMANextStart));

            // reset buffer size back to full length for next round
            pP2dma->ICB.pDMAActualBufferEnd=pP2dma->ICB.pDMABufferEnd;
            
            // in this case we don't want the write pointer 
            // to catch up to last start...
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMANextStart-1;

            // iterate last and next start pointer:
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;

            // free the shared memory lock
            pP2dma->ICB.ulICBLock=FALSE;

            return;

        } else     // nothing to do
        {
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
        }

        // free the shared memory lock
        pP2dma->ICB.ulICBLock=FALSE;

        return;

    } else
    {
        // the index pointer has been passed to IRQ service routine, nothing more to do..
        // 

        // unlock shared section, 
        pP2dma->ICB.ulICBLock=FALSE;

        // now we are filling the DMA buffer faster than the hardware
        // can follow up and we want to make sure that the DMA channel
        // keeps being busy and start the interrupt handler
       
        WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_DMA);
        WRITE_CTRL_REG( PREG_INTENABLE, pP2dma->ulIntFlags );

        return;
    } 
}


//----------------------------------------------------------------------------
// 
//  vFlushDMAEmulation
//
//  this version of FlushDMA emulates the DMA copy and 
//  lets the CPU copy the data
//
//----------------------------------------------------------------------------

VOID vFlushDMAEmulation(P2DMA *pP2dma)
{
    ASSERTDD(pP2dma->bEnabled, "vFlushDMAEmulation: not enabled");
    DISPDBG((10,"Emu::FlushDMA: Write: %04lx Next: %04lx Prev: %04lx End: %04lx",
        pP2dma->ICB.pDMAWritePos, pP2dma->ICB.pDMANextStart,
        pP2dma->ICB.pDMAPrevStart, pP2dma->ICB.pDMABufferEnd));
    ASSERTDD(pP2dma->bDMAEmulation, "FlushDMA called with DMA mode disabled");

    ULONG *pData=pP2dma->ICB.pDMABufferStart;
    ULONG *pDst;
    LONG   lWords=(LONG)(pP2dma->ICB.pDMAWritePos-pP2dma->ICB.pDMABufferStart);

    while (lWords > 0)
    {
        LONG lFifoSpace=(LONG)READ_CTRL_REG(PREG_INFIFOSPACE);
        if (lWords<lFifoSpace) lFifoSpace=lWords;
        lWords -= lFifoSpace;
        pDst = pP2dma->pGPFifo;
        while (lFifoSpace--)
        {
            WRITE_REGISTER_ULONG(pDst++,*pData++); 
            MEMORY_BARRIER();
        }
    }    

    pP2dma->ICB.pDMAWritePos=pP2dma->ICB.pDMANextStart=
        pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMABufferStart;
    pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
}

//----------------------------------------------------------------------------
//
//  bDrawEngineBusy
//
//  check if P2 is still busy drawing. 
//
//  return----  TRUE  P2 is still busy
//              FALSE P2 has finished drawing and is not busy anymore
//
//----------------------------------------------------------------------------

BOOL bDrawEngineBusy(P2DMA *pP2dma)
{
    if (READ_CTRL_REG(PREG_INDMACOUNT)!=0) return TRUE;   

    if (READ_CTRL_REG(PREG_FIFODISCON) & PREG_FIFODISCON_GPACTIVE)
    {
        return TRUE;
    }

    return FALSE;
}



//----------------------------------------------------------------------------
//
//  bInVerticalRetrace
//
//  Return----- TRUE if beam position is within current vertical sync.
//              FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL bInVerticalRetrace(PPDev ppdev)
{
    return P2_READ_CTRL_REG(PREG_LINECOUNT) < P2_READ_CTRL_REG(PREG_VBEND);
}

//----------------------------------------------------------------------------
//
//  lCurrentLine
//
//  returns current line of beam on display
//
//----------------------------------------------------------------------------

LONG lCurrentLine(PPDev ppdev)
{
    LONG lScanline=P2_READ_CTRL_REG(PREG_LINECOUNT)-P2_READ_CTRL_REG(PREG_VBEND);
    if (lScanline<0) return 0;
    return lScanline;
}

//----------------------------------------------------------------------------
//
//  vCheckFOREOB (End of Buffer)
//
//  Check if buffer end would be overrun and adjust actual buffer size.
//  The buffer size will be restored when the DMA handler passes the wrap 
//  around.
//
//----------------------------------------------------------------------------

VOID vCheckForEOBEmulation( P2DMA *pP2dma, LONG lEntries)
{
    vFlushDMAEmulation(pP2dma);
}

//
//  multiprocessor safe version of vCheckForEOB
//

VOID vCheckForEOBMP( P2DMA *pP2dma, LONG lEntries)
{
    // check for overrun condition over the buffer end:
    // if we would exceed the current buffer size, 
    // LastStart has already wrapped around (LastStart<=writepos)
    // but is not at the wraparound position
    // and the buffer size was already reset to the full size

    if (pP2dma->ICB.pDMAWritePos+lEntries >= pP2dma->ICB.pDMABufferEnd && 
        pP2dma->ICB.pDMAPrevStart<=pP2dma->ICB.pDMAWritePos &&            
        pP2dma->ICB.pDMAPrevStart!=pP2dma->ICB.pDMABufferStart)   
    {
        DISPDBG((10,"wrap condition before: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));

        while (InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,TRUE))
            ;

        if (pP2dma->ICB.pDMAWritePos==pP2dma->ICB.pDMANextStart)
        {
            // special case one:
            // NextStart equals LastStart, so we just reset Index and Next
            // to the buffer start and see if we have enough space
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;
        } else
        {
            // index exceeds buffer end on the next block, but there is
            // a DMA pending to the current position of Index. Set Buffer
            // end temporarily to the current index.
            pP2dma->ICB.pDMAActualBufferEnd = pP2dma->ICB.pDMAWritePos; 
        }

        // wrap index around and see if there are enought free entries
        pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMAPrevStart-1;
        pP2dma->ICB.pDMAWritePos=pP2dma->ICB.pDMABufferStart;

        InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

        DISPDBG((10,"wrap condition after: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));
    }
    vFlushDMAMP(pP2dma);
}

VOID vCheckForEOB( P2DMA *pP2dma, LONG lEntries)
{
    // check for overrun condition over the buffer end:
    // if we would exceed the current buffer size, 
    // LastStart has already wrapped around (LastStart<=writepos)
    // but is not at the wraparound position
    // and the buffer size was already reset to the full size

    if (pP2dma->ICB.pDMAWritePos+lEntries >= pP2dma->ICB.pDMABufferEnd && 
        pP2dma->ICB.pDMAPrevStart<=pP2dma->ICB.pDMAWritePos &&            
        pP2dma->ICB.pDMAPrevStart!=pP2dma->ICB.pDMABufferStart)   
    {
        DISPDBG((10,"wrap condition before: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));

        pP2dma->ICB.ulICBLock=TRUE;

        if (pP2dma->ICB.pDMAWritePos==pP2dma->ICB.pDMANextStart)
        {
            // special case one:
            // NextStart equals LastStart, so we just reset Index and Next
            // to the buffer start and see if we have enough space
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;
        } else
        {
            // index exceeds buffer end on the next block, but there is
            // a DMA pending to the current position of Index. Set Buffer
            // end temporarily to the current index.
            pP2dma->ICB.pDMAActualBufferEnd = pP2dma->ICB.pDMAWritePos; 
        }

        // wrap index around and see if there are enought free entries
        pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMAPrevStart-1;
        pP2dma->ICB.pDMAWritePos=pP2dma->ICB.pDMABufferStart;

        pP2dma->ICB.ulICBLock=FALSE;

        DISPDBG((10,"wrap condition after: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));
    }
    vFlushDMA(pP2dma);
}

#if DBG

//----------------------------------------------------------------------------
//
//  ReserveDMAPtr
//
//  return a pointer to current position in DMA buffer. The function guarantees
//  that there are at least lEntries available in the buffer.
//  Otherwise the caller can ask GetFreeEntries and adjust the download to 
//  batch more entries. The caller MUST call CommitDMAPtr after a call to
//  to ReserveDMAPtr to readjust the Index pointer.
//
//----------------------------------------------------------------------------

ULONG *ReserveDMAPtr(P2DMA *pP2dma, const LONG lEntries)
{
    ASSERTDD(pP2dma->bEnabled, "ReserveDMAPtr: not enabled");
    ASSERTDD(pP2dma->lDBGState==0,
        "ReserveDMAPtr called, but previous called was not closed");
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ASSERTDD(pP2dma->ppdev != NULL, "ReserveDMAPtr: pP2dma->ppdev = NULL");
#endif
    ASSERTLOCK(pP2dma->ppdev, ReserveDMAPtr);
//@@END_DDKSPLIT

    pP2dma->lDBGState=2;

    while (pP2dma->ICB.pDMAWritePos+lEntries>=
           pP2dma->ICB.pDMAWriteEnd)
    {
        (*pP2dma->pgfnCheckEOB)(pP2dma,lEntries);
    }   

    if (lEntries<MAXINPUTFIFOLENGTH)
        pP2dma->pDBGReservedEntries=
            (ULONG *)(lEntries+pP2dma->ICB.pDMAWritePos);
    else
        pP2dma->pDBGReservedEntries=NULL;

    return (ULONG *)pP2dma->ICB.pDMAWritePos;  
}


//----------------------------------------------------------------------------
//
//  CommitDMAPtr
//
//  pDMAPtr----DMA buffer address to which the caller has written to.
//
//  Readjust write pointer after being reserved by ReserveDMAPtr. 
//  By committing the pointer a DMA to the committed position could already
//  be started by interrupt handler!
//
//----------------------------------------------------------------------------

VOID CommitDMAPtr(P2DMA *pP2dma,ULONG *pDMAPtr)
{
    ASSERTDD(pP2dma->bEnabled, "CommitDMAPtr: not enabled");
    ASSERTDD(pP2